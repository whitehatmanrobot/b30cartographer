                  4:4 /* RWIVF */
NV_PGRAPH_Y_MISC_RANGE_0                TEXTEQU         <4:4>
;  RWI-V 
;  2042 : #define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_RANGE_0_0              EQU             000000000h
;  RWIVF 
;  2043 : #define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
NV_PGRAPH_Y_MISC_RANGE_1                TEXTEQU         <5:5>
;  RWI-V 
;  2044 : #define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_RANGE_1_0              EQU             000000000h
;  RWIVF 
;  2045 : #define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
NV_PGRAPH_Y_MISC_RANGE_2                TEXTEQU         <6:6>
;  RWI-V 
;  2046 : #define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_RANGE_2_0              EQU             000000000h
;  RWIVF 
;  2047 : #define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
NV_PGRAPH_Y_MISC_RANGE_3                TEXTEQU         <7:7>
;  RWI-V 
;  2048 : #define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
NV_PGRAPH_Y_MISC_RANGE_3_0              EQU             000000000h
;  RWXVF 
;  2049 : #define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
NV_PGRAPH_Y_MISC_ADDER_OUTPUT           TEXTEQU         <29:28>
;  RW--V 
;  2050 : #define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0              EQU             000000000h
;  RW--V 
;  2051 : #define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0              EQU             000000001h
;  RW--V 
;  2052 : #define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0              EQU             000000002h
;  RW-4R 
;  2053 : #define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
NV_PGRAPH_ABS_UCLIP_XMIN                EQU             00040053ch
;  RWXSF 
;  2054 : #define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIP_XMIN_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2055 : #define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
NV_PGRAPH_ABS_UCLIP_XMAX                EQU             000400544h
;  RWXSF 
;  2056 : #define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIP_XMAX_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2057 : #define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
NV_PGRAPH_ABS_UCLIP_YMIN                EQU             000400540h
;  RWXSF 
;  2058 : #define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIP_YMIN_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2059 : #define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
NV_PGRAPH_ABS_UCLIP_YMAX                EQU             000400548h
;  RWXSF 
;  2060 : #define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIP_YMAX_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2061 : #define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
NV_PGRAPH_ABS_UCLIPA_XMIN               EQU             000400560h
;  RWXSF 
;  2062 : #define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE         TEXTEQU         <17:0>
;  RW-4R 
;  2063 : #define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
NV_PGRAPH_ABS_UCLIPA_XMAX               EQU             000400568h
;  RWXSF 
;  2064 : #define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE         TEXTEQU         <17:0>
;  RW-4R 
;  2065 : #define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
NV_PGRAPH_ABS_UCLIPA_YMIN               EQU             000400564h
;  RWXSF 
;  2066 : #define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE         TEXTEQU         <17:0>
;  RW-4R 
;  2067 : #define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
NV_PGRAPH_ABS_UCLIPA_YMAX               EQU             00040056ch
;  RWXSF 
;  2068 : #define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE         TEXTEQU         <17:0>
;  RW-4R 
;  2069 : #define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
NV_PGRAPH_SOURCE_COLOR          EQU             00040050ch
;  RWXVF 
;  2070 : #define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
NV_PGRAPH_SOURCE_COLOR_VALUE            TEXTEQU         <31:0>
;  RW-4R 
;  2071 : #define NV_PGRAPH_EXCEPTIONS                             0x00400508 /* RW-4R */
NV_PGRAPH_EXCEPTIONS            EQU             000400508h
;  RWIVF 
;  2072 : #define NV_PGRAPH_EXCEPTIONS_VALID                             27:0 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_VALID              TEXTEQU         <27:0>
;  RWI-V 
;  2073 : #define NV_PGRAPH_EXCEPTIONS_VALID_0                     0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_VALID_0            EQU             000000000h
;  RWIVF 
;  2074 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MIN                         28:28 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_CLIP_MIN           TEXTEQU         <28:28>
;  RWI-V 
;  2075 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR           0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR          EQU             000000000h
;  RW--V 
;  2076 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY               0x00000001 /* RW--V */
NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY              EQU             000000001h
;  RWIVF 
;  2077 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN                        29:29 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_CLIPA_MIN          TEXTEQU         <29:29>
;  RWI-V 
;  2078 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR          0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR         EQU             000000000h
;  RW--V 
;  2079 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY              0x00000001 /* RW--V */
NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY             EQU             000000001h
;  RWIVF 
;  2080 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MAX                         30:30 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_CLIP_MAX           TEXTEQU         <30:30>
;  RWI-V 
;  2081 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR           0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR          EQU             000000000h
;  RW--V 
;  2082 : #define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY               0x00000001 /* RW--V */
NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY              EQU             000000001h
;  RWIVF 
;  2083 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX                        31:31 /* RWIVF */
NV_PGRAPH_EXCEPTIONS_CLIPA_MAX          TEXTEQU         <31:31>
;  RWI-V 
;  2084 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR          0x00000000 /* RWI-V */
NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR         EQU             000000000h
;  RW--V 
;  2085 : #define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY              0x00000001 /* RW--V */
NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY             EQU             000000001h
;  RW-4R 
;  2086 : #define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
NV_PGRAPH_ABS_ICLIP_XMAX                EQU             000400534h
;  RWXSF 
;  2087 : #define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_ICLIP_XMAX_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2088 : #define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
NV_PGRAPH_ABS_ICLIP_YMAX                EQU             000400538h
;  RWXSF 
;  2089 : #define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
NV_PGRAPH_ABS_ICLIP_YMAX_VALUE          TEXTEQU         <17:0>
;  RW-4R 
;  2090 : #define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
NV_PGRAPH_CLIPX_0               EQU             000400524h
;  RWIVF 
;  2091 : #define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP0_MIN             TEXTEQU         <1:0>
;  RW--V 
;  2092 : #define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT          EQU             000000000h
;  RWI-V 
;  2093 : #define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT          EQU             000000001h
;  RW--V 
;  2094 : #define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2095 : #define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP0_MAX             TEXTEQU         <3:2>
;  RW--V 
;  2096 : #define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT          EQU             000000000h
;  RWI-V 
;  2097 : #define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT          EQU             000000001h
;  RW--V 
;  2098 : #define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2099 : #define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP1_MIN             TEXTEQU         <5:4>
;  RW--V 
;  2100 : #define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT          EQU             000000000h
;  RWI-V 
;  2101 : #define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT          EQU             000000001h
;  RW--V 
;  2102 : #define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2103 : #define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP1_MAX             TEXTEQU         <7:6>
;  RW--V 
;  2104 : #define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT          EQU             000000000h
;  RWI-V 
;  2105 : #define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT          EQU             000000001h
;  RW--V 
;  2106 : #define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2107 : #define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP2_MIN             TEXTEQU         <9:8>
;  RW--V 
;  2108 : #define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT          EQU             000000000h
;  RWI-V 
;  2109 : #define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT          EQU             000000001h
;  RW--V 
;  2110 : #define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2111 : #define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP2_MAX             TEXTEQU         <11:10>
;  RW--V 
;  2112 : #define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT          EQU             000000000h
;  RWI-V 
;  2113 : #define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT          EQU             000000001h
;  RW--V 
;  2114 : #define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2115 : #define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP3_MIN             TEXTEQU         <13:12>
;  RW--V 
;  2116 : #define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT          EQU             000000000h
;  RWI-V 
;  2117 : #define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT          EQU             000000001h
;  RW--V 
;  2118 : #define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2119 : #define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP3_MAX             TEXTEQU         <15:14>
;  RW--V 
;  2120 : #define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT          EQU             000000000h
;  RWI-V 
;  2121 : #define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT          EQU             000000001h
;  RW--V 
;  2122 : #define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2123 : #define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP4_MIN             TEXTEQU         <17:16>
;  RW--V 
;  2124 : #define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT          EQU             000000000h
;  RWI-V 
;  2125 : #define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT          EQU             000000001h
;  RW--V 
;  2126 : #define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2127 : #define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP4_MAX             TEXTEQU         <19:18>
;  RW--V 
;  2128 : #define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT          EQU             000000000h
;  RWI-V 
;  2129 : #define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT          EQU             000000001h
;  RW--V 
;  2130 : #define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2131 : #define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP5_MIN             TEXTEQU         <21:20>
;  RW--V 
;  2132 : #define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT          EQU             000000000h
;  RWI-V 
;  2133 : #define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT          EQU             000000001h
;  RW--V 
;  2134 : #define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2135 : #define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP5_MAX             TEXTEQU         <23:22>
;  RW--V 
;  2136 : #define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT          EQU             000000000h
;  RWI-V 
;  2137 : #define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT          EQU             000000001h
;  RW--V 
;  2138 : #define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2139 : #define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP6_MIN             TEXTEQU         <25:24>
;  RW--V 
;  2140 : #define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT          EQU             000000000h
;  RWI-V 
;  2141 : #define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT          EQU             000000001h
;  RW--V 
;  2142 : #define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2143 : #define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP6_MAX             TEXTEQU         <27:26>
;  RW--V 
;  2144 : #define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT          EQU             000000000h
;  RWI-V 
;  2145 : #define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT          EQU             000000001h
;  RW--V 
;  2146 : #define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2147 : #define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP7_MIN             TEXTEQU         <29:28>
;  RW--V 
;  2148 : #define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT          EQU             000000000h
;  RWI-V 
;  2149 : #define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT          EQU             000000001h
;  RW--V 
;  2150 : #define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2151 : #define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWIVF */
NV_PGRAPH_CLIPX_0_CLIP7_MAX             TEXTEQU         <31:30>
;  RW--V 
;  2152 : #define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT          EQU             000000000h
;  RWI-V 
;  2153 : #define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT          EQU             000000001h
;  RW--V 
;  2154 : #define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ          EQU             000000002h
;  RW-4R 
;  2155 : #define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
NV_PGRAPH_CLIPX_1               EQU             000400528h
;  RWIVF 
;  2156 : #define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP8_MIN             TEXTEQU         <1:0>
;  RW--V 
;  2157 : #define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT          EQU             000000000h
;  RWI-V 
;  2158 : #define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT          EQU             000000001h
;  RW--V 
;  2159 : #define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2160 : #define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP8_MAX             TEXTEQU         <3:2>
;  RW--V 
;  2161 : #define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT          EQU             000000000h
;  RWI-V 
;  2162 : #define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT          EQU             000000001h
;  RW--V 
;  2163 : #define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2164 : #define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP9_MIN             TEXTEQU         <5:4>
;  RW--V 
;  2165 : #define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT          EQU             000000000h
;  RWI-V 
;  2166 : #define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT          EQU             000000001h
;  RW--V 
;  2167 : #define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2168 : #define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP9_MAX             TEXTEQU         <7:6>
;  RW--V 
;  2169 : #define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT          EQU             000000000h
;  RWI-V 
;  2170 : #define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT          EQU             000000001h
;  RW--V 
;  2171 : #define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2172 : #define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP10_MIN            TEXTEQU         <9:8>
;  RW--V 
;  2173 : #define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT         EQU             000000000h
;  RWI-V 
;  2174 : #define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT         EQU             000000001h
;  RW--V 
;  2175 : #define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2176 : #define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP10_MAX            TEXTEQU         <11:10>
;  RW--V 
;  2177 : #define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT         EQU             000000000h
;  RWI-V 
;  2178 : #define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT         EQU             000000001h
;  RW--V 
;  2179 : #define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2180 : #define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP11_MIN            TEXTEQU         <13:12>
;  RW--V 
;  2181 : #define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT         EQU             000000000h
;  RWI-V 
;  2182 : #define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT         EQU             000000001h
;  RW--V 
;  2183 : #define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ          EQU             000000002h
;  RWIVF 
;  2184 : #define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP11_MAX            TEXTEQU         <15:14>
;  RW--V 
;  2185 : #define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT         EQU             000000000h
;  RWI-V 
;  2186 : #define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT         EQU             000000001h
;  RW--V 
;  2187 : #define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2188 : #define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP12_MIN            TEXTEQU         <17:16>
;  RW--V 
;  2189 : #define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT         EQU             000000000h
;  RWI-V 
;  2190 : #define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT         EQU             000000001h
;  RW--V 
;  2191 : #define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2192 : #define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP12_MAX            TEXTEQU         <19:18>
;  RW--V 
;  2193 : #define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT         EQU             000000000h
;  RWI-V 
;  2194 : #define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT         EQU             000000001h
;  RW--V 
;  2195 : #define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2196 : #define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP13_MIN            TEXTEQU         <21:20>
;  RW--V 
;  2197 : #define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT         EQU             000000000h
;  RWI-V 
;  2198 : #define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT         EQU             000000001h
;  RW--V 
;  2199 : #define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2200 : #define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP13_MAX            TEXTEQU         <23:22>
;  RW--V 
;  2201 : #define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT         EQU             000000000h
;  RWI-V 
;  2202 : #define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT         EQU             000000001h
;  RW--V 
;  2203 : #define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2204 : #define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP14_MIN            TEXTEQU         <25:24>
;  RW--V 
;  2205 : #define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT         EQU             000000000h
;  RWI-V 
;  2206 : #define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT         EQU             000000001h
;  RW--V 
;  2207 : #define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2208 : #define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP14_MAX            TEXTEQU         <27:26>
;  RW--V 
;  2209 : #define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT         EQU             000000000h
;  RWI-V 
;  2210 : #define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT         EQU             000000001h
;  RW--V 
;  2211 : #define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2212 : #define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP15_MIN            TEXTEQU         <29:28>
;  RW--V 
;  2213 : #define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT         EQU             000000000h
;  RWI-V 
;  2214 : #define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT         EQU             000000001h
;  RW--V 
;  2215 : #define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2216 : #define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWIVF */
NV_PGRAPH_CLIPX_1_CLIP15_MAX            TEXTEQU         <31:30>
;  RW--V 
;  2217 : #define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT         EQU             000000000h
;  RWI-V 
;  2218 : #define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT         EQU             000000001h
;  RW--V 
;  2219 : #define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ         EQU             000000002h
;  RW-4R 
;  2220 : #define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
NV_PGRAPH_CLIPY_0               EQU             00040052ch
;  RWIVF 
;  2221 : #define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP0_MIN             TEXTEQU         <1:0>
;  RW--V 
;  2222 : #define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT          EQU             000000000h
;  RWI-V 
;  2223 : #define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT          EQU             000000001h
;  RW--V 
;  2224 : #define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2225 : #define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP0_MAX             TEXTEQU         <3:2>
;  RW--V 
;  2226 : #define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT          EQU             000000000h
;  RWI-V 
;  2227 : #define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT          EQU             000000001h
;  RW--V 
;  2228 : #define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2229 : #define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP1_MIN             TEXTEQU         <5:4>
;  RW--V 
;  2230 : #define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT          EQU             000000000h
;  RWI-V 
;  2231 : #define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT          EQU             000000001h
;  RW--V 
;  2232 : #define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2233 : #define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP1_MAX             TEXTEQU         <7:6>
;  RW--V 
;  2234 : #define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT          EQU             000000000h
;  RWI-V 
;  2235 : #define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT          EQU             000000001h
;  RW--V 
;  2236 : #define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2237 : #define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP2_MIN             TEXTEQU         <9:8>
;  RW--V 
;  2238 : #define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT          EQU             000000000h
;  RWI-V 
;  2239 : #define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT          EQU             000000001h
;  RW--V 
;  2240 : #define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2241 : #define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP2_MAX             TEXTEQU         <11:10>
;  RW--V 
;  2242 : #define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT          EQU             000000000h
;  RWI-V 
;  2243 : #define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT          EQU             000000001h
;  RW--V 
;  2244 : #define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2245 : #define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP3_MIN             TEXTEQU         <13:12>
;  RW--V 
;  2246 : #define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT          EQU             000000000h
;  RWI-V 
;  2247 : #define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT          EQU             000000001h
;  RW--V 
;  2248 : #define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2249 : #define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP3_MAX             TEXTEQU         <15:14>
;  RW--V 
;  2250 : #define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT          EQU             000000000h
;  RWI-V 
;  2251 : #define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT          EQU             000000001h
;  RW--V 
;  2252 : #define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2253 : #define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP4_MIN             TEXTEQU         <17:16>
;  RW--V 
;  2254 : #define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT          EQU             000000000h
;  RWI-V 
;  2255 : #define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT          EQU             000000001h
;  RW--V 
;  2256 : #define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2257 : #define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP4_MAX             TEXTEQU         <19:18>
;  RW--V 
;  2258 : #define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT          EQU             000000000h
;  RWI-V 
;  2259 : #define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT          EQU             000000001h
;  RW--V 
;  2260 : #define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2261 : #define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP5_MIN             TEXTEQU         <21:20>
;  RW--V 
;  2262 : #define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT          EQU             000000000h
;  RWI-V 
;  2263 : #define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT          EQU             000000001h
;  RW--V 
;  2264 : #define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2265 : #define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP5_MAX             TEXTEQU         <23:22>
;  RW--V 
;  2266 : #define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT          EQU             000000000h
;  RWI-V 
;  2267 : #define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT          EQU             000000001h
;  RW--V 
;  2268 : #define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2269 : #define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP6_MIN             TEXTEQU         <25:24>
;  RW--V 
;  2270 : #define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT          EQU             000000000h
;  RWI-V 
;  2271 : #define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT          EQU             000000001h
;  RW--V 
;  2272 : #define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2273 : #define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP6_MAX             TEXTEQU         <27:26>
;  RW--V 
;  2274 : #define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT          EQU             000000000h
;  RWI-V 
;  2275 : #define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT          EQU             000000001h
;  RW--V 
;  2276 : #define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2277 : #define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP7_MIN             TEXTEQU         <29:28>
;  RW--V 
;  2278 : #define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT          EQU             000000000h
;  RWI-V 
;  2279 : #define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT          EQU             000000001h
;  RW--V 
;  2280 : #define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2281 : #define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWIVF */
NV_PGRAPH_CLIPY_0_CLIP7_MAX             TEXTEQU         <31:30>
;  RW--V 
;  2282 : #define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT          EQU             000000000h
;  RWI-V 
;  2283 : #define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT          EQU             000000001h
;  RW--V 
;  2284 : #define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ          EQU             000000002h
;  RW-4R 
;  2285 : #define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
NV_PGRAPH_CLIPY_1               EQU             000400530h
;  RWIVF 
;  2286 : #define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP8_MIN             TEXTEQU         <1:0>
;  RW--V 
;  2287 : #define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT          EQU             000000000h
;  RWI-V 
;  2288 : #define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT          EQU             000000001h
;  RW--V 
;  2289 : #define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2290 : #define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP8_MAX             TEXTEQU         <3:2>
;  RW--V 
;  2291 : #define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT          EQU             000000000h
;  RWI-V 
;  2292 : #define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT          EQU             000000001h
;  RW--V 
;  2293 : #define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2294 : #define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP9_MIN             TEXTEQU         <5:4>
;  RW--V 
;  2295 : #define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT          EQU             000000000h
;  RWI-V 
;  2296 : #define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT          EQU             000000001h
;  RW--V 
;  2297 : #define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ          EQU             000000002h
;  RWIVF 
;  2298 : #define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP9_MAX             TEXTEQU         <7:6>
;  RW--V 
;  2299 : #define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT          EQU             000000000h
;  RWI-V 
;  2300 : #define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT          EQU             000000001h
;  RW--V 
;  2301 : #define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ          EQU             000000002h
;  RWIVF 
;  2302 : #define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP10_MIN            TEXTEQU         <9:8>
;  RW--V 
;  2303 : #define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT         EQU             000000000h
;  RWI-V 
;  2304 : #define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT         EQU             000000001h
;  RW--V 
;  2305 : #define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2306 : #define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP10_MAX            TEXTEQU         <11:10>
;  RW--V 
;  2307 : #define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT         EQU             000000000h
;  RWI-V 
;  2308 : #define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT         EQU             000000001h
;  RW--V 
;  2309 : #define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2310 : #define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP11_MIN            TEXTEQU         <13:12>
;  RW--V 
;  2311 : #define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT         EQU             000000000h
;  RWI-V 
;  2312 : #define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT         EQU             000000001h
;  RW--V 
;  2313 : #define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ          EQU             000000002h
;  RWIVF 
;  2314 : #define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP11_MAX            TEXTEQU         <15:14>
;  RW--V 
;  2315 : #define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT         EQU             000000000h
;  RWI-V 
;  2316 : #define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT         EQU             000000001h
;  RW--V 
;  2317 : #define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2318 : #define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP12_MIN            TEXTEQU         <17:16>
;  RW--V 
;  2319 : #define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT         EQU             000000000h
;  RWI-V 
;  2320 : #define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT         EQU             000000001h
;  RW--V 
;  2321 : #define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2322 : #define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP12_MAX            TEXTEQU         <19:18>
;  RW--V 
;  2323 : #define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT         EQU             000000000h
;  RWI-V 
;  2324 : #define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT         EQU             000000001h
;  RW--V 
;  2325 : #define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2326 : #define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP13_MIN            TEXTEQU         <21:20>
;  RW--V 
;  2327 : #define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT         EQU             000000000h
;  RWI-V 
;  2328 : #define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT         EQU             000000001h
;  RW--V 
;  2329 : #define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2330 : #define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP13_MAX            TEXTEQU         <23:22>
;  RW--V 
;  2331 : #define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT         EQU             000000000h
;  RWI-V 
;  2332 : #define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT         EQU             000000001h
;  RW--V 
;  2333 : #define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2334 : #define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP14_MIN            TEXTEQU         <25:24>
;  RW--V 
;  2335 : #define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT         EQU             000000000h
;  RWI-V 
;  2336 : #define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT         EQU             000000001h
;  RW--V 
;  2337 : #define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2338 : #define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP14_MAX            TEXTEQU         <27:26>
;  RW--V 
;  2339 : #define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT         EQU             000000000h
;  RWI-V 
;  2340 : #define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT         EQU             000000001h
;  RW--V 
;  2341 : #define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ         EQU             000000002h
;  RWIVF 
;  2342 : #define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP15_MIN            TEXTEQU         <29:28>
;  RW--V 
;  2343 : #define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT         EQU             000000000h
;  RWI-V 
;  2344 : #define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT         EQU             000000001h
;  RW--V 
;  2345 : #define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ         EQU             000000002h
;  RWIVF 
;  2346 : #define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWIVF */
NV_PGRAPH_CLIPY_1_CLIP15_MAX            TEXTEQU         <31:30>
;  RW--V 
;  2347 : #define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT         EQU             000000000h
;  RWI-V 
;  2348 : #define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT         EQU             000000001h
;  RW--V 
;  2349 : #define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ         EQU             000000002h
;  RW-4R 
;  2350 : #define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
NV_PGRAPH_MISC24_0              EQU             000400510h
;  RWXSF 
;  2351 : #define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXSF */
NV_PGRAPH_MISC24_0_VALUE                TEXTEQU         <23:0>
;  RW-4R 
;  2352 : #define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
NV_PGRAPH_MISC24_1              EQU             000400570h
;  RWXSF 
;  2353 : #define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXSF */
NV_PGRAPH_MISC24_1_VALUE                TEXTEQU         <23:0>
;  RW-4R 
;  2354 : #define NV_PGRAPH_PASSTHRU                               0x0040054c /* RW-4R */
NV_PGRAPH_PASSTHRU              EQU             00040054ch
;  RWXSF 
;  2355 : #define NV_PGRAPH_PASSTHRU_VALUE                               23:0 /* RWXSF */
NV_PGRAPH_PASSTHRU_VALUE                TEXTEQU         <23:0>
;  RW-4A 
;        
;  2356 : #define NV_PGRAPH_ZFOG_RAM(i)                    (0x00400580+(i)*4) /* RW-4A */
;  2357 : #define NV_PGRAPH_ZFOG_RAM__SIZE_1                               16 /*       */
NV_PGRAPH_ZFOG_RAM__SIZE_1              EQU             16t
;  RWXUF 
;  2358 : #define NV_PGRAPH_ZFOG_RAM_ZETA                                15:0 /* RWXUF */
NV_PGRAPH_ZFOG_RAM_ZETA         TEXTEQU         <15:0>
;  RWXUF 
;  2359 : #define NV_PGRAPH_ZFOG_RAM_FOG                                23:16 /* RWXUF */
NV_PGRAPH_ZFOG_RAM_FOG          TEXTEQU         <23:16>
;  RW-4R 
;  2360 : #define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
NV_PGRAPH_D3D_XY                EQU             0004005c0h
;  RWXSF 
;  2361 : #define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
NV_PGRAPH_D3D_XY_X_VALUE                TEXTEQU         <15:0>
;  RWXSF 
;  2362 : #define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
NV_PGRAPH_D3D_XY_Y_VALUE                TEXTEQU         <31:16>
;  RW-4R 
;  2363 : #define NV_PGRAPH_D3D_UV                                 0x004005c4 /* RW-4R */
NV_PGRAPH_D3D_UV                EQU             0004005c4h
;  RWXSF 
;  2364 : #define NV_PGRAPH_D3D_UV_U_VALUE                               15:0 /* RWXSF */
NV_PGRAPH_D3D_UV_U_VALUE                TEXTEQU         <15:0>
;  RWXSF 
;  2365 : #define NV_PGRAPH_D3D_UV_V_VALUE                              31:16 /* RWXSF */
NV_PGRAPH_D3D_UV_V_VALUE                TEXTEQU         <31:16>
;  RW-4R 
;  2366 : #define NV_PGRAPH_D3D_ZETA                               0x004005c8 /* RW-4R */
NV_PGRAPH_D3D_ZETA              EQU             0004005c8h
;  RWXSF 
;  2367 : #define NV_PGRAPH_D3D_ZETA_VALUE                               15:0 /* RWXSF */
NV_PGRAPH_D3D_ZETA_VALUE                TEXTEQU         <15:0>
;  RW-4R 
;  2368 : #define NV_PGRAPH_D3D_RGB                                0x004005cc /* RW-4R */
NV_PGRAPH_D3D_RGB               EQU             0004005cch
;  RWXSF 
;  2369 : #define NV_PGRAPH_D3D_RGB_VALUE                                15:0 /* RWXSF */
NV_PGRAPH_D3D_RGB_VALUE         TEXTEQU         <15:0>
;  RW-4R 
;  2370 : #define NV_PGRAPH_D3D_FOG                                0x004005d0 /* RW-4R */
NV_PGRAPH_D3D_FOG               EQU             0004005d0h
;  RWXSF 
;  2371 : #define NV_PGRAPH_D3D_FOG_I0                                    3:0 /* RWXSF */
NV_PGRAPH_D3D_FOG_I0            TEXTEQU         <3:0>
;  RWXSF 
;  2372 : #define NV_PGRAPH_D3D_FOG_I1                                    7:4 /* RWXSF */
NV_PGRAPH_D3D_FOG_I1            TEXTEQU         <7:4>
;  RWXSF 
;  2373 : #define NV_PGRAPH_D3D_FOG_I2                                   11:8 /* RWXSF */
NV_PGRAPH_D3D_FOG_I2            TEXTEQU         <11:8>
;  RWXSF 
;  2374 : #define NV_PGRAPH_D3D_FOG_I3                                  15:12 /* RWXSF */
NV_PGRAPH_D3D_FOG_I3            TEXTEQU         <15:12>
;  RWXSF 
;  2375 : #define NV_PGRAPH_D3D_FOG_I4                                  19:16 /* RWXSF */
NV_PGRAPH_D3D_FOG_I4            TEXTEQU         <19:16>
;  RWXSF 
;  2376 : #define NV_PGRAPH_D3D_FOG_I5                                  23:20 /* RWXSF */
NV_PGRAPH_D3D_FOG_I5            TEXTEQU         <23:20>
;  RWXSF 
;  2377 : #define NV_PGRAPH_D3D_FOG_FOG_VALUE                           31:24 /* RWXSF */
NV_PGRAPH_D3D_FOG_FOG_VALUE             TEXTEQU         <31:24>
;  RW-4R 
;  2378 : #define NV_PGRAPH_D3D_M                                  0x004005d4 /* RW-4R */
NV_PGRAPH_D3D_M         EQU             0004005d4h
;  RWXSF 
;  2379 : #define NV_PGRAPH_D3D_M_VALUE                                  31:0 /* RWXSF */
NV_PGRAPH_D3D_M_VALUE           TEXTEQU         <31:0>
;  RW-4R 
;  2380 : #define NV_PGRAPH_DMA_INTR_0                             0x00401100 /* RW-4R */
NV_PGRAPH_DMA_INTR_0            EQU             000401100h
;  RWXVF 
;  2381 : #define NV_PGRAPH_DMA_INTR_0_INSTANCE                           0:0 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_INSTANCE           TEXTEQU         <0:0>
;  R---V 
;  2382 : #define NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING        0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING               EQU             000000000h
;  R---V 
;  2383 : #define NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING            0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING           EQU             000000001h
;  -W--V 
;  2384 : #define NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET              0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET             EQU             000000001h
;  RWXVF 
;  2385 : #define NV_PGRAPH_DMA_INTR_0_PRESENT                            4:4 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_PRESENT            TEXTEQU         <4:4>
;  R---V 
;  2386 : #define NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING         0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING                EQU             000000000h
;  R---V 
;  2387 : #define NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING             0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING            EQU             000000001h
;  -W--V 
;  2388 : #define NV_PGRAPH_DMA_INTR_0_PRESENT_RESET               0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_PRESENT_RESET              EQU             000000001h
;  RWXVF 
;  2389 : #define NV_PGRAPH_DMA_INTR_0_PROTECTION                         8:8 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_PROTECTION         TEXTEQU         <8:8>
;  R---V 
;  2390 : #define NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING      0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING             EQU             000000000h
;  R---V 
;  2391 : #define NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING          0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING         EQU             000000001h
;  -W--V 
;  2392 : #define NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET            0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET           EQU             000000001h
;  RWXVF 
;  2393 : #define NV_PGRAPH_DMA_INTR_0_LINEAR                           12:12 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_LINEAR             TEXTEQU         <12:12>
;  R---V 
;  2394 : #define NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING          0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING         EQU             000000000h
;  R---V 
;  2395 : #define NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING              0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING             EQU             000000001h
;  -W--V 
;  2396 : #define NV_PGRAPH_DMA_INTR_0_LINEAR_RESET                0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_LINEAR_RESET               EQU             000000001h
;  RWXVF 
;  2397 : #define NV_PGRAPH_DMA_INTR_0_NOTIFY                           16:16 /* RWXVF */
NV_PGRAPH_DMA_INTR_0_NOTIFY             TEXTEQU         <16:16>
;  R---V 
;  2398 : #define NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING          0x00000000 /* R---V */
NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING         EQU             000000000h
;  R---V 
;  2399 : #define NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING              0x00000001 /* R---V */
NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING             EQU             000000001h
;  -W--V 
;  2400 : #define NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET                0x00000001 /* -W--V */
NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET               EQU             000000001h
;  RW-4R 
;  2401 : #define NV_PGRAPH_DMA_INTR_EN_0                          0x00401140 /* RW-4R */
NV_PGRAPH_DMA_INTR_EN_0         EQU             000401140h
;  RWIVF 
;  2402 : #define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                        0:0 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                TEXTEQU         <0:0>
;  RWI-V 
;  2403 : #define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED        0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED               EQU             000000000h
;  RW--V 
;  2404 : #define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED         0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED                EQU             000000001h
;  RWIVF 
;  2405 : #define NV_PGRAPH_DMA_INTR_EN_0_PRESENT                         4:4 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_PRESENT         TEXTEQU         <4:4>
;  RWI-V 
;  2406 : #define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED         0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED                EQU             000000000h
;  RW--V 
;  2407 : #define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED          0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED         EQU             000000001h
;  RWIVF 
;  2408 : #define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION                      8:8 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_PROTECTION              TEXTEQU         <8:8>
;  RWI-V 
;  2409 : #define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED      0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED             EQU             000000000h
;  RW--V 
;  2410 : #define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED       0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED              EQU             000000001h
;  RWIVF 
;  2411 : #define NV_PGRAPH_DMA_INTR_EN_0_LINEAR                        12:12 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_LINEAR          TEXTEQU         <12:12>
;  RWI-V 
;  2412 : #define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED          0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED         EQU             000000000h
;  RW--V 
;  2413 : #define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED           0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED          EQU             000000001h
;  RWIVF 
;  2414 : #define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY                        16:16 /* RWIVF */
NV_PGRAPH_DMA_INTR_EN_0_NOTIFY          TEXTEQU         <16:16>
;  RWI-V 
;  2415 : #define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED          0x00000000 /* RWI-V */
NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED         EQU             000000000h
;  RW--V 
;  2416 : #define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED           0x00000001 /* RW--V */
NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED          EQU             000000001h
;  -W-4R 
;  2417 : #define NV_PGRAPH_DMA_ACCESS                             0x00401200 /* -W-4R */
NV_PGRAPH_DMA_ACCESS            EQU             000401200h
;  -W-VF 
;  2418 : #define NV_PGRAPH_DMA_PTE_ACCESS_PTE                            0:0 /* -W-VF */
NV_PGRAPH_DMA_PTE_ACCESS_PTE            TEXTEQU         <0:0>
;  -W--V 
;  2419 : #define NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE              0x00000001 /* -W--V */
NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE             EQU             000000001h
;  RW-4R 
;  2420 : #define NV_PGRAPH_DMA_CONTROL                            0x00401210 /* RW-4R */
NV_PGRAPH_DMA_CONTROL           EQU             000401210h
;  RWXUF 
;  2421 : #define NV_PGRAPH_DMA_CONTROL_ADJUST                           11:0 /* RWXUF */
NV_PGRAPH_DMA_CONTROL_ADJUST            TEXTEQU         <11:0>
;  RWXVF 
;  2422 : #define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                      16:16 /* RWXVF */
NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                TEXTEQU         <16:16>
;  RW--V 
;  2423 : #define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT     0x00000000 /* RW--V */
NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT            EQU             000000000h
;  RW--V 
;  2424 : #define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT         0x00000001 /* RW--V */
NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT                EQU             000000001h
;  RWXUF 
;  2425 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE                     25:24 /* RWXUF */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE               TEXTEQU         <25:24>
;  RW--V 
;  2426 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM            0x00000000 /* RW--V */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM           EQU             000000000h
;  RW--V 
;  2427 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART           0x00000001 /* RW--V */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART          EQU             000000001h
;  RW--V 
;  2428 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI            0x00000002 /* RW--V */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI           EQU             000000002h
;  RW--V 
;  2429 : #define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP            0x00000003 /* RW--V */
NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP           EQU             000000003h
;  RW-4R 
;  2430 : #define NV_PGRAPH_DMA_LIMIT                              0x00401220 /* RW-4R */
NV_PGRAPH_DMA_LIMIT             EQU             000401220h
;  RWXUF 
;  2431 : #define NV_PGRAPH_DMA_LIMIT_OFFSET                             31:0 /* RWXUF */
NV_PGRAPH_DMA_LIMIT_OFFSET              TEXTEQU         <31:0>
;  RW-4R 
;  2432 : #define NV_PGRAPH_DMA_TLB_PTE                            0x00401230 /* RW-4R */
NV_PGRAPH_DMA_TLB_PTE           EQU             000401230h
;  RWXVF 
;  2433 : #define NV_PGRAPH_DMA_TLB_PTE_PAGE                              0:0 /* RWXVF */
NV_PGRAPH_DMA_TLB_PTE_PAGE              TEXTEQU         <0:0>
;  RW--V 
;  2434 : #define NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT           0x00000000 /* RW--V */
NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT          EQU             000000000h
;  RW--V 
;  2435 : #define NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT               0x00000001 /* RW--V */
NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT              EQU             000000001h
;  RWXVF 
;  2436 : #define NV_PGRAPH_DMA_TLB_PTE_ACCESS                            1:1 /* RWXVF */
NV_PGRAPH_DMA_TLB_PTE_ACCESS            TEXTEQU         <1:1>
;  RW--V 
;  2437 : #define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY           0x00000000 /* RW--V */
NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY          EQU             000000000h
;  RW--V 
;  2438 : #define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE          0x00000001 /* RW--V */
NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE         EQU             000000001h
;  RWXUF 
;  2439 : #define NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS                   31:12 /* RWXUF */
NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS             TEXTEQU         <31:12>
;  RW-4R 
;  2440 : #define NV_PGRAPH_DMA_TLB_TAG                            0x00401240 /* RW-4R */
NV_PGRAPH_DMA_TLB_TAG           EQU             000401240h
;  RWXUF 
;  2441 : #define NV_PGRAPH_DMA_TLB_TAG_ADDRESS                         31:12 /* RWXUF */
NV_PGRAPH_DMA_TLB_TAG_ADDRESS           TEXTEQU         <31:12>
;  RW-4R 
;  2442 : #define NV_PGRAPH_DMA_ADJ_OFFSET                         0x00401250 /* RW-4R */
NV_PGRAPH_DMA_ADJ_OFFSET                EQU             000401250h
;  RWXUF 
;  2443 : #define NV_PGRAPH_DMA_ADJ_OFFSET_VALUE                         31:0 /* RWXUF */
NV_PGRAPH_DMA_ADJ_OFFSET_VALUE          TEXTEQU         <31:0>
;  RW-4R 
;  2444 : #define NV_PGRAPH_DMA_OFFSET                             0x00401260 /* RW-4R */
NV_PGRAPH_DMA_OFFSET            EQU             000401260h
;  RW-UF 
;  2445 : #define NV_PGRAPH_DMA_OFFSET_VALUE                             31:0 /* RW-UF */
NV_PGRAPH_DMA_OFFSET_VALUE              TEXTEQU         <31:0>
;  RW-4R 
;  2446 : #define NV_PGRAPH_DMA_SIZE                               0x00401270 /* RW-4R */
NV_PGRAPH_DMA_SIZE              EQU             000401270h
;  RW-UF 
;  2447 : #define NV_PGRAPH_DMA_SIZE_VALUE                               18:0 /* RW-UF */
NV_PGRAPH_DMA_SIZE_VALUE                TEXTEQU         <18:0>
;  RW-4R 
;  2448 : #define NV_PGRAPH_DMA_XLATE_INST                         0x00401280 /* RW-4R */
NV_PGRAPH_DMA_XLATE_INST                EQU             000401280h
;  RWXUF 
;  2449 : #define NV_PGRAPH_DMA_XLATE_INST_VALUE                         15:0 /* RWXUF */
NV_PGRAPH_DMA_XLATE_INST_VALUE          TEXTEQU         <15:0>
;  RW-4R 
;  2450 : #define NV_PGRAPH_DMA_Y_SIZE                             0x00401290 /* RW-4R */
NV_PGRAPH_DMA_Y_SIZE            EQU             000401290h
;  RW-UF 
;  2451 : #define NV_PGRAPH_DMA_Y_SIZE_VALUE                             18:0 /* RW-UF */
NV_PGRAPH_DMA_Y_SIZE_VALUE              TEXTEQU         <18:0>
;  RW-4R 
;  2452 : #define NV_PGRAPH_DMA_LINEAR_LIMIT                       0x00401400 /* RW-4R */
NV_PGRAPH_DMA_LINEAR_LIMIT              EQU             000401400h
;  RWXUF 
;  2453 : #define NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                       21:0 /* RWXUF */
NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                TEXTEQU         <21:0>
;  RW-4A 
;        
;  2454 : #define NV_PGRAPH_DMA_START(i)                  (0x00401800+(i)*16) /* RW-4A */
;  2455 : #define NV_PGRAPH_DMA_START__SIZE_1                               3 /*       */
NV_PGRAPH_DMA_START__SIZE_1             EQU             3t
;  RWXUF 
;  2456 : #define NV_PGRAPH_DMA_START_VALUE                              31:0 /* RWXUF */
NV_PGRAPH_DMA_START_VALUE               TEXTEQU         <31:0>
;  RW-4R 
;  2457 : #define NV_PGRAPH_DMA_PITCH                              0x00401830 /* RW-4R */
NV_PGRAPH_DMA_PITCH             EQU             000401830h
;  RWXS4 
;  2458 : #define NV_PGRAPH_DMA_PITCH_0                                  15:0 /* RWXS4 */
NV_PGRAPH_DMA_PITCH_0           TEXTEQU         <15:0>
;  RWXS4 
;  2459 : #define NV_PGRAPH_DMA_PITCH_1                                 31:16 /* RWXS4 */
NV_PGRAPH_DMA_PITCH_1           TEXTEQU         <31:16>
;  RW-4R 
;  2460 : #define NV_PGRAPH_DMA_FORMAT                             0x00401840 /* RW-4R */
NV_PGRAPH_DMA_FORMAT            EQU             000401840h
;  RWXS4 
;  2461 : #define NV_PGRAPH_DMA_FORMAT_SRC                                2:0 /* RWXS4 */
NV_PGRAPH_DMA_FORMAT_SRC                TEXTEQU         <2:0>
;  RW--V 
;  2462 : #define NV_PGRAPH_DMA_FORMAT_SRC_INC_1                   0x00000001 /* RW--V */
NV_PGRAPH_DMA_FORMAT_SRC_INC_1          EQU             000000001h
;  RW--V 
;  2463 : #define NV_PGRAPH_DMA_FORMAT_SRC_INC_2                   0x00000002 /* RW--V */
NV_PGRAPH_DMA_FORMAT_SRC_INC_2          EQU             000000002h
;  RW--V 
;  2464 : #define NV_PGRAPH_DMA_FORMAT_SRC_INC_4                   0x00000004 /* RW--V */
NV_PGRAPH_DMA_FORMAT_SRC_INC_4          EQU             000000004h
;  RWXS4 
;  2465 : #define NV_PGRAPH_DMA_FORMAT_DST                               10:8 /* RWXS4 */
NV_PGRAPH_DMA_FORMAT_DST                TEXTEQU         <10:8>
;  RW--V 
;  2466 : #define NV_PGRAPH_DMA_FORMAT_DST_INC_1                   0x00000001 /* RW--V */
NV_PGRAPH_DMA_FORMAT_DST_INC_1          EQU             000000001h
;  RW--V 
;  2467 : #define NV_PGRAPH_DMA_FORMAT_DST_INC_2                   0x00000002 /* RW--V */
NV_PGRAPH_DMA_FORMAT_DST_INC_2          EQU             000000002h
;  RW--V 
;  2468 : #define NV_PGRAPH_DMA_FORMAT_DST_INC_4                   0x00000004 /* RW--V */
NV_PGRAPH_DMA_FORMAT_DST_INC_4          EQU             000000004h
;  RW-4R 
;  2469 : #define NV_PGRAPH_DMA_MTMF_NOTIFY                        0x00401820 /* RW-4R */
NV_PGRAPH_DMA_MTMF_NOTIFY               EQU             000401820h
;  RWIVF 
;  2470 : #define NV_PGRAPH_MTMF_NOTIFY_TYPE                             31:0 /* RWIVF */
NV_PGRAPH_MTMF_NOTIFY_TYPE              TEXTEQU         <31:0>
;  RWI-V 
;  2471 : #define NV_PGRAPH_MTMF_NOTIFY_TYPE_HW                    0x00000000 /* RWI-V */
NV_PGRAPH_MTMF_NOTIFY_TYPE_HW           EQU             000000000h
;  dev_video.ref 
;  RW--D 
;  2472 : /* dev_video.ref */
;  2473 : #define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
NV_PVIDEO               TEXTEQU         <0x006802FF:0x00680000>
;  RWI4R 
;  2474 : #define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
NV_PVIDEO_INTR_0                EQU             000680100h
;  RWIVF 
;  2475 : #define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
NV_PVIDEO_INTR_0_NOTIFY         TEXTEQU         <0:0>
;  R-I-V 
;  2476 : #define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING             EQU             000000000h
;  R---V 
;  2477 : #define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
NV_PVIDEO_INTR_0_NOTIFY_PENDING         EQU             000000001h
;  -W--V 
;  2478 : #define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
NV_PVIDEO_INTR_0_NOTIFY_RESET           EQU             000000001h
;  RWI4R 
;  2479 : #define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
NV_PVIDEO_INTR_EN_0             EQU             000680140h
;  RWIVF 
;  2480 : #define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
NV_PVIDEO_INTR_EN_0_NOTIFY              TEXTEQU         <0:0>
;  RWI-V 
;  2481 : #define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED             EQU             000000000h
;  RW--V 
;  2482 : #define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED              EQU             000000001h
;  RW-4R 
;  2483 : #define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
NV_PVIDEO_STEP_SIZE             EQU             000680200h
;  RWXVF 
;  2484 : #define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
NV_PVIDEO_STEP_SIZE_X           TEXTEQU         <11:0>
;  RWXVF 
;  2485 : #define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
NV_PVIDEO_STEP_SIZE_Y           TEXTEQU         <27:16>
;  RW-4R 
;  2486 : #define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
NV_PVIDEO_CONTROL_Y             EQU             000680204h
;  RW--F 
;  2487 : #define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
NV_PVIDEO_CONTROL_Y_BLUR                TEXTEQU         <0:0>
;  RW--V 
;  2488 : #define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_Y_BLUR_OFF            EQU             000000000h
;  RW--V 
;  2489 : #define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_Y_BLUR_ON             EQU             000000001h
;  RW--F 
;  2490 : #define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
NV_PVIDEO_CONTROL_Y_LINE                TEXTEQU         <4:4>
;  RW--V 
;  2491 : #define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_Y_LINE_HALF           EQU             000000000h
;  RW--V 
;  2492 : #define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_Y_LINE_FULL           EQU             000000001h
;  RW-4R 
;  2493 : #define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
NV_PVIDEO_CONTROL_X             EQU             000680208h
;  RW--F 
;  2494 : #define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
NV_PVIDEO_CONTROL_X_WEIGHT              TEXTEQU         <0:0>
;  RW--V 
;  2495 : #define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                EQU             000000000h
;  RW--V 
;  2496 : #define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                EQU             000000001h
;  RW--F 
;  2497 : #define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
NV_PVIDEO_CONTROL_X_SHARPENING          TEXTEQU         <4:4>
;  RW--V 
;  2498 : #define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_X_SHARPENING_OFF              EQU             000000000h
;  RW--V 
;  2499 : #define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_X_SHARPENING_ON               EQU             000000001h
;  RW--F 
;  2500 : #define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
NV_PVIDEO_CONTROL_X_SMOOTHING           TEXTEQU         <8:8>
;  RW--V 
;  2501 : #define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
NV_PVIDEO_CONTROL_X_SMOOTHING_OFF               EQU             000000000h
;  RW--V 
;  2502 : #define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
NV_PVIDEO_CONTROL_X_SMOOTHING_ON                EQU             000000001h
;  RW-4R 
;  2503 : #define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
NV_PVIDEO_BUFF0_START           EQU             00068020ch
;  RW-UF 
;  2504 : #define NV_PVIDEO_BUFF0_START_ADDRESS                          22:2 /* RW-UF */
NV_PVIDEO_BUFF0_START_ADDRESS           TEXTEQU         <22:2>
;  RW-4R 
;  2505 : #define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
NV_PVIDEO_BUFF1_START           EQU             000680210h
;  RW-UF 
;  2506 : #define NV_PVIDEO_BUFF1_START_ADDRESS                          22:2 /* RW-UF */
NV_PVIDEO_BUFF1_START_ADDRESS           TEXTEQU         <22:2>
;  RW-4R 
;  2507 : #define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
NV_PVIDEO_BUFF0_PITCH           EQU             000680214h
;  RW-UF 
;  2508 : #define NV_PVIDEO_BUFF0_PITCH_LENGTH                           11:2 /* RW-UF */
NV_PVIDEO_BUFF0_PITCH_LENGTH            TEXTEQU         <11:2>
;  RW-4R 
;  2509 : #define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
NV_PVIDEO_BUFF1_PITCH           EQU             000680218h
;  RW-UF 
;  2510 : #define NV_PVIDEO_BUFF1_PITCH_LENGTH                           11:2 /* RW-UF */
NV_PVIDEO_BUFF1_PITCH_LENGTH            TEXTEQU         <11:2>
;  RW-4R 
;  2511 : #define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
NV_PVIDEO_BUFF0_OFFSET          EQU             00068021ch
;  RW--F 
;  2512 : #define NV_PVIDEO_BUFF0_OFFSET_X                                0:0 /* RW--F */
NV_PVIDEO_BUFF0_OFFSET_X                TEXTEQU         <0:0>
;  RW--V 
;  2513 : #define NV_PVIDEO_BUFF0_OFFSET_X_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_X_OFF            EQU             000000000h
;  RW--V 
;  2514 : #define NV_PVIDEO_BUFF0_OFFSET_X_ON                      0x00000001 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_X_ON             EQU             000000001h
;  RW--F 
;  2515 : #define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
NV_PVIDEO_BUFF0_OFFSET_Y                TEXTEQU         <5:4>
;  RW--V 
;  2516 : #define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_Y_OFF            EQU             000000000h
;  RW--V 
;  2517 : #define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                EQU             000000001h
;  RW--V 
;  2518 : #define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
NV_PVIDEO_BUFF0_OFFSET_Y_HALF           EQU             000000002h
;  RW-4R 
;  2519 : #define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
NV_PVIDEO_BUFF1_OFFSET          EQU             000680220h
;  RW--F 
;  2520 : #define NV_PVIDEO_BUFF1_OFFSET_X                                0:0 /* RW--F */
NV_PVIDEO_BUFF1_OFFSET_X                TEXTEQU         <0:0>
;  RW--V 
;  2521 : #define NV_PVIDEO_BUFF1_OFFSET_X_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_X_OFF            EQU             000000000h
;  RW--V 
;  2522 : #define NV_PVIDEO_BUFF1_OFFSET_X_ON                      0x00000001 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_X_ON             EQU             000000001h
;  RW--F 
;  2523 : #define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
NV_PVIDEO_BUFF1_OFFSET_Y                TEXTEQU         <5:4>
;  RW--V 
;  2524 : #define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_Y_OFF            EQU             000000000h
;  RW--V 
;  2525 : #define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                EQU             000000001h
;  RW--V 
;  2526 : #define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
NV_PVIDEO_BUFF1_OFFSET_Y_HALF           EQU             000000002h
;  RW-4R 
;  2527 : #define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
NV_PVIDEO_OE_STATE              EQU             000680224h
;  RWXVF 
;  2528 : #define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY            TEXTEQU         <0:0>
;  RWXVF 
;  2529 : #define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY            TEXTEQU         <4:4>
;  RWXVF 
;  2530 : #define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF0_ERROR          TEXTEQU         <8:8>
;  RWXVF 
;  2531 : #define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF1_ERROR          TEXTEQU         <12:12>
;  RWXVF 
;  2532 : #define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF0_IN_USE         TEXTEQU         <16:16>
;  RWXVF 
;  2533 : #define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
NV_PVIDEO_OE_STATE_BUFF1_IN_USE         TEXTEQU         <20:20>
;  RWXVF 
;  2534 : #define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
NV_PVIDEO_OE_STATE_CURRENT_BUFFER               TEXTEQU         <24:24>
;  RW--V 
;  2535 : #define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0             EQU             000000000h
;  RW--V 
;  2536 : #define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1             EQU             000000001h
;  RW-4R 
;  2537 : #define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
NV_PVIDEO_SU_STATE              EQU             000680228h
;  RWXVF 
;  2538 : #define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
NV_PVIDEO_SU_STATE_BUFF0_IN_USE         TEXTEQU         <16:16>
;  RWXVF 
;  2539 : #define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
NV_PVIDEO_SU_STATE_BUFF1_IN_USE         TEXTEQU         <20:20>
;  RW-4R 
;  2540 : #define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
NV_PVIDEO_RM_STATE              EQU             00068022ch
;  RWXVF 
;  2541 : #define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY            TEXTEQU         <0:0>
;  RWXVF 
;  2542 : #define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY            TEXTEQU         <4:4>
;  RW-4R 
;  2543 : #define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
NV_PVIDEO_WINDOW_START          EQU             000680230h
;  RWXUF 
;  2544 : #define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
NV_PVIDEO_WINDOW_START_X                TEXTEQU         <10:0>
;  RWXUF 
;  2545 : #define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
NV_PVIDEO_WINDOW_START_Y                TEXTEQU         <26:16>
;  RW-4R 
;  2546 : #define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
NV_PVIDEO_WINDOW_SIZE           EQU             000680234h
;  RWXUF 
;  2547 : #define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
NV_PVIDEO_WINDOW_SIZE_X         TEXTEQU         <10:0>
;  RWXUF 
;  2548 : #define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
NV_PVIDEO_WINDOW_SIZE_Y         TEXTEQU         <26:16>
;  RW-4R 
;  2549 : #define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
NV_PVIDEO_FIFO_THRES            EQU             000680238h
;  RW--F 
;  2550 : #define NV_PVIDEO_FIFO_THRES_SIZE                               7:3 /* RW--F */
NV_PVIDEO_FIFO_THRES_SIZE               TEXTEQU         <7:3>
;  RW-4R 
;  2551 : #define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
NV_PVIDEO_FIFO_BURST            EQU             00068023ch
;  RW--F 
;  2552 : #define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
NV_PVIDEO_FIFO_BURST_LENGTH             TEXTEQU         <1:0>
;  RW--V 
;  2553 : #define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
NV_PVIDEO_FIFO_BURST_LENGTH_32          EQU             000000001h
;  RW--V 
;  2554 : #define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
NV_PVIDEO_FIFO_BURST_LENGTH_64          EQU             000000002h
;  RW--V 
;  2555 : #define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
NV_PVIDEO_FIFO_BURST_LENGTH_128         EQU             000000003h
;  RW-4R 
;  2556 : #define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
NV_PVIDEO_KEY           EQU             000680240h
;  RW-VF 
;  2557 : #define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
NV_PVIDEO_KEY_INDEX             TEXTEQU         <7:0>
;  RW-VF 
;  2558 : #define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
NV_PVIDEO_KEY_565               TEXTEQU         <15:0>
;  RW-VF 
;  2559 : #define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
NV_PVIDEO_KEY_555               TEXTEQU         <14:0>
;  RW-VF 
;  2560 : #define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
NV_PVIDEO_KEY_888               TEXTEQU         <23:0>
;  RW-VF 
;  2561 : #define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
NV_PVIDEO_KEY_PACK              TEXTEQU         <31:24>
;  RWI4R 
;  2562 : #define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
NV_PVIDEO_OVERLAY               EQU             000680244h
;  RWI-F 
;  2563 : #define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
NV_PVIDEO_OVERLAY_VIDEO         TEXTEQU         <0:0>
;  RWI-V 
;  2564 : #define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
NV_PVIDEO_OVERLAY_VIDEO_OFF             EQU             000000000h
;  RW--V 
;  2565 : #define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
NV_PVIDEO_OVERLAY_VIDEO_ON              EQU             000000001h
;  RW--F 
;  2566 : #define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
NV_PVIDEO_OVERLAY_KEY           TEXTEQU         <4:4>
;  RW--V 
;  2567 : #define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
NV_PVIDEO_OVERLAY_KEY_OFF               EQU             000000000h
;  RW--V 
;  2568 : #define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
NV_PVIDEO_OVERLAY_KEY_ON                EQU             000000001h
;  RW--F 
;  2569 : #define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
NV_PVIDEO_OVERLAY_FORMAT                TEXTEQU         <8:8>
;  RW--V 
;  2570 : #define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
NV_PVIDEO_OVERLAY_FORMAT_CCIR           EQU             000000000h
;  RW--V 
;  2571 : #define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
NV_PVIDEO_OVERLAY_FORMAT_YUY2           EQU             000000001h
;  RW-4R 
;  2572 : #define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
NV_PVIDEO_RED_CSC               EQU             000680280h
;  RWX-F 
;  2573 : #define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
NV_PVIDEO_RED_CSC_OFFSET                TEXTEQU         <7:0>
;  RW-4R 
;  2574 : #define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
NV_PVIDEO_GREEN_CSC             EQU             000680284h
;  RWX-F 
;  2575 : #define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
NV_PVIDEO_GREEN_CSC_OFFSET              TEXTEQU         <7:0>
;  RW-4R 
;  2576 : #define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
NV_PVIDEO_BLUE_CSC              EQU             000680288h
;  RWX-F 
;  2577 : #define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
NV_PVIDEO_BLUE_CSC_OFFSET               TEXTEQU         <7:0>
;  RW-4R 
;  2578 : #define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
NV_PVIDEO_CSC_ADJUST            EQU             00068028ch
;  RW--F 
;  2579 : #define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
NV_PVIDEO_CSC_ADJUST_B_FLAG             TEXTEQU         <0:0>
;  RW--V 
;  2580 : #define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF         EQU             000000000h
;  RW--V 
;  2581 : #define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_B_FLAG_ON          EQU             000000001h
;  RW--F 
;  2582 : #define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
NV_PVIDEO_CSC_ADJUST_G_FLAG             TEXTEQU         <4:4>
;  RW--V 
;  2583 : #define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF         EQU             000000000h
;  RW--V 
;  2584 : #define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_G_FLAG_ON          EQU             000000001h
;  RW--F 
;  2585 : #define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
NV_PVIDEO_CSC_ADJUST_R_FLAG             TEXTEQU         <8:8>
;  RW--V 
;  2586 : #define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF         EQU             000000000h
;  RW--V 
;  2587 : #define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_R_FLAG_ON          EQU             000000001h
;  RW--F 
;  2588 : #define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
NV_PVIDEO_CSC_ADJUST_L_FLAG             TEXTEQU         <12:12>
;  RW--V 
;  2589 : #define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF         EQU             000000000h
;  RW--V 
;  2590 : #define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_L_FLAG_ON          EQU             000000001h
;  RW--F 
;  2591 : #define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
NV_PVIDEO_CSC_ADJUST_CHROMA             TEXTEQU         <16:16>
;  RW--V 
;  2592 : #define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
NV_PVIDEO_CSC_ADJUST_CHROMA_OFF         EQU             000000000h
;  RW--V 
;  2593 : #define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
NV_PVIDEO_CSC_ADJUST_CHROMA_ON          EQU             000000001h
;  vga.ref 
;  RW--D 
;  2594 : /* vga.ref */
;  2595 : #define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
NV_PRMCIO               TEXTEQU         <0x00601FFF:0x00601000>
;  R--1R 
;  2596 : #define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
NV_PRMCIO_INP0          EQU             0006013c2h
;  R--1R 
;  2597 : #define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
NV_PRMCIO_INP0__MONO            EQU             0006013bah
;  R--1R 
;  2598 : #define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
NV_PRMCIO_INP0__COLOR           EQU             0006013dah
;  R--1R 
;  2599 : #define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
NV_PRMCIO_INP0__READ_MONO               EQU             0006013cah
;  -W-1R 
;  2600 : #define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
NV_PRMCIO_INP0__WRITE_MONO              EQU             0006013bah
;  -W-1R 
;  2601 : #define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
NV_PRMCIO_INP0__WRITE_COLOR             EQU             0006013dah
;  RW-1R 
;  2602 : #define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
NV_PRMCIO_ARX           EQU             0006013c0h
;  -W-1R 
;  2603 : #define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
NV_PRMCIO_AR_PALETTE__WRITE             EQU             0006013c0h
;  R--1R 
;  2604 : #define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
NV_PRMCIO_AR_PALETTE__READ              EQU             0006013c1h
;  -W-1R 
;  2605 : #define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
NV_PRMCIO_AR_MODE__WRITE                EQU             0006013c0h
;  R--1R 
;  2606 : #define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
NV_PRMCIO_AR_MODE__READ         EQU             0006013c1h
;        
;  2607 : #define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
NV_PRMCIO_AR_MODE_INDEX         EQU             000000010h
;  -W-1R 
;  2608 : #define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
NV_PRMCIO_AR_OSCAN__WRITE               EQU             0006013c0h
;  R--1R 
;  2609 : #define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
NV_PRMCIO_AR_OSCAN__READ                EQU             0006013c1h
;        
;  2610 : #define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
NV_PRMCIO_AR_OSCAN_INDEX                EQU             000000011h
;  -W-1R 
;  2611 : #define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
NV_PRMCIO_AR_PLANE__WRITE               EQU             0006013c0h
;  R--1R 
;  2612 : #define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
NV_PRMCIO_AR_PLANE__READ                EQU             0006013c1h
;        
;  2613 : #define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
NV_PRMCIO_AR_PLANE_INDEX                EQU             000000012h
;  -W-1R 
;  2614 : #define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
NV_PRMCIO_AR_HPP__WRITE         EQU             0006013c0h
;  R--1R 
;  2615 : #define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
NV_PRMCIO_AR_HPP__READ          EQU             0006013c1h
;        
;  2616 : #define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
NV_PRMCIO_AR_HPP_INDEX          EQU             000000013h
;  -W-1R 
;  2617 : #define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
NV_PRMCIO_AR_CSEL__WRITE                EQU             0006013c0h
;  R--1R 
;  2618 : #define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
NV_PRMCIO_AR_CSEL__READ         EQU             0006013c1h
;        
;  2619 : #define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
NV_PRMCIO_AR_CSEL_INDEX         EQU             000000014h
;  RW-1R 
;  2620 : #define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
NV_PRMCIO_CRX__MONO             EQU             0006013b4h
;  RW-1R 
;  2621 : #define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
NV_PRMCIO_CRX__COLOR            EQU             0006013d4h
;  RW-1R 
;  2622 : #define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
NV_PRMCIO_CR__MONO              EQU             0006013b5h
;  RW-1R 
;  2623 : #define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
NV_PRMCIO_CR__COLOR             EQU             0006013d5h
;  RW-1R 
;  2624 : #define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
NV_PRMCIO_CRE__MONO             EQU             0006013b5h
;  RW-1R 
;  2625 : #define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */
NV_PRMCIO_CRE__COLOR            EQU             0006013d5h
;  vga.ref 
;  ----- 
;  2626 : /* vga.ref */
;  2627 : #define NV_CIO                                          0x3DF:0x3B0 /* ----- */
NV_CIO          TEXTEQU         <0x3DF:0x3B0>
;  R--1R 
;  2628 : #define NV_CIO_INP0                                      0x000003c2 /* R--1R */
NV_CIO_INP0             EQU             0000003c2h
;  R--1R 
;  2629 : #define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
NV_CIO_INP0__MONO               EQU             0000003bah
;  R--1R 
;  2630 : #define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
NV_CIO_INP0__COLOR              EQU             0000003dah
;  R--1R 
;  2631 : #define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
NV_CIO_INP0__READ_MONO          EQU             0000003cah
;  -W-1R 
;  2632 : #define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
NV_CIO_INP0__WRITE_MONO         EQU             0000003bah
;  -W-1R 
;  2633 : #define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
NV_CIO_INP0__WRITE_COLOR                EQU             0000003dah
;  RW-1R 
;  2634 : #define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
NV_CIO_ARX              EQU             0000003c0h
;  -W-1R 
;  2635 : #define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
NV_CIO_AR_PALETTE__WRITE                EQU             0000003c0h
;  R--1R 
;  2636 : #define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
NV_CIO_AR_PALETTE__READ         EQU             0000003c1h
;  -W-1R 
;  2637 : #define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
NV_CIO_AR_MODE__WRITE           EQU             0000003c0h
;  R--1R 
;  2638 : #define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
NV_CIO_AR_MODE__READ            EQU             0000003c1h
;        
;  2639 : #define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
NV_CIO_AR_MODE_INDEX            EQU             000000010h
;  -W-1R 
;  2640 : #define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
NV_CIO_AR_OSCAN__WRITE          EQU             0000003c0h
;  R--1R 
;  2641 : #define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
NV_CIO_AR_OSCAN__READ           EQU             0000003c1h
;        
;  2642 : #define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
NV_CIO_AR_OSCAN_INDEX           EQU             000000011h
;  -W-1R 
;  2643 : #define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
NV_CIO_AR_PLANE__WRITE          EQU             0000003c0h
;  R--1R 
;  2644 : #define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
NV_CIO_AR_PLANE__READ           EQU             0000003c1h
;        
;  2645 : #define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
NV_CIO_AR_PLANE_INDEX           EQU             000000012h
;  -W-1R 
;  2646 : #define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
NV_CIO_AR_HPP__WRITE            EQU             0000003c0h
;  R--1R 
;  2647 : #define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
NV_CIO_AR_HPP__READ             EQU             0000003c1h
;        
;  2648 : #define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
NV_CIO_AR_HPP_INDEX             EQU             000000013h
;  -W-1R 
;  2649 : #define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
NV_CIO_AR_CSEL__WRITE           EQU             0000003c0h
;  R--1R 
;  2650 : #define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
NV_CIO_AR_CSEL__READ            EQU             0000003c1h
;        
;  2651 : #define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
NV_CIO_AR_CSEL_INDEX            EQU             000000014h
;  RW-1R 
;  2652 : #define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
NV_CIO_CRX__MONO                EQU             0000003b4h
;  RW-1R 
;  2653 : #define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
NV_CIO_CRX__COLOR               EQU             0000003d4h
;  RW-1R 
;  2654 : #define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
NV_CIO_CR__MONO         EQU             0000003b5h
;  RW-1R 
;  2655 : #define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
NV_CIO_CR__COLOR                EQU             0000003d5h
;        
;  2656 : #define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
NV_CIO_CR_HDT_INDEX             EQU             000000000h
;        
;  2657 : #define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
NV_CIO_CR_HDE_INDEX             EQU             000000001h
;        
;  2658 : #define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
NV_CIO_CR_HBS_INDEX             EQU             000000002h
;        
;  2659 : #define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
NV_CIO_CR_HBE_INDEX             EQU             000000003h
;  RW--F 
;  2660 : #define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
NV_CIO_CR_HBE_4_0               TEXTEQU         <4:0>
;        
;  2661 : #define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
NV_CIO_CR_HRS_INDEX             EQU             000000004h
;        
;  2662 : #define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
NV_CIO_CR_HRE_INDEX             EQU             000000005h
;  RW--F 
;  2663 : #define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
NV_CIO_CR_HRE_HBE_5             TEXTEQU         <7:7>
;  RW--F 
;  2664 : #define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
NV_CIO_CR_HRE_4_0               TEXTEQU         <4:0>
;        
;  2665 : #define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
NV_CIO_CR_VDT_INDEX             EQU             000000006h
;        
;  2666 : #define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
NV_CIO_CR_OVL_INDEX             EQU             000000007h
;  RW--F 
;  2667 : #define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
NV_CIO_CR_OVL_VDE_8             TEXTEQU         <1:1>
;  RW--F 
;  2668 : #define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
NV_CIO_CR_OVL_VDE_9             TEXTEQU         <6:6>
;  RW--F 
;  2669 : #define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
NV_CIO_CR_OVL_VDT_8             TEXTEQU         <0:0>
;  RW--F 
;  2670 : #define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
NV_CIO_CR_OVL_VDT_9             TEXTEQU         <5:5>
;  RW--F 
;  2671 : #define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
NV_CIO_CR_OVL_VBS_8             TEXTEQU         <3:3>
;  RW--F 
;  2672 : #define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
NV_CIO_CR_OVL_VRS_8             TEXTEQU         <2:2>
;  RW--F 
;  2673 : #define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
NV_CIO_CR_OVL_VRS_9             TEXTEQU         <7:7>
;        
;  2674 : #define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
NV_CIO_CR_RSAL_INDEX            EQU             000000008h
;  RW--F 
;  2675 : #define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
NV_CIO_CR_RSAL_PANNING          TEXTEQU         <6:5>
;        
;  2676 : #define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
NV_CIO_CR_CELL_HT_INDEX         EQU             000000009h
;  RW--F 
;  2677 : #define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
NV_CIO_CR_CELL_HT_SCANDBL               TEXTEQU         <7:7>
;  RW--F 
;  2678 : #define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
NV_CIO_CR_CELL_HT_VBS_9         TEXTEQU         <5:5>
;        
;  2679 : #define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
NV_CIO_CR_CURS_ST_INDEX         EQU             00000000ah
;        
;  2680 : #define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
NV_CIO_CR_CURS_END_INDEX                EQU             00000000bh
;        
;  2681 : #define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
NV_CIO_CR_SA_HI_INDEX           EQU             00000000ch
;        
;  2682 : #define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
NV_CIO_CR_SA_LO_INDEX           EQU             00000000dh
;        
;  2683 : #define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
NV_CIO_CR_TCOFF_HI_INDEX                EQU             00000000eh
;        
;  2684 : #define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
NV_CIO_CR_TCOFF_LO_INDEX                EQU             00000000fh
;        
;  2685 : #define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
NV_CIO_CR_VRS_INDEX             EQU             000000010h
;        
;  2686 : #define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
NV_CIO_CR_VRE_INDEX             EQU             000000011h
;  RW--F 
;  2687 : #define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
NV_CIO_CR_VRE_3_0               TEXTEQU         <3:0>
;        
;  2688 : #define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
NV_CIO_CR_VDE_INDEX             EQU             000000012h
;        
;  2689 : #define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
NV_CIO_CR_OFFSET_INDEX          EQU             000000013h
;        
;  2690 : #define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
NV_CIO_CR_ULINE_INDEX           EQU             000000014h
;        
;  2691 : #define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
NV_CIO_CR_VBS_INDEX             EQU             000000015h
;        
;  2692 : #define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
NV_CIO_CR_VBE_INDEX             EQU             000000016h
;        
;  2693 : #define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
NV_CIO_CR_MODE_INDEX            EQU             000000017h
;        
;  2694 : #define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
NV_CIO_CR_LCOMP_INDEX           EQU             000000018h
;        
;  2695 : #define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
NV_CIO_CR_GDATA_INDEX           EQU             000000022h
;        
;  2696 : #define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
NV_CIO_CR_ARFF_INDEX            EQU             000000024h
;        
;  2697 : #define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
NV_CIO_CR_ARX_INDEX             EQU             000000026h
;  RW-1R 
;  2698 : #define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
NV_CIO_CRE__MONO                EQU             0000003b5h
;  RW-1R 
;  2699 : #define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
NV_CIO_CRE__COLOR               EQU             0000003d5h
;        
;  2700 : #define NV_CIO_CRE_RPC0_INDEX                            0x00000019 /*       */
NV_CIO_CRE_RPC0_INDEX           EQU             000000019h
;  RW--F 
;  2701 : #define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
NV_CIO_CRE_RPC0_START           TEXTEQU         <4:0>
;  RW--F 
;  2702 : #define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
NV_CIO_CRE_RPC0_OFFSET_10_8             TEXTEQU         <7:5>
;        
;  2703 : #define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
NV_CIO_CRE_RPC1_INDEX           EQU             00000001ah
;        
;  2704 : #define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
NV_CIO_CRE_FF_INDEX             EQU             00000001bh
;  RW--F 
;  2705 : #define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
NV_CIO_CRE_FF_BURST             TEXTEQU         <2:0>
;  RW--V 
;  2706 : #define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
NV_CIO_CRE_FF_BURST_8           EQU             000000000h
;  RW--V 
;  2707 : #define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
NV_CIO_CRE_FF_BURST_32          EQU             000000001h
;  RW--V 
;  2708 : #define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
NV_CIO_CRE_FF_BURST_64          EQU             000000002h
;  RW--V 
;  2709 : #define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
NV_CIO_CRE_FF_BURST_128         EQU             000000003h
;  RW--V 
;  2710 : #define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
NV_CIO_CRE_FF_BURST_256         EQU             000000004h
;        
;  2711 : #define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
NV_CIO_CRE_ENH_INDEX            EQU             00000001ch
;        
;  2712 : #define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
NV_CIO_CRE_PAGE0_INDEX          EQU             00000001dh
;        
;  2713 : #define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
NV_CIO_CRE_PAGE1_INDEX          EQU             00000001eh
;        
;  2714 : #define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
NV_CIO_CRE_FFLWM__INDEX         EQU             000000020h
;  RW--F 
;  2715 : #define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
NV_CIO_CRE_FFLWM_LWM            TEXTEQU         <5:0>
;        
;  2716 : #define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
NV_CIO_CRE_LSR_INDEX            EQU             000000025h
;  RW--F 
;  2717 : #define NV_CIO_CRE_LSR_FORMAT                                   7:6 /* RW--F */
NV_CIO_CRE_LSR_FORMAT           TEXTEQU         <7:6>
;  RW--V 
;  2718 : #define NV_CIO_CRE_LSR_FORMAT_8BIT                       0x00000001 /* RW--V */
NV_CIO_CRE_LSR_FORMAT_8BIT              EQU             000000001h
;  RW--V 
;  2719 : #define NV_CIO_CRE_LSR_FORMAT_555                        0x00000002 /* RW--V */
NV_CIO_CRE_LSR_FORMAT_555               EQU             000000002h
;  RW--V 
;  2720 : #define NV_CIO_CRE_LSR_FORMAT_565                        0x00000003 /* RW--V */
NV_CIO_CRE_LSR_FORMAT_565               EQU             000000003h
;  RW--F 
;  2721 : #define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
NV_CIO_CRE_LSR_VDE_10           TEXTEQU         <1:1>
;  RW--F 
;  2722 : #define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
NV_CIO_CRE_LSR_VDT_10           TEXTEQU         <0:0>
;  RW--F 
;  2723 : #define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
NV_CIO_CRE_LSR_HBE_6            TEXTEQU         <4:4>
;  RW--F 
;  2724 : #define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
NV_CIO_CRE_LSR_VBS_10           TEXTEQU         <3:3>
;  RW--F 
;  2725 : #define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
NV_CIO_CRE_LSR_VRS_10           TEXTEQU         <2:2>
;        
;  2726 : #define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
NV_CIO_CRE_PIXEL_INDEX          EQU             000000028h
;  RW--F 
;  2727 : #define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
NV_CIO_CRE_PIXEL_FORMAT         TEXTEQU         <1:0>
;  RW--V 
;  2728 : #define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
NV_CIO_CRE_PIXEL_FORMAT_VGA             EQU             000000000h
;  RW--V 
;  2729 : #define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
NV_CIO_CRE_PIXEL_FORMAT_8BPP            EQU             000000001h
;  RW--V 
;  2730 : #define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
NV_CIO_CRE_PIXEL_FORMAT_16BPP           EQU             000000002h
;  RW--V 
;  2731 : #define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
NV_CIO_CRE_PIXEL_FORMAT_32BPP           EQU             000000003h
;  RW--F 
;  2732 : #define NV_CIO_CRE_PIXEL_TILING                                 2:2 /* RW--F */
NV_CIO_CRE_PIXEL_TILING         TEXTEQU         <2:2>
;        
;  2733 : #define NV_CIO_CRE_DEC__INDEX                            0x00000029 /*       */
NV_CIO_CRE_DEC__INDEX           EQU             000000029h
;        
;  2734 : #define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
NV_CIO_CRE_OSCOL__INDEX         EQU             00000002ah
;        
;  2735 : #define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
NV_CIO_CRE_SCRATCH0__INDEX              EQU             00000002bh
;        
;  2736 : #define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
NV_CIO_CRE_SCRATCH1__INDEX              EQU             00000002ch
;        
;  2737 : #define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
NV_CIO_CRE_HEB__INDEX           EQU             00000002dh
;  RW--F 
;  2738 : #define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
NV_CIO_CRE_HEB_ILC_8            TEXTEQU         <4:4>
;  RW--F 
;  2739 : #define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
NV_CIO_CRE_HEB_HRS_8            TEXTEQU         <3:3>
;  RW--F 
;  2740 : #define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
NV_CIO_CRE_HEB_HBS_8            TEXTEQU         <2:2>
;  RW--F 
;  2741 : #define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
NV_CIO_CRE_HEB_HDE_8            TEXTEQU         <1:1>
;  RW--F 
;  2742 : #define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
NV_CIO_CRE_HEB_HDT_8            TEXTEQU         <0:0>
;        
;  2743 : #define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
NV_CIO_CRE_HCUR_ADDR0_INDEX             EQU             000000030h
;  RW--F 
;  2744 : #define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
NV_CIO_CRE_HCUR_ADDR0_ADR               TEXTEQU         <6:0>
;        
;  2745 : #define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
NV_CIO_CRE_HCUR_ADDR1_INDEX             EQU             000000031h
;  RW--F 
;  2746 : #define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:3 /* RW--F */
NV_CIO_CRE_HCUR_ADDR1_ADR               TEXTEQU         <7:3>
;  RW--F 
;  2747 : #define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
NV_CIO_CRE_HCUR_ADDR1_CUR_DBL           TEXTEQU         <1:1>
;  RW--F 
;  2748 : #define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
NV_CIO_CRE_HCUR_ADDR1_ENABLE            TEXTEQU         <0:0>
;        
;  2749 : #define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
NV_CIO_CRE_VID_END0__INDEX              EQU             000000032h
;        
;  2750 : #define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
NV_CIO_CRE_VID_END1__INDEX              EQU             000000033h
;        
;  2751 : #define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
NV_CIO_CRE_RL0__INDEX           EQU             000000034h
;        
;  2752 : #define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
NV_CIO_CRE_RL1__INDEX           EQU             000000035h
;        
;  2753 : #define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
NV_CIO_CRE_RMA__INDEX           EQU             000000038h
;        
;  2754 : #define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
NV_CIO_CRE_ILACE__INDEX         EQU             000000039h
;        
;  2755 : #define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
NV_CIO_CRE_TREG__INDEX          EQU             00000003dh
;        
;  2756 : #define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
NV_CIO_CRE_DDC_STATUS__INDEX            EQU             00000003eh
;        
;  2757 : #define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
NV_CIO_CRE_DDC_WR__INDEX                EQU             00000003fh
;  vga.ref 
;  RW--D 
;  2758 : /* vga.ref */
;  2759 : #define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
NV_PRMVIO               TEXTEQU         <0x000C7FFF:0x000C0000>
;  RW-1R 
;  2760 : #define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
NV_PRMVIO_MBEN          EQU             0000c0094h
;  RW-1R 
;  2761 : #define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
NV_PRMVIO_ADDEN         EQU             0000c46e8h
;  RW-1R 
;  2762 : #define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
NV_PRMVIO_VSE1          EQU             0000c0102h
;  RW-1R 
;  2763 : #define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
NV_PRMVIO_VSE2          EQU             0000c03c3h
;  R--1R 
;  2764 : #define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
NV_PRMVIO_MISC__READ            EQU             0000c03cch
;  -W-1R 
;  2765 : #define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
NV_PRMVIO_MISC__WRITE           EQU             0000c03c2h
;  RW-1R 
;  2766 : #define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
NV_PRMVIO_SRX           EQU             0000c03c4h
;  RW-1R 
;  2767 : #define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_RESET              EQU             0000c03c5h
;        
;  2768 : #define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*       */
NV_PRMVIO_SR_RESET_INDEX                EQU             000000000h
;  RW-1R 
;  2769 : #define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_CLOCK              EQU             0000c03c5h
;        
;  2770 : #define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*       */
NV_PRMVIO_SR_CLOCK_INDEX                EQU             000000001h
;  RW-1R 
;  2771 : #define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_PLANE_MASK         EQU             0000c03c5h
;        
;  2772 : #define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*       */
NV_PRMVIO_SR_PLANE_MASK_INDEX           EQU             000000002h
;  RW-1R 
;  2773 : #define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_CHAR_MAP           EQU             0000c03c5h
;        
;  2774 : #define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
NV_PRMVIO_SR_CHAR_MAP_INDEX             EQU             000000003h
;  RW-1R 
;  2775 : #define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_MEM_MODE           EQU             0000c03c5h
;        
;  2776 : #define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
NV_PRMVIO_SR_MEM_MODE_INDEX             EQU             000000004h
;  RW-1R 
;  2777 : #define NV_PRMVIO_SR_LOCK                                0x000C03c5 /* RW-1R */
NV_PRMVIO_SR_LOCK               EQU             0000c03c5h
;        
;  2778 : #define NV_PRMVIO_SR_LOCK_INDEX                          0x00000005 /*       */
NV_PRMVIO_SR_LOCK_INDEX         EQU             000000005h
;  RW-1R 
;  2779 : #define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
NV_PRMVIO_GRX           EQU             0000c03ceh
;  RW-1R 
;  2780 : #define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
NV_PRMVIO_GX_SR         EQU             0000c03cfh
;        
;  2781 : #define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
NV_PRMVIO_GX_SR_INDEX           EQU             000000000h
;  RW-1R 
;  2782 : #define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
NV_PRMVIO_GX_SREN               EQU             0000c03cfh
;        
;  2783 : #define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
NV_PRMVIO_GX_SREN_INDEX         EQU             000000001h
;  RW-1R 
;  2784 : #define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
NV_PRMVIO_GX_CCOMP              EQU             0000c03cfh
;        
;  2785 : #define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
NV_PRMVIO_GX_CCOMP_INDEX                EQU             000000002h
;  RW-1R 
;  2786 : #define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
NV_PRMVIO_GX_ROP                EQU             0000c03cfh
;        
;  2787 : #define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
NV_PRMVIO_GX_ROP_INDEX          EQU             000000003h
;  RW-1R 
;  2788 : #define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
NV_PRMVIO_GX_READ_MAP           EQU             0000c03cfh
;        
;  2789 : #define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
NV_PRMVIO_GX_READ_MAP_INDEX             EQU             000000004h
;  RW-1R 
;  2790 : #define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
NV_PRMVIO_GX_MODE               EQU             0000c03cfh
;        
;  2791 : #define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
NV_PRMVIO_GX_MODE_INDEX         EQU             000000005h
;  RW-1R 
;  2792 : #define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
NV_PRMVIO_GX_MISC               EQU             0000c03cfh
;        
;  2793 : #define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
NV_PRMVIO_GX_MISC_INDEX         EQU             000000006h
;  RW-1R 
;  2794 : #define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
NV_PRMVIO_GX_DONT_CARE          EQU             0000c03cfh
;        
;  2795 : #define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
NV_PRMVIO_GX_DONT_CARE_INDEX            EQU             000000007h
;  RW-1R 
;  2796 : #define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
NV_PRMVIO_GX_BIT_MASK           EQU             0000c03cfh
;        
;  2797 : #define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
NV_PRMVIO_GX_BIT_MASK_INDEX             EQU             000000008h
;  vga.ref 
;  RW--D 
;  2798 : /* vga.ref */
;  2799 : #define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
NV_PRMVGA               TEXTEQU         <0x000BFFFF:0x000A0000>
;  dev_media.ref 
;  RW--D 
;  2800 : /* dev_media.ref */
;  2801 : #define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
NV_PME          TEXTEQU         <0x00200FFF:0x00200000>
;  RWI4R 
;  2802 : #define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
NV_PME_INTR_0           EQU             000200100h
;  RWIVF 
;  2803 : #define NV_PME_INTR_0_NOTIFY                                    0:0 /* RWIVF */
NV_PME_INTR_0_NOTIFY            TEXTEQU         <0:0>
;  R-I-V 
;  2804 : #define NV_PME_INTR_0_NOTIFY_NOT_PENDING                 0x00000000 /* R-I-V */
NV_PME_INTR_0_NOTIFY_NOT_PENDING                EQU             000000000h
;  R---V 
;  2805 : #define NV_PME_INTR_0_NOTIFY_PENDING                     0x00000001 /* R---V */
NV_PME_INTR_0_NOTIFY_PENDING            EQU             000000001h
;  -W--V 
;  2806 : #define NV_PME_INTR_0_NOTIFY_RESET                       0x00000001 /* -W--V */
NV_PME_INTR_0_NOTIFY_RESET              EQU             000000001h
;  RWIVF 
;  2807 : #define NV_PME_INTR_0_VMI                                       4:4 /* RWIVF */
NV_PME_INTR_0_VMI               TEXTEQU         <4:4>
;  R-I-V 
;  2808 : #define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
NV_PME_INTR_0_VMI_NOT_PENDING           EQU             000000000h
;  R---V 
;  2809 : #define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
NV_PME_INTR_0_VMI_PENDING               EQU             000000001h
;  -W--V 
;  2810 : #define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
NV_PME_INTR_0_VMI_RESET         EQU             000000001h
;  RWI4R 
;  2811 : #define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
NV_PME_INTR_EN_0                EQU             000200140h
;  RWIVF 
;  2812 : #define NV_PME_INTR_EN_0_NOTIFY                                 0:0 /* RWIVF */
NV_PME_INTR_EN_0_NOTIFY         TEXTEQU         <0:0>
;  RWI-V 
;  2813 : #define NV_PME_INTR_EN_0_NOTIFY_DISABLED                 0x00000000 /* RWI-V */
NV_PME_INTR_EN_0_NOTIFY_DISABLED                EQU             000000000h
;  RW--V 
;  2814 : #define NV_PME_INTR_EN_0_NOTIFY_ENABLED                  0x00000001 /* RW--V */
NV_PME_INTR_EN_0_NOTIFY_ENABLED         EQU             000000001h
;  RWIVF 
;  2815 : #define NV_PME_INTR_EN_0_VMI                                    4:4 /* RWIVF */
NV_PME_INTR_EN_0_VMI            TEXTEQU         <4:4>
;  RWI-V 
;  2816 : #define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
NV_PME_INTR_EN_0_VMI_DISABLED           EQU             000000000h
;  RW--V 
;  2817 : #define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
NV_PME_INTR_EN_0_VMI_ENABLED            EQU             000000001h
;  RWI4R 
;  2818 : #define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
NV_PME_CONFIG_0         EQU             000200200h
;  RWIVF 
;  2819 : #define NV_PME_CONFIG_0_CCIR656                                 0:0 /* RWIVF */
NV_PME_CONFIG_0_CCIR656         TEXTEQU         <0:0>
;  RWI-V 
;  2820 : #define NV_PME_CONFIG_0_CCIR656_DISABLED                 0x00000000 /* RWI-V */
NV_PME_CONFIG_0_CCIR656_DISABLED                EQU             000000000h
;  RW--V 
;  2821 : #define NV_PME_CONFIG_0_CCIR656_ENABLED                  0x00000001 /* RW--V */
NV_PME_CONFIG_0_CCIR656_ENABLED         EQU             000000001h
;  RWIVF 
;  2822 : #define NV_PME_CONFIG_0_VMI                                     4:4 /* RWIVF */
NV_PME_CONFIG_0_VMI             TEXTEQU         <4:4>
;  RWI-V 
;  2823 : #define NV_PME_CONFIG_0_VMI_DISABLED                     0x00000000 /* RWI-V */
NV_PME_CONFIG_0_VMI_DISABLED            EQU             000000000h
;  RW--V 
;  2824 : #define NV_PME_CONFIG_0_VMI_ENABLED                      0x00000001 /* RW--V */
NV_PME_CONFIG_0_VMI_ENABLED             EQU             000000001h
;  RWIVF 
;  2825 : #define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
NV_PME_CONFIG_0_VBI_MODE                TEXTEQU         <9:8>
;  RWI-V 
;  2826 : #define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
NV_PME_CONFIG_0_VBI_MODE_DISABLED               EQU             000000000h
;  RW--V 
;  2827 : #define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
NV_PME_CONFIG_0_VBI_MODE_1              EQU             000000001h
;  RW--V 
;  2828 : #define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
NV_PME_CONFIG_0_VBI_MODE_2              EQU             000000002h
;  RWIVF 
;  2829 : #define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
NV_PME_CONFIG_0_VID_CD          TEXTEQU         <12:12>
;  RWI-V 
;  2830 : #define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
NV_PME_CONFIG_0_VID_CD_DISABLED         EQU             000000000h
;  RW--V 
;  2831 : #define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
NV_PME_CONFIG_0_VID_CD_ENABLED          EQU             000000001h
;  RWIVF 
;  2832 : #define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
NV_PME_CONFIG_0_AUD_CD          TEXTEQU         <16:16>
;  RWI-V 
;  2833 : #define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
NV_PME_CONFIG_0_AUD_CD_DISABLED         EQU             000000000h
;  RW--V 
;  2834 : #define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
NV_PME_CONFIG_0_AUD_CD_ENABLED          EQU             000000001h
;  RWI4R 
;  2835 : #define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
NV_PME_CONFIG_1         EQU             000200204h
;  RWIVF 
;  2836 : #define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
NV_PME_CONFIG_1_BUFFS           TEXTEQU         <0:0>
;  RWI-V 
;  2837 : #define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
NV_PME_CONFIG_1_BUFFS_PNVM              EQU             000000000h
;  RW--V 
;  2838 : #define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
NV_PME_CONFIG_1_BUFFS_SYS               EQU             000000001h
;  RWIVF 
;  2839 : #define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
NV_PME_CONFIG_1_HOST            TEXTEQU         <4:4>
;  RWI-V 
;  2840 : #define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
NV_PME_CONFIG_1_HOST_PCI                EQU             000000000h
;  RW--V 
;  2841 : #define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
NV_PME_CONFIG_1_HOST_AGP                EQU             000000001h
;  RWI4R 
;  2842 : #define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */ 
NV_PME_VID_BUFF0_START_SYS              EQU             000200300h
;  RWXUF 
;  2843 : #define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
NV_PME_VID_BUFF0_START_SYS_ADDRESS              TEXTEQU         <31:4>
;  RWI4R 
;  2844 : #define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */ 
NV_PME_VID_BUFF1_START_SYS              EQU             000200304h
;  RWXUF 
;  2845 : #define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
NV_PME_VID_BUFF1_START_SYS_ADDRESS              TEXTEQU         <31:4>
;  RWI4R 
;  2846 : #define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */ 
NV_PME_VID_BUFF0_START_PNVM             EQU             000200308h
;  RWXUF 
;  2847 : #define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
NV_PME_VID_BUFF0_START_PNVM_ADDRESS             TEXTEQU         <22:4>
;  RWI4R 
;  2848 : #define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */ 
NV_PME_VID_BUFF1_START_PNVM             EQU             00020030ch
;  RWXUF 
;  2849 : #define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
NV_PME_VID_BUFF1_START_PNVM_ADDRESS             TEXTEQU         <22:4>
;  RWI4R 
;  2850 : #define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */ 
NV_PME_VID_BUFF0_LENGTH         EQU             000200310h
;  RWXUF 
;  2851 : #define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
NV_PME_VID_BUFF0_LENGTH_BITS            TEXTEQU         <15:12>
;  RWI4R 
;  2852 : #define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */ 
NV_PME_VID_BUFF1_LENGTH         EQU             000200314h
;  RWXUF 
;  2853 : #define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
NV_PME_VID_BUFF1_LENGTH_BITS            TEXTEQU         <15:12>
;  RW-4R 
;  2854 : #define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
NV_PME_VID_ME_STATE             EQU             000200318h
;  RWIVF 
;  2855 : #define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2856 : #define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2857 : #define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP         TEXTEQU         <8:8>
;  RWXVF 
;  2858 : #define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP         TEXTEQU         <12:12>
;  RWXVF 
;  2859 : #define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2860 : #define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_VID_ME_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RWXVF 
;  2861 : #define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
NV_PME_VID_ME_STATE_CURRENT_BUFFER              TEXTEQU         <24:24>
;  RW--V 
;  2862 : #define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
NV_PME_VID_ME_STATE_CURRENT_BUFFER_0            EQU             000000000h
;  RW--V 
;  2863 : #define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
NV_PME_VID_ME_STATE_CURRENT_BUFFER_1            EQU             000000001h
;  RW-4R 
;  2864 : #define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
NV_PME_VID_SU_STATE             EQU             00020031ch
;  RWXVF 
;  2865 : #define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_VID_SU_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2866 : #define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_VID_SU_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RW-4R 
;  2867 : #define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
NV_PME_VID_RM_STATE             EQU             000200320h
;  RWXVF 
;  2868 : #define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2869 : #define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2870 : #define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP         TEXTEQU         <8:8>
;  RWXVF 
;  2871 : #define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP         TEXTEQU         <12:12>
;  RWI4R 
;  2872 : #define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */ 
NV_PME_VID_CURRENT              EQU             000200324h
;  RWXUF 
;  2873 : #define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
NV_PME_VID_CURRENT_POS          TEXTEQU         <15:2>
;  RWI4R 
;  2874 : #define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */ 
NV_PME_AUD_BUFF0_START_SYS              EQU             000200340h
;  RWXUF 
;  2875 : #define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
NV_PME_AUD_BUFF0_START_SYS_ADDRESS              TEXTEQU         <31:4>
;  RWI4R 
;  2876 : #define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */ 
NV_PME_AUD_BUFF1_START_SYS              EQU             000200344h
;  RWXUF 
;  2877 : #define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
NV_PME_AUD_BUFF1_START_SYS_ADDRESS              TEXTEQU         <31:4>
;  RWI4R 
;  2878 : #define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */ 
NV_PME_AUD_BUFF0_START_PNVM             EQU             000200348h
;  RWXUF 
;  2879 : #define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
NV_PME_AUD_BUFF0_START_PNVM_ADDRESS             TEXTEQU         <22:4>
;  RWI4R 
;  2880 : #define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */ 
NV_PME_AUD_BUFF1_START_PNVM             EQU             00020034ch
;  RWXUF 
;  2881 : #define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
NV_PME_AUD_BUFF1_START_PNVM_ADDRESS             TEXTEQU         <22:4>
;  RWI4R 
;  2882 : #define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */ 
NV_PME_AUD_BUFF0_LENGTH         EQU             000200350h
;  RWXUF 
;  2883 : #define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
NV_PME_AUD_BUFF0_LENGTH_BITS            TEXTEQU         <12:10>
;  RWI4R 
;  2884 : #define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */ 
NV_PME_AUD_BUFF1_LENGTH         EQU             000200354h
;  RWXUF 
;  2885 : #define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
NV_PME_AUD_BUFF1_LENGTH_BITS            TEXTEQU         <12:10>
;  RW-4R 
;  2886 : #define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
NV_PME_AUD_ME_STATE             EQU             000200358h
;  RWIVF 
;  2887 : #define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2888 : #define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2889 : #define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP         TEXTEQU         <8:8>
;  RWXVF 
;  2890 : #define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP         TEXTEQU         <12:12>
;  RWXVF 
;  2891 : #define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2892 : #define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_AUD_ME_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RWXVF 
;  2893 : #define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
NV_PME_AUD_ME_STATE_CURRENT_BUFFER              TEXTEQU         <24:24>
;  RW--V 
;  2894 : #define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0            EQU             000000000h
;  RW--V 
;  2895 : #define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1            EQU             000000001h
;  RW-4R 
;  2896 : #define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
NV_PME_AUD_SU_STATE             EQU             00020035ch
;  RWXVF 
;  2897 : #define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_AUD_SU_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2898 : #define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_AUD_SU_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RW-4R 
;  2899 : #define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
NV_PME_AUD_RM_STATE             EQU             000200360h
;  RWXVF 
;  2900 : #define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2901 : #define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2902 : #define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP         TEXTEQU         <8:8>
;  RWXVF 
;  2903 : #define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP         TEXTEQU         <12:12>
;  RWI4R 
;  2904 : #define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */ 
NV_PME_AUD_CURRENT              EQU             000200364h
;  RWXUF 
;  2905 : #define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
NV_PME_AUD_CURRENT_POS          TEXTEQU         <12:2>
;  RWI4R 
;  2906 : #define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */ 
NV_PME_VBI_BUFF0_START          EQU             000200380h
;  RWXUF 
;  2907 : #define NV_PME_VBI_BUFF0_START_ADDRESS                         22:4 /* RWXUF */
NV_PME_VBI_BUFF0_START_ADDRESS          TEXTEQU         <22:4>
;  RWI4R 
;  2908 : #define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */ 
NV_PME_VBI_BUFF1_START          EQU             000200384h
;  RWXUF 
;  2909 : #define NV_PME_VBI_BUFF1_START_ADDRESS                         22:4 /* RWXUF */
NV_PME_VBI_BUFF1_START_ADDRESS          TEXTEQU         <22:4>
;  RWI4R 
;  2910 : #define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */ 
NV_PME_VBI_BUFF0_PITCH          EQU             000200388h
;  RWXUF 
;  2911 : #define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
NV_PME_VBI_BUFF0_PITCH_VALUE            TEXTEQU         <13:4>
;  RWI4R 
;  2912 : #define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */ 
NV_PME_VBI_BUFF1_PITCH          EQU             00020038ch
;  RWXUF 
;  2913 : #define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
NV_PME_VBI_BUFF1_PITCH_VALUE            TEXTEQU         <13:4>
;  RWI4R 
;  2914 : #define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */ 
NV_PME_VBI_BUFF0_LENGTH         EQU             000200390h
;  RWXUF 
;  2915 : #define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
NV_PME_VBI_BUFF0_LENGTH_BITS            TEXTEQU         <19:4>
;  RWI4R 
;  2916 : #define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */ 
NV_PME_VBI_BUFF1_LENGTH         EQU             000200394h
;  RWXUF 
;  2917 : #define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
NV_PME_VBI_BUFF1_LENGTH_BITS            TEXTEQU         <19:4>
;  RW-4R 
;  2918 : #define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
NV_PME_VBI_ME_STATE             EQU             000200398h
;  RWXVF 
;  2919 : #define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2920 : #define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWXVF 
;  2921 : #define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE            TEXTEQU         <10:8>
;  RWXVF 
;  2922 : #define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE            TEXTEQU         <14:12>
;  RWXVF 
;  2923 : #define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2924 : #define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_VBI_ME_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RWXVF 
;  2925 : #define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
NV_PME_VBI_ME_STATE_CURRENT_BUFFER              TEXTEQU         <24:24>
;  RW--V 
;  2926 : #define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0            EQU             000000000h
;  RW--V 
;  2927 : #define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1            EQU             000000001h
;  RW-4R 
;  2928 : #define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
NV_PME_VBI_SU_STATE             EQU             00020039ch
;  RWXVF 
;  2929 : #define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
NV_PME_VBI_SU_STATE_BUFF0_FIELD         TEXTEQU         <8:8>
;  RWXVF 
;  2930 : #define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
NV_PME_VBI_SU_STATE_BUFF1_FIELD         TEXTEQU         <12:12>
;  RWXVF 
;  2931 : #define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
NV_PME_VBI_SU_STATE_BUFF0_IN_USE                TEXTEQU         <16:16>
;  RWXVF 
;  2932 : #define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
NV_PME_VBI_SU_STATE_BUFF1_IN_USE                TEXTEQU         <20:20>
;  RW-4R 
;  2933 : #define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
NV_PME_VBI_RM_STATE             EQU             0002003a0h
;  RWXVF 
;  2934 : #define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY           TEXTEQU         <0:0>
;  RWXVF 
;  2935 : #define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY           TEXTEQU         <4:4>
;  RWI4R 
;  2936 : #define NV_PME_VBI                                       0x002003a4 /* RWI4R */
NV_PME_VBI              EQU             0002003a4h
;  RWX-F 
;  2937 : #define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
NV_PME_VBI_START_LINE           TEXTEQU         <4:0>
;  RWX-F 
;  2938 : #define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
NV_PME_VBI_NUM_LINES            TEXTEQU         <20:16>
;  RWI4R 
;  2939 : #define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */ 
NV_PME_IMAGE_BUFF0_START                EQU             000200400h
;  RWXUF 
;  2940 : #define NV_PME_IMAGE_BUFF0_START_ADDRESS                       22:4 /* RWXUF */
NV_PME_IMAGE_BUFF0_START_ADDRESS                TEXTEQU         <22:4>
;  RWI4R 
;  2941 : #define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */ 
NV_PME_IMAGE_BUFF1_START                EQU             000200404h
;  RWXUF 
;  2942 : #define NV_PME_IMAGE_BUFF1_START_ADDRESS                       22:4 /* RWXUF */
NV_PME_IMAGE_BUFF1_START_ADDRESS                TEXTEQU         <22:4>
;  RWI4R 
;  2943 : #define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */ 
NV_PME_IMAGE_BUFF0_PITCH                EQU             000200408h
;  RWXUF 
;  2944 : #define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
NV_PME_IMAGE_BUFF0_PITCH_VALUE          TEXTEQU         <13:4>
;  RWI4R 
;  2945 : #define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */ 
NV_PME_IMAGE_BUFF1_PITCH                EQU             00020040ch
;  RWXUF 
;  2946 : #define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
NV_PME_IMAGE_BUFF1_PITCH_VALUE          TEXTEQU         <13:4>
;  RWI4R 
;  2947 : #define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */ 
NV_PME_IMAGE_BUFF0_LENGTH               EQU             000200410h
;  RWXUF 
;  2948 : #define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
NV_PME_IMAGE_BUFF0_LENGTH_BITS          TEXTEQU         <19:4>
;  RWI4R 
;  2949 : #define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */ 
NV_PME_IMAGE_BUFF1_LENGTH               EQU             000200414h
;  RWXUF 
;  2950 : #define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
NV_PME_IMAGE_BUFF1_LENGTH_BITS          TEXTEQU         <19:4>
;  RW-4R 
;  2951 : #define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
NV_PME_IMAGE_ME_STATE           EQU             000200418h
;  RWXVF 
;  2952 : #define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY         TEXTEQU         <0:0>
;  RWXVF 
;  2953 : #define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY         TEXTEQU         <4:4>
;  RWXVF 
;  2954 : #define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE          TEXTEQU         <10:8>
;  RWXVF 
;  2955 : #define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE          TEXTEQU         <14:12>
;  RWXVF 
;  2956 : #define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE              TEXTEQU         <16:16>
;  RWXVF 
;  2957 : #define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE              TEXTEQU         <20:20>
;  RWXVF 
;  2958 : #define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER            TEXTEQU         <24:24>
;  RW--V 
;  2959 : #define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0          EQU             000000000h
;  RW--V 
;  2960 : #define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1          EQU             000000001h
;  RW-4R 
;  2961 : #define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
NV_PME_IMAGE_SU_STATE           EQU             00020041ch
;  RWXVF 
;  2962 : #define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
NV_PME_IMAGE_SU_STATE_BUFF0_FIELD               TEXTEQU         <8:8>
;  RWXVF 
;  2963 : #define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
NV_PME_IMAGE_SU_STATE_BUFF1_FIELD               TEXTEQU         <12:12>
;  RWXVF 
;  2964 : #define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE              TEXTEQU         <16:16>
;  RWXVF 
;  2965 : #define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE              TEXTEQU         <20:20>
;  RW-4R 
;  2966 : #define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
NV_PME_IMAGE_RM_STATE           EQU             000200420h
;  RWXVF 
;  2967 : #define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY         TEXTEQU         <0:0>
;  RWXVF 
;  2968 : #define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY         TEXTEQU         <4:4>
;  RW-4R 
;  2969 : #define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
NV_PME_IMAGE_BUFF0_SCALE_INCR           EQU             000200424h
;  RWXVF 
;  2970 : #define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
NV_PME_IMAGE_BUFF0_SCALE_INCR_Y         TEXTEQU         <26:16>
;  RWXVF 
;  2971 : #define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
NV_PME_IMAGE_BUFF0_SCALE_INCR_X         TEXTEQU         <10:0>
;  RW-4R 
;  2972 : #define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
NV_PME_IMAGE_BUFF1_SCALE_INCR           EQU             000200428h
;  RWXVF 
;  2973 : #define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
NV_PME_IMAGE_BUFF1_SCALE_INCR_Y         TEXTEQU         <26:16>
;  RWXVF 
;  2974 : #define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
NV_PME_IMAGE_BUFF1_SCALE_INCR_X         TEXTEQU         <10:0>
;  R--4R 
;  2975 : #define NV_PME_FIFO_LINE_START                           0x00200480 /* R--4R */
NV_PME_FIFO_LINE_START          EQU             000200480h
;  R-XVF 
;  2976 : #define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* R-XVF */
NV_PME_FIFO_LINE_START_ADDRESS          TEXTEQU         <20:4>
;  RWI4R 
;  2977 : #define NV_PME_FIFO_CURRENT                              0x00200484 /* RWI4R */
NV_PME_FIFO_CURRENT             EQU             000200484h
;  RWXVF 
;  2978 : #define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
NV_PME_FIFO_CURRENT_ADDRESS             TEXTEQU         <20:2>
;  R--4R 
;  2979 : #define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
NV_PME_VMI_POLL         EQU             000200488h
;  R-IVF 
;  2980 : #define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
NV_PME_VMI_POLL_UNCD            TEXTEQU         <0:0>
;  R-IVF 
;  2981 : #define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-IVF */
NV_PME_VMI_POLL_UNCD_NOT_PENDING                EQU             000000000h
;  R--VF 
;  2982 : #define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R--VF */
NV_PME_VMI_POLL_UNCD_PENDING            EQU             000000001h
;  R-IVF 
;  2983 : #define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
NV_PME_VMI_POLL_VIDCD           TEXTEQU         <1:1>
;  R-IVF 
;  2984 : #define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-IVF */
NV_PME_VMI_POLL_VIDCD_NOT_PENDING               EQU             000000000h
;  R--VF 
;  2985 : #define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R--VF */
NV_PME_VMI_POLL_VIDCD_PENDING           EQU             000000001h
;  R-IVF 
;  2986 : #define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
NV_PME_VMI_POLL_AUDCD           TEXTEQU         <2:2>
;  R-IVF 
;  2987 : #define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-IVF */
NV_PME_VMI_POLL_AUDCD_NOT_PENDING               EQU             000000000h
;  R--VF 
;  2988 : #define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R--VF */
NV_PME_VMI_POLL_AUDCD_PENDING           EQU             000000001h
;  R-IVF 
;  2989 : #define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
NV_PME_VMI_POLL_INT             TEXTEQU         <3:3>
;  R-IVF 
;  2990 : #define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-IVF */
NV_PME_VMI_POLL_INT_NOT_PENDING         EQU             000000000h
;  R--VF 
;  2991 : #define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R--VF */
NV_PME_VMI_POLL_INT_PENDING             EQU             000000001h
;  R-IVF 
;  2992 : #define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
NV_PME_VMI_POLL_CPURDREC                TEXTEQU         <4:4>
;  R-IVF 
;  2993 : #define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-IVF */
NV_PME_VMI_POLL_CPURDREC_NOT_PENDING            EQU             000000000h
;  R--VF 
;  2994 : #define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R--VF */
NV_PME_VMI_POLL_CPURDREC_PENDING                EQU             000000001h
;  RWI4R 
;  2995 : #define NV_PME_DMA_STATUS_0                              0x00200500 /* RWI4R */
NV_PME_DMA_STATUS_0             EQU             000200500h
;  R-I-F 
;  2996 : #define NV_PME_DMA_STATUS_0_STATE                               0:0 /* R-I-F */
NV_PME_DMA_STATUS_0_STATE               TEXTEQU         <0:0>
;  R-I-V 
;  2997 : #define NV_PME_DMA_STATUS_0_STATE_IDLE                   0x00000000 /* R-I-V */
NV_PME_DMA_STATUS_0_STATE_IDLE          EQU             000000000h
;  R-I-V 
;  2998 : #define NV_PME_DMA_STATUS_0_STATE_BUSY                   0x00000001 /* R-I-V */                  
NV_PME_DMA_STATUS_0_STATE_BUSY          EQU             000000001h
;  R-I-F 
;  2999 : #define NV_PME_DMA_STATUS_0_DRAIN                               8:8 /* R-I-F */
NV_PME_DMA_STATUS_0_DRAIN               TEXTEQU         <8:8>
;  R-I-V 
;  3000 : #define NV_PME_DMA_STATUS_0_DRAIN_IDLE                   0x00000000 /* R-I-V */
NV_PME_DMA_STATUS_0_DRAIN_IDLE          EQU             000000000h
;  R-I-V 
;  3001 : #define NV_PME_DMA_STATUS_0_DRAIN_BUSY                   0x00000001 /* R-I-V */                  
NV_PME_DMA_STATUS_0_DRAIN_BUSY          EQU             000000001h
;  R-I-F 
;  3002 : #define NV_PME_DMA_STATUS_0_FLUSH                             12:12 /* R-I-F */
NV_PME_DMA_STATUS_0_FLUSH               TEXTEQU         <12:12>
;  R-I-V 
;  3003 : #define NV_PME_DMA_STATUS_0_FLUSH_IDLE                   0x00000000 /* R-I-V */
NV_PME_DMA_STATUS_0_FLUSH_IDLE          EQU             000000000h
;  R-I-V 
;  3004 : #define NV_PME_DMA_STATUS_0_FLUSH_BUSY                   0x00000001 /* R-I-V */                  
NV_PME_DMA_STATUS_0_FLUSH_BUSY          EQU             000000001h
;  R-I-F 
;  3005 : #define NV_PME_DMA_STATUS_0_READ                              16:16 /* R-I-F */
NV_PME_DMA_STATUS_0_READ                TEXTEQU         <16:16>
;  R-I-V 
;  3006 : #define NV_PME_DMA_STATUS_0_READ_IDLE                    0x00000000 /* R-I-V */
NV_PME_DMA_STATUS_0_READ_IDLE           EQU             000000000h
;  R-I-V 
;  3007 : #define NV_PME_DMA_STATUS_0_READ_BUSY                    0x00000001 /* R-I-V */                  
NV_PME_DMA_STATUS_0_READ_BUSY           EQU             000000001h
;  RW-4A 
;        
;  3008 : #define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
;  3009 : #define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */  
NV_PME_EXTERNAL_SIZE_1          EQU             256t
;  RWXVF 
;  3010 : #define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
NV_PME_EXTERNAL_DATA            TEXTEQU         <7:0>
;  usr_beta_solid.ref 
;  -W--D 
;  3011 : /* usr_beta_solid.ref */
;  3012 : #define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
NV_UBETA                TEXTEQU         <0x00411FFF:0x00410000>
;  -W-4R 
;  3013 : #define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
NV_UBETA_CTX_SWITCH             EQU             000410000h
;  -W-UF 
;  3014 : #define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UBETA_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3015 : #define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UBETA_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3016 : #define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UBETA_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3017 : #define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3018 : #define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UBETA_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3019 : #define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
NV_UBETA_SET_NOTIFY             EQU             000410104h
;  -W-VF 
;  3020 : #define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UBETA_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3021 : #define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UBETA_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3022 : #define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
NV_UBETA_SET_BETA1D31           EQU             000410300h
;  -W-UF 
;  3023 : #define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
NV_UBETA_SET_BETA1D31_VALUE_FRACTION            TEXTEQU         <30:21>
;  -W-SF 
;  3024 : #define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
NV_UBETA_SET_BETA1D31_VALUE             TEXTEQU         <31:31>
;  usr_rop_solid.ref 
;  -W--D 
;  3025 : /* usr_rop_solid.ref */
;  3026 : #define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
NV_UROP         TEXTEQU         <0x00421FFF:0x00420000>
;  -W-4R 
;  3027 : #define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
NV_UROP_CTX_SWITCH              EQU             000420000h
;  -W-UF 
;  3028 : #define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
NV_UROP_CTX_SWITCH_INSTANCE             TEXTEQU         <15:0>
;  -W-UF 
;  3029 : #define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
NV_UROP_CTX_SWITCH_CHID         TEXTEQU         <22:16>
;  -W-VF 
;  3030 : #define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
NV_UROP_CTX_SWITCH_VOLATILE             TEXTEQU         <31:31>
;  -W--V 
;  3031 : #define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
NV_UROP_CTX_SWITCH_VOLATILE_IGNORE              EQU             000000000h
;  -W--V 
;  3032 : #define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
NV_UROP_CTX_SWITCH_VOLATILE_RESET               EQU             000000001h
;  -W-4R 
;  3033 : #define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
NV_UROP_SET_NOTIFY              EQU             000420104h
;  -W-VF 
;  3034 : #define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
NV_UROP_SET_NOTIFY_PARAMETER            TEXTEQU         <31:0>
;  -W--V 
;  3035 : #define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
NV_UROP_SET_NOTIFY_PARAMETER_WRITE              EQU             000000000h
;  -W-4R 
;  3036 : #define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
NV_UROP_SET_ROP         EQU             000420300h
;  -W-VF 
;  3037 : #define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF */
NV_UROP_SET_ROP_VALUE           TEXTEQU         <7:0>
;  usr_color_key.ref 
;  -W--D 
;  3038 : /* usr_color_key.ref */
;  3039 : #define NV_UCHROMA                            0x00431FFF:0x00430000 /* -W--D */
NV_UCHROMA              TEXTEQU         <0x00431FFF:0x00430000>
;  -W-4R 
;  3040 : #define NV_UCHROMA_CTX_SWITCH                            0x00430000 /* -W-4R */
NV_UCHROMA_CTX_SWITCH           EQU             000430000h
;  -W-UF 
;  3041 : #define NV_UCHROMA_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UCHROMA_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3042 : #define NV_UCHROMA_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UCHROMA_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3043 : #define NV_UCHROMA_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UCHROMA_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3044 : #define NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3045 : #define NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3046 : #define NV_UCHROMA_SET_NOTIFY                            0x00430104 /* -W-4R */
NV_UCHROMA_SET_NOTIFY           EQU             000430104h
;  -W-VF 
;  3047 : #define NV_UCHROMA_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UCHROMA_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3048 : #define NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3049 : #define NV_UCHROMA_SET_COLOR                             0x00430304 /* -W-4R */
NV_UCHROMA_SET_COLOR            EQU             000430304h
;  -W-VF 
;  3050 : #define NV_UCHROMA_SET_COLOR_VALUE                             31:0 /* -W-VF */
NV_UCHROMA_SET_COLOR_VALUE              TEXTEQU         <31:0>
;  usr_plane_switch.ref 
;  -W--D 
;  3051 : /* usr_plane_switch.ref */
;  3052 : #define NV_UPLANE                             0x00441FFF:0x00440000 /* -W--D */
NV_UPLANE               TEXTEQU         <0x00441FFF:0x00440000>
;  -W-4R 
;  3053 : #define NV_UPLANE_CTX_SWITCH                             0x00440000 /* -W-4R */
NV_UPLANE_CTX_SWITCH            EQU             000440000h
;  -W-UF 
;  3054 : #define NV_UPLANE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UPLANE_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3055 : #define NV_UPLANE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UPLANE_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3056 : #define NV_UPLANE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UPLANE_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3057 : #define NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3058 : #define NV_UPLANE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UPLANE_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3059 : #define NV_UPLANE_SET_NOTIFY                             0x00440104 /* -W-4R */
NV_UPLANE_SET_NOTIFY            EQU             000440104h
;  -W-VF 
;  3060 : #define NV_UPLANE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UPLANE_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3061 : #define NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3062 : #define NV_UPLANE_SET_COLOR                              0x00440304 /* -W-4R */
NV_UPLANE_SET_COLOR             EQU             000440304h
;  -W-VF 
;  3063 : #define NV_UPLANE_SET_COLOR_VALUE                              31:0 /* -W-VF */
NV_UPLANE_SET_COLOR_VALUE               TEXTEQU         <31:0>
;  usr_clipping.ref 
;  -W--D 
;  3064 : /* usr_clipping.ref */
;  3065 : #define NV_UCLIP                              0x00451FFF:0x00450000 /* -W--D */
NV_UCLIP                TEXTEQU         <0x00451FFF:0x00450000>
;  -W-4R 
;  3066 : #define NV_UCLIP_CTX_SWITCH                              0x00450000 /* -W-4R */
NV_UCLIP_CTX_SWITCH             EQU             000450000h
;  -W-UF 
;  3067 : #define NV_UCLIP_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UCLIP_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3068 : #define NV_UCLIP_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UCLIP_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3069 : #define NV_UCLIP_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UCLIP_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3070 : #define NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3071 : #define NV_UCLIP_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UCLIP_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3072 : #define NV_UCLIP_SET_NOTIFY                              0x00450104 /* -W-4R */
NV_UCLIP_SET_NOTIFY             EQU             000450104h
;  -W-VF 
;  3073 : #define NV_UCLIP_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UCLIP_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3074 : #define NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3075 : #define NV_UCLIP_SET_RECT_0                              0x00450300 /* -W-4R */
NV_UCLIP_SET_RECT_0             EQU             000450300h
;  -W-SF 
;  3076 : #define NV_UCLIP_SET_RECT_0_X                                  15:0 /* -W-SF */
NV_UCLIP_SET_RECT_0_X           TEXTEQU         <15:0>
;  -W-SF 
;  3077 : #define NV_UCLIP_SET_RECT_0_Y                                 31:16 /* -W-SF */
NV_UCLIP_SET_RECT_0_Y           TEXTEQU         <31:16>
;  -W-4R 
;  3078 : #define NV_UCLIP_SET_RECT_1                              0x00450304 /* -W-4R */
NV_UCLIP_SET_RECT_1             EQU             000450304h
;  -W-UF 
;  3079 : #define NV_UCLIP_SET_RECT_1_WIDTH                              15:0 /* -W-UF */
NV_UCLIP_SET_RECT_1_WIDTH               TEXTEQU         <15:0>
;  -W-UF 
;  3080 : #define NV_UCLIP_SET_RECT_1_HEIGHT                            31:16 /* -W-UF */
NV_UCLIP_SET_RECT_1_HEIGHT              TEXTEQU         <31:16>
;  usr_d3d0_triangle_zeta.ref 
;  -W--D 
;  3081 : /* usr_d3d0_triangle_zeta.ref */
;  3082 : #define NV_UD3D0Z                             0x00571FFF:0x00570000 /* -W--D */
NV_UD3D0Z               TEXTEQU         <0x00571FFF:0x00570000>
;  -W-4R 
;  3083 : #define NV_UD3D0Z_CTX_SWITCH                             0x00570000 /* -W-4R */
NV_UD3D0Z_CTX_SWITCH            EQU             000570000h
;  -W-UF 
;  3084 : #define NV_UD3D0Z_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UD3D0Z_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3085 : #define NV_UD3D0Z_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UD3D0Z_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3086 : #define NV_UD3D0Z_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UD3D0Z_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3087 : #define NV_UD3D0Z_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UD3D0Z_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3088 : #define NV_UD3D0Z_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UD3D0Z_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3089 : #define NV_UD3D0Z_SET_NOTIFY                             0x00570104 /* -W-4R */
NV_UD3D0Z_SET_NOTIFY            EQU             000570104h
;  -W-VF 
;  3090 : #define NV_UD3D0Z_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UD3D0Z_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3091 : #define NV_UD3D0Z_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UD3D0Z_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3092 : #define NV_UD3D0Z_TEXTURE_OFFSET                         0x00570304 /* -W-4R */
NV_UD3D0Z_TEXTURE_OFFSET                EQU             000570304h
;  -W-UF 
;  3093 : #define NV_UD3D0Z_TEXTURE_OFFSET_VALUE                         31:0 /* -W-UF */
NV_UD3D0Z_TEXTURE_OFFSET_VALUE          TEXTEQU         <31:0>
;  -W-4R 
;  3094 : #define NV_UD3D0Z_TEXTURE_FORMAT                         0x00570308 /* -W-4R */
NV_UD3D0Z_TEXTURE_FORMAT                EQU             000570308h
;  -W-UF 
;  3095 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK          15:0 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK           TEXTEQU         <15:0>
;  -W-UF 
;  3096 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY                    16:16 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY              TEXTEQU         <16:16>
;  -W-UV 
;  3097 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_DISABLED      0x00000000 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_DISABLED             EQU             000000000h
;  -W-UV 
;  3098 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_ENABLED       0x00000001 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_ENABLED              EQU             000000001h
;  -W-UF 
;  3099 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT                 21:20 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT           TEXTEQU         <21:20>
;  -W-UV 
;  3100 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5   0x00000000 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5          EQU             000000000h
;  -W-UV 
;  3101 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5   0x00000001 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5          EQU             000000001h
;  -W-UV 
;  3102 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4   0x00000002 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4          EQU             000000002h
;  -W-UV 
;  3103 : #define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5     0x00000003 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5            EQU             000000003h
;  -W-UF 
;  3104 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN                     27:24 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN               TEXTEQU         <27:24>
;  -W-UV 
;  3105 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1X1            0x00000000 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1X1           EQU             000000000h
;  -W-UV 
;  3106 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2X2            0x00000001 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2X2           EQU             000000001h
;  -W-UV 
;  3107 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_4X4            0x00000002 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_4X4           EQU             000000002h
;  -W-UV 
;  3108 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_8X8            0x00000003 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_8X8           EQU             000000003h
;  -W-UV 
;  3109 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_16X16          0x00000004 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_16X16         EQU             000000004h
;  -W-UV 
;  3110 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_32X32          0x00000005 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_32X32         EQU             000000005h
;  -W-UV 
;  3111 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_64X64          0x00000006 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_64X64         EQU             000000006h
;  -W-UV 
;  3112 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_128X128        0x00000007 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_128X128               EQU             000000007h
;  -W-UV 
;  3113 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_256X256        0x00000008 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_256X256               EQU             000000008h
;  -W-UV 
;  3114 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_512X512        0x00000009 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_512X512               EQU             000000009h
;  -W-UV 
;  3115 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1024X1024      0x0000000a /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1024X1024             EQU             00000000ah
;  -W-UV 
;  3116 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2048X2048      0x0000000b /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2048X2048             EQU             00000000bh
;  -W-UF 
;  3117 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX                     31:28 /* -W-UF */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX               TEXTEQU         <31:28>
;  -W-UV 
;  3118 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1X1            0x00000000 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1X1           EQU             000000000h
;  -W-UV 
;  3119 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2X2            0x00000001 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2X2           EQU             000000001h
;  -W-UV 
;  3120 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_4X4            0x00000002 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_4X4           EQU             000000002h
;  -W-UV 
;  3121 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_8X8            0x00000003 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_8X8           EQU             000000003h
;  -W-UV 
;  3122 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_16X16          0x00000004 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_16X16         EQU             000000004h
;  -W-UV 
;  3123 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_32X32          0x00000005 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_32X32         EQU             000000005h
;  -W-UV 
;  3124 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_64X64          0x00000006 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_64X64         EQU             000000006h
;  -W-UV 
;  3125 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_128X128        0x00000007 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_128X128               EQU             000000007h
;  -W-UV 
;  3126 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_256X256        0x00000008 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_256X256               EQU             000000008h
;  -W-UV 
;  3127 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_512X512        0x00000009 /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_512X512               EQU             000000009h
;  -W-UV 
;  3128 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1024X1024      0x0000000a /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1024X1024             EQU             00000000ah
;  -W-UV 
;  3129 : #define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2048X2048      0x0000000b /* -W-UV */
NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2048X2048             EQU             00000000bh
;  -W-4R 
;  3130 : #define NV_UD3D0Z_FILTER                                 0x0057030C /* -W-4R */
NV_UD3D0Z_FILTER                EQU             00057030ch
;  -W-UF 
;  3131 : #define NV_UD3D0Z_FILTER_SPREADX                                7:0 /* -W-UF */
NV_UD3D0Z_FILTER_SPREADX                TEXTEQU         <7:0>
;  -W-UF 
;  3132 : #define NV_UD3D0Z_FILTER_SPREADY                               15:8 /* -W-UF */
NV_UD3D0Z_FILTER_SPREADY                TEXTEQU         <15:8>
;  -W-SF 
;  3133 : #define NV_UD3D0Z_FILTER_MIPMAP                               23:16 /* -W-SF */
NV_UD3D0Z_FILTER_MIPMAP         TEXTEQU         <23:16>
;  -W-SF 
;  3134 : #define NV_UD3D0Z_FILTER_TURBO                                31:24 /* -W-SF */
NV_UD3D0Z_FILTER_TURBO          TEXTEQU         <31:24>
;  -W-4R 
;  3135 : #define NV_UD3D0Z_FOG_COLOR                              0x00570310 /* -W-4R */
NV_UD3D0Z_FOG_COLOR             EQU             000570310h
;  -W-UF 
;  3136 : #define NV_UD3D0Z_FOG_COLOR_BLU                                 7:0 /* -W-UF */
NV_UD3D0Z_FOG_COLOR_BLU         TEXTEQU         <7:0>
;  -W-UF 
;  3137 : #define NV_UD3D0Z_FOG_COLOR_GRN                                15:8 /* -W-UF */
NV_UD3D0Z_FOG_COLOR_GRN         TEXTEQU         <15:8>
;  -W-UF 
;  3138 : #define NV_UD3D0Z_FOG_COLOR_RED                               23:16 /* -W-UF */
NV_UD3D0Z_FOG_COLOR_RED         TEXTEQU         <23:16>
;  -W-UF 
;  3139 : #define NV_UD3D0Z_FOG_COLOR_VALUE                              31:0 /* -W-UF */
NV_UD3D0Z_FOG_COLOR_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3140 : #define NV_UD3D0Z_CONTROL_OUT                            0x00570314 /* -W-4R */
NV_UD3D0Z_CONTROL_OUT           EQU             000570314h
;  -W-UF 
;  3141 : #define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR                      1:0 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR              TEXTEQU         <1:0>
;  -W-UV 
;  3142 : #define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH          EQU             000000000h
;  -W-UV 
;  3143 : #define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH_MS               EQU             000000001h
;  -W-UV 
;  3144 : #define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_FOH          EQU             000000002h
;  -W-UF 
;  3145 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U                            5:4 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_WRAP_U            TEXTEQU         <5:4>
;  -W-UV 
;  3146 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_U_CYLINDRICAL                EQU             000000000h
;  -W-UV 
;  3147 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_U_WRAP               EQU             000000001h
;  -W-UV 
;  3148 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_U_MIRROR             EQU             000000002h
;  -W-UV 
;  3149 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_U_CLAMP              EQU             000000003h
;  -W-UF 
;  3150 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V                            7:6 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_WRAP_V            TEXTEQU         <7:6>
;  -W-UV 
;  3151 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_V_CYLINDRICAL                EQU             000000000h
;  -W-UV 
;  3152 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_V_WRAP               EQU             000000001h
;  -W-UV 
;  3153 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_V_MIRROR             EQU             000000002h
;  -W-UV 
;  3154 : #define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_WRAP_V_CLAMP              EQU             000000003h
;  -W-UF 
;  3155 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT              TEXTEQU         <8:8>
;  -W-UV 
;  3156 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8          EQU             000000000h
;  -W-UV 
;  3157 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8          EQU             000000001h
;  -W-UF 
;  3158 : #define NV_UD3D0Z_CONTROL_OUT_CULLING                         13:12 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_CULLING           TEXTEQU         <13:12>
;  -W-UV 
;  3159 : #define NV_UD3D0Z_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_CULLING_NONE              EQU             000000001h
;  -W-UV 
;  3160 : #define NV_UD3D0Z_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_CULLING_CLOCKWISE         EQU             000000002h
;  -W-UV 
;  3161 : #define NV_UD3D0Z_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_CULLING_COUNTERCLOCKWISE          EQU             000000003h
;  -W-UF 
;  3162 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE              TEXTEQU         <19:16>
;  -W-UV 
;  3163 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_FALSE                EQU             000000001h
;  -W-UV 
;  3164 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LT           EQU             000000002h
;  -W-UV 
;  3165 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_EQ           EQU             000000003h
;  -W-UV 
;  3166 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LE           EQU             000000004h
;  -W-UV 
;  3167 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GT           EQU             000000005h
;  -W-UV 
;  3168 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_NE           EQU             000000006h
;  -W-UV 
;  3169 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GE           EQU             000000007h
;  -W-UV 
;  3170 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_TRUE         EQU             000000008h
;  -W-UF 
;  3171 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE                      22:20 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE                TEXTEQU         <22:20>
;  -W-UV 
;  3172 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_NEVER          EQU             000000000h
;  -W-UV 
;  3173 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA          EQU             000000001h
;  -W-UV 
;  3174 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA             EQU             000000002h
;  -W-UV 
;  3175 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ZETA           EQU             000000003h
;  -W-UV 
;  3176 : #define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALWAYS         EQU             000000004h
;  -W-UF 
;  3177 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE                     25:24 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE               TEXTEQU         <25:24>
;  -W-UV 
;  3178 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_NEVER         EQU             000000000h
;  -W-UV 
;  3179 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA         EQU             000000001h
;  -W-UV 
;  3180 : #define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA            EQU             000000002h
;  -W-UF 
;  3181 : #define NV_UD3D0Z_CONTROL_OUT_ROP                             28:28 /* -W-UF */
NV_UD3D0Z_CONTROL_OUT_ROP               TEXTEQU         <28:28>
;  -W-UV 
;  3182 : #define NV_UD3D0Z_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ROP_BLEND_AND             EQU             000000000h
;  -W-UV 
;  3183 : #define NV_UD3D0Z_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
NV_UD3D0Z_CONTROL_OUT_ROP_ADD_WITH_SATURATION           EQU             000000001h
;  -W-4A 
;        
;  3184 : #define NV_UD3D0Z_SPECULAR(i)                   (0x00571000+(i)*32) /* -W-4A */
;  3185 : #define NV_UD3D0Z_SPECULAR__SIZE_1                              128 /*       */
NV_UD3D0Z_SPECULAR__SIZE_1              EQU             128t
;  -W-UF 
;  3186 : #define NV_UD3D0Z_SPECULAR_I0                                   3:0 /* -W-UF */
NV_UD3D0Z_SPECULAR_I0           TEXTEQU         <3:0>
;  -W-UF 
;  3187 : #define NV_UD3D0Z_SPECULAR_I1                                   7:4 /* -W-UF */
NV_UD3D0Z_SPECULAR_I1           TEXTEQU         <7:4>
;  -W-UF 
;  3188 : #define NV_UD3D0Z_SPECULAR_I2                                  11:8 /* -W-UF */
NV_UD3D0Z_SPECULAR_I2           TEXTEQU         <11:8>
;  -W-UF 
;  3189 : #define NV_UD3D0Z_SPECULAR_I3                                 15:12 /* -W-UF */
NV_UD3D0Z_SPECULAR_I3           TEXTEQU         <15:12>
;  -W-UF 
;  3190 : #define NV_UD3D0Z_SPECULAR_I4                                 19:16 /* -W-UF */
NV_UD3D0Z_SPECULAR_I4           TEXTEQU         <19:16>
;  -W-UF 
;  3191 : #define NV_UD3D0Z_SPECULAR_I5                                 23:20 /* -W-UF */
NV_UD3D0Z_SPECULAR_I5           TEXTEQU         <23:20>
;  -W-UF 
;  3192 : #define NV_UD3D0Z_SPECULAR_FOG                                31:24 /* -W-UF */
NV_UD3D0Z_SPECULAR_FOG          TEXTEQU         <31:24>
;  -W-4A 
;        
;  3193 : #define NV_UD3D0Z_COLOR(i)                      (0x00571004+(i)*32) /* -W-4A */
;  3194 : #define NV_UD3D0Z_COLOR__SIZE_1                                 128 /*       */
NV_UD3D0Z_COLOR__SIZE_1         EQU             128t
;  -W-UF 
;  3195 : #define NV_UD3D0Z_COLOR_B8                                      7:0 /* -W-UF */
NV_UD3D0Z_COLOR_B8              TEXTEQU         <7:0>
;  -W-UF 
;  3196 : #define NV_UD3D0Z_COLOR_G8                                     16:8 /* -W-UF */
NV_UD3D0Z_COLOR_G8              TEXTEQU         <16:8>
;  -W-UF 
;  3197 : #define NV_UD3D0Z_COLOR_R8                                    23:16 /* -W-UF */
NV_UD3D0Z_COLOR_R8              TEXTEQU         <23:16>
;  -W-UF 
;  3198 : #define NV_UD3D0Z_COLOR_A8                                    32:24 /* -W-UF */
NV_UD3D0Z_COLOR_A8              TEXTEQU         <32:24>
;  -W-4A 
;        
;  3199 : #define NV_UD3D0Z_X(i)                          (0x00571008+(i)*32) /* -W-4A */
;  3200 : #define NV_UD3D0Z_X__SIZE_1                                     128 /*       */
NV_UD3D0Z_X__SIZE_1             EQU             128t
;  -W-FF 
;  3201 : #define NV_UD3D0Z_X_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_X_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3202 : #define NV_UD3D0Z_Y(i)                          (0x0057100C+(i)*32) /* -W-4A */
;  3203 : #define NV_UD3D0Z_Y__SIZE_1                                     128 /*       */
NV_UD3D0Z_Y__SIZE_1             EQU             128t
;  -W-FF 
;  3204 : #define NV_UD3D0Z_Y_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_Y_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3205 : #define NV_UD3D0Z_Z(i)                          (0x00571010+(i)*32) /* -W-4A */
;  3206 : #define NV_UD3D0Z_Z__SIZE_1                                     128 /*       */
NV_UD3D0Z_Z__SIZE_1             EQU             128t
;  -W-FF 
;  3207 : #define NV_UD3D0Z_Z_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_Z_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3208 : #define NV_UD3D0Z_M(i)                          (0x00571014+(i)*32) /* -W-4A */
;  3209 : #define NV_UD3D0Z_M__SIZE_1                                     128 /*       */
NV_UD3D0Z_M__SIZE_1             EQU             128t
;  -W-FF 
;  3210 : #define NV_UD3D0Z_M_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_M_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3211 : #define NV_UD3D0Z_U(i)                          (0x00571018+(i)*32) /* -W-4A */
;  3212 : #define NV_UD3D0Z_U__SIZE_1                                     128 /*       */
NV_UD3D0Z_U__SIZE_1             EQU             128t
;  -W-FF 
;  3213 : #define NV_UD3D0Z_U_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_U_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3214 : #define NV_UD3D0Z_V(i)                          (0x0057101c+(i)*32) /* -W-4A */
;  3215 : #define NV_UD3D0Z_V__SIZE_1                                     128 /*       */
NV_UD3D0Z_V__SIZE_1             EQU             128t
;  -W-FF 
;  3216 : #define NV_UD3D0Z_V_VALUE                                      31:0 /* -W-FF */
NV_UD3D0Z_V_VALUE               TEXTEQU         <31:0>
;  usr_d3d0_triangle.ref 
;  -W--D 
;  3217 : /* usr_d3d0_triangle.ref */
;  3218 : #define NV_UD3D0                              0x00561FFF:0x00560000 /* -W--D */
NV_UD3D0                TEXTEQU         <0x00561FFF:0x00560000>
;  -W-4R 
;  3219 : #define NV_UD3D0_CTX_SWITCH                              0x00560000 /* -W-4R */
NV_UD3D0_CTX_SWITCH             EQU             000560000h
;  -W-UF 
;  3220 : #define NV_UD3D0_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UD3D0_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3221 : #define NV_UD3D0_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UD3D0_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3222 : #define NV_UD3D0_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UD3D0_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3223 : #define NV_UD3D0_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UD3D0_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3224 : #define NV_UD3D0_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UD3D0_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3225 : #define NV_UD3D0_SET_NOTIFY                              0x00560104 /* -W-4R */
NV_UD3D0_SET_NOTIFY             EQU             000560104h
;  -W-VF 
;  3226 : #define NV_UD3D0_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UD3D0_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3227 : #define NV_UD3D0_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UD3D0_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3228 : #define NV_UD3D0_TEXTURE_OFFSET                          0x00560304 /* -W-4R */
NV_UD3D0_TEXTURE_OFFSET         EQU             000560304h
;  -W-UF 
;  3229 : #define NV_UD3D0_TEXTURE_OFFSET_VALUE                          31:0 /* -W-UF */
NV_UD3D0_TEXTURE_OFFSET_VALUE           TEXTEQU         <31:0>
;  -W-4R 
;  3230 : #define NV_UD3D0_TEXTURE_FORMAT                          0x00560308 /* -W-4R */
NV_UD3D0_TEXTURE_FORMAT         EQU             000560308h
;  -W-UF 
;  3231 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK           15:0 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK            TEXTEQU         <15:0>
;  -W-UF 
;  3232 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY                     16:16 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY               TEXTEQU         <16:16>
;  -W-UV 
;  3233 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_DISABLED       0x00000000 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_DISABLED              EQU             000000000h
;  -W-UV 
;  3234 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_ENABLED        0x00000001 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_KEY_ENABLED               EQU             000000001h
;  -W-UF 
;  3235 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT                  21:20 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT            TEXTEQU         <21:20>
;  -W-UV 
;  3236 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5    0x00000000 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5           EQU             000000000h
;  -W-UV 
;  3237 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5    0x00000001 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5           EQU             000000001h
;  -W-UV 
;  3238 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4    0x00000002 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4           EQU             000000002h
;  -W-UV 
;  3239 : #define NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5      0x00000003 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5             EQU             000000003h
;  -W-UF 
;  3240 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN                      27:24 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN                TEXTEQU         <27:24>
;  -W-UV 
;  3241 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_1X1             0x00000000 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_1X1            EQU             000000000h
;  -W-UV 
;  3242 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_2X2             0x00000001 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_2X2            EQU             000000001h
;  -W-UV 
;  3243 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_4X4             0x00000002 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_4X4            EQU             000000002h
;  -W-UV 
;  3244 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_8X8             0x00000003 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_8X8            EQU             000000003h
;  -W-UV 
;  3245 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_16X16           0x00000004 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_16X16          EQU             000000004h
;  -W-UV 
;  3246 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_32X32           0x00000005 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_32X32          EQU             000000005h
;  -W-UV 
;  3247 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_64X64           0x00000006 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_64X64          EQU             000000006h
;  -W-UV 
;  3248 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_128X128         0x00000007 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_128X128                EQU             000000007h
;  -W-UV 
;  3249 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_256X256         0x00000008 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_256X256                EQU             000000008h
;  -W-UV 
;  3250 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_512X512         0x00000009 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_512X512                EQU             000000009h
;  -W-UV 
;  3251 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_1024X1024       0x0000000a /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_1024X1024              EQU             00000000ah
;  -W-UV 
;  3252 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_2048X2048       0x0000000b /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MIN_2048X2048              EQU             00000000bh
;  -W-UF 
;  3253 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX                      31:28 /* -W-UF */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX                TEXTEQU         <31:28>
;  -W-UV 
;  3254 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_1X1             0x00000000 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_1X1            EQU             000000000h
;  -W-UV 
;  3255 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_2X2             0x00000001 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_2X2            EQU             000000001h
;  -W-UV 
;  3256 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_4X4             0x00000002 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_4X4            EQU             000000002h
;  -W-UV 
;  3257 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_8X8             0x00000003 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_8X8            EQU             000000003h
;  -W-UV 
;  3258 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_16X16           0x00000004 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_16X16          EQU             000000004h
;  -W-UV 
;  3259 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_32X32           0x00000005 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_32X32          EQU             000000005h
;  -W-UV 
;  3260 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_64X64           0x00000006 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_64X64          EQU             000000006h
;  -W-UV 
;  3261 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_128X128         0x00000007 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_128X128                EQU             000000007h
;  -W-UV 
;  3262 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_256X256         0x00000008 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_256X256                EQU             000000008h
;  -W-UV 
;  3263 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_512X512         0x00000009 /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_512X512                EQU             000000009h
;  -W-UV 
;  3264 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_1024X1024       0x0000000a /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_1024X1024              EQU             00000000ah
;  -W-UV 
;  3265 : #define NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_2048X2048       0x0000000b /* -W-UV */
NV_UD3D0_TEXTURE_FORMAT_SIZE_MAX_2048X2048              EQU             00000000bh
;  -W-4R 
;  3266 : #define NV_UD3D0_FILTER                                  0x0056030C /* -W-4R */
NV_UD3D0_FILTER         EQU             00056030ch
;  -W-UF 
;  3267 : #define NV_UD3D0_FILTER_SPREADX                                 7:0 /* -W-UF */
NV_UD3D0_FILTER_SPREADX         TEXTEQU         <7:0>
;  -W-UF 
;  3268 : #define NV_UD3D0_FILTER_SPREADY                                15:8 /* -W-UF */
NV_UD3D0_FILTER_SPREADY         TEXTEQU         <15:8>
;  -W-SF 
;  3269 : #define NV_UD3D0_FILTER_MIPMAP                                23:16 /* -W-SF */
NV_UD3D0_FILTER_MIPMAP          TEXTEQU         <23:16>
;  -W-SF 
;  3270 : #define NV_UD3D0_FILTER_TURBO                                 31:24 /* -W-SF */
NV_UD3D0_FILTER_TURBO           TEXTEQU         <31:24>
;  -W-4R 
;  3271 : #define NV_UD3D0_FOG_COLOR                               0x00560310 /* -W-4R */
NV_UD3D0_FOG_COLOR              EQU             000560310h
;  -W-UF 
;  3272 : #define NV_UD3D0_FOG_COLOR_VALUE                               31:0 /* -W-UF */
NV_UD3D0_FOG_COLOR_VALUE                TEXTEQU         <31:0>
;  -W-4R 
;  3273 : #define NV_UD3D0_CONTROL_OUT                             0x00560314 /* -W-4R */
NV_UD3D0_CONTROL_OUT            EQU             000560314h
;  -W-UF 
;  3274 : #define NV_UD3D0_CONTROL_OUT_INTERPOLATOR                       1:0 /* -W-UF */
NV_UD3D0_CONTROL_OUT_INTERPOLATOR               TEXTEQU         <1:0>
;  -W-UV 
;  3275 : #define NV_UD3D0_CONTROL_OUT_INTERPOLATOR_ZOH            0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_INTERPOLATOR_ZOH           EQU             000000000h
;  -W-UV 
;  3276 : #define NV_UD3D0_CONTROL_OUT_INTERPOLATOR_ZOH_MS         0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_INTERPOLATOR_ZOH_MS                EQU             000000001h
;  -W-UV 
;  3277 : #define NV_UD3D0_CONTROL_OUT_INTERPOLATOR_FOH            0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_INTERPOLATOR_FOH           EQU             000000002h
;  -W-UF 
;  3278 : #define NV_UD3D0_CONTROL_OUT_WRAP_U                             5:4 /* -W-UF */
NV_UD3D0_CONTROL_OUT_WRAP_U             TEXTEQU         <5:4>
;  -W-UV 
;  3279 : #define NV_UD3D0_CONTROL_OUT_WRAP_U_CYLINDRICAL          0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_U_CYLINDRICAL         EQU             000000000h
;  -W-UV 
;  3280 : #define NV_UD3D0_CONTROL_OUT_WRAP_U_WRAP                 0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_U_WRAP                EQU             000000001h
;  -W-UV 
;  3281 : #define NV_UD3D0_CONTROL_OUT_WRAP_U_MIRROR               0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_U_MIRROR              EQU             000000002h
;  -W-UV 
;  3282 : #define NV_UD3D0_CONTROL_OUT_WRAP_U_CLAMP                0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_U_CLAMP               EQU             000000003h
;  -W-UF 
;  3283 : #define NV_UD3D0_CONTROL_OUT_WRAP_V                             7:6 /* -W-UF */
NV_UD3D0_CONTROL_OUT_WRAP_V             TEXTEQU         <7:6>
;  -W-UV 
;  3284 : #define NV_UD3D0_CONTROL_OUT_WRAP_V_CYLINDRICAL          0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_V_CYLINDRICAL         EQU             000000000h
;  -W-UV 
;  3285 : #define NV_UD3D0_CONTROL_OUT_WRAP_V_WRAP                 0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_V_WRAP                EQU             000000001h
;  -W-UV 
;  3286 : #define NV_UD3D0_CONTROL_OUT_WRAP_V_MIRROR               0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_V_MIRROR              EQU             000000002h
;  -W-UV 
;  3287 : #define NV_UD3D0_CONTROL_OUT_WRAP_V_CLAMP                0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_WRAP_V_CLAMP               EQU             000000003h
;  -W-UF 
;  3288 : #define NV_UD3D0_CONTROL_OUT_COLOR_FORMAT                       8:8 /* -W-UF */
NV_UD3D0_CONTROL_OUT_COLOR_FORMAT               TEXTEQU         <8:8>
;  -W-UV 
;  3289 : #define NV_UD3D0_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8    0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8           EQU             000000000h
;  -W-UV 
;  3290 : #define NV_UD3D0_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8    0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8           EQU             000000001h
;  -W-UF 
;  3291 : #define NV_UD3D0_CONTROL_OUT_CULLING                          13:12 /* -W-UF */
NV_UD3D0_CONTROL_OUT_CULLING            TEXTEQU         <13:12>
;  -W-UV 
;  3292 : #define NV_UD3D0_CONTROL_OUT_CULLING_NONE                0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_CULLING_NONE               EQU             000000001h
;  -W-UV 
;  3293 : #define NV_UD3D0_CONTROL_OUT_CULLING_CLOCKWISE           0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_CULLING_CLOCKWISE          EQU             000000002h
;  -W-UV 
;  3294 : #define NV_UD3D0_CONTROL_OUT_CULLING_COUNTERCLOCKWISE    0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_CULLING_COUNTERCLOCKWISE           EQU             000000003h
;  -W-UF 
;  3295 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE                     19:16 /* -W-UF */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE               TEXTEQU         <19:16>
;  -W-UV 
;  3296 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_FALSE          0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_FALSE         EQU             000000001h
;  -W-UV 
;  3297 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_LT             0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_LT            EQU             000000002h
;  -W-UV 
;  3298 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_EQ             0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_EQ            EQU             000000003h
;  -W-UV 
;  3299 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_LE             0x00000004 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_LE            EQU             000000004h
;  -W-UV 
;  3300 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_GT             0x00000005 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_GT            EQU             000000005h
;  -W-UV 
;  3301 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_NE             0x00000006 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_NE            EQU             000000006h
;  -W-UV 
;  3302 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_GE             0x00000007 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_GE            EQU             000000007h
;  -W-UV 
;  3303 : #define NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_TRUE           0x00000008 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_COMPARE_TRUE          EQU             000000008h
;  -W-UF 
;  3304 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE                       22:20 /* -W-UF */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE         TEXTEQU         <22:20>
;  -W-UV 
;  3305 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_NEVER            0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_NEVER           EQU             000000000h
;  -W-UV 
;  3306 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALPHA            0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALPHA           EQU             000000001h
;  -W-UV 
;  3307 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA       0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA              EQU             000000002h
;  -W-UV 
;  3308 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ZETA             0x00000003 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ZETA            EQU             000000003h
;  -W-UV 
;  3309 : #define NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALWAYS           0x00000004 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ZETA_WRITE_ALWAYS          EQU             000000004h
;  -W-UF 
;  3310 : #define NV_UD3D0_CONTROL_OUT_COLOR_WRITE                      25:24 /* -W-UF */
NV_UD3D0_CONTROL_OUT_COLOR_WRITE                TEXTEQU         <25:24>
;  -W-UV 
;  3311 : #define NV_UD3D0_CONTROL_OUT_COLOR_WRITE_NEVER           0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_WRITE_NEVER          EQU             000000000h
;  -W-UV 
;  3312 : #define NV_UD3D0_CONTROL_OUT_COLOR_WRITE_ALPHA           0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_WRITE_ALPHA          EQU             000000001h
;  -W-UV 
;  3313 : #define NV_UD3D0_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
NV_UD3D0_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA             EQU             000000002h
;  -W-UF 
;  3314 : #define NV_UD3D0_CONTROL_OUT_ROP                              28:28 /* -W-UF */
NV_UD3D0_CONTROL_OUT_ROP                TEXTEQU         <28:28>
;  -W-UV 
;  3315 : #define NV_UD3D0_CONTROL_OUT_ROP_BLEND_AND               0x00000000 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ROP_BLEND_AND              EQU             000000000h
;  -W-UV 
;  3316 : #define NV_UD3D0_CONTROL_OUT_ROP_ADD_WITH_SATURATION     0x00000001 /* -W-UV */
NV_UD3D0_CONTROL_OUT_ROP_ADD_WITH_SATURATION            EQU             000000001h
;  -W-4A 
;        
;  3317 : #define NV_UD3D0_SPECULAR(i)                    (0x00561000+(i)*32) /* -W-4A */
;  3318 : #define NV_UD3D0_SPECULAR__SIZE_1                               128 /*       */
NV_UD3D0_SPECULAR__SIZE_1               EQU             128t
;  -W-UF 
;  3319 : #define NV_UD3D0_SPECULAR_I0                                    3:0 /* -W-UF */
NV_UD3D0_SPECULAR_I0            TEXTEQU         <3:0>
;  -W-UF 
;  3320 : #define NV_UD3D0_SPECULAR_I1                                    7:4 /* -W-UF */
NV_UD3D0_SPECULAR_I1            TEXTEQU         <7:4>
;  -W-UF 
;  3321 : #define NV_UD3D0_SPECULAR_I2                                   11:8 /* -W-UF */
NV_UD3D0_SPECULAR_I2            TEXTEQU         <11:8>
;  -W-UF 
;  3322 : #define NV_UD3D0_SPECULAR_I3                                  15:12 /* -W-UF */
NV_UD3D0_SPECULAR_I3            TEXTEQU         <15:12>
;  -W-UF 
;  3323 : #define NV_UD3D0_SPECULAR_I4                                  19:16 /* -W-UF */
NV_UD3D0_SPECULAR_I4            TEXTEQU         <19:16>
;  -W-UF 
;  3324 : #define NV_UD3D0_SPECULAR_I5                                  23:20 /* -W-UF */
NV_UD3D0_SPECULAR_I5            TEXTEQU         <23:20>
;  -W-UF 
;  3325 : #define NV_UD3D0_SPECULAR_FOG                                 31:24 /* -W-UF */
NV_UD3D0_SPECULAR_FOG           TEXTEQU         <31:24>
;  -W-4A 
;        
;  3326 : #define NV_UD3D0_COLOR(i)                       (0x00561004+(i)*32) /* -W-4A */
;  3327 : #define NV_UD3D0_COLOR__SIZE_1                                  128 /*       */
NV_UD3D0_COLOR__SIZE_1          EQU             128t
;  -W-UF 
;  3328 : #define NV_UD3D0_COLOR_B8                                       7:0 /* -W-UF */
NV_UD3D0_COLOR_B8               TEXTEQU         <7:0>
;  -W-UF 
;  3329 : #define NV_UD3D0_COLOR_G8                                      16:8 /* -W-UF */
NV_UD3D0_COLOR_G8               TEXTEQU         <16:8>
;  -W-UF 
;  3330 : #define NV_UD3D0_COLOR_R8                                     23:16 /* -W-UF */
NV_UD3D0_COLOR_R8               TEXTEQU         <23:16>
;  -W-UF 
;  3331 : #define NV_UD3D0_COLOR_A8                                     32:24 /* -W-UF */
NV_UD3D0_COLOR_A8               TEXTEQU         <32:24>
;  -W-4A 
;        
;  3332 : #define NV_UD3D0_X(i)                           (0x00561008+(i)*32) /* -W-4A */
;  3333 : #define NV_UD3D0_X__SIZE_1                                      128 /*       */
NV_UD3D0_X__SIZE_1              EQU             128t
;  -W-FF 
;  3334 : #define NV_UD3D0_X_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_X_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3335 : #define NV_UD3D0_Y(i)                           (0x0056100C+(i)*32) /* -W-4A */
;  3336 : #define NV_UD3D0_Y__SIZE_1                                      128 /*       */
NV_UD3D0_Y__SIZE_1              EQU             128t
;  -W-FF 
;  3337 : #define NV_UD3D0_Y_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_Y_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3338 : #define NV_UD3D0_Z(i)                           (0x00561010+(i)*32) /* -W-4A */
;  3339 : #define NV_UD3D0_Z__SIZE_1                                      128 /*       */
NV_UD3D0_Z__SIZE_1              EQU             128t
;  -W-FF 
;  3340 : #define NV_UD3D0_Z_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_Z_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3341 : #define NV_UD3D0_M(i)                           (0x00561014+(i)*32) /* -W-4A */
;  3342 : #define NV_UD3D0_M__SIZE_1                                      128 /*       */
NV_UD3D0_M__SIZE_1              EQU             128t
;  -W-FF 
;  3343 : #define NV_UD3D0_M_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_M_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3344 : #define NV_UD3D0_U(i)                           (0x00561018+(i)*32) /* -W-4A */
;  3345 : #define NV_UD3D0_U__SIZE_1                                      128 /*       */
NV_UD3D0_U__SIZE_1              EQU             128t
;  -W-FF 
;  3346 : #define NV_UD3D0_U_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_U_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3347 : #define NV_UD3D0_V(i)                           (0x0056101c+(i)*32) /* -W-4A */
;  3348 : #define NV_UD3D0_V__SIZE_1                                      128 /*       */
NV_UD3D0_V__SIZE_1              EQU             128t
;  -W-FF 
;  3349 : #define NV_UD3D0_V_VALUE                                       31:0 /* -W-FF */
NV_UD3D0_V_VALUE                TEXTEQU         <31:0>
;  usr_pattern.ref 
;  -W--D 
;  3350 : /* usr_pattern.ref */
;  3351 : #define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
NV_UPATT                TEXTEQU         <0x00461FFF:0x00460000>
;  -W-4R 
;  3352 : #define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
NV_UPATT_CTX_SWITCH             EQU             000460000h
;  -W-UF 
;  3353 : #define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UPATT_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3354 : #define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UPATT_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3355 : #define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UPATT_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3356 : #define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3357 : #define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UPATT_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3358 : #define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
NV_UPATT_SET_NOTIFY             EQU             000460104h
;  -W-VF 
;  3359 : #define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UPATT_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3360 : #define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UPATT_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3361 : #define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
NV_UPATT_SET_SHAPE              EQU             000460308h
;  -W-VF 
;  3362 : #define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
NV_UPATT_SET_SHAPE_VALUE                TEXTEQU         <1:0>
;  -W--V 
;  3363 : #define NV_UPATT_SET_SHAPE_VALUE_8X8                     0x00000000 /* -W--V */
NV_UPATT_SET_SHAPE_VALUE_8X8            EQU             000000000h
;  -W--V 
;  3364 : #define NV_UPATT_SET_SHAPE_VALUE_64X1                    0x00000001 /* -W--V */
NV_UPATT_SET_SHAPE_VALUE_64X1           EQU             000000001h
;  -W--V 
;  3365 : #define NV_UPATT_SET_SHAPE_VALUE_1X64                    0x00000002 /* -W--V */
NV_UPATT_SET_SHAPE_VALUE_1X64           EQU             000000002h
;  -W-4R 
;  3366 : #define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
NV_UPATT_SET_COLOR0             EQU             000460310h
;  -W-VF 
;  3367 : #define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
NV_UPATT_SET_COLOR0_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3368 : #define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
NV_UPATT_SET_COLOR1             EQU             000460314h
;  -W-VF 
;  3369 : #define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
NV_UPATT_SET_COLOR1_VALUE               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3370 : #define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
;  3371 : #define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
NV_UPATT_SET_PATTERN__SIZE_1            EQU             2t
;  -W-VF 
;  3372 : #define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
NV_UPATT_SET_PATTERN_BITMAP             TEXTEQU         <31:0>
;  usr_point.ref 
;  -W--D 
;  3373 : /* usr_point.ref */
;  3374 : #define NV_UPOINT                             0x00481FFF:0x00480000 /* -W--D */
NV_UPOINT               TEXTEQU         <0x00481FFF:0x00480000>
;  -W-4R 
;  3375 : #define NV_UPOINT_CTX_SWITCH                             0x00480000 /* -W-4R */
NV_UPOINT_CTX_SWITCH            EQU             000480000h
;  -W-UF 
;  3376 : #define NV_UPOINT_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UPOINT_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3377 : #define NV_UPOINT_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UPOINT_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3378 : #define NV_UPOINT_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UPOINT_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3379 : #define NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3380 : #define NV_UPOINT_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UPOINT_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3381 : #define NV_UPOINT_SET_NOTIFY                             0x00480104 /* -W-4R */
NV_UPOINT_SET_NOTIFY            EQU             000480104h
;  -W-VF 
;  3382 : #define NV_UPOINT_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UPOINT_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3383 : #define NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3384 : #define NV_UPOINT_COLOR                                  0x00480304 /* -W-4R */
NV_UPOINT_COLOR         EQU             000480304h
;  -W-VF 
;  3385 : #define NV_UPOINT_COLOR_VALUE                                  31:0 /* -W-VF */
NV_UPOINT_COLOR_VALUE           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3386 : #define NV_UPOINT_POINT(i)                       (0x00480400+(i)*4) /* -W-4A */
;  3387 : #define NV_UPOINT_POINT__SIZE_1                                  32 /*       */
NV_UPOINT_POINT__SIZE_1         EQU             32t
;  -W-SF 
;  3388 : #define NV_UPOINT_POINT_X                                      15:0 /* -W-SF */
NV_UPOINT_POINT_X               TEXTEQU         <15:0>
;  -W-SF 
;  3389 : #define NV_UPOINT_POINT_Y                                     31:16 /* -W-SF */
NV_UPOINT_POINT_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3390 : #define NV_UPOINT_POINT32_0(i)                   (0x00480480+(i)*8) /* -W-4A */
;  3391 : #define NV_UPOINT_POINT32_0__SIZE_1                              16 /*       */
NV_UPOINT_POINT32_0__SIZE_1             EQU             16t
;  -W-SF 
;  3392 : #define NV_UPOINT_POINT32_0_X                                  31:0 /* -W-SF */
NV_UPOINT_POINT32_0_X           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3393 : #define NV_UPOINT_POINT32_1(i)                   (0x00480484+(i)*8) /* -W-4A */
;  3394 : #define NV_UPOINT_POINT32_1__SIZE_1                              16 /*       */
NV_UPOINT_POINT32_1__SIZE_1             EQU             16t
;  -W-SF 
;  3395 : #define NV_UPOINT_POINT32_1_Y                                  31:0 /* -W-SF */
NV_UPOINT_POINT32_1_Y           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3396 : #define NV_UPOINT_CPOINT_0(i)                    (0x00480500+(i)*8) /* -W-4A */
;  3397 : #define NV_UPOINT_CPOINT_0__SIZE_1                               16 /*       */
NV_UPOINT_CPOINT_0__SIZE_1              EQU             16t
;  -W-VF 
;  3398 : #define NV_UPOINT_CPOINT_0_COLOR                               31:0 /* -W-VF */
NV_UPOINT_CPOINT_0_COLOR                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3399 : #define NV_UPOINT_CPOINT_1(i)                    (0x00480504+(i)*8) /* -W-4A */
;  3400 : #define NV_UPOINT_CPOINT_1__SIZE_1                               16 /*       */
NV_UPOINT_CPOINT_1__SIZE_1              EQU             16t
;  -W-SF 
;  3401 : #define NV_UPOINT_CPOINT_1_X                                   15:0 /* -W-SF */
NV_UPOINT_CPOINT_1_X            TEXTEQU         <15:0>
;  -W-SF 
;  3402 : #define NV_UPOINT_CPOINT_1_Y                                  31:16 /* -W-SF */
NV_UPOINT_CPOINT_1_Y            TEXTEQU         <31:16>
;  usr_pointz.ref 
;  -W--D 
;  3403 : /* usr_pointz.ref */
;  3404 : #define NV_UPOINTZ                            0x00581FFF:0x00580000 /* -W--D */
NV_UPOINTZ              TEXTEQU         <0x00581FFF:0x00580000>
;  -W-4R 
;  3405 : #define NV_UPOINTZ_CTX_SWITCH                            0x00580000 /* -W-4R */
NV_UPOINTZ_CTX_SWITCH           EQU             000580000h
;  -W-UF 
;  3406 : #define NV_UPOINTZ_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UPOINTZ_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3407 : #define NV_UPOINTZ_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UPOINTZ_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3408 : #define NV_UPOINTZ_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UPOINTZ_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3409 : #define NV_UPOINTZ_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UPOINTZ_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3410 : #define NV_UPOINTZ_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UPOINTZ_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3411 : #define NV_UPOINTZ_SET_NOTIFY                            0x00580104 /* -W-4R */
NV_UPOINTZ_SET_NOTIFY           EQU             000580104h
;  -W-VF 
;  3412 : #define NV_UPOINTZ_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UPOINTZ_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3413 : #define NV_UPOINTZ_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UPOINTZ_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3414 : #define NV_UPOINTZ_CONTROL_OUT                           0x00580304 /* -W-4R */
NV_UPOINTZ_CONTROL_OUT          EQU             000580304h
;  -W-UF 
;  3415 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE                   19:16 /* -W-UF */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE             TEXTEQU         <19:16>
;  -W-UV 
;  3416 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_FALSE        0x00000001 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_FALSE               EQU             000000001h
;  -W-UV 
;  3417 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LT           0x00000002 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LT          EQU             000000002h
;  -W-UV 
;  3418 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_EQ           0x00000003 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_EQ          EQU             000000003h
;  -W-UV 
;  3419 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LE           0x00000004 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LE          EQU             000000004h
;  -W-UV 
;  3420 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GT           0x00000005 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GT          EQU             000000005h
;  -W-UV 
;  3421 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_NE           0x00000006 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_NE          EQU             000000006h
;  -W-UV 
;  3422 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GE           0x00000007 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GE          EQU             000000007h
;  -W-UV 
;  3423 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_TRUE         0x00000008 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_TRUE                EQU             000000008h
;  -W-UF 
;  3424 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE                     22:20 /* -W-UF */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE               TEXTEQU         <22:20>
;  -W-UV 
;  3425 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_NEVER          0x00000000 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_NEVER         EQU             000000000h
;  -W-UV 
;  3426 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA          0x00000001 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA         EQU             000000001h
;  -W-UV 
;  3427 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA            EQU             000000002h
;  -W-UV 
;  3428 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ZETA           0x00000003 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ZETA          EQU             000000003h
;  -W-UV 
;  3429 : #define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALWAYS         0x00000004 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALWAYS                EQU             000000004h
;  -W-UF 
;  3430 : #define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE                    25:24 /* -W-UF */
NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE              TEXTEQU         <25:24>
;  -W-UV 
;  3431 : #define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_NEVER         0x00000000 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_NEVER                EQU             000000000h
;  -W-UV 
;  3432 : #define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA         0x00000001 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA                EQU             000000001h
;  -W-UV 
;  3433 : #define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA    0x00000002 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA           EQU             000000002h
;  -W-UF 
;  3434 : #define NV_UPOINTZ_CONTROL_OUT_ROP                            28:28 /* -W-UF */
NV_UPOINTZ_CONTROL_OUT_ROP              TEXTEQU         <28:28>
;  -W-UV 
;  3435 : #define NV_UPOINTZ_CONTROL_OUT_ROP_BLEND_AND             0x00000000 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ROP_BLEND_AND            EQU             000000000h
;  -W-UV 
;  3436 : #define NV_UPOINTZ_CONTROL_OUT_ROP_ADD_WITH_SATURATION   0x00000001 /* -W-UV */
NV_UPOINTZ_CONTROL_OUT_ROP_ADD_WITH_SATURATION          EQU             000000001h
;  -W-4R 
;  3437 : #define NV_UPOINTZ_POINT                                 0x005807FC /* -W-4R */
NV_UPOINTZ_POINT                EQU             0005807fch
;  -W-SF 
;  3438 : #define NV_UPOINTZ_POINT_X                                     15:0 /* -W-SF */
NV_UPOINTZ_POINT_X              TEXTEQU         <15:0>
;  -W-SF 
;  3439 : #define NV_UPOINTZ_POINT_Y                                    31:16 /* -W-SF */
NV_UPOINTZ_POINT_Y              TEXTEQU         <31:16>
;  -W-4A 
;        
;  3440 : #define NV_UPOINTZ_COLOR(i)                      (0x00580800+(i)*8) /* -W-4A */
;  3441 : #define NV_UPOINTZ_COLOR__SIZE_1                                256 /*       */
NV_UPOINTZ_COLOR__SIZE_1                EQU             256t
;  -W-VF 
;  3442 : #define NV_UPOINTZ_COLOR_VALUE                                 31:0 /* -W-VF */
NV_UPOINTZ_COLOR_VALUE          TEXTEQU         <31:0>
;  -W-4A 
;        
;  3443 : #define NV_UPOINTZ_ZETA(i)                       (0x00580804+(i)*8) /* -W-4A */
;  3444 : #define NV_UPOINTZ_ZETA__SIZE_1                                 256 /*       */
NV_UPOINTZ_ZETA__SIZE_1         EQU             256t
;  -W-VF 
;  3445 : #define NV_UPOINTZ_ZETA_VALUE                                  31:0 /* -W-VF */
NV_UPOINTZ_ZETA_VALUE           TEXTEQU         <31:0>
;  usr_line.ref 
;  -W--D 
;  3446 : /* usr_line.ref */
;  3447 : #define NV_ULINE                              0x00491FFF:0x00490000 /* -W--D */
NV_ULINE                TEXTEQU         <0x00491FFF:0x00490000>
;  -W-4R 
;  3448 : #define NV_ULINE_CTX_SWITCH                              0x00490000 /* -W-4R */
NV_ULINE_CTX_SWITCH             EQU             000490000h
;  -W-UF 
;  3449 : #define NV_ULINE_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_ULINE_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3450 : #define NV_ULINE_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_ULINE_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3451 : #define NV_ULINE_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_ULINE_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3452 : #define NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3453 : #define NV_ULINE_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_ULINE_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3454 : #define NV_ULINE_SET_NOTIFY                              0x00490104 /* -W-4R */
NV_ULINE_SET_NOTIFY             EQU             000490104h
;  -W-VF 
;  3455 : #define NV_ULINE_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_ULINE_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3456 : #define NV_ULINE_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_ULINE_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3457 : #define NV_ULINE_COLOR                                   0x00490304 /* -W-4R */
NV_ULINE_COLOR          EQU             000490304h
;  -W-VF 
;  3458 : #define NV_ULINE_COLOR_VALUE                                   31:0 /* -W-VF */
NV_ULINE_COLOR_VALUE            TEXTEQU         <31:0>
;  -W-4A 
;        
;  3459 : #define NV_ULINE_LINE_0(i)                       (0x00490400+(i)*8) /* -W-4A */
;  3460 : #define NV_ULINE_LINE_0__SIZE_1                                  16 /*       */
NV_ULINE_LINE_0__SIZE_1         EQU             16t
;  -W-SF 
;  3461 : #define NV_ULINE_LINE_0_X                                      15:0 /* -W-SF */
NV_ULINE_LINE_0_X               TEXTEQU         <15:0>
;  -W-SF 
;  3462 : #define NV_ULINE_LINE_0_Y                                     31:16 /* -W-SF */
NV_ULINE_LINE_0_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3463 : #define NV_ULINE_LINE_1(i)                       (0x00490404+(i)*8) /* -W-4A */
;  3464 : #define NV_ULINE_LINE_1__SIZE_1                                  16 /*       */
NV_ULINE_LINE_1__SIZE_1         EQU             16t
;  -W-SF 
;  3465 : #define NV_ULINE_LINE_1_X                                      15:0 /* -W-SF */
NV_ULINE_LINE_1_X               TEXTEQU         <15:0>
;  -W-SF 
;  3466 : #define NV_ULINE_LINE_1_Y                                     31:16 /* -W-SF */
NV_ULINE_LINE_1_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3467 : #define NV_ULINE_LINE32_0(i)                    (0x00490480+(i)*16) /* -W-4A */
;  3468 : #define NV_ULINE_LINE32_0__SIZE_1                                 8 /*       */
NV_ULINE_LINE32_0__SIZE_1               EQU             8t
;  -W-SF 
;  3469 : #define NV_ULINE_LINE32_0_X                                    31:0 /* -W-SF */
NV_ULINE_LINE32_0_X             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3470 : #define NV_ULINE_LINE32_1(i)                    (0x00490484+(i)*16) /* -W-4A */
;  3471 : #define NV_ULINE_LINE32_1__SIZE_1                                 8 /*       */
NV_ULINE_LINE32_1__SIZE_1               EQU             8t
;  -W-SF 
;  3472 : #define NV_ULINE_LINE32_1_Y                                    31:0 /* -W-SF */
NV_ULINE_LINE32_1_Y             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3473 : #define NV_ULINE_LINE32_2(i)                    (0x00490488+(i)*16) /* -W-4A */
;  3474 : #define NV_ULINE_LINE32_2__SIZE_1                                 8 /*       */
NV_ULINE_LINE32_2__SIZE_1               EQU             8t
;  -W-SF 
;  3475 : #define NV_ULINE_LINE32_2_X                                    31:0 /* -W-SF */
NV_ULINE_LINE32_2_X             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3476 : #define NV_ULINE_LINE32_3(i)                    (0x0049048C+(i)*16) /* -W-4A */
;  3477 : #define NV_ULINE_LINE32_3__SIZE_1                                 8 /*       */
NV_ULINE_LINE32_3__SIZE_1               EQU             8t
;  -W-SF 
;  3478 : #define NV_ULINE_LINE32_3_Y                                    31:0 /* -W-SF */
NV_ULINE_LINE32_3_Y             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3479 : #define NV_ULINE_POLYLINE(i)                     (0x00490500+(i)*4) /* -W-4A */
;  3480 : #define NV_ULINE_POLYLINE__SIZE_1                                32 /*       */
NV_ULINE_POLYLINE__SIZE_1               EQU             32t
;  -W-SF 
;  3481 : #define NV_ULINE_POLYLINE_X                                    15:0 /* -W-SF */
NV_ULINE_POLYLINE_X             TEXTEQU         <15:0>
;  -W-SF 
;  3482 : #define NV_ULINE_POLYLINE_Y                                   31:16 /* -W-SF */
NV_ULINE_POLYLINE_Y             TEXTEQU         <31:16>
;  -W-4A 
;        
;  3483 : #define NV_ULINE_POLYLINE32_0(i)                 (0x00490580+(i)*8) /* -W-4A */
;  3484 : #define NV_ULINE_POLYLINE32_0__SIZE_1                            16 /*       */
NV_ULINE_POLYLINE32_0__SIZE_1           EQU             16t
;  -W-SF 
;  3485 : #define NV_ULINE_POLYLINE32_0_X                                31:0 /* -W-SF */
NV_ULINE_POLYLINE32_0_X         TEXTEQU         <31:0>
;  -W-4A 
;        
;  3486 : #define NV_ULINE_POLYLINE32_1(i)                 (0x00490584+(i)*8) /* -W-4A */
;  3487 : #define NV_ULINE_POLYLINE32_1__SIZE_1                            16 /*       */
NV_ULINE_POLYLINE32_1__SIZE_1           EQU             16t
;  -W-SF 
;  3488 : #define NV_ULINE_POLYLINE32_1_Y                                31:0 /* -W-SF */
NV_ULINE_POLYLINE32_1_Y         TEXTEQU         <31:0>
;  -W-4A 
;        
;  3489 : #define NV_ULINE_CPOLYLINE_0(i)                  (0x00490600+(i)*8) /* -W-4A */
;  3490 : #define NV_ULINE_CPOLYLINE_0__SIZE_1                             16 /*       */
NV_ULINE_CPOLYLINE_0__SIZE_1            EQU             16t
;  -W-VF 
;  3491 : #define NV_ULINE_CPOLYLINE_0_COLOR                             31:0 /* -W-VF */
NV_ULINE_CPOLYLINE_0_COLOR              TEXTEQU         <31:0>
;  -W-4A 
;        
;  3492 : #define NV_ULINE_CPOLYLINE_1(i)                  (0x00490604+(i)*8) /* -W-4A */
;  3493 : #define NV_ULINE_CPOLYLINE_1__SIZE_1                             16 /*       */
NV_ULINE_CPOLYLINE_1__SIZE_1            EQU             16t
;  -W-SF 
;  3494 : #define NV_ULINE_CPOLYLINE_1_X                                 15:0 /* -W-SF */
NV_ULINE_CPOLYLINE_1_X          TEXTEQU         <15:0>
;  -W-SF 
;  3495 : #define NV_ULINE_CPOLYLINE_1_Y                                31:16 /* -W-SF */
NV_ULINE_CPOLYLINE_1_Y          TEXTEQU         <31:16>
;  usr_lin.ref 
;  -W--D 
;  3496 : /* usr_lin.ref */
;  3497 : #define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
NV_ULIN         TEXTEQU         <0x004A1FFF:0x004A0000>
;  -W-4R 
;  3498 : #define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
NV_ULIN_CTX_SWITCH              EQU             0004a0000h
;  -W-UF 
;  3499 : #define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
NV_ULIN_CTX_SWITCH_INSTANCE             TEXTEQU         <15:0>
;  -W-UF 
;  3500 : #define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
NV_ULIN_CTX_SWITCH_CHID         TEXTEQU         <22:16>
;  -W-VF 
;  3501 : #define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
NV_ULIN_CTX_SWITCH_VOLATILE             TEXTEQU         <31:31>
;  -W--V 
;  3502 : #define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE              EQU             000000000h
;  -W--V 
;  3503 : #define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
NV_ULIN_CTX_SWITCH_VOLATILE_RESET               EQU             000000001h
;  -W-4R 
;  3504 : #define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
NV_ULIN_SET_NOTIFY              EQU             0004a0104h
;  -W-VF 
;  3505 : #define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
NV_ULIN_SET_NOTIFY_PARAMETER            TEXTEQU         <31:0>
;  -W--V 
;  3506 : #define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
NV_ULIN_SET_NOTIFY_PARAMETER_WRITE              EQU             000000000h
;  -W-4R 
;  3507 : #define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
NV_ULIN_COLOR           EQU             0004a0304h
;  -W-VF 
;  3508 : #define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
NV_ULIN_COLOR_VALUE             TEXTEQU         <31:0>
;  -W-4A 
;        
;  3509 : #define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
;  3510 : #define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
NV_ULIN_LIN_0__SIZE_1           EQU             16t
;  -W-SF 
;  3511 : #define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
NV_ULIN_LIN_0_X         TEXTEQU         <15:0>
;  -W-SF 
;  3512 : #define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
NV_ULIN_LIN_0_Y         TEXTEQU         <31:16>
;  -W-4A 
;        
;  3513 : #define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
;  3514 : #define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
NV_ULIN_LIN_1__SIZE_1           EQU             16t
;  -W-SF 
;  3515 : #define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
NV_ULIN_LIN_1_X         TEXTEQU         <15:0>
;  -W-SF 
;  3516 : #define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
NV_ULIN_LIN_1_Y         TEXTEQU         <31:16>
;  -W-4A 
;        
;  3517 : #define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
;  3518 : #define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
NV_ULIN_LIN32_0__SIZE_1         EQU             8t
;  -W-SF 
;  3519 : #define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
NV_ULIN_LIN32_0_X               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3520 : #define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
;  3521 : #define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
NV_ULIN_LIN32_1__SIZE_1         EQU             8t
;  -W-SF 
;  3522 : #define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
NV_ULIN_LIN32_1_Y               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3523 : #define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
;  3524 : #define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
NV_ULIN_LIN32_2__SIZE_1         EQU             8t
;  -W-SF 
;  3525 : #define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
NV_ULIN_LIN32_2_X               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3526 : #define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
;  3527 : #define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
NV_ULIN_LIN32_3__SIZE_1         EQU             8t
;  -W-SF 
;  3528 : #define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
NV_ULIN_LIN32_3_Y               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3529 : #define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
;  3530 : #define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
NV_ULIN_POLYLIN__SIZE_1         EQU             32t
;  -W-SF 
;  3531 : #define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
NV_ULIN_POLYLIN_X               TEXTEQU         <15:0>
;  -W-SF 
;  3532 : #define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
NV_ULIN_POLYLIN_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3533 : #define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
;  3534 : #define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
NV_ULIN_POLYLIN32_0__SIZE_1             EQU             16t
;  -W-SF 
;  3535 : #define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
NV_ULIN_POLYLIN32_0_X           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3536 : #define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
;  3537 : #define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
NV_ULIN_POLYLIN32_1__SIZE_1             EQU             16t
;  -W-SF 
;  3538 : #define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
NV_ULIN_POLYLIN32_1_Y           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3539 : #define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
;  3540 : #define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
NV_ULIN_CPOLYLIN_0__SIZE_1              EQU             16t
;  -W-VF 
;  3541 : #define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
NV_ULIN_CPOLYLIN_0_COLOR                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3542 : #define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
;  3543 : #define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
NV_ULIN_CPOLYLIN_1__SIZE_1              EQU             16t
;  -W-SF 
;  3544 : #define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
NV_ULIN_CPOLYLIN_1_X            TEXTEQU         <15:0>
;  -W-SF 
;  3545 : #define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
NV_ULIN_CPOLYLIN_1_Y            TEXTEQU         <31:16>
;  usr_mem_to_mem.ref 
;  -W--D 
;  3546 : /* usr_mem_to_mem.ref */
;  3547 : #define NV_UMEMFMT                            0x004D1FFF:0x004D0000 /* -W--D */
NV_UMEMFMT              TEXTEQU         <0x004D1FFF:0x004D0000>
;  -W-4R 
;  3548 : #define NV_UMEMFMT_CTX_SWITCH                            0x004D0000 /* -W-4R */
NV_UMEMFMT_CTX_SWITCH           EQU             0004d0000h
;  -W-UF 
;  3549 : #define NV_UMEMFMT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UMEMFMT_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3550 : #define NV_UMEMFMT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UMEMFMT_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3551 : #define NV_UMEMFMT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UMEMFMT_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3552 : #define NV_UMEMFMT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UMEMFMT_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3553 : #define NV_UMEMFMT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UMEMFMT_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3554 : #define NV_UMEMFMT_SET_NOTIFY                            0x004D0104 /* -W-4R */
NV_UMEMFMT_SET_NOTIFY           EQU             0004d0104h
;  -W-VF 
;  3555 : #define NV_UMEMFMT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UMEMFMT_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3556 : #define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3557 : #define NV_UMEMFMT_OFFSET_IN                             0x004D030C /* -W-4R */
NV_UMEMFMT_OFFSET_IN            EQU             0004d030ch
;  -W-UF 
;  3558 : #define NV_UMEMFMT_OFFSET_IN_VALUE                             31:0 /* -W-UF */
NV_UMEMFMT_OFFSET_IN_VALUE              TEXTEQU         <31:0>
;  -W-4R 
;  3559 : #define NV_UMEMFMT_OFFSET_OUT                            0x004D0310 /* -W-4R */
NV_UMEMFMT_OFFSET_OUT           EQU             0004d0310h
;  -W-UF 
;  3560 : #define NV_UMEMFMT_OFFSET_OUT_VALUE                            31:0 /* -W-UF */
NV_UMEMFMT_OFFSET_OUT_VALUE             TEXTEQU         <31:0>
;  -W-4R 
;  3561 : #define NV_UMEMFMT_PITCH_IN                              0x004D0314 /* -W-4R */
NV_UMEMFMT_PITCH_IN             EQU             0004d0314h
;  -W-SF 
;  3562 : #define NV_UMEMFMT_PITCH_IN_VALUE                              31:0 /* -W-SF */
NV_UMEMFMT_PITCH_IN_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3563 : #define NV_UMEMFMT_PITCH_OUT                             0x004D0318 /* -W-4R */
NV_UMEMFMT_PITCH_OUT            EQU             0004d0318h
;  -W-SF 
;  3564 : #define NV_UMEMFMT_PITCH_OUT_VALUE                             31:0 /* -W-SF */
NV_UMEMFMT_PITCH_OUT_VALUE              TEXTEQU         <31:0>
;  -W-4R 
;  3565 : #define NV_UMEMFMT_LINE_LENGTH_IN                        0x004D031C /* -W-4R */
NV_UMEMFMT_LINE_LENGTH_IN               EQU             0004d031ch
;  -W-UF 
;  3566 : #define NV_UMEMFMT_LINE_LENGTH_IN_VALUE                        31:0 /* -W-UF */
NV_UMEMFMT_LINE_LENGTH_IN_VALUE         TEXTEQU         <31:0>
;  -W-4R 
;  3567 : #define NV_UMEMFMT_LINE_COUNT                            0x004D0320 /* -W-4R */
NV_UMEMFMT_LINE_COUNT           EQU             0004d0320h
;  -W-UF 
;  3568 : #define NV_UMEMFMT_LINE_COUNT_VALUE                            31:0 /* -W-UF */
NV_UMEMFMT_LINE_COUNT_VALUE             TEXTEQU         <31:0>
;  -W-4R 
;  3569 : #define NV_UMEMFMT_FORMAT                                0x004D0324 /* -W-4R */
NV_UMEMFMT_FORMAT               EQU             0004d0324h
;  -W-UF 
;  3570 : #define NV_UMEMFMT_FORMAT_INPUT_INC                             2:0 /* -W-UF */
NV_UMEMFMT_FORMAT_INPUT_INC             TEXTEQU         <2:0>
;  -WIUV 
;  3571 : #define NV_UMEMFMT_FORMAT_INPUT_INC_1                    0x00000001 /* -WIUV */
NV_UMEMFMT_FORMAT_INPUT_INC_1           EQU             000000001h
;  -W-UV 
;  3572 : #define NV_UMEMFMT_FORMAT_INPUT_INC_2                    0x00000002 /* -W-UV */
NV_UMEMFMT_FORMAT_INPUT_INC_2           EQU             000000002h
;  -W-UV 
;  3573 : #define NV_UMEMFMT_FORMAT_INPUT_INC_4                    0x00000004 /* -W-UV */
NV_UMEMFMT_FORMAT_INPUT_INC_4           EQU             000000004h
;  -W-UF 
;  3574 : #define NV_UMEMFMT_FORMAT_OUTPUT_INC                           10:8 /* -W-UF */
NV_UMEMFMT_FORMAT_OUTPUT_INC            TEXTEQU         <10:8>
;  -WIUV 
;  3575 : #define NV_UMEMFMT_FORMAT_OUTPUT_INC_1                   0x00000001 /* -WIUV */
NV_UMEMFMT_FORMAT_OUTPUT_INC_1          EQU             000000001h
;  -W-UV 
;  3576 : #define NV_UMEMFMT_FORMAT_OUTPUT_INC_2                   0x00000002 /* -W-UV */
NV_UMEMFMT_FORMAT_OUTPUT_INC_2          EQU             000000002h
;  -W-UV 
;  3577 : #define NV_UMEMFMT_FORMAT_OUTPUT_INC_4                   0x00000004 /* -W-UV */
NV_UMEMFMT_FORMAT_OUTPUT_INC_4          EQU             000000004h
;  -W-4R 
;  3578 : #define NV_UMEMFMT_BUF_NOTIFY                            0x004D0328 /* -W-4R */
NV_UMEMFMT_BUF_NOTIFY           EQU             0004d0328h
;  -W-UF 
;  3579 : #define NV_UMEMFMT_BUF_NOTIFY_VALUE                            31:0 /* -W-UF */
NV_UMEMFMT_BUF_NOTIFY_VALUE             TEXTEQU         <31:0>
;  usr_triangle.ref 
;  -W--D 
;  3580 : /* usr_triangle.ref */
;  3581 : #define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
NV_UTRI         TEXTEQU         <0x004B1FFF:0x004B0000>
;  -W-4R 
;  3582 : #define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
NV_UTRI_CTX_SWITCH              EQU             0004b0000h
;  -W-UF 
;  3583 : #define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
NV_UTRI_CTX_SWITCH_INSTANCE             TEXTEQU         <15:0>
;  -W-UF 
;  3584 : #define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
NV_UTRI_CTX_SWITCH_CHID         TEXTEQU         <22:16>
;  -W-VF 
;  3585 : #define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
NV_UTRI_CTX_SWITCH_VOLATILE             TEXTEQU         <31:31>
;  -W--V 
;  3586 : #define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE              EQU             000000000h
;  -W--V 
;  3587 : #define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
NV_UTRI_CTX_SWITCH_VOLATILE_RESET               EQU             000000001h
;  -W-4R 
;  3588 : #define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
NV_UTRI_SET_NOTIFY              EQU             0004b0104h
;  -W-VF 
;  3589 : #define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
NV_UTRI_SET_NOTIFY_PARAMETER            TEXTEQU         <31:0>
;  -W--V 
;  3590 : #define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
NV_UTRI_SET_NOTIFY_PARAMETER_WRITE              EQU             000000000h
;  -W-4R 
;  3591 : #define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
NV_UTRI_COLOR           EQU             0004b0304h
;  -W-VF 
;  3592 : #define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
NV_UTRI_COLOR_VALUE             TEXTEQU         <31:0>
;  -W-4R 
;  3593 : #define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
NV_UTRI_TRIANGLE_0              EQU             0004b0310h
;  -W-SF 
;  3594 : #define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
NV_UTRI_TRIANGLE_0_X            TEXTEQU         <15:0>
;  -W-SF 
;  3595 : #define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
NV_UTRI_TRIANGLE_0_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3596 : #define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
NV_UTRI_TRIANGLE_1              EQU             0004b0314h
;  -W-SF 
;  3597 : #define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
NV_UTRI_TRIANGLE_1_X            TEXTEQU         <15:0>
;  -W-SF 
;  3598 : #define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
NV_UTRI_TRIANGLE_1_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3599 : #define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
NV_UTRI_TRIANGLE_2              EQU             0004b0318h
;  -W-SF 
;  3600 : #define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
NV_UTRI_TRIANGLE_2_X            TEXTEQU         <15:0>
;  -W-SF 
;  3601 : #define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
NV_UTRI_TRIANGLE_2_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3602 : #define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
NV_UTRI_TRIANGLE32_0            EQU             0004b0320h
;  -W-SF 
;  3603 : #define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_0_X          TEXTEQU         <31:0>
;  -W-4R 
;  3604 : #define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
NV_UTRI_TRIANGLE32_1            EQU             0004b0324h
;  -W-SF 
;  3605 : #define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_1_Y          TEXTEQU         <31:0>
;  -W-4R 
;  3606 : #define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
NV_UTRI_TRIANGLE32_2            EQU             0004b0328h
;  -W-SF 
;  3607 : #define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_2_X          TEXTEQU         <31:0>
;  -W-4R 
;  3608 : #define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
NV_UTRI_TRIANGLE32_3            EQU             0004b032ch
;  -W-SF 
;  3609 : #define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_3_Y          TEXTEQU         <31:0>
;  -W-4R 
;  3610 : #define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
NV_UTRI_TRIANGLE32_4            EQU             0004b0330h
;  -W-SF 
;  3611 : #define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_4_X          TEXTEQU         <31:0>
;  -W-4R 
;  3612 : #define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
NV_UTRI_TRIANGLE32_5            EQU             0004b0334h
;  -W-SF 
;  3613 : #define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
NV_UTRI_TRIANGLE32_5_Y          TEXTEQU         <31:0>
;  -W-4A 
;        
;  3614 : #define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
;  3615 : #define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
NV_UTRI_TRIMESH__SIZE_1         EQU             32t
;  -W-SF 
;  3616 : #define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
NV_UTRI_TRIMESH_X               TEXTEQU         <15:0>
;  -W-SF 
;  3617 : #define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
NV_UTRI_TRIMESH_Y               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3618 : #define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
;  3619 : #define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
NV_UTRI_TRIMESH32_0__SIZE_1             EQU             16t
;  -W-SF 
;  3620 : #define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
NV_UTRI_TRIMESH32_0_X           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3621 : #define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
;  3622 : #define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
NV_UTRI_TRIMESH32_1__SIZE_1             EQU             16t
;  -W-SF 
;  3623 : #define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
NV_UTRI_TRIMESH32_1_Y           TEXTEQU         <31:0>
;  -W-4A 
;        
;  3624 : #define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
;  3625 : #define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
NV_UTRI_CTRIANGLE_0__SIZE_1             EQU             8t
;  -W-VF 
;  3626 : #define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
NV_UTRI_CTRIANGLE_0_COLOR               TEXTEQU         <31:0>
;  -W-4A 
;        
;  3627 : #define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
;  3628 : #define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
NV_UTRI_CTRIANGLE_1__SIZE_1             EQU             8t
;  -W-SF 
;  3629 : #define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
NV_UTRI_CTRIANGLE_1_X           TEXTEQU         <15:0>
;  -W-SF 
;  3630 : #define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
NV_UTRI_CTRIANGLE_1_Y           TEXTEQU         <31:16>
;  -W-4A 
;        
;  3631 : #define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
;  3632 : #define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
NV_UTRI_CTRIANGLE_2__SIZE_1             EQU             8t
;  -W-SF 
;  3633 : #define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
NV_UTRI_CTRIANGLE_2_X           TEXTEQU         <15:0>
;  -W-SF 
;  3634 : #define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
NV_UTRI_CTRIANGLE_2_Y           TEXTEQU         <31:16>
;  -W-4A 
;        
;  3635 : #define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
;  3636 : #define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
NV_UTRI_CTRIANGLE_3__SIZE_1             EQU             8t
;  -W-SF 
;  3637 : #define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
NV_UTRI_CTRIANGLE_3_X           TEXTEQU         <15:0>
;  -W-SF 
;  3638 : #define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
NV_UTRI_CTRIANGLE_3_Y           TEXTEQU         <31:16>
;  -W-4A 
;        
;  3639 : #define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
;  3640 : #define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
NV_UTRI_CTRIMESH_0__SIZE_1              EQU             16t
;  -W-VF 
;  3641 : #define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
NV_UTRI_CTRIMESH_0_COLOR                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3642 : #define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
;  3643 : #define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
NV_UTRI_CTRIMESH_1__SIZE_1              EQU             16t
;  -W-SF 
;  3644 : #define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
NV_UTRI_CTRIMESH_1_X            TEXTEQU         <15:0>
;  -W-SF 
;  3645 : #define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
NV_UTRI_CTRIMESH_1_Y            TEXTEQU         <31:16>
;  usr_rectangle.ref 
;  -W--D 
;  3646 : /* usr_rectangle.ref */
;  3647 : #define NV_URECT                              0x00471FFF:0x00470000 /* -W--D */
NV_URECT                TEXTEQU         <0x00471FFF:0x00470000>
;  -W-4R 
;  3648 : #define NV_URECT_CTX_SWITCH                              0x00470000 /* -W-4R */
NV_URECT_CTX_SWITCH             EQU             000470000h
;  -W-UF 
;  3649 : #define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_URECT_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3650 : #define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_URECT_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3651 : #define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_URECT_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3652 : #define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_URECT_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3653 : #define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_URECT_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3654 : #define NV_URECT_SET_NOTIFY                              0x00470104 /* -W-4R */
NV_URECT_SET_NOTIFY             EQU             000470104h
;  -W-VF 
;  3655 : #define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_URECT_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3656 : #define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_URECT_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3657 : #define NV_URECT_COLOR                                   0x00470304 /* -W-4R */
NV_URECT_COLOR          EQU             000470304h
;  -W-VF 
;  3658 : #define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
NV_URECT_COLOR_VALUE            TEXTEQU         <31:0>
;  -W-4A 
;        
;  3659 : #define NV_URECT_RECTANGLE_0(i)                  (0x00470400+(i)*8) /* -W-4A */
;  3660 : #define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
NV_URECT_RECTANGLE_0__SIZE_1            EQU             16t
;  -W-SF 
;  3661 : #define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
NV_URECT_RECTANGLE_0_X          TEXTEQU         <15:0>
;  -W-SF 
;  3662 : #define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
NV_URECT_RECTANGLE_0_Y          TEXTEQU         <31:16>
;  -W-4A 
;        
;  3663 : #define NV_URECT_RECTANGLE_1(i)                  (0x00470404+(i)*8) /* -W-4A */
;  3664 : #define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
NV_URECT_RECTANGLE_1__SIZE_1            EQU             16t
;  -W-UF 
;  3665 : #define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
NV_URECT_RECTANGLE_1_WIDTH              TEXTEQU         <15:0>
;  -W-UF 
;  3666 : #define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
NV_URECT_RECTANGLE_1_HEIGHT             TEXTEQU         <31:16>
;  usr_image_blit.ref 
;  -W--D 
;  3667 : /* usr_image_blit.ref */
;  3668 : #define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
NV_UBLIT                TEXTEQU         <0x00501FFF:0x00500000>
;  -W-4R 
;  3669 : #define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
NV_UBLIT_CTX_SWITCH             EQU             000500000h
;  -W-UF 
;  3670 : #define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
NV_UBLIT_CTX_SWITCH_INSTANCE            TEXTEQU         <15:0>
;  -W-UF 
;  3671 : #define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
NV_UBLIT_CTX_SWITCH_CHID                TEXTEQU         <22:16>
;  -W-VF 
;  3672 : #define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
NV_UBLIT_CTX_SWITCH_VOLATILE            TEXTEQU         <31:31>
;  -W--V 
;  3673 : #define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE             EQU             000000000h
;  -W--V 
;  3674 : #define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
NV_UBLIT_CTX_SWITCH_VOLATILE_RESET              EQU             000000001h
;  -W-4R 
;  3675 : #define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
NV_UBLIT_SET_NOTIFY             EQU             000500104h
;  -W-VF 
;  3676 : #define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
NV_UBLIT_SET_NOTIFY_PARAMETER           TEXTEQU         <31:0>
;  -W--V 
;  3677 : #define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE             EQU             000000000h
;  -W-4R 
;  3678 : #define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
NV_UBLIT_POINT_IN               EQU             000500300h
;  -W-SF 
;  3679 : #define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-SF */
NV_UBLIT_POINT_IN_X             TEXTEQU         <15:0>
;  -W-SF 
;  3680 : #define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-SF */
NV_UBLIT_POINT_IN_Y             TEXTEQU         <31:16>
;  -W-4R 
;  3681 : #define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
NV_UBLIT_POINT_OUT              EQU             000500304h
;  -W-SF 
;  3682 : #define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-SF */
NV_UBLIT_POINT_OUT_X            TEXTEQU         <15:0>
;  -W-SF 
;  3683 : #define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-SF */
NV_UBLIT_POINT_OUT_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3684 : #define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
NV_UBLIT_SIZE           EQU             000500308h
;  -W-UF 
;  3685 : #define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
NV_UBLIT_SIZE_WIDTH             TEXTEQU         <15:0>
;  -W-UF 
;  3686 : #define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
NV_UBLIT_SIZE_HEIGHT            TEXTEQU         <31:16>
;  usr_image_from_cpu.ref 
;  -W--D 
;  3687 : /* usr_image_from_cpu.ref */
;  3688 : #define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
NV_UIMAGE               TEXTEQU         <0x00511FFF:0x00510000>
;  -W-4R 
;  3689 : #define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
NV_UIMAGE_CTX_SWITCH            EQU             000510000h
;  -W-UF 
;  3690 : #define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UIMAGE_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3691 : #define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UIMAGE_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3692 : #define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UIMAGE_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3693 : #define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3694 : #define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3695 : #define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
NV_UIMAGE_SET_NOTIFY            EQU             000510104h
;  -W-VF 
;  3696 : #define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UIMAGE_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3697 : #define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3698 : #define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
NV_UIMAGE_POINT         EQU             000510304h
;  -W-SF 
;  3699 : #define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
NV_UIMAGE_POINT_X               TEXTEQU         <15:0>
;  -W-SF 
;  3700 : #define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
NV_UIMAGE_POINT_Y               TEXTEQU         <31:16>
;  -W-4R 
;  3701 : #define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
NV_UIMAGE_SIZE          EQU             000510308h
;  -W-UF 
;  3702 : #define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
NV_UIMAGE_SIZE_WIDTH            TEXTEQU         <15:0>
;  -W-UF 
;  3703 : #define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
NV_UIMAGE_SIZE_HEIGHT           TEXTEQU         <31:16>
;  -W-4R 
;  3704 : #define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
NV_UIMAGE_SIZE_IN               EQU             00051030ch
;  -W-UF 
;  3705 : #define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
NV_UIMAGE_SIZE_IN_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3706 : #define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
NV_UIMAGE_SIZE_IN_HEIGHT                TEXTEQU         <31:16>
;  -W-4A 
;        
;  3707 : #define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
;  3708 : #define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
NV_UIMAGE_COLOR__SIZE_1         EQU             32t
;  -W-VF 
;  3709 : #define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
NV_UIMAGE_COLOR_VALUE           TEXTEQU         <31:0>
;  usr_bitmap_from_cpu.ref 
;  -W--D 
;  3710 : /* usr_bitmap_from_cpu.ref */
;  3711 : #define NV_UBITMAP                            0x00521FFF:0x00520000 /* -W--D */
NV_UBITMAP              TEXTEQU         <0x00521FFF:0x00520000>
;  -W-4R 
;  3712 : #define NV_UBITMAP_CTX_SWITCH                            0x00520000 /* -W-4R */
NV_UBITMAP_CTX_SWITCH           EQU             000520000h
;  -W-UF 
;  3713 : #define NV_UBITMAP_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UBITMAP_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3714 : #define NV_UBITMAP_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UBITMAP_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3715 : #define NV_UBITMAP_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UBITMAP_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3716 : #define NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3717 : #define NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3718 : #define NV_UBITMAP_SET_NOTIFY                            0x00520104 /* -W-4R */
NV_UBITMAP_SET_NOTIFY           EQU             000520104h
;  -W-VF 
;  3719 : #define NV_UBITMAP_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UBITMAP_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3720 : #define NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3721 : #define NV_UBITMAP_COLOR0                                0x00520308 /* -W-4R */
NV_UBITMAP_COLOR0               EQU             000520308h
;  -W-VF 
;  3722 : #define NV_UBITMAP_COLOR0_VALUE                                31:0 /* -W-VF */
NV_UBITMAP_COLOR0_VALUE         TEXTEQU         <31:0>
;  -W-4R 
;  3723 : #define NV_UBITMAP_COLOR1                                0x0052030C /* -W-4R */
NV_UBITMAP_COLOR1               EQU             00052030ch
;  -W-VF 
;  3724 : #define NV_UBITMAP_COLOR1_VALUE                                31:0 /* -W-VF */
NV_UBITMAP_COLOR1_VALUE         TEXTEQU         <31:0>
;  -W-4R 
;  3725 : #define NV_UBITMAP_POINT                                 0x00520310 /* -W-4R */
NV_UBITMAP_POINT                EQU             000520310h
;  -W-SF 
;  3726 : #define NV_UBITMAP_POINT_X                                     15:0 /* -W-SF */
NV_UBITMAP_POINT_X              TEXTEQU         <15:0>
;  -W-SF 
;  3727 : #define NV_UBITMAP_POINT_Y                                    31:16 /* -W-SF */
NV_UBITMAP_POINT_Y              TEXTEQU         <31:16>
;  -W-4R 
;  3728 : #define NV_UBITMAP_SIZE                                  0x00520314 /* -W-4R */
NV_UBITMAP_SIZE         EQU             000520314h
;  -W-UF 
;  3729 : #define NV_UBITMAP_SIZE_WIDTH                                  15:0 /* -W-UF */
NV_UBITMAP_SIZE_WIDTH           TEXTEQU         <15:0>
;  -W-UF 
;  3730 : #define NV_UBITMAP_SIZE_HEIGHT                                31:16 /* -W-UF */
NV_UBITMAP_SIZE_HEIGHT          TEXTEQU         <31:16>
;  -W-4R 
;  3731 : #define NV_UBITMAP_SIZE_IN                               0x00520318 /* -W-4R */
NV_UBITMAP_SIZE_IN              EQU             000520318h
;  -W-UF 
;  3732 : #define NV_UBITMAP_SIZE_IN_WIDTH                               15:0 /* -W-UF */
NV_UBITMAP_SIZE_IN_WIDTH                TEXTEQU         <15:0>
;  -W-UF 
;  3733 : #define NV_UBITMAP_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
NV_UBITMAP_SIZE_IN_HEIGHT               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3734 : #define NV_UBITMAP_MONOCHROME(i)                 (0x00520400+(i)*4) /* -W-4A */
;  3735 : #define NV_UBITMAP_MONOCHROME__SIZE_1                            32 /*       */
NV_UBITMAP_MONOCHROME__SIZE_1           EQU             32t
;  -W-VF 
;  3736 : #define NV_UBITMAP_MONOCHROME_BITMAP                           31:0 /* -W-VF */
NV_UBITMAP_MONOCHROME_BITMAP            TEXTEQU         <31:0>
;  usr_image_from_mem.ref 
;  -W--D 
;  3737 : /* usr_image_from_mem.ref */
;  3738 : #define NV_UFROMEM                            0x00531FFF:0x00530000 /* -W--D */
NV_UFROMEM              TEXTEQU         <0x00531FFF:0x00530000>
;  -W-4R 
;  3739 : #define NV_UFROMEM_CTX_SWITCH                            0x00530000 /* -W-4R */
NV_UFROMEM_CTX_SWITCH           EQU             000530000h
;  -W-UF 
;  3740 : #define NV_UFROMEM_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UFROMEM_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3741 : #define NV_UFROMEM_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UFROMEM_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3742 : #define NV_UFROMEM_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UFROMEM_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3743 : #define NV_UFROMEM_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UFROMEM_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3744 : #define NV_UFROMEM_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UFROMEM_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4A 
;        
;  3745 : #define NV_UFROMEM_DMA_REPLY(i)                  (0x00530040+(i)*4) /* -W-4A */
;  3746 : #define NV_UFROMEM_DMA_REPLY__SIZE_1                             16 /*       */
NV_UFROMEM_DMA_REPLY__SIZE_1            EQU             16t
;  -W-VF 
;  3747 : #define NV_UFROMEM_DMA_REPLY_DATA                              31:0 /* -W-VF */
NV_UFROMEM_DMA_REPLY_DATA               TEXTEQU         <31:0>
;  -W-4R 
;  3748 : #define NV_UFROMEM_SET_NOTIFY                            0x00530104 /* -W-4R */
NV_UFROMEM_SET_NOTIFY           EQU             000530104h
;  -W-VF 
;  3749 : #define NV_UFROMEM_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UFROMEM_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3750 : #define NV_UFROMEM_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UFROMEM_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3751 : #define NV_UFROMEM_POINT                                 0x00530308 /* -W-4R */
NV_UFROMEM_POINT                EQU             000530308h
;  -W-SF 
;  3752 : #define NV_UFROMEM_POINT_X                                     15:0 /* -W-SF */
NV_UFROMEM_POINT_X              TEXTEQU         <15:0>
;  -W-SF 
;  3753 : #define NV_UFROMEM_POINT_Y                                    31:16 /* -W-SF */
NV_UFROMEM_POINT_Y              TEXTEQU         <31:16>
;  -W-4R 
;  3754 : #define NV_UFROMEM_SIZE                                  0x0053030C /* -W-4R */
NV_UFROMEM_SIZE         EQU             00053030ch
;  -W-UF 
;  3755 : #define NV_UFROMEM_SIZE_WIDTH                                  15:0 /* -W-UF */
NV_UFROMEM_SIZE_WIDTH           TEXTEQU         <15:0>
;  -W-UF 
;  3756 : #define NV_UFROMEM_SIZE_HEIGHT                                31:16 /* -W-UF */
NV_UFROMEM_SIZE_HEIGHT          TEXTEQU         <31:16>
;  -W-4R 
;  3757 : #define NV_UFROMEM_PITCH                                 0x00530310 /* -W-4R */
NV_UFROMEM_PITCH                EQU             000530310h
;  -W-SF 
;  3758 : #define NV_UFROMEM_PITCH_VALUE                                 31:0 /* -W-SF */
NV_UFROMEM_PITCH_VALUE          TEXTEQU         <31:0>
;  -W-4R 
;  3759 : #define NV_UFROMEM_IMAGE_START                           0x00530314 /* -W-4R */
NV_UFROMEM_IMAGE_START          EQU             000530314h
;  -W-UF 
;  3760 : #define NV_UFROMEM_PITCH_START_OFFSET                          31:0 /* -W-UF */
NV_UFROMEM_PITCH_START_OFFSET           TEXTEQU         <31:0>
;  usr_image_to_mem.ref 
;  -W--D 
;  3761 : /* usr_image_to_mem.ref */
;  3762 : #define NV_UTOMEM                             0x00541FFF:0x00540000 /* -W--D */
NV_UTOMEM               TEXTEQU         <0x00541FFF:0x00540000>
;  -W-4R 
;  3763 : #define NV_UTOMEM_CTX_SWITCH                             0x00540000 /* -W-4R */
NV_UTOMEM_CTX_SWITCH            EQU             000540000h
;  -W-UF 
;  3764 : #define NV_UTOMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UTOMEM_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3765 : #define NV_UTOMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UTOMEM_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3766 : #define NV_UTOMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UTOMEM_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3767 : #define NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3768 : #define NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3769 : #define NV_UTOMEM_SET_NOTIFY                             0x00540104 /* -W-4R */
NV_UTOMEM_SET_NOTIFY            EQU             000540104h
;  -W-VF 
;  3770 : #define NV_UTOMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UTOMEM_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3771 : #define NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3772 : #define NV_UTOMEM_POINT                                  0x00540308 /* -W-4R */
NV_UTOMEM_POINT         EQU             000540308h
;  -W-SF 
;  3773 : #define NV_UTOMEM_POINT_X                                      15:0 /* -W-SF */
NV_UTOMEM_POINT_X               TEXTEQU         <15:0>
;  -W-SF 
;  3774 : #define NV_UTOMEM_POINT_Y                                     31:16 /* -W-SF */
NV_UTOMEM_POINT_Y               TEXTEQU         <31:16>
;  -W-4R 
;  3775 : #define NV_UTOMEM_SIZE                                   0x0054030C /* -W-4R */
NV_UTOMEM_SIZE          EQU             00054030ch
;  -W-UF 
;  3776 : #define NV_UTOMEM_SIZE_WIDTH                                   15:0 /* -W-UF */
NV_UTOMEM_SIZE_WIDTH            TEXTEQU         <15:0>
;  -W-UF 
;  3777 : #define NV_UTOMEM_SIZE_HEIGHT                                 31:16 /* -W-UF */
NV_UTOMEM_SIZE_HEIGHT           TEXTEQU         <31:16>
;  -W-4R 
;  3778 : #define NV_UTOMEM_IMAGE_PITCH                            0x00540310 /* -W-4R */
NV_UTOMEM_IMAGE_PITCH           EQU             000540310h
;  -W-SF 
;  3779 : #define NV_UTOMEM_IMAGE_PITCH_VALUE                            31:0 /* -W-SF */
NV_UTOMEM_IMAGE_PITCH_VALUE             TEXTEQU         <31:0>
;  -W-4R 
;  3780 : #define NV_UTOMEM_IMAGE_START                            0x00540314 /* -W-4R */
NV_UTOMEM_IMAGE_START           EQU             000540314h
;  -W-UF 
;  3781 : #define NV_UTOMEM_IMAGE_START_OFFSET                           31:0 /* -W-UF */
NV_UTOMEM_IMAGE_START_OFFSET            TEXTEQU         <31:0>
;  usr_scaled_image_from_mem.ref 
;  -W--D 
;  3782 : /* usr_scaled_image_from_mem.ref */
;  3783 : #define NV_USCALED                            0x004E1FFF:0x004E0000 /* -W--D */
NV_USCALED              TEXTEQU         <0x004E1FFF:0x004E0000>
;  -W-4R 
;  3784 : #define NV_USCALED_CTX_SWITCH                            0x004E0000 /* -W-4R */
NV_USCALED_CTX_SWITCH           EQU             0004e0000h
;  -W-UF 
;  3785 : #define NV_USCALED_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_USCALED_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3786 : #define NV_USCALED_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_USCALED_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3787 : #define NV_USCALED_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_USCALED_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3788 : #define NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3789 : #define NV_USCALED_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_USCALED_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3790 : #define NV_USCALED_SET_NOTIFY                            0x004E0104 /* -W-4R */
NV_USCALED_SET_NOTIFY           EQU             0004e0104h
;  -W-VF 
;  3791 : #define NV_USCALED_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_USCALED_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3792 : #define NV_USCALED_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_USCALED_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3793 : #define NV_USCALED_CLIP_0                                0x004E0308 /* -W-4R */
NV_USCALED_CLIP_0               EQU             0004e0308h
;  -W-SF 
;  3794 : #define NV_USCALED_CLIP_0_X                                    15:0 /* -W-SF */
NV_USCALED_CLIP_0_X             TEXTEQU         <15:0>
;  -W-SF 
;  3795 : #define NV_USCALED_CLIP_0_Y                                   31:16 /* -W-SF */
NV_USCALED_CLIP_0_Y             TEXTEQU         <31:16>
;  -W-4R 
;  3796 : #define NV_USCALED_CLIP_1                                0x004E030C /* -W-4R */
NV_USCALED_CLIP_1               EQU             0004e030ch
;  -W-UF 
;  3797 : #define NV_USCALED_CLIP_1_WIDTH                                15:0 /* -W-UF */
NV_USCALED_CLIP_1_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3798 : #define NV_USCALED_CLIP_1_HEIGHT                              31:16 /* -W-UF */
NV_USCALED_CLIP_1_HEIGHT                TEXTEQU         <31:16>
;  -W-4R 
;  3799 : #define NV_USCALED_RECTANGLE_OUT_0                       0x004E0310 /* -W-4R */
NV_USCALED_RECTANGLE_OUT_0              EQU             0004e0310h
;  -W-SF 
;  3800 : #define NV_USCALED_RECTANGLE_OUT_0_X                           15:0 /* -W-SF */
NV_USCALED_RECTANGLE_OUT_0_X            TEXTEQU         <15:0>
;  -W-SF 
;  3801 : #define NV_USCALED_RECTANGLE_OUT_0_Y                          31:16 /* -W-SF */
NV_USCALED_RECTANGLE_OUT_0_Y            TEXTEQU         <31:16>
;  -W-4R 
;  3802 : #define NV_USCALED_RECTANGLE_OUT_1                       0x004E0314 /* -W-4R */
NV_USCALED_RECTANGLE_OUT_1              EQU             0004e0314h
;  -W-UF 
;  3803 : #define NV_USCALED_RECTANGLE_OUT_1_WIDTH                       15:0 /* -W-UF */
NV_USCALED_RECTANGLE_OUT_1_WIDTH                TEXTEQU         <15:0>
;  -W-UF 
;  3804 : #define NV_USCALED_RECTANGLE_OUT_1_HEIGHT                     31:16 /* -W-UF */
NV_USCALED_RECTANGLE_OUT_1_HEIGHT               TEXTEQU         <31:16>
;  -W-4R 
;  3805 : #define NV_USCALED_DELTA_DU_DX                           0x004E0318 /* -W-4R */
NV_USCALED_DELTA_DU_DX          EQU             0004e0318h
;  -W-SF 
;  3806 : #define NV_USCALED_DELTA_DU_DX_R_FRACTION                      19:0 /* -W-SF */
NV_USCALED_DELTA_DU_DX_R_FRACTION               TEXTEQU         <19:0>
;  -W-UF 
;  3807 : #define NV_USCALED_DELTA_DU_DX_R_INT                          31:20 /* -W-UF */
NV_USCALED_DELTA_DU_DX_R_INT            TEXTEQU         <31:20>
;  -W-UF 
;  3808 : #define NV_USCALED_DELTA_DU_DX_R                               31:0 /* -W-UF */
NV_USCALED_DELTA_DU_DX_R                TEXTEQU         <31:0>
;  -W-4R 
;  3809 : #define NV_USCALED_DELTA_DV_DY                           0x004E031C /* -W-4R */
NV_USCALED_DELTA_DV_DY          EQU             0004e031ch
;  -W-SF 
;  3810 : #define NV_USCALED_DELTA_DV_DY_R_FRACTION                      19:0 /* -W-SF */
NV_USCALED_DELTA_DV_DY_R_FRACTION               TEXTEQU         <19:0>
;  -W-UF 
;  3811 : #define NV_USCALED_DELTA_DV_DY_R_INT                          31:20 /* -W-UF */
NV_USCALED_DELTA_DV_DY_R_INT            TEXTEQU         <31:20>
;  -W-UF 
;  3812 : #define NV_USCALED_DELTA_DV_DY_R                               31:0 /* -W-UF */
NV_USCALED_DELTA_DV_DY_R                TEXTEQU         <31:0>
;  -W-4R 
;  3813 : #define NV_USCALED_SIZE                                  0x004E0400 /* -W-4R */
NV_USCALED_SIZE         EQU             0004e0400h
;  -W-UF 
;  3814 : #define NV_USCALED_SIZE_WIDTH                                  15:0 /* -W-UF */
NV_USCALED_SIZE_WIDTH           TEXTEQU         <15:0>
;  -W-UF 
;  3815 : #define NV_USCALED_SIZE_HEIGHT                                31:16 /* -W-UF */
NV_USCALED_SIZE_HEIGHT          TEXTEQU         <31:16>
;  -W-4R 
;  3816 : #define NV_USCALED_PITCH                                 0x004E0404 /* -W-4R */
NV_USCALED_PITCH                EQU             0004e0404h
;  -W-SF 
;  3817 : #define NV_USCALED_PITCH_VALUE                                 31:0 /* -W-SF */
NV_USCALED_PITCH_VALUE          TEXTEQU         <31:0>
;  -W-4R 
;  3818 : #define NV_USCALED_OFFSET                                0x004E0408 /* -W-4R */
NV_USCALED_OFFSET               EQU             0004e0408h
;  -W-UF 
;  3819 : #define NV_USCALED_OFFSET_VALUE                               31:0  /* -W-UF */
NV_USCALED_OFFSET_VALUE         TEXTEQU         <31:0>
;  -W-4R 
;  3820 : #define NV_USCALED_POINT                                 0x004E040C /* -W-4R */
NV_USCALED_POINT                EQU             0004e040ch
;  -W-UF 
;  3821 : #define NV_USCALED_POINT_V_FRACTION                            11:0 /* -W-UF */
NV_USCALED_POINT_V_FRACTION             TEXTEQU         <11:0>
;  -W-UF 
;  3822 : #define NV_USCALED_POINT_V_INT                                15:12 /* -W-UF */
NV_USCALED_POINT_V_INT          TEXTEQU         <15:12>
;  -W-UF 
;  3823 : #define NV_USCALED_POINT_V_VALUE                               15:0 /* -W-UF */
NV_USCALED_POINT_V_VALUE                TEXTEQU         <15:0>
;  -W-UF 
;  3824 : #define NV_USCALED_POINT_U_FRACTION                           19:16 /* -W-UF */
NV_USCALED_POINT_U_FRACTION             TEXTEQU         <19:16>
;  -W-UF 
;  3825 : #define NV_USCALED_POINT_U_INT                                31:20 /* -W-UF */
NV_USCALED_POINT_U_INT          TEXTEQU         <31:20>
;  -W-UF 
;  3826 : #define NV_USCALED_POINT_U_VALUE                               31:0 /* -W-UF */
NV_USCALED_POINT_U_VALUE                TEXTEQU         <31:0>
;  -W-4R 
;  3827 : #define NV_USCALED_SIZE_Y                                0x004E0500 /* -W-4R */
NV_USCALED_SIZE_Y               EQU             0004e0500h
;  -W-UF 
;  3828 : #define NV_USCALED_SIZE_Y_WIDTH                                15:0 /* -W-UF */
NV_USCALED_SIZE_Y_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3829 : #define NV_USCALED_SIZE_Y_HEIGHT                              31:16 /* -W-UF */
NV_USCALED_SIZE_Y_HEIGHT                TEXTEQU         <31:16>
;  -W-4R 
;  3830 : #define NV_USCALED_PITCH_420                             0x004E0504 /* -W-4R */
NV_USCALED_PITCH_420            EQU             0004e0504h
;  -W-UF 
;  3831 : #define NV_USCALED_PITCH_420_Y                                 15:0 /* -W-UF */
NV_USCALED_PITCH_420_Y          TEXTEQU         <15:0>
;  -W-UF 
;  3832 : #define NV_USCALED_PITCH_420_UV                               31:16 /* -W-UF */
NV_USCALED_PITCH_420_UV         TEXTEQU         <31:16>
;  -W-4R 
;  3833 : #define NV_USCALED_OFFSET_Y                              0x004E0508 /* -W-4R */
NV_USCALED_OFFSET_Y             EQU             0004e0508h
;  -W-UF 
;  3834 : #define NV_USCALED_OFFSET_Y_VALUE                             31:0  /* -W-UF */
NV_USCALED_OFFSET_Y_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3835 : #define NV_USCALED_OFFSET_U                              0x004E050C /* -W-4R */
NV_USCALED_OFFSET_U             EQU             0004e050ch
;  -W-UF 
;  3836 : #define NV_USCALED_OFFSET_U_VALUE                             31:0  /* -W-UF */
NV_USCALED_OFFSET_U_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3837 : #define NV_USCALED_OFFSET_V                              0x004E0510 /* -W-4R */
NV_USCALED_OFFSET_V             EQU             0004e0510h
;  -W-UF 
;  3838 : #define NV_USCALED_OFFSET_V_VALUE                             31:0  /* -W-UF */
NV_USCALED_OFFSET_V_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3839 : #define NV_USCALED_POINT_Y                               0x004E0514 /* -W-4R */
NV_USCALED_POINT_Y              EQU             0004e0514h
;  -W-UF 
;  3840 : #define NV_USCALED_POINT_Y_V_FRACTION                          11:0 /* -W-UF */
NV_USCALED_POINT_Y_V_FRACTION           TEXTEQU         <11:0>
;  -W-UF 
;  3841 : #define NV_USCALED_POINT_Y_V_INT                              15:12 /* -W-UF */
NV_USCALED_POINT_Y_V_INT                TEXTEQU         <15:12>
;  -W-UF 
;  3842 : #define NV_USCALED_POINT_Y_V_VALUE                             15:0 /* -W-UF */
NV_USCALED_POINT_Y_V_VALUE              TEXTEQU         <15:0>
;  -W-UF 
;  3843 : #define NV_USCALED_POINT_Y_U_FRACTION                         19:16 /* -W-UF */
NV_USCALED_POINT_Y_U_FRACTION           TEXTEQU         <19:16>
;  -W-UF 
;  3844 : #define NV_USCALED_POINT_Y_U_INT                              31:20 /* -W-UF */
NV_USCALED_POINT_Y_U_INT                TEXTEQU         <31:20>
;  -W-UF 
;  3845 : #define NV_USCALED_POINT_Y_U_VALUE                            31:16 /* -W-UF */
NV_USCALED_POINT_Y_U_VALUE              TEXTEQU         <31:16>
;  usr_stretch_from_cpu.ref 
;  -W--D 
;  3846 : /* usr_stretch_from_cpu.ref */
;  3847 : #define NV_USTRTCH                            0x00551FFF:0x00550000 /* -W--D */
NV_USTRTCH              TEXTEQU         <0x00551FFF:0x00550000>
;  -W-4R 
;  3848 : #define NV_USTRTCH_CTX_SWITCH                            0x00550000 /* -W-4R */
NV_USTRTCH_CTX_SWITCH           EQU             000550000h
;  -W-UF 
;  3849 : #define NV_USTRTCH_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_USTRTCH_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3850 : #define NV_USTRTCH_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_USTRTCH_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3851 : #define NV_USTRTCH_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_USTRTCH_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3852 : #define NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3853 : #define NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3854 : #define NV_USTRTCH_SET_NOTIFY                            0x00550104 /* -W-4R */
NV_USTRTCH_SET_NOTIFY           EQU             000550104h
;  -W-VF 
;  3855 : #define NV_USTRTCH_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_USTRTCH_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3856 : #define NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3857 : #define NV_USTRTCH_SIZE_IN                               0x00550304 /* -W-4R */
NV_USTRTCH_SIZE_IN              EQU             000550304h
;  -W-UF 
;  3858 : #define NV_USTRTCH_SIZE_IN_WIDTH                               15:0 /* -W-UF */
NV_USTRTCH_SIZE_IN_WIDTH                TEXTEQU         <15:0>
;  -W-UF 
;  3859 : #define NV_USTRTCH_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
NV_USTRTCH_SIZE_IN_HEIGHT               TEXTEQU         <31:16>
;  -W-4R 
;  3860 : #define NV_USTRTCH_DELTA_DX_DU                           0x00550308 /* -W-4R */
NV_USTRTCH_DELTA_DX_DU          EQU             000550308h
;  -W-UF 
;  3861 : #define NV_USTRTCH_DELTA_DX_DU_R_FRACTION                      19:0 /* -W-UF */
NV_USTRTCH_DELTA_DX_DU_R_FRACTION               TEXTEQU         <19:0>
;  -W-UF 
;  3862 : #define NV_USTRTCH_DELTA_DX_DU_R_INT                          31:20 /* -W-UF */
NV_USTRTCH_DELTA_DX_DU_R_INT            TEXTEQU         <31:20>
;  -W-UF 
;  3863 : #define NV_USTRTCH_DELTA_DX_DU_R                               31:0 /* -W-UF */
NV_USTRTCH_DELTA_DX_DU_R                TEXTEQU         <31:0>
;  -W-4R 
;  3864 : #define NV_USTRTCH_DELTA_DY_DV                           0x0055030C /* -W-4R */
NV_USTRTCH_DELTA_DY_DV          EQU             00055030ch
;  -W-UF 
;  3865 : #define NV_USTRTCH_DELTA_DY_DV_R_FRACTION                      19:0 /* -W-UF */
NV_USTRTCH_DELTA_DY_DV_R_FRACTION               TEXTEQU         <19:0>
;  -W-UF 
;  3866 : #define NV_USTRTCH_DELTA_DY_DV_R_INT                          31:20 /* -W-UF */
NV_USTRTCH_DELTA_DY_DV_R_INT            TEXTEQU         <31:20>
;  -W-UF 
;  3867 : #define NV_USTRTCH_DELTA_DY_DV_R                               31:0 /* -W-UF */
NV_USTRTCH_DELTA_DY_DV_R                TEXTEQU         <31:0>
;  -W-4R 
;  3868 : #define NV_USTRTCH_CLIP_0                                0x00550310 /* -W-4R */
NV_USTRTCH_CLIP_0               EQU             000550310h
;  -W-SF 
;  3869 : #define NV_USTRTCH_CLIP_0_X                                    15:0 /* -W-SF */
NV_USTRTCH_CLIP_0_X             TEXTEQU         <15:0>
;  -W-SF 
;  3870 : #define NV_USTRTCH_CLIP_0_Y                                   31:16 /* -W-SF */
NV_USTRTCH_CLIP_0_Y             TEXTEQU         <31:16>
;  -W-4R 
;  3871 : #define NV_USTRTCH_CLIP_1                                0x00550314 /* -W-4R */
NV_USTRTCH_CLIP_1               EQU             000550314h
;  -W-UF 
;  3872 : #define NV_USTRTCH_CLIP_1_WIDTH                                15:0 /* -W-UF */
NV_USTRTCH_CLIP_1_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3873 : #define NV_USTRTCH_CLIP_1_HEIGHT                              31:16 /* -W-UF */
NV_USTRTCH_CLIP_1_HEIGHT                TEXTEQU         <31:16>
;  -W-4R 
;  3874 : #define NV_USTRTCH_POINT12D4                             0x00550318 /* -W-4R */
NV_USTRTCH_POINT12D4            EQU             000550318h
;  -W-SF 
;  3875 : #define NV_USTRTCH_POINT12D4_X_FRACTION                         3:0 /* -W-SF */
NV_USTRTCH_POINT12D4_X_FRACTION         TEXTEQU         <3:0>
;  -W-SF 
;  3876 : #define NV_USTRTCH_POINT12D4_X_INT                             15:4 /* -W-SF */
NV_USTRTCH_POINT12D4_X_INT              TEXTEQU         <15:4>
;  -W-SF 
;  3877 : #define NV_USTRTCH_POINT12D4_X                                 15:0 /* -W-SF */
NV_USTRTCH_POINT12D4_X          TEXTEQU         <15:0>
;  -W-SF 
;  3878 : #define NV_USTRTCH_POINT12D4_Y_FRACTION                       19:16 /* -W-SF */
NV_USTRTCH_POINT12D4_Y_FRACTION         TEXTEQU         <19:16>
;  -W-SF 
;  3879 : #define NV_USTRTCH_POINT12D4_Y_INT                            31:20 /* -W-SF */
NV_USTRTCH_POINT12D4_Y_INT              TEXTEQU         <31:20>
;  -W-SF 
;  3880 : #define NV_USTRTCH_POINT12D4_Y                                31:16 /* -W-SF */
NV_USTRTCH_POINT12D4_Y          TEXTEQU         <31:16>
;  -W-4A 
;        
;  3881 : #define NV_USTRTCH_COLOR(i)                      (0x00550400+(i)*4) /* -W-4A */
;  3882 : #define NV_USTRTCH_COLOR__SIZE_1                               1792 /*       */
NV_USTRTCH_COLOR__SIZE_1                EQU             1792t
;  -W-VF 
;  3883 : #define NV_USTRTCH_COLOR_VALUE                                 31:0 /* -W-VF */
NV_USTRTCH_COLOR_VALUE          TEXTEQU         <31:0>
;  usr_win95_text.ref 
;  -W--D 
;  3884 : /* usr_win95_text.ref */
;  3885 : #define NV_UW95TXT                            0x004C1FFF:0x004C0000 /* -W--D */
NV_UW95TXT              TEXTEQU         <0x004C1FFF:0x004C0000>
;  -W-4R 
;  3886 : #define NV_UW95TXT_CTX_SWITCH                            0x004C0000 /* -W-4R */
NV_UW95TXT_CTX_SWITCH           EQU             0004c0000h
;  -W-UF 
;  3887 : #define NV_UW95TXT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
NV_UW95TXT_CTX_SWITCH_INSTANCE          TEXTEQU         <15:0>
;  -W-UF 
;  3888 : #define NV_UW95TXT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
NV_UW95TXT_CTX_SWITCH_CHID              TEXTEQU         <22:16>
;  -W-VF 
;  3889 : #define NV_UW95TXT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
NV_UW95TXT_CTX_SWITCH_VOLATILE          TEXTEQU         <31:31>
;  -W--V 
;  3890 : #define NV_UW95TXT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
NV_UW95TXT_CTX_SWITCH_VOLATILE_IGNORE           EQU             000000000h
;  -W--V 
;  3891 : #define NV_UW95TXT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
NV_UW95TXT_CTX_SWITCH_VOLATILE_RESET            EQU             000000001h
;  -W-4R 
;  3892 : #define NV_UW95TXT_SET_NOTIFY                            0x004C0104 /* -W-4R */
NV_UW95TXT_SET_NOTIFY           EQU             0004c0104h
;  -W-VF 
;  3893 : #define NV_UW95TXT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
NV_UW95TXT_SET_NOTIFY_PARAMETER         TEXTEQU         <31:0>
;  -W--V 
;  3894 : #define NV_UW95TXT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
NV_UW95TXT_SET_NOTIFY_PARAMETER_WRITE           EQU             000000000h
;  -W-4R 
;  3895 : #define NV_UW95TXT_COLOR_A                               0x004C03FC /* -W-4R */
NV_UW95TXT_COLOR_A              EQU             0004c03fch
;  -W-VF 
;  3896 : #define NV_UW95TXT_COLOR_A_VALUE                               31:0 /* -W-VF */
NV_UW95TXT_COLOR_A_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3897 : #define NV_UW95TXT_RECT_NCLIP_0(i)               (0x004C0400+(i)*8) /* -W-4A */
;  3898 : #define NV_UW95TXT_RECT_NCLIP_0__SIZE_1                          64 /*       */
NV_UW95TXT_RECT_NCLIP_0__SIZE_1         EQU             64t
;  -W-SF 
;  3899 : #define NV_UW95TXT_RECT_NCLIP_0_Y                              15:0 /* -W-SF */
NV_UW95TXT_RECT_NCLIP_0_Y               TEXTEQU         <15:0>
;  -W-SF 
;  3900 : #define NV_UW95TXT_RECT_NCLIP_0_X                             31:16 /* -W-SF */
NV_UW95TXT_RECT_NCLIP_0_X               TEXTEQU         <31:16>
;  -W-4A 
;        
;  3901 : #define NV_UW95TXT_RECT_NCLIP_1(i)               (0x004C0404+(i)*8) /* -W-4A */
;  3902 : #define NV_UW95TXT_RECT_NCLIP_1__SIZE_1                          64 /*       */
NV_UW95TXT_RECT_NCLIP_1__SIZE_1         EQU             64t
;  -W-UF 
;  3903 : #define NV_UW95TXT_RECT_NCLIP_1_HEIGHT                         15:0 /* -W-UF */
NV_UW95TXT_RECT_NCLIP_1_HEIGHT          TEXTEQU         <15:0>
;  -W-UF 
;  3904 : #define NV_UW95TXT_RECT_NCLIP_1_WIDTH                         31:16 /* -W-UF */
NV_UW95TXT_RECT_NCLIP_1_WIDTH           TEXTEQU         <31:16>
;  -W-4R 
;  3905 : #define NV_UW95TXT_CLIP_B_0                              0x004C07F4 /* -W-4R */
NV_UW95TXT_CLIP_B_0             EQU             0004c07f4h
;  -W-SF 
;  3906 : #define NV_UW95TXT_CLIP_B_0_LEFT                               15:0 /* -W-SF */
NV_UW95TXT_CLIP_B_0_LEFT                TEXTEQU         <15:0>
;  -W-SF 
;  3907 : #define NV_UW95TXT_CLIP_B_0_TOP                               31:16 /* -W-SF */
NV_UW95TXT_CLIP_B_0_TOP         TEXTEQU         <31:16>
;  -W-4R 
;  3908 : #define NV_UW95TXT_CLIP_B_1                              0x004C07F8 /* -W-4R */
NV_UW95TXT_CLIP_B_1             EQU             0004c07f8h
;  -W-SF 
;  3909 : #define NV_UW95TXT_CLIP_B_1_RIGHT                              15:0 /* -W-SF */
NV_UW95TXT_CLIP_B_1_RIGHT               TEXTEQU         <15:0>
;  -W-SF 
;  3910 : #define NV_UW95TXT_CLIP_B_1_BOTTOM                            31:16 /* -W-SF */
NV_UW95TXT_CLIP_B_1_BOTTOM              TEXTEQU         <31:16>
;  -W-4R 
;  3911 : #define NV_UW95TXT_COLOR_B                               0x004C07FC /* -W-4R */
NV_UW95TXT_COLOR_B              EQU             0004c07fch
;  -W-VF 
;  3912 : #define NV_UW95TXT_COLOR_B_VALUE                               31:0 /* -W-VF */
NV_UW95TXT_COLOR_B_VALUE                TEXTEQU         <31:0>
;  -W-4A 
;        
;  3913 : #define NV_UW95TXT_RECT_CLIP_0(i)                (0x004C0800+(i)*8) /* -W-4A */
;  3914 : #define NV_UW95TXT_RECT_CLIP_0__SIZE_1                           64 /*       */
NV_UW95TXT_RECT_CLIP_0__SIZE_1          EQU             64t
;  -W-SF 
;  3915 : #define NV_UW95TXT_RECT_CLIP_0_LEFT                            15:0 /* -W-SF */
NV_UW95TXT_RECT_CLIP_0_LEFT             TEXTEQU         <15:0>
;  -W-SF 
;  3916 : #define NV_UW95TXT_RECT_CLIP_0_TOP                            31:16 /* -W-SF */
NV_UW95TXT_RECT_CLIP_0_TOP              TEXTEQU         <31:16>
;  -W-4A 
;        
;  3917 : #define NV_UW95TXT_RECT_CLIP_1(i)                (0x004C0804+(i)*8) /* -W-4A */
;  3918 : #define NV_UW95TXT_RECT_CLIP_1__SIZE_1                           64 /*       */
NV_UW95TXT_RECT_CLIP_1__SIZE_1          EQU             64t
;  -W-SF 
;  3919 : #define NV_UW95TXT_RECT_CLIP_1_RIGHT                           15:0 /* -W-SF */
NV_UW95TXT_RECT_CLIP_1_RIGHT            TEXTEQU         <15:0>
;  -W-SF 
;  3920 : #define NV_UW95TXT_RECT_CLIP_1_BOTTOM                         31:16 /* -W-SF */
NV_UW95TXT_RECT_CLIP_1_BOTTOM           TEXTEQU         <31:16>
;  -W-4R 
;  3921 : #define NV_UW95TXT_CLIP_C_0                              0x004C0BEC /* -W-4R */
NV_UW95TXT_CLIP_C_0             EQU             0004c0bech
;  -W-SF 
;  3922 : #define NV_UW95TXT_CLIP_C_0_LEFT                               15:0 /* -W-SF */
NV_UW95TXT_CLIP_C_0_LEFT                TEXTEQU         <15:0>
;  -W-SF 
;  3923 : #define NV_UW95TXT_CLIP_C_0_TOP                               31:16 /* -W-SF */
NV_UW95TXT_CLIP_C_0_TOP         TEXTEQU         <31:16>
;  -W-4R 
;  3924 : #define NV_UW95TXT_CLIP_C_1                              0x004C0BF0 /* -W-4R */
NV_UW95TXT_CLIP_C_1             EQU             0004c0bf0h
;  -W-SF 
;  3925 : #define NV_UW95TXT_CLIP_C_1_RIGHT                              15:0 /* -W-SF */
NV_UW95TXT_CLIP_C_1_RIGHT               TEXTEQU         <15:0>
;  -W-SF 
;  3926 : #define NV_UW95TXT_CLIP_C_1_BOTTOM                            31:16 /* -W-SF */
NV_UW95TXT_CLIP_C_1_BOTTOM              TEXTEQU         <31:16>
;  -W-4R 
;  3927 : #define NV_UW95TXT_COLOR1_C                              0x004C0BF4 /* -W-4R */
NV_UW95TXT_COLOR1_C             EQU             0004c0bf4h
;  -W-VF 
;  3928 : #define NV_UW95TXT_COLOR1_C_VALUE                              31:0 /* -W-VF */
NV_UW95TXT_COLOR1_C_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3929 : #define NV_UW95TXT_SIZE_C                                0x004C0BF8 /* -W-4R */
NV_UW95TXT_SIZE_C               EQU             0004c0bf8h
;  -W-UF 
;  3930 : #define NV_UW95TXT_SIZE_C_WIDTH                                15:0 /* -W-UF */
NV_UW95TXT_SIZE_C_WIDTH         TEXTEQU         <15:0>
;  -W-UF 
;  3931 : #define NV_UW95TXT_SIZE_C_HEIGHT                              31:16 /* -W-UF */
NV_UW95TXT_SIZE_C_HEIGHT                TEXTEQU         <31:16>
;  -W-4R 
;  3932 : #define NV_UW95TXT_POINT_C                               0x004C0BFC /* -W-4R */
NV_UW95TXT_POINT_C              EQU             0004c0bfch
;  -W-SF 
;  3933 : #define NV_UW95TXT_POINT_C_X                                   15:0 /* -W-SF */
NV_UW95TXT_POINT_C_X            TEXTEQU         <15:0>
;  -W-SF 
;  3934 : #define NV_UW95TXT_POINT_C_Y                                  31:16 /* -W-SF */
NV_UW95TXT_POINT_C_Y            TEXTEQU         <31:16>
;  -W-4A 
;        
;  3935 : #define NV_UW95TXT_MONO_COLOR1_C(i)              (0x004C0C00+(i)*4) /* -W-4A */
;  3936 : #define NV_UW95TXT_MONO_COLOR1_C__SIZE_1                        128 /*       */
NV_UW95TXT_MONO_COLOR1_C__SIZE_1                EQU             128t
;  -W-VF 
;  3937 : #define NV_UW95TXT_MONO_COLOR1_C_BITMAP                        31:0 /* -W-VF */
NV_UW95TXT_MONO_COLOR1_C_BITMAP         TEXTEQU         <31:0>
;  -W-4R 
;  3938 : #define NV_UW95TXT_CLIP_D_0                              0x004C0FE8 /* -W-4R */
NV_UW95TXT_CLIP_D_0             EQU             0004c0fe8h
;  -W-SF 
;  3939 : #define NV_UW95TXT_CLIP_D_0_LEFT                               15:0 /* -W-SF */
NV_UW95TXT_CLIP_D_0_LEFT                TEXTEQU         <15:0>
;  -W-SF 
;  3940 : #define NV_UW95TXT_CLIP_D_0_TOP                               31:16 /* -W-SF */
NV_UW95TXT_CLIP_D_0_TOP         TEXTEQU         <31:16>
;  -W-4R 
;  3941 : #define NV_UW95TXT_CLIP_D_1                              0x004C0FEC /* -W-4R */
NV_UW95TXT_CLIP_D_1             EQU             0004c0fech
;  -W-SF 
;  3942 : #define NV_UW95TXT_CLIP_D_1_RIGHT                              15:0 /* -W-SF */
NV_UW95TXT_CLIP_D_1_RIGHT               TEXTEQU         <15:0>
;  -W-SF 
;  3943 : #define NV_UW95TXT_CLIP_D_1_BOTTOM                            31:16 /* -W-SF */
NV_UW95TXT_CLIP_D_1_BOTTOM              TEXTEQU         <31:16>
;  -W-4R 
;  3944 : #define NV_UW95TXT_COLOR1_D                              0x004C0FF0 /* -W-4R */
NV_UW95TXT_COLOR1_D             EQU             0004c0ff0h
;  -W-VF 
;  3945 : #define NV_UW95TXT_COLOR1_D_VALUE                              31:0 /* -W-VF */
NV_UW95TXT_COLOR1_D_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3946 : #define NV_UW95TXT_SIZE_IN_D                             0x004C0FF4 /* -W-4R */
NV_UW95TXT_SIZE_IN_D            EQU             0004c0ff4h
;  -W-UF 
;  3947 : #define NV_UW95TXT_SIZE_IN_D_WIDTH                             15:0 /* -W-UF */
NV_UW95TXT_SIZE_IN_D_WIDTH              TEXTEQU         <15:0>
;  -W-UF 
;  3948 : #define NV_UW95TXT_SIZE_IN_D_HEIGHT                           31:16 /* -W-UF */
NV_UW95TXT_SIZE_IN_D_HEIGHT             TEXTEQU         <31:16>
;  -W-4R 
;  3949 : #define NV_UW95TXT_SIZE_OUT_D                            0x004C0FF8 /* -W-4R */
NV_UW95TXT_SIZE_OUT_D           EQU             0004c0ff8h
;  -W-UF 
;  3950 : #define NV_UW95TXT_SIZE_OUT_D_WIDTH                            15:0 /* -W-UF */
NV_UW95TXT_SIZE_OUT_D_WIDTH             TEXTEQU         <15:0>
;  -W-UF 
;  3951 : #define NV_UW95TXT_SIZE_OUT_D_HEIGHT                          31:16 /* -W-UF */
NV_UW95TXT_SIZE_OUT_D_HEIGHT            TEXTEQU         <31:16>
;  -W-4R 
;  3952 : #define NV_UW95TXT_POINT_D                               0x004C0FFC /* -W-4R */
NV_UW95TXT_POINT_D              EQU             0004c0ffch
;  -W-SF 
;  3953 : #define NV_UW95TXT_POINT_D_X                                   15:0 /* -W-SF */
NV_UW95TXT_POINT_D_X            TEXTEQU         <15:0>
;  -W-SF 
;  3954 : #define NV_UW95TXT_POINT_D_Y                                  31:16 /* -W-SF */
NV_UW95TXT_POINT_D_Y            TEXTEQU         <31:16>
;  -W-4A 
;        
;  3955 : #define NV_UW95TXT_MONO_COLOR1_D(i)              (0x004C1000+(i)*4) /* -W-4A */
;  3956 : #define NV_UW95TXT_MONO_COLOR1_D__SIZE_1                        128 /*       */
NV_UW95TXT_MONO_COLOR1_D__SIZE_1                EQU             128t
;  -W-VF 
;  3957 : #define NV_UW95TXT_MONO_COLOR1_D_BITMAP                        31:0 /* -W-VF */
NV_UW95TXT_MONO_COLOR1_D_BITMAP         TEXTEQU         <31:0>
;  -W-4R 
;  3958 : #define NV_UW95TXT_CLIP_E_0                              0x004C13E4 /* -W-4R */
NV_UW95TXT_CLIP_E_0             EQU             0004c13e4h
;  -W-SF 
;  3959 : #define NV_UW95TXT_CLIP_E_0_LEFT                               15:0 /* -W-SF */
NV_UW95TXT_CLIP_E_0_LEFT                TEXTEQU         <15:0>
;  -W-SF 
;  3960 : #define NV_UW95TXT_CLIP_E_0_TOP                               31:16 /* -W-SF */
NV_UW95TXT_CLIP_E_0_TOP         TEXTEQU         <31:16>
;  -W-4R 
;  3961 : #define NV_UW95TXT_CLIP_E_1                              0x004C13E8 /* -W-4R */
NV_UW95TXT_CLIP_E_1             EQU             0004c13e8h
;  -W-SF 
;  3962 : #define NV_UW95TXT_CLIP_E_1_RIGHT                              15:0 /* -W-SF */
NV_UW95TXT_CLIP_E_1_RIGHT               TEXTEQU         <15:0>
;  -W-SF 
;  3963 : #define NV_UW95TXT_CLIP_E_1_BOTTOM                            31:16 /* -W-SF */
NV_UW95TXT_CLIP_E_1_BOTTOM              TEXTEQU         <31:16>
;  -W-4R 
;  3964 : #define NV_UW95TXT_COLOR0_E                              0x004C13EC /* -W-4R */
NV_UW95TXT_COLOR0_E             EQU             0004c13ech
;  -W-VF 
;  3965 : #define NV_UW95TXT_COLOR0_E_VALUE                              31:0 /* -W-VF */
NV_UW95TXT_COLOR0_E_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3966 : #define NV_UW95TXT_COLOR1_E                              0x004C13F0 /* -W-4R */
NV_UW95TXT_COLOR1_E             EQU             0004c13f0h
;  -W-VF 
;  3967 : #define NV_UW95TXT_COLOR1_E_VALUE                              31:0 /* -W-VF */
NV_UW95TXT_COLOR1_E_VALUE               TEXTEQU         <31:0>
;  -W-4R 
;  3968 : #define NV_UW95TXT_SIZE_IN_E                             0x004C13F4 /* -W-4R */
NV_UW95TXT_SIZE_IN_E            EQU             0004c13f4h
;  -W-UF 
;  3969 : #define NV_UW95TXT_SIZE_IN_E_WIDTH                             15:0 /* -W-UF */
NV_UW95TXT_SIZE_IN_E_WIDTH              TEXTEQU         <15:0>
;  -W-UF 
;  3970 : #define NV_UW95TXT_SIZE_IN_E_HEIGHT                           31:16 /* -W-UF */
NV_UW95TXT_SIZE_IN_E_HEIGHT             TEXTEQU         <31:16>
;  -W-4R 
;  3971 : #define NV_UW95TXT_SIZE_OUT_E                            0x004C13F8 /* -W-4R */
NV_UW95TXT_SIZE_OUT_E           EQU             0004c13f8h
;  -W-UF 
;  3972 : #define NV_UW95TXT_SIZE_OUT_E_WIDTH                            15:0 /* -W-UF */
NV_UW95TXT_SIZE_OUT_E_WIDTH             TEXTEQU         <15:0>
;  -W-UF 
;  3973 : #define NV_UW95TXT_SIZE_OUT_E_HEIGHT                          31:16 /* -W-UF */
NV_UW95TXT_SIZE_OUT_E_HEIGHT            TEXTEQU         <31:16>
;  -W-4R 
;  3974 : #define NV_UW95TXT_POINT_E                               0x004C13FC /* -W-4R */
NV_UW95TXT_POINT_E              EQU             0004c13fch
;  -W-SF 
;  3975 : #define NV_UW95TXT_POINT_E_X                                   15:0 /* -W-SF */
NV_UW95TXT_POINT_E_X            TEXTEQU         <15:0>
;  -W-SF 
;  3976 : #define NV_UW95TXT_POINT_E_Y                                  31:16 /* -W-SF */
NV_UW95TXT_POINT_E_Y            TEXTEQU         <31:16>
;  -W-4A 
;        
;  3977 : #define NV_UW95TXT_MONO_COLOR01_E(i)             (0x004C1400+(i)*4) /* -W-4A */
;  3978 : #define NV_UW95TXT_MONO_COLOR01_E__SIZE_1                       128 /*       */
NV_UW95TXT_MONO_COLOR01_E__SIZE_1               EQU             128t
;  -W-VF 
;  3979 : #define NV_UW95TXT_MONO_COLOR01_E_BITMAP                       31:0 /* -W-VF */
NV_UW95TXT_MONO_COLOR01_E_BITMAP                TEXTEQU         <31:0>
;  usr_image_in_mem.ref 
;  -W--D 
;  3980 : /* usr_image_in_mem.ref */
;  3981 : #define NV_UINMEM                             0x005C1FFF:0x005C0000 /* -W--D */
NV_UINMEM               TEXTEQU         <0x005C1FFF:0x005C0000>
;  -W-4R 
;  3982 : #define NV_UINMEM_CTX_SWITCH                             0x005C0000 /* -W-4R */
NV_UINMEM_CTX_SWITCH            EQU             0005c0000h
;  -W-UF 
;  3983 : #define NV_UINMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
NV_UINMEM_CTX_SWITCH_INSTANCE           TEXTEQU         <15:0>
;  -W-UF 
;  3984 : #define NV_UINMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
NV_UINMEM_CTX_SWITCH_CHID               TEXTEQU         <22:16>
;  -W-VF 
;  3985 : #define NV_UINMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
NV_UINMEM_CTX_SWITCH_VOLATILE           TEXTEQU         <31:31>
;  -W--V 
;  3986 : #define NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE            EQU             000000000h
;  -W--V 
;  3987 : #define NV_UINMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
NV_UINMEM_CTX_SWITCH_VOLATILE_RESET             EQU             000000001h
;  -W-4R 
;  3988 : #define NV_UINMEM_SET_NOTIFY                             0x005C0104 /* -W-4R */
NV_UINMEM_SET_NOTIFY            EQU             0005c0104h
;  -W-VF 
;  3989 : #define NV_UINMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
NV_UINMEM_SET_NOTIFY_PARAMETER          TEXTEQU         <31:0>
;  -W--V 
;  3990 : #define NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE            EQU             000000000h
;  -W-4R 
;  3991 : #define NV_UINMEM_PITCH                                  0x005C0308 /* -W-4R */
NV_UINMEM_PITCH         EQU             0005c0308h
;  -WXUF 
;  3992 : #define NV_UINMEM_PITCH_VALUE                                  15:0 /* -WXUF */
NV_UINMEM_PITCH_VALUE           TEXTEQU         <15:0>
;  -W-4R 
;  3993 : #define NV_UINMEM_OFFSET                                 0x005C030C /* -W-4R */
NV_UINMEM_OFFSET                EQU             0005c030ch
;  -WIUF 
;  3994 : #define NV_UINMEM_OFFSET_LINADRS                               22:4 /* -WIUF */
NV_UINMEM_OFFSET_LINADRS                TEXTEQU         <22:4>
;  -WI-V 
;  3995 : #define NV_UINMEM_OFFSET_LINADRS_0                       0x00000000 /* -WI-V */
NV_UINMEM_OFFSET_LINADRS_0              EQU             000000000h
;  -W-4R 
;  3996 : #define NV_UINMEM_FORMAT                                 0x005C0300 /* -W-4R */
NV_UINMEM_FORMAT                EQU             0005c0300h
;  -WXUF 
;  3997 : #define NV_UINMEM_FORMAT_VALUE                                 31:0 /* -WXUF */
NV_UINMEM_FORMAT_VALUE          TEXTEQU         <31:0>
;  -W--V 
;  3998 : #define NV_UINMEM_FORMAT_VALUE_LE_Y8_P4                  0x01010000 /* -W--V */
NV_UINMEM_FORMAT_VALUE_LE_Y8_P4         EQU             001010000h
;  -W--V 
;  3999 : #define NV_UINMEM_FORMAT_VALUE_LE_Y16_P2                 0x01010001 /* -W--V */
NV_UINMEM_FORMAT_VALUE_LE_Y16_P2                EQU             001010001h
;  -W--V 
;  4000 : #define NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_P2            0x01000000 /* -W--V */
NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_P2           EQU             001000000h
;  -W--V 
;  4001 : #define NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8               0x00000001 /* -W--V */
NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8              EQU             000000001h
;  dev_framebuffer.ref 
;  RW--D 
;  4002 : /* dev_framebuffer.ref */
;  4003 : #define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
NV_PFB          TEXTEQU         <0x00100FFF:0x00100000>
;  RW-4R 
;  4004 : #define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
NV_PFB_BOOT_0           EQU             000100000h
;  RWIVF 
;  4005 : #define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RWIVF */
NV_PFB_BOOT_0_RAM_AMOUNT                TEXTEQU         <1:0>
;  RW--V 
;  4006 : #define NV_PFB_BOOT_0_RAM_AMOUNT_1MB                     0x00000000 /* RW--V */
NV_PFB_BOOT_0_RAM_AMOUNT_1MB            EQU             000000000h
;  RW--V 
;  4007 : #define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000001 /* RW--V */
NV_PFB_BOOT_0_RAM_AMOUNT_2MB            EQU             000000001h
;  RW--V 
;  4008 : #define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000002 /* RW--V */
NV_PFB_BOOT_0_RAM_AMOUNT_4MB            EQU             000000002h
;  RWI-V 
;  4009 : #define NV_PFB_BOOT_0_RAM_AMOUNT_DEFAULT                 0x00000002 /* RWI-V */
NV_PFB_BOOT_0_RAM_AMOUNT_DEFAULT                EQU             000000002h
;  RW-VF 
;  4010 : #define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
NV_PFB_BOOT_0_RAM_WIDTH_128             TEXTEQU         <2:2>
;  RW--V 
;  4011 : #define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
NV_PFB_BOOT_0_RAM_WIDTH_128_OFF         EQU             000000000h
;  RW--V 
;  4012 : #define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
NV_PFB_BOOT_0_RAM_WIDTH_128_ON          EQU             000000001h
;  RW-4R 
;  4013 : #define NV_PFB_DELAY_1                                   0x00100044 /* RW-4R */
NV_PFB_DELAY_1          EQU             000100044h
;  RWIUF 
;  4014 : #define NV_PFB_DELAY_1_WRITE_ENABLE_RISE                        1:0 /* RWIUF */
NV_PFB_DELAY_1_WRITE_ENABLE_RISE                TEXTEQU         <1:0>
;  RWI-V 
;  4015 : #define NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0               0x00000000 /* RWI-V */
NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0              EQU             000000000h
;  RWIUF 
;  4016 : #define NV_PFB_DELAY_1_WRITE_ENABLE_FALL                        5:4 /* RWIUF */
NV_PFB_DELAY_1_WRITE_ENABLE_FALL                TEXTEQU         <5:4>
;  RWI-V 
;  4017 : #define NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0               0x00000000 /* RWI-V */
NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0              EQU             000000000h
;  RWIUF 
;  4018 : #define NV_PFB_DELAY_1_CAS_ENABLE_RISE                          9:8 /* RWIUF */
NV_PFB_DELAY_1_CAS_ENABLE_RISE          TEXTEQU         <9:8>
;  RWI-V 
;  4019 : #define NV_PFB_DELAY_1_CAS_ENABLE_RISE_0                 0x00000000 /* RWI-V */
NV_PFB_DELAY_1_CAS_ENABLE_RISE_0                EQU             000000000h
;  RWIUF 
;  4020 : #define NV_PFB_DELAY_1_CAS_ENABLE_FALL                        13:12 /* RWIUF */
NV_PFB_DELAY_1_CAS_ENABLE_FALL          TEXTEQU         <13:12>
;  RWI-V 
;  4021 : #define NV_PFB_DELAY_1_CAS_ENABLE_FALL_0                 0x00000000 /* RWI-V */
NV_PFB_DELAY_1_CAS_ENABLE_FALL_0                EQU             000000000h
;  RWIUF 
;  4022 : #define NV_PFB_DELAY_1_OUTPUT_DATA                            17:16 /* RWIUF */
NV_PFB_DELAY_1_OUTPUT_DATA              TEXTEQU         <17:16>
;  RWI-V 
;  4023 : #define NV_PFB_DELAY_1_OUTPUT_DATA_0                     0x00000000 /* RWI-V */
NV_PFB_DELAY_1_OUTPUT_DATA_0            EQU             000000000h
;  RWIUF 
;  4024 : #define NV_PFB_DELAY_1_RAS_ENABLE                             21:20 /* RWIUF */
NV_PFB_DELAY_1_RAS_ENABLE               TEXTEQU         <21:20>
;  RWI-V 
;  4025 : #define NV_PFB_DELAY_1_RAS_ENABLE_0                      0x00000000 /* RWI-V */
NV_PFB_DELAY_1_RAS_ENABLE_0             EQU             000000000h
;  RW-4R 
;  4026 : #define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
NV_PFB_DEBUG_0          EQU             000100080h
;  RWIVF 
;  4027 : #define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
NV_PFB_DEBUG_0_PAGE_MODE                TEXTEQU         <0:0>
;  RWI-V 
;  4028 : #define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                EQU             000000000h
;  RW--V 
;  4029 : #define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
NV_PFB_DEBUG_0_PAGE_MODE_DISABLED               EQU             000000001h
;  RWIVF 
;  4030 : #define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
NV_PFB_DEBUG_0_REFRESH          TEXTEQU         <4:4>
;  RWI-V 
;  4031 : #define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
NV_PFB_DEBUG_0_REFRESH_ENABLED          EQU             000000000h
;  RW--V 
;  4032 : #define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
NV_PFB_DEBUG_0_REFRESH_DISABLED         EQU             000000001h
;  RWIVF 
;  4033 : #define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        12:8 /* RWIVF */
NV_PFB_DEBUG_0_REFRESH_COUNTX64         TEXTEQU         <12:8>
;  RWI-V 
;  4034 : #define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT         EQU             000000010h
;  RWIVF 
;  4035 : #define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
NV_PFB_DEBUG_0_CASOE            TEXTEQU         <20:20>
;  RWI-V 
;  4036 : #define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
NV_PFB_DEBUG_0_CASOE_ENABLED            EQU             000000000h
;  RW--V 
;  4037 : #define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
NV_PFB_DEBUG_0_CASOE_DISABLED           EQU             000000001h
;  RWIVF 
;  4038 : #define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
NV_PFB_DEBUG_0_CKE_INVERT               TEXTEQU         <28:28>
;  RWIVF 
;  4039 : #define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWIVF */
NV_PFB_DEBUG_0_CKE_INVERT_OFF           EQU             000000000h
;  RW-VF 
;  4040 : #define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW-VF */
NV_PFB_DEBUG_0_CKE_INVERT_ON            EQU             000000001h
;  RWIVF 
;  4041 : #define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
NV_PFB_DEBUG_0_CKE_ALWAYSON             TEXTEQU         <29:29>
;  RW-VF 
;  4042 : #define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW-VF */
NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF         EQU             000000000h
;  RWIVF 
;  4043 : #define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWIVF */
NV_PFB_DEBUG_0_CKE_ALWAYSON_ON          EQU             000000001h
;  RWIVF 
;  4044 : #define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
NV_PFB_DEBUG_0_SAVE_POWER               TEXTEQU         <30:30>
;  RWIVF 
;  4045 : #define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWIVF */
NV_PFB_DEBUG_0_SAVE_POWER_ON            EQU             000000000h
;  RW-VF 
;  4046 : #define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW-VF */
NV_PFB_DEBUG_0_SAVE_POWER_OFF           EQU             000000001h
;  RW-4R 
;  4047 : #define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
NV_PFB_GREEN_0          EQU             0001000c0h
;  RWIVF 
;  4048 : #define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
NV_PFB_GREEN_0_LEVEL            TEXTEQU         <1:0>
;  RW--V 
;  4049 : #define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED              EQU             000000000h
;  RW--V 
;  4050 : #define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED             EQU             000000001h
;  RW--V 
;  4051 : #define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED            EQU             000000002h
;  RWI-V 
;  4052 : #define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED            EQU             000000003h
;  RW-4R 
;  4053 : #define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
NV_PFB_CONFIG_0         EQU             000100200h
;  RWIVF 
;  4054 : #define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
NV_PFB_CONFIG_0_RESOLUTION              TEXTEQU         <5:0>
;  RW--V 
;  4055 : #define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS           EQU             00000000ah
;  RW--V 
;  4056 : #define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS           EQU             00000000dh
;  RW--V 
;  4057 : #define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS           EQU             00000000fh
;  RW--V 
;  4058 : #define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS           EQU             000000010h
;  RW--V 
;  4059 : #define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS           EQU             000000014h
;  RW--V 
;  4060 : #define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS           EQU             000000019h
;  RW--V 
;  4061 : #define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS           EQU             00000001eh
;  RW--V 
;  4062 : #define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS          EQU             000000020h
;  RW--V 
;  4063 : #define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS          EQU             000000024h
;  RW--V 
;  4064 : #define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS          EQU             000000028h
;  RW--V 
;  4065 : #define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS          EQU             000000032h
;  RWI-V 
;  4066 : #define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
NV_PFB_CONFIG_0_RESOLUTION_DEFAULT              EQU             000000014h
;  RWIVF 
;  4067 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
NV_PFB_CONFIG_0_PIXEL_DEPTH             TEXTEQU         <9:8>
;  RW--V 
;  4068 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS              EQU             000000001h
;  RW--V 
;  4069 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS             EQU             000000002h
;  RW--V 
;  4070 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS             EQU             000000003h
;  RWI-V 
;  4071 : #define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT             EQU             000000001h
;  RWIVF 
;  4072 : #define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
NV_PFB_CONFIG_0_TILING          TEXTEQU         <12:12>
;  RW--V 
;  4073 : #define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
NV_PFB_CONFIG_0_TILING_ENABLED          EQU             000000000h
;  RWI-V 
;  4074 : #define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
NV_PFB_CONFIG_0_TILING_DISABLED         EQU             000000001h
;  RWIVF 
;  4075 : #define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
NV_PFB_CONFIG_0_TILING_DEBUG            TEXTEQU         <23:13>
;  RW--V 
;  4076 : #define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED           EQU             000000000h
;  RW-4R 
;  4077 : #define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
NV_PFB_CONFIG_1         EQU             000100204h
;  RWIVF 
;  4078 : #define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
NV_PFB_CONFIG_1_CAS_LATENCY             TEXTEQU         <2:0>
;  RWI-V 
;  4079 : #define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
NV_PFB_CONFIG_1_CAS_LATENCY_3           EQU             000000003h
;  RWIVF 
;  4080 : #define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
NV_PFB_CONFIG_1_SGRAM100                TEXTEQU         <3:3>
;  RWI-V 
;  4081 : #define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_SGRAM100_ENABLED                EQU             000000000h
;  RW--V 
;  4082 : #define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
NV_PFB_CONFIG_1_SGRAM100_DISABLED               EQU             000000001h
;  RWIUF 
;  4083 : #define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
NV_PFB_CONFIG_1_RAS_RAS         TEXTEQU         <7:4>
;  RWI-V 
;  4084 : #define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
NV_PFB_CONFIG_1_RAS_RAS_DEFAULT         EQU             000000009h
;  RW--V 
;  4085 : #define NV_PFB_CONFIG_1_RAS_RAS_SG100                    0x00000004 /* RW--V */
NV_PFB_CONFIG_1_RAS_RAS_SG100           EQU             000000004h
;  RWIUF 
;  4086 : #define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
NV_PFB_CONFIG_1_RAS_PCHG                TEXTEQU         <10:8>
;  RWI-V 
;  4087 : #define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                EQU             000000002h
;  RW--V 
;  4088 : #define NV_PFB_CONFIG_1_RAS_PCHG_SG100                   0x00000001 /* RW--V */
NV_PFB_CONFIG_1_RAS_PCHG_SG100          EQU             000000001h
;  RWIUF 
;  4089 : #define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
NV_PFB_CONFIG_1_RAS_LOW         TEXTEQU         <14:12>
;  RWI-V 
;  4090 : #define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
NV_PFB_CONFIG_1_RAS_LOW_DEFAULT         EQU             000000006h
;  RW--V 
;  4091 : #define NV_PFB_CONFIG_1_RAS_LOW_SG100                    0x00000003 /* RW--V */
NV_PFB_CONFIG_1_RAS_LOW_SG100           EQU             000000003h
;  RWIUF 
;  4092 : #define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
NV_PFB_CONFIG_1_MRS_TO_RAS              TEXTEQU         <18:16>
;  RWI-V 
;  4093 : #define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT              EQU             000000001h
;  RW--V 
;  4094 : #define NV_PFB_CONFIG_1_MRS_TO_RAS_SG100                 0x00000000 /* RW--V */
NV_PFB_CONFIG_1_MRS_TO_RAS_SG100                EQU             000000000h
;  RWIUF 
;  4095 : #define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
NV_PFB_CONFIG_1_WRITE_TO_READ           TEXTEQU         <22:20>
;  RWI-V 
;  4096 : #define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT           EQU             000000000h
;  RW--V 
;  4097 : #define NV_PFB_CONFIG_1_WRITE_TO_READ_SG100              0x00000000 /* RW--V */
NV_PFB_CONFIG_1_WRITE_TO_READ_SG100             EQU             000000000h
;  RWIUF 
;  4098 : #define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
NV_PFB_CONFIG_1_RAS_TO_CAS_M1           TEXTEQU         <26:24>
;  RWI-V 
;  4099 : #define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT           EQU             000000001h
;  RWI-V 
;  4100 : #define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_SG100              0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_RAS_TO_CAS_M1_SG100             EQU             000000000h
;  RWIUF 
;  4101 : #define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
NV_PFB_CONFIG_1_READ_TO_WRITE           TEXTEQU         <30:28>
;  RWI-V 
;  4102 : #define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */ 
NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT           EQU             000000004h
;  RWI-V 
;  4103 : #define NV_PFB_CONFIG_1_READ_TO_WRITE_SG100              0x00000002 /* RWI-V */ 
NV_PFB_CONFIG_1_READ_TO_WRITE_SG100             EQU             000000002h
;  RWIUF 
;  4104 : #define NV_PFB_CONFIG_1_ED_RAC1                                 0:0 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC1         TEXTEQU         <0:0>
;  RWI-V 
;  4105 : #define NV_PFB_CONFIG_1_ED_RAC1_DEFAULT                  0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC1_DEFAULT         EQU             000000000h
;  RWIUF 
;  4106 : #define NV_PFB_CONFIG_1_ED_RWT1                                 1:1 /* RWIUF */
NV_PFB_CONFIG_1_ED_RWT1         TEXTEQU         <1:1>
;  RWI-V 
;  4107 : #define NV_PFB_CONFIG_1_ED_RWT1_DEFAULT                  0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RWT1_DEFAULT         EQU             000000001h
;  RWIUF 
;  4108 : #define NV_PFB_CONFIG_1_ED_RPC1                                 2:2 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC1         TEXTEQU         <2:2>
;  RWI-V 
;  4109 : #define NV_PFB_CONFIG_1_ED_RPC1_DEFAULT                  0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC1_DEFAULT         EQU             000000001h
;  RWIUF 
;  4110 : #define NV_PFB_CONFIG_1_ED_PMAW                                 4:4 /* RWIUF */
NV_PFB_CONFIG_1_ED_PMAW         TEXTEQU         <4:4>
;  RWI-V 
;  4111 : #define NV_PFB_CONFIG_1_ED_PMAW_DEFAULT                  0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_PMAW_DEFAULT         EQU             000000000h
;  RWIUF 
;  4112 : #define NV_PFB_CONFIG_1_ED_PAGE                                 5:5 /* RWIUF */
NV_PFB_CONFIG_1_ED_PAGE         TEXTEQU         <5:5>
;  RWI-V 
;  4113 : #define NV_PFB_CONFIG_1_ED_PAGE_DEFAULT                  0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_PAGE_DEFAULT         EQU             000000000h
;  RWIUF 
;  4114 : #define NV_PFB_CONFIG_1_ED_RAC0_0                               8:8 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC0_0               TEXTEQU         <8:8>
;  RWI-V 
;  4115 : #define NV_PFB_CONFIG_1_ED_RAC0_0_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC0_0_DEFAULT               EQU             000000000h
;  RWIUF 
;  4116 : #define NV_PFB_CONFIG_1_ED_RAC0_1                               9:9 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC0_1               TEXTEQU         <9:9>
;  RWI-V 
;  4117 : #define NV_PFB_CONFIG_1_ED_RAC0_1_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC0_1_DEFAULT               EQU             000000000h
;  RWIUF 
;  4118 : #define NV_PFB_CONFIG_1_ED_RAC1_0                             10:10 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC1_0               TEXTEQU         <10:10>
;  RWI-V 
;  4119 : #define NV_PFB_CONFIG_1_ED_RAC1_0_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC1_0_DEFAULT               EQU             000000001h
;  RWIUF 
;  4120 : #define NV_PFB_CONFIG_1_ED_RAC1_1                             12:12 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAC1_1               TEXTEQU         <12:12>
;  RWI-V 
;  4121 : #define NV_PFB_CONFIG_1_ED_RAC1_1_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAC1_1_DEFAULT               EQU             000000000h
;  RWIUF 
;  4122 : #define NV_PFB_CONFIG_1_ED_RAD0_0                             13:13 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAD0_0               TEXTEQU         <13:13>
;  RWI-V 
;  4123 : #define NV_PFB_CONFIG_1_ED_RAD0_0_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAD0_0_DEFAULT               EQU             000000001h
;  RWIUF 
;  4124 : #define NV_PFB_CONFIG_1_ED_RAD0_1                             14:14 /* RWIUF */
NV_PFB_CONFIG_1_ED_RAD0_1               TEXTEQU         <14:14>
;  RWI-V 
;  4125 : #define NV_PFB_CONFIG_1_ED_RAD0_1_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RAD0_1_DEFAULT               EQU             000000001h
;  RWIUF 
;  4126 : #define NV_PFB_CONFIG_1_ED_RPC0_0                             16:16 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC0_0               TEXTEQU         <16:16>
;  RWI-V 
;  4127 : #define NV_PFB_CONFIG_1_ED_RPC0_0_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC0_0_DEFAULT               EQU             000000000h
;  RWIUF 
;  4128 : #define NV_PFB_CONFIG_1_ED_RPC0_1                             17:17 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC0_1               TEXTEQU         <17:17>
;  RWI-V 
;  4129 : #define NV_PFB_CONFIG_1_ED_RPC0_1_DEFAULT                0x00000000 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC0_1_DEFAULT               EQU             000000000h
;  RWIUF 
;  4130 : #define NV_PFB_CONFIG_1_ED_RPC1_0                             18:18 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC1_0               TEXTEQU         <18:18>
;  RWI-V 
;  4131 : #define NV_PFB_CONFIG_1_ED_RPC1_0_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC1_0_DEFAULT               EQU             000000001h
;  RWIUF 
;  4132 : #define NV_PFB_CONFIG_1_ED_RPC1_1                             20:20 /* RWIUF */
NV_PFB_CONFIG_1_ED_RPC1_1               TEXTEQU         <20:20>
;  RWI-V 
;  4133 : #define NV_PFB_CONFIG_1_ED_RPC1_1_DEFAULT                0x00000001 /* RWI-V */
NV_PFB_CONFIG_1_ED_RPC1_1_DEFAULT               EQU             000000001h
;  RW-4R 
;  4134 : #define NV_PFB_RTL                                       0x00100300 /* RW-4R */
NV_PFB_RTL              EQU             000100300h
;  RWIUF 
;  4135 : #define NV_PFB_RTL_S                                            1:0 /* RWIUF */
NV_PFB_RTL_S            TEXTEQU         <1:0>
;  RWI-V 
;  4136 : #define NV_PFB_RTL_S_DEFAULT                             0x00000002 /* RWI-V */
NV_PFB_RTL_S_DEFAULT            EQU             000000002h
;  RWIUF 
;  4137 : #define NV_PFB_RTL_V                                            5:4 /* RWIUF */
NV_PFB_RTL_V            TEXTEQU         <5:4>
;  RWI-V 
;  4138 : #define NV_PFB_RTL_V_DEFAULT                             0x00000002 /* RWI-V */
NV_PFB_RTL_V_DEFAULT            EQU             000000002h
;  RWIUF 
;  4139 : #define NV_PFB_RTL_M                                            9:8 /* RWIUF */
NV_PFB_RTL_M            TEXTEQU         <9:8>
;  RWI-V 
;  4140 : #define NV_PFB_RTL_M_DEFAULT                             0x00000002 /* RWI-V */
NV_PFB_RTL_M_DEFAULT            EQU             000000002h
;  RWIUF 
;  4141 : #define NV_PFB_RTL_H                                          13:12 /* RWIUF */
NV_PFB_RTL_H            TEXTEQU         <13:12>
;  RWI-V 
;  4142 : #define NV_PFB_RTL_H_DEFAULT                             0x00000001 /* RWI-V */
NV_PFB_RTL_H_DEFAULT            EQU             000000001h
;  RWIUF 
;  4143 : #define NV_PFB_RTL_A                                          17:16 /* RWIUF */
NV_PFB_RTL_A            TEXTEQU         <17:16>
;  RWI-V 
;  4144 : #define NV_PFB_RTL_A_DEFAULT                             0x00000001 /* RWI-V */
NV_PFB_RTL_A_DEFAULT            EQU             000000001h
;  RWIUF 
;  4145 : #define NV_PFB_RTL_G                                          21:20 /* RWIUF */
NV_PFB_RTL_G            TEXTEQU         <21:20>
;  RWI-V 
;  4146 : #define NV_PFB_RTL_G_DEFAULT                             0x00000001 /* RWI-V */
NV_PFB_RTL_G_DEFAULT            EQU             000000001h
;  RWIUF 
;  4147 : #define NV_PFB_RTL_ARB_GR_HI_PRIOR                            24:24 /* RWIUF */
NV_PFB_RTL_ARB_GR_HI_PRIOR              TEXTEQU         <24:24>
;  RWI-V 
;  4148 : #define NV_PFB_RTL_ARB_GR_HI_PRIOR_DEFAULT               0x00000000 /* RWI-V */
NV_PFB_RTL_ARB_GR_HI_PRIOR_DEFAULT              EQU             000000000h
;  RWIUF 
;  4149 : #define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR                         28:28 /* RWIUF */
NV_PFB_RTL_ARB_MEDIA_HI_PRIOR           TEXTEQU         <28:28>
;  RWI-V 
;  4150 : #define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR_DEFAULT            0x00000000 /* RWI-V */
NV_PFB_RTL_ARB_MEDIA_HI_PRIOR_DEFAULT           EQU             000000000h
;  dev_framebuffer.ref 
;  RW--M 
;  4151 : /* dev_framebuffer.ref */
;  4152 : #define NV_PNVM                               0x01BFFFFF:0x01800000 /* RW--M */
NV_PNVM         TEXTEQU         <0x01BFFFFF:0x01800000>
;  RW-4A 
;        
;  4153 : #define NV_PNVM_DATA032(i)                       (0x01800000+(i)*4) /* RW-4A */
;  4154 : #define NV_PNVM_DATA032__SIZE_1                              524288 /*       */
NV_PNVM_DATA032__SIZE_1         EQU             524288t
;  RWXVF 
;  4155 : #define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
NV_PNVM_DATA032_VALUE           TEXTEQU         <31:0>
;  RW-3A 
;        
;  4156 : #define NV_PNVM_DATA024(i)           (0x01800000+((i)/2)*4+((i)%2)) /* RW-3A */
;  4157 : #define NV_PNVM_DATA024__SIZE_1                             1048576 /*       */
NV_PNVM_DATA024__SIZE_1         EQU             1048576t
;  RWXVF 
;  4158 : #define NV_PNVM_DATA024_VALUE                                  23:0 /* RWXVF */
NV_PNVM_DATA024_VALUE           TEXTEQU         <23:0>
;  RW-2A 
;        
;  4159 : #define NV_PNVM_DATA016(i)           (0x01800000+((i)/3)*4+((i)%3)) /* RW-2A */
;  4160 : #define NV_PNVM_DATA016__SIZE_1                             1572864 /*       */
NV_PNVM_DATA016__SIZE_1         EQU             1572864t
;  RWXVF 
;  4161 : #define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
NV_PNVM_DATA016_VALUE           TEXTEQU         <15:0>
;  RW-1A 
;        
;  4162 : #define NV_PNVM_DATA008(i)                         (0x01800000+(i)) /* RW-1A */
;  4163 : #define NV_PNVM_DATA008__SIZE_1                             2097152 /*       */
NV_PNVM_DATA008__SIZE_1         EQU             2097152t
;  RWXVF 
;  4164 : #define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
NV_PNVM_DATA008_VALUE           TEXTEQU         <7:0>
;  dev_framebuffer.ref 
;  RW--M 
;  4165 : /* dev_framebuffer.ref */
;  4166 : #define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
NV_PRAMIN               TEXTEQU         <0x01FFFFFF:0x01C00000>
;  RW-4A 
;        
;  4167 : #define NV_PRAMIN_DATA032(i)                       (0x01C00000+(i)*4) /* RW-4A */
;  4168 : #define NV_PRAMIN_DATA032__SIZE_1                              524288 /*       */
NV_PRAMIN_DATA032__SIZE_1               EQU             524288t
;  RWXVF 
;  4169 : #define NV_PRAMIN_DATA032_VALUE                                  31:0 /* RWXVF */
NV_PRAMIN_DATA032_VALUE         TEXTEQU         <31:0>
;  RW-3A 
;        
;  4170 : #define NV_PRAMIN_DATA024(i)           (0x01C00000+((i)/2)*4+((i)%2)) /* RW-3A */
;  4171 : #define NV_PRAMIN_DATA024__SIZE_1                             1048576 /*       */
NV_PRAMIN_DATA024__SIZE_1               EQU             1048576t
;  RWXVF 
;  4172 : #define NV_PRAMIN_DATA024_VALUE                                  23:0 /* RWXVF */
NV_PRAMIN_DATA024_VALUE         TEXTEQU         <23:0>
;  RW-2A 
;        
;  4173 : #define NV_PRAMIN_DATA016(i)           (0x01C00000+((i)/3)*4+((i)%3)) /* RW-2A */
;  4174 : #define NV_PRAMIN_DATA016__SIZE_1                             1572864 /*       */
NV_PRAMIN_DATA016__SIZE_1               EQU             1572864t
;  RWXVF 
;  4175 : #define NV_PRAMIN_DATA016_VALUE                                  15:0 /* RWXVF */
NV_PRAMIN_DATA016_VALUE         TEXTEQU         <15:0>
;  RW-1A 
;        
;  4176 : #define NV_PRAMIN_DATA008(i)                         (0x01C00000+(i)) /* RW-1A */
;  4177 : #define NV_PRAMIN_DATA008__SIZE_1                             2097152 /*       */
NV_PRAMIN_DATA008__SIZE_1               EQU             2097152t
;  RWXVF 
;  4178 : #define NV_PRAMIN_DATA008_VALUE                                   7:0 /* RWXVF */
NV_PRAMIN_DATA008_VALUE         TEXTEQU         <7:0>
;  dev_ram.ref 
;  RW--M 
;        
;  4179 : /* dev_ram.ref */
;  4180 : #define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
;  4181 : #define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
NV_PRAMIN_CONTEXT_0             TEXTEQU         <( 0*32+31):( 0*32+ 0)>
;        
;  4182 : #define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
NV_PRAMIN_CONTEXT_1             TEXTEQU         <( 1*32+31):( 1*32+ 0)>
;        
;  4183 : #define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
NV_PRAMIN_CONTEXT_2             TEXTEQU         <( 2*32+31):( 2*32+ 0)>
;        
;  4184 : #define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
NV_PRAMIN_CONTEXT_3             TEXTEQU         <( 3*32+31):( 3*32+ 0)>
;  RW--M 
;  4185 : #define NV_PRAMIN_RAMHT_0                     0x01400FFF:0x01400000 /* RW--M */
NV_PRAMIN_RAMHT_0               TEXTEQU         <0x01400FFF:0x01400000>
;  RW--M 
;     9 : #define NV_PRAMIN_RAMAU_0                     0x01401BFF:0x01401000 /* RW--M */
NV_PRAMIN_RAMAU_0               TEXTEQU         <0x01401BFF:0x01401000>
;  RW--M 
;    10 : #define NV_PRAMIN_RAMFC_0                     0x01401DFF:0x01401C00 /* RW--M */
NV_PRAMIN_RAMFC_0               TEXTEQU         <0x01401DFF:0x01401C00>
;  RW--M 
;    11 : #define NV_PRAMIN_RAMRO_0                     0x01401FFF:0x01401E00 /* RW--M */
NV_PRAMIN_RAMRO_0               TEXTEQU         <0x01401FFF:0x01401E00>
;  RW--M 
;    12 : #define NV_PRAMIN_RAMRM_0                     0x01402FFF:0x01402000 /* RW--M */
NV_PRAMIN_RAMRM_0               TEXTEQU         <0x01402FFF:0x01402000>
;  dev_framebuffer.ref 
;  RW--D 
;    13 : /* dev_framebuffer.ref */
;    14 : #define NV_PDFB                               0x017FFFFF:0x01000000 /* RW--D */
NV_PDFB         TEXTEQU         <0x017FFFFF:0x01000000>
;  RW-4A 
;        
;    15 : #define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
;    16 : #define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
NV_PDFB_DATA032__SIZE_1         EQU             524288t
;  RWXVF 
;    17 : #define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
NV_PDFB_DATA032_VALUE           TEXTEQU         <31:0>
;  RW-3A 
;        
;    18 : #define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
;    19 : #define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
NV_PDFB_DATA024__SIZE_1         EQU             1048576t
;  RWXVF 
;    20 : #define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
NV_PDFB_DATA024_VALUE           TEXTEQU         <23:0>
;  RW-2A 
;        
;    21 : #define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
;    22 : #define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
NV_PDFB_DATA016__SIZE_1         EQU             1572864t
;  RWXVF 
;    23 : #define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
NV_PDFB_DATA016_VALUE           TEXTEQU         <15:0>
;  RW-1A 
;        
;    24 : #define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
;    25 : #define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
NV_PDFB_DATA008__SIZE_1         EQU             2097152t
;  RWXVF 
;    26 : #define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
NV_PDFB_DATA008_VALUE           TEXTEQU         <7:0>
;  dev_ram.ref 
;  RW--D 
;    27 : /* dev_ram.ref */
;    28 : #define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
NV_PRAM         TEXTEQU         <0x00006FFF:0x00006000>
;  dev_ext_devices.ref 
;  RW--D 
;    29 : /* dev_ext_devices.ref */
;    30 : #define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
NV_PEXTDEV              TEXTEQU         <0x00101FFF:0x00101000>
;  R--4R 
;    31 : #define NV_PEXTDEV_BOOT_0                                0x00101000 /* R--4R */
NV_PEXTDEV_BOOT_0               EQU             000101000h
;  R-XVF 
;    32 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED                       0:0 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED               TEXTEQU         <0:0>
;  R---V 
;    33 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ          0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ         EQU             000000000h
;  R---V 
;    34 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ          0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ         EQU             000000001h
;  R-XVF 
;    35 : #define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR              TEXTEQU         <1:1>
;  R---V 
;    36 : #define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS              EQU             000000000h
;  R---V 
;    37 : #define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS         EQU             000000001h
;  R-XVF 
;    38 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        3:2 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                TEXTEQU         <3:2>
;  R---V 
;    39 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO             0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO            EQU             000000000h
;  R---V 
;    40 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K      0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K             EQU             000000001h
;  R---V 
;    41 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_RESERVED        0x00000002 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_RESERVED               EQU             000000002h
;  R---V 
;    42 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K      0x00000003 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K             EQU             000000003h
;  R-XVF 
;    43 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH                       4:4 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH               TEXTEQU         <4:4>
;  R---V 
;    44 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64             0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64            EQU             000000000h
;  R---V 
;    45 : #define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128            0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128           EQU             000000001h
;  R-XVF 
;    46 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        5:5 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                TEXTEQU         <5:5>
;  R---V 
;    47 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI            EQU             000000000h
;  R---V 
;    48 : #define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP            EQU             000000001h
;  R-XVF 
;    49 : #define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL         TEXTEQU         <6:6>
;  R---V 
;    50 : #define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K          EQU             000000000h
;  R---V 
;    51 : #define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180                EQU             000000001h
;  R-XVF 
;    52 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE          TEXTEQU         <8:7>
;  R---V 
;    53 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM            EQU             000000000h
;  R---V 
;    54 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC             EQU             000000001h
;  R---V 
;    55 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL              EQU             000000002h
;  R---V 
;    56 : #define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED         EQU             000000003h
;  R-XVF 
;    57 : #define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE                        9:9 /* R-XVF */
NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE                TEXTEQU         <9:9>
;  R---V 
;    58 : #define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_20              0x00000000 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_20             EQU             000000000h
;  R---V 
;    59 : #define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_21              0x00000001 /* R---V */
NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_21             EQU             000000001h
;  dev_ext_devices.ref 
;  RW--D 
;    60 : /* dev_ext_devices.ref */
;    61 : #define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
NV_PDAC         TEXTEQU         <0x00680FFF:0x00680000>
;  RW-4A 
;        
;    62 : #define NV_PDAC_DATA(i)                          (0x00500000+(i)*4) /* RW-4A */
;    63 : #define NV_PDAC_DATA__SIZE_1                                     16 /*       */
NV_PDAC_DATA__SIZE_1            EQU             16t
;  RW-VF 
;    64 : #define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
NV_PDAC_DATA_VALUE              TEXTEQU         <7:0>
;  dev_ext_devices.ref 
;  dev_ext_devices.ref 
;  RW--D 
;    65 : /* dev_ext_devices.ref */
;    66 : /* dev_ext_devices.ref */
;    67 : #define NV_PROM                               0x0011FFFF:0x00110000 /* RW--D */
NV_PROM         TEXTEQU         <0x0011FFFF:0x00110000>
;  RW-1A 
;        
;    68 : #define NV_PROM_DATA(i)                            (0x00110000+(i)) /* RW-1A */
;    69 : #define NV_PROM_DATA__SIZE_1                                  65536 /*       */
NV_PROM_DATA__SIZE_1            EQU             65536t
;  RW-VF 
;    70 : #define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
NV_PROM_DATA_VALUE              TEXTEQU         <7:0>
;  dev_ext_devices.ref 
;  RW--D 
;    71 : /* dev_ext_devices.ref */
;    72 : #define NV_PALT                               0x0012FFFF:0x00120000 /* RW--D */
NV_PALT         TEXTEQU         <0x0012FFFF:0x00120000>
;  RW-1A 
;        
;    73 : #define NV_PALT_DATA(i)                            (0x00120000+(i)) /* RW-1A */
;    74 : #define NV_PALT_DATA__SIZE_1                                  65536 /*       */
NV_PALT_DATA__SIZE_1            EQU             65536t
;  RW-VF 
;    75 : #define NV_PALT_DATA_VALUE                                      7:0 /* RW-VF */
NV_PALT_DATA_VALUE              TEXTEQU         <7:0>
;  dev_realmode.ref 
;  RW--D 
;    76 : /* dev_realmode.ref */
;    77 : #define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
NV_PRM          TEXTEQU         <0x00005FFF:0x00004000>
;  RW-4R 
;    78 : #define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
NV_PRM_INTR_0           EQU             000004100h
;  RWXVF 
;    79 : #define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
NV_PRM_INTR_0_TRACE_MPU401              TEXTEQU         <0:0>
;  R---V 
;    80 : #define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING          EQU             000000000h
;  R---V 
;    81 : #define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_MPU401_PENDING              EQU             000000001h
;  -W--V 
;    82 : #define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_MPU401_RESET                EQU             000000001h
;  RWXVF 
;    83 : #define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
NV_PRM_INTR_0_TRACE_FM          TEXTEQU         <4:4>
;  R---V 
;    84 : #define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_FM_NOT_PENDING              EQU             000000000h
;  R---V 
;    85 : #define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_FM_PENDING          EQU             000000001h
;  -W--V 
;    86 : #define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_FM_RESET            EQU             000000001h
;  RWXVF 
;    87 : #define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
NV_PRM_INTR_0_TRACE_SB_DIGITAL          TEXTEQU         <8:8>
;  R---V 
;    88 : #define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING              EQU             000000000h
;  R---V 
;    89 : #define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING          EQU             000000001h
;  -W--V 
;    90 : #define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET            EQU             000000001h
;  RWXVF 
;    91 : #define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
NV_PRM_INTR_0_TRACE_SB_MIXER            TEXTEQU         <12:12>
;  R---V 
;    92 : #define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING                EQU             000000000h
;  R---V 
;    93 : #define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING            EQU             000000001h
;  -W--V 
;    94 : #define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_SB_MIXER_RESET              EQU             000000001h
;  RWXVF 
;    95 : #define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
NV_PRM_INTR_0_TRACE_OVERFLOW            TEXTEQU         <16:16>
;  R---V 
;    96 : #define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING                EQU             000000000h
;  R---V 
;    97 : #define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING            EQU             000000001h
;  -W--V 
;    98 : #define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
NV_PRM_INTR_0_TRACE_OVERFLOW_RESET              EQU             000000001h
;  RW-4R 
;    99 : #define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
NV_PRM_INTR_EN_0                EQU             000004140h
;  RWIVF 
;   100 : #define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_MPU401           TEXTEQU         <0:0>
;  RWI-V 
;   101 : #define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED          EQU             000000000h
;  RW--V 
;   102 : #define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED           EQU             000000001h
;  RWIVF 
;   103 : #define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_FM               TEXTEQU         <4:4>
;  RWI-V 
;   104 : #define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_FM_DISABLED              EQU             000000000h
;  RW--V 
;   105 : #define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_FM_ENABLED               EQU             000000001h
;  RWIVF 
;   106 : #define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL               TEXTEQU         <8:8>
;  RWI-V 
;   107 : #define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED              EQU             000000000h
;  RW--V 
;   108 : #define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED               EQU             000000001h
;  RWIVF 
;   109 : #define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_SB_MIXER         TEXTEQU         <12:12>
;  RWI-V 
;   110 : #define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED                EQU             000000000h
;  RW--V 
;   111 : #define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED         EQU             000000001h
;  RWIVF 
;   112 : #define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
NV_PRM_INTR_EN_0_TRACE_OVERFLOW         TEXTEQU         <16:16>
;  RWI-V 
;   113 : #define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED                EQU             000000000h
;  RW--V 
;   114 : #define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED         EQU             000000001h
;  RW-4R 
;   115 : #define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
NV_PRM_RAMRM            EQU             000004200h
;  RWXVF 
;   116 : #define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
NV_PRM_RAMRM_BASE_ADDRESS               TEXTEQU         <15:12>
;  RWI-V 
;   117 : #define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
NV_PRM_RAMRM_BASE_ADDRESS_2000          EQU             000002000h
;  RW-4R 
;   118 : #define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
NV_PRM_TRACE            EQU             000004300h
;  RWIVF 
;   119 : #define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
NV_PRM_TRACE_IO_CAPTURE         TEXTEQU         <1:0>
;  RWI-V 
;   120 : #define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
NV_PRM_TRACE_IO_CAPTURE_DISABLED                EQU             000000000h
;  RW--V 
;   121 : #define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
NV_PRM_TRACE_IO_CAPTURE_WRITES          EQU             000000001h
;  RW--V 
;   122 : #define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
NV_PRM_TRACE_IO_CAPTURE_READS           EQU             000000002h
;  RW--V 
;   123 : #define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
NV_PRM_TRACE_IO_CAPTURE_READS_WRITES            EQU             000000003h
;  RWXVF 
;   124 : #define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
NV_PRM_TRACE_IO_WRITE           TEXTEQU         <4:4>
;  R---V 
;   125 : #define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
NV_PRM_TRACE_IO_WRITE_NONE              EQU             000000000h
;  R---V 
;   126 : #define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
NV_PRM_TRACE_IO_WRITE_OCCURED           EQU             000000001h
;  -W--V 
;   127 : #define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
NV_PRM_TRACE_IO_WRITE_RESET             EQU             000000001h
;  RWXVF 
;   128 : #define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
NV_PRM_TRACE_IO_READ            TEXTEQU         <5:5>
;  R---V 
;   129 : #define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
NV_PRM_TRACE_IO_READ_NONE               EQU             000000000h
;  R---V 
;   130 : #define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
NV_PRM_TRACE_IO_READ_OCCURED            EQU             000000001h
;  -W--V 
;   131 : #define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
NV_PRM_TRACE_IO_READ_RESET              EQU             000000001h
;  RW-4R 
;   132 : #define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
NV_PRM_TRACE_INDEX              EQU             000004310h
;  RWXUF 
;   133 : #define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
NV_PRM_TRACE_INDEX_ADDRESS              TEXTEQU         <9:0>
;  RW--V 
;   134 : #define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
NV_PRM_TRACE_INDEX_ADDRESS_0            EQU             000000000h
;  RW-4R 
;   135 : #define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
NV_PRM_IGNORE_0         EQU             000004320h
;  RWXVF 
;   136 : #define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
NV_PRM_IGNORE_0_MPU401          TEXTEQU         <1:0>
;  RW--V 
;   137 : #define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
NV_PRM_IGNORE_0_MPU401_DISABLED         EQU             000000000h
;  RW--V 
;   138 : #define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
NV_PRM_IGNORE_0_MPU401_WRITES           EQU             000000001h
;  RW--V 
;   139 : #define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
NV_PRM_IGNORE_0_MPU401_READS            EQU             000000002h
;  RW--V 
;   140 : #define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
NV_PRM_IGNORE_0_MPU401_READS_WRITES             EQU             000000003h
;  RWXVF 
;   141 : #define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
NV_PRM_IGNORE_0_FM              TEXTEQU         <5:4>
;  RW--V 
;   142 : #define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
NV_PRM_IGNORE_0_FM_DISABLED             EQU             000000000h
;  RW--V 
;   143 : #define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
NV_PRM_IGNORE_0_FM_WRITES               EQU             000000001h
;  RW--V 
;   144 : #define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
NV_PRM_IGNORE_0_FM_READS                EQU             000000002h
;  RW--V 
;   145 : #define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
NV_PRM_IGNORE_0_FM_READS_WRITES         EQU             000000003h
;  RWXVF 
;   146 : #define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
NV_PRM_IGNORE_0_SB_DIGITAL              TEXTEQU         <9:8>
;  RW--V 
;   147 : #define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED             EQU             000000000h
;  RW--V 
;   148 : #define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
NV_PRM_IGNORE_0_SB_DIGITAL_WRITES               EQU             000000001h
;  RW--V 
;   149 : #define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
NV_PRM_IGNORE_0_SB_DIGITAL_READS                EQU             000000002h
;  RW--V 
;   150 : #define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES         EQU             000000003h
;  RWXVF 
;   151 : #define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
NV_PRM_IGNORE_0_SB_MIXER                TEXTEQU         <13:12>
;  RW--V 
;   152 : #define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
NV_PRM_IGNORE_0_SB_MIXER_DISABLED               EQU             000000000h
;  RW--V 
;   153 : #define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
NV_PRM_IGNORE_0_SB_MIXER_WRITES         EQU             000000001h
;  RW--V 
;   154 : #define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
NV_PRM_IGNORE_0_SB_MIXER_READS          EQU             000000002h
;  RW--V 
;   155 : #define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES           EQU             000000003h
;  dev_realmode.ref 
;  RW--D 
;   156 : /* dev_realmode.ref */
;   157 : #define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
NV_PRMIO                TEXTEQU         <0x00007FFF:0x00007000>
;  dev_realmode.ref 
;  dev_fifo.ref 
;  RW--D 
;   158 : /* dev_realmode.ref */
;   159 : /* dev_fifo.ref */
;   160 : #define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
NV_USER         TEXTEQU         <0x00FFFFFF:0x00800000>
;  -W-4A 
;        
;   161 : #define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
;   162 : #define NV_USER_OBJECT__SIZE_1                                  128 /*       */
NV_USER_OBJECT__SIZE_1          EQU             128t
;        
;   163 : #define NV_USER_OBJECT__SIZE_2                                    8 /*       */
NV_USER_OBJECT__SIZE_2          EQU             8t
;  -W-VF 
;   164 : #define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
NV_USER_OBJECT_HANDLE           TEXTEQU         <31:0>
;  R--2A 
;        
;   165 : #define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
;   166 : #define NV_USER_FREE016__SIZE_1                                 128 /*       */
NV_USER_FREE016__SIZE_1         EQU             128t
;        
;   167 : #define NV_USER_FREE016__SIZE_2                                   8 /*       */
NV_USER_FREE016__SIZE_2         EQU             8t
;  C--UF 
;   168 : #define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
NV_USER_FREE016_COUNT_LO                TEXTEQU         <1:0>
;  C---V 
;   169 : #define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
NV_USER_FREE016_COUNT_LO_0              EQU             000000000h
;  R--UF 
;   170 : #define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
NV_USER_FREE016_COUNT           TEXTEQU         <9:2>
;  C--UF 
;   171 : #define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
NV_USER_FREE016_COUNT_HI                TEXTEQU         <15:10>
;  C---V 
;   172 : #define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
NV_USER_FREE016_COUNT_HI_0              EQU             000000000h
;  R--4A 
;        
;   173 : #define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
;   174 : #define NV_USER_FREE032__SIZE_1                                 128 /*       */
NV_USER_FREE032__SIZE_1         EQU             128t
;        
;   175 : #define NV_USER_FREE032__SIZE_2                                   8 /*       */
NV_USER_FREE032__SIZE_2         EQU             8t
;  C--UF 
;   176 : #define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
NV_USER_FREE032_COUNT_LO                TEXTEQU         <1:0>
;  C---V 
;   177 : #define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
NV_USER_FREE032_COUNT_LO_0              EQU             000000000h
;  R--UF 
;   178 : #define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
NV_USER_FREE032_COUNT           TEXTEQU         <9:2>
;  C--UF 
;   179 : #define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
NV_USER_FREE032_COUNT_HI                TEXTEQU         <31:10>
;  C---V 
;   180 : #define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
NV_USER_FREE032_COUNT_HI_0              EQU             000000000h
;  R--2A 
;        
;   181 : #define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
;   182 : #define NV_USER_ZERO016__SIZE_1                                 128 /*       */
NV_USER_ZERO016__SIZE_1         EQU             128t
;        
;   183 : #define NV_USER_ZERO016__SIZE_2                                   8 /*       */
NV_USER_ZERO016__SIZE_2         EQU             8t
;        
;   184 : #define NV_USER_ZERO016__SIZE_3                                   7 /*       */
NV_USER_ZERO016__SIZE_3         EQU             7t
;  C--UF 
;   185 : #define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
NV_USER_ZERO016_COUNT           TEXTEQU         <15:0>
;  C---V 
;   186 : #define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
NV_USER_ZERO016_COUNT_0         EQU             000000000h
;  R--4A 
;        
;   187 : #define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
;   188 : #define NV_USER_ZERO032__SIZE_1                                 128 /*       */
NV_USER_ZERO032__SIZE_1         EQU             128t
;        
;   189 : #define NV_USER_ZERO032__SIZE_2                                   8 /*       */
NV_USER_ZERO032__SIZE_2         EQU             8t
;        
;   190 : #define NV_USER_ZERO032__SIZE_3                                   3 /*       */
NV_USER_ZERO032__SIZE_3         EQU             3t
;  C--UF 
;   191 : #define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
NV_USER_ZERO032_COUNT           TEXTEQU         <31:0>
;  C---V 
;   192 : #define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
NV_USER_ZERO032_COUNT_0         EQU             000000000h
;  dev_misc.ref 
;        
;   193 : /* dev_misc.ref */
;   194 : #define NV_USER_ADR_CHID                                      22:16 /*       */
NV_USER_ADR_CHID                TEXTEQU         <22:16>
;        
;   195 : #define NV_USER_ADR_SUBCHID                                   15:13 /*       */
NV_USER_ADR_SUBCHID             TEXTEQU         <15:13>
;        
;   196 : #define NV_USER_ADR_METHOD                                     12:0 /*       */
NV_USER_ADR_METHOD              TEXTEQU         <12:0>
;        
;   197 : #define NV_USER_DEVICE                                        22:16 /*       */
NV_USER_DEVICE          TEXTEQU         <22:16>
;  dev_timer.ref 
;  RW--D 
;   198 : /* dev_timer.ref */
;   199 : #define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
NV_PTIMER               TEXTEQU         <0x00009FFF:0x00009000>
;  RW-4R 
;   200 : #define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
NV_PTIMER_INTR_0                EQU             000009100h
;  RWXVF 
;   201 : #define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
NV_PTIMER_INTR_0_ALARM          TEXTEQU         <0:0>
;  R---V 
;   202 : #define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
NV_PTIMER_INTR_0_ALARM_NOT_PENDING              EQU             000000000h
;  R---V 
;   203 : #define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
NV_PTIMER_INTR_0_ALARM_PENDING          EQU             000000001h
;  -W--V 
;   204 : #define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
NV_PTIMER_INTR_0_ALARM_RESET            EQU             000000001h
;  RW-4R 
;   205 : #define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
NV_PTIMER_INTR_EN_0             EQU             000009140h
;  RWIVF 
;   206 : #define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
NV_PTIMER_INTR_EN_0_ALARM               TEXTEQU         <0:0>
;  RWI-V 
;   207 : #define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
NV_PTIMER_INTR_EN_0_ALARM_DISABLED              EQU             000000000h
;  RW--V 
;   208 : #define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
NV_PTIMER_INTR_EN_0_ALARM_ENABLED               EQU             000000001h
;  RW-4R 
;   209 : #define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
NV_PTIMER_NUMERATOR             EQU             000009200h
;  RWIUF 
;   210 : #define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
NV_PTIMER_NUMERATOR_VALUE               TEXTEQU         <15:0>
;  RWI-V 
;   211 : #define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
NV_PTIMER_NUMERATOR_VALUE_0             EQU             000000000h
;  RW-4R 
;   212 : #define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
NV_PTIMER_DENOMINATOR           EQU             000009210h
;  RWIUF 
;   213 : #define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
NV_PTIMER_DENOMINATOR_VALUE             TEXTEQU         <15:0>
;  RWI-V 
;   214 : #define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
NV_PTIMER_DENOMINATOR_VALUE_0           EQU             000000000h
;  RW-4R 
;   215 : #define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
NV_PTIMER_TIME_0                EQU             000009400h
;  RWXUF 
;   216 : #define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
NV_PTIMER_TIME_0_NSEC           TEXTEQU         <31:5>
;  RW-4R 
;   217 : #define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
NV_PTIMER_TIME_1                EQU             000009410h
;  RWXUF 
;   218 : #define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
NV_PTIMER_TIME_1_NSEC           TEXTEQU         <28:0>
;  RW-4R 
;   219 : #define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
NV_PTIMER_ALARM_0               EQU             000009420h
;  RWXUF 
;   220 : #define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
NV_PTIMER_ALARM_0_NSEC          TEXTEQU         <31:5>
;  dev_realmode.ref 
;  RW--M 
;   221 : /* dev_realmode.ref */
;   222 : #define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
NV_TRACE                TEXTEQU         <0x0000FFFF:0x00000000>
;  RWXVF 
;   223 : #define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
NV_TRACE_DATA           TEXTEQU         <( 0*32+ 7):( 0*32+ 0)>
;  RWXVF 
;   224 : #define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
NV_TRACE_ACCESS         TEXTEQU         <( 0*32+14):( 0*32+14)>
;  RW--V 
;   225 : #define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
NV_TRACE_ACCESS_WRITE           EQU             000000000h
;  RW--V 
;   226 : #define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
NV_TRACE_ACCESS_READ            EQU             000000001h
;  RWXVF 
;   227 : #define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
NV_TRACE_TYPE           TEXTEQU         <( 0*32+15):( 0*32+15)>
;  RW--V 
;   228 : #define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
NV_TRACE_TYPE_IO                EQU             000000000h
;  RW--V 
;   229 : #define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
NV_TRACE_TYPE_MEMORY            EQU             000000001h
;  RWXUF 
;   230 : #define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
NV_TRACE_ADDRESS                TEXTEQU         <( 0*32+31):( 0*32+16)>
;  dev_ram.ref 
;  RW--M 
;   231 : /* dev_ram.ref */
;   232 : #define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
NV_RAMHT__SIZE_0                TEXTEQU         <0x00000FFF:0x00000000>
;  RW--M 
;   233 : #define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
NV_RAMHT__SIZE_1                TEXTEQU         <0x00001FFF:0x00000000>
;  RW--M 
;   234 : #define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
NV_RAMHT__SIZE_2                TEXTEQU         <0x00003FFF:0x00000000>
;  RW--M 
;   235 : #define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
NV_RAMHT__SIZE_3                TEXTEQU         <0x00007FFF:0x00000000>
;  RWXVF 
;   236 : #define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
NV_RAMHT_HANDLE         TEXTEQU         <( 0*32+31):( 0*32+ 0)>
;  RWXUF 
;   237 : #define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
NV_RAMHT_INSTANCE               TEXTEQU         <( 1*32+15):( 1*32+ 0)>
;  RWXUF 
;   238 : #define NV_RAMHT_DEVICE                       ( 1*32+22):( 1*32+16) /* RWXUF */
NV_RAMHT_DEVICE         TEXTEQU         <( 1*32+22):( 1*32+16)>
;  RWXVF 
;   239 : #define NV_RAMHT_ENGINE                       ( 1*32+23):( 1*32+23) /* RWXVF */
NV_RAMHT_ENGINE         TEXTEQU         <( 1*32+23):( 1*32+23)>
;  RW--V 
;   240 : #define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
NV_RAMHT_ENGINE_SW              EQU             000000000h
;  RW--V 
;   241 : #define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
NV_RAMHT_ENGINE_GRAPHICS                EQU             000000001h
;  RWXUF 
;   242 : #define NV_RAMHT_CHID                         ( 1*32+30):( 1*32+24) /* RWXUF */
NV_RAMHT_CHID           TEXTEQU         <( 1*32+30):( 1*32+24)>
;  dev_ram.ref 
;  RW--M 
;   243 : /* dev_ram.ref */
;   244 : #define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
NV_RAMRO__SIZE_0                TEXTEQU         <0x000001FF:0x00000000>
;  RW--M 
;   245 : #define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
NV_RAMRO__SIZE_1                TEXTEQU         <0x00001FFF:0x00000000>
;  RWXUF 
;   246 : #define NV_RAMRO_METHOD                       ( 0*32+15):( 0*32+ 0) /* RWXUF */
NV_RAMRO_METHOD         TEXTEQU         <( 0*32+15):( 0*32+ 0)>
;  RWXUF 
;   247 : #define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
NV_RAMRO_CHID           TEXTEQU         <( 0*32+22):( 0*32+16)>
;  RWXVF 
;   248 : #define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
NV_RAMRO_TYPE           TEXTEQU         <( 0*32+23):( 0*32+23)>
;  RW--V 
;   249 : #define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
NV_RAMRO_TYPE_WRITE             EQU             000000000h
;  RW--V 
;   250 : #define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
NV_RAMRO_TYPE_READ              EQU             000000001h
;  RWXVF 
;   251 : #define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
NV_RAMRO_BYTE_ENABLES           TEXTEQU         <( 0*32+27):( 0*32+24)>
;  RWXVF 
;   252 : #define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
NV_RAMRO_REASON         TEXTEQU         <( 0*32+31):( 0*32+28)>
;  RW--V 
;   253 : #define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
NV_RAMRO_REASON_ILLEGAL_ACCESS          EQU             000000000h
;  RW--V 
;   254 : #define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
NV_RAMRO_REASON_NO_CACHE_AVAILABLE              EQU             000000001h
;  RW--V 
;   255 : #define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
NV_RAMRO_REASON_CACHE_RAN_OUT           EQU             000000002h
;  RW--V 
;   256 : #define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
NV_RAMRO_REASON_FREE_COUNT_OVERRUN              EQU             000000003h
;  RW--V 
;   257 : #define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
NV_RAMRO_REASON_CAUGHT_LYING            EQU             000000004h
;  RW--V 
;   258 : #define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
NV_RAMRO_REASON_RESERVED_ACCESS         EQU             000000005h
;  RWXVF 
;   259 : #define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
NV_RAMRO_DATA           TEXTEQU         <( 1*32+31):( 1*32+ 0)>
;  dev_ram.ref 
;  RW--M 
;   260 : /* dev_ram.ref */
;   261 : #define NV_RAMAU                              0x00000BFF:0x00000000 /* RW--M */
NV_RAMAU                TEXTEQU         <0x00000BFF:0x00000000>
;  RWXVF 
;   262 : #define NV_RAMAU_DATA                                          31:0 /* RWXVF */
NV_RAMAU_DATA           TEXTEQU         <31:0>
;  dev_ram.ref 
;  RW--M 
;   263 : /* dev_ram.ref */
;   264 : #define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
NV_RAMFC__SIZE_0                TEXTEQU         <0x000001FF:0x00000000>
;  RW--M 
;   265 : #define NV_RAMFC__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
NV_RAMFC__SIZE_1                TEXTEQU         <0x00000FFF:0x00000000>
;  RWXUF 
;   266 : #define NV_RAMFC_INSTANCE_0                   ( 0*32+15):( 0*32+ 0) /* RWXUF */
NV_RAMFC_INSTANCE_0             TEXTEQU         <( 0*32+15):( 0*32+ 0)>
;  RWXUF 
;   267 : #define NV_RAMFC_DEVICE_0                     ( 0*32+22):( 0*32+16) /* RWXUF */
NV_RAMFC_DEVICE_0               TEXTEQU         <( 0*32+22):( 0*32+16)>
;  RW--V 
;   268 : #define NV_RAMFC_DEVICE_0_NOT_FOUND                      0x00000000 /* RW--V */
NV_RAMFC_DEVICE_0_NOT_FOUND             EQU             000000000h
;  RWXVF 
;   269 : #define NV_RAMFC_ENGINE_0                     ( 0*32+23):( 0*32+23) /* RWXVF */
NV_RAMFC_ENGINE_0               TEXTEQU         <( 0*32+23):( 0*32+23)>
;  RW--V 
;   270 : #define NV_RAMFC_ENGINE_0_SW                             0x00000000 /* RW--V */
NV_RAMFC_ENGINE_0_SW            EQU             000000000h
;  RW--V 
;   271 : #define NV_RAMFC_ENGINE_0_GRAPHICS                       0x00000001 /* RW--V */
NV_RAMFC_ENGINE_0_GRAPHICS              EQU             000000001h
;  RWXUF 
;   272 : #define NV_RAMFC_INSTANCE_1                   ( 1*32+15):( 1*32+ 0) /* RWXUF */
NV_RAMFC_INSTANCE_1             TEXTEQU         <( 1*32+15):( 1*32+ 0)>
;  RWXUF 
;   273 : #define NV_RAMFC_DEVICE_1                     ( 1*32+22):( 1*32+16) /* RWXUF */
NV_RAMFC_DEVICE_1               TEXTEQU         <( 1*32+22):( 1*32+16)>
;  RW--V 
;   274 : #define NV_RAMFC_DEVICE_1_NOT_FOUND                      0x00000000 /* RW--V */
NV_RAMFC_DEVICE_1_NOT_FOUND             EQU             000000000h
;  RWXVF 
;   275 : #define NV_RAMFC_ENGINE_1                     ( 1*32+23):( 1*32+23) /* RWXVF */
NV_RAMFC_ENGINE_1               TEXTEQU         <( 1*32+23):( 1*32+23)>
;  RW--V 
;   276 : #define NV_RAMFC_ENGINE_1_SW                             0x00000000 /* RW--V */
NV_RAMFC_ENGINE_1_SW            EQU             000000000h
;  RW--V 
;   277 : #define NV_RAMFC_ENGINE_1_GRAPHICS                       0x00000001 /* RW--V */
NV_RAMFC_ENGINE_1_GRAPHICS              EQU             000000001h
;  RWXUF 
;   278 : #define NV_RAMFC_INSTANCE_7                   ( 7*32+15):( 7*32+ 0) /* RWXUF */
NV_RAMFC_INSTANCE_7             TEXTEQU         <( 7*32+15):( 7*32+ 0)>
;  RWXUF 
;   279 : #define NV_RAMFC_DEVICE_7                     ( 7*32+22):( 7*32+16) /* RWXUF */
NV_RAMFC_DEVICE_7               TEXTEQU         <( 7*32+22):( 7*32+16)>
;  RW--V 
;   280 : #define NV_RAMFC_DEVICE_7_NOT_FOUND                      0x00000000 /* RW--V */
NV_RAMFC_DEVICE_7_NOT_FOUND             EQU             000000000h
;  RWXVF 
;   281 : #define NV_RAMFC_ENGINE_7                     ( 7*32+23):( 7*32+23) /* RWXVF */
NV_RAMFC_ENGINE_7               TEXTEQU         <( 7*32+23):( 7*32+23)>
;  RW--V 
;   282 : #define NV_RAMFC_ENGINE_7_SW                             0x00000000 /* RW--V */
NV_RAMFC_ENGINE_7_SW            EQU             000000000h
;  RW--V 
;   283 : #define NV_RAMFC_ENGINE_7_GRAPHICS                       0x00000001 /* RW--V */
NV_RAMFC_ENGINE_7_GRAPHICS              EQU             000000001h
;  dev_ram.ref 
;  dev_ram.ref 
;  dev_ram.ref 
;  RWXUF 
;   284 : /* dev_ram.ref */
;   285 : /* dev_ram.ref */
;   286 : /* dev_ram.ref */
;   287 : #define NV_DMA_ADJUST                         ( 0*32+11):( 0*32+ 0) /* RWXUF */
NV_DMA_ADJUST           TEXTEQU         <( 0*32+11):( 0*32+ 0)>
;  RWXVF 
;   288 : #define NV_DMA_PAGE_TABLE                     ( 0*32+16):( 0*32+16) /* RWXVF */
NV_DMA_PAGE_TABLE               TEXTEQU         <( 0*32+16):( 0*32+16)>
;  RW--V 
;   289 : #define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
NV_DMA_PAGE_TABLE_NOT_PRESENT           EQU             000000000h
;  RW--V 
;   290 : #define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
NV_DMA_PAGE_TABLE_PRESENT               EQU             000000001h
;  RWXVF 
;   291 : #define NV_DMA_TARGET_NODE                    ( 0*32+25):( 0*32+24) /* RWXVF */
NV_DMA_TARGET_NODE              TEXTEQU         <( 0*32+25):( 0*32+24)>
;  RW--V 
;   292 : #define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
NV_DMA_TARGET_NODE_NVM          EQU             000000000h
;  RW--V 
;   293 : #define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
NV_DMA_TARGET_NODE_PCI          EQU             000000002h
;  RW--V 
;   294 : #define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
NV_DMA_TARGET_NODE_AGP          EQU             000000003h
;  RWXUF 
;   295 : #define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
NV_DMA_LIMIT            TEXTEQU         <( 1*32+31):( 1*32+ 0)>
;  RWXVF 
;   296 : #define NV_DMA_PAGE                           ( 2*32+ 0):( 2*32+ 0) /* RWXVF */
NV_DMA_PAGE             TEXTEQU         <( 2*32+ 0):( 2*32+ 0)>
;  RW--V 
;   297 : #define NV_DMA_PAGE_NOT_PRESENT                          0x00000000 /* RW--V */
NV_DMA_PAGE_NOT_PRESENT         EQU             000000000h
;  RW--V 
;   298 : #define NV_DMA_PAGE_PRESENT                              0x00000001 /* RW--V */
NV_DMA_PAGE_PRESENT             EQU             000000001h
;  RWXVF 
;   299 : #define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
NV_DMA_ACCESS           TEXTEQU         <( 2*32+ 1):( 2*32+ 1)>
;  RW--V 
;   300 : #define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
NV_DMA_ACCESS_READ_ONLY         EQU             000000000h
;  RW--V 
;   301 : #define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
NV_DMA_ACCESS_READ_AND_WRITE            EQU             000000001h
;  RWXUF 
;   302 : #define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
NV_DMA_FRAME_ADDRESS            TEXTEQU         <( 2*32+31):( 2*32+12)>
;  dev_ram.ref 
;  RWXUF 
;   303 : /* dev_ram.ref */
;   304 : #define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
NV_SUBCHAN_CTX_SWITCH           TEXTEQU         <( 0*32+31):( 0*32+ 0)>
;  RWXUF 
;   305 : #define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
NV_SUBCHAN_DMA_INSTANCE         TEXTEQU         <( 1*32+15):( 1*32+ 0)>
;  RWXUF 
;   306 : #define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
NV_SUBCHAN_NOTIFY_INSTANCE              TEXTEQU         <( 1*32+31):( 1*32+16)>
;  RWXUF 
;   307 : #define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
NV_SUBCHAN_MEMFMT_INSTANCE              TEXTEQU         <( 2*32+15):( 2*32+ 0)>
;  RWXUF 
;   308 : #define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
NV_SUBCHAN_MEMFMT_LINEAR                TEXTEQU         <( 2*32+16):( 2*32+16)>
;  RW--V 
;   309 : #define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
NV_SUBCHAN_MEMFMT_LINEAR_OUT            EQU             000000000h
;  RW--V 
;   310 : #define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */
NV_SUBCHAN_MEMFMT_LINEAR_IN             EQU             000000001h
;  dev_ram.ref 
;  RW--M 
;   311 : /* dev_ram.ref */
;   312 : #define NV_AUDIN                              0x00000033:0x00000000 /* RW--M */
NV_AUDIN                TEXTEQU         <0x00000033:0x00000000>
;  RWWVF 
;   313 : #define NV_AUDIN_AE_STATE                       (0*32+15):(0*32+ 0) /* RWWVF */
NV_AUDIN_AE_STATE               TEXTEQU         <(0*32+15):(0*32+ 0)>
;  RWWUF 
;   314 : #define NV_AUDIN_AE_SKIP_COUNT                  (1*32+31):(1*32+ 0) /* RWWUF */
NV_AUDIN_AE_SKIP_COUNT          TEXTEQU         <(1*32+31):(1*32+ 0)>
;  RWWUF 
;   315 : #define NV_AUDIN_AE_POSITION                    (2*32+31):(2*32+ 0) /* RWWUF */
NV_AUDIN_AE_POSITION            TEXTEQU         <(2*32+31):(2*32+ 0)>
;  RWWUF 
;   316 : #define NV_AUDIN_RM_NEXT_INSTANCE               (3*32+31):(3*32+ 0) /* RWWUF */
NV_AUDIN_RM_NEXT_INSTANCE               TEXTEQU         <(3*32+31):(3*32+ 0)>
;  RWWVF 
;   317 : #define NV_AUDIN_RM_STATE                       (4*32+15):(4*32+ 0) /* RWWVF */
NV_AUDIN_RM_STATE               TEXTEQU         <(4*32+15):(4*32+ 0)>
;  RWWVF 
;   318 : #define NV_AUDIN_SU_STATE                       (5*32+15):(5*32+ 0) /* RWWVF */
NV_AUDIN_SU_STATE               TEXTEQU         <(5*32+15):(5*32+ 0)>
;  RWWUF 
;   319 : #define NV_AUDIN_SU_START_TIME_LOW              (5*32+31):(5*32+16) /* RWWUF */
NV_AUDIN_SU_START_TIME_LOW              TEXTEQU         <(5*32+31):(5*32+16)>
;  RWWUF 
;   320 : #define NV_AUDIN_SU_START_TIME_HIGH             (6*32+31):(6*32+ 0) /* RWWUF */
NV_AUDIN_SU_START_TIME_HIGH             TEXTEQU         <(6*32+31):(6*32+ 0)>
;  RWWUF 
;   321 : #define NV_AUDIN_SU_SKIP_INC                    (7*32+31):(7*32+ 0) /* RWWUF */
NV_AUDIN_SU_SKIP_INC            TEXTEQU         <(7*32+31):(7*32+ 0)>
;  RWWUF 
;   322 : #define NV_AUDIN_SU_BUFF0_DMA_INSTANCE          (8*32+15):(8*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF0_DMA_INSTANCE          TEXTEQU         <(8*32+15):(8*32+ 0)>
;  RWWUF 
;   323 : #define NV_AUDIN_SU_BUFF1_DMA_INSTANCE          (8*32+31):(8*32+16) /* RWWUF */
NV_AUDIN_SU_BUFF1_DMA_INSTANCE          TEXTEQU         <(8*32+31):(8*32+16)>
;  RWWUF 
;   324 : #define NV_AUDIN_SU_BUFF0_START_POSITION        (9*32+31):(9*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF0_START_POSITION                TEXTEQU         <(9*32+31):(9*32+ 0)>
;  RWWUF 
;   325 : #define NV_AUDIN_SU_BUFF0_LAST_PLUS1          (10*32+31):(10*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF0_LAST_PLUS1            TEXTEQU         <(10*32+31):(10*32+ 0)>
;  RWWUF 
;   326 : #define NV_AUDIN_SU_BUFF1_START_POSITION      (11*32+31):(11*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF1_START_POSITION                TEXTEQU         <(11*32+31):(11*32+ 0)>
;  RWWUF 
;   327 : #define NV_AUDIN_SU_BUFF1_LAST_PLUS1          (12*32+31):(12*32+ 0) /* RWWUF */
NV_AUDIN_SU_BUFF1_LAST_PLUS1            TEXTEQU         <(12*32+31):(12*32+ 0)>
;  RWXVF 
;   328 : #define NV_AUDIN_AE_EVENT_START               ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
NV_AUDIN_AE_EVENT_START         TEXTEQU         <( 0*32+ 3):( 0*32+ 3)>
;  RWXVF 
;   329 : #define NV_AUDIN_AE_BUFF0_INTR_NOTIFY         ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
NV_AUDIN_AE_BUFF0_INTR_NOTIFY           TEXTEQU         <( 0*32+ 4):( 0*32+ 4)>
;  RWXVF 
;   330 : #define NV_AUDIN_AE_BUFF1_INTR_NOTIFY         ( 0*32+ 5):( 0*32+ 5) /* RWXVF */
NV_AUDIN_AE_BUFF1_INTR_NOTIFY           TEXTEQU         <( 0*32+ 5):( 0*32+ 5)>
;  RWXVF 
;   331 : #define NV_AUDIN_AE_BUFF0_INTR_CHAIN_GAP      ( 0*32+ 6):( 0*32+ 6) /* RWXVF */
NV_AUDIN_AE_BUFF0_INTR_CHAIN_GAP                TEXTEQU         <( 0*32+ 6):( 0*32+ 6)>
;  RWXVF 
;   332 : #define NV_AUDIN_AE_BUFF1_INTR_CHAIN_GAP      ( 0*32+ 7):( 0*32+ 7) /* RWXVF */
NV_AUDIN_AE_BUFF1_INTR_CHAIN_GAP                TEXTEQU         <( 0*32+ 7):( 0*32+ 7)>
;  RWXVF 
;   333 : #define NV_AUDIN_AE_BUFF0_IN_USE              ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
NV_AUDIN_AE_BUFF0_IN_USE                TEXTEQU         <( 0*32+ 8):( 0*32+ 8)>
;  RWXVF 
;   334 : #define NV_AUDIN_AE_BUFF1_IN_USE              ( 0*32+ 9):( 0*32+ 9) /* RWXVF */
NV_AUDIN_AE_BUFF1_IN_USE                TEXTEQU         <( 0*32+ 9):( 0*32+ 9)>
;  RWXVF 
;   335 : #define NV_AUDIN_AE_CURRENT_BUFFER            ( 0*32+12):( 0*32+12) /* RWXVF */
NV_AUDIN_AE_CURRENT_BUFFER              TEXTEQU         <( 0*32+12):( 0*32+12)>
;  RW--V 
;   336 : #define NV_AUDIN_AE_CURRENT_BUFFER_0                     0x00000000 /* RW--V */
NV_AUDIN_AE_CURRENT_BUFFER_0            EQU             000000000h
;  RW--V 
;   337 : #define NV_AUDIN_AE_CURRENT_BUFFER_1                     0x00000001 /* RW--V */
NV_AUDIN_AE_CURRENT_BUFFER_1            EQU             000000001h
;  RWXVF 
;   338 : #define NV_AUDIN_AE_INTR_DMA                  ( 0*32+11):( 0*32+11) /* RWXVF */
NV_AUDIN_AE_INTR_DMA            TEXTEQU         <( 0*32+11):( 0*32+11)>
;  RWXVF 
;   339 : #define NV_AUDIN_RM_BUFF0_INTR_NOTIFY         ( 4*32+ 4):( 4*32+ 4) /* RWXVF */
NV_AUDIN_RM_BUFF0_INTR_NOTIFY           TEXTEQU         <( 4*32+ 4):( 4*32+ 4)>
;  RWXVF 
;   340 : #define NV_AUDIN_RM_BUFF1_INTR_NOTIFY         ( 4*32+ 5):( 4*32+ 5) /* RWXVF */
NV_AUDIN_RM_BUFF1_INTR_NOTIFY           TEXTEQU         <( 4*32+ 5):( 4*32+ 5)>
;  RWXVF 
;   341 : #define NV_AUDIN_RM_BUFF0_INTR_CHAIN_GAP      ( 4*32+ 6):( 4*32+ 6) /* RWXVF */
NV_AUDIN_RM_BUFF0_INTR_CHAIN_GAP                TEXTEQU         <( 4*32+ 6):( 4*32+ 6)>
;  RWXVF 
;   342 : #define NV_AUDIN_RM_BUFF1_INTR_CHAIN_GAP      ( 4*32+ 7):( 4*32+ 7) /* RWXVF */
NV_AUDIN_RM_BUFF1_INTR_CHAIN_GAP                TEXTEQU         <( 4*32+ 7):( 4*32+ 7)>
;  RWXVF 
;   343 : #define NV_AUDIN_SU_BUFF0_OFFSET              ( 5*32+ 1):( 5*32+ 0) /* RWXVF */
NV_AUDIN_SU_BUFF0_OFFSET                TEXTEQU         <( 5*32+ 1):( 5*32+ 0)>
;  RWXVF 
;   344 : #define NV_AUDIN_SU_BUFF1_OFFSET              ( 5*32+ 3):( 5*32+ 2) /* RWXVF */
NV_AUDIN_SU_BUFF1_OFFSET                TEXTEQU         <( 5*32+ 3):( 5*32+ 2)>
;  RWXVF 
;   345 : #define NV_AUDIN_SU_BYPASS_PTE                ( 5*32+ 4):( 5*32+ 4) /* RWXVF */
NV_AUDIN_SU_BYPASS_PTE          TEXTEQU         <( 5*32+ 4):( 5*32+ 4)>
;  RW--V 
;   346 : #define NV_AUDIN_SU_BYPASS_PTE_DISABLED                  0x00000000 /* RW--V */
NV_AUDIN_SU_BYPASS_PTE_DISABLED         EQU             000000000h
;  RW--V 
;   347 : #define NV_AUDIN_SU_BYPASS_PTE_ENABLED                   0x00000001 /* RW--V */
NV_AUDIN_SU_BYPASS_PTE_ENABLED          EQU             000000001h
;  RWXVF 
;   348 : #define NV_AUDIN_SU_BYPASS_TARGET             ( 5*32+ 6):( 5*32+ 5) /* RWXVF */
NV_AUDIN_SU_BYPASS_TARGET               TEXTEQU         <( 5*32+ 6):( 5*32+ 5)>
;  RW--V 
;   349 : #define NV_AUDIN_SU_BYPASS_TARGET_NVM                    0x00000000 /* RW--V */
NV_AUDIN_SU_BYPASS_TARGET_NVM           EQU             000000000h
;  RW--V 
;   350 : #define NV_AUDIN_SU_BYPASS_TARGET_PCI                    0x00000002 /* RW--V */
NV_AUDIN_SU_BYPASS_TARGET_PCI           EQU             000000002h
;  RW--V 
;   351 : #define NV_AUDIN_SU_BYPASS_TARGET_AGP                    0x00000003 /* RW--V */
NV_AUDIN_SU_BYPASS_TARGET_AGP           EQU             000000003h
;  RWXVF 
;   352 : #define NV_AUDIN_SU_BUFF0_IN_USE              ( 5*32+ 8):( 5*32+ 8) /* RWXVF */
NV_AUDIN_SU_BUFF0_IN_USE                TEXTEQU         <( 5*32+ 8):( 5*32+ 8)>
;  RWXVF 
;   353 : #define NV_AUDIN_SU_BUFF1_IN_USE              ( 5*32+ 9):( 5*32+ 9) /* RWXVF */
NV_AUDIN_SU_BUFF1_IN_USE                TEXTEQU         <( 5*32+ 9):( 5*32+ 9)>
;  RWXVF 
;   354 : #define NV_AUDIN_SU_BUFF0_NOTIFY              (16*32+10):(16*32+10) /* RWXVF */
NV_AUDIN_SU_BUFF0_NOTIFY                TEXTEQU         <(16*32+10):(16*32+10)>
;  RW--V 
;   355 : #define NV_AUDIN_SU_BUFF0_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
NV_AUDIN_SU_BUFF0_NOTIFY_DMA_WRITE              EQU             000000000h
;  RW--V 
;   356 : #define NV_AUDIN_SU_BUFF0_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
NV_AUDIN_SU_BUFF0_NOTIFY_INTERRUPT              EQU             000000001h
;  RWXVF 
;   357 : #define NV_AUDIN_SU_BUFF1_NOTIFY              (16*32+11):(16*32+11) /* RWXVF */
NV_AUDIN_SU_BUFF1_NOTIFY                TEXTEQU         <(16*32+11):(16*32+11)>
;  RW--V 
;   358 : #define NV_AUDIN_SU_BUFF1_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
NV_AUDIN_SU_BUFF1_NOTIFY_DMA_WRITE              EQU             000000000h
;  RW--V 
;   359 : #define NV_AUDIN_SU_BUFF1_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
NV_AUDIN_SU_BUFF1_NOTIFY_INTERRUPT              EQU             000000001h
;  RWXVF 
;   360 : #define NV_AUDIN_SU_CHANNEL                   ( 5*32+12):( 5*32+12) /* RWXVF */
NV_AUDIN_SU_CHANNEL             TEXTEQU         <( 5*32+12):( 5*32+12)>
;  RW--V 
;   361 : #define NV_AUDIN_SU_CHANNEL_MONO                         0x00000000 /* RW--V */
NV_AUDIN_SU_CHANNEL_MONO                EQU             000000000h
;  RW--V 
;   362 : #define NV_AUDIN_SU_CHANNEL_STEREO                       0x00000001 /* RW--V */
NV_AUDIN_SU_CHANNEL_STEREO              EQU             000000001h
;  RWXVF 
;   363 : #define NV_AUDIN_SU_FORMAT                    ( 5*32+15):( 5*32+13) /* RWXVF */
NV_AUDIN_SU_FORMAT              TEXTEQU         <( 5*32+15):( 5*32+13)>
;  RW--V 
;   364 : #define NV_AUDIN_SU_FORMAT_LINEAR                        0x00000000 /* RW--V */
NV_AUDIN_SU_FORMAT_LINEAR               EQU             000000000h
;  RW--V 
;   365 : #define NV_AUDIN_SU_FORMAT_ULAW                          0x00000001 /* RW--V */
NV_AUDIN_SU_FORMAT_ULAW         EQU             000000001h
;  RW--V 
;   366 : #define NV_AUDIN_SU_FORMAT_ALAW                          0x00000002 /* RW--V */
NV_AUDIN_SU_FORMAT_ALAW         EQU             000000002h
;  RW--V 
;   367 : #define NV_AUDIN_SU_FORMAT_OFFSET8                       0x00000003 /* RW--V */
NV_AUDIN_SU_FORMAT_OFFSET8              EQU             000000003h
;  dev_ram.ref 
;  RW--M 
;   368 : /* dev_ram.ref */
;   369 : #define NV_AUDOUT                             0x0000003b:0x00000000 /* RW--M */
NV_AUDOUT               TEXTEQU         <0x0000003b:0x00000000>
;  RWWVF 
;   370 : #define NV_AUDOUT_AE_STATE                      (0*32+15):(0*32+ 0) /* RWWVF */
NV_AUDOUT_AE_STATE              TEXTEQU         <(0*32+15):(0*32+ 0)>
;  RWWUF 
;   371 : #define NV_AUDOUT_AE_POSITION_LOW               (0*32+31):(0*32+16) /* RWWUF */
NV_AUDOUT_AE_POSITION_LOW               TEXTEQU         <(0*32+31):(0*32+16)>
;  RWWUF 
;   372 : #define NV_AUDOUT_AE_POSITION                   (1*32+31):(1*32+ 0) /* RWWUF */
NV_AUDOUT_AE_POSITION           TEXTEQU         <(1*32+31):(1*32+ 0)>
;  RWWUF 
;   373 : #define NV_AUDOUT_AE_VOLUME_1                   (2*32+15):(2*32+ 0) /* RWWUF */
NV_AUDOUT_AE_VOLUME_1           TEXTEQU         <(2*32+15):(2*32+ 0)>
;  RWWUF 
;   374 : #define NV_AUDOUT_AE_VOLUME_0                   (2*32+31):(2*32+16) /* RWWUF */
NV_AUDOUT_AE_VOLUME_0           TEXTEQU         <(2*32+31):(2*32+16)>
;  RWWUF 
;   375 : #define NV_AUDOUT_RM_VOLUME_0                   (3*32+15):(3*32+ 0) /* RWWUF */
NV_AUDOUT_RM_VOLUME_0           TEXTEQU         <(3*32+15):(3*32+ 0)>
;  RWWUF 
;   376 : #define NV_AUDOUT_SU_VOLUME_0                   (3*32+31):(3*32+16) /* RWWUF */
NV_AUDOUT_SU_VOLUME_0           TEXTEQU         <(3*32+31):(3*32+16)>
;  RWWUF 
;   377 : #define NV_AUDOUT_RM_VOLUME_1                   (4*32+15):(4*32+ 0) /* RWWUF */
NV_AUDOUT_RM_VOLUME_1           TEXTEQU         <(4*32+15):(4*32+ 0)>
;  RWWUF 
;   378 : #define NV_AUDOUT_SU_VOLUME_1                   (4*32+31):(4*32+16) /* RWWUF */
NV_AUDOUT_SU_VOLUME_1           TEXTEQU         <(4*32+31):(4*32+16)>
;  RWWUF 
;   379 : #define NV_AUDOUT_AE_POSITION_INC               (5*32+31):(5*32+ 0) /* RWWUF */
NV_AUDOUT_AE_POSITION_INC               TEXTEQU         <(5*32+31):(5*32+ 0)>
;  RWWUF 
;   380 : #define NV_AUDOUT_RM_NEXT_INSTANCE              (6*32+31):(6*32+ 0) /* RWWUF */
NV_AUDOUT_RM_NEXT_INSTANCE              TEXTEQU         <(6*32+31):(6*32+ 0)>
;  RWWVF 
;   381 : #define NV_AUDOUT_RM_STATE                      (7*32+15):(7*32+ 0) /* RWWVF */
NV_AUDOUT_RM_STATE              TEXTEQU         <(7*32+15):(7*32+ 0)>
;  RWWVF 
;   382 : #define NV_AUDOUT_SU_STATE                      (8*32+15):(8*32+ 0) /* RWWVF */
NV_AUDOUT_SU_STATE              TEXTEQU         <(8*32+15):(8*32+ 0)>
;  RWWUF 
;   383 : #define NV_AUDOUT_SU_START_TIME_LOW             (8*32+31):(8*32+16) /* RWWUF */
NV_AUDOUT_SU_START_TIME_LOW             TEXTEQU         <(8*32+31):(8*32+16)>
;  RWWUF 
;   384 : #define NV_AUDOUT_SU_START_TIME_HIGH            (9*32+31):(9*32+ 0) /* RWWUF */
NV_AUDOUT_SU_START_TIME_HIGH            TEXTEQU         <(9*32+31):(9*32+ 0)>
;  RWWUF 
;   385 : #define NV_AUDOUT_SU_BUFF0_DMA_INSTANCE       (10*32+15):(10*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF0_DMA_INSTANCE         TEXTEQU         <(10*32+15):(10*32+ 0)>
;  RWWUF 
;   386 : #define NV_AUDOUT_SU_BUFF1_DMA_INSTANCE       (10*32+31):(10*32+16) /* RWWUF */
NV_AUDOUT_SU_BUFF1_DMA_INSTANCE         TEXTEQU         <(10*32+31):(10*32+16)>
;  RWWUF 
;   387 : #define NV_AUDOUT_SU_BUFF0_START_POSITION     (11*32+31):(11*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF0_START_POSITION               TEXTEQU         <(11*32+31):(11*32+ 0)>
;  RWWUF 
;   388 : #define NV_AUDOUT_SU_BUFF0_LAST_PLUS1         (12*32+31):(12*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF0_LAST_PLUS1           TEXTEQU         <(12*32+31):(12*32+ 0)>
;  RWWUF 
;   389 : #define NV_AUDOUT_SU_BUFF1_START_POSITION     (13*32+31):(13*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF1_START_POSITION               TEXTEQU         <(13*32+31):(13*32+ 0)>
;  RWWUF 
;   390 : #define NV_AUDOUT_SU_BUFF1_LAST_PLUS1         (14*32+31):(14*32+ 0) /* RWWUF */
NV_AUDOUT_SU_BUFF1_LAST_PLUS1           TEXTEQU         <(14*32+31):(14*32+ 0)>
;  RWXVF 
;   391 : #define NV_AUDOUT_AE_INTR_MIXING              ( 0*32+ 0):( 0*32+ 0) /* RWXVF */
NV_AUDOUT_AE_INTR_MIXING                TEXTEQU         <( 0*32+ 0):( 0*32+ 0)>
;  RWXVF 
;   392 : #define NV_AUDOUT_AE_INTR_VOLUME              ( 0*32+ 1):( 0*32+ 1) /* RWXVF */
NV_AUDOUT_AE_INTR_VOLUME                TEXTEQU         <( 0*32+ 1):( 0*32+ 1)>
;  RWXVF 
;   393 : #define NV_AUDOUT_AE_EVENT_START              ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
NV_AUDOUT_AE_EVENT_START                TEXTEQU         <( 0*32+ 3):( 0*32+ 3)>
;  RWXVF 
;   394 : #define NV_AUDOUT_AE_BUFF0_INTR_NOTIFY        ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
NV_AUDOUT_AE_BUFF0_INTR_NOTIFY          TEXTEQU         <( 0*32+ 4):( 0*32+ 4)>
;  RWXVF 
;   395 : #define NV_AUDOUT_AE_BUFF1_INTR_NOTIFY        ( 0*32+ 5):( 0*32+ 5) /* RWXVF */
NV_AUDOUT_AE_BUFF1_INTR_NOTIFY          TEXTEQU         <( 0*32+ 5):( 0*32+ 5)>
;  RWXVF 
;   396 : #define NV_AUDOUT_AE_BUFF0_INTR_CHAIN_GAP     ( 0*32+ 6):( 0*32+ 6) /* RWXVF */
NV_AUDOUT_AE_BUFF0_INTR_CHAIN_GAP               TEXTEQU         <( 0*32+ 6):( 0*32+ 6)>
;  RWXVF 
;   397 : #define NV_AUDOUT_AE_BUFF1_INTR_CHAIN_GAP     ( 0*32+ 7):( 0*32+ 7) /* RWXVF */
NV_AUDOUT_AE_BUFF1_INTR_CHAIN_GAP               TEXTEQU         <( 0*32+ 7):( 0*32+ 7)>
;  RWXVF 
;   398 : #define NV_AUDOUT_AE_BUFF0_IN_USE             ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
NV_AUDOUT_AE_BUFF0_IN_USE               TEXTEQU         <( 0*32+ 8):( 0*32+ 8)>
;  RWXVF 
;   399 : #define NV_AUDOUT_AE_BUFF1_IN_USE             ( 0*32+ 9):( 0*32+ 9) /* RWXVF */
NV_AUDOUT_AE_BUFF1_IN_USE               TEXTEQU         <( 0*32+ 9):( 0*32+ 9)>
;  RWXVF 
;   400 : #define NV_AUDOUT_AE_GAP_DETECT               ( 0*32+10):( 0*32+10) /* RWXVF */
NV_AUDOUT_AE_GAP_DETECT         TEXTEQU         <( 0*32+10):( 0*32+10)>
;  RWXVF 
;   401 : #define NV_AUDOUT_AE_INTR_DMA                 ( 0*32+11):( 0*32+11) /* RWXVF */
NV_AUDOUT_AE_INTR_DMA           TEXTEQU         <( 0*32+11):( 0*32+11)>
;  RWXVF 
;   402 : #define NV_AUDOUT_AE_CURRENT_BUFFER           ( 0*32+12):( 0*32+12) /* RWXVF */
NV_AUDOUT_AE_CURRENT_BUFFER             TEXTEQU         <( 0*32+12):( 0*32+12)>
;  RW--V 
;   403 : #define NV_AUDOUT_AE_CURRENT_BUFFER_0                    0x00000000 /* RW--V */
NV_AUDOUT_AE_CURRENT_BUFFER_0           EQU             000000000h
;  RW--V 
;   404 : #define NV_AUDOUT_AE_CURRENT_BUFFER_1                    0x00000001 /* RW--V */
NV_AUDOUT_AE_CURRENT_BUFFER_1           EQU             000000001h
;  RWXVF 
;   405 : #define NV_AUDOUT_RM_INTR_MIXING              (15*32+ 0):(15*32+ 0) /* RWXVF */
NV_AUDOUT_RM_INTR_MIXING                TEXTEQU         <(15*32+ 0):(15*32+ 0)>
;  RWXVF 
;   406 : #define NV_AUDOUT_RM_INTR_VOLUME              (15*32+ 1):(15*32+ 1) /* RWXVF */
NV_AUDOUT_RM_INTR_VOLUME                TEXTEQU         <(15*32+ 1):(15*32+ 1)>
;  RWXVF 
;   407 : #define NV_AUDOUT_RM_BUFF0_INTR_NOTIFY        (15*32+ 4):(15*32+ 4) /* RWXVF */
NV_AUDOUT_RM_BUFF0_INTR_NOTIFY          TEXTEQU         <(15*32+ 4):(15*32+ 4)>
;  RWXVF 
;   408 : #define NV_AUDOUT_RM_BUFF1_INTR_NOTIFY        (15*32+ 5):(15*32+ 5) /* RWXVF */
NV_AUDOUT_RM_BUFF1_INTR_NOTIFY          TEXTEQU         <(15*32+ 5):(15*32+ 5)>
;  RWXVF 
;   409 : #define NV_AUDOUT_RM_BUFF0_INTR_CHAIN_GAP     (15*32+ 6):(15*32+ 6) /* RWXVF */
NV_AUDOUT_RM_BUFF0_INTR_CHAIN_GAP               TEXTEQU         <(15*32+ 6):(15*32+ 6)>
;  RWXVF 
;   410 : #define NV_AUDOUT_RM_BUFF1_INTR_CHAIN_GAP     (15*32+ 7):(15*32+ 7) /* RWXVF */
NV_AUDOUT_RM_BUFF1_INTR_CHAIN_GAP               TEXTEQU         <(15*32+ 7):(15*32+ 7)>
;  RWXVF 
;   411 : #define NV_AUDOUT_SU_BUFF0_OFFSET             (16*32+ 1):(16*32+ 0) /* RWXVF */
NV_AUDOUT_SU_BUFF0_OFFSET               TEXTEQU         <(16*32+ 1):(16*32+ 0)>
;  RWXVF 
;   412 : #define NV_AUDOUT_SU_BUFF1_OFFSET             (16*32+ 3):(16*32+ 2) /* RWXVF */
NV_AUDOUT_SU_BUFF1_OFFSET               TEXTEQU         <(16*32+ 3):(16*32+ 2)>
;  RWXVF 
;   413 : #define NV_AUDOUT_SU_BYPASS_PTE               (16*32+ 4):(16*32+ 4) /* RWXVF */
NV_AUDOUT_SU_BYPASS_PTE         TEXTEQU         <(16*32+ 4):(16*32+ 4)>
;  RW--V 
;   414 : #define NV_AUDOUT_SU_BYPASS_PTE_DISABLED                 0x00000000 /* RW--V */
NV_AUDOUT_SU_BYPASS_PTE_DISABLED                EQU             000000000h
;  RW--V 
;   415 : #define NV_AUDOUT_SU_BYPASS_PTE_ENABLED                  0x00000001 /* RW--V */
NV_AUDOUT_SU_BYPASS_PTE_ENABLED         EQU             000000001h
;  RWXVF 
;   416 : #define NV_AUDOUT_SU_BYPASS_TARGET            (16*32+ 6):(16*32+ 5) /* RWXVF */
NV_AUDOUT_SU_BYPASS_TARGET              TEXTEQU         <(16*32+ 6):(16*32+ 5)>
;  RW--V 
;   417 : #define NV_AUDOUT_SU_BYPASS_TARGET_NVM                   0x00000000 /* RW--V */
NV_AUDOUT_SU_BYPASS_TARGET_NVM          EQU             000000000h
;  RW--V 
;   418 : #define NV_AUDOUT_SU_BYPASS_TARGET_PCI                   0x00000002 /* RW--V */
NV_AUDOUT_SU_BYPASS_TARGET_PCI          EQU             000000002h
;  RW--V 
;   419 : #define NV_AUDOUT_SU_BYPASS_TARGET_AGP                   0x00000003 /* RW--V */
NV_AUDOUT_SU_BYPASS_TARGET_AGP          EQU             000000003h
;  RWXVF 
;   420 : #define NV_AUDOUT_SU_BUFF0_IN_USE             (16*32+ 8):(16*32+ 8) /* RWXVF */
NV_AUDOUT_SU_BUFF0_IN_USE               TEXTEQU         <(16*32+ 8):(16*32+ 8)>
;  RWXVF 
;   421 : #define NV_AUDOUT_SU_BUFF1_IN_USE             (16*32+ 9):(16*32+ 9) /* RWXVF */
NV_AUDOUT_SU_BUFF1_IN_USE               TEXTEQU         <(16*32+ 9):(16*32+ 9)>
;  RWXVF 
;   422 : #define NV_AUDOUT_SU_BUFF0_NOTIFY             (16*32+10):(16*32+10) /* RWXVF */
NV_AUDOUT_SU_BUFF0_NOTIFY               TEXTEQU         <(16*32+10):(16*32+10)>
;  RW--V 
;   423 : #define NV_AUDOUT_SU_BUFF0_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
NV_AUDOUT_SU_BUFF0_NOTIFY_DMA_WRITE             EQU             000000000h
;  RW--V 
;   424 : #define NV_AUDOUT_SU_BUFF0_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
NV_AUDOUT_SU_BUFF0_NOTIFY_INTERRUPT             EQU             000000001h
;  RWXVF 
;   425 : #define NV_AUDOUT_SU_BUFF1_NOTIFY             (16*32+11):(16*32+11) /* RWXVF */
NV_AUDOUT_SU_BUFF1_NOTIFY               TEXTEQU         <(16*32+11):(16*32+11)>
;  RW--V 
;   426 : #define NV_AUDOUT_SU_BUFF1_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
NV_AUDOUT_SU_BUFF1_NOTIFY_DMA_WRITE             EQU             000000000h
;  RW--V 
;   427 : #define NV_AUDOUT_SU_BUFF1_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
NV_AUDOUT_SU_BUFF1_NOTIFY_INTERRUPT             EQU             000000001h
;  RWXVF 
;   428 : #define NV_AUDOUT_SU_CHANNEL                  (16*32+12):(16*32+12) /* RWXVF */
NV_AUDOUT_SU_CHANNEL            TEXTEQU         <(16*32+12):(16*32+12)>
;  RW--V 
;   429 : #define NV_AUDOUT_SU_CHANNEL_MONO                        0x00000000 /* RW--V */
NV_AUDOUT_SU_CHANNEL_MONO               EQU             000000000h
;  RW--V 
;   430 : #define NV_AUDOUT_SU_CHANNEL_STEREO                      0x00000001 /* RW--V */
NV_AUDOUT_SU_CHANNEL_STEREO             EQU             000000001h
;  RWXVF 
;   431 : #define NV_AUDOUT_SU_FORMAT                   (16*32+15):(16*32+13) /* RWXVF */
NV_AUDOUT_SU_FORMAT             TEXTEQU         <(16*32+15):(16*32+13)>
;  RW--V 
;   432 : #define NV_AUDOUT_SU_FORMAT_LINEAR                       0x00000000 /* RW--V */
NV_AUDOUT_SU_FORMAT_LINEAR              EQU             000000000h
;  RW--V 
;   433 : #define NV_AUDOUT_SU_FORMAT_ULAW                         0x00000001 /* RW--V */
NV_AUDOUT_SU_FORMAT_ULAW                EQU             000000001h
;  RW--V 
;   434 : #define NV_AUDOUT_SU_FORMAT_ALAW                         0x00000002 /* RW--V */
NV_AUDOUT_SU_FORMAT_ALAW                EQU             000000002h
;  RW--V 
;   435 : #define NV_AUDOUT_SU_FORMAT_OFFSET8                      0x00000003 /* RW--V */
NV_AUDOUT_SU_FORMAT_OFFSET8             EQU             000000003h
;  RWXVF 
;  dev_ram.ref 
;  RW--M 
;   436 : #define NV_AUDOUT_SU_BUFF0_OFFSET             (16*32+ 1):(16*32+ 0) /* RWXVF */
;   437 : /* dev_ram.ref */
;   438 : #define NV_AUDNOTE                            0x00000083:0x00000000 /* RW--M */
NV_AUDNOTE              TEXTEQU         <0x00000083:0x00000000>
;  RWWVF 
;   439 : #define NV_AUDNOTE_AE_STATE                     (0*32+15):(0*32+ 0) /* RWWVF */
NV_AUDNOTE_AE_STATE             TEXTEQU         <(0*32+15):(0*32+ 0)>
;  RWWUF 
;   440 : #define NV_AUDNOTE_AE_POSITION_LOW              (0*32+31):(0*32+16) /* RWWUF */
NV_AUDNOTE_AE_POSITION_LOW              TEXTEQU         <(0*32+31):(0*32+16)>
;  RWWUF 
;   441 : #define NV_AUDNOTE_AE_POSITION                  (1*32+31):(1*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_POSITION          TEXTEQU         <(1*32+31):(1*32+ 0)>
;  RWWUF 
;   442 : #define NV_AUDNOTE_AE_POSITION_INC              (2*32+31):(2*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_POSITION_INC              TEXTEQU         <(2*32+31):(2*32+ 0)>
;  RWWUF 
;   443 : #define NV_AUDNOTE_AE_EG_ADSR_LEVEL             (3*32+31):(3*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_EG_ADSR_LEVEL             TEXTEQU         <(3*32+31):(3*32+ 0)>
;  RWWUF 
;   444 : #define NV_AUDNOTE_AE_PE_ADSR_LEVEL             (4*32+31):(4*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_PE_ADSR_LEVEL             TEXTEQU         <(4*32+31):(4*32+ 0)>
;  RWWUF 
;   445 : #define NV_AUDNOTE_AE_ADSR_VOLUME               (5*32+15):(5*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_ADSR_VOLUME               TEXTEQU         <(5*32+15):(5*32+ 0)>
;  RWWUF 
;   446 : #define NV_AUDNOTE_AE_VIBRATO_TREMOLO_LEVEL     (5*32+31):(5*32+16) /* RWWUF */
NV_AUDNOTE_AE_VIBRATO_TREMOLO_LEVEL             TEXTEQU         <(5*32+31):(5*32+16)>
;  RWWUF 
;   447 : #define NV_AUDNOTE_AE_VIBRATO_POSITION          (6*32+31):(6*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_VIBRATO_POSITION          TEXTEQU         <(6*32+31):(6*32+ 0)>
;  RWWUF 
;   448 : #define NV_AUDNOTE_AE_TREMOLO_POSITION          (7*32+31):(7*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_TREMOLO_POSITION          TEXTEQU         <(7*32+31):(7*32+ 0)>
;  RWWUF 
;   449 : #define NV_AUDNOTE_AE_VOLUME_1                  (8*32+15):(8*32+ 0) /* RWWUF */
NV_AUDNOTE_AE_VOLUME_1          TEXTEQU         <(8*32+15):(8*32+ 0)>
;  RWWUF 
;   450 : #define NV_AUDNOTE_AE_VOLUME_0                  (8*32+31):(8*32+16) /* RWWUF */
NV_AUDNOTE_AE_VOLUME_0          TEXTEQU         <(8*32+31):(8*32+16)>
;  RWWUF 
;   451 : #define NV_AUDNOTE_RM_NEXT_INSTANCE             (9*32+31):(9*32+ 0) /* RWWUF */
NV_AUDNOTE_RM_NEXT_INSTANCE             TEXTEQU         <(9*32+31):(9*32+ 0)>
;  RWWUF 
;   452 : #define NV_AUDNOTE_RM_VOLUME_0                (10*32+15):(10*32+ 0) /* RWWUF */
NV_AUDNOTE_RM_VOLUME_0          TEXTEQU         <(10*32+15):(10*32+ 0)>
;  RWWUF 
;   453 : #define NV_AUDNOTE_SU_VOLUME_0                (10*32+31):(10*32+16) /* RWWUF */
NV_AUDNOTE_SU_VOLUME_0          TEXTEQU         <(10*32+31):(10*32+16)>
;  RWWUF 
;   454 : #define NV_AUDNOTE_RM_VOLUME_1                (11*32+15):(11*32+ 0) /* RWWUF */
NV_AUDNOTE_RM_VOLUME_1          TEXTEQU         <(11*32+15):(11*32+ 0)>
;  RWWUF 
;   455 : #define NV_AUDNOTE_SU_VOLUME_1                (11*32+31):(11*32+16) /* RWWUF */
NV_AUDNOTE_SU_VOLUME_1          TEXTEQU         <(11*32+31):(11*32+16)>
;  RWWVF 
;   456 : #define NV_AUDNOTE_RM_STATE                   (12*32+15):(12*32+ 0) /* RWWVF */
NV_AUDNOTE_RM_STATE             TEXTEQU         <(12*32+15):(12*32+ 0)>
;  RWWUF 
;   457 : #define NV_AUDNOTE_SU_STOP_TIME_LOW           (12*32+31):(12*32+16) /* RWWUF */
NV_AUDNOTE_SU_STOP_TIME_LOW             TEXTEQU         <(12*32+31):(12*32+16)>
;  RWWVF 
;   458 : #define NV_AUDNOTE_SU_STATE                   (13*32+15):(13*32+ 0) /* RWWVF */
NV_AUDNOTE_SU_STATE             TEXTEQU         <(13*32+15):(13*32+ 0)>
;  RWWUF 
;   459 : #define NV_AUDNOTE_SU_START_TIME_LOW          (13*32+31):(13*32+16) /* RWWUF */
NV_AUDNOTE_SU_START_TIME_LOW            TEXTEQU         <(13*32+31):(13*32+16)>
;  RWWUF 
;   460 : #define NV_AUDNOTE_SU_START_TIME_HIGH         (14*32+31):(14*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_START_TIME_HIGH           TEXTEQU         <(14*32+31):(14*32+ 0)>
;  RWWUF 
;   461 : #define NV_AUDNOTE_SU_STOP_TIME_HIGH          (15*32+31):(15*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_STOP_TIME_HIGH            TEXTEQU         <(15*32+31):(15*32+ 0)>
;  RWWVF 
;   462 : #define NV_AUDNOTE_SU_FM_STATE                (16*32+15):(16*32+ 0) /* RWWVF */
NV_AUDNOTE_SU_FM_STATE          TEXTEQU         <(16*32+15):(16*32+ 0)>
;  RWWUF 
;   463 : #define NV_AUDNOTE_SU_RELEASE_TIME_LOW        (16*32+31):(16*32+16) /* RWWUF */
NV_AUDNOTE_SU_RELEASE_TIME_LOW          TEXTEQU         <(16*32+31):(16*32+16)>
;  RWWUF 
;   464 : #define NV_AUDNOTE_SU_DMA_INSTANCE            (17*32+15):(17*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_DMA_INSTANCE              TEXTEQU         <(17*32+15):(17*32+ 0)>
;  RWWUF 
;   465 : #define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_LO (17*32+31):(17*32+16) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_LO           TEXTEQU         <(17*32+31):(17*32+16)>
;  RWWUF 
;   466 : #define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_HI (18*32+31):(18*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_HI           TEXTEQU         <(18*32+31):(18*32+ 0)>
;  RWWUF 
;   467 : #define NV_AUDNOTE_SU_RELEASE_TIME_HIGH       (19*32+31):(19*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_RELEASE_TIME_HIGH         TEXTEQU         <(19*32+31):(19*32+ 0)>
;  RWWUF 
;   468 : #define NV_AUDNOTE_SU_POSITION_INC            (20*32+31):(20*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_POSITION_INC              TEXTEQU         <(20*32+31):(20*32+ 0)>
;  RWWUF 
;   469 : #define NV_AUDNOTE_SU_LOOP_START              (21*32+31):(21*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_LOOP_START                TEXTEQU         <(21*32+31):(21*32+ 0)>
;  RWWUF 
;   470 : #define NV_AUDNOTE_SU_LOOP_END_PLUS1          (22*32+31):(22*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_LOOP_END_PLUS1            TEXTEQU         <(22*32+31):(22*32+ 0)>
;  RWWUF 
;   471 : #define NV_AUDNOTE_SU_LAST_PLUS1              (23*32+31):(23*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_LAST_PLUS1                TEXTEQU         <(23*32+31):(23*32+ 0)>
;  RWWUF 
;   472 : #define NV_AUDNOTE_SU_EG_ATTACK_RATE          (24*32+15):(24*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_EG_ATTACK_RATE            TEXTEQU         <(24*32+15):(24*32+ 0)>
;  RWWUF 
;   473 : #define NV_AUDNOTE_SU_EG_DECAY_RATE           (24*32+31):(24*32+16) /* RWWUF */
NV_AUDNOTE_SU_EG_DECAY_RATE             TEXTEQU         <(24*32+31):(24*32+16)>
;  RWWUF 
;   474 : #define NV_AUDNOTE_SU_EG_SUSTAIN_RATE         (25*32+15):(25*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_EG_SUSTAIN_RATE           TEXTEQU         <(25*32+15):(25*32+ 0)>
;  RWWUF 
;   475 : #define NV_AUDNOTE_SU_EG_RELEASE_RATE         (25*32+31):(25*32+16) /* RWWUF */
NV_AUDNOTE_SU_EG_RELEASE_RATE           TEXTEQU         <(25*32+31):(25*32+16)>
;  RWWUF 
;   476 : #define NV_AUDNOTE_SU_PE_ATTACK_RATE          (26*32+15):(26*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_PE_ATTACK_RATE            TEXTEQU         <(26*32+15):(26*32+ 0)>
;  RWWUF 
;   477 : #define NV_AUDNOTE_SU_PE_DECAY_RATE           (26*32+31):(26*32+16) /* RWWUF */
NV_AUDNOTE_SU_PE_DECAY_RATE             TEXTEQU         <(26*32+31):(26*32+16)>
;  RWWUF 
;   478 : #define NV_AUDNOTE_SU_PE_SUSTAIN_RATE         (27*32+15):(27*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_PE_SUSTAIN_RATE           TEXTEQU         <(27*32+15):(27*32+ 0)>
;  RWWUF 
;   479 : #define NV_AUDNOTE_SU_PE_RELEASE_RATE         (27*32+31):(27*32+16) /* RWWUF */
NV_AUDNOTE_SU_PE_RELEASE_RATE           TEXTEQU         <(27*32+31):(27*32+16)>
;  RWWUF 
;   480 : #define NV_AUDNOTE_SU_VIBRATO_TREMOLO_ATTACK  (28*32+15):(28*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_TREMOLO_ATTACK            TEXTEQU         <(28*32+15):(28*32+ 0)>
;  RWWUF 
;   481 : #define NV_AUDNOTE_SU_VIBRATO_DEPTH           (29*32+15):(29*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_DEPTH             TEXTEQU         <(29*32+15):(29*32+ 0)>
;  RWWUF 
;   482 : #define NV_AUDNOTE_SU_EG_SUSTAIN_LEVEL        (29*32+31):(29*32+16) /* RWWUF */
NV_AUDNOTE_SU_EG_SUSTAIN_LEVEL          TEXTEQU         <(29*32+31):(29*32+16)>
;  RWWUF 
;   483 : #define NV_AUDNOTE_SU_PE_SCALE                (30*32+15):(30*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_PE_SCALE          TEXTEQU         <(30*32+15):(30*32+ 0)>
;  RWWUF 
;   484 : #define NV_AUDNOTE_SU_PE_SUSTAIN_LEVEL        (30*32+31):(30*32+16) /* RWWUF */
NV_AUDNOTE_SU_PE_SUSTAIN_LEVEL          TEXTEQU         <(30*32+31):(30*32+16)>
;  RWWUF 
;   485 : #define NV_AUDNOTE_SU_TREMOLO_POSITION_INC    (31*32+15):(31*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_TREMOLO_POSITION_INC              TEXTEQU         <(31*32+15):(31*32+ 0)>
;  RWWUF 
;   486 : #define NV_AUDNOTE_SU_VIBRATO_POSITION_INC    (31*32+31):(31*32+16) /* RWWUF */
NV_AUDNOTE_SU_VIBRATO_POSITION_INC              TEXTEQU         <(31*32+31):(31*32+16)>
;  RWWUF 
;   487 : #define NV_AUDNOTE_SU_TREMOLO_DEPTH           (32*32+15):(32*32+ 0) /* RWWUF */
NV_AUDNOTE_SU_TREMOLO_DEPTH             TEXTEQU         <(32*32+15):(32*32+ 0)>
;  RWWUF 
;   488 : #define NV_AUDNOTE_SU_TREMOLO_OFFSET          (32*32+31):(32*32+16) /* RWWUF */
NV_AUDNOTE_SU_TREMOLO_OFFSET            TEXTEQU         <(32*32+31):(32*32+16)>
;  RWXVF 
;   489 : #define NV_AUDNOTE_AE_INTR_MIXING             ( 0*32+ 0):( 0*32+ 0) /* RWXVF */
NV_AUDNOTE_AE_INTR_MIXING               TEXTEQU         <( 0*32+ 0):( 0*32+ 0)>
;  RWXVF 
;   490 : #define NV_AUDNOTE_AE_INTR_VOLUME             ( 0*32+ 1):( 0*32+ 1) /* RWXVF */
NV_AUDNOTE_AE_INTR_VOLUME               TEXTEQU         <( 0*32+ 1):( 0*32+ 1)>
;  RWXVF 
;   491 : #define NV_AUDNOTE_AE_EVENT_STOP              ( 0*32+ 2):( 0*32+ 2) /* RWXVF */
NV_AUDNOTE_AE_EVENT_STOP                TEXTEQU         <( 0*32+ 2):( 0*32+ 2)>
;  RWXVF 
;   492 : #define NV_AUDNOTE_AE_EVENT_START             ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
NV_AUDNOTE_AE_EVENT_START               TEXTEQU         <( 0*32+ 3):( 0*32+ 3)>
;  RWXVF 
;   493 : #define NV_AUDNOTE_AE_INTR_NOTIFY             ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
NV_AUDNOTE_AE_INTR_NOTIFY               TEXTEQU         <( 0*32+ 4):( 0*32+ 4)>
;  RWXVF 
;   494 : #define NV_AUDNOTE_AE_PE_STATE                ( 0*32+ 7):( 0*32+ 6) /* RWXVF */
NV_AUDNOTE_AE_PE_STATE          TEXTEQU         <( 0*32+ 7):( 0*32+ 6)>
;  RW--V 
;   495 : #define NV_AUDNOTE_AE_PE_ATTACK                          0x00000000 /* RW--V */
NV_AUDNOTE_AE_PE_ATTACK         EQU             000000000h
;  RW--V 
;   496 : #define NV_AUDNOTE_AE_PE_DECAY                           0x00000001 /* RW--V */
NV_AUDNOTE_AE_PE_DECAY          EQU             000000001h
;  RW--V 
;   497 : #define NV_AUDNOTE_AE_PE_SUSTAIN                         0x00000002 /* RW--V */
NV_AUDNOTE_AE_PE_SUSTAIN                EQU             000000002h
;  RW--V 
;   498 : #define NV_AUDNOTE_AE_PE_RELEASE                         0x00000003 /* RW--V */
NV_AUDNOTE_AE_PE_RELEASE                EQU             000000003h
;  RWXVF 
;   499 : #define NV_AUDNOTE_AE_IN_USE                  ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
NV_AUDNOTE_AE_IN_USE            TEXTEQU         <( 0*32+ 8):( 0*32+ 8)>
;  RWXVF 
;   500 : #define NV_AUDNOTE_AE_GAP_DETECT              ( 0*32+10):( 0*32+10) /* RWXVF */
NV_AUDNOTE_AE_GAP_DETECT                TEXTEQU         <( 0*32+10):( 0*32+10)>
;  RWXVF 
;   501 : #define NV_AUDNOTE_AE_INTR_DMA                ( 0*32+11):( 0*32+11) /* RWXVF */
NV_AUDNOTE_AE_INTR_DMA          TEXTEQU         <( 0*32+11):( 0*32+11)>
;  RWXVF 
;   502 : #define NV_AUDNOTE_AE_EG_STATE                ( 0*32+14):( 0*32+13) /* RWXVF */
NV_AUDNOTE_AE_EG_STATE          TEXTEQU         <( 0*32+14):( 0*32+13)>
;  RW--V 
;   503 : #define NV_AUDNOTE_AE_EG_ATTACK                          0x00000000 /* RW--V */
NV_AUDNOTE_AE_EG_ATTACK         EQU             000000000h
;  RW--V 
;   504 : #define NV_AUDNOTE_AE_EG_DECAY                           0x00000001 /* RW--V */
NV_AUDNOTE_AE_EG_DECAY          EQU             000000001h
;  RW--V 
;   505 : #define NV_AUDNOTE_AE_EG_SUSTAIN                         0x00000002 /* RW--V */
NV_AUDNOTE_AE_EG_SUSTAIN                EQU             000000002h
;  RW--V 
;   506 : #define NV_AUDNOTE_AE_EG_RELEASE                         0x00000003 /* RW--V */
NV_AUDNOTE_AE_EG_RELEASE                EQU             000000003h
;  RWXVF 
;   507 : #define NV_AUDNOTE_AE_POS_VALID               ( 0*32+15):( 0*32+15) /* RWXVF */
NV_AUDNOTE_AE_POS_VALID         TEXTEQU         <( 0*32+15):( 0*32+15)>
;  RWXVF 
;   508 : #define NV_AUDNOTE_RM_INTR_MIXING             (14*32+ 0):(14*32+ 0) /* RWXVF */
NV_AUDNOTE_RM_INTR_MIXING               TEXTEQU         <(14*32+ 0):(14*32+ 0)>
;  RWXVF 
;   509 : #define NV_AUDNOTE_RM_INTR_VOLUME             (14*32+ 1):(14*32+ 1) /* RWXVF */
NV_AUDNOTE_RM_INTR_VOLUME               TEXTEQU         <(14*32+ 1):(14*32+ 1)>
;  RWXVF 
;   510 : #define NV_AUDNOTE_RM_INTR_NOTIFY             (14*32+ 4):(14*32+ 4) /* RWXVF */
NV_AUDNOTE_RM_INTR_NOTIFY               TEXTEQU         <(14*32+ 4):(14*32+ 4)>
;  RWXVF 
;   511 : #define NV_AUDNOTE_SU_BYPASS_PTE              (12*32+ 4):(12*32+ 4) /* RWXVF */
NV_AUDNOTE_SU_BYPASS_PTE                TEXTEQU         <(12*32+ 4):(12*32+ 4)>
;  RW--V 
;   512 : #define NV_AUDNOTE_SU_BYPASS_PTE_DISABLED                0x00000000 /* RW--V */
NV_AUDNOTE_SU_BYPASS_PTE_DISABLED               EQU             000000000h
;  RW--V 
;   513 : #define NV_AUDNOTE_SU_BYPASS_PTE_ENABLED                 0x00000001 /* RW--V */
NV_AUDNOTE_SU_BYPASS_PTE_ENABLED                EQU             000000001h
;  RWXVF 
;   514 : #define NV_AUDNOTE_SU_BYPASS_TARGET           (12*32+ 6):(12*32+ 5) /* RWXVF */
NV_AUDNOTE_SU_BYPASS_TARGET             TEXTEQU         <(12*32+ 6):(12*32+ 5)>
;  RW--V 
;   515 : #define NV_AUDNOTE_SU_BYPASS_TARGET_NVM                  0x00000000 /* RW--V */
NV_AUDNOTE_SU_BYPASS_TARGET_NVM         EQU             000000000h
;  RW--V 
;   516 : #define NV_AUDNOTE_SU_BYPASS_TARGET_PCI                  0x00000002 /* RW--V */
NV_AUDNOTE_SU_BYPASS_TARGET_PCI         EQU             000000002h
;  RW--V 
;   517 : #define NV_AUDNOTE_SU_BYPASS_TARGET_AGP                  0x00000003 /* RW--V */
NV_AUDNOTE_SU_BYPASS_TARGET_AGP         EQU             000000003h
;  RWXVF 
;   518 : #define NV_AUDNOTE_SU_EG_LINEAR               (12*32+ 7):(12*32+ 7) /* RWXVF */
NV_AUDNOTE_SU_EG_LINEAR         TEXTEQU         <(12*32+ 7):(12*32+ 7)>
;  RW--V 
;   519 : #define NV_AUDNOTE_SU_EG_ATCK_NV1                        0x00000000 /* RW--V */
NV_AUDNOTE_SU_EG_ATCK_NV1               EQU             000000000h
;  RW--V 
;   520 : #define NV_AUDNOTE_SU_EG_ATCK_LINEAR                     0x00000001 /* RW--V */
NV_AUDNOTE_SU_EG_ATCK_LINEAR            EQU             000000001h
;  RWXVF 
;   521 : #define NV_AUDNOTE_SU_IN_USE                  (12*32+ 8):(12*32+ 8) /* RWXVF */
NV_AUDNOTE_SU_IN_USE            TEXTEQU         <(12*32+ 8):(12*32+ 8)>
;  RWXVF 
;   522 : #define NV_AUDNOTE_SU_BUFF_NOTIFY             (16*32+10):(16*32+10) /* RWXVF */
NV_AUDNOTE_SU_BUFF_NOTIFY               TEXTEQU         <(16*32+10):(16*32+10)>
;  RW--V 
;   523 : #define NV_AUDNOTE_SU_BUFF_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
NV_AUDNOTE_SU_BUFF_NOTIFY_DMA_WRITE             EQU             000000000h
;  RW--V 
;   524 : #define NV_AUDNOTE_SU_BUFF_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
NV_AUDNOTE_SU_BUFF_NOTIFY_INTERRUPT             EQU             000000001h
;  RWXVF 
;   525 : #define NV_AUDNOTE_SU_CHANNEL                 (12*32+12):(12*32+12) /* RWXVF */
NV_AUDNOTE_SU_CHANNEL           TEXTEQU         <(12*32+12):(12*32+12)>
;  RW--V 
;   526 : #define NV_AUDNOTE_SU_CHANNEL_MONO                       0x00000000 /* RW--V */
NV_AUDNOTE_SU_CHANNEL_MONO              EQU             000000000h
;  RW--V 
;   527 : #define NV_AUDNOTE_SU_CHANNEL_STEREO                     0x00000001 /* RW--V */
NV_AUDNOTE_SU_CHANNEL_STEREO            EQU             000000001h
;  RWXVF 
;   528 : #define NV_AUDNOTE_SU_FORMAT                  (12*32+15):(12*32+13) /* RWXVF */
NV_AUDNOTE_SU_FORMAT            TEXTEQU         <(12*32+15):(12*32+13)>
;  RW--V 
;   529 : #define NV_AUDNOTE_SU_FORMAT_LINEAR                      0x00000000 /* RW--V */
NV_AUDNOTE_SU_FORMAT_LINEAR             EQU             000000000h
;  RW--V 
;   530 : #define NV_AUDNOTE_SU_FORMAT_ULAW                        0x00000001 /* RW--V */
NV_AUDNOTE_SU_FORMAT_ULAW               EQU             000000001h
;  RW--V 
;   531 : #define NV_AUDNOTE_SU_FORMAT_ALAW                        0x00000002 /* RW--V */
NV_AUDNOTE_SU_FORMAT_ALAW               EQU             000000002h
;  RW--V 
;   532 : #define NV_AUDNOTE_SU_FORMAT_OFFSET8                     0x00000003 /* RW--V */
NV_AUDNOTE_SU_FORMAT_OFFSET8            EQU             000000003h
;  RWXVF 
;   533 : #define NV_AUDNOTE_FM_FEEDBACK                (15*32+ 6):(15*32+ 4) /* RWXVF */
NV_AUDNOTE_FM_FEEDBACK          TEXTEQU         <(15*32+ 6):(15*32+ 4)>
;  RW--V 
;   534 : #define NV_AUDNOTE_FM_FB_0                               0x00000000 /* RW--V */
NV_AUDNOTE_FM_FB_0              EQU             000000000h
;  RW--V 
;   535 : #define NV_AUDNOTE_FM_FB_PI_16                           0x00000001 /* RW--V */
NV_AUDNOTE_FM_FB_PI_16          EQU             000000001h
;  RW--V 
;   536 : #define NV_AUDNOTE_FM_FB_PI_8                            0x00000002 /* RW--V */
NV_AUDNOTE_FM_FB_PI_8           EQU             000000002h
;  RW--V 
;   537 : #define NV_AUDNOTE_FM_FB_PI_4                            0x00000003 /* RW--V */
NV_AUDNOTE_FM_FB_PI_4           EQU             000000003h
;  RW--V 
;   538 : #define NV_AUDNOTE_FM_FB_PI_2                            0x00000004 /* RW--V */
NV_AUDNOTE_FM_FB_PI_2           EQU             000000004h
;  RW--V 
;   539 : #define NV_AUDNOTE_FM_FB_1_PI                            0x00000005 /* RW--V */
NV_AUDNOTE_FM_FB_1_PI           EQU             000000005h
;  RW--V 
;   540 : #define NV_AUDNOTE_FM_FB_2_PI                            0x00000006 /* RW--V */
NV_AUDNOTE_FM_FB_2_PI           EQU             000000006h
;  RW--V 
;   541 : #define NV_AUDNOTE_FM_FB_4_PI                            0x00000007 /* RW--V */
NV_AUDNOTE_FM_FB_4_PI           EQU             000000007h
;  RWXVF 
;   542 : #define NV_AUDNOTE_FM_WAVE_SELECT             (15*32+ 2):(15*32+ 0) /* RWXVF */
NV_AUDNOTE_FM_WAVE_SELECT               TEXTEQU         <(15*32+ 2):(15*32+ 0)>
;  RW--V 
;   543 : #define NV_AUDNOTE_FM_WS_SINE                            0x00000000 /* RW--V */
NV_AUDNOTE_FM_WS_SINE           EQU             000000000h
;  RW--V 
;   544 : #define NV_AUDNOTE_FM_WS_HALF_SINE                       0x00000001 /* RW--V */
NV_AUDNOTE_FM_WS_HALF_SINE              EQU             000000001h
;  RW--V 
;   545 : #define NV_AUDNOTE_FM_WS_ABS_SINE                        0x00000002 /* RW--V */
NV_AUDNOTE_FM_WS_ABS_SINE               EQU             000000002h
;  RW--V 
;   546 : #define NV_AUDNOTE_FM_WS_SHARK_SINE                      0x00000003 /* RW--V */
NV_AUDNOTE_FM_WS_SHARK_SINE             EQU             000000003h
;  RW--V 
;   547 : #define NV_AUDNOTE_FM_WS_QUICK_SINE                      0x00000004 /* RW--V */
NV_AUDNOTE_FM_WS_QUICK_SINE             EQU             000000004h
;  RW--V 
;   548 : #define NV_AUDNOTE_FM_WS_ABS_QUICK                       0x00000005 /* RW--V */
NV_AUDNOTE_FM_WS_ABS_QUICK              EQU             000000005h
;  RW--V 
;   549 : #define NV_AUDNOTE_FM_WS_SQUARE                          0x00000006 /* RW--V */
NV_AUDNOTE_FM_WS_SQUARE         EQU             000000006h
;  RW--V 
;   550 : #define NV_AUDNOTE_FM_WS_INV_SINE                        0x00000007 /* RW--V */
NV_AUDNOTE_FM_WS_INV_SINE               EQU             000000007h
;  RWXVF 
;   551 : #define NV_AUDNOTE_FM_PHASE_OUT               (15*32+ 8):(15*32+ 8) /* RWXVF */
NV_AUDNOTE_FM_PHASE_OUT         TEXTEQU         <(15*32+ 8):(15*32+ 8)>
;  RWXVF 
;   552 : #define NV_AUDNOTE_FM_SYNTHESIS               (15*32+12):(15*32+12) /* RWXVF */
NV_AUDNOTE_FM_SYNTHESIS         TEXTEQU         <(15*32+12):(15*32+12)>
;  _NV_REF_H_ 
;   553 : #endif /* _NV_REF_H_ */
;   554 : 
; End of file nv_ref.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\nv_sim.inc ===
;       Copyright (C) 1996-1997 NVidia Corporation
;
;       NV_SIM.INC - NVidia simulation specific macro definitions
;
;       Written by:     Mark Stephen Krueger
;       Date:           9/13/96
;
;       $Revision: 1 $
;       $Date: 5/13/97 10:43a $
;       $Logfile: /resman.040/win96/vdd/nv_sim.inc $
;       $Log: /resman.040/win96/vdd/nv_sim.inc $
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 2     1/23/97 10:58a Markk
; Removed tabs.
; Fixed copyright.
; 
; 1     11/15/96 6:12p Markk
; Used for simulating NV3.
; 
; 1     9/24/96 3:44p Markk
; Created from part of nv_mac.inc.
; 
;
;       SIM_NO - Simulate an out to an NV I/O port
;
;       Parameters: port - dx or constant I/O port below 00100h
;                   value - ax or al
;       Entry:  dx - I/O port (optional)
;               ax/al - Value
;       Exit:   None
;       Return: None
;       Uses:   None
;
SIM_NO macro port:req, value:req
    IFDEF SERIAL_OUT_OPS
        ifidni <port>, <DX>
            ifidni <value>, <AX>
                call    NVLogOutWord
            else
                call    NVLogOutByte
            endif
        else
            ifidni <value>, <AX>
                push    dx
                mov     dx, port
                call    NVLogOutWord
                pop     dx
            else
                push    dx
                mov     dx, port
                call    NVLogOutByte
                pop     dx
            endif
        endif
    ELSE ; SERIAL_OUT_OPS
        IFDEF NVIDIA_SIMULATE
                ifidni <port>, <DX>
                    ifidni <value>, <AX>
                        call    NVSimulateOutWord
                    else
                        call    NVSimulateOutByte
                    endif
                else
                    ifidni <value>, <AX>
                        push    dx
                        mov     dx, port
                        call    NVSimulateOutWord
                        pop     dx
                    else
                        push    dx
                        mov     dx, port
                        call    NVSimulateOutByte
                        pop     dx
                    endif
                endif
        ELSE ; NVIDIA_SIMULATE
                IFNDEF WEITEK_PROTO
                    out port, value
                ENDIF ; WEITEK_PROTO
        ENDIF ; NVIDIA_SIMULATE
    ENDIF ; SERIAL_OUT_OPS
endm
;
;       SIM_WO - Simulate an out to a Weitek I/O port
;
;       Parameters: port - dx or constant I/O port below 00100h
;                   value - ax or al
;       Entry:  dx - I/O port (optional)
;               ax/al - Value
;       Exit:   None
;       Return: None
;       Uses:   None
;
SIM_WO macro port:req, value:req
    IFDEF WEITEK_PROTO
        out port, value
    ELSE
        .err <Use of SIM_WO without WEITEK_PROTO defined.>
    ENDIF ; WEITEK_PROTO
endm
;
;       SIM_NI - Simulate an in from an NV I/O port
;
;       Parameters: dest - ax or al
;                   port - dX or constant I/O port below 00100h
;       Entry:  dx - I/O port (optional)
;       Exit:   al or ax - value
;       Return: None
;       Uses:   None
;
SIM_NI macro dest:req, port:req
    IFDEF NVIDIA_SIMULATE
        ifidni <port>, <DX>
            ifidni <dest>, <AX>
                call    NVSimulateInWord
            else
                call    NVSimulateInByte
            endif
        else
            .err <Can not do SIM_NI from system port>
        endif
    ELSE ; NVIDIA_SIMULATE
        in dest, port
    ENDIF ; NVIDIA_SIMULATE
endm
;
;       SIM_WI - Simulate an in from a Weitek I/O port
;
;       Parameters: dest - ax or al
;                   port - dX or constant I/O port below 00100h
;       Entry:  dx - I/O port (optional)
;       Exit:   al or ax - value
;       Return: None
;       Uses:   None
;
SIM_WI macro dest:req, port:req
    IFDEF WEITEK_PROTO
        in dest, port
    ELSE
        .err <Use of SIM_WI without WEITEK_PROTO defined.>
    ENDIF ; WEITEK_PROTO
endm
;
;       SIM_GET_INDEX_REGISTER_WTK - Simulate an in from a Weitek indexed I/O port
;
;       Parameters: None
;       Entry:  dx - I/O port
;               al - Index
;       Exit:   ah - Value
;       Return: None
;       Uses:   None
;
SIM_GET_INDEX_REGISTER_WTK macro
        IFDEF NVIDIA_SIMULATE
                call    WTKGetIndexRegister
        ELSE ; NVIDIA_SIMULATE
                call    GetIndexRegister
        ENDIF ; NVIDIA_SIMULATE
endm
;
;       SIM_GET_INDEX_REGISTER_NV - Simulate an in from an NV indexed I/O port
;
;       Parameters: None
;       Entry:  dx - I/O port
;               al - Index
;       Exit:   ah - Value
;       Return: None
;       Uses:   None
;
SIM_GET_INDEX_REGISTER_NV macro
        IFDEF NVIDIA_SIMULATE
                call    NVGetIndexRegister
        ELSE ; NVIDIA_SIMULATE
                call    GetIndexRegister
        ENDIF ; NVIDIA_SIMULATE
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\OSWIN.H ===
#ifndef _OSWIN_H_
#define _OSWIN_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OSWIN.H                                                           *
*       Operating system wrapper functions used to abstract the OS.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    11/22/93 - wrote it.                    *
*       David Schmenk (dschmenk)    06/22/94 - rewrote it.                  *
*       Jeff Westerinen (jsw)    	05/05/97 - Modified to build under MS   *
*                                                                           *
\***************************************************************************/

//
// necessary definitions due to (missing in) new headers
//
#define CARRY       void
//
// necessary abstract types due to new headers (jsw)
// typedef struct VxD_Desc_Block DDB;
//
typedef CLIENT_STRUCT *PCS;
//
// IOCTL functions.
//
typedef VOID (*IOCTL_DISPATCH)(U032, DWORD, PVOID);

//---------------------------------------------------------------------------
//
//  OS specific defines.
//
//---------------------------------------------------------------------------

//
// Number of outstanding callbacks.
//
#define NUM_CALLBACKS                   64
#define MAX_PARAMS                      10
//
// Size of service stack.
//
#define STACK_SIZE                      8192

//---------------------------------------------------------------------------
//
//  OS specific structures.
//
//---------------------------------------------------------------------------

//
// Array of callback parameters.
//
typedef struct _def_callback
{
    U016 Selector;
    U016 Offset;
    U032 Count;
    U032 Params[MAX_PARAMS];
    struct _def_callback *Next;
} CALLBACK, *PCALLBACK;

//---------------------------------------------------------------------------
//
//  External variable definitions.
//
//---------------------------------------------------------------------------

// JJV-MM
//extern PCHANNELINFO channelInfo;
extern PCLIENTINFO    clientInfo;
// JJV-MM
//extern U032         hpicIRQ;
//extern IOCTL_DISPATCH rmArchDispatchTable[];
extern U032           rmInService;
extern U032           osInService;
extern U032           rmInSafeService;
extern U032           rmInCallback;
extern U032           rmSemaphore;
extern U032           osSemaphore;
extern U032           mmSemaphore;
extern U032         * rmStackBase;
extern U032         * rmStack;
extern U032           vmmStack;

// Registry string globals.
extern char strDevNodeRM[];
extern char strRegistryGlobalParameters[];
extern char strRmCoreName[];
extern char strRmCoreVxd[];

extern char strMaxRefreshRate[];
extern char strMaxOptimalRefreshRate[];
extern char strOptimalNotFromEDID[];
extern char strDMTOverride[];
extern char strMonitorTiming[];
extern char strCursorCacheOverride[];
extern char strDisplayType[];
extern char strDisplay2Type[];
extern char strTVtype[];
extern char strStartUp[];
extern char strTVOutType[];
extern char strNewModeSet[];
extern char strFpMode[];


//
// Callback functions into the 16 bit RM DLL.
//
// JJV-MM
//extern U032      dllNotifyOffset;
//extern U032      dllNotifySelector;
//extern U032      dllIpcOffset;
//extern U032      dllIpcSelector;
extern PCALLBACK osCallbackTable;
extern PCALLBACK osCallbackList;
extern PCALLBACK osCallbackFreeList;

//---------------------------------------------------------------------------
//
// Function prototypes.
//
//---------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

//
//  PCI BIOS interface.
//
VOID CDECL PCI(PCS);  // (jsw)

//
// VBE BIOS interface.
//
VOID CDECL VBE(PCS);  // (jsw)
VOID CDECL readToshibaEDID(PCS);  // (lpl)
VOID CDECL VBE30(PCS);  // (jsw)

//
//  Timer BIOS interface.
//
VOID CDECL TIMER(CLIENT_STRUCT *);


#ifdef __cplusplus
};
#endif

#define CLI	_asm cli

#define STI _asm sti

//
// Function prototypes for Resource Manager entrypoints.
//
RM_STATUS CDECL rmControl(U032, U032);
U032      CDECL rmGetVersion(VOID);
U032      CDECL rmSysRegister(U032, NVRMSYSAPI *);
U032      CDECL rmEnableVga(PHWINFO, BOOL);
U032      CDECL rmFixUpVga(VOID);
U032	  CDECL rmGetAddress(U032);
U032      CDECL rmEnableHiRes(PHWINFO, BOOL);
U032      CDECL rmSetDpmLevel(U032);
U032      CDECL rmDDC(U032 *);
RM_STATUS CDECL rmSysAPI(U032, U032, V032, V032);
RM_STATUS  __fastcall     rmUsrAPI(U032, PCS);
//RM_STATUS CDECL rmUsrAPI(U032, PCS);  // (jsw)
//VOID            rmUsrPrivAPI(U032, PCRS); (jsw)
S032            rmGetDevInfo(U032);
VOID            rmInterrupt(U032, U032);
VOID            osInterrupt(U032, U032);
U032            osInterruptProcess(PHWINFO *,U032, U032);
BOOL      CDECL osService(PHWINFO);
VOID      CDECL osBoostService(VOID);
VOID      CDECL osSafeService(VOID);
VOID            osVMIntEOI(U032, U032);
VOID            osNopInt(U032, U032);
RM_STATUS CDECL osScheduleCallback(PHWINFO,U016, U016, U032, U032, ...);
VOID            osCallback(U032);
//
// Initialization routines.
//
RM_STATUS initStack(VOID);
RM_STATUS initSemaphore(VOID);
RM_STATUS initCallbackFreeList(VOID);
RM_STATUS initClientInfo(VOID);
RM_STATUS initChannelInfo(VOID);
RM_STATUS initDevInfo(VOID);
RM_STATUS initNv(VOID);
//
// Stack switch routine.
//
U032 osSwapStack(U032);
/*** Watcom syntax...  (jsw)
#pragma aux osSwapStack   =                         \
            "xchg   EAX, ESP"                       \
            parm [EAX]                              \
            value [EAX];
*/

//
// Register push/pop routines.
//
/* (jsw)
VOID osPushRegs(VOID);
VOID osPopRegs(VOID);
#pragma aux osPushRegs    =                         \
            "push   EBP"                            \
            "push   EAX"                            \
            "push   EBX"                            \
            "push   ECX"                            \
            "push   EDX"                            \
            "push   ESI"                            \
            "push   EDI"                            \
            modify [];
#pragma aux osPopRegs    =                          \
            "pop    EDI"                            \
            "pop    ESI"                            \
            "pop    EDX"                            \
            "pop    ECX"                            \
            "pop    EBX"                            \
            "pop    EAX"                            \
            "pop    EBP"                            \
            modify [];
*/

//---------------------------------------------------------------------------
//
//  Compiler specific options are set here to interface to the VMM and other
//  VxDs in the system.  Different calling conventions are used for almost
//  every function.  Inlining of functions and assembly interface operations
//  are used extensively for performance and size considerations.
//
//---------------------------------------------------------------------------

//
// Handy functions used in this module.
//
/* (jsw)
DWORD asmGetCS(VOID);
#pragma aux asmGetCS =                              \
            "xor    EAX, EAX"                       \
            "mov    AX, CS"                         \
            value [EAX];
DWORD asmGetDS(VOID);
#pragma aux asmGetDS =                              \
            "xor    EAX, EAX"                       \
            "mov    AX, DS"                         \
            value [EAX];
*/

/*  Watcom syntax  (jsw)
VOID CLI(VOID);
#pragma aux CLI = "cli";
VOID STI(VOID);
#pragma aux STI = "sti";
*/
//VOID CLI(VOID);
//VOID STI(VOID);

//
// Parameter passing/return value mapping to entrypoints.
//
/*  no such specific parameter passing tweaking in MSC -- will this kill performance???
#pragma aux (VMM_CTL)   rmControl;
#pragma aux (VMM_API)   rmUsrAPI;
#pragma aux (VPICD_INT) rmInterrupt;
#pragma aux (VMM_CB)    osCallBack;
#pragma aux (VPICD_INT) osInterrupt;
#pragma aux (VPICD_INT) osVMIntEOI;
#pragma aux (VPICD_INT) osNopInt;
*/

#endif // _OSWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\serial.h ===
#ifndef _SERIAL_H_
#define _SERIAL_H_

#define DBG_COM1_PORT (0x3F8)
#define DBG_COM2_PORT (0x2F8)

#define DATA_OFFSET (0)
#define DLOW_OFFSET (0)
#define ICR_OFFSET (1)
#define DHI_OFFSET (1)
#define IIR_OFFSET (2)
#define FIFO_OFFSET (2)
#define LCR_OFFSET (3)
#define MCR_OFFSET (4)
#define LSR_OFFSET (5)
#define MRR_OFFSET (6)
#define SPARE_OFFSET (7)

#ifndef PSTR
typedef char * PSTR;
#endif

NvU16 dbgBaudRate(NvU32 uBaudRate);
VOID dbgInitSerial(PDBGPORT pDbgPort);
VOID dbgDisplaySerial(PSTR pStr);


#define DBG_FFLAGS_BINARY (0x00000001)
#define DBG_FFLAGS_PARITY (0x00000002)
#define DBG_FFLAGS_CTSFLOW (0x00000004)
#define DBG_FFLAGS_DSRFLOW (0x00000008)
#define DBG_FFLAGS_DTRCONTROL (0x00000030)
#define DBG_FFLAGS_TXONOFF (0x00000040)
#define DBG_FFLAGS_OUTX (0x00000080)
#define DBG_FFLAGS_INX (0x00000100)
#define DBG_FFLAGS_ERRORCHAR (0x00000200)
#define DBG_FFLAGS_FNULL (0x00000400)
#define DBG_FFLAGS_RTS (0x00001800)
#define DBG_FFLAGS_ABORT (0x00020000)
#define DBG_FFLAGS_DUMMY2 (0xFFFC0000)

#define FAR far

typedef struct _WIN32DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */
    DWORD BaudRate;       /* Baudrate at which running       */
    DWORD fFlags;         /* All the stuff blow is one dword */ 
#if 0
    DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1;     /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2;  /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1;  /* Enable Err Replacement          */
    DWORD fNull: 1;       /* Enable Null stripping           */
    DWORD fRtsControl:2;  /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17;     /* Reserved                        */
#endif
    WORD wReserved;       /* Not currently used              */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    char ErrorChar;       /* Error replacement char          */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Recieved Event character        */
    char xx1;
    char xx2;
} WIN32DCB, * PWIN32DCB;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\nv_mac.inc ===
;       Copyright (C) 1996-1997 NVidia Corporation
;
;       NV_MAC.INC - NVidia specific macro definitions for the VxD environment
;
;       Written by:     Mark Stephen Krueger
;       Date:           7/22/96
;
;       $Revision: 5 $
;       $Date: 3/10/98 10:36a $
;       $Logfile: /resman.040/win96/vdd/nv_mac.inc $
;       $Log: /resman.040/win96/vdd/nv_mac.inc $
; 
; 5     3/10/98 10:36a Jhinman
; Fix bug in reg_rd08 (read 32).
; 
; 4     2/13/98 3:36p Jhinman
; Add reg_wr08/reg_rd08 macros.
; 
; 3     1/09/98 2:03p Jhinman
; Address of chip (nvAddr) is now local, since RM is separate from
; miniVDD. Removed the underscore, since its not a "C" declaration.
; 
; 2     10/30/97 6:43p Jhinman
; Add underscore to nvAddr, since its now declared in osapi.c.
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 4     1/23/97 10:57a Markk
; Removed tabs.
; 
; 3     11/15/96 6:07p Markk
; Added code for simulating NV accesses.
; 
; 2     11/13/96 12:33p Markk
; Fixed bugs with REG_WR32 and REG_RD32 macros.
; 
; 1     10/16/96 9:15a Markk
; Contains NV macros for the VDD environment.
;

;
;       REG_WR32 - Writes the value in eax to an NV register
;
;       Parameters: nv_address - Address to write to (optional)
;       Entry:  esi - Address to write to (optional)
;               eax - Value
;       Exit:   None
;       Return: None
;       Uses:   esi (if esi not already loaded with address)
;
REG_WR32 macro nv_address:=<esi>, data
    ifnb <data>
        mov     eax,data
    endif
IFDEF NVIDIA_SIMULATE
    ifidni <nv_address>, <esi>
        push    eax
        push    ebx
        mov     ebx,eax
        mov     eax,esi
        call    NVSimulateWriteReg
        pop     ebx
        pop     eax
    else
        mov     esi,nv_address
        push    eax
        push    ebx
        mov     ebx,eax
        mov     eax,esi
        call    NVSimulateWriteReg
        pop     ebx
        pop     eax
    endif
ELSE ; NVIDIA_SIMULATE
    ifidni <nv_address>, <esi>
        add     esi,nvAddr
        mov     [esi],eax
        sub     esi,nvAddr
    else
        mov     esi,nv_address
        add     esi,nvAddr
        mov     [esi],eax
;        sub     esi,nvAddr
    endif
ENDIF ; NVIDIA_SIMULATE
    exitm <>
endm
;
;       REG_RD32 - Reads the value in an NV register into eax
;
;       Parameters: nv_address - Address to read from  (optional)
;       Entry:  esi - Address to read from  (optional)
;       Exit:   eax - Value
;       Return: None
;       Uses:   esi (if esi not already loaded with address)
;
REG_RD32 macro nv_address:=<esi>
IFDEF NVIDIA_SIMULATE
    ifidni <nv_address>, <esi>
        push    ebx
        mov     eax,esi
        call    NVSimulateReadReg
        mov     eax,ebx
        pop     ebx
    else
        mov     esi,nv_address
        push    ebx
        mov     eax,esi
        call    NVSimulateReadReg
        mov     eax,ebx
        pop     ebx
    endif
ELSE ; NVIDIA_SIMULATE
    ifidni <nv_address>, <esi>
        add     esi,nvAddr
        mov     eax,[esi]
        sub     esi,nvAddr
    else
        mov     esi,nv_address
        add     esi,nvAddr
        mov     eax,[esi]         
;        sub     esi,nvAddr
    endif
ENDIF ; NVIDIA_SIMULATE
    exitm <>
endm
;
;
;       REG_WR08 - Writes the value in eax to an NV register
;
;       Parameters: nv_address - Address to write to (optional)
;       Entry:  esi - Address to write to (optional)
;               al - Value
;       Exit:   None
;       Return: None
;       Uses:   esi (if esi not already loaded with address)
;
REG_WR08 macro nv_address:=<esi>, data
    ifnb <data>
        mov     eax,data
    endif
    ifidni <nv_address>, <esi>
        add     esi,nvAddr
        mov     [esi],al
        sub     esi,nvAddr
    else
        mov     esi,nv_address
        add     esi,nvAddr
        mov     [esi],al
    endif
    exitm <>
endm
;
;       REG_RD08 - Reads the value in an NV register into eax
;
;       Parameters: nv_address - Address to read from  (optional)
;       Entry:  esi - Address to read from  (optional)
;       Exit:   al - Value
;       Return: None
;       Uses:   esi (if esi not already loaded with address)
;
REG_RD08 macro nv_address:=<esi>
    ifidni <nv_address>, <esi>
        add     esi,nvAddr
        mov     al,[esi]
        sub     esi,nvAddr
    else
        mov     esi,nv_address
        add     esi,nvAddr
        mov     al,[esi]         
    endif
    exitm <>
endm

;----------------------------------------------------------------------
; hex = 0x00000000
; decimal = 0
; Note: if esi and eax usage is hard to work with, could add push/pop's
;----------------------------------------------------------------------
;
;       BIT(b) - Returns a bit mask with bit 'b' set
;
;       Parameters: b - Bit
;       Entry:  None
;       Exit:   None
;       Return: Mask
;
;#define BIT(b)                  (1<<(b))
BIT macro b
    exitm %(1 SHL b)
endm
;
;       DEVICE_BASE(d) - Returns the base address of a device
;
;       Parameters: d - Device
;       Entry:  None
;       Exit:   None
;       Return: Base address in hex
;
;       Requires that definition of device be hex:hex
;
;#define DEVICE_BASE(d)          (0?d)
DEVICE_BASE macro nv_device
    local pos
    pos = @InStr(1,%nv_device,<:>)
    exitm @CatStr(@SubStr( %nv_device, %pos + 3, %@SizeStr(%nv_device) - pos - 2),<h>)
endm
;
;       DRF_SHIFT(drf) - Returns the least significant bit of a field
;
;       Parameters: drf - Field
;       Entry:  None
;       Exit:   None
;       Return: Bit
;
;       Requires that definition of drf be decimal:decimal
;
;#define DRF_SHIFT(drf)          (0?drf)
DRF_SHIFT macro drf
        local pos
;        echo    DRF_SHIFT
;%       echo    drf
    pos = @InStr(1,%drf,<:>)
;temp3   TEXTEQU %pos
;%       echo    temp3
    exitm @SubStr( %drf, %pos + 1, %@SizeStr(%drf) - pos)
endm
;
;       DRF_MASK(drf) - Returns the bit mask of a field
;
;       Parameters: drf - Field
;       Entry:  None
;       Exit:   None
;       Return: Mask
;
;       Requires that definition of drf be decimal:decimal
;
;#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-(1?drf)+(0?drf)))
DRF_MASK macro drf
    local pos, value1, value0, result
    pos = @InStr(1,%drf,<:>)
;temp3 TEXTEQU %pos
;%   echo temp3
    value1 = @SubStr( %drf, 1, %pos - 1)
    value0 = @SubStr( %drf, %pos + 1, %@SizeStr(%drf) - pos)
;    result TEXTEQU %(0FFFFFFFFh SHR (31 - value1 + value0))
;temp3 TEXTEQU %result
;%   echo temp3
    exitm %(0FFFFFFFFh SHR (31 - value1 + value0))
endm
;
;       DRF_DEF(d,r,f,c) - Returns the value of a constant shifted into a field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   c - Constant
;       Entry:  None
;       Exit:   None
;       Return: Value
;
;#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
DRF_DEF macro d, r, f, c
    local value, shift
;    value = %@CatStr(<NV>, %d, %r, %f, %c)
    value = @CatStr(<NV>, d, r, f, c)
;    shift = %DRF_SHIFT(%@CatStr(<NV>, %d, %r, %f))
    shift = DRF_SHIFT(@CatStr(<NV>, d, r, f))
    exitm %(value SHL shift)
endm
;
;       DRF_NUM(d,r,f,n) - Returns the value of a number shifted into a field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   n - Number
;       Entry:  None
;       Exit:   eax - result, if number is not a constant value
;       Return: Value, if number is a constant value
;
;#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
DRF_NUM macro d, r, f, n
    local value, shift
    value = DRF_MASK(@CatStr(<NV>, d, r, f))
    shift = DRF_SHIFT(@CatStr(<NV>, d, r, f))
    if (((opattr n) AND 4) NE 0)        ; Check for immediate value
        exitm %((n AND value) SHL shift)
    else                                ; Must be non-immediate, move to eax
        ifdifi <n>, <eax>               ; See if its already in eax
                if ((type n) NE 4)      ; Make sure its a dword value
                        .err <Must pass a dword number for n in DRF_NUM>
                else
                        mov     eax, n
                endif
        endif
        and     eax, value
        if (shift gt 0)
            shl     eax, shift
        endif
        exitm <>
    endif
endm
;
;       DRF_VAL(d,r,f,v) - Returns the contents of a field within a value
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   v - Value
;       Entry:  None
;       Exit:   eax - result, if number is not a constant value
;       Return: Value, if number is a constant value
;
;#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
DRF_VAL macro d, r, f, v:=<eax>
    local value, shift
    value = DRF_MASK(@CatStr(<NV>, d, r, f))
    shift = DRF_SHIFT(@CatStr(<NV>, d, r, f))
    if (((opattr v) AND 4) NE 0)        ; Check for immediate value
            exitm %((v SHR shift) AND value)
    else                                ; Must be non-immediate, move to eax
        ifdifi <v>, <eax>               ; See if its already in eax
                if ((type v) NE 4)      ; Make sure its a dword value
                        .err <Must pass a dword number for n in DRF_NUM>
                else
                        mov     eax, v
                endif
        endif
        if (shift gt 0)
            shr     eax, shift
        endif
        and     eax, value
        exitm <>
    endif
endm
;
;       REG_WR_DRF_NUM(d,r,f,n) - Writes a field number into an NV register
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   n - Number
;       Entry:  None
;       Exit:   eax - result, if number is not a constant value
;       Return: Value, if number is a constant value
;       Uses:   esi, eax
;
;#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
REG_WR_DRF_NUM macro d, r, f, n:=<eax>
    mov     esi,@CatStr(<NV>,d,r)
    if (((opattr n) AND 4) NE 0)        ; Check for immediate value
            mov     eax,DRF_NUM(d,r,f,n)
    else                                ; Must be non-immediate, move to eax
        DRF_NUM(d,r,f,n)
    endif
    REG_WR32 esi
    exitm <>
endm
;
;       REG_WR_DRF_DEF(d,r,f,c) - Writes a field constant into an NV register
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   c - Constant
;       Entry:  None
;       Exit:   None
;       Return: None
;       Uses:   esi, eax
;
;#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
REG_WR_DRF_DEF macro d, r, f, c
    mov     esi,@CatStr(<NV>,d,r)
    mov     eax,DRF_DEF(d,r,f,c)
    REG_WR32 esi
    exitm <>
endm
;
;       FLD_WR_DRF_NUM(d,r,f,n) - Writes a number into an NV field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   n - Number
;       Entry:  None
;       Exit:   None
;       Return: None
;       Uses:   esi, eax, ebx
;
;#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
FLD_WR_DRF_NUM macro d, r, f, n:=<eax>
    ifidni  <n>, <eax>                  ; See if its already in eax
        push    eax                     ; Save it on stack
    endif
    mov     esi,@CatStr(<NV>,d,r)
    REG_RD32  esi
    and     eax,NOT (DRF_MASK(@CatStr(<NV>, d, r, f)) SHL DRF_SHIFT(@CatStr(<NV>, d, r, f)))
    
    ifidni  <n>, <eax>                  ; See if its already in eax
        mov     ebx, eax                ; Move read value into ebx
        pop     eax                     ; Restore eax for DRF_NUM function (n=eax)
        DRF_NUM(d,r,f,n)                ; Loads number into eax (same as DRF_NUM(d,r,f,eax))
        or      eax, ebx                ; OR with value read
    elseif (((opattr n) AND 4) NE 0)    ; Check for immediate value
        or     eax,DRF_NUM(d,r,f,n)
    else                                ; Must be non-immediate, move to eax
        push    eax
        DRF_NUM(d,r,f,n)                ; Loads number into eax
        pop     ebx                     ; Pop saved eax into ebx
        or      eax, ebx
    endif
    REG_WR32 esi
    exitm <>
endm
;
;       FLD_WR_DRF_DEF(d,r,f,c) - Writes a constant into an NV field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;                   c - Constant
;       Entry:  None
;       Exit:   None
;       Return: None
;       Uses:   esi, eax
;
;#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
FLD_WR_DRF_DEF macro d, r, f, c
    mov     esi,@CatStr(<NV>,d,r)
    REG_RD32  esi
    and     eax,NOT (DRF_MASK(@CatStr(<NV>, d, r, f)) SHL DRF_SHIFT(@CatStr(<NV>, d, r, f)))
    or      eax,DRF_DEF(d,r,f,c)
    REG_WR32 esi
    exitm <>
endm
;
;       REG_RD_DRF(d,r,f) - Reads the contents of an NV field
;
;       Parameters: d - Device
;                   r - Register
;                   f - Field
;       Entry:  None
;       Exit:   None
;       Return: eax - Field contents
;       Uses:   esi
;
;#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
REG_RD_DRF macro d, r, f
    local shift
    shift = DRF_SHIFT(@CatStr(<NV>, d, r, f))
    mov     esi,@CatStr(<NV>,d,r)
    REG_RD32(esi)
;temp9 TEXTEQU %shift
;%   echo temp9
    if (shift gt 0)
        shr     eax,shift
    endif
    and     eax,DRF_MASK(@CatStr(<NV>, d, r, f))
    exitm <>
endm
; Dumb macro to read PCI Config space.
ReadPCI	macro
  push   eax
  
  mov    dx, 0cf8h
  out    dx, eax
  mov    dx, 0cfch
  in     eax, dx
  mov    edx,eax
  
  pop    eax
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\VBE30.INC ===
;       Copyright (C) 1996-1997 NVidia Corporation
;
;       VBE30.INC - VESA VBE 3.0 constants, structure and data definitions
;
;       Written by:     Mark Stephen Krueger
;       Date:           10/10/96
;
;       $Revision: 1 $
;       $Date: 5/13/97 10:43a $
;       $Logfile: /resman.040/win96/vdd/VBE30.INC $
;       $Log: /resman.040/win96/vdd/VBE30.INC $
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 3     1/23/97 11:02a Markk
; Removed tabs.
; 
; 2     11/19/96 2:03p Markk
; Fixed bug with size of ModeInfoBlock.
; 
; 1     10/16/96 9:16a Markk
; VESA VBE 3.0 definitions for use by the Mini-VDD.
; 
;
VESA_SET_MODE           equ     04F02h
;
VESA_SUCCESS            equ     004Fh        
VESA_NOSUCCESS          equ     014fh        ; Supported function unsuccessful.
;
; VBE_InfoBlock data structure (as defined by VBE 2.0 revision 0.3)
;
VBE_InfoBlock   struc
        VESASignature           db      'VESA'          ; VBE Signature
        VESAVersion             dw      200h            ; VBE Version
        OEMStringPtr            dd      ?               ; Pointer to OEM string
        VBE_Capabilities        db      4 dup (?)       ; Capabilities of graphics
        VBE_ModePtr             dd      ?               ; Pointer to VBE mode list
        VBE_TotalMemory         dw      ?               ; Number of 64K memory blocks
; VBE 2.0 stuff
        VBE_SoftwareRev         dw      ?               ; VBE BIOS Software revision
        VBE_VendorNamePtr       dd      ?               ; Pointer to Vendor Name string
        VBE_ProductNamePtr      dd      ?               ; Pointer to Product Name string
        VBE_ProductRevPtr       dd      ?               ; Pointer to Product Revision string
IFDEF VESA30_REFRESH
        VBE_DotClockPtr         dd      ?               ; Pointer to DotClockList
ENDIF ; VESA30_REFRESH
        Reserved                db      222 dup (?)     ; Reserved
        VBE_OEM_Data            db      256 dup (?)     ; Data Scratch for OEM strings
VBE_InfoBlock   ends
;
VBE_InfoBlock_102       struc   ; Old version of info block structure
        VESASignature_102       db      'VESA'          ; VBE Signature
        VESAVersion_102         dw      102h            ; VBE Version
        OEMStringPtrOff_102     dw      ?               ; Pointer to OEM string (offset)
        OEMStringPtrSeg_102     dw      ?               ; Pointer to OEM string (segment)
        Capabilities_102        dd      ?               ; Capabilities of graphics
        VideoModePtrOff_102     dw      ?               ; Pointer to VBE mode list (offset)
        VideoModePtrSeg_102     dw      ?               ; Pointer to VBE mode list (segment)
        TotalMemory_102         dw      ?               ; Number of 64K memory blocks
VBE_InfoBlock_102       ends
;
; VBE_ModeInfoBlock data structure (as defined by VBE 2.0 revision 0.3)
;
VBE_ModeInfoBlock       struc
; Mandatory (all revisions)
        ModeAttributes          dw      ?       ; Mode attributes
        WinAAttributes          db      ?       ; Window A attributes
        WinBAttributes          db      ?       ; Window B attributes
        WinGranularity          dw      ?       ; Window granularity
        WinSize                 dw      ?       ; Window size
        WinASegment             dw      ?       ; Window A start segment
        WinBSegment             dw      ?       ; Window B start segment
        WinFuncPtr              dd      ?       ; Pointer to window function
        BytesPerScanLine        dw      ?       ; Bytes per scan line
; Mandatory (VBE 1.20 and above)
        XResolution             dw      ?       ; Horizontal resolution
        YResolution             dw      ?       ; Vertical resolution
        XCharSize               db      ?       ; Character cell width
        YCharSize               db      ?       ; Character cell height
        NumberOfPlanes          db      ?       ; Number of memory planes
        BitsPerPixel            db      ?       ; Bits per pixel
        NumberOfBanks           db      ?       ; Number of banks
        MemoryModel             db      ?       ; Memory model type
        BankSize                db      ?       ; Bank size in KB
        NumberOfImagePages      db      ?       ; Number of images
        Reserved1               db      1       ; Reserved for page function
; Direct color fields (required for direct/6 and YUV/7 models)
        RedMaskSize             db      ?       ; Size of direct color red mask in bits
        RedFieldPosition        db      ?       ; Bit position of LSB of red mask
        GreenMaskSize           db      ?       ; Size of direct color green mask in bits
        GreenFieldPosition      db      ?       ; Bit position of LSB of green mask
        BlueMaskSize            db      ?       ; Size of direct color blue mask in bits
        BlueFieldPosition       db      ?       ; Bit position of LSB of blue mask
        ReservedMaskSize        db      ?       ; Size of direct color reserved mask in bits
        ReservedFieldPosition   db      ?       ; Bit position of LSB of reserved mask
        DirectColorModeInfo     db      ?       ; Direct color mode attributes
; Mandatory information (VBE 2.00 and above)
        PhysBasePtr             dd      ?       ; Physical address for flat frame buffer
        OffScreenMemPtr         dd      ?       ; Pointer to start of off-screen memory
        OffScreenMemPtrSize     dw      ?       ; Amount of off-screen memory in 1K units
IFDEF VESA30
; Optional information for VBE 3.0 and above (filled with zeroes if same in linear modes)
        LinBytesPerScanLine     dw      ?       ; Bytes per scan line for linear modes
        BnkNumberOfImagePages   db      ?       ; Number of images for banked modes
        LinNumberOfImagePages   db      ?       ; Number of images for linear modes
        LinRedMaskSize          db      ?       ; Size of direct color red mask (linear modes)
        LinRedFieldPosition     db      ?       ; Bit position of lsb of red mask (linear modes)
        LinGreenMaskSize        db      ?       ; Size of direct color green mask  (linear modes)
        LinGreenFieldPosition   db      ?       ; Bit position of lsb of green mask (linear modes)
        LinBlueMaskSize         db      ?       ; Size of direct color blue mask  (linear modes)
        LinBlueFieldPosition    db      ?       ; Bit position of lsb of blue mask (linear modes)
        LinRsvdMaskSize         db      ?       ; Size of direct color reserved mask (linear modes)
        LinRsvdFieldPosition    db      ?       ; Bit position of lsb of reserved mask (linear modes)
IFDEF VESA30_REFRESH
; Mandatory information (VBE 3.0 and above)
        MaxDotClock             dw      ?       ; Maximum dot clock for graphics mode
        DotClockScaleFactor     dw      ?       ; Dot clock scaling factor for mode
        IntDotClockScaleFactor  dw      ?       ; Interlaced dot clock scaling factor for mode
        Reserved2               db      188 dup (?)
ELSE ; VESA30_REFRESH
        Reserved2               db      194 dup (?)
ENDIF ; VESA30_REFRESH
ELSE ; VESA30
        Reserved2               db      206 dup (?)
ENDIF ; VESA30
VBE_ModeInfoBlock   ends
;
IFDEF VESA30_REFRESH
CRTCInfoBlock           struc
HorizontalTotal                 dw      ?       ; Normalized horizontal total in pixels
HorizontalSyncStart             dw      ?       ; Normalized horizontal sync start in pixels
HorizontalSyncEnd               dw      ?       ; Normalized horizontal sync end in pixels
VerticalTotal                   dw      ?       ; Normalized vertical total in lines
VerticalSyncStart               dw      ?       ; Normalized vertical sync start in lines
VerticalSyncEnd                 dw      ?       ; Normalized vertical sync end in lines
HorizontalSyncPolarity          db      ?       ; Horizontal sync polarity '+' or '-'
VerticalSyncPolarity            db      ?       ; Vertical sync polarity '+' or '-'
Flags                           db      ?       ; 0 for non-interlaced, 1 for interlaced
PhysDotClock                    dw      ?       ; Physical dot clock in KHz * 100 
RefreshRate                     dw      ?       ; Refresh rate in Hz * 100
Reserved                        db      40 dup (?)  ; remainder of ModeInfoBlock
CRTCInfoBlock           ends
ENDIF ; VESA30_REFRESH
;
VBEStateSave    struc
        SeqIndex        db      ?               ; SEQ index
        Miscreg         db      ?               ; Extended misc reg (3C5[11])
        GraIndex        db      ?               ; GDC index
        CRTIndex        db      ?               ; CRTC index
        ATCToggle       db      ?               ; ATC toggle state
        ATCIndex        db      ?               ; ATC index register
        OvrColH         db      ?               ; Overscan Color High (3C0[15])
        BankSelReg      db      ?               ; Bank Select
        LowSeqRegs      db      2 dup (?)       ; SEQ[5..6]
        HighSeqRegs     db      5 dup (?)       ; SEQ[12..16]
        CRTRegs         db      5 dup (?)       ; CRTC[19..1D]
        GDCRegs         db      8 dup (?)       ; GDC[9..10]
        DACMode         db      ?               ; DAC Mode control
        FreqIndex       db      ?               ; Frequency synthesizer index
        FreqRegs        dw      8 dup (?)       ; Frequency synthesizer clock words
        DACAuxCtrl      db      ?               ; DAC auxiliary and power down control
VBEStateSave    ends
;
; Number of 64-byte blocks needed for save/restore state information
;
if ((size VBEStateSave) MOD 64) GT 0
  SVGABLOCKS    equ     (size VBEStateSave)/64 + 1
else
  SVGABLOCKS    equ     (size VBEStateSave)/64
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\VNVRMD.H ===
#ifndef _VNVRMD_H_
#define _VNVRMD_H_
/********* Operating System Interface for NVidia Resource Manager **********\
*                                                                           *
* Module: NVRM.H                                                            *
*       Header file for NVRM defines and service exports.                   *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)  06/21/94 - wrote it                      *
*        Jeff Westerinen (jsw)     05/05/97 - Modified to build under MS    *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//
// Version numbers.
//

#define NVRM_Major_Version  1
#define NVRM_Minor_Version  0

//
// Device IDs.
//

#define NVRM_Device_ID      0x32DC

//
// Init order.
//

//#define NVRM_Init_Order     (VDD_Init_Order - 0x00100000)	// init before VDD  (jsw)
#define NVRM_Init_Order     (VDD_INIT_ORDER - 0x00100000)	// init before VDD

//
// Virtual device services.
//

#define NVRM_Get_Version        0
#define NVRM_Register           1

//
// Prototypes to call NVRM services.
//

typedef DWORD (CDECL *NVRMSYSAPI)(DWORD, DWORD, DWORD, DWORD);

/* (jsw)

DWORD nvrmGetVersion(VOID);
LONG  nvrmRegister(DWORD, NVRMSYSAPI);

#pragma aux nvrmGetVersion =                            \
            CALL_VXD(NVRM_Device_ID, NVRM_Get_Version)  \
            parm caller []                              \
            value no8087 [EAX]                          \
            modify [EAX EBX ECX EDX];

#pragma aux nvrmRegister =                          \
            CALL_VXD(NVRM_Device_ID, NVRM_Register) \
            parm caller []                          \
            value no8087 [EAX]                      \
            modify [EAX EBX ECX EDX];

*/

#endif // _VNVRMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incnv\VNVRMD.INC ===
;********* Operating System Interface for NVidia Resource Manager **********;
;                                                                           ;
; Module: NVRM.INC                                                          ;
;       Header file for NVRM defines and service exports.                   ;
;                                                                           ;
;---------------------------------------------------------------------------;
;                                                                           ;
; History:                                                                  ;
;        David Schmenk (dschmenk)     11/19/93 - wrote it                   ;
;                                                                           ;
;*********************** Copyright 1993 NVidia, Inc. ***********************;

;
; Version numbers.
;

NVRM_Major_Version  EQU     01h
NVRM_Minor_Version  EQU     00h

;
; Device IDs.
;

NVRM_Device_ID      EQU     032DCh

;
; Init order.
;

NVRM_Init_Order     EQU     070000000h

;===========================================================================;
;                                                                           ;
;                     Virtual device services.                              ;
;                                                                           ;
;       The virtual device services are declared here, along with their     ;
;       cod segments.  The service entrypoints are declared with a preceding;
;       underscore, the service is a C based function with stack based      ;
;       parameters.  Otherwise, it is an assembly based function with       ;
;       register based parameters.                                          ;
;                                                                           ;
;===========================================================================;

Begin_Service_Table NVRM
        NVRM_Service    NVRM_Get_Version,   LOCAL
        NVRM_Service    NVRM_Enable_Vga,    LOCAL
        NVRM_Service    NVRM_Fixup_Vga,     LOCAL
        NVRM_Service    NVRM_Enable_Hires,  LOCAL
        NVRM_Service    NVRM_Set_Dpm_Level, LOCAL
        NVRM_Service    NVRM_DDC,           LOCAL
        NVRM_Service    NVRM_ServicePlace,  LOCAL
        NVRM_Service    NVRM_GetAddress,    LOCAL
        NVRM_Service    NVRM_AuNote,        LOCAL
End_Service_Table NVRM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\CMACROS.INC ===
IFNDEF MASM6
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
ELSE  ;MASM6
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
??CM_Paste macro arg1:req, arg2:req
exitm <arg1&arg2>
endm
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
%out e r r o r ----- msg
.err e r r o r ----- msg
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.30 - Copyright (c) Microsoft Corp. 1984-1991>
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small Model>
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = ?PLM
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ??CM_Paste(?,x))
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ??CM_Paste(?,x))
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ??CM_Paste(?,x)
n=n or ??CM_Paste(?,x)
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?pcc
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmH macro n
?pp <n>,<word>,4,2
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
ife ?pcc
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?pcc
n equ (t ptr [bp][+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc macro po
uconcat <n>,,<equ>,,<(t ptr [bp][+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp][-o-2])
.xcref ?t_&n
?t_&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp][-o])
.xcref ?t_&n
?t_&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ??CM_Paste(?,x) eq ??CM_Paste(?,r)
n equ (byte ptr [bp][-o])
??CM_Paste(?t_,n)=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <%??CM_Paste(seg_,x)>,<word ptr>,2,2,1
?aloc <%??CM_Paste(off_,x)>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp][-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ word ptr n[0]
seg_&n equ word ptr n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?ex2
extrn ??CM_Paste(_,x):&d
x equ ??CM_Paste(_,x)
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ??CM_Paste(?CC,x)
.cref
??CM_Paste(?CC,x)=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?lb2
if ?lblpu
public ??CM_Paste(_,x)
endif
??CM_Paste(_,x) label &d
x equ ??CM_Paste(_,x)
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t_&n
.cref
n macro
	push	s
	push	o
endm
?t_&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i macro
?ap <n>
endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t_&n
ife ?t_&n-1
	push	word ptr (n)
exitm
endif
ife ?t_&n-2
	push	n
exitm
endif
ife ?t_&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t_&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t_&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t_&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 macro arg
purge ?PLMParm0
endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
endm
.xcref ?utpe
?utpe macro
??error <unterminated procedure definition: "&n">
endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,(-2)[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
endm
.cref
endm
assumes macro s,ln
ifdef MS_STARTUP
ifidn <code>,<ln>
assume s&:_TEXT
exitm
elseifidn <CODE>,<ln>
assume s&:_TEXT
exitm
elseifidn <data>,<ln>
assume s&:dgroup
exitm
elseifidn <DATA>,<ln>
assume s&:dgroup
exitm
endif
endif
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
ifnb <grp>
grp group n
?cs3 <ln>,<grp>
ln&OFFSET equ <offset grp:>
ln&BASE equ <grp>
else
?cs3 <ln>,<n>
ln&OFFSET equ <offset>
ln&BASE equ <n>
endif
endm
addseg macro grp,seg
.xcref
.xcref grp&_add
.cref
grp&_add macro s
grp&_in <seg>,s
endm
.xcref
.xcref grp&_in
.cref
grp&_in macro sl,s
ifb <s>
grp group sl
else
grp&_add macro ns
grp&_in <sl,s>,ns
endm
endif
endm
endm
defgrp macro grp,ln
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin macro
?cs2 <ln>,<n>
n segment
.xcref
.xcref ?mf
.cref
?mf macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
endm
endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd macro arg
n ends
purge ?mf
purge sEnd
endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes macro s
assume s:&n
endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
ifnb <x>
.errnz (x),<x>
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
callcrt MACRO funcname
ifdef _QC2
call funcname
else
if sizeC
push cs
call near ptr (funcname)
else
call funcname
endif
endif
ENDM
.cref
ENDIF ;MASM6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\CONFIGMG.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

//#ifdef	GOLDEN	
#ifndef	DEBUG
#define	CM_GOLDEN_RETAIL
#endif
//#endif

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"All/None", \
	"Mem     ", \
	"IO      ", \
	"DMA     ", \
	"IRQ     ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0x0003		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share		1			// IRQ can be shared
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_HARDWIRED		0x0000E000
#define	LCPRI_IMPOSSIBLE	0x0000F000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Find_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Global_State, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Reinsert_All, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"Get_Version", \
	"Initialize", \
	"Locate_DevNode", \
	"Get_Parent", \
	"Get_Child", \
	"Get_Sibling", \
	"Get_Device_ID_Size", \
	"Get_Device_ID", \
	"Get_Depth", \
	"Get_Private_DWord", \
	"Set_Private_DWord", \
	"Create_DevNode", \
	"Query_Remove_SubTree", \
	"Remove_SubTree", \
	"Register_Device_Driver", \
	"Register_Enumerator", \
	"Register_Arbitrator", \
	"Deregister_Arbitrator", \
	"Query_Arbitrator_Free_Size", \
	"Query_Arbitrator_Free_Data", \
	"Sort_NodeList", \
	"Yield", \
	"Lock", \
	"Unlock", \
	"Add_Empty_Log_Conf", \
	"Free_Log_Conf", \
	"Get_First_Log_Conf", \
	"Get_Next_Log_Conf", \
	"Add_Res_Des", \
	"Modify_Res_Des", \
	"Free_Res_Des", \
	"Get_Next_Res_Des", \
	"Get_Performance_Info", \
	"Get_Res_Des_Data_Size", \
	"Get_Res_Des_Data", \
	"Process_Events_Now", \
	"Create_Range_List", \
	"Add_Range", \
	"Delete_Range", \
	"Test_Range_Available", \
	"Dup_Range_List", \
	"Free_Range_List", \
	"Invert_Range_List", \
	"Intersect_Range_List", \
	"First_Range", \
	"Next_Range", \
	"Dump_Range_List", \
	"Load_DLVxDs", \
	"Get_DDBs", \
	"Get_CRC_CheckSum", \
	"Register_DevLoader", \
	"Reenumerate_DevNode", \
	"Setup_DevNode", \
	"Reset_Children_Marks", \
	"Get_DevNode_Status", \
	"Remove_Unmarked_Children", \
	"ISAPNP_To_CM", \
	"CallBack_Device_Driver", \
	"CallBack_Enumerator", \
	"Get_Alloc_Log_Conf", \
	"Get_DevNode_Key_Size", \
	"Get_DevNode_Key", \
	"Read_Registry_Value", \
	"Write_Registry_Value", \
	"Disable_DevNode", \
	"Enable_DevNode", \
	"Move_DevNode", \
	"Set_Bus_Info", \
	"Get_Bus_Info", \
	"Set_HW_Prof", \
	"Recompute_HW_Prof", \
	"Query_Change_HW_Prof", \
	"Get_Device_Driver_Private_DWord", \
	"Set_Device_Driver_Private_DWord", \
	"Get_HW_Prof_Flags", \
	"Set_HW_Prof_Flags", \
	"Read_Registry_Log_Confs", \
	"Run_Detection", \
	"Call_At_Appy_Time", \
	"Fail_Change_HW_Prof", \
	"Set_Private_Problem", \
	"Debug_DevNode", \
	"Get_Hardware_Profile_Info", \
	"Register_Enumerator_Function", \
	"Call_Enumerator_Function", \
	"Add_ID", \
	"Find_Range", \
	"Get_Global_State", \
	"Broadcast_Device_Change_Message", \
	"Call_DevNode_Handler", \
	"Remove_Reinsert_All", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			NODELIST;	// Pointer to a nodelist element.
typedef	DWORD			NODELIST_HEADER;// Pointer to a nodelist header.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, NODELIST_HEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040

/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS		0x00000000
#define	CR_DEFAULT		0x00000001
#define	CR_OUT_OF_MEMORY	0x00000002
#define	CR_INVALID_POINTER	0x00000003
#define	CR_INVALID_FLAG		0x00000004
#define	CR_INVALID_DEVNODE	0x00000005
#define	CR_INVALID_RES_DES	0x00000006
#define	CR_INVALID_LOG_CONF	0x00000007
#define	CR_INVALID_ARBITRATOR	0x00000008
#define	CR_INVALID_NODELIST	0x00000009
#define	CR_DEVNODE_HAS_REQS	0x0000000A
#define	CR_INVALID_RESOURCEID	0x0000000B
#define	CR_DLVXD_NOT_FOUND	0x0000000C
#define	CR_NO_SUCH_DEVNODE	0x0000000D
#define	CR_NO_MORE_LOG_CONF	0x0000000E
#define	CR_NO_MORE_RES_DES	0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE	0x00000010
#define	CR_INVALID_RANGE_LIST	0x00000011
#define	CR_INVALID_RANGE	0x00000012
#define	CR_FAILURE		0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV	0x00000014
#define	CR_CREATE_BLOCKED	0x00000015
#define	CR_NOT_SYSTEM_VM	0x00000016
#define	CR_REMOVE_VETOED	0x00000017
#define	CR_APM_VETOED		0x00000018
#define	CR_INVALID_LOAD_TYPE	0x00000019
#define	CR_BUFFER_SMALL		0x0000001A
#define	CR_NO_ARBITRATOR	0x0000001B
#define	CR_NO_REGISTRY_HANDLE	0x0000001C
#define	CR_REGISTRY_ERROR	0x0000001D
#define	CR_INVALID_DEVICE_ID	0x0000001E
#define	CR_INVALID_DATA		0x0000001F
#define	CR_INVALID_API		0x00000020
#define	CR_DEVLOADER_NOT_READY	0x00000021
#define	CR_NEED_RESTART		0x00000022
#define	CR_NO_MORE_HW_PROFILES	0x00000023
#define	CR_DEVICE_NOT_THERE	0x00000024
#define	CR_NO_SUCH_VALUE	0x00000025
#define	CR_WRONG_TYPE		0x00000026
#define	CR_INVALID_PRIORITY	0x00000027
#define	CR_NOT_DISABLEABLE	0x00000028
#define	CR_FREE_RESOURCES	0x00000029
#define	CR_QUERY_VETOED		0x0000002A
#define	CR_CANT_SHARE_IRQ	0x0000002B
#define	NUM_CR_RESULTS		0x0000002C

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_SYSTEM_VM", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_NO_MORE_HW_PROFILES", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_FREE_RESOURCES", \
	"CR_QUERY_VETOED", \
	"CR_CANT_SHARE_IRQ", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_LIAR				0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	CM_PROB_FAILED_INSTALL			0x0000001C
#define	CM_PROB_HARDWARE_DISABLED		0x0000001D
#define	CM_PROB_CANT_SHARE_IRQ			0x0000001E
#define	NUM_CM_PROB				0x0000001F

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"Device failed something not failable", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
	"Failed install", \
	"Hardware Disabled", \
	"Can't share IRQ", \
};

/*XLATON*/

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_VXDLDR			0x00000001
#define	CM_INITIALIZE_BITS			0x00000001

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_BITS			0x00000001

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x00000003

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000001

#define	CM_QUERY_REMOVE_UI_OK			0x00000000
#define	CM_QUERY_REMOVE_UI_NOT_OK		0x00000001
#define	CM_QUERY_REMOVE_BITS			0x00000001

#define	CM_REMOVE_UI_OK				0x00000000
#define	CM_REMOVE_UI_NOT_OK			0x00000001
#define	CM_REMOVE_BITS				0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_WRITE_LOG_CONFS		0x00000002
#define	CM_SETUP_PROP_CHANGE			0x00000003
#define	CM_SETUP_BITS				0x00000003

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_HARDWARE			0x00000002	// Don't ask the driver, and won't be restarteable
#define	CM_DISABLE_BITS				0x00000003	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

#define	CM_BROADCAST_SEND			0x00000000
#define	CM_BROADCAST_QUERY			0x00000001
#define	CM_BROADCAST_BITS			0x00000001

#define	CM_CALL_HANDLER_ENUMERATOR		0x00000000
#define	CM_CALL_HANDLER_DEVICE_DRIVER		0x00000001
#define	CM_CALL_HANDLER_BITS			0x00000001

#define	CM_GLOBAL_STATE_CAN_DO_UI		0x00000001
#define	CM_GLOBAL_STATE_ON_BIG_STACK		0x00000002
#define	CM_GLOBAL_STATE_SERVICES_AVAILABLE	0x00000004
#define	CM_GLOBAL_STATE_SHUTING_DOWN		0x00000008
#define	CM_GLOBAL_STATE_DETECTION_PENDING	0x00000010

#define	CM_REMOVE_REINSERT_ALL_REMOVE		0x00000000
#define	CM_REMOVE_REINSERT_ALL_REINSERT		0x00000001
#define	CM_REMOVE_REINSERT_ALL_BITS		0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 * 
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process. 
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.
#define	CONFIG_PROP_CHANGE	0x00000010	// The property page is exiting.
#define	CONFIG_PRIVATE		0x00000011	// Someone called Call_Handler.
#define	CONFIG_PRESHUTDOWN	0x00000012	// We are shutting down

#define	NUM_CONFIG_COMMANDS	0x00000013	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
	"CONFIG_PROP_CHANGE", \
	"CONFIG_PRIVATE", \
	"CONFIG_PRESHUTDOWN", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

//
// For both CONFIG_REMOVE, CONFIG_PREREMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define	CONFIG_APM_TEST_STANDBY				0x00000000
#define	CONFIG_APM_TEST_SUSPEND				0x00000001
#define	CONFIG_APM_TEST_STANDBY_FAILED			0x00000002
#define	CONFIG_APM_TEST_SUSPEND_FAILED			0x00000003
#define	CONFIG_APM_TEST_STANDBY_SUCCEEDED		0x00000004
#define	CONFIG_APM_TEST_SUSPEND_SUCCEEDED		0x00000005
#define	CONFIG_APM_RESUME_STANDBY			0x00000006
#define	CONFIG_APM_RESUME_SUSPEND			0x00000007
#define	CONFIG_APM_RESUME_CRITICAL			0x00000008
#define	CONFIG_APM_UI_ALLOWED                  		0x80000000

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makles no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC
#define	NUM_ARB_COMMANDS	0x00000007	// Number of arb commands

#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
};

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	cann be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000013	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
};

struct vmmtime_s {
DWORD		vmmtime_lo;
DWORD		vmmtime_hi;
};

typedef	struct vmmtime_s	VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctRegistry;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctReceiveMessage;
CMTIME		ctAppyTime;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	ARB_GLOBAL		0x00000001	// Arbitrator is global.
#define	ARB_LOCAL		0x00000000	// Arbitrator is local.
#define	ARB_SCOPE_BIT		0x00000001	// Arbitrator is global/local bit.

#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	NUM_LOG_CONF		0x00000005	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

#ifndef	Not_VxD

/****************************************************************************
 *
 * Arbitration list structures
 *
 ***************************************************************************/
struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	struct devnode_s	*nl_ItsDevNode;		// The dev node it represent

	// You can add fields to this structure, but the first three
	// fields must NEVER be changed.

	struct Log_Conf 	*nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct	nodelist_s	*nlh_Head;		// First node element
	struct	nodelist_s	*nlh_Tail;		// Last node element
};

struct	arbitfree_s {
	PVOID			*af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};

#endif

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name (OEM format)
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUGBUG(d, id, msg)	message("BUGBUG: "##d##", "##id##": "##msg)

#ifndef	DEBUG

#define	CM_WARN1(strings)
#define	CM_WARN2(strings)
#define	CM_ERROR(strings)

#else

#ifndef	MAXDEBUG

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings)
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#else

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG
#define	CURSEG()		LCODE

#else

#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#pragma warning (disable:4005)			// turn off redefinition

#define	CURSEG()		CCODE

#pragma warning (default:4005)			// turn on redefinition

#endif

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL \
_asm	popfd\

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

/****************************************************************************
 *
 *	CONFIGMG_Get_Entry_Point - Return the address to call to get in
 *				   Config Manager.
 *
 *	Exported.
 *
 *	ENTRY:	None.
 *
 *	EXIT:	None.
 *
 *	On return, the variable CMEntryPoint has been updated with the
 *	proper address to call to get to Configuration Manager.
 *
 ***************************************************************************/
DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (NODELIST_HEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (DEVNODE dnDevnode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))
MAKE_CM_HEADER(Find_Range, (PFARULONG pulStart, ULONG ulStart, ULONG ulLength, ULONG ulAlignment, ULONG ulEnd, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Global_State, (PFARULONG pulState, ULONG ulFlags))
MAKE_CM_HEADER(Broadcast_Device_Change_Message, (ULONG ulwParam, PFARVOID plParam, ULONG ulFlags))
MAKE_CM_HEADER(Call_DevNode_Handler, (DEVNODE dnDevNode, ULONG ulPrivate, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Reinsert_All, (ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\BASEDEF.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/***    BASEDEF.H
 *
 *      Basic constants and types for the VMM and VxDs
 *
 *      NOBASEDEFS turns off the base definations
 */

#ifndef NOBASEDEFS
#define NOBASEDEFS

/*
 *  No warnings generated on non-standard usuage such as double
 *  slash for comments
 */
#pragma warning (disable:4206)
#pragma warning (disable:4214)
#pragma warning (disable:4505)
#pragma warning (disable:4001)

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE	1
#endif
#ifndef NULL
#define NULL    '\0'                    // Null pointer
#endif

#define CDECL   _cdecl
#define PASCAL  _pascal
#define VOID    void
#define CONST   const
#define VOLATILE volatile

typedef int INT;                        // i
typedef unsigned int UINT;              // u
typedef int BOOL;                       // f

typedef unsigned char BYTE;             // b
typedef unsigned short WORD;            // w
typedef unsigned long DWORD;            // dw

#ifndef _H2INC

typedef struct qword_s {                /* qword */
   DWORD qword_lo;
   DWORD qword_hi;
} QWORD;				// qw

#endif 

typedef char CHAR;                      // ch
typedef unsigned char UCHAR;            // uch
typedef short SHORT;                    // s
typedef unsigned short USHORT;          // us
typedef long LONG;                      // l
typedef unsigned long ULONG;            // ul

typedef VOID *PVOID;                    // p
typedef PVOID *PPVOID;                  // pp

typedef INT *PINT;                      // pi
typedef UINT *PUINT;                    // pu
typedef BYTE *PBYTE;                    // pb
typedef WORD *PWORD;                    // pw
typedef DWORD *PDWORD;                  // pdw
typedef CHAR *PCHAR;                    // pch
typedef SHORT *PSHORT;                  // ps
typedef LONG *PLONG;                    // pl
typedef UCHAR *PUCHAR;                  // puch
typedef USHORT *PUSHORT;                // pus
typedef ULONG *PULONG;                  // pul
typedef BOOL *PBOOL;                    // pf

typedef UCHAR SZ[];                     // sz
typedef UCHAR *PSZ;                     // psz
typedef UCHAR SZZ[];                    // szz
typedef UCHAR *PSZZ;                    // pszz

typedef USHORT SEL;                     // sel
typedef SEL *PSEL;                      // psel

typedef ULONG PPHYS;                    // pphys

typedef (*PFN)();                       // pfn
typedef PFN *PPFN;                      // ppfn

typedef PVOID HANDLE;                   // h
typedef HANDLE *PHANDLE;                // ph

typedef ULONG HTIMEOUT;			// timeout handle
typedef ULONG CMS;			// count of milliseconds

#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX

#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))

#endif // NOBASEDEFS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\CONFIGMG.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef _CONFIGMG_H
_CONFIGMG_H	EQU	1
CONFIGMG_VERSION	EQU	0400H
PNPDRVS_Major_Ver	EQU	0004H
PNPDRVS_Minor_Ver	EQU	0000H
ifdef	MAXDEBUG
CM_PERFORMANCE_INFO	EQU	1
endif
ifndef	DEBUG
CM_GOLDEN_RETAIL	EQU	1
endif
ifndef	NORESDES
ResType_All	EQU	00000000H
ResType_None	EQU	00000000H
ResType_Mem	EQU	00000001H
ResType_IO	EQU	00000002H
ResType_DMA	EQU	00000003H
ResType_IRQ	EQU	00000004H
ResType_Max	EQU	00000004H
ResType_Ignored_Bit	EQU	00008000H
DEBUG_RESTYPE_NAMES	EQU	<charCMFAR*lpszResourceName[ResType_Max+1]{"All/None","Mem","IO","DMA","IRQ",}>
MType_Range	EQU	SIZE Mem_Range_s
fMD_MemoryType	EQU	1
fMD_ROM	EQU	0
fMD_RAM	EQU	1
fMD_32_24	EQU	2
fMD_24	EQU	0
fMD_32	EQU	2

Mem_Range_s	STRUC
MR_Align	DD	?
MR_nBytes	DD	?
MR_Min	DD	?
MR_Max	DD	?
MR_Flags	DW	?
MR_Reserved	DW	?
Mem_Range_s	ENDS

Mem_Des_s	STRUC
MD_Count	DW	?
MD_Type	DW	?
MD_Alloc_Base	DD	?
MD_Alloc_End	DD	?
MD_Flags	DW	?
MD_Reserved	DW	?
Mem_Des_s	ENDS
IOType_Range	EQU	SIZE IO_Range_s

IO_Range_s	STRUC
IOR_Align	DW	?
IOR_nPorts	DW	?
IOR_Min	DW	?
IOR_Max	DW	?
IOR_RangeFlags	DW	?
IOR_Alias	DB	?
IOR_Decode	DB	?
IO_Range_s	ENDS

IO_Des_s	STRUC
IOD_Count	DW	?
IOD_Type	DW	?
IOD_Alloc_Base	DW	?
IOD_Alloc_End	DW	?
IOD_DesFlags	DW	?
IOD_Alloc_Alias	DB	?
IOD_Alloc_Decode	DB	?
IO_Des_s	ENDS
IOA_Local	EQU	0ffH
mDD_Width	EQU	0003H
fDD_BYTE	EQU	0
fDD_WORD	EQU	1
fDD_DWORD	EQU	2
szDMA_Des_Flags	EQU	<"WD">

DMA_Des_s	STRUC
DD_Flags	DB	?
DD_Alloc_Chan	DB	?
DD_Req_Mask	DB	?
DD_Reserved	DB	?
DMA_Des_s	ENDS
fIRQD_Share	EQU	1
cIRQ_Des_Flags	EQU	<'S'>

IRQ_Des_s	STRUC
IRQD_Flags	DW	?
IRQD_Alloc_Num	DW	?
IRQD_Req_Mask	DW	?
IRQD_Reserved	DW	?
IRQ_Des_s	ENDS
endif
LCPRI_FORCECONFIG	EQU	00000000H
LCPRI_BOOTCONFIG	EQU	00000001H
LCPRI_DESIRED	EQU	00002000H
LCPRI_NORMAL	EQU	00003000H
LCPRI_LASTBESTCONFIG	EQU	00003FFFH
LCPRI_SUBOPTIMAL	EQU	00005000H
LCPRI_LASTSOFTCONFIG	EQU	00007FFFH
LCPRI_RESTART	EQU	00008000H
LCPRI_REBOOT	EQU	00009000H
LCPRI_POWEROFF	EQU	0000A000H
LCPRI_HARDRECONFIG	EQU	0000C000H
LCPRI_HARDWIRED	EQU	0000E000H
LCPRI_IMPOSSIBLE	EQU	0000F000H
LCPRI_DISABLED	EQU	0000FFFFH
MAX_LCPRI	EQU	0000FFFFH
MAX_MEM_REGISTERS	EQU	9
MAX_IO_PORTS	EQU	20
MAX_IRQS	EQU	7
MAX_DMA_CHANNELS	EQU	7

Config_Buff_s	STRUC
wNumMemWindows	DW	?
dMemBase	DD	MAX_MEM_REGISTERS DUP (?)
dMemLength	DD	MAX_MEM_REGISTERS DUP (?)
wMemAttrib	DW	MAX_MEM_REGISTERS DUP (?)
wNumIOPorts	DW	?
wIOPortBase	DW	MAX_IO_PORTS DUP (?)
wIOPortLength	DW	MAX_IO_PORTS DUP (?)
wNumIRQs	DW	?
bIRQRegisters	DB	MAX_IRQS DUP (?)
bIRQAttrib	DB	MAX_IRQS DUP (?)
wNumDMAs	DW	?
bDMALst	DB	MAX_DMA_CHANNELS DUP (?)
wDMAAttrib	DW	MAX_DMA_CHANNELS DUP (?)
bReserved1	DB	3 DUP (?)
Config_Buff_s	ENDS
ifndef	CMJUSTRESDES
MAX_DEVICE_ID_LEN	EQU	200
INCLUDE vmmreg.INC
Begin_Service_Table CONFIGMG, VxD
CONFIGMG_Service	 _CONFIGMG_Get_Version, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Initialize, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Locate_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Parent, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Child, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Sibling, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Device_ID_Size, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Device_ID, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Depth, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Private_DWord, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_Private_DWord, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Create_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Query_Remove_SubTree, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Remove_SubTree, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_Device_Driver, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_Enumerator, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_Arbitrator, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Deregister_Arbitrator, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Sort_NodeList, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Yield, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Lock, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Unlock, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Add_Empty_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Free_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_First_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Next_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Add_Res_Des, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Modify_Res_Des, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Free_Res_Des, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Next_Res_Des, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Performance_Info, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Res_Des_Data, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Process_Events_Now, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Create_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Add_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Delete_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Test_Range_Available, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Dup_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Free_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Invert_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Intersect_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_First_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Next_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Dump_Range_List, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Load_DLVxDs, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_DDBs, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_CRC_CheckSum, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_DevLoader, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Reenumerate_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Setup_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Reset_Children_Marks, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_DevNode_Status, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Remove_Unmarked_Children, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_ISAPNP_To_CM, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_CallBack_Device_Driver, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_CallBack_Enumerator, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_DevNode_Key_Size, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_DevNode_Key, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Read_Registry_Value, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Write_Registry_Value, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Disable_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Enable_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Move_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_Bus_Info, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Bus_Info, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_HW_Prof, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Recompute_HW_Prof, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Query_Change_HW_Prof, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_HW_Prof_Flags, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_HW_Prof_Flags, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Read_Registry_Log_Confs, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Run_Detection, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Call_At_Appy_Time, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Fail_Change_HW_Prof, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Set_Private_Problem, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Debug_DevNode, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Register_Enumerator_Function, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Call_Enumerator_Function, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Add_ID, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Find_Range, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Get_Global_State, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Call_DevNode_Handler, VxD_CODE
CONFIGMG_Service	 _CONFIGMG_Remove_Reinsert_All, VxD_CODE
End_Service_Table CONFIGMG, VxD
BusType_None	EQU	00000000H
BusType_ISA	EQU	00000001H
BusType_EISA	EQU	00000002H
BusType_PCI	EQU	00000004H
BusType_PCMCIA	EQU	00000008H
BusType_ISAPNP	EQU	00000010H
BusType_MCA	EQU	00000020H
BusType_BIOS	EQU	00000040H
CR_SUCCESS	EQU	00000000H
CR_DEFAULT	EQU	00000001H
CR_OUT_OF_MEMORY	EQU	00000002H
CR_INVALID_POINTER	EQU	00000003H
CR_INVALID_FLAG	EQU	00000004H
CR_INVALID_DEVNODE	EQU	00000005H
CR_INVALID_RES_DES	EQU	00000006H
CR_INVALID_LOG_CONF	EQU	00000007H
CR_INVALID_ARBITRATOR	EQU	00000008H
CR_INVALID_NODELIST	EQU	00000009H
CR_DEVNODE_HAS_REQS	EQU	0000000AH
CR_INVALID_RESOURCEID	EQU	0000000BH
CR_DLVXD_NOT_FOUND	EQU	0000000CH
CR_NO_SUCH_DEVNODE	EQU	0000000DH
CR_NO_MORE_LOG_CONF	EQU	0000000EH
CR_NO_MORE_RES_DES	EQU	0000000FH
CR_ALREADY_SUCH_DEVNODE	EQU	00000010H
CR_INVALID_RANGE_LIST	EQU	00000011H
CR_INVALID_RANGE	EQU	00000012H
CR_FAILURE	EQU	00000013H
CR_NO_SUCH_LOGICAL_DEV	EQU	00000014H
CR_CREATE_BLOCKED	EQU	00000015H
CR_NOT_SYSTEM_VM	EQU	00000016H
CR_REMOVE_VETOED	EQU	00000017H
CR_APM_VETOED	EQU	00000018H
CR_INVALID_LOAD_TYPE	EQU	00000019H
CR_BUFFER_SMALL	EQU	0000001AH
CR_NO_ARBITRATOR	EQU	0000001BH
CR_NO_REGISTRY_HANDLE	EQU	0000001CH
CR_REGISTRY_ERROR	EQU	0000001DH
CR_INVALID_DEVICE_ID	EQU	0000001EH
CR_INVALID_DATA	EQU	0000001FH
CR_INVALID_API	EQU	00000020H
CR_DEVLOADER_NOT_READY	EQU	00000021H
CR_NEED_RESTART	EQU	00000022H
CR_NO_MORE_HW_PROFILES	EQU	00000023H
CR_DEVICE_NOT_THERE	EQU	00000024H
CR_NO_SUCH_VALUE	EQU	00000025H
CR_WRONG_TYPE	EQU	00000026H
CR_INVALID_PRIORITY	EQU	00000027H
CR_NOT_DISABLEABLE	EQU	00000028H
CR_FREE_RESOURCES	EQU	00000029H
CR_QUERY_VETOED	EQU	0000002AH
CR_CANT_SHARE_IRQ	EQU	0000002BH
NUM_CR_RESULTS	EQU	0000002CH
CM_PROB_NOT_CONFIGURED	EQU	00000001H
CM_PROB_DEVLOADER_FAILED	EQU	00000002H
CM_PROB_OUT_OF_MEMORY	EQU	00000003H
CM_PROB_ENTRY_IS_WRONG_TYPE	EQU	00000004H
CM_PROB_LACKED_ARBITRATOR	EQU	00000005H
CM_PROB_BOOT_CONFIG_CONFLICT	EQU	00000006H
CM_PROB_FAILED_FILTER	EQU	00000007H
CM_PROB_DEVLOADER_NOT_FOUND	EQU	00000008H
CM_PROB_INVALID_DATA	EQU	00000009H
CM_PROB_FAILED_START	EQU	0000000AH
CM_PROB_LIAR	EQU	0000000BH
CM_PROB_NORMAL_CONFLICT	EQU	0000000CH
CM_PROB_NOT_VERIFIED	EQU	0000000DH
CM_PROB_NEED_RESTART	EQU	0000000EH
CM_PROB_REENUMERATION	EQU	0000000FH
CM_PROB_PARTIAL_LOG_CONF	EQU	00000010H
CM_PROB_UNKNOWN_RESOURCE	EQU	00000011H
CM_PROB_REINSTALL	EQU	00000012H
CM_PROB_REGISTRY	EQU	00000013H
CM_PROB_VXDLDR	EQU	00000014H
CM_PROB_WILL_BE_REMOVED	EQU	00000015H
CM_PROB_DISABLED	EQU	00000016H
CM_PROB_DEVLOADER_NOT_READY	EQU	00000017H
CM_PROB_DEVICE_NOT_THERE	EQU	00000018H
CM_PROB_MOVED	EQU	00000019H
CM_PROB_TOO_EARLY	EQU	0000001AH
CM_PROB_NO_VALID_LOG_CONF	EQU	0000001BH
CM_PROB_FAILED_INSTALL	EQU	0000001CH
CM_PROB_HARDWARE_DISABLED	EQU	0000001DH
CM_PROB_CANT_SHARE_IRQ	EQU	0000001EH
NUM_CM_PROB	EQU	0000001FH
CM_INITIALIZE_VMM	EQU	00000000H
CM_INITIALIZE_VXDLDR	EQU	00000001H
CM_INITIALIZE_BITS	EQU	00000001H
CM_YIELD_NO_RESUME_EXEC	EQU	00000000H
CM_YIELD_RESUME_EXEC	EQU	00000001H
CM_YIELD_BITS	EQU	00000001H
CM_CREATE_DEVNODE_NORMAL	EQU	00000000H
CM_CREATE_DEVNODE_NO_WAIT_INSTALL	EQU	00000001H
CM_CREATE_DEVNODE_BITS	EQU	00000001H
CM_REGISTER_DEVICE_DRIVER_STATIC	EQU	00000000H
CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	EQU	00000001H
CM_REGISTER_DEVICE_DRIVER_REMOVABLE	EQU	00000002H
CM_REGISTER_DEVICE_DRIVER_BITS	EQU	00000003H
CM_REGISTER_ENUMERATOR_SOFTWARE	EQU	00000000H
CM_REGISTER_ENUMERATOR_HARDWARE	EQU	00000001H
CM_REGISTER_ENUMERATOR_BITS	EQU	00000001H
CM_QUERY_REMOVE_UI_OK	EQU	00000000H
CM_QUERY_REMOVE_UI_NOT_OK	EQU	00000001H
CM_QUERY_REMOVE_BITS	EQU	00000001H
CM_REMOVE_UI_OK	EQU	00000000H
CM_REMOVE_UI_NOT_OK	EQU	00000001H
CM_REMOVE_BITS	EQU	00000001H
CM_SETUP_DEVNODE_READY	EQU	00000000H
CM_SETUP_DOWNLOAD	EQU	00000001H
CM_SETUP_WRITE_LOG_CONFS	EQU	00000002H
CM_SETUP_PROP_CHANGE	EQU	00000003H
CM_SETUP_BITS	EQU	00000003H
CM_ADD_RANGE_ADDIFCONFLICT	EQU	00000000H
CM_ADD_RANGE_DONOTADDIFCONFLICT	EQU	00000001H
CM_ADD_RANGE_BITS	EQU	00000001H
CM_ISAPNP_ADD_RES_DES	EQU	00000000H
CM_ISAPNP_SETUP	EQU	00000001H
CM_ISAPNP_ADD_BOOT_RES_DES	EQU	00000002H
CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	EQU	00000003H
CM_ISAPNP_BITS	EQU	00000003H
CM_GET_PERFORMANCE_INFO_DATA	EQU	00000000H
CM_GET_PERFORMANCE_INFO_RESET	EQU	00000001H
CM_GET_PERFORMANCE_INFO_START	EQU	00000002H
CM_GET_PERFORMANCE_INFO_STOP	EQU	00000003H
CM_RESET_HIT_DATA	EQU	00000004H
CM_GET_HIT_DATA	EQU	00000005H
CM_GET_PERFORMANCE_INFO_BITS	EQU	0000000FH
CM_HIT_DATA_FILES	EQU	0FFFF0000H
CM_HIT_DATA_SIZE	EQU	((256*8)+8)
CM_GET_ALLOC_LOG_CONF_ALLOC	EQU	00000000H
CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	EQU	00000001H
CM_GET_ALLOC_LOG_CONF_BITS	EQU	00000001H
CM_REGISTRY_HARDWARE	EQU	00000000H
CM_REGISTRY_SOFTWARE	EQU	00000001H
CM_REGISTRY_USER	EQU	00000100H
CM_REGISTRY_CONFIG	EQU	00000200H
CM_REGISTRY_BITS	EQU	00000301H
CM_DISABLE_POLITE	EQU	00000000H
CM_DISABLE_ABSOLUTE	EQU	00000001H
CM_DISABLE_HARDWARE	EQU	00000002H
CM_DISABLE_BITS	EQU	00000003H
CM_HW_PROF_UNDOCK	EQU	00000000H
CM_HW_PROF_DOCK	EQU	00000001H
CM_HW_PROF_RECOMPUTE_BITS	EQU	00000001H
CM_HW_PROF_DOCK_KNOWN	EQU	00000002H
CM_HW_PROF_QUERY_CHANGE_BITS	EQU	00000003H
CM_DETECT_NEW_PROFILE	EQU	00000001H
CM_DETECT_CRASHED	EQU	00000002H
CM_DETECT_HWPROF_FIRST_BOOT	EQU	00000004H
CM_DETECT_RUN	EQU	80000000H
CM_ADD_ID_HARDWARE	EQU	00000000H
CM_ADD_ID_COMPATIBLE	EQU	00000001H
CM_ADD_ID_BITS	EQU	00000001H
CM_REENUMERATE_NORMAL	EQU	00000000H
CM_REENUMERATE_SYNCHRONOUS	EQU	00000001H
CM_REENUMERATE_BITS	EQU	00000001H
CM_BROADCAST_SEND	EQU	00000000H
CM_BROADCAST_QUERY	EQU	00000001H
CM_BROADCAST_BITS	EQU	00000001H
CM_CALL_HANDLER_ENUMERATOR	EQU	00000000H
CM_CALL_HANDLER_DEVICE_DRIVER	EQU	00000001H
CM_CALL_HANDLER_BITS	EQU	00000001H
CM_GLOBAL_STATE_CAN_DO_UI	EQU	00000001H
CM_GLOBAL_STATE_ON_BIG_STACK	EQU	00000002H
CM_GLOBAL_STATE_SERVICES_AVAILABLE	EQU	00000004H
CM_GLOBAL_STATE_SHUTING_DOWN	EQU	00000008H
CM_GLOBAL_STATE_DETECTION_PENDING	EQU	00000010H
CM_REMOVE_REINSERT_ALL_REMOVE	EQU	00000000H
CM_REMOVE_REINSERT_ALL_REINSERT	EQU	00000001H
CM_REMOVE_REINSERT_ALL_BITS	EQU	00000001H
CONFIG_FILTER	EQU	00000000H
CONFIG_START	EQU	00000001H
CONFIG_STOP	EQU	00000002H
CONFIG_TEST	EQU	00000003H
CONFIG_REMOVE	EQU	00000004H
CONFIG_ENUMERATE	EQU	00000005H
CONFIG_SETUP	EQU	00000006H
CONFIG_CALLBACK	EQU	00000007H
CONFIG_APM	EQU	00000008H
CONFIG_TEST_FAILED	EQU	00000009H
CONFIG_TEST_SUCCEEDED	EQU	0000000AH
CONFIG_VERIFY_DEVICE	EQU	0000000BH
CONFIG_PREREMOVE	EQU	0000000CH
CONFIG_SHUTDOWN	EQU	0000000DH
CONFIG_PREREMOVE2	EQU	0000000EH
CONFIG_READY	EQU	0000000FH
CONFIG_PROP_CHANGE	EQU	00000010H
CONFIG_PRIVATE	EQU	00000011H
CONFIG_PRESHUTDOWN	EQU	00000012H
NUM_CONFIG_COMMANDS	EQU	00000013H
CONFIG_START_DYNAMIC_START	EQU	00000000H
CONFIG_START_FIRST_START	EQU	00000001H
CONFIG_STOP_DYNAMIC_STOP	EQU	00000000H
CONFIG_STOP_HAS_PROBLEM	EQU	00000001H
CONFIG_REMOVE_DYNAMIC	EQU	00000000H
CONFIG_REMOVE_SHUTDOWN	EQU	00000001H
CONFIG_REMOVE_REBOOT	EQU	00000002H
CONFIG_TEST_CAN_STOP	EQU	00000000H
CONFIG_TEST_CAN_REMOVE	EQU	00000001H
CONFIG_APM_TEST_STANDBY	EQU	00000000H
CONFIG_APM_TEST_SUSPEND	EQU	00000001H
CONFIG_APM_TEST_STANDBY_FAILED	EQU	00000002H
CONFIG_APM_TEST_SUSPEND_FAILED	EQU	00000003H
CONFIG_APM_TEST_STANDBY_SUCCEEDED	EQU	00000004H
CONFIG_APM_TEST_SUSPEND_SUCCEEDED	EQU	00000005H
CONFIG_APM_RESUME_STANDBY	EQU	00000006H
CONFIG_APM_RESUME_SUSPEND	EQU	00000007H
CONFIG_APM_RESUME_CRITICAL	EQU	00000008H
CONFIG_APM_UI_ALLOWED	EQU	80000000H
ARB_TEST_ALLOC	EQU	00000000H
ARB_RETEST_ALLOC	EQU	00000001H
ARB_SET_ALLOC	EQU	00000002H
ARB_RELEASE_ALLOC	EQU	00000003H
ARB_QUERY_FREE	EQU	00000004H
ARB_REMOVE	EQU	00000005H
ARB_FORCE_ALLOC	EQU	00000006H
NUM_ARB_COMMANDS	EQU	00000007H
DEBUG_ARB_NAMES	EQU	<charCMFAR*lpszArbFuncName[NUM_ARB_COMMANDS]{"ARB_TEST_ALLOC","ARB_RETEST_ALLOC","ARB_SET_ALLOC","ARB_RELEASE_ALLOC","ARB_QUERY_FREE","ARB_REMOVE","ARB_FORCE_ALLOC",}>
DN_ROOT_ENUMERATED	EQU	00000001H
DN_DRIVER_LOADED	EQU	00000002H
DN_ENUM_LOADED	EQU	00000004H
DN_STARTED	EQU	00000008H
DN_MANUAL	EQU	00000010H
DN_NEED_TO_ENUM	EQU	00000020H
DN_NOT_FIRST_TIME	EQU	00000040H
DN_HARDWARE_ENUM	EQU	00000080H
DN_LIAR	EQU	00000100H
DN_HAS_MARK	EQU	00000200H
DN_HAS_PROBLEM	EQU	00000400H
DN_FILTERED	EQU	00000800H
DN_MOVED	EQU	00001000H
DN_DISABLEABLE	EQU	00002000H
DN_REMOVABLE	EQU	00004000H
DN_PRIVATE_PROBLEM	EQU	00008000H
DN_MF_PARENT	EQU	00010000H
DN_MF_CHILD	EQU	00020000H
DN_WILL_BE_REMOVED	EQU	00040000H
DLVXD_LOAD_ENUMERATOR	EQU	00000000H
DLVXD_LOAD_DEVLOADER	EQU	00000001H
DLVXD_LOAD_DRIVER	EQU	00000002H
NUM_DLVXD_LOAD_TYPE	EQU	00000003H
ARB_GLOBAL	EQU	00000001H
ARB_LOCAL	EQU	00000000H
ARB_SCOPE_BIT	EQU	00000001H
BASIC_LOG_CONF	EQU	00000000H
FILTERED_LOG_CONF	EQU	00000001H
ALLOC_LOG_CONF	EQU	00000002H
BOOT_LOG_CONF	EQU	00000003H
FORCED_LOG_CONF	EQU	00000004H
NUM_LOG_CONF	EQU	00000005H
LOG_CONF_BITS	EQU	00000007H
DEBUG_LOG_CONF_NAMES	EQU	<charCMFAR*lpszLogConfName[NUM_LOG_CONF]{"BASIC_LOG_CONF","FILTERED_LOG_CONF","ALLOC_LOG_CONF","BOOT_LOG_CONF","FORCED_LOG_CONF",}>
PRIORITY_EQUAL_FIRST	EQU	00000008H
PRIORITY_EQUAL_LAST	EQU	00000000H
PRIORITY_BIT	EQU	00000008H
ifndef	Not_VxD

nodelist_s	STRUC
nl_Next	DD	?
nl_Previous	DD	?
nl_ItsDevNode	DD	?
nl_Test_Req	DD	?
nl_ulSortDWord	DD	?
nodelist_s	ENDS

nodelistheader_s	STRUC
nlh_Head	DD	?
nlh_Tail	DD	?
nodelistheader_s	ENDS

arbitfree_s	STRUC
af_PointerToInfo	DD	?
af_SizeOfInfo	DD	?
arbitfree_s	ENDS
endif

MEM_Arb_s	STRUC
MEMA_Alloc	DD	?
MEM_Arb_s	ENDS

IO_Arb_s	STRUC
IOA_Alloc	DD	?
IO_Arb_s	ENDS

DMA_Arb_s	STRUC
DMAA_Alloc	DW	?
DMA_Arb_s	ENDS

IRQ_Arb_s	STRUC
IRQA_Alloc	DW	?
IRQA_Share	DW	?
IRQA_Share_Count	DB	16 DUP (?)
IRQ_Arb_s	ENDS
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF


CM_API_s	STRUC
pCMAPIStack	DD	?
dwCMAPIService	DD	?
dwCMAPIRet	DD	?
CM_API_s	ENDS
ifndef	MAX_PROFILE_LEN
MAX_PROFILE_LEN	EQU	80
endif

HWProfileInfo_s	STRUC
HWPI_ulHWProfile	DD	?
HWPI_szFriendlyName	DB	MAX_PROFILE_LEN DUP (?)
HWPI_dwFlags	DD	?
HWProfileInfo_s	ENDS
CM_HWPI_NOT_DOCKABLE	EQU	00000000H
CM_HWPI_UNDOCKED	EQU	00000001H
CM_HWPI_DOCKED	EQU	00000002H
endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\DEBUG.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

NOBUGBUG	EQU	1










BUGBUG	macro	d, id, note
endm





























IsDebugOnlyLoaded	macro	lab
	local	var, magic
_DBOSTART segment
var	label	byte
_DBOSTART ends
	db	0F7h, 05h
	dd	OFFSET32 magic
magic	dd	OFFSET32 var - (MAXSYSTEMLADDR + 1)
ifnb <lab>
	jz	lab
endif
	endm










DPublic MACRO	arg
if DEBLEVEL GT DEBLEVELRETAIL
	public	arg
endif
        ENDM















Assumes_Fall_Through MACRO L
ifndef MASM6
IF2
 IFDEF profileall
  IF (?prolog_&L - $) GT 3
  %OUT ERROR:  Fall through to &L invalid
  .ERR
  ENDIF
 ELSE
  IF (L - $) GT 3
  %OUT ERROR:  Fall through to &L invalid
  .ERR
  ENDIF
 ENDIF
ENDIF
else
 IFDEF profileall
.errnz ((?prolog_&L - $) GT 3), <ERROR: Fall through to &L invalid>
 ELSE
.errnz ((L - $) GT 3), <ERROR: Fall through to &L invalid>
 ENDIF
endif

     ENDM


ifndef Not_VxD





























??avh_parse_one_arg macro arg
    ifidni <arg>, <USES_FLAGS>
	??_fUsesFlagsPushfd equ <>
	??_fUsesFlagsPopfd equ <>
    elseifnb <arg>
	??_debLevel = arg
    endif
endm

??avh_parse_args macro DL, fUSES_FLAGS
	??_fUsesFlagsPushfd equ <pushfd>
	??_fUsesFlagsPopfd equ <popfd>
	??_debLevel = DEBLEVELNORMAL
	??avh_parse_one_arg <DL>
	??avh_parse_one_arg <fUSES_FLAGS>
endm

Assert_VM_Handle MACRO R, DL, fUSES_FLAGS
	LOCAL l1

IF DEBLEVEL GT DEBLEVELRETAIL

	??avh_parse_args <DL>, <fUSES_FLAGS>

IF DEBLEVEL GE ??_debLevel

IFNDEF WIN31COMPAT
IF DEBLEVEL LT DEBLEVELMAX
	??_fUsesFlagsPushfd
	cmp	[R].CB_Signature, VMCB_ID
	je	SHORT l1
ENDIF
ENDIF

IFDIFI <ebx>,<R>
	push	ebx
	mov	ebx, R
ENDIF
	VMMCall	Debug_Test_Valid_Handle
IFDIFI <ebx>, <R>
	pop	ebx
ENDIF

IFNDEF WIN31COMPAT
IF DEBLEVEL LT DEBLEVELMAX
l1:
	??_fUsesFlagsPopfd
ENDIF
ENDIF

ENDIF

ENDIF
	ENDM




























Assert_Thread_Handle MACRO R, DL, fUSES_FLAGS
	LOCAL l1

IF DEBLEVEL GT DEBLEVELRETAIL

	??avh_parse_args <DL>, <fUSES_FLAGS>

IF DEBLEVEL GE ??_debLevel

IF DEBLEVEL LT DEBLEVELMAX
	??_fUsesFlagsPushfd
	cmp	dword ptr [R.TCB_Signature], SCHED_OBJ_ID_THREAD
	je	SHORT l1
ENDIF

IFDIFI <edi>,<R>
        push    edi
        mov     edi, R
ENDIF
        VMMCall Debug_Test_Valid_Thread_Handle
IFDIFI <edi>,<R>
        pop     edi
ENDIF

IF DEBLEVEL LT DEBLEVELMAX
l1:
	??_fUsesFlagsPopfd
ENDIF

ENDIF

ENDIF
	ENDM

















Assert_Cur_Thread_Handle MACRO R, DL
	LOCAL myDebLevel
	LOCAL	OK

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel EQU DEBLEVELNORMAL
ELSE
	myDebLevel EQU <DL>
ENDIF

IF DEBLEVEL GE myDebLevel

IFDIFI <edi>,<R>
        push    edi
        mov     edi, R
ENDIF
        VMMCall Debug_Test_Cur_Thread
IFDIFI <edi>,<R>
        pop     edi
ENDIF

ENDIF

ENDIF
	ENDM













Debug_Printf	macro	fmt, args, dl
	local	fmtlab, myDebLevel

ife ?_DBOCODE
    ??_fDoit = VMM_TRUE
else
    ??_fDoit = FALSE
endif

if DEBLEVEL GT DEBLEVELRETAIL

ifb <dl>
	myDebLevel EQU <DEBLEVELNORMAL>
else
	myDebLevel EQU <dl>
endif

if DEBLEVEL GE myDebLevel
    ??_fDoit = VMM_TRUE
endif

endif

if ??_fDoit

ife ?_DBOCODE

VxD_DEBUG_ONLY_DATA_SEG
fmtlab	db	fmt, 0
VxD_DEBUG_ONLY_DATA_ENDS

else

ifdef VMMSYS

VMM_LOCKED_DATA_SEG
fmtlab	db	fmt, 0
VMM_LOCKED_DATA_ENDS

else

VxD_LOCKED_DATA_SEG
fmtlab	db	fmt, 0
VxD_LOCKED_DATA_ENDS

endif

endif

	ifb <args>
	VMMCall _Debug_Printf_Service, <(OFFSET32 fmtlab), esp>
	else
	VMMCall _Debug_Printf_Service, <(OFFSET32 fmtlab), esp, args>
	endif

endif

	endm







CHECK_EOL MACRO f, x, ln
	ifdifi <x>,<noeol>
	ifdifi <x>,<no_eol>
	ifdifi <x>,<nocrlf>
	ifdifi <x>,</noeol>
		%OUT Line ln: Unknown symbol (x) in f, taken as NOEOL
	endif
	endif
	endif
	endif

ENDM

??_Gen_String macro lbl:req, str:req
	ife ?_ICODE
	    ??_segName textequ <_IDATA>
	elseife ?_PCODE
	    ??_segName textequ <_PDATA>
	elseife ?_SCODE
	    ??_segName textequ <_SDATA>
	elseife ?_DBOCODE
	    ??_segName textequ <_DBODATA>
	else
	    ??_segName textequ <_LDATA>
	endif

	??_segName segment
	    lbl	db	str
	    ife ??_nocrlf
		db	0dh,0ah
	    endif
		db	0
	??_segName ends
endm


??Trace_Debug_Helper macro typ, str, arg1, arg2
	local	string

    ife ?_DBOCODE
	??_fDoit = VMM_TRUE
    else
	??_fDoit = 0
    endif

    if (DEBLEVEL GT DEBLEVELRETAIL) OR ??_fDoit

	??_nocrlf = 0
	??_debLevel = DEBLEVELNORMAL

	irp x, <arg1, arg2>
	    ifnb <x>
		if ((.TYPE x) AND 20h) GT 0
		    ??_debLevel = x
		else
		    Check_EOL <typ>, <x>, %(@Line)
		    ??_nocrlf = 1
		endif
	    endif
	endm

	if DEBLEVEL GE ??_debLevel
	    ??_fDoit = VMM_TRUE
	endif

    endif

    if ??_fDoit

	irpc c, str
	    ifidn <c>, <">
		??_is_string = 1
	    else
	    ifidni <c>, <'>
		??_is_string = 1
	    else
		??_is_string = 0
	    endif
	    endif
	    exitm
	endm

	if ??_is_string
	    ??_Gen_String string, <str>
	    ??_debug_out_str textequ <OFFSET32 string>
	else
	    ??_debug_out_str textequ <str>
	endif

	ifdef WIN31COMPAT
		pushfd
		pushad
		mov	esi, ??_debug_out_str
		VMMCall Out_Debug_String
	    ifidni <typ>, <Debug_Out>
		VMMCall Test_Debug_Installed
		jz	SHORT $+4
		int	1
	    endif
		popad
		popfd
	else
		push	??_debug_out_str
	    ifidni <typ>, <Debug_Out>
		VMMCall _Debug_Out_Service
	    else
		VMMCall _Trace_Out_Service
	    endif
	endif

    endif

	endm
















irp     cond,<S,C,A,AE,B,BE,E,Z,G,GE,L,LE,O>

Trace_Out&cond macro str, arg1, arg2
	?trace_out <str>,jn&cond, <arg1>, <arg2>
	endm

Trace_OutN&cond macro str, arg1, arg2
	?trace_out <str>,j&cond, <arg1>, <arg2>
	endm

endm

Trace_Out MACRO str, arg1, arg2
	??Trace_Debug_Helper <Trace_Out>, <str>, <arg1>, <arg2>
endm

Trace_OutECXZ   macro str, arg1, arg2
	local	l1,l2
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	jecxz	l1
	jmp	short l2
l1:	Trace_Out <str>, <arg1>, <arg2>
l2:
endif
	endm

Trace_OutECXNZ macro str, arg1, arg2
	?trace_out <str>,jecxz, <arg1>, <arg2>
	endm

Trace_OutEAXz macro str, arg1, arg2
	local	l1
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	or	eax,eax
	jnz	short l1
	Trace_Out <str>, <arg1>, <arg2>
l1:
endif
	endm

Trace_OutEAXnz macro str, arg1, arg2
	local	l1
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	or	eax,eax
	jz	short l1
	Trace_Out <str>, <arg1>, <arg2>
l1:
endif
	endm

?trace_out macro str, jmpop, arg1, arg2
	Local	nomsg
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	jmpop	short nomsg
	Trace_Out <str>,<arg1>,<arg2>
nomsg:
endif
	endm


















irp	cond,<S,C,A,AE,B,BE,E,Z,G,GE,L,LE,O>

Debug_Out&cond &macro str, arg1
	?debug_out <str>,jn&cond,<arg1>
	&endm

Debug_OutN&cond &macro str, arg1
	?debug_out <str>,j&cond,<arg1>
	&endm

endm

Debug_Out MACRO str, arg1, arg2
	??Trace_Debug_Helper <Debug_Out>, <str>, <arg1>, <arg2>
endm

Debug_OutECXZ	macro str, arg1
	local	l1,l2
if DEBLEVEL GT DEBLEVELRETAIL
	jecxz	l1
	jmp	short l2
l1:	Debug_Out <str>, <arg1>
l2:
endif
	endm

Debug_OutECXNZ macro str, arg1
	?debug_out <str>,jecxz, <arg1>
	endm

Debug_OutEAXz macro str, arg1
	local	l1
if DEBLEVEL GT DEBLEVELRETAIL
	or	eax,eax
	jnz	short l1
	Debug_Out <str>, <arg1>
l1:
endif
	endm

Debug_OutEAXnz macro str, arg1
	local	l1
if DEBLEVEL GT DEBLEVELRETAIL
	or	eax,eax
	jz	short l1
	Debug_Out <str>, <arg1>
l1:
endif
	endm

?debug_out macro str,jmpop, arg1
	Local	nomsg
if DEBLEVEL GT DEBLEVELRETAIL
	jmpop	short nomsg
	Debug_Out <str>, <arg1>
nomsg:
endif
	endm








Queue_Out MACRO S, V1, V2, DL
	LOCAL	Str_Off
	LOCAL MyDebLevel

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel

_LDATA SEGMENT
Str_Off db S, 0dh,0ah, 0
_LDATA ENDS

	push	esi
IFNB <V1>
    IF	TYPE V1 GT 0
	push	dword ptr V1
    ELSE
	push	V1
    ENDIF
ELSE
	push	eax
ENDIF
IFNB <V2>
    IF	TYPE V2 GT 0
	push	dword ptr V2
    ELSE
	push	V2
    ENDIF
ELSE
	push	ebx
ENDIF
	mov	esi, OFFSET32 Str_Off
	VMMCall Queue_Debug_String
	pop	esi
ENDIF

ENDIF
	ENDM








Mono_Out MACRO S, nocrlf
	LOCAL	Str_Off
IF DEBLEVEL GT DEBLEVELRETAIL
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0dh,0ah
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	esi, OFFSET32 Str_Off
	VMMCall Out_Mono_String
	popad
	popfd
ENDIF
	ENDM








Mono_Out_At MACRO Row, Col, S, nocrlf
	LOCAL	Str_Off
IF DEBLEVEL GT DEBLEVELRETAIL
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0dh,0ah
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	dx, (Row SHL 8)+Col
	VMMCall Set_Mono_Cur_Pos
	mov	esi, OFFSET32 Str_Off
	VMMCall Out_Mono_String
	popad
	popfd
ENDIF
	ENDM










Assert_Ints_Disabled MACRO DL

IFB <DL>
	??_debLevel = DEBLEVELNORMAL
ELSE
	??_debLevel = DL
ENDIF

IF DEBLEVEL GE ??_debLevel

ifndef ??_aidMessage
	_LDATA segment
	??_aidMessage	db	"ERROR:  Ints enabled at Assert_Ints_Disabled"
			db	0Dh, 0Ah, 0
	_LDATA ends
endif
	pushfd
	test	byte ptr [esp+1], IF_Mask SHR 8
    .if	!ZERO?
	push	OFFSET32 ??_aidMessage
	VMMCall _Debug_Out_Service
    .endif
	popfd
ENDIF
	ENDM








Assert_Ints_Enabled MACRO DL

IFB <DL>
	??_debLevel = DEBLEVELNORMAL
ELSE
	??_debLevel = DL
ENDIF

IF DEBLEVEL GE ??_debLevel

ifndef ??_aieMessage
	_LDATA segment
	??_aieMessage	db	"ERROR:  Ints disabled at Assert_Ints_Enabled"
			db	0Dh, 0Ah, 0
	_LDATA ends
endif
	pushfd
	test	byte ptr [esp+1], IF_Mask SHR 8
    .if	ZERO?
	push	OFFSET32 ??_aieMessage
	VMMCall _Debug_Out_Service
    .endif
	popfd
ENDIF
	ENDM

















Assert_Cur_VM_Handle MACRO R, DL
	LOCAL	OK
	LOCAL myDebLevel

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel

IFDIFI <ebx>,<R>
	push	ebx
	mov	ebx, R
ENDIF
	VMMCall Debug_Test_Cur_VM
IFDIFI <ebx>,<R>
	pop	ebx
ENDIF

ENDIF

ENDIF
	ENDM


Assert_Client_Ptr MACRO Reg, DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel
IFDIFI <ebp>,<Reg>
	push	ebp
	mov	ebp, Reg
ENDIF
	VMMCall Validate_Client_Ptr
IFDIFI <ebp>,<Reg>
	pop	ebp
ENDIF
ENDIF

ENDIF
	ENDM

endif























irp	cond,<s,c,a,ae,b,be,e,z,g,ge,l,le,o>

TRAP&cond &macro
	?trap	jn&cond
	&endm

TRAPn&cond &macro
	?trap	j&cond
	&endm

TRAPFATAL&cond &macro
	?trap	jn&cond, FATAL
	&endm

TRAPFATALn&cond &macro
	?trap	j&cond, FATAL
	&endm
endm

TRAP	macro
if DEBLEVEL GT DEBLEVELRETAIL
	int	3
endif
	endm

TRAPFATAL	macro
	local	l
if DEBLEVEL GT DEBLEVELRETAIL
l:	int	3
	jmp	short l
endif
	endm

TRAPecxz macro
	local	l1,l2
if DEBLEVEL GT DEBLEVELRETAIL
	jecxz	l1
	jmp	short l2
l1:	int	3
l2:
endif
	endm

TRAPecxnz macro
	?trap	jecxz
	endm

?trap	macro	jmpop, fatal
	Local	l, n
if DEBLEVEL GT DEBLEVELRETAIL
	jmpop	short n
l:	int	3
ifnb	<fatal>
	jmp	short l
endif
n:
endif
	endm

ifndef Not_VxD




Dump_Struc_Head MACRO
if DEBLEVEL GT DEBLEVELRETAIL
	Trace_Out "  Base    Address   Offs     Value  Field name"
ENDIF
	ENDM

Dump_Struc MACRO Base, X
if DEBLEVEL GT DEBLEVELRETAIL
	pushfd
	pushad
	lea	esi, [Base]
	mov	ecx, X
	lea	edx, [esi+ecx]

IF SIZE X EQ 6
	mov	bx, WORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #BX:#EAX  &X"
ELSE
IF SIZE X EQ 4
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #EAX  &X"
ELSE
IF SIZE X EQ 2
	mov	ax, WORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX      #AX  &X"
ELSE
	mov	al, BYTE PTR [edx]
	Trace_Out "#ESI  #EDX  #CX        #AL  &X"
ENDIF
ENDIF
ENDIF

	popad
	popfd
ENDIF
	ENDM

BeginDoc



























EndDoc

Begin_Touch_1st_Meg MACRO DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL
IFB <DL>
	myDebLevel = DEBLEVELMAX
ELSE
	myDebLevel = DL
ENDIF
IF DEBLEVEL GE myDebLevel
	VMMCall Enable_Touch_1st_Meg
ENDIF
ENDIF
	ENDM



End_Touch_1st_Meg MACRO DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL
IFB <DL>
	myDebLevel = DEBLEVELMAX
ELSE
	myDebLevel = DL
ENDIF
IF DEBLEVEL GE myDebLevel
	VMMCall Disable_Touch_1st_Meg
ENDIF
ENDIF
	ENDM

endif

IFDEF	DEBUG
TrashThis Macro	l:vararg
    ?TrashThisVal equ <0FFFFFF80h>
    ?TrashThisValSet = 0
    for r, <l>
	or	r, ?TrashThisVal
      ife ?TrashThisValSet
        if (OPATTR r) and 10h
	    ?TrashThisVal equ <r>
	    ?TrashThisValSet = 1
	endif
      endif
    endm
endm
ELSE
TrashThis Macro	l:vararg
endm
ENDIF


ifndef Not_VxD

if DEBLEVEL GT DEBLEVELRETAIL

ENTER_NOBLOCK MACRO
	push	DFS_ENTER_NOBLOCK
	VMMCall _Debug_Flags_Service
	ENDM

EXIT_NOBLOCK MACRO
	push	DFS_EXIT_NOBLOCK
	VMMCall _Debug_Flags_Service
	ENDM

Assert_CLD MACRO
	pushfd
	test	dword ptr [esp], DF_MASK
	Debug_OutNZ "Direction flag is not clear."
	popfd
	ENDM

Assert_Might_Block MACRO
	push	DFS_TEST_BLOCK
	VMMCall _Debug_Flags_Service
	ENDM

Assert_Not_Nest_Exec MACRO
	push	DFS_TEST_NEST_EXEC
	VMMCall _Debug_Flags_Service
	ENDM

ELSE

ENTER_NOBLOCK EQU <>
EXIT_NOBLOCK EQU <>
Assert_CLD EQU <>
Assert_Might_Block EQU <>
Assert_Not_Nest_Exec EQU <>

ENDIF


ifdef Begin_Service_Table
Begin_Service_Table DEBUG
DEBUG_Service	 DEBUG_Get_Version, LOCAL
DEBUG_Service	 DEBUG_Fault, LOCAL
DEBUG_Service	 DEBUG_CheckFault, LOCAL
DEBUG_Service	 _DEBUG_LoadSyms
End_Service_Table DEBUG
endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\basedef.inc ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

option expr32

IFNDEF	basedef_inc
basedef_inc	EQU		1

; Begin of file ..\..\..\dev\ddk\inc\basedef.h
FALSE		EQU		0t
TRUE		EQU		1t
NULL		EQU		000000000h
_INT		TYPEDEF		SWORD

UINT		TYPEDEF		WORD

BOOL		TYPEDEF		SWORD

CHAR		TYPEDEF		SBYTE

UCHAR		TYPEDEF		BYTE

_SHORT		TYPEDEF		SWORD

USHORT		TYPEDEF		WORD

LONG		TYPEDEF		SDWORD

ULONG		TYPEDEF		DWORD

PVOID		TYPEDEF		PTR 

PPVOID		TYPEDEF		PTR PVOID

PINT		TYPEDEF		PTR _INT

PUINT		TYPEDEF		PTR UINT

PBYTE		TYPEDEF		PTR BYTE

PWORD		TYPEDEF		PTR WORD

PDWORD		TYPEDEF		PTR DWORD

PCHAR		TYPEDEF		PTR CHAR

PSHORT		TYPEDEF		PTR _SHORT

PLONG		TYPEDEF		PTR LONG

PUCHAR		TYPEDEF		PTR UCHAR

PUSHORT		TYPEDEF		PTR USHORT

PULONG		TYPEDEF		PTR ULONG

PBOOL		TYPEDEF		PTR BOOL

SZ		TYPEDEF		UCHAR

PSZ		TYPEDEF		PTR UCHAR

SZZ		TYPEDEF		UCHAR

PSZZ		TYPEDEF		PTR UCHAR

SEL		TYPEDEF		USHORT

PSEL		TYPEDEF		PTR SEL

PPHYS		TYPEDEF		ULONG

PFN		TYPEDEF		PTR 

PPFN		TYPEDEF		PTR PFN

HANDLE		TYPEDEF		PVOID

PHANDLE		TYPEDEF		PTR HANDLE

HTIMEOUT		TYPEDEF		ULONG

CMS		TYPEDEF		ULONG

; End of file ..\..\..\dev\ddk\inc\basedef.h

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\INT2FAPI.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT2FAPI.INC - Windows/386 V86 Application Program Interface
;
;   Version:	3.00
;
;   Date:	10-Mar-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Mar-1989 RAL Original for 3.0
;   07-Apr-1989 RAL Added device broadcast equate
;
;==============================================================================
;
;   For inforamtion on these APIs please refer to the Windows/386 DDK
;   appendix on the Int 2Fh Application Program Interface.
;
;------------------------------------------------------------------------------

;
;   Interrupt 2Fh is used for Windows/386 API calls.
;
W386_API_Int		EQU	2Fh

;
;   All Windows/386 API Int 2Fh calls must be issued with AH = 16h
;
W386_Int_Multiplex	EQU	16h

;
;   Values for AL for all Windows/386 API calls
;
W386_Get_Version	EQU	00h		; Install check/Get version
W386_Old_Get_VMID_API	EQU	02h		; Version 2.xx get VMID API call
W386_Startup		EQU	05h		; Broadcast when Win386 starting
W386_Exit		EQU	06h		; Broadcast when Win386 exited
W386_Device_Broadcast	EQU	07h		; Broadcast by virtual device
W386_Startup_Complete	EQU	08h		; Broadcast when Win386 start is complete
W386_Begin_Exit 	EQU	09h		; Broadcast when Win386 is starting
						;   a NORMAL exit sequence
W386_Windows_ID 	EQU	0Ah		; Identify windows ver/type
W386_TSR_Identify	EQU	0Bh		; Identify TSRs
W386_ROM_Detect 	EQU	0Ch		; Used by ROM win to detect ROMs

W386_Release_Time	EQU	80h		; Release cur VM's time-slice
W386_Begin_Critical	EQU	81h		; Begin critical section
W386_End_Critical	EQU	82h		; End critical section
W386_Get_Cur_VMID	EQU	83h		; Returns BX = ID of current VM
W386_Get_Device_API	EQU	84h		; Returns ES:DI -> Device API
W386_Switch_And_Call	EQU	85h		; Change VMs and call-back
W386_Test_Int31_Avail	EQU	86h		; Returns AX=0 if Int 31 avail
W386_Get_PM_Switch_Addr EQU	87h		; Get call-back addr for PM
W386_Get_LDT_Base_Sel	EQU	88h		; Get selector to LDT
W386_Win_Kernel_Idle	EQU	89h		; Windows kernel idle call
W386_DPMI_Extension	EQU	8Ah		; DPMI extension Int 2Fh
W386_Set_Focus		EQU	8Bh		; Set focus to specified VM
W386_Restart_Cmd	EQU	8Ch		; Win.Com execs specified app

;
;   Structure for real mode device initialization API.
;
Win386_Startup_Info_Struc STRUC
SIS_Version		db	3, 0		; Structure version
SIS_Next_Ptr		dd	?		; Seg:Off of next dev in list
SIS_Virt_Dev_File_Ptr	dd	0		; Ptr to ASCIZ file name to load
SIS_Reference_Data	dd	?		; Data to be passed to device
SIS_Instance_Data_Ptr	dd	0		; Ptr to instance data list
Win386_Startup_Info_Struc ENDS

;
;   Structure for instance data list.  (List terminated with 0 dword).
;
Instance_Item_Struc STRUC
IIS_Ptr 		dd	?		; Seg:Off of instance item
IIS_Size		dw	?		; Size of instance item in bytes
Instance_Item_Struc ENDS

;
;   Flags passed to the Win_Kernel_Idle call to indicate state of Windows
;   in the BX register.
;
Win_Idle_Mouse_Busy	EQU	00000001b
Win_Idle_Mouse_Busy_Bit EQU	0

;
; Structure for TSR <-> Windows communication
; (W386_TSR_Identify call, AL=0Bh)
;
TSR_Info_Struc	STRUC
    TSR_Next		    dd	?
    TSR_PSP_Segment	    dw	?
    TSR_API_Ver_ID	    dw	100h
    TSR_Exec_Flags	    dw	0
    TSR_Exec_Cmd_Show	    dw	0
    TSR_Exec_Cmd	    dd	0
    TSR_Reserved	    db	4 dup (0)
    TSR_ID_Block	    dd	0
    TSR_Data_Block	    dd	0
TSR_Info_Struc ENDS

;
; TSR_Exec_Flags equates
;
TSR_WINEXEC	EQU	1
TSR_LOADLIBRARY EQU	2
TSR_OPENDRIVER	EQU	4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MINIVDD.H ===
//*****************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title:      minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:    4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//           the general include area.  Added services are ONLY for the
//           use of the Mini-VDD and should therefore not be documented.
//
//-----------------------------------------------------------------------------
//=============================================================================

#ifndef _MINIVDD_H_
#define _MINIVDD_H_

#ifndef Not_VxD

/*XLATOFF*/
#define VDD_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

#ifdef MINIVDD
#ifdef NEC_98
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version            ) // Get version number and ID string ptr
VDD_Service(     VDD_PIF_State              ) // Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn            ) // Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor            ) // Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType             ) // Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime            ) // Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk            ) // Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn            ) // Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor           ) // Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor           ) // Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut            ) // Output a string
VDD_Service(     VDD_Msg_SetCursPos         ) // Set cursor position
VDD_Service(     VDD_Query_Access           ) // Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon      ) // User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table) // Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port  ) // Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info            ) // Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs     ) // returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port      ) // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO        ) // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO         ) // perform physical I/O for trapped port
VDD_Service(     VDD_Register_Mini_VDD   )
VDD_Service(    VDD_Install_IO_Handler   )
VDD_Service(    VDD_Install_Mult_IO_Handlers    )
VDD_Service(    VDD_Enable_Local_Trapping       )
VDD_Service(    VDD_Disable_Local_Trapping      )
VDD_Service(    VDD_Trap_Suspend        )
VDD_Service(    Test_Vid_VM_Handle      )
VDD_Service(    VDD_Set_Core_Graphics   )
VDD_Service(    VDD_Load_AccBIOS        )
VDD_Service(    VDD_Map_AccBIOS         )
VDD_Service(    VDD_Map_VRAM            )
End_Service_Table(VDD)
/*ENDMACROS*/
#else  /*NEC_98*/
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version             )// Get version number and ID string ptr
VDD_Service(     VDD_PIF_State               )// Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn             )// Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor             )// Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType              )// Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime             )// Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk             )// Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn             )// Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor            )// Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor            )// Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut             )// Output a string
VDD_Service(     VDD_Msg_SetCursPos          )// Set cursor position
VDD_Service(     VDD_Query_Access            )// Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon       )// User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table )// Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port   )// Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info             )// Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs      )// returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port   )    // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO     )    // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO      )    // perform physical I/O for trapped port
VDD_Service(     VDD_Set_Sleep_Flag_Addr )    // when display driver can't be interrupted
End_Service_Table(VDD)                   
/*ENDMACROS*/
#endif  /*NEC_98*/
#endif  /*MINIVDD*/

/*XLATOFF*/
#pragma warning (default:4003)              // turn off not enough params warning
/*XLATON*/

#define VDD_VerNum      0x0400  // version 4.00
#define VDD_MinVerNum   0x030A  // supports down to 3.10

//***************
// PIF_State service definitions
//
// These definitions cannot change without changing the PIF editor!!!
//
#ifdef NEC_98
#define bVidTextMd	 4	; Allocate text mode mem
#define fVidTextMd	 (1 << 4)
#define bVidNTModeFF	 0	; NoTrap: Mode F/F
#define fVidNTModeFF	 (1 << 0)
#define bVidNTModeFFC16	 1	; Default is 16 color mode
#define fVidNTModeFFC16	 (1 << 1)
#define bVidNTDispRW	 2	; NoTrap: Bank Register
#define fVidNTDispRW	 (1 << 2)
#define bVidNTPal	 3	; NoTrap: Palette
#define fVidNTPal	 (1 << 3)
#define bVidNTGDC	 5	; NoTrap: GDC
#define fVidNTGDC	 (1 << 5)
#define bVidNTGDCTON	 6	; Default Text on
#define fVidNTGDCTON	 (1 << 6)
#define bVidNTGDCGON	 7	; Default Grph on
#define fVidNTGDCGON	 (1 << 7)
#define bVidNTFont	 8	; NoTrap: KCG
#define fVidNTFont	 (1 << 8)
#define bVidCRTC	 9	; Use CRTC Tracer
#define fVidCRTC	 (1 << 9)
#define bVidDispDataXfer 10	; Transrate mode (0:Text, 1:Text/Grph)
#define fVidDispDataXfer (1 << 10)
#define bVidXFERPlane0	 11	; Transrate plane Blue
#define fVidXFERPlane0	 (1 << 11)
#define bVidXFERPlane1	 12	; 		  Red
#define fVidXFERPlane1	 (1 << 12)
#define bVidXFERPlane2	 13	; 		  Green
#define fVidXFERPlane2	 (1 << 13)
#define bVidXFERPlane3	 14	; 		  Intensity
#define fVidXFERPlane3	 (1 << 14)

#define mVidXFERPlane	(fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
#define mVidNTH98	(fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
#else //NEC_98
#define fVidTxtEmulate  0x0001  // Do INT 10h TTY and cursor emulation
#define fVidNoTrpTxt    0x0002  // Do not trap text mode apps
#define fVidNoTrpLRGrfx 0x0004  // Do not trap lo res graphics mode apps
#define fVidNoTrpHRGrfx 0x0008  // Do not trap hi res graphics mode apps
#define fVidTextMd      0x0010  // Allocate text mode mem
#define fVidLowRsGrfxMd 0x0020  // Allocate lo res graphics mode mem
#define fVidHghRsGrfxMd 0x0040  // Allocate hi res graphics mode mem
#define fVidRetainAllo  0x0080  // Never deallocate once allocated
#endif //NEC_98

//
// The following stuff was added for mini-VDD support:
//
// Functions that we can call in the hardware-dependent mini-VDD.  Note that
// these equates are used to create the dispatch table for calling functions
// in the mini-VDD:
//
#ifdef NEC_98
#define REGISTER_DISPLAY_DRIVER 	     0
#define PRE_HIRES_TO_VGA		     1
#define SAVE_REGISTERS			     2
#define RESTORE_REGISTERS		     3
#define ENABLE_TRAPS			     4
#define DISABLE_TRAPS			     5
#define DISPLAY_DRIVER_DISABLING	     6
#define ENABLE_ACCELERATER		     7
#define DISABLE_ACCELERATER		     8
#define CHECK_UPDATE			     9
#define CHECK_WINDOWED			     10
#define ACC_VBE_PM			     11
#define ACC_VBE_DDC			     12
#define ACC_INT_10			     13
#define ACC_GET_CAPABILITIES		     14
#define ACC_GET_EXT_MODE_INFO		     15
#define ACC_GET_FLAT_SELECTOR		     16
#define ACC_ENABLE_BIOS			     17
#define ACC_DISABLE_BIOS		     18
#define ACC_SET_PALETTE			     19
#define ACC_GET_PALETTE			     20
#define ACC_SET_CURSOR			     21
#define ACC_SHOW_CURSOR			     22
#define ACC_HIDE_CURSOR			     23
#define ACC_SET_CURSOR_POS		     24
#define ACC_GET_CURSOR_POS		     25
;
#define NBR_MINI_VDD_FUNCTIONS               26      //REMEMBER TO RESET THIS!!!!!!
#else //NEC_98
#define REGISTER_DISPLAY_DRIVER              0
#define GET_VDD_BANK                         1
#define SET_VDD_BANK                         2
#define RESET_BANK                           3
#define PRE_HIRES_TO_VGA                     4
#define POST_HIRES_TO_VGA                    5
#define PRE_VGA_TO_HIRES                     6
#define POST_VGA_TO_HIRES                    7
#define SAVE_REGISTERS                       8
#define RESTORE_REGISTERS                    9
#define MODIFY_REGISTER_STATE                10
#define ACCESS_VGA_MEMORY_MODE               11
#define ACCESS_LINEAR_MEMORY_MODE            12
#define ENABLE_TRAPS                         13
#define DISABLE_TRAPS                        14
#define MAKE_HARDWARE_NOT_BUSY               15
#define VIRTUALIZE_CRTC_IN                   16
#define VIRTUALIZE_CRTC_OUT                  17
#define VIRTUALIZE_SEQUENCER_IN              18
#define VIRTUALIZE_SEQUENCER_OUT             19
#define VIRTUALIZE_GCR_IN                    20
#define VIRTUALIZE_GCR_OUT                   21
#define SET_LATCH_BANK                       22
#define RESET_LATCH_BANK                     23
#define SAVE_LATCHES                         24
#define RESTORE_LATCHES                      25
#define DISPLAY_DRIVER_DISABLING             26
#define SELECT_PLANE                         27
#define PRE_CRTC_MODE_CHANGE                 28
#define POST_CRTC_MODE_CHANGE                29
#define VIRTUALIZE_DAC_OUT                   30
#define VIRTUALIZE_DAC_IN                    31
#define GET_CURRENT_BANK_WRITE               32
#define GET_CURRENT_BANK_READ                33
#define SET_BANK                             34
#define CHECK_HIRES_MODE                     35
#define GET_TOTAL_VRAM_SIZE                  36
#define GET_BANK_SIZE                        37
#define SET_HIRES_MODE                       38
#define PRE_HIRES_SAVE_RESTORE               39
#define POST_HIRES_SAVE_RESTORE              40
#define VESA_SUPPORT                         41
#define GET_CHIP_ID                          42
#define CHECK_SCREEN_SWITCH_OK               43
#define VIRTUALIZE_BLTER_IO                  44
#define SAVE_MESSAGE_MODE_STATE              45
#define SAVE_FORCED_PLANAR_STATE             46
#define VESA_CALL_POST_PROCESSING            47
#define PRE_INT_10_MODE_SET                  48
#define NBR_MINI_VDD_FUNCTIONS_40            49      //REMEMBER TO RESET THIS!!!!!!

//
//  new miniVDD functions that a 4.1 miniVDD should implement
//
#define GET_NUM_UNITS                        49
#define TURN_VGA_OFF                         50
#define TURN_VGA_ON                          51
#define SET_ADAPTER_POWER_STATE              52
#define GET_ADAPTER_POWER_STATE_CAPS         53
#define SET_MONITOR_POWER_STATE              54
#define GET_MONITOR_POWER_STATE_CAPS         55
#define NBR_MINI_VDD_FUNCTIONS_41            56

#ifdef MAINVDD
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_41
#else
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_40
#endif

#endif //NEC_98

#endif /*NotVxD*/

//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
// all these entry points take as input:
//
// Entry:
//      Client_EAX  - function code.
//      Client_EBX  - device handle, or device id (1-N)
//
#define VDD_QUERY_VERSION                   0
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PC98_RESERVED                   (10 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_VBE_PM                          (10 + MINIVDD_SVC_BASE_OFFSET)
//
//   all functions >= VDD_ENABLE also take the following params:
//
//      Client_ES:DI    - buffer
//      Client_ECX      - buffer size
//      Client_EDX      - flags
//
// Exit:
//      Client_EAX  = function code  if the function is not supported.
//                  = 0              if the function succeded.
//                  = -1             if the function failed.
//
#define VDD_ENABLE                          (11 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GETMEMBASE                      (12 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN                            (13 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_CLOSE                           (14 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN_KEY                        (15 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_POWER_STATE                 (16 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_ENUM                            (17 + MINIVDD_SVC_BASE_OFFSET)

//
// special verion of VDD_GET_DISPLAY_CONFIG that always get the
// monitor data, even if the user has disabled using a refresh rate.
//
#define VDD_GET_DISPLAY_CONFIG2             0x8085

//
//  VDD_DRIVER_REGISTER
//
//  The display driver sends us some information needed to handle various
//  context changes.
//
//  Entry:
//         Client_ES:DI Selector:Offset of callback routine used
//                      to reset to Windows HiRes mode upon return
//                      from a full screen DOS VM to the Windows VM.
//         Client_ES    Main code segment of display driver.
//         Client_ECX   contains the total nbr of bytes on-screen (excluding
//                      off-screen memory).
//         Client_EDX   contain 0 if we are to attempt to allow 4 plane VGA
//                      virtualization.
//         Client_EDX   contains -1 if we are to not allow 4 plane VGA
//                      virtualization.
//         Client_EBX   device handle, or device id (1-N)
//  Exit:
//         Client_EAX   contains total bytes of memory used by visible screen
//                      AND the VDD virtualization area (ie: the start of
//                      off-screen memory available for use by the display
//                      driver as "scratch" memory).
//

//
//  VDD_DRIVER_UNREGISTER
//
//  Entry:
//          Client_EBX   device handle, or device id (1-N)
//  Exit:
//

//
//  VDD_ENABLE
//
//  entry:
//      Client_EAX      - VDD_ENABLE (0x008B)
//      Client_EBX      - device handle, or device id (1-N)
//      Client_EDX      - enable flags (see below)
//
//  exit:
//      Client_EAX      - previous enable state.
//
//  only one device at a time can have VGAMEM, VGAIO, or ROM access
//  at a time.
//
#define ENABLE_IO               0x00000001  // enable IO.
#define ENABLE_MEM              0x00000002  // enable memory.
#define ENABLE_VGA              0x00000030  // enable VGA
#define ENABLE_ROM              0x00000080  // enable ROM at C000.
#define ENABLE_ALL              0x000000FF  // enable all access to this device
#define ENABLE_NONE             0x00000000  // disable device.
#define ENABLE_VALID            0x000000FF  // valid flags.
#define ENABLE_ERROR            0xFFFFFFFF  // enable fail code

//
//  VDD_OPEN
//
//      open a device given a name
//
//  Entry:
//          Client_ES:EDI   - device name
//          Client_EDX      - flag
//  Exit:
//          Client_EAX      - device handle
//
#define VDD_OPEN_TEST       0x00000001


//
//  WIN32 IOCTLS
//
//  The following defines are used with the Win32 function DeviceIOControl
//
#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD

//
//  VDD_IOCTL_SET_NOTIFY
//
//  sets a notification function that will be called when events
//  happen on the device.
//
//  input:
//          NotifyMask      - bitfield of events
//          NotifyType      - type of notify
//          NotifyProc      - notify procedure
//          NotifyData      - client data
//
//  output:
//           none
//
//  return:
//          ERROR_SUCCES
//
typedef struct tagVDD_IOCTL_SET_NOTIFY_INPUT {
    DWORD   NotifyMask;
    DWORD   NotifyType;
    DWORD   NotifyProc;
    DWORD   NotifyData;
}   VDD_IOCTL_SET_NOTIFY_INPUT;


//
// NotifyMask
//
#define VDD_NOTIFY_START_MODE_CHANGE    0x00000001
#define VDD_NOTIFY_END_MODE_CHANGE      0x00000002
#define VDD_NOTIFY_ENABLE               0x00000004
#define VDD_NOTIFY_DISABLE              0x00000008

//
//  NotifyType
//
#define VDD_NOTIFY_TYPE_CALLBACK        1


//
// Port size equates:
//
#define BYTE_LENGTHED                       1
#define WORD_LENGTHED                       2

//
// Flag equates:
//
#define GOING_TO_WINDOWS_MODE               1
#define GOING_TO_VGA_MODE                   2
#define DISPLAY_DRIVER_DISABLED             4
#define IN_WINDOWS_HIRES_MODE               8

//
//  DISPLAYINFO structure
//
typedef struct DISPLAYINFO {
        WORD  diHdrSize;
        WORD  diInfoFlags;
        //
        //  display mode specific data
        //
        DWORD diDevNodeHandle;
        char  diDriverName[16];
        WORD  diXRes;
        WORD  diYRes;
        WORD  diDPI;
        BYTE  diPlanes;
        BYTE  diBpp;
        //
        //  monitor specific data
        //
        WORD  diRefreshRateMax;
        WORD  diRefreshRateMin;
        WORD  diLowHorz;
        WORD  diHighHorz;
        WORD  diLowVert;
        WORD  diHighVert;
        DWORD diMonitorDevNodeHandle;
        BYTE  diHorzSyncPolarity;
        BYTE  diVertSyncPolarity;
        //
        // new 4.1 stuff
        //
        DWORD diUnitNumber;             // device unit number
        DWORD diDisplayFlags;           // mode specific flags
        DWORD diXDesktopPos;            // position of desktop
        DWORD diYDesktopPos;            // ...
        DWORD diXDesktopSize;           // size of desktop (for panning)
        DWORD diYDesktopSize;           // ...

} DISPLAYINFO;

/*ASM
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize
*/

//
// Following are values for the diInfoFlags word in DISPLAYINFO:
//
#define RETURNED_DATA_IS_STALE           0x0001
#define MINIVDD_FAILED_TO_LOAD           0x0002
#define MINIVDD_CHIP_ID_DIDNT_MATCH      0x0004
#define REGISTRY_BPP_NOT_VALID           0x0008
#define REGISTRY_RESOLUTION_NOT_VALID    0x0010
#define REGISTRY_DPI_NOT_VALID           0x0020
#define MONITOR_DEVNODE_NOT_ACTIVE       0x0040
#define MONITOR_INFO_NOT_VALID           0x0080
#define MONITOR_INFO_DISABLED_BY_USER    0x0100
#define REFRESH_RATE_MAX_ONLY            0x0200
#define CARD_VDD_LOADED_OK               0x0400
#define DEVICE_IS_NOT_VGA                0x0800

//
//  Following are explanations for the diInfoFlags word in DISPLAYINFO:
//
//  RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
//  or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
//  program would get the DISPLAYINFO structure returned to him) caused the VDD
//  to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
//  insted of actually going out and reading "fresh" data from the Registry.
//
//  This flag brings to light the fact that there are some circumstances when the
//  VDD cannot go out and read the registry in response to the call to
//  VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
//  considerations).  In this case, this flag will be set to a 1 to indicate that
//  the information being returned isn't "fresh" -- that is -- it may be
//  incorrect and obsolete.  The caller should respond accordingly if this flag
//  is set.
//
//
//  MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
//  that the MiniVDD didn't match the chipset installed in the machine), the
//  MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
//
//  MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
//  successfully, when the ChipID that the MiniVDD calculated was compared
//  against the value saved in the registry, they didn't match.  An example of
//  when this would happen is when the user is happily using an S3-911 card
//  and then decides to upgrade his display card to an S3-864.  Since both
//  cards use S3.VXD, the MiniVDD will load, however, since the card model
//  is different, the VDD will return a defect to configuration manager and
//  set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
//  flag to take appropriate actions to make sure that the user gets his
//  configuration correct.
//
//
//  REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
//  from the registry when the VDD tried to read it.
//
//
//  REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
//  resolution value from the registry when the VDD tried to read it.
//
//
//  REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
//  DPI value from the registry when the VDD tried to read it.
//
//
//  MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
//  GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
//  This is certainly not fatal by any means.  It simply means that the
//  monitor refresh rate info in the DISPLAYINFO data structure is totally
//  invalid!
//
//
//  MONITOR_INFO_NOT_VALID indicates that something within the code which
//  retrieves and calculates the refresh rate data has failed.  This indicates
//  that the values in diRefreshRateMax through diVertSyncPolarity are not
//  valid and could contain random data.
//
//
//  MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
//  string in SYSTEM.INI had a negative number in it or that the string in
//  the display's software key RefreshRate = string was 0 or a negative number.
//
//
//  REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
//  diLowVert, diHighVert, or sync polarity data in the registry.  The
//  value returned in diRefreshRateMax is the only refresh rate data that
//  we have available.  This was derived either from RefreshRate= in SYSTEM.INI
//  or the display software key RefreshRate = string in the registry.
//
//
//  CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
//  display card manufacturers wishing to extend the capabilities of the chip level
//  MiniVDD's ) has successfully been loaded and initialized.
//
//  DEVICE_IS_NOT_VGA indicates that this device is not the primary vga
//

#define NoTrace_VIRTUALIZE_CRTC_IN
#define NoTrace_VIRTUALIZE_CRTC_OUT
#define NoTrace_VIRTUALIZE_SEQUENCER_IN
#define NoTrace_VIRTUALIZE_SEQUENCER_OUT
#define NoTrace_VIRTUALIZE_GCR_IN
#define NoTrace_VIRTUALIZE_GCR_OUT
#define NoTrace_VIRTUALIZE_DAC_OUT
#define NoTrace_VIRTUALIZE_DAC_IN
#define NoTrace_CHECK_HIRES_MODE
/*ASM

ifdef NEC_98
;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

    ;
    ;	Mini-VDD Static Flags
    ;
vFlg_Machine_Std	equ			00000001b
vFlg_Machine_Multi	equ			00000010b
vFlg_Machine_Mate	equ			00000100b
vFlg_Machine_H98	equ			00001000b
vFlg_CRT_New		equ			00010000b
vFlg_CRT_NonInter	equ			00100000b
vFlg_GDC_5MHz		equ			01000000b
vFlg_GDC_Emulate	equ			10000000b
vFlg_Acc_Internal	equ		0000000100000000b
vFlg_Acc_External	equ		0000001000000000b
vFlg_Acc_PCI		equ		0000010000000000b
vFlg_Acc_ML		equ		0000100000000000b
vFlg_Acc_PVD		equ		0001000000000000b
vFlg_Mode_NH		equ		0010000000000000b
vFlg_Mode_H		equ		0100000000000000b
vFlg_Initialized	equ		1000000000000000b
vFlg_Opt_MFR		equ	000000010000000000000000b
vFlg_Opt_NewMFR		equ	000000100000000000000000b
vFlg_Opt_VDP		equ	000001000000000000000000b
vFlg_Opt_NewVDP		equ	000010000000000000000000b

vFlg_Local		equ	000000000100000010000000b

    ;
    ;	Mini-VDD Support Max
    ;
MaxMiniVDD	equ	16
MaxMiniTrap	equ	32
MaxMultiTrap	equ	3
MaxMultiFunc	equ	MaxMiniVDD

    ;
    ;	MiniVDD_LTrap_Struct.LTrap_Status
    ;	MiniVDD_LTrap_Struct.LTrap_Flags.xxxx
    ;
LT_Enable	equ	00000001b
LT_Enable_bit	equ	0
LT_Initialized	equ	10000000b
LT_Initialized_bit equ	7


;******************************************************************************
;			D A T A   S T R U C T U R E S
;******************************************************************************

    ;
    ;	Vids_struct
    ;

Vids_struct struc
   ;
   ;	Common Data supplied by Base-VDD. Some data(bits) set by Mini-VDD.
   ;
	Vids_SFlags		dd	?	; Static flags
	Vids_CB_Offset		dd	?	; 
	Vids_Msg_Pseudo_VM	dd	?	; 

   ;
   ;	Common Procedure supplied by Base-VDD
   ;
	VDD_TGDC_Draw_Off	dd	?	; 
	VDD_TGDC_Sync_Off	dd	?	; 
	VDD_TGDC_Sync_On	dd	?	; 
	VDD_TGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_Draw_Off	dd	?	; 
	VDD_GGDC_Sync_Off	dd	?	; 
	VDD_GGDC_Sync_On	dd	?	; 
	VDD_GGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_MOD_Emulate	dd	?	; 

   ;
   ;	Common Procedure supplied by Mini-VDD
   ;
	H98_FLORA_Change	dd	?	; H98 - NH mode
	H98_Clear_Text		dd	?	; H98 - NH mode
	H98_Rest_GCs		dd	?	; H98
	H98_Rest_etc		dd	?	; H98
	H98_Save_ModeFF		dd	?	; H98

Vids_struct ends


Vid_SFlags		equ	<Vids.Vids_SFlags>
VDD_CB_Offset		equ	<Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM	equ	<Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off		equ	<Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off		equ	<Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On		equ	<Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off		equ	<Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty		equ	<Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty		equ	<Vids.VDD_GGDC_FIFO_Empty>


    ;
    ;	RegTrapStruct
    ;
MiniFuncStruct	STRUC
MF_ProcAddr	dd	?
;;MF_Order	dw	?
;;MF_MiniID	db	?
;;MF_Flags	db	?
MiniFuncStruct	ENDS

    ;
    ;	MiniProcStruct
    ;
MiniVDD_Proc_Struct	STRUC
Proc_Address	dd	?
Proc_Order	dw	?
Proc_MiniID	db	?
Proc_Flags	db	?
MiniVDD_Proc_Struct	ENDS
.errnz	(size MiniVDD_Proc_Struct) mod 4

    ;
    ;	MiniTrapTable	- Global Info
    ;	LocalTrapTable	- Local Status
    ;
MiniVDD_GTrap_Struct	STRUC
GTrap_ProcAddr	dd	?
GTrap_PortAddr	dw	?
GTrap_NumMini	dw	?
GTrap_ProcTable	db	((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct	ENDS

MiniVDD_LTrap_Struct	STRUC
LTrap_ProcAddr	dd	?
LTrap_Status	db	?
LTrap_Flags	db	MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct	ENDS


;******************************************************************************
;				M A C R O S
;******************************************************************************

    ;
    ;	BeginMiniFunc	TableName
    ;	    MiniFunc	Function-ID, ProcedureName
    ;		|	
    ;	EndMiniFunc	TableName
    ;
EndMiniFunc_	MACRO	n
ifdef	MiniFunc&n
	dd	OFFSET32 MiniFunc&n		; MiniFuncStruct
else
	dd	0
endif
		ENDM

MiniFunc_	MACRO	FuncID, FuncName
		MiniFunc&FuncID equ <FuncName>
		ENDM

BeginMiniFunc	MACRO	TableName
public	TableName
TableName	label	near
		ENDM

EndMiniFunc	MACRO	TableName
		x = 0
		REPT	NBR_MINI_VDD_FUNCTIONS
		EndMiniFunc_	%x
		x = x + 1
		ENDM
		ENDM

MiniFunc	MACRO	FuncID, FuncName
		MiniFunc_ %(FuncID), <FuncName>
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDCall	MACRO	FuncID, SetCarry
		local	MiniCall_Loop
		local	MiniCall_Exit

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		mov	ecx, [MiniVDD_NumMini]
MiniCall_Loop:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
		jc	MiniCall_Exit
		add	esi, size MiniVDD_Proc_Struct
		loop	MiniCall_Loop
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDFunc	MACRO	TmpReg, FuncID
		mov	TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		ENDM

    ;
    ;	ExecMode/ExecModeThru
    ;	ExecModeNot/ExecModeThruNot
    ;	ExecModeOnly
    ;	ExecModeOnlyNot
    ;	ExecModeElse
    ;	ExecModeElseNot
    ;	ExecModeEnd
    ;

ExecModeLL	macro	Num
ExecMode_L&Num:
		endm

ExecModeLE	macro	Num
ExecMode_E&Num:
		endm

ExecModeJE	macro	Num
	jmp	ExecMode_E&Num
		endm

ExecModeJZ	macro	Num
	jz	ExecMode_L&Num
		endm

ExecModeJNZ	macro	Num
	jnz	ExecMode_L&Num
		endm

ExecModeJEZ	macro	Num
	jz	ExecMode_E&Num
		endm

ExecModeJENZ	macro	Num
	jnz	ExecMode_E&Num
		endm


ExecModeTest	macro	ModeFlag, CB_Reg
if	ModeFlag and vFlg_Local
ifidni	<CB_Reg>, <Vid>
	push	ebx
	mov	ebx, [Vid_VM_Handle]
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifidni	<CB_Reg>, <Cur>
	push	ebx
	VMMCall	Get_Cur_VM_Handle
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifb	<CB_Reg>
	push	ebx
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
	test	[CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
	test	[Vid_SFlags], ModeFlag
endif
	endm


ExecModeChk	macro	HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni	<HdrFlag>, <Jmp>
.erre	FlgExecMode
	ExecModeJE	%EndExecMode
endif
ExecModeLL	%NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb	<ModeFlag>
	ExecModeTest	<ModeFlag>, <CB_Reg>
ifidni	<JmpLabel>, <End>
ifidni	<JmpFlag>, <Not>
	ExecModeJENZ	%EndExecMode
else
	ExecModeJEZ	%EndExecMode
endif
else
ifidni	<JmpFlag>, <Not>
	ExecModeJNZ	%NumExecMode
else
	ExecModeJZ	%NumExecMode
endif
endif
endif
		endm

ExecModeEnd	macro
ExecModeLL	%NumExecMode
ExecModeLE	%EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
		endm

   ;
   ;	CB_Reg   = Regs/Vid/Cur
   ;	ModeFlag = vFlg_xxxx
   ;
ExecModeJmp	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jnz	JmpLabel
		endm

ExecModeJmpNot	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jz	JmpLabel
		endm

ExecMode	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeOnly	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
		endm

ExecModeOnlyNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
		endm

ExecModeElse	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeElseNot	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeThru	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeThruNot	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
		endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else ;NEC_98
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
CardVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi                     ;;save this register for now
ifnb    <SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm
endif ;NEC_98
*/

#endif  // _MINIVDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MINIVDD.INC ===
ifndef _MINIVDD_H_
_MINIVDD_H_     EQU     1
ifndef Not_VxD
ifdef MINIVDD
ifdef NEC_98
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Register_Mini_VDD
VDD_Service     VDD_Install_IO_Handler
VDD_Service     VDD_Install_Mult_IO_Handlers
VDD_Service     VDD_Enable_Local_Trapping
VDD_Service     VDD_Disable_Local_Trapping
VDD_Service     VDD_Trap_Suspend
VDD_Service     Test_Vid_VM_Handle
VDD_Service     VDD_Set_Core_Graphics
VDD_Service     VDD_Load_AccBIOS
VDD_Service     VDD_Map_AccBIOS
VDD_Service     VDD_Map_VRAM
End_Service_Table VDD
else
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Set_Sleep_Flag_Addr
End_Service_Table VDD
endif
endif
VDD_VerNum      EQU     0400H
VDD_MinVerNum   EQU     030AH
ifdef NEC_98
bVidTextMd      EQU     4
fVidTextMd      EQU     (1 SHL 4)
bVidNTModeFF    EQU     0
fVidNTModeFF    EQU     (1 SHL 0)
bVidNTModeFFC16 EQU     1
fVidNTModeFFC16 EQU     (1 SHL 1)
bVidNTDispRW    EQU     2
fVidNTDispRW    EQU     (1 SHL 2)
bVidNTPal       EQU     3
fVidNTPal       EQU     (1 SHL 3)
bVidNTGDC       EQU     5
fVidNTGDC       EQU     (1 SHL 5)
bVidNTGDCTON    EQU     6
fVidNTGDCTON    EQU     (1 SHL 6)
bVidNTGDCGON    EQU     7
fVidNTGDCGON    EQU     (1 SHL 7)
bVidNTFont      EQU     8
fVidNTFont      EQU     (1 SHL 8)
bVidCRTC        EQU     9
fVidCRTC        EQU     (1 SHL 9)
bVidDispDataXfer        EQU     10
fVidDispDataXfer        EQU     (1 SHL 10)
bVidXFERPlane0  EQU     11
fVidXFERPlane0  EQU     (1 SHL 11)
bVidXFERPlane1  EQU     12
fVidXFERPlane1  EQU     (1 SHL 12)
bVidXFERPlane2  EQU     13
fVidXFERPlane2  EQU     (1 SHL 13)
bVidXFERPlane3  EQU     14
fVidXFERPlane3  EQU     (1 SHL 14)
mVidXFERPlane   EQU     (fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
mVidNTH98       EQU     (fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
else
fVidTxtEmulate  EQU     0001H
fVidNoTrpTxt    EQU     0002H
fVidNoTrpLRGrfx EQU     0004H
fVidNoTrpHRGrfx EQU     0008H
fVidTextMd      EQU     0010H
fVidLowRsGrfxMd EQU     0020H
fVidHghRsGrfxMd EQU     0040H
fVidRetainAllo  EQU     0080H
endif
ifdef NEC_98
REGISTER_DISPLAY_DRIVER EQU     0
PRE_HIRES_TO_VGA        EQU     1
SAVE_REGISTERS  EQU     2
RESTORE_REGISTERS       EQU     3
ENABLE_TRAPS    EQU     4
DISABLE_TRAPS   EQU     5
DISPLAY_DRIVER_DISABLING        EQU     6
ENABLE_ACCELERATER      EQU     7
DISABLE_ACCELERATER     EQU     8
CHECK_UPDATE    EQU     9
CHECK_WINDOWED  EQU     10
ACC_VBE_PM      EQU     11
ACC_VBE_DDC     EQU     12
ACC_INT_10      EQU     13
ACC_GET_CAPABILITIES    EQU     14
ACC_GET_EXT_MODE_INFO   EQU     15
ACC_GET_FLAT_SELECTOR   EQU     16
ACC_ENABLE_BIOS EQU     17
ACC_DISABLE_BIOS        EQU     18
ACC_SET_PALETTE EQU     19
ACC_GET_PALETTE EQU     20
ACC_SET_CURSOR  EQU     21
ACC_SHOW_CURSOR EQU     22
ACC_HIDE_CURSOR EQU     23
ACC_SET_CURSOR_POS      EQU     24
ACC_GET_CURSOR_POS      EQU     25
NBR_MINI_VDD_FUNCTIONS_40       EQU     26
GET_NUM_UNITS   EQU     26
SET_ADAPTER_POWER_STATE EQU     27
GET_ADAPTER_POWER_STATE_CAPS    EQU     28
SET_MONITOR_POWER_STATE EQU     29
GET_MONITOR_POWER_STATE_CAPS    EQU     30
GET_MONITOR_INFO        EQU     31
NBR_MINI_VDD_FUNCTIONS_41       EQU     32
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
else
REGISTER_DISPLAY_DRIVER EQU     0
GET_VDD_BANK    EQU     1
SET_VDD_BANK    EQU     2
RESET_BANK      EQU     3
PRE_HIRES_TO_VGA        EQU     4
POST_HIRES_TO_VGA       EQU     5
PRE_VGA_TO_HIRES        EQU     6
POST_VGA_TO_HIRES       EQU     7
SAVE_REGISTERS  EQU     8
RESTORE_REGISTERS       EQU     9
MODIFY_REGISTER_STATE   EQU     10
ACCESS_VGA_MEMORY_MODE  EQU     11
ACCESS_LINEAR_MEMORY_MODE       EQU     12
ENABLE_TRAPS    EQU     13
DISABLE_TRAPS   EQU     14
MAKE_HARDWARE_NOT_BUSY  EQU     15
VIRTUALIZE_CRTC_IN      EQU     16
VIRTUALIZE_CRTC_OUT     EQU     17
VIRTUALIZE_SEQUENCER_IN EQU     18
VIRTUALIZE_SEQUENCER_OUT        EQU     19
VIRTUALIZE_GCR_IN       EQU     20
VIRTUALIZE_GCR_OUT      EQU     21
SET_LATCH_BANK  EQU     22
RESET_LATCH_BANK        EQU     23
SAVE_LATCHES    EQU     24
RESTORE_LATCHES EQU     25
DISPLAY_DRIVER_DISABLING        EQU     26
SELECT_PLANE    EQU     27
PRE_CRTC_MODE_CHANGE    EQU     28
POST_CRTC_MODE_CHANGE   EQU     29
VIRTUALIZE_DAC_OUT      EQU     30
VIRTUALIZE_DAC_IN       EQU     31
GET_CURRENT_BANK_WRITE  EQU     32
GET_CURRENT_BANK_READ   EQU     33
SET_BANK        EQU     34
CHECK_HIRES_MODE        EQU     35
GET_TOTAL_VRAM_SIZE     EQU     36
GET_BANK_SIZE   EQU     37
SET_HIRES_MODE  EQU     38
PRE_HIRES_SAVE_RESTORE  EQU     39
POST_HIRES_SAVE_RESTORE EQU     40
VESA_SUPPORT    EQU     41
GET_CHIP_ID     EQU     42
CHECK_SCREEN_SWITCH_OK  EQU     43
VIRTUALIZE_BLTER_IO     EQU     44
SAVE_MESSAGE_MODE_STATE EQU     45
SAVE_FORCED_PLANAR_STATE        EQU     46
VESA_CALL_POST_PROCESSING       EQU     47
PRE_INT_10_MODE_SET     EQU     48
NBR_MINI_VDD_FUNCTIONS_40       EQU     49
GET_NUM_UNITS   EQU     49
TURN_VGA_OFF    EQU     50
TURN_VGA_ON     EQU     51
SET_ADAPTER_POWER_STATE EQU     52
GET_ADAPTER_POWER_STATE_CAPS    EQU     53
SET_MONITOR_POWER_STATE EQU     54
GET_MONITOR_POWER_STATE_CAPS    EQU     55
GET_MONITOR_INFO        EQU     56
I2C_OPEN        EQU     57
I2C_ACCESS      EQU     58
GPIO_OPEN       EQU     59
GPIO_ACCESS     EQU     60
COPYPROTECTION_ACCESS   EQU     61
NBR_MINI_VDD_FUNCTIONS_41       EQU     62
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
endif
endif
VDD_QUERY_VERSION       EQU     0
MINIVDD_SVC_BASE_OFFSET EQU     80H
VDD_DRIVER_REGISTER     EQU     (0+MINIVDD_SVC_BASE_OFFSET)
VDD_DRIVER_UNREGISTER   EQU     (1+MINIVDD_SVC_BASE_OFFSET)
VDD_SAVE_DRIVER_STATE   EQU     (2+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_DISPLAY_DRIVER_INFO        EQU     (3+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_SSB_FLAGS  EQU     (4+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG  EQU     (5+MINIVDD_SVC_BASE_OFFSET)
VDD_PRE_MODE_CHANGE     EQU     (6+MINIVDD_SVC_BASE_OFFSET)
VDD_POST_MODE_CHANGE    EQU     (7+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_USER_FLAGS      EQU     (8+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_BUSY_FLAG_ADDR  EQU     (9+MINIVDD_SVC_BASE_OFFSET)
VDD_PC98_RESERVED       EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_VBE_PM      EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_ENABLE      EQU     (11+MINIVDD_SVC_BASE_OFFSET)
VDD_GETMEMBASE  EQU     (12+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN        EQU     (13+MINIVDD_SVC_BASE_OFFSET)
VDD_CLOSE       EQU     (14+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN_KEY    EQU     (15+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_POWER_STATE     EQU     (16+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_POWER_STATE_CAPS        EQU     (17+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG2 EQU     8085H
ENABLE_IO       EQU     00000001H
ENABLE_MEM      EQU     00000002H
ENABLE_VGA      EQU     00000030H
ENABLE_ROM      EQU     00000080H
ENABLE_ALL      EQU     000000FFH
ENABLE_NONE     EQU     00000000H
ENABLE_VALID    EQU     000000FFH
ENABLE_ERROR    EQU     0FFFFFFFFH
VDD_OPEN_EXIST  EQU     00000001H
VDD_OPEN_ENUM   EQU     00000002H
VDD_OPEN_LOCK   EQU     00000000H
VDD_OPEN_TEST   EQU     VDD_OPEN_EXIST
VDD_OPEN_KEY_WRITE      EQU     00000001H
VDD_OPEN_KEY_READ       EQU     00000002H
VDD_OPEN_KEY_USER       EQU     00000010H
VDD_OPEN_KEY_GLOBAL     EQU     00000020H
VDD_IOCTL_SET_NOTIFY    EQU     10000001H
VDD_IOCTL_GET_DDHAL     EQU     10000002H

tagVDD_IOCTL_SET_NOTIFY_INPUT   STRUC
NotifyMask      DD      ?
NotifyType      DD      ?
NotifyProc      DD      ?
NotifyData      DD      ?
tagVDD_IOCTL_SET_NOTIFY_INPUT   ENDS
VDD_NOTIFY_START_MODE_CHANGE    EQU     00000001H
VDD_NOTIFY_END_MODE_CHANGE      EQU     00000002H
VDD_NOTIFY_ENABLE       EQU     00000004H
VDD_NOTIFY_DISABLE      EQU     00000008H
VDD_NOTIFY_TYPE_CALLBACK        EQU     1
BYTE_LENGTHED   EQU     1
WORD_LENGTHED   EQU     2
GOING_TO_WINDOWS_MODE   EQU     1
GOING_TO_VGA_MODE       EQU     2
DISPLAY_DRIVER_DISABLED EQU     4
IN_WINDOWS_HIRES_MODE   EQU     8

DISPLAYINFO     STRUC
diHdrSize       DW      ?
diInfoFlags     DW      ?
diDevNodeHandle DD      ?
diDriverName    DB      16 DUP (?)
diXRes  DW      ?
diYRes  DW      ?
diDPI   DW      ?
diPlanes        DB      ?
diBpp   DB      ?
diRefreshRateMax        DW      ?
diRefreshRateMin        DW      ?
diLowHorz       DW      ?
diHighHorz      DW      ?
diLowVert       DW      ?
diHighVert      DW      ?
diMonitorDevNodeHandle  DD      ?
diHorzSyncPolarity      DB      ?
diVertSyncPolarity      DB      ?
diUnitNumber    DD      ?
diDisplayFlags  DD      ?
diXDesktopPos   DD      ?
diYDesktopPos   DD      ?
diXDesktopSize  DD      ?
diYDesktopSize  DD      ?
DISPLAYINFO     ENDS
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize

RETURNED_DATA_IS_STALE  EQU     0001H
MINIVDD_FAILED_TO_LOAD  EQU     0002H
MINIVDD_CHIP_ID_DIDNT_MATCH     EQU     0004H
REGISTRY_BPP_NOT_VALID  EQU     0008H
REGISTRY_RESOLUTION_NOT_VALID   EQU     0010H
REGISTRY_DPI_NOT_VALID  EQU     0020H
MONITOR_DEVNODE_NOT_ACTIVE      EQU     0040H
MONITOR_INFO_NOT_VALID  EQU     0080H
MONITOR_INFO_DISABLED_BY_USER   EQU     0100H
REFRESH_RATE_MAX_ONLY   EQU     0200H
CARD_VDD_LOADED_OK      EQU     0400H
DEVICE_IS_NOT_VGA       EQU     0800H
NoTrace_VIRTUALIZE_CRTC_IN      EQU     1
NoTrace_VIRTUALIZE_CRTC_OUT     EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_IN EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_OUT        EQU     1
NoTrace_VIRTUALIZE_GCR_IN       EQU     1
NoTrace_VIRTUALIZE_GCR_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_IN       EQU     1
NoTrace_CHECK_HIRES_MODE        EQU     1

ifdef NEC_98







vFlg_Machine_Std        equ                     00000001b
vFlg_Machine_Multi      equ                     00000010b
vFlg_Machine_Mate       equ                     00000100b
vFlg_Machine_H98        equ                     00001000b
vFlg_CRT_New            equ                     00010000b
vFlg_CRT_NonInter       equ                     00100000b
vFlg_GDC_5MHz           equ                     01000000b
vFlg_GDC_Emulate        equ                     10000000b
vFlg_Acc_Internal       equ             0000000100000000b
vFlg_Acc_External       equ             0000001000000000b
vFlg_Acc_PCI            equ             0000010000000000b
vFlg_Acc_ML             equ             0000100000000000b
vFlg_Acc_PVD            equ             0001000000000000b
vFlg_Mode_NH            equ             0010000000000000b
vFlg_Mode_H             equ             0100000000000000b
vFlg_Initialized        equ             1000000000000000b
vFlg_Opt_MFR            equ     000000010000000000000000b
vFlg_Opt_NewMFR         equ     000000100000000000000000b
vFlg_Opt_VDP            equ     000001000000000000000000b
vFlg_Opt_NewVDP         equ     000010000000000000000000b

vFlg_Local              equ     000000000100000010000000b




MaxMiniVDD      equ     16
MaxMiniTrap     equ     32
MaxMultiTrap    equ     3
MaxMultiFunc    equ     MaxMiniVDD





LT_Enable       equ     00000001b
LT_Enable_bit   equ     0
LT_Initialized  equ     10000000b
LT_Initialized_bit equ  7










Vids_struct struc



        Vids_SFlags             dd      ?
        Vids_CB_Offset          dd      ?
        Vids_Msg_Pseudo_VM      dd      ?




        VDD_TGDC_Draw_Off       dd      ?
        VDD_TGDC_Sync_Off       dd      ?
        VDD_TGDC_Sync_On        dd      ?
        VDD_TGDC_FIFO_Empty     dd      ?
        VDD_GGDC_Draw_Off       dd      ?
        VDD_GGDC_Sync_Off       dd      ?
        VDD_GGDC_Sync_On        dd      ?
        VDD_GGDC_FIFO_Empty     dd      ?
        VDD_GGDC_MOD_Emulate    dd      ?




        H98_FLORA_Change        dd      ?
        H98_Clear_Text          dd      ?
        H98_Rest_GCs            dd      ?
        H98_Rest_etc            dd      ?
        H98_Save_ModeFF         dd      ?

Vids_struct ends


Vid_SFlags              equ     <Vids.Vids_SFlags>
VDD_CB_Offset           equ     <Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM       equ     <Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off           equ     <Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off           equ     <Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On            equ     <Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off           equ     <Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty         equ     <Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty         equ     <Vids.VDD_GGDC_FIFO_Empty>





MiniFuncStruct  STRUC
MF_ProcAddr     dd      ?



MiniFuncStruct  ENDS




MiniVDD_Proc_Struct     STRUC
Proc_Address    dd      ?
Proc_Order      dw      ?
Proc_MiniID     db      ?
Proc_Flags      db      ?
MiniVDD_Proc_Struct     ENDS
.errnz  (size MiniVDD_Proc_Struct) mod 4





MiniVDD_GTrap_Struct    STRUC
GTrap_ProcAddr  dd      ?
GTrap_PortAddr  dw      ?
GTrap_NumMini   dw      ?
GTrap_ProcTable db      ((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct    ENDS

MiniVDD_LTrap_Struct    STRUC
LTrap_ProcAddr  dd      ?
LTrap_Status    db      ?
LTrap_Flags     db      MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct    ENDS












EndMiniFunc_    MACRO   n
ifdef   MiniFunc&n
        dd      OFFSET32 MiniFunc&n
else
        dd      0
endif
                ENDM

MiniFunc_       MACRO   FuncID, FuncName
                MiniFunc&FuncID equ <FuncName>
                ENDM

BeginMiniFunc   MACRO   TableName
public  TableName
TableName       label   near
                ENDM

if 1
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS_41
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
else
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
endif

MiniFunc        MACRO   FuncID, FuncName
                MiniFunc_ %(FuncID), <FuncName>
                ENDM




MiniVDDCall     MACRO   FuncID, SetCarry
                local   MiniCall_Loop
                local   MiniCall_Exit

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                mov     ecx, [MiniVDD_NumMini]
MiniCall_Loop:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
                jc      MiniCall_Exit
                add     esi, size MiniVDD_Proc_Struct
                loop    MiniCall_Loop
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall2    MACRO   FuncID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall3    MACRO   FuncID, MiniID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Loop
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                movzx   ecx, MiniID
MiniCall_Loop:
                cmp     ecx, 0
                jz      MiniCall_Proc
                add     esi, size MiniVDD_Proc_Struct
                dec     ecx
                jmp     MiniCall_Loop
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM




MiniVDDFunc     MACRO   TmpReg, FuncID
                mov     TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                ENDM











ExecModeLL      macro   Num
ExecMode_L&Num:
                endm

ExecModeLE      macro   Num
ExecMode_E&Num:
                endm

ExecModeJE      macro   Num
        jmp     ExecMode_E&Num
                endm

ExecModeJZ      macro   Num
        jz      ExecMode_L&Num
                endm

ExecModeJNZ     macro   Num
        jnz     ExecMode_L&Num
                endm

ExecModeJEZ     macro   Num
        jz      ExecMode_E&Num
                endm

ExecModeJENZ    macro   Num
        jnz     ExecMode_E&Num
                endm


ExecModeTest    macro   ModeFlag, CB_Reg
if      ModeFlag and vFlg_Local
ifidni  <CB_Reg>, <Vid>
        push    ebx
        mov     ebx, [Vid_VM_Handle]
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifidni  <CB_Reg>, <Cur>
        push    ebx
        VMMCall Get_Cur_VM_Handle
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifb     <CB_Reg>
        push    ebx
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
        test    [CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
        test    [Vid_SFlags], ModeFlag
endif
        endm


ExecModeChk     macro   HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni  <HdrFlag>, <Jmp>
.erre   FlgExecMode
        ExecModeJE      %EndExecMode
endif
ExecModeLL      %NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb    <ModeFlag>
        ExecModeTest    <ModeFlag>, <CB_Reg>
ifidni  <JmpLabel>, <End>
ifidni  <JmpFlag>, <Not>
        ExecModeJENZ    %EndExecMode
else
        ExecModeJEZ     %EndExecMode
endif
else
ifidni  <JmpFlag>, <Not>
        ExecModeJNZ     %NumExecMode
else
        ExecModeJZ      %NumExecMode
endif
endif
endif
                endm

ExecModeEnd     macro
ExecModeLL      %NumExecMode
ExecModeLE      %EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
                endm





ExecModeJmp     macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jnz     JmpLabel
                endm

ExecModeJmpNot  macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jz      JmpLabel
                endm

ExecMode        macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeNot     macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeOnly    macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
                endm

ExecModeOnlyNot macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
                endm

ExecModeElse    macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeElseNot macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeThru    macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeThruNot macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
                endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else




ifdef MAINVDD
externdef       MiniVDDDispatchTable:dword
endif


MiniVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm


CardVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm


MiniVDDCall             macro   FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi
ifnb    <SaveFlags>
        pushfd
endif
        mov     edi,OFFSET32 MiniVDDDispatchTable
        cmp     dword ptr [edi+(FunctionCode*4)],0
        je      MiniVDDCallLeave
ifnb    <SaveFlags>
        popfd
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb    <SaveFlags>
        jmp     MiniVDDCallExit
endif

MiniVDDCallLeave:
ifnb    <SaveFlags>
        popfd
endif

MiniVDDCallExit:
        pop     edi
endm
endif

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MTRR.INC ===
ifndef  _MTRR_H_
_MTRR_H_        EQU     1
MTRR_Ver_Major  EQU     01H
MTRR_Ver_Minor  EQU     00H
MTRR_DEVICE_ID  EQU     <DDS_DEVICE_ID>
MmNonCached     EQU     0
MmCached        EQU     1
MmFrameBufferCached     EQU     2
MmHardwareCoherentCached        EQU     3
MmMaximumCacheType      EQU     4
Begin_Service_Table MTRR, VxD
MTRR_Service             _MTRR_Get_Version, LOCAL
MTRR_StdCall_Service     MTRRSetPhysicalCacheTypeRange, 4
End_Service_Table MTRR, VxD
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MMDEVLDR.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*
 *  MMDEVLDR.H - The main include file for the DevLoader
 *
 *  Version 4.00
 *
 */

#define Multimedia_OEM_ID   0x0440	//            ; MS Reserved OEM # 34
#define MMDEVLDR_DEVICE_ID  Multimedia_OEM_ID + 10 	//;MMDEVLDR's device ID

#ifdef Begin_Service_Table		// define only if vmm.h is included

#define	MMDEVLDR_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning

//MACROS
Begin_Service_Table(MMDEVLDR)

MMDEVLDR_Service	(MMDEVLDR_Register_Device_Driver, LOCAL)
MMDEVLDR_Service	(MMDEVLDR_SetDevicePresence)
MMDEVLDR_Service  (MMDEVLDR_SetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_GetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_RemoveEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_AddEnvironmentString)

End_Service_Table(MMDEVLDR)
//ENDMACROS       

#pragma warning (default:4003)		// turn on not enough params warning

#pragma warning (disable:4035)		// turn off no return code warning

VOID VXDINLINE MMDEVLDR_Register_Device_Driver
(
    DEVNODE         dnDevNode,
    DWORD           fnConfigHandler,
    DWORD           dwUserData
)
{
    _asm push ebx
    _asm mov eax,dnDevNode
    _asm mov ebx,fnConfigHandler
    _asm mov ecx,dwUserData
    VxDCall(MMDEVLDR_Register_Device_Driver);
    _asm pop ebx
}

VOID VXDINLINE MMDEVLDR_SetDevicePresence
(
    DEVNODE         dn,
    PCHAR           pszReg,
    BOOL            fPresent
)
{
    _asm push fPresent
    _asm push pszReg
    _asm push dn
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetDevicePresence);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_SetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetEnvironmentString);
    _asm add  esp, 2*4
} ;

BOOL VXDINLINE MMDEVLDR_GetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue,
    UINT            uBufSize
)
{
    _asm push uBufSize
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_GetEnvironmentString);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_RemoveEnvironmentString
(
    PCHAR           pszName
)
{
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_RemoveEnvironmentString);
    _asm add  esp, 4
} ;

VOID VXDINLINE MMDEVLDR_AddEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_AddEnvironmentString);
    _asm add  esp, 2*4
} ;

#pragma warning (disable:4035)		// turn on no return code warning

#endif // Begin_Service_Table
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\PAGESWAP.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	PageSwap.Inc - Demand Paging Swap Device Services
;
;   Version:	1.00
;
;   Date:	18-Oct-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   18-Oct-1988 RAL Original
;   19-Oct-1990 JEM Added Buffer Descriptor structure
;
;==============================================================================


Begin_Service_Table PageSwap

PageSwap_Service PageSwap_Get_Version, LOCAL
PageSwap_Service PageSwap_Test_Create, LOCAL
PageSwap_Service PageSwap_Create, LOCAL
PageSwap_Service PageSwap_Destroy, LOCAL
PageSwap_Service PageSwap_In, LOCAL
PageSwap_Service PageSwap_Out, LOCAL
PageSwap_Service PageSwap_Test_IO_Valid, LOCAL

End_Service_Table PageSwap

PS_Zero_Init_Mask	EQU	0001h
PS_Zero_Init_Bit	EQU	00h
PS_Fixed_Page_Mask	EQU	0008h
PS_Fixed_Page_Bit	EQU	03h
PS_First_Page_In_Mask	EQU	0020h
PS_First_Page_In_Bit	EQU	05h
PS_Dirty_Mask		EQU	0040h
PS_Dirty_Bit		EQU	06h
PS_Ever_Dirty_Mask	EQU	8000h
PS_Ever_Dirty_Bit	EQU	0Fh

PS_NoXchg_Mask		EQU	80000000h
PS_NoXchg_Bit		EQU	1Fh	; DO NOT xchg phys addrs on PageSwap_Out


; Buffer descriptor for asynchronous I/O

SIZE_PS_BD_RESERVED EQU 44

PageSwapBufferDesc	STRUC
PS_BD_Next		dd	?
PS_BD_List		dw	?
PS_BD_Cmd		db	?
PS_BD_Priority		db	?
PS_BD_Page_Number	dd	?
PS_BD_Buffer_Ptr	dd	?
PS_BD_File_Page 	dd	?
PS_BD_Call_Back 	dd	?
PS_BD_Reserved		db SIZE_PS_BD_RESERVED dup (?)
PageSwapBufferDesc	ENDS

; List values for PS_BD_List

PS_BDL_Free		EQU	1
PS_BDL_Pending_WB	EQU	2
PS_BDL_Submitted_RA	EQU	3
PS_BDL_Locked		EQU	4

PS_BDP_Invalid_Data	EQU	-1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MMDEVLDR.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;******************************************************************************
TITLE mmdevldr.inc - Windows/386 MMSYSTEM Device loader DLVxD include file
;******************************************************************************
;
;   Title:  mmdevldr.INC - Windows/386 Config Manager DLVxD DEVLOADER for MMSYSTEM
;
;   Version:    1.00
;
;==============================================================================
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID           equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_Ver_Major           equ 1                ; version 1.0 of this VxD
MMDEVLDR_Ver_Minor           equ 0

ifdef DDB_Sys_Crit_Init_Done
 
Begin_Service_Table	MMDEVLDR
	MMDEVLDR_Service	MMDEVLDR_Register_Device_Driver, LOCAL
	MMDEVLDR_Service	_MMDEVLDR_SetDevicePresence
        MMDEVLDR_Service        _MMDEVLDR_SetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_GetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_RemoveEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_AddEnvironmentString
End_Service_Table MMDEVLDR	

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MTRR.H ===
#ifndef	_MTRR_H_
#define	_MTRR_H_

#define	MTRR_Ver_Major	0x01
#define	MTRR_Ver_Minor	0x00

#define	MTRR_DEVICE_ID	DDS_DEVICE_ID

/*INT32*/

/*XLATOFF*/
#define MTRR_Service	Declare_Service
#define MTRR_StdCall_Service Declare_SCService
#pragma	warning (disable:4003)

/*XLATON*/

#define		MmNonCached			0
#define		MmCached			1
#define		MmFrameBufferCached		2
#define		MmHardwareCoherentCached        3
#define		MmMaximumCacheType		4

/*MACROS*/
Begin_Service_Table(MTRR, VxD)

MTRR_Service		(_MTRR_Get_Version, LOCAL)
MTRR_StdCall_Service    (MTRRSetPhysicalCacheTypeRange, 4)

End_Service_Table(MTRR, VxD)

/*ENDMACROS*/

/*XLATOFF*/

WORD VXDINLINE
MTRRGetVersion() {

   WORD w;
   VxDCall(_MTRR_Get_Version);
   _asm mov [w], ax;
   return (w);

}

ULONG VXDINLINE
MTRRSetPhysicalCacheTypeRange(
   PVOID PhysicalAddress,
   ULONG NumberOfBytes,
   MEMORY_CACHING_TYPE CacheType) {

   ULONG	ulResult;

   _asm push CacheType;
   _asm push NumberOfBytes;
   _asm push 0;
   _asm push PhysicalAddress;
   VxDCall(MTRRSetPhysicalCacheTypeRange);
   _asm	mov [ulResult], eax;
   
   return (ulResult);
}

/*XLATON*/

#endif // ifndef _MTRR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\OPTTEST.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	OPTTEST.INC - Macros to optimize test instructions
;
;   Version:	1.00
;
;   Date:	28-Jun-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   28-Jun-1990 RAL
;
;==============================================================================


TestMem MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	test	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	test	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	test	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	test	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	test	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	test	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	test	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	test	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM





TestReg MACRO R, Mask

_@TR MACRO Ltr
IFE (Mask) AND 0FFFFFF00h
	test	Ltr&&l, Mask
ELSE
IFE (Mask) AND 0FFFF00FFh
	test	Ltr&&h, ((Mask) SHR 8)
ELSE
IFE (Mask) AND 0FFFF0000h
	test	Ltr&&x, Mask
ELSE
	test	e&&Ltr&&x, Mask
ENDIF
ENDIF
ENDIF
	ENDM


IFIDNI <R>, <EAX>
	_@TR a, Mask
ELSE
IFIDNI <R>, <EBX>
	_@TR b, Mask
ELSE
IFIDNI <R>, <ECX>
	_@TR c, Mask
ELSE
IFIDNI <R>, <EDX>
	_@TR d, Mask
ELSE
IFIDNI <R>, <ESI>
IFE (Mask) AND 0FFFF0000h
	test	si, Mask
ELSE
	test	esi, Mask
ENDIF
ELSE
IFIDNI <R>, <EDI>
IFE (Mask) AND 0FFFF0000h
	test	di, Mask
ELSE
	test	edi, Mask
ENDIF
ELSE
%OUT ERROR:  Bad param to TestReg macro
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM




SetFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	or	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	or	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	or	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	or	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	or	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	or	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	or	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	or	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM



ClrFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	and	BYTE PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FFFF00FFh
	and	BYTE PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	and	BYTE PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	and	BYTE PTR [MemPtr+3], NOT ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	and	WORD PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FF0000FFh
	and	WORD PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	and	WORD PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
	and	DWORD PTR [MemPtr], NOT (M)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\STDDEF.H ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value and the offset() macro */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#define offsetof(s,m)   (size_t)&(((s *)0)->m)


/* Declare reference to errno */

#if     (defined(_MT) || defined(_DLL)) && !defined(_MAC)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifdef  _MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern unsigned long  __cdecl __threadhandle(void);
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\V86MMGR.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;******************************************************************************
;
;   Title:	V86MMGR.Inc - Public services for V86MMGR
;
;   Version:	2.00
;
;==============================================================================

Begin_Service_Table V86MMGR

V86MMGR_Service 	V86MMGR_Get_Version,		LOCAL
V86MMGR_Service 	V86MMGR_Allocate_V86_Pages,	LOCAL
V86MMGR_Service 	V86MMGR_Set_EMS_XMS_Limits,	LOCAL
V86MMGR_Service 	V86MMGR_Get_EMS_XMS_Limits,	LOCAL
;
;   Services used for API mapping.
;
V86MMGR_Service 	V86MMGR_Set_Mapping_Info, VxD_ICODE
V86MMGR_Service 	V86MMGR_Get_Mapping_Info
V86MMGR_Service 	V86MMGR_Xlat_API
V86MMGR_Service 	V86MMGR_Load_Client_Ptr
V86MMGR_Service 	V86MMGR_Allocate_Buffer
V86MMGR_Service 	V86MMGR_Free_Buffer
V86MMGR_Service 	V86MMGR_Get_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Set_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Get_VM_Flat_Sel
V86MMGR_Service 	V86MMGR_Map_Pages
V86MMGR_Service 	V86MMGR_Free_Page_Map_Region
;***********************************************************
;  END OF 3.00 level services
;
V86MMGR_Service 	V86MMGR_LocalGlobalReg
V86MMGR_Service 	V86MMGR_GetPgStatus,		LOCAL
V86MMGR_Service 	V86MMGR_SetLocalA20,		VxD_ICODE
V86MMGR_Service 	V86MMGR_ResetBasePages, 	LOCAL
V86MMGR_Service 	V86MMGR_SetAvailMapPgs, 	VxD_ICODE
V86MMGR_Service 	V86MMGR_NoUMBInitCalls, 	VxD_ICODE

IFNDEF	WIN31COMPAT

;   Services added post Win 3.1
V86MMGR_Service         V86MMGR_Get_EMS_XMS_Avail,      LOCAL
V86MMGR_Service         V86MMGR_Toggle_HMA
V86MMGR_Service 	V86MMGR_Dev_Init,		LOCAL
V86MMGR_Service 	V86MMGR_Alloc_UM_Page,		LOCAL

ENDIF ;	WIN31COMPAT


End_Service_Table V86MMGR

;
; BITS of returned EAX flags for V86MMGR_GetPgStatus
;
V86PS_ROM       equ     0000000000000001b       ; Page contains global ROM
V86PS_RAM       equ     0000000000000010b       ; Page contains global RAM
V86PS_EMM	equ	0000000010000000b	; Page belongs to EMM driver
V86PS_XMS	equ	0000000100000000b	; Page belongs to XMS driver
V86PS_MAP	equ	0000001000000000b	; Page belongs to mapper
V86PS_UMB       equ     0001000000000000b       ; Page contains imported UMB
                                                ;  (Note that V86PS_XMS is not
                                                ;   necessarily set)

;
; BITS of ECX flags for V86MMGR_Allocate_V86_Pages
;
AV86PLocked			EQU	00000000000000000000000000000001B
AV86PLockedBit			EQU	0	; VM memory is to be
						;   ALWAYS LOCKED regardless of
						;   pager type or whether VM
						;   is suspended.
;
; BITS of ECX flags for V86MMGR_Set_EMS_XMS_Limits
;
; NOTE: If neither Limit_DisableHMA or Limit_EnableHMA is set, the HMA
;	state is not altered.
;
EMS_XMS_Limit_DisableHMA	EQU	00000000000000000000000000000001B
EMS_XMS_Limit_DisableHMABit	EQU	0
EMS_XMS_Limit_EnableHMA 	EQU	00000000000000000000000000000010B
EMS_XMS_Limit_EnableHMABit	EQU	1
EMS_XMS_Limit_XMS_Is_Locked	EQU	00000000000000000000000000000100B
EMS_XMS_Limit_XMS_Is_LockedBit	EQU	2
EMS_XMS_Limit_EMS_Is_Locked	EQU	00000000000000000000000000001000B
EMS_XMS_Limit_EMS_Is_LockedBit	EQU	3



;
;   API mapper equates and macros
;

Xlat_Exec_Int	    EQU     000h
Xlat_Fixed_Len	    EQU     001h
Xlat_Var_Len	    EQU     002h
Xlat_Calc_Len	    EQU     003h
Xlat_ASCIIZ	    EQU     004h
Xlat_Jmp_To_Proc    EQU     005h
Xlat_Return_Ptr     EQU     006h
Xlat_Return_Seg     EQU     007h
Xlat_ASCIIZ_InOut   EQU     008h


Xlat_API_Exec_Int MACRO Int_Number
	db	Xlat_Exec_Int
	db	Int_Number
	ENDM

Xlat_API_Fixed_Len MACRO Ptr_Seg, Ptr_Off, Length
	db	Xlat_Fixed_Len
	dw	Length
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Var_Len MACRO Ptr_Seg, Ptr_Off, Len_Reg
	db	Xlat_Var_Len
	db	Client_&Len_Reg
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Calc_Len MACRO Ptr_Seg, Ptr_Off, Calc_Proc_Addr
	db	Xlat_Calc_Len
	dd	OFFSET32 Calc_Proc_Addr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ_InOut  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ_InOut
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Jmp_To_Proc MACRO Proc_Name
	db	Xlat_Jmp_To_Proc
	dd	OFFSET32 Proc_Name
	ENDM


Xlat_API_Return_Ptr MACRO Ptr_Seg, Ptr_Off
	db	Xlat_Return_Ptr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Return_Seg MACRO Ptr_Seg
	db	Xlat_Return_Seg
	db	Client_&Ptr_Seg
	ENDM

;
; The V86MMGR does W386_Device_Broadcast call outs. The 'subfunction' number
; for these call outs is contained in the CX register. These are the equates
; for the subfunction numbers.
;
V86CallOut_LclA20forGlblHMA	equ	0	; Should A20 state be local
						;   even if HMA is GLOBAL?
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\SHELL.INC ===
ifndef _SHELL_H
_SHELL_H	EQU	1
ifndef Not_VxD
Begin_Service_Table SHELL
SHELL_Service    SHELL_Get_Version, LOCAL
SHELL_Service    SHELL_Resolve_Contention, LOCAL
SHELL_Service    SHELL_Event, LOCAL
SHELL_Service    SHELL_SYSMODAL_Message, LOCAL
SHELL_Service    SHELL_Message, LOCAL
ifndef WIN30COMPAT
SHELL_Service    SHELL_GetVMInfo, LOCAL
endif
ifndef WIN31COMPAT
SHELL_Service    _SHELL_PostMessage, LOCAL
SHELL_Service    _SHELL_ShellExecute
SHELL_Service    _SHELL_PostShellMessage
SHELL_Service    SHELL_DispatchRing0AppyEvents, LOCAL
SHELL_Service    SHELL_Hook_Properties, LOCAL
SHELL_Service    SHELL_Unhook_Properties, LOCAL
SHELL_Service    SHELL_Update_User_Activity, LOCAL
SHELL_Service    _SHELL_QueryAppyTimeAvailable, LOCAL
SHELL_Service    _SHELL_CallAtAppyTime, LOCAL
SHELL_Service    _SHELL_CancelAppyTimeEvent
SHELL_Service    _SHELL_BroadcastSystemMessage, LOCAL
SHELL_Service    _SHELL_HookSystemBroadcast, LOCAL
SHELL_Service    _SHELL_UnhookSystemBroadcast, LOCAL
SHELL_Service    _SHELL_LocalAllocEx, LOCAL
SHELL_Service    _SHELL_LocalFree, LOCAL
SHELL_Service    _SHELL_LoadLibrary, LOCAL
SHELL_Service    _SHELL_FreeLibrary, LOCAL
SHELL_Service    _SHELL_GetProcAddress, LOCAL
SHELL_Service    _SHELL_CallDll, LOCAL
SHELL_Service	 _SHELL_SuggestSingleMSDOSMode
SHELL_Service	 SHELL_CheckHotkeyAllowed
SHELL_Service	 _SHELL_GetDOSAppInfo
ifdef WIN41SERVICES
SHELL_Service    _SHELL_Update_User_Activity_Ex, LOCAL
endif
endif
End_Service_Table SHELL
ifndef WIN31COMPAT
SBH_CALL_ORDER_DEFAULT	EQU	0
SBH_CALL_ORDER_REGISTRY	EQU	30000000H
SBH_CALL_ORDER_CONFIGMG	EQU	40000000H
SBH_CALL_ORDER_NTKERN	EQU	50000000H
SUUAE_SYSTEM_REQUIRED_BIT	EQU	00000000H
SUUAE_SYSTEM_REQUIRED	EQU	(1 SHL SUUAE_SYSTEM_REQUIRED_BIT)
SUUAE_DISPLAY_REQUIRED_BIT	EQU	00000001H
SUUAE_DISPLAY_REQUIRED	EQU	(1 SHL SUUAE_DISPLAY_REQUIRED_BIT)
SUUAE_LOW_LATENCY_BIT	EQU	00000003H
SUUAE_LOW_LATENCY	EQU	(1 SHL SUUAE_LOW_LATENCY_BIT)
SUUAE_CONTINUOUS_CHECK_BIT	EQU	29
SUUAE_CONTINUOUS_CHECK	EQU	(1 SHL SUUAE_CONTINUOUS_CHECK_BIT)
SUUAE_CONTINUOUS_ADD_BIT	EQU	30
SUUAE_CONTINUOUS_ADD	EQU	(1 SHL SUUAE_CONTINUOUS_ADD_BIT)
SUUAE_CONTINUOUS_REMOVE	EQU	0
SUUAE_CONTINUOUS_BIT	EQU	31
SUUAE_CONTINUOUS	EQU	(1 SHL SUUAE_CONTINUOUS_BIT)
endif

_SHELL_SUUAE_INFO	STRUC
ssiTimeLastActiveDisplay	DD	?
ssiTimeLastActiveSystem	DD	?
ssiHoldDisplay	DB	?
ssiHoldSystem	DB	?
ssiLowLatency	DB	?
_SHELL_SUUAE_INFO	ENDS
MB_OK	EQU	00H
MB_OKCANCEL	EQU	01H
MB_ABORTRETRYIGNORE	EQU	02H
MB_YESNOCANCEL	EQU	03H
MB_YESNO	EQU	04H
MB_RETRYCANCEL	EQU	05H
MB_ICONHAND	EQU	10H
MB_ICONEXCLAMATION	EQU	30H
MB_ICONASTERISK	EQU	40H
MB_DEFBUTTON1	EQU	00H
MB_DEFBUTTON2	EQU	100H
MB_DEFBUTTON3	EQU	200H
MB_APPLMODAL	EQU	00H
MB_SYSTEMMODAL	EQU	1000H
MB_NOFOCUS	EQU	8000H
MB_ASAP	EQU	80000000H
MB_NOWINDOW	EQU	40000000H
MB_HANGSYS	EQU	20000000H
ifndef WIN31COMPAT
MB_APPYTIME	EQU	10000000H
endif
IDOK	EQU	1
IDCANCEL	EQU	2
IDABORT	EQU	3
IDRETRY	EQU	4
IDIGNORE	EQU	5
IDYES	EQU	6
IDNO	EQU	7
SE_WP_PrtScBoost	EQU	00100000H
SE_WP_PrtScBoostBit	EQU	20
SE_WP_DispUpdBoost	EQU	00200000H
SE_WP_DispUpdBoostBit	EQU	21
ifndef WIN31COMPAT
SPM_UM_DoNotWaitForCrit	EQU	00020000H
SPM_UM_DoNotWaitForCritBit	EQU	17
SPM_UM_AlwaysSchedule	EQU	00080000H
SPM_UM_AlwaysScheduleBit	EQU	19
endif
SGVMI_Windowed	EQU	00000004H
SGVMI_ALTTABdis	EQU	00000020H
SGVMI_ALTESCdis	EQU	00000040H
SGVMI_ALTSPACEdis	EQU	00000080H
SGVMI_ALTENTERdis	EQU	00000100H
SGVMI_ALTPRTSCdis	EQU	00000200H
SGVMI_PRTSCdis	EQU	00000400H
SGVMI_CTRLESCdis	EQU	00000800H
SGVMI_HasHotKey	EQU	00004000H
SGVMI_Polling	EQU	00001000H
SGVMI_FastPaste	EQU	00020000H
SGVMI_NoHMA	EQU	00002000H
SGVMI_XMS_Lock	EQU	00010000H
SGVMI_EMS_Lock	EQU	00008000H
SGVMI_V86_Lock	EQU	00040000H
SGVMI_ClsExit	EQU	40000000H
endif
ifndef WIN31COMPAT
ifndef Not_VxD
LMEM_FIXED	EQU	0000H
LMEM_ZEROINIT	EQU	0040H
LPTR	EQU	(LMEM_FIXED OR LMEM_ZEROINIT)
LMEM_STRING	EQU	00010000H
LMEM_OEM2ANSI	EQU	00020000H
QAAFL_APPYAVAIL	EQU	00000001H
QAAFL_APPYNOW	EQU	00000002H
CAAFL_RING0	EQU	00000001H
CAAFL_TIMEOUT	EQU	00000002H
endif

SHEXPACKET	STRUC
shex_dwTotalSize	DD	?
shex_dwSize	DD	?
shex_ibOp	DD	?
shex_ibFile	DD	?
shex_ibParams	DD	?
shex_ibDir	DD	?
shex_dwReserved	DD	?
shex_nCmdShow	DD	?
SHEXPACKET	ENDS
SGDAIF_COMPARENAME	EQU	0
SGDAIF_TESTAPPBIT	EQU	1
SGDAIF_LASTVALID	EQU	1
SGDAIR_SUCCESS	EQU	0
SGDAIR_NOMATCH	EQU	1
SGDAIR_BADFUNCTION	EQU	2
endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\SHELLFSC.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	SHELLFSC.Inc - EQUATES related to the File Sys Change stuff
;
;   Version:	1.00
;
;   Date:	19-Sep-1988
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Sep-1988 ARR Original
;
;==============================================================================

VDA_FileSysChange	EQU	0400H+20+11

;
; On VDA_FileSysChange, wParam is not used
;   Particular VMDOSAPP instance which gets the message is the VM that has
;   changed the file system
;
; NOTE THERE MUST BE A CALL BACK ON THIS EVENT.
;
; The reference data MUST BE A pointer to a structure of the following type:
;
; It is the responsibility of the caller to "FREE" this structure (if needed)
;   on the call back.
;
; Caller can extend this structure if needed by tacking extra info on the end.
;
MAXFSCINFOSIZE		EQU	256

VMDA_FileSysChng  STRUC
VMDA_FSC_Func		dw	?
VMDA_FSC_Buffer 	db	MAXFSCINFOSIZE DUP(?)
VMDA_FileSysChng  ENDS

;
; equates for VMDA_FSC_Func
;
VMDA_FSC_CREATE 	EQU	0
VMDA_FSC_DELETE 	EQU	1
VMDA_FSC_RENAME 	EQU	2
VMDA_FSC_ATTRIBUTES	EQU	3
VMDA_FSC_NETCONNECT	EQU	4
VMDA_FSC_NETDISCONNECT	EQU	5
VMDA_FSC_REFRESH	EQU	6
VMDA_FSC_MKDIR		EQU	7
VMDA_FSC_RMDIR		EQU	8
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VERSION.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

#define OFFICIAL   1 
#define FINAL      1 

/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include "ver.h"
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/

#ifndef FROSTING
/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
/* NVidia's definitions for these live in nvver.h
#ifndef WIN32
#define VERSION                     "4.02.100"
#endif                            
#define VER_PRODUCTVERSION_STR      "4.02.100\0"
#define VER_PRODUCTVERSION          4,02,0,100
#define VER_PRODUCTVERSION_DW       (0x0402000 | 100)
*/
#else
/*--------------------------------------------------------------*/
/* FROSTING Builds will need a higher version # than Windows 95 */
/*--------------------------------------------------------------*/
#ifndef WIN32
#define VERSION                     "4.05"
#endif
#define VER_PRODUCTVERSION_STR      "4.05\0"
#define VER_PRODUCTVERSION          4,05,0,000
#define VER_PRODUCTVERSION_DW       (0x04050000 | 000)
#endif

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#ifndef FROSTING
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#else
#define VER_PRODUCTNAME_STR         "Microsoft\256  Plus!  for  Windows\256  95\0"
#endif

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VDD.H ===
#ifndef _VDD_H_
#define _VDD_H_
/************ Operating System Interface for NVidia Hardware ***************\
*                                                                           *
* Module: VDD.H                                                             *
*       Header file for Virtual Display device.                             *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)      7/22/95 - wrote it                   *
*                                                                           *
\*********************** Copyright 1995 NVidia, Inc. ***********************/
//***************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title: minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:   4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//      the general include area.  Added services are ONLY for the
//      use of the Mini-VDD and should therefore not be documented.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------
//
// VDD services.
//
#define VDD_Get_Version                     0x0000  // Get version number and ID string ptr
#define VDD_PIF_State                       0x0001  // Pass video PIF bits to VDD
#define VDD_Get_GrabRtn                     0x0002  // Get routine addr for video grab
#define VDD_Hide_Cursor                     0x0003  // Hide cursor when display is windowed
#define VDD_Set_VMType                      0x0004  // Set VM type(windowed, bckgrnd, excl)
#define VDD_Get_ModTime                     0x0005  // Return system time of last mod
#define VDD_Set_HCurTrk                     0x0006  // Track horiz cursor movement in window
#define VDD_Msg_ClrScrn                     0x0007  // Clear screen for sysmodal message
#define VDD_Msg_ForColor                    0x0008  // Set Msg_TextOut forground color
#define VDD_Msg_BakColor                    0x0009  // Set Msg_TextOut background color
#define VDD_Msg_TextOut                     0x000A  // Output a string
#define VDD_Msg_SetCursPos                  0x000B  // Set cursor position
#define VDD_Query_Access                    0x000C  // Is it OK to access video now?
#define VDD_Check_Update_Soon               0x000D  // User action may update screen
#define VDD_Get_Mini_Dispatch_Table         0x000E  // Get addr of dispatch table to mini-VDD
#define VDD_Register_Virtual_Port           0x000F  // Mini-VDD asks us to setup I/O trap
#define VDD_Get_VM_Info                     0x0010  // Returns CRTC owner and MemC owners
                                                    // and other special VM handles
#define VDD_Get_Special_VM_IDs              0x0011  // returns planar & msg mode IDs
#define VDD_Register_Extra_Screen_Selector  0x0012  // allows display driver to use second
                                                    // screen selector for block moves
#define VDD_Takeover_VGA_Port               0x0013  //allows MiniVDD to takeover a port
                                                    // in range 3C0H through 3DFH
#define VDD_Get_DISPLAYINFO                 0x0014  //get DISPLAYINFO data structure
#define VDD_Do_Physical_IO                  0x0015  //perform physical I/O for trapped port
#define VDD_Set_Sleep_Flag_Addr             0x0016  //when display driver can't be interrupted
//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9 | MINIVDD_SVC_BASE_OFFSET)
typedef struct
{
    WORD  HdrSize;
    WORD  InfoFlags;
    DWORD DevNodeHandle;
    BYTE  DriverName[16];
    WORD  XRes;
    WORD  YRes;
    WORD  DPI;
    BYTE  Planes;
    BYTE  Bpp;
    WORD  RefreshRateMax;
    WORD  RefreshRateMin;
    WORD  LowHorz;
    WORD  HighHorz;
    WORD  LowVert;
    WORD  HighVert;
    DWORD MonitorDevNodeHandle;
    BYTE  HorzSyncPolarity;
    BYTE  VertSyncPolarity;
} DISPLAYINFO, * PDISPLAYINFO;
//
// Following are values and explanations for the diInfoFlags word in DISPLAYINFO:
//
// RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
// or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
// program would get the DISPLAYINFO structure returned to him) caused the VDD
// to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
// insted of actually going out and reading "fresh" data from the Registry.
//
// This flag brings to light the fact that there are some circumstances when the
// VDD cannot go out and read the registry in response to the call to
// VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
// considerations).  In this case, this flag will be set to a 1 to indicate that
// the information being returned isn't "fresh" -- that is -- it may be
// incorrect and obsolete.  The caller should respond accordingly if this flag
// is set.
//
#define RETURNED_DATA_IS_STALE          0x0001
//
// MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
// that the MiniVDD didn't match the chipset installed in the machine), the
// MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
#define MINIVDD_FAILED_TO_LOAD          0x0002
//
// MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
// successfully, when the ChipID that the MiniVDD calculated was compared
// against the value saved in the registry, they didn't match.  An example of
// when this would happen is when the user is happily using an S3-911 card
// and then decides to upgrade his display card to an S3-864.  Since both
// cards use S3.VXD, the MiniVDD will load, however, since the card model
// is different, the VDD will return a defect to configuration manager and
// set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
// flag to take appropriate actions to make sure that the user gets his
// configuration correct.
//
#define MINIVDD_CHIP_ID_DIDNT_MATCH     0x0004
//
// REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
// from the registry when the VDD tried to read it.
//
#define REGISTRY_BPP_NOT_VALID          0x0008
//
// REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
// resolution value from the registry when the VDD tried to read it.
//
#define REGISTRY_RESOLUTION_NOT_VALID   0x0010
//
// REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
// DPI value from the registry when the VDD tried to read it.
//
#define REGISTRY_DPI_NOT_VALID          0x0020
//
// MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
// GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
// This is certainly not fatal by any means.  It simply means that the
// monitor refresh rate info in the DISPLAYINFO data structure is totally
// invalid!
//
#define MONITOR_DEVNODE_NOT_ACTIVE      0x0040
//
// MONITOR_INFO_NOT_VALID indicates that something within the code which
// retrieves and calculates the refresh rate data has failed.  This indicates
// that the values in diRefreshRateMax through diVertSyncPolarity are not
// valid and could contain random data.
//
#define MONITOR_INFO_NOT_VALID          0x0080
//
// MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
// string in SYSTEM.INI had a negative number in it or that the string in
// the display's software key (HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate)
// was 0 or a negative number.
//
#define MONITOR_INFO_DISABLED_BY_USER   0x0100
//
// REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
// diLowVert, diHighVert, or sync polarity data in the registry.    The
// value returned in diRefreshRateMax is the only refresh rate data that
// we have available.  This was derived either from RefreshRate= in SYSTEM.INI
// or the HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate = string in the
// registry.
//
#define REFRESH_RATE_MAX_ONLY           0x0200
//
// CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
// display card manufacturers wishing to extend the capabilities of the chip level
// MiniVDD's ) has successfully been loaded and initialized.
//
#define CARD_VDD_LOADED_OK              0x0400

#endif // _VDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VDD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	vdd.inc - VDD definitions for other VxD's and multiple VDD's
;
;   Version:	1.00
;
;   Date:
;
;   Author: AR, MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jan-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD

;***************
;VDD protect mode services for other devices and VMM(Get_Version must be first)
;
VDD_Service	VDD_Get_Version 	; Get version number and ID string ptr
VDD_Service	VDD_PIF_State		; Pass video PIF bits to VDD
VDD_Service	VDD_Get_GrabRtn 	; Get routine addr for video grab
VDD_Service	VDD_Hide_Cursor 	; Hide cursor when display is windowed
VDD_Service	VDD_Set_VMType		; Set VM type(windowed, bckgrnd, excl)
VDD_Service	VDD_Get_ModTime 	; Return system time of last mod
VDD_Service	VDD_Set_HCurTrk 	; Track horiz cursor movement in window
VDD_Service	VDD_Msg_ClrScrn 	; Clear screen for sysmodal message
VDD_Service	VDD_Msg_ForColor	; Set Msg_TextOut forground color
VDD_Service	VDD_Msg_BakColor	; Set Msg_TextOut background color
VDD_Service	VDD_Msg_TextOut 	; Output a string
VDD_Service	VDD_Msg_SetCursPos	; Set cursor position
VDD_Service	VDD_Query_Access	; Is it OK to access video now?

; New services for 3.1	Not supported for 3.0 VDD's
;
VDD_Service	VDD_Check_Update_Soon,,VGA31 ; User action may update screen

End_Service_Table VDD

IFDEF VGA31
VDD_VerNum	EQU	030Ah		; version 3, 10
ELSE
VDD_VerNum	=	0300h

IFDEF DEBUG
IFNDEF VGA
IFNDEF EGA
VDD_VerNum = VDD_VerNum + 0FFh
ENDIF ;EGA
ENDIF ;VGA
ENDIF ;DEBUG

ENDIF	;VGA31

;***************
; PIF_State service definitions
;
; These definitions cannot change without changing the PIF editor!!!
;
fVidTxtEmulate	EQU	0001h		; Do INT 10h TTY and cursor emulation
fVidNoTrpTxt	EQU	0002h		; Do not trap text mode apps
fVidNoTrpLRGrfx EQU	0004h		; Do not trap lo res graphics mode apps
fVidNoTrpHRGrfx EQU	0008h		; Do not trap hi res graphics mode apps
fVidTextMd	EQU	0010h		; Allocate text mode mem
fVidLowRsGrfxMd EQU	0020h		; Allocate lo res graphics mode mem
fVidHghRsGrfxMd EQU	0040h		; Allocate hi res graphics mode mem
fVidRetainAllo	EQU	0080h		; Never deallocate once allocated
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VCOMM.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*;***************************************************************************
;
; VCOMM.H
;
; Version:	1.00
;
;============================================================================*/

/* H2INCSWITCHES -d */

#ifndef _VCOMM_H
#define _VCOMM_H

/*XLATOFF*/
#pragma	pack(1)
/*XLATON*/

#ifndef Not_VxD

/*XLATOFF*/
#define	VCOMM_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VCOMM, VxD)

VCOMM_Service	(VCOMM_Get_Version, LOCAL)
VCOMM_Service	(_VCOMM_Register_Port_Driver,LOCAL)
VCOMM_Service	(_VCOMM_Acquire_Port,LOCAL)
VCOMM_Service	(_VCOMM_Release_Port,LOCAL)
VCOMM_Service	(_VCOMM_OpenComm, VxD_CODE)
VCOMM_Service	(_VCOMM_SetCommState, VxD_CODE)
VCOMM_Service	(_VCOMM_GetCommState, VxD_CODE)
VCOMM_Service	(_VCOMM_SetupComm, VxD_CODE)
VCOMM_Service	(_VCOMM_TransmitCommChar, VxD_CODE)
VCOMM_Service	(_VCOMM_CloseComm, VxD_CODE)
VCOMM_Service	(_VCOMM_GetCommQueueStatus, VxD_CODE)
VCOMM_Service	(_VCOMM_ClearCommError, VxD_CODE)
VCOMM_Service	(_VCOMM_GetModemStatus, VxD_CODE)
VCOMM_Service	(_VCOMM_GetCommProperties, VxD_CODE)
VCOMM_Service	(_VCOMM_EscapeCommFunction, VxD_CODE)
VCOMM_Service	(_VCOMM_PurgeComm, VxD_CODE)
VCOMM_Service	(_VCOMM_SetCommEventMask, VxD_CODE)
VCOMM_Service	(_VCOMM_GetCommEventMask, VxD_CODE)
VCOMM_Service	(_VCOMM_WriteComm, VxD_CODE)
VCOMM_Service	(_VCOMM_ReadComm, VxD_CODE)
VCOMM_Service	(_VCOMM_EnableCommNotification, VxD_CODE)
VCOMM_Service	(_VCOMM_GetLastError, VxD_CODE)

VCOMM_Service	(_VCOMM_Steal_Port,LOCAL)

VCOMM_Service	(_VCOMM_SetReadCallBack, VxD_CODE)
VCOMM_Service	(_VCOMM_SetWriteCallBack, VxD_CODE)

VCOMM_Service	(_VCOMM_Add_Port, LOCAL)

/*ENDMACROS*/
#ifndef		WIN31COMPAT
/*MACROS*/

VCOMM_Service	(_VCOMM_GetSetCommTimeouts, VxD_CODE)
VCOMM_Service	(_VCOMM_SetWriteRequest, VxD_CODE)
VCOMM_Service	(_VCOMM_SetReadRequest, VxD_CODE)
VCOMM_Service	(_VCOMM_Dequeue_Request, VxD_CODE)

VCOMM_Service	(_VCOMM_Enumerate_DevNodes, VxD_CODE)

VCOMM_Service	(VCOMM_Map_Win32DCB_To_Ring0, VxD_CODE)
VCOMM_Service	(VCOMM_Map_Ring0DCB_To_Win32, VxD_CODE)

VCOMM_Service	(_VCOMM_Get_Contention_Handler, VxD_CODE)
VCOMM_Service	(_VCOMM_Map_Name_To_Resource, VxD_CODE)
/*ENDMACROS*/
#endif
/*MACROS*/

End_Service_Table(VCOMM, VxD)
/*ENDMACROS*/

#endif

typedef struct _PortFunctions {
	BOOL (*pPortSetCommState)();	/* ptr to PortSetState */
	BOOL (*pPortGetCommState)();	/* ptr to PortGetState */
	BOOL (*pPortSetup)();		/* ptr to PortSetup */
	BOOL (*pPortTransmitChar)();	/* ptr to PortTransmitChar */
	BOOL (*pPortClose)();		/* ptr to PortClose */
	BOOL (*pPortGetQueueStatus)();	/* ptr to PortGetQueueStatus */
	BOOL (*pPortClearError)();	/* ptr to PortClearError */
	BOOL (*pPortSetModemStatusShadow)(); /* ptr to
					        PortSetModemStatusShadow */
	BOOL (*pPortGetProperties)();	/* ptr to PortGetProperties */
	BOOL (*pPortEscapeFunction)();	/* ptr to PortEscapeFunction */
	BOOL (*pPortPurge)();		/* ptr to PortPurge */
	BOOL (*pPortSetEventMask)();	/* ptr to PortSetEventMask */
	BOOL (*pPortGetEventMask)();	/* ptr to PortGetEventMask */
	BOOL (*pPortWrite)();		/* ptr to PortWrite */
	BOOL (*pPortRead)();		/* ptr to PortRead */
	BOOL (*pPortEnableNotification)(); /* ptr to PortEnableNotification */
	BOOL (*pPortSetReadCallBack)(); /* ptr to PortSetReadCallBack */
	BOOL (*pPortSetWriteCallBack)(); /* ptr to PortSetWriteCallBack */
	BOOL (*pPortGetModemStatus)();	/* ptr to PortGetModemStatus */

#ifndef	WIN31COMPAT
	
	BOOL (*pPortGetCommConfig)();	/* ptr to PortGetCommConfig */
	BOOL (*pPortSetCommConfig)();	/* ptr to PortSetCommConfig */
	BOOL (*pPortGetError)();	/* ptr to PortGetError (win32 style)*/
	BOOL (*pPortDeviceIOCtl)();	/* ptr to PortDeviceIOCtl */
		
#endif
	
} PortFunctions;

typedef struct COMMTIMEOUTS {
	DWORD ReadIntervalTimeout;
	DWORD ReadTotalTimeoutMultiplier;
	DWORD ReadTotalTimeoutConstant;
	DWORD WriteTotalTimeoutMultiplier;
	DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS, *LPCOMMTIMEOUTS;

typedef struct _PortData {
	WORD PDLength;			/* sizeof (PortData) */
        WORD PDVersion;			/* version of struct */
        PortFunctions *PDfunctions;	/* Points to a list of functions
					   supported by	the port driver */
        DWORD PDNumFunctions;		/* Highest ordinal of supported
					   function */
        DWORD dwLastError;		/* what was the error
					   for the last operation */
        DWORD dwClientEventMask;	/* event mask set by client */
        DWORD lpClientEventNotify;	/* address set by client for
					   event notification */
	DWORD lpClientReadNotify;	/* adress set by client for
					   read threshold notification */
	DWORD lpClientWriteNotify;	/* address set by client for
					   write threshold notification */
	DWORD dwClientRefData;		/* Client's reference data */
	DWORD dwWin31Req;		/* Used for WIN3.1 specific reasons */
	DWORD dwClientEvent;		/* Event to send to client */
	DWORD dwCallerVMId;		/* Used for supporting all VMs */

	DWORD dwDetectedEvents;		/* mask of detected and
					   enabled events */
        DWORD dwCommError;		/* non-zero if I/O error. */
	BYTE bMSRShadow;		/* the shadow of Modem Status
					   Register */
	WORD wFlags;			/* flags for the port */
	BYTE LossByte;			/* For COMM ports 1-4 VCD flags this
					   byte telling port driver that it
					   has lost the port */

	DWORD QInAddr;			/* Address of the queue */
	DWORD QInSize;			/* Length of queue in bytes */
	DWORD QOutAddr;			/* Address of the queue */
	DWORD QOutSize;			/* Length of queue in bytes */
	DWORD QInCount;			/* # of bytes currently in queue */
	DWORD QInGet;			/* Offset into q to get bytes from */
	DWORD QInPut;			/* Offset into q to put bytes in */
	DWORD QOutCount;		/* Number of bytes currently in q */
	DWORD QOutGet;			/* Offset into q to get bytes from */
	DWORD QOutPut;			/* Offset into q to put bytes in */

	DWORD ValidPortData;		/* For checking validity etc. */

	DWORD lpLoadHandle;		/* load handle of the owner VxD */
	COMMTIMEOUTS cmto;		/* Commtimeouts struct */

	DWORD lpReadRequestQueue;	/* Pointer to pending Read requests */
	DWORD lpWriteRequestQueue;	/* Pointer to pending Write requests */

	DWORD dwLastReceiveTime;	/* Time of last reception of data */
		
	DWORD dwReserved1;		/* Reserved */
	DWORD dwReserved2;		/* Reserved */
} PortData;

#ifndef	Not_VxD

/* Standard error codes set in dwLastError. */

#define	IE_BADID	-1	 /* invalid or unsupported device */
#define	IE_OPEN		-2	 /* Device already open */
#define	IE_NOPEN	-3	 /* Device not open */
#define	IE_MEMORY	-4	 /* unable to allocate queues */
#define	IE_DEFAULT	-5	 /* error in default params */
#define	IE_INVALIDSERVICE -6	 /* port driver doesn't support this service*/
#define	IE_HARDWARE	-10	 /* hardware not present */
#define	IE_BYTESIZE	-11	 /* illegal byte size */
#define	IE_BAUDRATE	-12	 /* unsupported baud rate */
#define	IE_EXTINVALID	-20	 /* unsupported extended function */
#define	IE_INVALIDPARAM	-21	 /* Parameters are wrong */
#define	IE_TRANSMITCHARFAILED 0x4000 /* TransmitChar failed */

/* Events that can be set in dwClientEventMask */

#define	EV_RXCHAR	0x00000001	 /* Any Character received */
#define	EV_RXFLAG	0x00000002	 /* Received certain character */
#define	EV_TXEMPTY	0x00000004	 /* Transmitt Queue Empty */
#define	EV_CTS		0x00000008	 /* CTS changed state */
#define	EV_DSR		0x00000010	 /* DSR changed state */
#define	EV_RLSD		0x00000020	 /* RLSD changed state */
#define	EV_BREAK	0x00000040	 /* BREAK received */
#define	EV_ERR		0x00000080	 /* Line status error occurred */
#define	EV_RING		0x00000100	 /* Ring signal detected */
#define	EV_PERR		0x00000200	 /* Printer error occured */
#define	EV_CTSS		0x00000400	 /* CTS state */
#define	EV_DSRS		0x00000800	 /* DSR state */
#define	EV_RLSDS	0x00001000	 /* RLSD state */
#define	EV_RingTe	0x00002000	 /* Ring Trailing Edge Indicator */
#define	EV_TXCHAR	0x00004000	 /* Any character transmitted */
#define	EV_DRIVER	0x00008000	 /* Driver specific event */
#define	EV_UNAVAIL	0x00010000	 /* Acquired port has been stolen */
#define	EV_AVAIL	0x00020000	 /* stolen port has been released */


/* Error Flags for dwCommError */

#define	CE_RXOVER	0x00000001		/* Receive Queue overflow */
#define	CE_OVERRUN	0x00000002		/* Receive Overrun Error */
#define	CE_RXPARITY	0x00000004		/* Receive Parity Error */
#define	CE_FRAME	0x00000008		/* Receive Framing error */
#define	CE_BREAK	0x00000010		/* Break Detected */
#define	CE_CTSTO	0x00000020		/* CTS Timeout */
#define	CE_DSRTO	0x00000040		/* DSR Timeout */
#define	CE_RLSDTO	0x00000080		/* RLSD Timeout */
#define	CE_TXFULL	0x00000100		/* TX Queue is full */
#define	CE_PTO		0x00000200		/* LPTx Timeout */
#define	CE_IOE		0x00000400		/* LPTx I/O Error */
#define	CE_DNS		0x00000800		/* LPTx Device not selected */
#define	CE_OOP		0x00001000		/* LPTx Out-Of-Paper */
#define	CE_Unused1	0x00002000		/* unused */
#define	CE_Unused2	0x00004000		/* unused */
#define	CE_MODE		0x00008000		/* Requested mode unsupported*/

#endif

//
// Modem status flags
//

#define	MS_CTS_ON	0x0010
#define	MS_DSR_ON	0x0020
#define	MS_RING_ON	0x0040
#define	MS_RLSD_ON	0x0080
#define	MS_Modem_Status	0x00F0


/* flags for wFlags of PortData */

#define	Event_Sent	0x0001	/* has an event been set for COMM.DRV ? */
#define	Event_Sent_Bit	0x0000	/* bit in the flag word */
#define	TimeOut_Error	0x0002	/* Operation was abandoned due to timeout */
#define	TimeOut_Error_Bit 0x0001 /* its bit field */
#define	Flush_In_Progress 0x0004 /* FlushFileBuffers is in progress */
#define	Flush_In_Progress_Bit 0x0002 /* its bit */
#define	TxQueuesSet	0x0008	/* Non-zero xmit queue exists */
#define	TxQueuesSetBit	0x0003	/* its bit */
#define	CloseComm_In_Progress	0x0010	/* CloseComm is in progress */
#define	CloseComm_In_Progress_Bit 0x0004 /* its bit */
#define Spec_Timeouts_Set	0x0020	/* Special timeouts have been set */
#define	Spec_Timeouts_Set_Bit	0x0005	/* its bit */

typedef struct _DCB {
	DWORD DCBLength;		/* sizeof (DCB) */
	DWORD BaudRate ;		/* Baudrate at which running */
        DWORD BitMask;			/* flag DWORD */
        DWORD XonLim;			/* Transmit X-ON threshold */
        DWORD XoffLim;			/* Transmit X-OFF threshold */
        WORD wReserved;			/* reserved */
        BYTE ByteSize;			/* Number of bits/byte, 4-8 */
	BYTE Parity;			/* 0-4=None,Odd,Even,Mark,Space */
	BYTE StopBits;			/* 0,1,2 = 1, 1.5, 2 */
	char XonChar;			/* Tx and Rx X-ON character */
	char XoffChar;			/* Tx and Rx X-OFF character */
	char ErrorChar;			/* Parity error replacement char */
	char EofChar;			/* End of Input character */
	char EvtChar1;			/* special event character */
	char EvtChar2;			/* Another special event character */
	BYTE bReserved;			/* reserved */
	DWORD RlsTimeout;		/* Timeout for RLSD to be set */
	DWORD CtsTimeout;		/* Timeout for CTS to be set */
	DWORD DsrTimeout;		/* Timeout for DSR to be set */
	DWORD TxDelay;			/* Amount of time between chars */
} _DCB;

#ifndef	Not_VxD

/*  Comm Baud Rate indices : allowable values for BaudRate */

#define	CBR_110		0x0000FF10
#define	CBR_300		0x0000FF11
#define	CBR_600		0x0000FF12
#define	CBR_1200	0x0000FF13
#define	CBR_2400	0x0000FF14
#define	CBR_4800	0x0000FF15
#define	CBR_9600	0x0000FF16
#define	CBR_14400	0x0000FF17
#define	CBR_19200	0x0000FF18

/* 0x0000FF19,0x00000FF1A are reserved */

#define	CBR_38400	0x0000FF1B

/* 0x0000FF1C, 0x0000FF1D, 0x0000FF1E are reserved */

#define	CBR_56000	0x0000FF1F

/* 0x0000FF20, 0x0000FF21, 0x0000FF22 are reserved */

#define	CBR_128000	0x0000FF23

/* 0x0000FF24, 0x0000FF25, 0x0000FF26 are reserved */

#define	CBR_256000	0x0000FF27

#endif

/* Flags for Bitmask */

#define	fBinary		0x00000001	/* Binary mode */
#define	fRTSDisable	0x00000002	/* Disable RTS */
#define fParity		0x00000004	/* Perform parity checking */
#define	fOutXCTSFlow	0x00000008	/* Output handshaking using CTS */
#define	fOutXDSRFlow	0x00000010	/* Output handshaking using DSR */
#define	fEnqAck		0x00000020	/* ENQ/ACK software handshaking */
#define	fEtxAck		0x00000040	/* ETX/ACK software handshaking */
#define	fDTRDisable	0x00000080	/* Disable DTR */

#define	fOutX		0x00000100	/* Output X-ON/X-OFF */
#define	fInX		0x00000200	/* Input X-ON/X-OFF */
#define	fPErrChar	0x00000400	/* Parity error replacement active */
#define	fNullStrip	0x00000800	/* Null stripping */
#define	fCharEvent	0x00001000	/* Character event */
#define	fDTRFlow	0x00002000	/* Input handshaking using DTR */
#define	fRTSFlow	0x00004000	/* Output handshaking using RTS */
#define	fWin30Compat	0x00008000	/* Maintain Compatiblity */

#define	fDsrSensitivity	0x00010000	/* DSR sensitivity */
#define	fTxContinueOnXoff 0x00020000	/* Continue Tx when Xoff sent */
#define	fDtrEnable	0x00040000	/* Enable DTR on device open */
#define	fAbortOnError	0x00080000	/*abort all reads and writes on error*/
#define	fRTSEnable	0x00100000	/* enable RTS on device open */
#define	fRTSToggle	0x00200000	/* iff bytes in Q, set RTS high */

/* Allowable parity values */

#define	NOPARITY	0
#define	ODDPARITY	1
#define	EVENPARITY	2
#define	MARKPARITY	3
#define	SPACEPARITY	4

/* Allowable stopbits */

#define	ONESTOPBIT	0
#define	ONE5STOPBITS	1
#define	TWOSTOPBITS	2

typedef	unsigned short WCHAR;

typedef struct _COMMPROP {
	WORD   wPacketLength;		/* length of property structure
					   in bytes */
	WORD   wPacketVersion;		/* version of this structure */
	DWORD  dwServiceMask;		/* Bitmask indicating services
					   provided */
	DWORD  dwReserved1;		/* reserved */
	DWORD  dwMaxTxQueue;		/* Max transmit queue size.
					   0 => not used */
	DWORD  dwMaxRxQueue;		/* Max receive queue size.
					   0 => not used */
	DWORD  dwMaxBaud;		/* maximum baud supported */
	DWORD  dwProvSubType;		/* specific COMM provider type */
	DWORD  dwProvCapabilities;	/* flow control capabilities */
	DWORD  dwSettableParams;	/* Bitmask indicating params
					   that can be set. */
	DWORD  dwSettableBaud;		/* Bitmask indicating baud rates
					   that can be set*/
	WORD   wSettableData;		/* bitmask indicating # of data bits
					   that can be set*/
	WORD   wSettableStopParity;	/* bitmask indicating allowed
					   stopbits and parity checking */
	DWORD  dwCurrentTxQueue;	/* Current size of transmit queue
					   0 => unavailable */
	DWORD  dwCurrentRxQueue;	/* Current size of receive queue
					   0 => unavailable */
	DWORD  dwProvSpec1;		/* Used iff clients have
					   intimate knowledge of format */
	DWORD  dwProvSpec2;		/* Used iff clients have intimate
					   knowledge of format */
	WCHAR  wcProvChar[1];		/* Used iff clients have intimate \						   knowledge of format */
	WORD	filler;			/* To make it multiple of 4 */
	
} _COMMPROP;

//
// Serial provider type.
//

#define SP_SERIALCOMM    ((DWORD)0x00000001)

//
// Provider SubTypes
//

#define PST_UNSPECIFIED      ((DWORD)0x00000000)
#define PST_RS232            ((DWORD)0x00000001)
#define PST_PARALLELPORT     ((DWORD)0x00000002)
#define PST_RS422            ((DWORD)0x00000003)
#define PST_RS423            ((DWORD)0x00000004)
#define PST_RS449            ((DWORD)0x00000005)
#define PST_MODEM            ((DWORD)0x00000006)
#define PST_FAX              ((DWORD)0x00000021)
#define PST_SCANNER          ((DWORD)0x00000022)
#define PST_NETWORK_BRIDGE   ((DWORD)0x00000100)
#define PST_LAT              ((DWORD)0x00000101)
#define PST_TCPIP_TELNET     ((DWORD)0x00000102)
#define PST_X25              ((DWORD)0x00000103)

//
// Provider capabilities flags.
//

#define PCF_DTRDSR        ((DWORD)0x0001)
#define PCF_RTSCTS        ((DWORD)0x0002)
#define PCF_RLSD          ((DWORD)0x0004)
#define PCF_PARITY_CHECK  ((DWORD)0x0008)
#define PCF_XONXOFF       ((DWORD)0x0010)
#define PCF_SETXCHAR      ((DWORD)0x0020)
#define PCF_TOTALTIMEOUTS ((DWORD)0x0040)
#define PCF_INTTIMEOUTS   ((DWORD)0x0080)
#define PCF_SPECIALCHARS  ((DWORD)0x0100)
#define PCF_16BITMODE     ((DWORD)0x0200)

//
// Comm provider settable parameters.
//

#define SP_PARITY         ((DWORD)0x0001)
#define SP_BAUD           ((DWORD)0x0002)
#define SP_DATABITS       ((DWORD)0x0004)
#define SP_STOPBITS       ((DWORD)0x0008)
#define SP_HANDSHAKING    ((DWORD)0x0010)
#define SP_PARITY_CHECK   ((DWORD)0x0020)
#define SP_RLSD           ((DWORD)0x0040)

//
// Settable baud rates in the provider.
//

#define BAUD_075          ((DWORD)0x00000001)
#define BAUD_110          ((DWORD)0x00000002)
#define BAUD_134_5        ((DWORD)0x00000004)
#define BAUD_150          ((DWORD)0x00000008)
#define BAUD_300          ((DWORD)0x00000010)
#define BAUD_600          ((DWORD)0x00000020)
#define BAUD_1200         ((DWORD)0x00000040)
#define BAUD_1800         ((DWORD)0x00000080)
#define BAUD_2400         ((DWORD)0x00000100)
#define BAUD_4800         ((DWORD)0x00000200)
#define BAUD_7200         ((DWORD)0x00000400)
#define BAUD_9600         ((DWORD)0x00000800)
#define BAUD_14400        ((DWORD)0x00001000)
#define BAUD_19200        ((DWORD)0x00002000)
#define BAUD_38400        ((DWORD)0x00004000)
#define BAUD_56K          ((DWORD)0x00008000)
#define BAUD_128K         ((DWORD)0x00010000)
#define BAUD_USER         ((DWORD)0x10000000)

//
// Settable Data Bits
//

#define DATABITS_5        ((WORD)0x0001)
#define DATABITS_6        ((WORD)0x0002)
#define DATABITS_7        ((WORD)0x0004)
#define DATABITS_8        ((WORD)0x0008)
#define DATABITS_16       ((WORD)0x0010)
#define DATABITS_16X      ((WORD)0x0020)

//
// Settable Stop and Parity bits.
//

#define STOPBITS_10       ((WORD)0x0001)
#define STOPBITS_15       ((WORD)0x0002)
#define STOPBITS_20       ((WORD)0x0004)
#define PARITY_NONE       ((WORD)0x0100)
#define PARITY_ODD        ((WORD)0x0200)
#define PARITY_EVEN       ((WORD)0x0400)
#define PARITY_MARK       ((WORD)0x0800)
#define PARITY_SPACE      ((WORD)0x1000)

typedef struct  _COMSTAT {
	DWORD BitMask;		/* flags DWORD */
	DWORD cbInque;		/* Count of characters in receive queue */
	DWORD cbOutque;		/* Count of characters in transmit queue */
} _COMSTAT;

/* Flags of BitMask */

#define	fCtsHold	0x00000001	/* Transmit is on CTS hold */
#define	fDsrHold	0x00000002	/* Transmit is on DSR hold */
#define	fRlsdHold	0x00000004	/* Transmit is on RLSD hold */
#define	fXoffHold	0x00000008	/* Received handshake */
#define	fXoffSent	0x00000010	/* Issued handshake */
#define	fEof		0x00000020	/* EOF character found */
#define	fTximmed	0x00000040	/* Character being transmitted */

typedef struct _QSB {
	DWORD ReceiveQueueGetPtr; /* offset into queue to get bytes from */
	DWORD ReceiveQueueCount;  /* Number of bytes in receive queue */
} _QSB;


/* Following constants are used by COMM.DRV to access the PM apis supported
   by VCOMM.
*/

#define	VCOMM_PM_API_OpenCom	0
#define	VCOMM_PM_API_SetCom	1
#define	VCOMM_PM_API_Setup	2
#define	VCOMM_PM_API_ctx	3
#define	VCOMM_PM_API_TrmCom	4
#define	VCOMM_PM_API_StaCom	5
#define	VCOMM_PM_API_cextnfcn	6
#define	VCOMM_PM_API_cFlush	7
#define	VCOMM_PM_API_cevt	8
#define	VCOMM_PM_API_cevtget	9

#define	VCOMM_PM_API_SetMSRShadow	10
#define	VCOMM_PM_API_WriteString	11
#define	VCOMM_PM_API_ReadString		12
#define	VCOMM_PM_API_EnableNotify	13

#ifndef	Not_VxD

/* Escape Functions (extended functions). */

#define	Dummy	0		  /* Dummy */
#define	SETXOFF	1		  /* Simulate XOFF received */
#define	SETXON  2		  /* Simulate XON received */
#define	SETRTS	3		  /* Set RTS high */
#define	CLRRTS	4		  /* Set RTS low */
#define	SETDTR	5		  /* Set DTR high */
#define	CLRDTR	6		  /* Set DTR low */
#define	RESETDEV 7		  /* Reset device if possible */

#endif

#ifdef	Not_VxD

/* These numbers are reserved for compatibility reasons */

#define	GETLPTMAX 8		 /* Get maximum LPT supported */
#define	GETCOMMAX 9		 /* Get maximum COM supported */

#endif

#define	GETCOMBASEIRQ	10	 /* Get COM base and IRQ */
#define	GETCOMBASEIRQ1	11	 /* FOR COMPATIBILITY REASONS */

#define	SETBREAK	12	 /* Set break condition */
#define	CLEARBREAK	13	 /* Clear break condition */

#ifdef	Not_VxD

/* These too are not available to client VxDs and not implemented by
   port drivers. */

#define	GETPORTHANDLE	14	 /* Get handle for Port */
#define	GETEXTENDEDFNADDR 15	 /* Get the address of extended functions */

#endif

#define	CLRTIMERLOGIC	16	/* Clear the timer logic of the port driver */

#define GETDEVICEID	17	/* Get the device ID of the device */
#define SETECPADDRESS	18	/* Set ECP channel address */

#define SETUPDATETIMEADDR	19	/* Set address of update field for
					   last time a char was received */

#define IGNOREERRORONREADS	20	/* Ignore pending IO errors on reads*/

#define ENABLETIMERLOGIC	21	/* Re-enable timer logic code */
#define	IGNORESELECT		22	/* Ignore select bit */

#define STARTNONSTDESCAPES	200	/* non standard escapes */

#define	PEEKCHAR		200	/* peek the Rx Q */

/* END OF ESCAPES for ESCAPECOMMFUNCTION */

#ifndef	Not_VxD
/* notifications passed in Event of Notification function */

#define	CN_RECEIVE	1	 /* bytes are available in the input queue */
#define	CN_TRANSMIT	2	 /* fewer than wOutTrigger bytes still */
				 /* remain in the output queue waiting */
				 /* to be transmitted. */
#define	CN_EVENT	4	 /* an enabled event has occurred */

#endif
				
/* Other constants */

#ifndef	Not_VxD
				
#define	IGNORE		0		/* Ignore signal */

#endif
				
#define	INFINITE32	-1		/* Infinite timeout */

/* Defined ways of supporting a port (return value of PortInquire fn) */

#define	PD_UNSUPPORTED	0		/* Port is not supported */
#define	PD_DEFAULT	1		/* Port is supported by default */
#define	PD_BEST		-1		/* Best possible support */

/* Masks for relevant fields of DCB */
#define	fBaudRate	0x00000001
#define	fBitMask	0x00000002
#define	fXonLim		0x00000004
#define	fXoffLim	0x00000008
#define	fByteSize	0x00000010
#define	fbParity	0x00000020
#define	fStopBits	0x00000040
#define	fXonChar	0x00000080
#define	fXoffChar	0x00000100
#define	fErrorChar	0x00000200
#define	fEofChar	0x00000400
#define	fEvtChar1	0x00000800
#define	fEvtChar2	0x00001000
#define	fRlsTimeout	0x00002000
#define	fCtsTimeout	0x00004000
#define	fDsrTimeout	0x00008000
#define	fTxDelay	0x00010000
#define	fTimeout	(fRlsTimeout | fDsrTimeout | fCtsTimeout)
#define	fLCR		0x00000070

/*

 IORequest

 VCOMM allows a client to impose a "block" structure on a port
 driver in the following way. It can call VCOMM_SetWriteRequest
 with the buffer to write. When all the earlier write requests are satisfied
 by the port driver, VCOMM will call the port driver to satisfy this
 request. A client can also call VCOMM_SetReadRequest with the buffer
 to read data into. VCOMM will queue up this request and when all previous
 read requests are satisfied, call the port driver to satisfy this request.
 So now, clients can get a notification per read/write request. The buffers
 passed by client must be in locked memory during the duration of the whole
 operation and should not be touched by the client till it receives the
 notification.

 A client should not use a combination of VCOMM_WriteComm and
 VCOMM_SetWriteRequest. This will lead to strange results. VCOMM_WriteComm
 goes directly to the port driver without any processing by VCOMM. There
 is considerable work done by VCOMM for VCOMM_SetWriteRequest. Similarly,
 VCOMM_SetReadRequest and VCOMM_ReadComm should not be used together.

 When a client attempts to get the total queued count of characters to write,
 VCOMM calls the port driver to find the size of its xmit queue and then
 adds up all the pending write operations to return the count.

 VCOMM_PurgeComm leads to VCOMM calling each aborted IORequest if TXAbort
 parameter is set. For TxClear, it does not do so, it just calls down into
 the port driver to clear its transmit queue.
 
*/

typedef struct IORequest {

	DWORD IOBuffer;			//  address of IO buffer
	DWORD IOCount;			// the size of IO buffer
	DWORD IOCallCompletionRoutine;	// whom to call back when done
	DWORD NumBytes;			// How many bytes were written/read
	DWORD dwReserved[8];		// eight reserved words used by VCOMM
	DWORD dwSig;			// signature dword
	
} IORequest;

#define	WRITE_REQUEST	1
#define	READ_REQUEST	0


/* For supporting Plug and Play, a port driver must be dynamically
   loadable. It must exist in the system directory (where DOS386.exe
   is executed from).
   It will be loaded by VCOMM which will be its devloader. During
   Sys_Dynamic_Device_Init, it should register with VCOMM via
   _VCOMM_Register_Port_Driver. While registering, it should pass
   the address of its initialization function. VCOMM will call this
   function to initialize a port supported by the port driver. The
   port driver should check if such a port exists and call VCOMM to
   add this port to its list via _VCOMM_Add_Port. It MUST add the
   port in its initialization function before returning to VCOMM.
   When all the ports supported by the port driver are closed, VCOMM
   will unload the driver. It will call the initialization function of
   the driver once per open of each port. So the port driver can allocate
   the required data for the port at this time and deallocate it at
   the time of closing of the port.
   
   The procedure must be of the form:
   
   void InitFunction(DWORD hDevNode, DWORD AllocPortBase, DWORD AllocPortIrq,
		      char *PortName);

   where:
   hDevNode = devnode for the port
   AllocPortBase = allocated base port address of the port being initialized.
   AllocPortIrq = allocated base Irq of the port being initialized.
   PortName -> name of the port. The port driver, if it supports the port
	   should add the port by using a copy of this name.
	   It will be later be called to open the port with this name.
   
   */

/*

The DriverControl function of the port drivers is called by VCOMM to
perform various actions such as initialize all or one port etc.
Following function codes specify various actions.

*/

#define	DC_Initialize	0x00000000		/* initialize port. */

/* ASM

IFDEF	WIN31COMPAT

VxD_My_Pageable_Code_Seg MACRO
VxD_Locked_Code_Seg
ENDM

VxD_My_Pageable_Code_Ends MACRO
VxD_Locked_Code_Ends
ENDM

VxD_My_Pageable_Data_Seg MACRO
VxD_Locked_Data_Seg
ENDM

VxD_My_Pageable_Data_Ends MACRO
VxD_Locked_Data_Ends
ENDM


ELSE

VxD_My_Pageable_Code_Seg MACRO
VxD_Pageable_Code_Seg
ENDM

VxD_My_Pageable_Code_Ends MACRO
VxD_Pageable_Code_Ends
ENDM

VxD_My_Pageable_Data_Seg MACRO
VxD_Pageable_Data_Seg
ENDM

VxD_My_Pageable_Data_Ends MACRO
VxD_Pageable_Data_Ends
ENDM

ENDIF

*/

#define	ERROR_NOT_READY	21L
#define	ERROR_OUT_OF_PAPER	28L
#define	ERROR_COUNTER_TIMEOUT	1121L

/*XLATOFF*/
#pragma	pack()
/*XLATON*/

#endif                  // _VCOMM_H

typedef	struct IOCtlBlock {
	DWORD IO_lpOverlapped;
	DWORD IO_lpcbBytesReturned;
	DWORD IO_Event;
	DWORD IO_ThreadHandle;
	DWORD IO_NumBytesReturned;
} IOCtlBlock;

/*
 * Contention related equates
 */

#define	MAP_DEVICE_TO_RESOURCE	0
#define	ACQUIRE_RESOURCE	1
#define	STEAL_RESOURCE		2
#define	RELEASE_RESOURCE	3
#define	ADD_RESOURCE		4
#define	REMOVE_RESOURCE		5

#define	MAX_CONTEND_FUNCTIONS	5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VDD2.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	vdd2.inc - VDD definitions for Secondary VDD
;
;   Version:	1.00
;
;   Author: MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   02-Aug-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD2

;***************
;VDD2 services for other devices and VMM(Get_Version must be first)
;
VDD2_Service	VDD2_Get_Version	; Get version number and ID string ptr
End_Service_Table VDD2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VDDGRB.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;***************
; Shell_Event definitions for the VDD
;
;   DO NOT CHANGE THESE EVER WITHOUT REDOING THE SHELL AND THE GRABBER
;	AND THE VDD!!!
;
VDA_Type_Chng		EQU	((0400h+20)+2)

VDA_Display_Event	EQU	((0400h+20)+6)
; On VDA_Display_Event event,
;   VMDOSAPP instance which gets the message has display event
;   wParam is a "subfunction code" which identifies the event.
;
VDA_DE_DispChngMin	EQU	0
VDA_DE_DispChngMax	EQU	80
VDA_DE_ControlChngMin	EQU	VDA_DE_DispChngMax
VDA_DE_ControlChngMax	EQU	160
VDA_DE_ScreenGrabMin	EQU	VDA_DE_ControlChngMax
VDA_DE_ScreenGrabMax	EQU	240

VDA_DE_SpecialMin	EQU	0FFAFh
VDA_DE_SpecialMax	EQU	0FFFFh
;
; Subfunctions >= VDA_DE_DispChngMin, < VDA_DE_DispChngMax indicate
;   that the display has changed without a change to the video controller
;   state.
;
; Subfunctions >= VDA_DE_ControlChngMin, < VDA_DE_ControlChngMax indicate
;   that the video controller state has changed.
;
; Subfunctions >= VDA_DE_ScreenGrabMin, < VDA_DE_ScreenGrabMax indicate
;   that a screen grab event has occured.
;
; Subfunctions >= VDA_DE_SpecialMin, < VDA_DE_SpecialMax indicate
;   private GRABBER events which VMDOSAPP just passes through to the
;   GRABBER
;
; This parameter is passed through VMDOSAPP to the display specific GRABBER.
;   "ranges" on the parameter allow specific info to be passed to the GRABBER
;   while allowing VMDOSAPP to know about the general high level aspect of the
;   event.
;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMDAVGA.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VMDAVGA.INC
;
;   Version:	3.10
;
;   Date:	15-Aug-1990
;
;   Author: AR, MDW, RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jan-1989 MDW Added service definitions(some from VDAMSG.INC)
;   15-Feb-1989 MDW Memory data structures
;   15-Aug-1990 RAP VGA version of VMDAEGA.INC
;
;==============================================================================



;******************************************************************************
;
;	VDD virtual mode services for the grabber
;
GRB_Get_Version     EQU 0
GRB_Get_Mem	    EQU GRB_Get_Version + 1
GRB_Get_State	    EQU GRB_Get_Mem + 1
GRB_Get_Mod	    EQU GRB_Get_State + 1
GRB_Clear_Mod	    EQU GRB_Get_Mod + 1
GRB_Free_Mem	    EQU GRB_Clear_Mod + 1
GRB_Get_GrbMem	    EQU GRB_Free_Mem + 1
GRB_Free_Grab	    EQU GRB_Get_GrbMem + 1
GRB_Get_GrbState    EQU GRB_Free_Grab + 1
GRB_Unlock_APP	    EQU GRB_Get_GrbState + 1

; New API's for 3.1 display drivers
Private_DspDrvr_1   EQU 0Ah
			    .errnz Private_DspDrvr_1 - GRB_Unlock_APP - 1
DspDrvr_Version     EQU 0Bh
DspDrvr_Addresses   EQU 0Ch


Grabber_VerNum	    EQU     030Ah	    ; version 3, 10


;*******************************************************************************
;
;	Controller state structure
;
VDA_EGA_State	STRUC
    VDA_EGA_Mode    DB	?		; Display mode(0-A)
    VDA_EGA_Colr    DB	?		; Border color
    VDA_EGA_Flags   DB	?		; Flags
    VDA_EGA_Rows    DB	?		; Height of display in lines (text mode)
    VDA_EGA_CurX    DW	?		; Cursor horizontal position
    VDA_EGA_CurY    DW	?		; Cursor vertical position
    VDA_EGA_CurBeg  DW	?		; Cursor start scan line
    VDA_EGA_CurEnd  DW	?		; Cursor end scan line
    VDA_EGA_Pal     DB	16 DUP (?)	; Palettes(6 bits of color mapping)
VDA_EGA_State	ENDS

;*******
;
;	Controller flags
;
fVDA_V_ScOff	    EQU 0001h		; Screen off
fVDA_V_ScOffBit     EQU 0
fVDA_V_HCurTrk	    EQU 0002h		; Horizontal cursor track - keep
fVDA_V_HCurTrkBit   EQU 1		;   cursor position in window
; GEM Ventura programs DAC 0 as white - set if DAC 0 is non-zero
fVDA_V_InvDAC	    EQU 0004h		
fVDA_V_InvDACBit    EQU 2


BeginDoc
;*******************************************************************************
;   EGA/VGA VDD modifications state structure ::= <flag>,<count>,<list>
;
;   <flag> indicates type, list valid and controller change and cursor change.
;   <count> is count of entries(not bytes or words) in list.
;   <list> is type dependent as follows:
;	Type 0 - list is modified pages bit map, 1 bit per displayed 4k page,
;	    count is page count. Bit map is one byte per 32k linear address
;	    space, where byte 0's bits are <page 0 bit>,<page 1 bit>,
;	    ...,<page 7 bit>. byte 1's bits are <page 8 bit>,<page 9 bit>.
;	    A set bit indicates a change in that page.
;
;	    This type is not used for text modes.
;
;	    Modes D and E display is less than two pages long and so the
;	    page count will be two. Mode 10 page count is 7. Modes
;	    11 and 12 page count is 10.
;
;	Type 1 - modified enclosing rectangles, count is rectangle count,
;	    (less than four) , rectangle is two points: <left>,<top> and
;	    <right>,<bottom>. Each point is relative to left, upper
;	    corner which is 0,0 and each value is stored in one word.
;
;	    This type may be used for all modes.
;
;	    For text modes, modes 0-3, there may be a special, scroll rectangle.
;	    If the high bit of R_Left is set in one of these RECTs, then it is
;	    not a rect but a scroll specification.
;		The structure then becomes: <scroll count>,<scroll flags>,
;		<right column>,<left column>,<bottom line>,<top line>,
;		<fill character>,<fill attribute>
;	    Note that all items are byte values and that the scroll event
;		specification takes the same space as an update rectangle.
;
ModListMax	EQU	64		    ; Max size of VDD_Mod_List field
EndDoc
VDD_Mod_State	STRUC

    VDD_Mod_Flag    DW	?		    ; Modified state flag
    VDD_Mod_Count   DW	?		    ; Count of entries in modification list
    VDD_Mod_List    DB	ModListMax dup(?)   ; The modification list(type dependent)

VDD_Mod_State	ENDS

;*******
;
; Masks and bit numbers for VDD_Mod_Flag
;
fVDD_M_Type	EQU 0000000000000111B	; Mask for value field
fVDD_M_TypeBit	EQU 0			; start bit for value field
fVDD_M_Ctlr	EQU 0000000000001000B	; flag indicating controller state chg
fVDD_M_CtlrBit	EQU 3			; bit for controller state change
fVDD_M_VRAM	EQU 0000000000010000B	; flag indicating Video RAM change
fVDD_M_VRAMBit	EQU 4			; bit for Video RAM change
fVDD_M_Curs	EQU 0000000000100000B	; flag indicating Cursor change
fVDD_M_CursBit	EQU 5			; bit for Cursor change
fVDD_M_ScOff	EQU 0000000001000000B	; flag indicating screen is off
fVDD_M_ScOffBit EQU 6			; bit for screen off
fVDD_M_Err	EQU 1000000000000000B	; flag indicating error, can't pass mods
fVDD_M_ErrBit	EQU 15			; bit for error
;
; Values for fVDD_M_TypeMsk field
;
fVDD_M_Type_Page	EQU    0	; Bit field of modified pages
fVDD_M_Type_Rect	EQU    1	; Array of RECT structures

;*******
;
; Structure for accessing RECTs
;
Rect	STRUC
    R_Left  DW	?
    R_Top   DW	?
    R_Right DW	?
    R_Botm  DW	?
Rect	ENDS

;********
;
;	Scroll rect definition
;
; If the high bit of R_Left is set in one of these RECTs, then it is
;  not a rect but a scroll event specification.
;  THIS APPLIES TO TEXT MODE ONLY (modes 0-3)!!
;  A scroll event spec looks like this:
;
ScrollRect STRUC
    ScrCnt  DB	?	    ; Count of lines to scroll in scroll region
    ScrFlgs DB	?	    ; Flags
    ScrRgt  DB	?	    ; Right Col of scroll (0 indexed)(ignore if full width bit set)
    ScrLft  DB	?	    ; Left Col of scroll (0 indexed)(ignore if full width bit set)
    ScrBot  DB	?	    ; Bottom line of scroll (0 indexed)
    ScrTop  DB	?	    ; Top line of scroll (0 indexed)
    ScrFch  DB	?	    ; Fill character for blank lines of scroll
    ScrFatt DB	?	    ; Fill attribute for blank lines of scroll
ScrollRect ENDS

; Masks for ScrFlgs
Scr_M_Scroll	    EQU 10000000B   ; High bit of flags indicates scroll
Scr_M_ScrollBit     EQU 7
Scr_M_FullWid	    EQU 00000001B   ; Set if scroll is full width (ignore Rgt Lft)
Scr_M_FullWidBit    EQU 0
Scr_M_Up	    EQU 00000010B   ; Set if scroll is UP, clear if DOWN
Scr_M_UpBit	    EQU 1

IF2
    IF (SIZE ScrollRect) NE (SIZE Rect)
	%out ERROR -- ScrollRect is wrong size!!!!!
    ENDIF
ENDIF


;*******************************************************************************
;
;	Memory state structure
;
VDA_Mem_State	STRUC
    VDA_Mem_Addr_P0	DD  ?		; Addr of plane 0 video memory
    VDA_Mem_Addr_P1	DD  ?		; Addr of plane 1 video memory
    VDA_Mem_Addr_P2	DD  ?		; Addr of plane 2 video memory
    VDA_Mem_Addr_P3	DD  ?		; Addr of plane 3 video memory
    VDA_Mem_DPagOff	DD  ?		; 32 bit offset to start of display
    VDA_Mem_Size_P0	DD  ?		; Size of plane 0 video memory
    VDA_Mem_Size_P1	DD  ?		; Size of plane 1 video memory
    VDA_Mem_Size_P2	DD  ?		; Size of plane 2 video memory
    VDA_Mem_Size_P3	DD  ?		; Size of plane 3 video memory
    VDA_Mem_DACOff	DD  ?		; address of DAC
VDA_Mem_State	ENDS

VDA_Mem_Addr_Win_State EQU VDA_Mem_Addr_P1  ; In text (0-3,7) modes
VDA_Mem_Size_Win_State EQU VDA_Mem_Size_P1

;*******
;
; ADDRESSING VIDEO DISPLAY
;
; Start of the display memory = VDA_Mem_Addr[plane] + VDA_Mem_DPagOffset
;
;   For modes 0-6, the <plane> is always 0
;
;   Displayed memory within a plane is always contiguous from the start
;	address as computed according to the formula above and the macro below.
;	Addressing the display memory from the computed start is as follows,
;	    where X is 0 based column and Y is 0 based row.
;
;	Mode 0-1: Even byte is char, odd byte is attr, 40 cols, 25 rows
;		   one plane.
;	    ChrByteOff=(X/2)+(Y*80); AttrByteOff=ChrByteOff+1
;
;	Mode 2-3,7: Even byte is char, odd byte is attr, 80 cols, 25 rows,
;		   one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 3,"43": Even byte is char, odd byte is attr, 80 cols,
;		    43 rows on EGA or VGA, one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 3,"50": Even byte is char, odd byte is attr, 80 cols,
;		    50 rows on VGA, one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 4-5: 2 bits per PEL, packed into bytes: bits 7-6 is PEL 0,
;		    bits 5-4 is PEL 1, etc. Where PEL = X MOD 4. Odd rows
;		    offset by 8k from even rows. 320 cols, 200 rows, one plane.
;	    PELByteOff=(X/4)+((Y/2)*80)+((Y MOD 2)*8192)
;
;	Mode 6: 1 bit per PEL, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, bit 5 is PEL 2, etc., where PEL = X MOD 8.
;		    Odd rows offset by 8k from even rows. 640 cols, 200 rows,
;		    one plane.
;	    PELByteOff=(X/8)+((Y/2)*160)+((Y MOD 2)*8192)
;
;	Mode D: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 320 cols,
;		    200 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*80)
;
;	Mode E: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    200 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 10: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    350 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 12: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    480 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 13: 8 bits or one byte per PEL.  320 cols, 200 rows, 1 plane.
;	    PELByteOff=(X)+(Y*160)
;
;
;	DestReg     = 32 bit register to place video memory address
;	MemStateReg = 32 bit register which -> VDA_Mem_State
;	MemStateSeg = SEGMENT REGISTER for MemStateReg
;	PlaneReg    = 32 bit register holding plane number desired
;
; ALL REGISTERS MUST BE SEPARATE!!!!!
;
;
GetStartDispAddr MACRO	 DestReg,MemStateReg,PlaneReg,MemStateSeg
	mov	DestReg,MemStateSeg:[MemStateReg.VDA_Mem_Addr_P0][PlaneReg*4]
	add	DestReg,MemStateSeg:[MemStateReg.VDA_Mem_DPagOff]
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VKD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	vkd.inc -
;
;   Version:	1.00
;
;   Date:	10-Aug-1988
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Aug-1988 RAP started re-write of VKD
;   03-Nov-1988 RAP separated internal stuff out into VKDSYS.INC
;
;==============================================================================


Begin_Service_Table VKD

VKD_Service	VKD_Get_Version, LOCAL
VKD_Service	VKD_Define_Hot_Key, LOCAL
VKD_Service	VKD_Remove_Hot_Key, LOCAL
VKD_Service	VKD_Local_Enable_Hot_Key, LOCAL
VKD_Service	VKD_Local_Disable_Hot_Key, LOCAL
VKD_Service	VKD_Reflect_Hot_Key, LOCAL
VKD_Service	VKD_Cancel_Hot_Key_State, LOCAL
VKD_Service	VKD_Force_Keys, LOCAL
VKD_Service	VKD_Get_Kbd_Owner, LOCAL
VKD_Service	VKD_Define_Paste_Mode, LOCAL
VKD_Service	VKD_Start_Paste, LOCAL
VKD_Service	VKD_Cancel_Paste, LOCAL
VKD_Service	VKD_Get_Msg_Key, LOCAL
VKD_Service	VKD_Peek_Msg_Key, LOCAL
VKD_Service	VKD_Flush_Msg_Key_Queue, LOCAL

End_Service_Table VKD


VKD_Version	equ 200h


;******************************************************************************
;
; shift state bits for both global & local shift states
;
		      ;;5432109876543210
SS_Shift	equ	0000000000000001b   ; left or right
SS_LShift	equ	0000000000000010b
SS_RShift	equ	0000001000000000b
SS_Ctrl 	equ	0000000010000000b   ; left or right
SS_LCtrl	equ	0000000000000100b
SS_RCtrl	equ	0000010000000000b
SS_Alt		equ	0000000100000000b   ; left or right
SS_LAlt 	equ	0000000000001000b
SS_RAlt 	equ	0000100000000000b
SS_CapLock	equ	0000000001000000b
SS_NumLock	equ	0000000000100000b
SS_ScrlLock	equ	0000000000010000b
SS_CapLock_Dn	equ	0100000000000000b   ; SS_CapLock shl 8
SS_NumLock_Dn	equ	0010000000000000b   ; SS_NumLock shl 8
SS_ScrlLock_Dn	equ	0001000000000000b   ; SS_ScrlLock shl 8
SS_Unused	equ	1000000000000000b

SS_Toggle_mask	    equ     SS_CapLock + SS_NumLock + SS_ScrlLock
SS_Toggle_Dn_mask   equ     SS_CapLock_Dn + SS_NumLock_Dn + SS_ScrlLock_Dn
SS_LShift_mask	    equ     SS_LShift + SS_LCtrl + SS_LAlt
SS_Shift_mask	    equ     SS_LShift_mask + SS_RShift + SS_RCtrl + SS_RAlt

SS_Either_Shift     equ     SS_LShift + SS_RShift
SS_Either_Ctrl	    equ     SS_LCtrl + SS_RCtrl
SS_Either_Alt	    equ     SS_LAlt + SS_RAlt


; LED state bits
LED_ScLok	equ	1		    ; Scroll Lock
LED_NmLok	equ	2		    ; Num Lock
LED_CpLok	equ	4		    ; Caps Lock
Toggle_To_LED	equ	4		    ; "state shr Toggle_To_LED" converts
					    ; state bits into kybd LED bits


; VKD_Define_Hot_Key equates & macro

ExtendedKey_B	equ 1
ExtendedKey	equ 100h
AllowExtended_B equ 0FFh
AllowExtended	equ 0FF00h


;VKD_Define_Hot_Key flags:

CallOnPress	equ 1		; Call call-back when key press is detected
CallOnRelease	equ 2		; Call call-back when key release is detected
				; (keyboard may still be in hot-key hold state)
CallOnRepeat	equ 4		; Call call-back when repeated press is detected
CallOnComplete	equ 8		; Call call-back when the hot key state is
				; ended (all shift modifier keys are released)
				; or when a different hot key is entered
				; (i.e. pressing ALT 1 2, if both ALT-1
				;  and ALT-2 are defined hot keys, then ALT-1's
				;  call back will be called before ALT-2's to
				;  indicate that the ALT-1 is complete even
				;  though the ALT key is still down)
CallOnUpDwn	equ CallOnPress + CallOnRelease
				; Call call-back on both press and release
CallOnAll	equ 0		; Call call-back on press, release, auto-repeat
				; and complete
PriorityNotify	equ 10h 	; notification calls to the call-back can only
				; happen when interrupts are enabled and
				; the critical section is un-owned
Local_Key	equ 80h 	; key can be locally enabled/disabled

Hot_Key_Pressed     equ 0
Hot_Key_Released    equ 1
Hot_Key_Repeated    equ 2
Hot_Key_Completed   equ 3

Hot_Key_SysVM_Notify	 equ 80h
Hot_Key_SysVM_Notify_bit equ 7

BeginDoc
;******************************************************************************
;
;   ShiftState
;
;   DESCRIPTION:    Macro to aid in setting EBX with the shift state mask and
;		    shift state compare value for calling VKD_Define_Hot_Key.
;
;   USAGE:	    ShiftState mask, compare
;
;		    The mask specifies the shift state bits that should be
;		    excluded before the compare is done.
;
;==============================================================================
EndDoc
ShiftState MACRO mask, compare
	mov	ebx, ((NOT mask) SHL 16) + compare
	   ENDM

; common shift states

HKSS_Shift  equ (NOT (SS_Either_Shift + SS_Toggle_mask)) SHL 16 + SS_Shift
HKSS_Ctrl   equ (NOT (SS_Either_Ctrl + SS_Toggle_mask)) SHL 16 + SS_Ctrl
HKSS_Alt    equ (NOT (SS_Either_Alt + SS_Toggle_mask)) SHL 16 + SS_Alt


; include structure of entries in paste buffer

include VKDpaste.INC


; paste completion flags passed to the paste call-back

Paste_Complete	equ 0	; paste successful
Paste_Aborted	equ 1	; paste aborted by user
Paste_VM_Term	equ 2	; paste aborted because VM terminated

;
; Modifier byte for Message Keys, retrieved with services VKD_Get_Msg_Key and
; VKD_Peek_Msg_Key
;
MK_Shift	equ 00000010b
MK_Ctrl 	equ 00000100b
MK_Alt		equ 00001000b
MK_Extended	equ 10000000b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VER.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

#ifdef LIB

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

#endif /* LIB */

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMM.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef _VMM_
_VMM_	EQU	1
FALSE	EQU	0
VMM_TRUE	EQU	(NOT FALSE)
DEBLEVELRETAIL	EQU	0
DEBLEVELNORMAL	EQU	1
DEBLEVELMAX	EQU	2
ifndef DEBLEVEL
ifdef DEBUG
DEBLEVEL	EQU	DEBLEVELNORMAL
else
DEBLEVEL	EQU	DEBLEVELRETAIL
endif
endif
ifndef WIN31COMPAT
WIN40SERVICES	EQU	1
endif
ifdef MASM6
ifndef NO_MASM6_OPTIONS



    option oldmacros
ifndef  NEWSTRUCTS
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif




IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF

UNDEFINED_DEVICE_ID	EQU	00000H
VMM_DEVICE_ID	EQU	00001H
DEBUG_DEVICE_ID	EQU	00002H
VPICD_DEVICE_ID	EQU	00003H
VDMAD_DEVICE_ID	EQU	00004H
VTD_DEVICE_ID	EQU	00005H
V86MMGR_DEVICE_ID	EQU	00006H
PAGESWAP_DEVICE_ID	EQU	00007H
PARITY_DEVICE_ID	EQU	00008H
REBOOT_DEVICE_ID	EQU	00009H
VDD_DEVICE_ID	EQU	0000AH
VSD_DEVICE_ID	EQU	0000BH
VMD_DEVICE_ID	EQU	0000CH
VKD_DEVICE_ID	EQU	0000DH
VCD_DEVICE_ID	EQU	0000EH
VPD_DEVICE_ID	EQU	0000FH
BLOCKDEV_DEVICE_ID	EQU	00010H
VMCPD_DEVICE_ID	EQU	00011H
EBIOS_DEVICE_ID	EQU	00012H
BIOSXLAT_DEVICE_ID	EQU	00013H
VNETBIOS_DEVICE_ID	EQU	00014H
DOSMGR_DEVICE_ID	EQU	00015H
WINLOAD_DEVICE_ID	EQU	00016H
SHELL_DEVICE_ID	EQU	00017H
VMPOLL_DEVICE_ID	EQU	00018H
VPROD_DEVICE_ID	EQU	00019H
DOSNET_DEVICE_ID	EQU	0001AH
VFD_DEVICE_ID	EQU	0001BH
VDD2_DEVICE_ID	EQU	0001CH
WINDEBUG_DEVICE_ID	EQU	0001DH
TSRLOAD_DEVICE_ID	EQU	0001EH
BIOSHOOK_DEVICE_ID	EQU	0001FH
INT13_DEVICE_ID	EQU	00020H
PAGEFILE_DEVICE_ID	EQU	00021H
SCSI_DEVICE_ID	EQU	00022H
MCA_POS_DEVICE_ID	EQU	00023H
SCSIFD_DEVICE_ID	EQU	00024H
VPEND_DEVICE_ID	EQU	00025H
APM_DEVICE_ID	EQU	00026H
VPOWERD_DEVICE_ID	EQU	APM_DEVICE_ID
VXDLDR_DEVICE_ID	EQU	00027H
NDIS_DEVICE_ID	EQU	00028H
BIOS_EXT_DEVICE_ID	EQU	00029H
VWIN32_DEVICE_ID	EQU	0002AH
VCOMM_DEVICE_ID	EQU	0002BH
SPOOLER_DEVICE_ID	EQU	0002CH
WIN32S_DEVICE_ID	EQU	0002DH
DEBUGCMD_DEVICE_ID	EQU	0002EH
CONFIGMG_DEVICE_ID	EQU	00033H
DWCFGMG_DEVICE_ID	EQU	00034H
SCSIPORT_DEVICE_ID	EQU	00035H
VFBACKUP_DEVICE_ID	EQU	00036H
ENABLE_DEVICE_ID	EQU	00037H
VCOND_DEVICE_ID	EQU	00038H
ISAPNP_DEVICE_ID	EQU	0003CH
BIOS_DEVICE_ID	EQU	0003DH
IFSMgr_Device_ID	EQU	00040H
VCDFSD_DEVICE_ID	EQU	00041H
MRCI2_DEVICE_ID	EQU	00042H
PCI_DEVICE_ID	EQU	00043H
PELOADER_DEVICE_ID	EQU	00044H
EISA_DEVICE_ID	EQU	00045H
DRAGCLI_DEVICE_ID	EQU	00046H
DRAGSRV_DEVICE_ID	EQU	00047H
PERF_DEVICE_ID	EQU	00048H
AWREDIR_DEVICE_ID	EQU	00049H
ETEN_Device_ID	EQU	00060H
CHBIOS_Device_ID	EQU	00061H
VMSGD_Device_ID	EQU	00062H
VPPID_Device_ID	EQU	00063H
VIME_Device_ID	EQU	00064H
VHBIOSD_Device_ID	EQU	00065H
BASEID_FOR_NAMEBASEDVXD	EQU	0f000H
BASEID_FOR_NAMEBASEDVXD_MASK	EQU	0fffH
VMM_INIT_ORDER	EQU	000000000H
DEBUG_INIT_ORDER	EQU	000000000H
DEBUGCMD_INIT_ORDER	EQU	000000000H
PERF_INIT_ORDER	EQU	000900000H
APM_INIT_ORDER	EQU	001000000H
VPOWERD_INIT_ORDER	EQU	APM_INIT_ORDER
BIOSHOOK_INIT_ORDER	EQU	006000000H
VPROD_INIT_ORDER	EQU	008000000H
VPICD_INIT_ORDER	EQU	00C000000H
VTD_INIT_ORDER	EQU	014000000H
VXDLDR_INIT_ORDER	EQU	016000000H
ENUMERATOR_INIT_ORDER	EQU	016800000H
ISAPNP_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
EISA_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
PCI_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
BIOS_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+1
CONFIGMG_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+0FFFFH
VCDFSD_INIT_ORDER	EQU	016F00000H
IOS_INIT_ORDER	EQU	017000000H
PAGEFILE_INIT_ORDER	EQU	018000000H
PAGESWAP_INIT_ORDER	EQU	01C000000H
PARITY_INIT_ORDER	EQU	020000000H
REBOOT_INIT_ORDER	EQU	024000000H
EBIOS_INIT_ORDER	EQU	026000000H
VDD_INIT_ORDER	EQU	028000000H
VSD_INIT_ORDER	EQU	02C000000H
VCD_INIT_ORDER	EQU	030000000H
COMMDRVR_INIT_ORDER	EQU	(VCD_INIT_ORDER-1)
PRTCL_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-2)
MODEM_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-3)
PORT_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-4)
VMD_INIT_ORDER	EQU	034000000H
VKD_INIT_ORDER	EQU	038000000H
VPD_INIT_ORDER	EQU	03C000000H
BLOCKDEV_INIT_ORDER	EQU	040000000H
MCA_POS_INIT_ORDER	EQU	041000000H
SCSIFD_INIT_ORDER	EQU	041400000H
SCSIMASTER_INIT_ORDER	EQU	041800000H
INT13_INIT_ORDER	EQU	042000000H
VMCPD_INIT_ORDER	EQU	048000000H
BIOSXLAT_INIT_ORDER	EQU	050000000H
VNETBIOS_INIT_ORDER	EQU	054000000H
DOSMGR_INIT_ORDER	EQU	058000000H
DOSNET_INIT_ORDER	EQU	05C000000H
WINLOAD_INIT_ORDER	EQU	060000000H
VMPOLL_INIT_ORDER	EQU	064000000H
UNDEFINED_INIT_ORDER	EQU	080000000H
WIN32_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
VCOND_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
WINDEBUG_INIT_ORDER	EQU	081000000H
VDMAD_INIT_ORDER	EQU	090000000H
V86MMGR_INIT_ORDER	EQU	0A0000000H
IFSMgr_Init_Order	EQU	10000H+V86MMGR_Init_Order
FSD_Init_Order	EQU	00100H+IFSMgr_Init_Order
VFD_INIT_ORDER	EQU	50000H+IFSMgr_Init_Order
UNDEF_TOUCH_MEM_INIT_ORDER	EQU	0A8000000H
SHELL_INIT_ORDER	EQU	0B0000000H






IO_Delay    macro
jmp $+2
ENDM

VXD_FAILURE	EQU	0
VXD_SUCCESS	EQU	1

Pushad_Struc	STRUC
Pushad_EDI	DD	?
Pushad_ESI	DD	?
Pushad_EBP	DD	?
Pushad_ESP	DD	?
Pushad_EBX	DD	?
Pushad_EDX	DD	?
Pushad_ECX	DD	?
Pushad_EAX	DD	?
Pushad_Struc	ENDS
ifndef Not_VxD
??_CUR_CODE_SEG = 0

??_LCODE    =   1
??_ICODE    =   2
??_PCODE    =   3
??_SCODE    =   4
??_DBOCODE  =   5
??_16ICODE  =   6
??_RCODE    =   7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE  equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS





IFDEF   MASM6
_FLAT   EQU FLAT
ELSE
_FLAT   EQU USE32
ENDIF


_LTEXT      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT      ENDS

_TEXT       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT       ENDS


_PTEXT      SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT      ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>

IFNB    <classname>
    segname     SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname     SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
        ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB    <grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM











DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM









DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM





CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
        extrn   name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM






MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM






MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or  ??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM



_ITEXT      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT      ENDS


_LDATA      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA      ENDS

_DATA       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA       ENDS


_PDATA      SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA      ENDS


_IDATA      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA      ENDS


_BSS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS        ENDS

CONST       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST       ENDS

_TLS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS        ENDS


_STEXT      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT      ENDS


_SDATA      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA      ENDS


_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS


_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS


_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL

_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS


_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS


_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif


_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS


_RCODE      SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE      ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP	  GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc





































EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF   Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID    = 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName  Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName   MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table

Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&Procedure

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
    EXTRN   Procedure:NEAR
      ELSE
    dd  OFFSET32 Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
        IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
        ENDIF
        IFNB <Condition>
    $$&&Procedure extern
       ELSE
    EXTRN   Procedure:NEAR
        ENDIF
        IFNB <Local_Seg>
Local_Seg&&_ENDS
        ELSE
Def_Segment&_CODE_ENDS
        ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
    dd  OFFSET32 Procedure
      ENDIF

          IFDEF Device_Name&_Name_Based
        @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
          ELSE
        @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
          ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    ENDM

ELSE



IFDEF   Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ENDIF

ENDIF

    ENDM



End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal    macro   reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress    macro   reg,service
    mov reg,OFFSET32 service
    endm


















Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd  csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
        .erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
        dd  OFFSET32 Name,cparm&&Name
    endif
        @32&&Name equ   ((VxDName&_Device_ID SHL 16) + ??w32svcno)
        ??w32svcno = ??w32svcno + 1
        ENDM
    ENDM










End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM











Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM












Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM







Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
        ENDM


BeginDoc

















EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h


cb_s	STRUC
CB_VM_Status	DD	?
CB_High_Linear	DD	?
CB_Client_Pointer	DD	?
CB_VMID	DD	?
CB_Signature	DD	?
cb_s	ENDS
VMCB_ID	EQU	62634D56H
VMSTAT_EXCLUSIVE_BIT	EQU	00H
VMSTAT_EXCLUSIVE	EQU	(1 SHL VMSTAT_EXCLUSIVE_BIT)
VMSTAT_BACKGROUND_BIT	EQU	01H
VMSTAT_BACKGROUND	EQU	(1 SHL VMSTAT_BACKGROUND_BIT)
VMSTAT_CREATING_BIT	EQU	02H
VMSTAT_CREATING	EQU	(1 SHL VMSTAT_CREATING_BIT)
VMSTAT_SUSPENDED_BIT	EQU	03H
VMSTAT_SUSPENDED	EQU	(1 SHL VMSTAT_SUSPENDED_BIT)
VMSTAT_NOT_EXECUTEABLE_BIT	EQU	04H
VMSTAT_NOT_EXECUTEABLE	EQU	(1 SHL VMSTAT_NOT_EXECUTEABLE_BIT)
VMSTAT_PM_EXEC_BIT	EQU	05H
VMSTAT_PM_EXEC	EQU	(1 SHL VMSTAT_PM_EXEC_BIT)
VMSTAT_PM_APP_BIT	EQU	06H
VMSTAT_PM_APP	EQU	(1 SHL VMSTAT_PM_APP_BIT)
VMSTAT_PM_USE32_BIT	EQU	07H
VMSTAT_PM_USE32	EQU	(1 SHL VMSTAT_PM_USE32_BIT)
VMSTAT_VXD_EXEC_BIT	EQU	08H
VMSTAT_VXD_EXEC	EQU	(1 SHL VMSTAT_VXD_EXEC_BIT)
VMSTAT_HIGH_PRI_BACK_BIT	EQU	09H
VMSTAT_HIGH_PRI_BACK	EQU	(1 SHL VMSTAT_HIGH_PRI_BACK_BIT)
VMSTAT_BLOCKED_BIT	EQU	0AH
VMSTAT_BLOCKED	EQU	(1 SHL VMSTAT_BLOCKED_BIT)
VMSTAT_AWAKENING_BIT	EQU	0BH
VMSTAT_AWAKENING	EQU	(1 SHL VMSTAT_AWAKENING_BIT)
VMSTAT_PAGEABLEV86BIT	EQU	0CH
VMSTAT_PAGEABLEV86_BIT	EQU	VMSTAT_PAGEABLEV86BIT
VMSTAT_PAGEABLEV86	EQU	(1 SHL VMSTAT_PAGEABLEV86BIT)
VMSTAT_V86INTSLOCKEDBIT	EQU	0DH
VMSTAT_V86INTSLOCKED_BIT	EQU	VMSTAT_V86INTSLOCKEDBIT
VMSTAT_V86INTSLOCKED	EQU	(1 SHL VMSTAT_V86INTSLOCKEDBIT)
VMSTAT_IDLE_TIMEOUT_BIT	EQU	0EH
VMSTAT_IDLE_TIMEOUT	EQU	(1 SHL VMSTAT_IDLE_TIMEOUT_BIT)
VMSTAT_IDLE_BIT	EQU	0FH
VMSTAT_IDLE	EQU	(1 SHL VMSTAT_IDLE_BIT)
VMSTAT_CLOSING_BIT	EQU	10H
VMSTAT_CLOSING	EQU	(1 SHL VMSTAT_CLOSING_BIT)
VMSTAT_TS_SUSPENDED_BIT	EQU	11H
VMSTAT_TS_SUSPENDED	EQU	(1 SHL VMSTAT_TS_SUSPENDED_BIT)
VMSTAT_TS_MAXPRI_BIT	EQU	12H
VMSTAT_TS_MAXPRI	EQU	(1 SHL VMSTAT_TS_MAXPRI_BIT)
VMSTAT_USE32_MASK	EQU	(VMSTAT_PM_USE32 OR VMSTAT_VXD_EXEC)

tcb_s	STRUC
TCB_Flags	DD	?
TCB_Reserved1	DD	?
TCB_Reserved2	DD	?
TCB_Signature	DD	?
TCB_ClientPtr	DD	?
TCB_VMHandle	DD	?
TCB_ThreadId	DW	?
TCB_PMLockOrigSS	DW	?
TCB_PMLockOrigESP	DD	?
TCB_PMLockOrigEIP	DD	?
TCB_PMLockStackCount	DD	?
TCB_PMLockOrigCS	DW	?
TCB_PMPSPSelector	DW	?
TCB_ThreadType	DD	?
TCB_pad1	DW	?
TCB_pad2	DB	?
TCB_extErrLocus	DB	?
TCB_extErr	DW	?
TCB_extErrAction	DB	?
TCB_extErrClass	DB	?
TCB_extErrPtr	DD	?
tcb_s	ENDS
SCHED_OBJ_ID_THREAD	EQU	42434854H
THFLAG_SUSPENDED_BIT	EQU	03H
THFLAG_SUSPENDED	EQU	(1 SHL THFLAG_SUSPENDED_BIT)
THFLAG_NOT_EXECUTEABLE_BIT	EQU	04H
THFLAG_NOT_EXECUTEABLE	EQU	(1 SHL THFLAG_NOT_EXECUTEABLE_BIT)
THFLAG_THREAD_CREATION_BIT	EQU	08H
THFLAG_THREAD_CREATION	EQU	(1 SHL THFLAG_THREAD_CREATION_BIT)
THFLAG_THREAD_BLOCKED_BIT	EQU	0AH
THFLAG_THREAD_BLOCKED	EQU	(1 SHL THFLAG_THREAD_BLOCKED_BIT)
THFLAG_RING0_THREAD_BIT	EQU	1CH
THFLAG_RING0_THREAD	EQU	(1 SHL THFLAG_RING0_THREAD_BIT)
THFLAG_CHARSET_BITS	EQU	10H
THFLAG_CHARSET_MASK	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_ANSI	EQU	(0 SHL THFLAG_CHARSET_BITS)
THFLAG_OEM	EQU	(1 SHL THFLAG_CHARSET_BITS)
THFLAG_UNICODE	EQU	(2 SHL THFLAG_CHARSET_BITS)
THFLAG_RESERVED	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_EXTENDED_HANDLES_BIT	EQU	12H
THFLAG_EXTENDED_HANDLES	EQU	(1 SHL THFLAG_EXTENDED_HANDLES_BIT)
THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT	EQU	13H
THFLAG_OPEN_AS_IMMOVABLE_FILE	EQU	(1 SHL THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

pmcb_s	STRUC
PMCB_Flags	DD	?
PMCB_Parent	DD	?
pmcb_s	ENDS

VMFaultInfo	STRUC
VMFI_EIP	DD	?
VMFI_CS	DW	?
VMFI_Ints	DW	?
VMFaultInfo	ENDS
Begin_Service_Table VMM, VMM
VMM_Service  Get_VMM_Version, LOCAL
VMM_Service  Get_Cur_VM_Handle
VMM_Service  Test_Cur_VM_Handle
VMM_Service  Get_Sys_VM_Handle
VMM_Service  Test_Sys_VM_Handle
VMM_Service  Validate_VM_Handle
VMM_Service  Get_VMM_Reenter_Count
VMM_Service  Begin_Reentrant_Execution
VMM_Service  End_Reentrant_Execution
VMM_Service  Install_V86_Break_Point
VMM_Service  Remove_V86_Break_Point
VMM_Service  Allocate_V86_Call_Back
VMM_Service  Allocate_PM_Call_Back
VMM_Service  Call_When_VM_Returns
VMM_Service  Schedule_Global_Event
VMM_Service  Schedule_VM_Event
VMM_Service  Call_Global_Event
VMM_Service  Call_VM_Event
VMM_Service  Cancel_Global_Event
VMM_Service  Cancel_VM_Event
VMM_Service  Call_Priority_VM_Event
VMM_Service  Cancel_Priority_VM_Event
VMM_Service  Get_NMI_Handler_Addr
VMM_Service  Set_NMI_Handler_Addr
VMM_Service  Hook_NMI_Event
VMM_Service  Call_When_VM_Ints_Enabled
VMM_Service  Enable_VM_Ints
VMM_Service  Disable_VM_Ints
VMM_Service  Map_Flat
VMM_Service  Map_Lin_To_VM_Addr
VMM_Service  Adjust_Exec_Priority
VMM_Service  Begin_Critical_Section
VMM_Service  End_Critical_Section
VMM_Service  End_Crit_And_Suspend
VMM_Service  Claim_Critical_Section
VMM_Service  Release_Critical_Section
VMM_Service  Call_When_Not_Critical
VMM_Service  Create_Semaphore
VMM_Service  Destroy_Semaphore
VMM_Service  Wait_Semaphore
VMM_Service  Signal_Semaphore
VMM_Service  Get_Crit_Section_Status
VMM_Service  Call_When_Task_Switched
VMM_Service  Suspend_VM
VMM_Service  Resume_VM
VMM_Service  No_Fail_Resume_VM
VMM_Service  Nuke_VM
VMM_Service  Crash_Cur_VM
VMM_Service  Get_Execution_Focus
VMM_Service  Set_Execution_Focus
VMM_Service  Get_Time_Slice_Priority
VMM_Service  Set_Time_Slice_Priority
VMM_Service  Get_Time_Slice_Granularity
VMM_Service  Set_Time_Slice_Granularity
VMM_Service  Get_Time_Slice_Info
VMM_Service  Adjust_Execution_Time
VMM_Service  Release_Time_Slice
VMM_Service  Wake_Up_VM
VMM_Service  Call_When_Idle
VMM_Service  Get_Next_VM_Handle
VMM_Service  Set_Global_Time_Out
VMM_Service  Set_VM_Time_Out
VMM_Service  Cancel_Time_Out
VMM_Service  Get_System_Time
VMM_Service  Get_VM_Exec_Time
VMM_Service  Hook_V86_Int_Chain
VMM_Service  Get_V86_Int_Vector
VMM_Service  Set_V86_Int_Vector
VMM_Service  Get_PM_Int_Vector
VMM_Service  Set_PM_Int_Vector
VMM_Service  Simulate_Int
VMM_Service  Simulate_Iret
VMM_Service  Simulate_Far_Call
VMM_Service  Simulate_Far_Jmp
VMM_Service  Simulate_Far_Ret
VMM_Service  Simulate_Far_Ret_N
VMM_Service  Build_Int_Stack_Frame
VMM_Service  Simulate_Push
VMM_Service  Simulate_Pop
VMM_Service  _HeapAllocate
VMM_Service  _HeapReAllocate
VMM_Service  _HeapFree
VMM_Service  _HeapGetSize
HEAPZEROINIT	EQU	00000001H
HEAPZEROREINIT	EQU	00000002H
HEAPNOCOPY	EQU	00000004H
HEAPLOCKEDIFDP	EQU	00000100H
HEAPSWAP	EQU	00000200H
HEAPINIT	EQU	00000400H
HEAPCLEAN	EQU	00000800H
VMM_Service  _PageAllocate
VMM_Service  _PageReAllocate
VMM_Service  _PageFree
VMM_Service  _PageLock
VMM_Service  _PageUnLock
VMM_Service  _PageGetSizeAddr
VMM_Service  _PageGetAllocInfo
VMM_Service  _GetFreePageCount
VMM_Service  _GetSysPageCount
VMM_Service  _GetVMPgCount
VMM_Service  _MapIntoV86
VMM_Service  _PhysIntoV86
VMM_Service  _TestGlobalV86Mem
VMM_Service  _ModifyPageBits
VMM_Service  _CopyPageTable
VMM_Service  _LinMapIntoV86
VMM_Service  _LinPageLock
VMM_Service  _LinPageUnLock
VMM_Service  _SetResetV86Pageable
VMM_Service  _GetV86PageableArray
VMM_Service  _PageCheckLinRange
VMM_Service  _PageOutDirtyPages
VMM_Service  _PageDiscardPages
PAGEZEROINIT	EQU	00000001H
PAGEUSEALIGN	EQU	00000002H
PAGECONTIG	EQU	00000004H
PAGEFIXED	EQU	00000008H
PAGEDEBUGNULFAULT	EQU	00000010H
PAGEZEROREINIT	EQU	00000020H
PAGENOCOPY	EQU	00000040H
PAGELOCKED	EQU	00000080H
PAGELOCKEDIFDP	EQU	00000100H
PAGESETV86PAGEABLE	EQU	00000200H
PAGECLEARV86PAGEABLE	EQU	00000400H
PAGESETV86INTSLOCKED	EQU	00000800H
PAGECLEARV86INTSLOCKED	EQU	00001000H
PAGEMARKPAGEOUT	EQU	00002000H
PAGEPDPSETBASE	EQU	00004000H
PAGEPDPCLEARBASE	EQU	00008000H
PAGEDISCARD	EQU	00010000H
PAGEPDPQUERYDIRTY	EQU	00020000H
PAGEMAPFREEPHYSREG	EQU	00040000H
PAGENOMOVE	EQU	10000000H
PAGEMAPGLOBAL	EQU	40000000H
PAGEMARKDIRTY	EQU	80000000H
MAPV86_IGNOREWRAP	EQU	00000001H
VMM_Service  _GetNulPageHandle
VMM_Service  _GetFirstV86Page
VMM_Service  _MapPhysToLinear
VMM_Service  _GetAppFlatDSAlias
VMM_Service  _SelectorMapFlat
VMM_Service  _GetDemandPageInfo
VMM_Service  _GetSetPageOutCount
GSPOC_F_GET	EQU	00000001H
VMM_Service  Hook_V86_Page
VMM_Service  _Assign_Device_V86_Pages
VMM_Service  _DeAssign_Device_V86_Pages
VMM_Service  _Get_Device_V86_Pages_Array
VMM_Service  MMGR_SetNULPageAddr
VMM_Service  _Allocate_GDT_Selector
VMM_Service  _Free_GDT_Selector
VMM_Service  _Allocate_LDT_Selector
VMM_Service  _Free_LDT_Selector
VMM_Service  _BuildDescriptorDWORDs
VMM_Service  _GetDescriptor
VMM_Service  _SetDescriptor
BDDEXPLICITDPL	EQU	00000001H
ALDTSPECSEL	EQU	00000001H
VMM_Service  _MMGR_Toggle_HMA
MMGRHMAPHYSICAL	EQU	00000001H
MMGRHMAENABLE	EQU	00000002H
MMGRHMADISABLE	EQU	00000004H
MMGRHMAQUERY	EQU	00000008H
VMM_Service  Get_Fault_Hook_Addrs
VMM_Service  Hook_V86_Fault
VMM_Service  Hook_PM_Fault
VMM_Service  Hook_VMM_Fault
VMM_Service  Begin_Nest_V86_Exec
VMM_Service  Begin_Nest_Exec
VMM_Service  Exec_Int
VMM_Service  Resume_Exec
VMM_Service  End_Nest_Exec
VMM_Service  Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service  Get_Cur_PM_App_CB
VMM_Service  Set_V86_Exec_Mode
VMM_Service  Set_PM_Exec_Mode
VMM_Service  Begin_Use_Locked_PM_Stack
VMM_Service  End_Use_Locked_PM_Stack
VMM_Service  Save_Client_State
VMM_Service  Restore_Client_State
VMM_Service  Exec_VxD_Int
VMM_Service  Hook_Device_Service
VMM_Service  Hook_Device_V86_API
VMM_Service  Hook_Device_PM_API
VMM_Service  System_Control
VMM_Service  Simulate_IO
VMM_Service  Install_Mult_IO_Handlers
VMM_Service  Install_IO_Handler
VMM_Service  Enable_Global_Trapping
VMM_Service  Enable_Local_Trapping
VMM_Service  Disable_Global_Trapping
VMM_Service  Disable_Local_Trapping
VMM_Service  List_Create
VMM_Service  List_Destroy
VMM_Service  List_Allocate
VMM_Service  List_Attach
VMM_Service  List_Attach_Tail
VMM_Service  List_Insert
VMM_Service  List_Remove
VMM_Service  List_Deallocate
VMM_Service  List_Get_First
VMM_Service  List_Get_Next
VMM_Service  List_Remove_First
LF_ASYNC_BIT	EQU	0
LF_ASYNC	EQU	(1 SHL LF_ASYNC_BIT)
LF_USE_HEAP_BIT	EQU	1
LF_USE_HEAP	EQU	(1 SHL LF_USE_HEAP_BIT)
LF_ALLOC_ERROR_BIT	EQU	2
LF_ALLOC_ERROR	EQU	(1 SHL LF_ALLOC_ERROR_BIT)
LF_SWAP	EQU	(LF_USE_HEAP+(1 SHL 3))
VMM_Service  _AddInstanceItem
VMM_Service  _Allocate_Device_CB_Area
VMM_Service  _Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service  _Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service  _Free_Temp_V86_Data_Area, VMM_ICODE
GVDAWordAlign	EQU	00000001H
GVDADWordAlign	EQU	00000002H
GVDAParaAlign	EQU	00000004H
GVDAPageAlign	EQU	00000008H
GVDAInstance	EQU	00000100H
GVDAZeroInit	EQU	00000200H
GVDAReclaim	EQU	00000400H
GVDAInquire	EQU	00000800H
GVDAHighSysCritOK	EQU	00001000H
GVDAOptInstance	EQU	00002000H
GVDAForceLow	EQU	00004000H
TVDANeedTilInitComplete	EQU	00000001H
VMM_Service  Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service  Convert_Decimal_String, VMM_ICODE
VMM_Service  Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service  Convert_Fixed_Point_String, VMM_ICODE
VMM_Service  Get_Profile_Hex_Int, VMM_ICODE
VMM_Service  Convert_Hex_String, VMM_ICODE
VMM_Service  Get_Profile_Boolean, VMM_ICODE
VMM_Service  Convert_Boolean_String, VMM_ICODE
VMM_Service  Get_Profile_String, VMM_ICODE
VMM_Service  Get_Next_Profile_String, VMM_ICODE
VMM_Service  Get_Environment_String, VMM_ICODE
VMM_Service  Get_Exec_Path, VMM_ICODE
VMM_Service  Get_Config_Directory, VMM_ICODE
VMM_Service  OpenFile, VMM_ICODE
VMM_OPENFILE_BUF_SIZE	EQU	260
VMM_Service  Get_PSP_Segment, VMM_ICODE
VMM_Service  GetDOSVectors, VMM_ICODE
VMM_Service  Get_Machine_Info
GMIF_80486_BIT	EQU	10H
GMIF_80486	EQU	(1 SHL GMIF_80486_BIT)
GMIF_PCXT_BIT	EQU	11H
GMIF_PCXT	EQU	(1 SHL GMIF_PCXT_BIT)
GMIF_MCA_BIT	EQU	12H
GMIF_MCA	EQU	(1 SHL GMIF_MCA_BIT)
GMIF_EISA_BIT	EQU	13H
GMIF_EISA	EQU	(1 SHL GMIF_EISA_BIT)
GMIF_CPUID_BIT	EQU	14H
GMIF_CPUID	EQU	(1 SHL GMIF_CPUID_BIT)
VMM_Service  GetSet_HMA_Info
VMM_Service  Set_System_Exit_Code
VMM_Service  Fatal_Error_Handler
VMM_Service  Fatal_Memory_Error
VMM_Service  Update_System_Clock
VMM_Service  Test_Debug_Installed
VMM_Service  Out_Debug_String
VMM_Service  Out_Debug_Chr
VMM_Service  In_Debug_Chr
VMM_Service  Debug_Convert_Hex_Binary
VMM_Service  Debug_Convert_Hex_Decimal
VMM_Service  Debug_Test_Valid_Handle
VMM_Service  Validate_Client_Ptr
VMM_Service  Test_Reenter
VMM_Service  Queue_Debug_String
VMM_Service  Log_Proc_Call
VMM_Service  Debug_Test_Cur_VM
VMM_Service  Get_PM_Int_Type
VMM_Service  Set_PM_Int_Type
VMM_Service  Get_Last_Updated_System_Time
VMM_Service  Get_Last_Updated_VM_Exec_Time
VMM_Service  Test_DBCS_Lead_Byte
.errnz  @@Test_DBCS_Lead_Byte - 100D1h

VMM_Service  _AddFreePhysPage, VMM_ICODE
VMM_Service  _PageResetHandlePAddr
VMM_Service  _SetLastV86Page, VMM_ICODE
VMM_Service  _GetLastV86Page
VMM_Service  _MapFreePhysReg
VMM_Service  _UnmapFreePhysReg
VMM_Service  _XchgFreePhysReg
VMM_Service  _SetFreePhysRegCalBk, VMM_ICODE
VMM_Service  Get_Next_Arena, VMM_ICODE
VMM_Service  Get_Name_Of_Ugly_TSR, VMM_ICODE
VMM_Service  Get_Debug_Options, VMM_ICODE
AFPP_SWAPOUT	EQU	0001H
PCP_CHANGEPAGER	EQU	1H
PCP_CHANGEPAGERDATA	EQU	2H
PCP_VIRGINONLY	EQU	4H
GNA_HIDOSLINKED	EQU	0002H
GNA_ISHIGHDOS	EQU	0004H
VMM_Service  Set_Physical_HMA_Alias, VMM_ICODE
VMM_Service  _GetGlblRng0V86IntBase, VMM_ICODE
VMM_Service  _Add_Global_V86_Data_Area, VMM_ICODE
VMM_Service  GetSetDetailedVMError
GSDVME_PRIVINST	EQU	00010001H
GSDVME_INVALINST	EQU	00010002H
GSDVME_INVALPGFLT	EQU	00010003H
GSDVME_INVALGPFLT	EQU	00010004H
GSDVME_INVALFLT	EQU	00010005H
GSDVME_USERNUKE	EQU	00010006H
GSDVME_DEVNUKE	EQU	00010007H
GSDVME_DEVNUKEHDWR	EQU	00010008H
GSDVME_NUKENOMSG	EQU	00010009H
GSDVME_OKNUKEMASK	EQU	80000000H
GSDVME_INSMEMV86	EQU	00020001H
GSDVME_INSV86SPACE	EQU	00020002H
GSDVME_INSMEMXMS	EQU	00020003H
GSDVME_INSMEMEMS	EQU	00020004H
GSDVME_INSMEMV86HI	EQU	00020005H
GSDVME_INSMEMVID	EQU	00020006H
GSDVME_INSMEMVM	EQU	00020007H
GSDVME_INSMEMDEV	EQU	00020008H
GSDVME_CRTNOMSG	EQU	00020009H
VMM_Service  Is_Debug_Chr
VMM_Service  Clear_Mono_Screen
VMM_Service  Out_Mono_Chr
VMM_Service  Out_Mono_String
VMM_Service  Set_Mono_Cur_Pos
VMM_Service  Get_Mono_Cur_Pos
VMM_Service  Get_Mono_Chr
VMM_Service  Locate_Byte_In_ROM, VMM_ICODE
VMM_Service  Hook_Invalid_Page_Fault
VMM_Service  Unhook_Invalid_Page_Fault
IPF_PGDIR	EQU	00000001H
IPF_V86PG	EQU	00000002H
IPF_V86PGH	EQU	00000004H
IPF_INVTYP	EQU	00000008H
IPF_PGERR	EQU	00000010H
IPF_REFLT	EQU	00000020H
IPF_VMM	EQU	00000040H
IPF_PM	EQU	00000080H
IPF_V86	EQU	00000100H
VMM_Service  Set_Delete_On_Exit_File
VMM_Service  Close_VM
CVF_CONTINUE_EXEC_BIT	EQU	0
CVF_CONTINUE_EXEC	EQU	(1 SHL CVF_CONTINUE_EXEC_BIT)
VMM_Service  Enable_Touch_1st_Meg
VMM_Service  Disable_Touch_1st_Meg
VMM_Service  Install_Exception_Handler
VMM_Service  Remove_Exception_Handler
VMM_Service  Get_Crit_Status_No_Block

.errnz   @@Get_Crit_Status_No_Block - 100F1h

ifdef WIN40SERVICES
VMM_Service  _GetLastUpdatedThreadExecTime
VMM_Service  _Trace_Out_Service
VMM_Service  _Debug_Out_Service
VMM_Service  _Debug_Flags_Service
endif
DFS_LOG_BIT	EQU	0
DFS_LOG	EQU	(1 SHL DFS_LOG_BIT)
DFS_PROFILE_BIT	EQU	1
DFS_PROFILE	EQU	(1 SHL DFS_PROFILE_BIT)
DFS_TEST_CLD_BIT	EQU	2
DFS_TEST_CLD	EQU	(1 SHL DFS_TEST_CLD_BIT)
DFS_NEVER_REENTER_BIT	EQU	3
DFS_NEVER_REENTER	EQU	(1 SHL DFS_NEVER_REENTER_BIT)
DFS_TEST_REENTER_BIT	EQU	4
DFS_TEST_REENTER	EQU	(1 SHL DFS_TEST_REENTER_BIT)
DFS_NOT_SWAPPING_BIT	EQU	5
DFS_NOT_SWAPPING	EQU	(1 SHL DFS_NOT_SWAPPING_BIT)
DFS_TEST_BLOCK_BIT	EQU	6
DFS_TEST_BLOCK	EQU	(1 SHL DFS_TEST_BLOCK_BIT)
DFS_RARE_SERVICES	EQU	0FFFFFF80H
DFS_EXIT_NOBLOCK	EQU	(DFS_RARE_SERVICES+0)
DFS_ENTER_NOBLOCK	EQU	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)
DFS_TEST_NEST_EXEC	EQU	(DFS_RARE_SERVICES+1)
ifdef WIN40SERVICES
VMM_Service  VMMAddImportModuleName
VMM_Service  VMM_Add_DDB
VMM_Service  VMM_Remove_DDB
VMM_Service  Test_VM_Ints_Enabled
VMM_Service  _BlockOnID
VMM_Service  Schedule_Thread_Event
VMM_Service  Cancel_Thread_Event
VMM_Service  Set_Thread_Time_Out
VMM_Service  Set_Async_Time_Out
VMM_Service  _AllocateThreadDataSlot
VMM_Service  _FreeThreadDataSlot
MUTEX_MUST_COMPLETE	EQU	1
MUTEX_NO_CLEANUP_THREAD_STATE	EQU	2
VMM_Service  _CreateMutex
VMM_Service  _DestroyMutex
VMM_Service  _GetMutexOwner
VMM_Service  Call_When_Thread_Switched
VMM_Service  VMMCreateThread
VMM_Service  _GetThreadExecTime
VMM_Service  VMMTerminateThread
VMM_Service  Get_Cur_Thread_Handle
VMM_Service  Test_Cur_Thread_Handle
VMM_Service  Get_Sys_Thread_Handle
VMM_Service  Test_Sys_Thread_Handle
VMM_Service  Validate_Thread_Handle
VMM_Service  Get_Initial_Thread_Handle
VMM_Service  Test_Initial_Thread_Handle
VMM_Service  Debug_Test_Valid_Thread_Handle
VMM_Service  Debug_Test_Cur_Thread
VMM_Service  VMM_GetSystemInitState
VMM_Service  Cancel_Call_When_Thread_Switched
VMM_Service  Get_Next_Thread_Handle
VMM_Service  Adjust_Thread_Exec_Priority
VMM_Service  _Deallocate_Device_CB_Area
VMM_Service  Remove_IO_Handler
VMM_Service  Remove_Mult_IO_Handlers
VMM_Service  Unhook_V86_Int_Chain
VMM_Service  Unhook_V86_Fault
VMM_Service  Unhook_PM_Fault
VMM_Service  Unhook_VMM_Fault
VMM_Service  Unhook_Device_Service
VMM_Service  _PageReserve
VMM_Service  _PageCommit
VMM_Service  _PageDecommit
VMM_Service  _PagerRegister
VMM_Service  _PagerQuery
VMM_Service  _PagerDeregister
VMM_Service  _ContextCreate
VMM_Service  _ContextDestroy
VMM_Service  _PageAttach
VMM_Service  _PageFlush
VMM_Service  _SignalID
VMM_Service  _PageCommitPhys
VMM_Service  _Register_Win32_Services
VMM_Service  Cancel_Call_When_Not_Critical
VMM_Service  Cancel_Call_When_Idle
VMM_Service  Cancel_Call_When_Task_Switched
VMM_Service  _Debug_Printf_Service
VMM_Service  _EnterMutex
VMM_Service  _LeaveMutex
VMM_Service  Simulate_VM_IO
VMM_Service  Signal_Semaphore_No_Switch
VMM_Service  _ContextSwitch
VMM_Service  _PageModifyPermissions
VMM_Service  _PageQuery
VMM_Service  _EnterMustComplete
VMM_Service  _LeaveMustComplete
VMM_Service  _ResumeExecMustComplete
THREAD_TERM_STATUS_CRASH_PEND	EQU	1
THREAD_TERM_STATUS_NUKE_PEND	EQU	2
THREAD_TERM_STATUS_SUSPEND_PEND	EQU	4
VMM_Service  _GetThreadTerminationStatus
VMM_Service  _GetInstanceInfo
INSTINFO_NONE	EQU	0
INSTINFO_SOME	EQU	1
INSTINFO_ALL	EQU	2
VMM_Service  _ExecIntMustComplete
VMM_Service  _ExecVxDIntMustComplete
VMM_Service  Begin_V86_Serialization
VMM_Service  Unhook_V86_Page
VMM_Service  VMM_GetVxDLocationList
VMM_Service  VMM_GetDDBList
VMM_Service  Unhook_NMI_Event
VMM_Service  Get_Instanced_V86_Int_Vector
VMM_Service  Get_Set_Real_DOS_PSP
GSRDP_Set	EQU	0001H
VMM_Service  Call_Priority_Thread_Event
VMM_Service  Get_System_Time_Address
VMM_Service  Get_Crit_Status_Thread
VMM_Service  Get_DDB
VMM_Service  Directed_Sys_Control
VMM_Service  _RegOpenKey
VMM_Service  _RegCloseKey
VMM_Service  _RegCreateKey
VMM_Service  _RegDeleteKey
VMM_Service  _RegEnumKey
VMM_Service  _RegQueryValue
VMM_Service  _RegSetValue
VMM_Service  _RegDeleteValue
VMM_Service  _RegEnumValue
VMM_Service  _RegQueryValueEx
VMM_Service  _RegSetValueEx
ifndef REG_SZ
REG_SZ	EQU	0001H
REG_BINARY	EQU	0003H
endif
ifndef HKEY_LOCAL_MACHINE
HKEY_CLASSES_ROOT	EQU	80000000H
HKEY_CURRENT_USER	EQU	80000001H
HKEY_LOCAL_MACHINE	EQU	80000002H
HKEY_USERS	EQU	80000003H
HKEY_PERFORMANCE_DATA	EQU	80000004H
HKEY_CURRENT_CONFIG	EQU	80000005H
HKEY_DYN_DATA	EQU	80000006H
endif
VMM_Service  _CallRing3
VMM_Service  Exec_PM_Int
VMM_Service  _RegFlushKey
VMM_Service  _PageCommitContig
VMM_Service  _GetCurrentContext
VMM_Service  _LocalizeSprintf
VMM_Service  _LocalizeStackSprintf
VMM_Service  Call_Restricted_Event
VMM_Service  Cancel_Restricted_Event
VMM_Service  Register_PEF_Provider, VMM_ICODE
VMM_Service  _GetPhysPageInfo
VMM_Service  _RegQueryInfoKey
VMM_Service  MemArb_Reserve_Pages
PHYSINFO_NONE	EQU	0
PHYSINFO_SOME	EQU	1
PHYSINFO_ALL	EQU	2
VMM_Service  Time_Slice_Sys_VM_Idle
VMM_Service  Time_Slice_Sleep
VMM_Service  Boost_With_Decay
VMM_Service  Set_Inversion_Pri
VMM_Service  Reset_Inversion_Pri
VMM_Service  Release_Inversion_Pri
VMM_Service  Get_Thread_Win32_Pri
VMM_Service  Set_Thread_Win32_Pri
VMM_Service  Set_Thread_Static_Boost
VMM_Service  Set_VM_Static_Boost
VMM_Service  Release_Inversion_Pri_ID
VMM_Service  Attach_Thread_To_Group
VMM_Service  Detach_Thread_From_Group
VMM_Service  Set_Group_Static_Boost
VMM_Service  _GetRegistryPath, VMM_ICODE
VMM_Service  _GetRegistryKey
REGTYPE_ENUM	EQU	0
REGTYPE_CLASS	EQU	1
REGTYPE_VXD	EQU	2
REGKEY_OPEN	EQU	0
REGKEY_CREATE_IFNOTEXIST	EQU	1
ASSERT_RANGE_NULL_BAD	EQU	00000000H
ASSERT_RANGE_NULL_OK	EQU	00000001H
ASSERT_RANGE_NO_DEBUG	EQU	80000000H
ASSERT_RANGE_BITS	EQU	80000001H
VMM_Service  Cleanup_Thread_State
VMM_Service  _RegRemapPreDefKey
VMM_Service  End_V86_Serialization
VMM_Service  _Assert_Range
VMM_Service  _Sprintf
VMM_Service  _PageChangePager
VMM_Service  _RegCreateDynKey
VMM_Service  _RegQueryMultipleValues
VMM_Service  Boost_Thread_With_VM
BOOT_CLEAN	EQU	00000001H
BOOT_DOSCLEAN	EQU	00000002H
BOOT_NETCLEAN	EQU	00000004H
BOOT_INTERACTIVE	EQU	00000008H
VMM_Service  Get_Boot_Flags
VMM_Service  Set_Boot_Flags
VMM_Service  _lstrcpyn
VMM_Service  _lstrlen
VMM_Service  _lmemcpy
VMM_Service  _GetVxDName
VMM_Service  Force_Mutexes_Free
VMM_Service  Restore_Forced_Mutexes
VMM_Service  _AddReclaimableItem
VMM_Service  _SetReclaimableItem
VMM_Service  _EnumReclaimableItem
VMM_Service  Time_Slice_Wake_Sys_VM
VMM_Service  VMM_Replace_Global_Environment
VMM_Service  Begin_Non_Serial_Nest_V86_Exec
VMM_Service  Get_Nest_Exec_Status
VMM_Service  Open_Boot_Log
VMM_Service  Write_Boot_Log
VMM_Service  Close_Boot_Log
VMM_Service  EnableDisable_Boot_Log
VMM_Service  _Call_On_My_Stack
VMM_Service  Get_Inst_V86_Int_Vec_Base
VMM_Service  _lstrcmpi
VMM_Service  _strupr
VMM_Service  Log_Fault_Call_Out
VMM_Service  _AtEventTime
endif
End_Service_Table VMM, VMM
RS_RECLAIM	EQU	00000001H
RS_RESTORE	EQU	00000002H
RS_DOSARENA	EQU	00000004H

ReclaimStruc	STRUC
RS_Linear	DD	?
RS_Bytes	DD	?
RS_CallBack	DD	?
RS_RefData	DD	?
RS_HookTable	DD	?
RS_Flags	DD	?
ReclaimStruc	ENDS

frmtx	STRUC
frmtx_pfrmtxNext	DD	?
frmtx_hmutex	DD	?
frmtx_cEnterCount	DD	?
frmtx_pthcbOwner	DD	?
frmtx_htimeout	DD	?
frmtx	ENDS

vmmfrinfo	STRUC
vmmfrinfo_frmtxDOS	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxV86	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxOther	DB	SIZE frmtx DUP (?)
vmmfrinfo	ENDS

DemandInfoStruc	STRUC
DILin_Total_Count	DD	?
DIPhys_Count	DD	?
DIFree_Count	DD	?
DIUnlock_Count	DD	?
DILinear_Base_Addr	DD	?
DILin_Total_Free	DD	?
DIPage_Faults	DD	?
DIPage_Ins	DD	?
DIPage_Outs	DD	?
DIPage_Discards	DD	?
DIInstance_Faults	DD	?
DIPagingFileMax	DD	?
DIPagingFileInUse	DD	?
DICommit_Count	DD	?
DIReserved	DD	2 DUP (?)
DemandInfoStruc	ENDS

InstDataStruc	STRUC
InstLinkF	DD	0
InstLinkB	DD	0
InstLinAddr	DD	?
InstSize	DD	?
InstType	DD	?
InstDataStruc	ENDS
INDOS_FIELD	EQU	100H
ALWAYS_FIELD	EQU	200H
OPTIONAL_FIELD	EQU	400H

IPF_Data	STRUC
IPF_LinAddr	DD	?
IPF_MapPageNum	DD	?
IPF_PTEEntry	DD	?
IPF_FaultingVM	DD	?
IPF_Flags	DD	?
IPF_Data	ENDS

Exception_Handler_Struc	STRUC
EH_Reserved	DD	?
EH_Start_EIP	DD	?
EH_End_EIP	DD	?
EH_Handler	DD	?
Exception_Handler_Struc	ENDS
PR_PRIVATE	EQU	80000400H
PR_SHARED	EQU	80060000H
PR_SYSTEM	EQU	80080000H
PR_FIXED	EQU	00000008H
PR_4MEG	EQU	00000001H
PR_STATIC	EQU	00000010H
PD_ZEROINIT	EQU	00000001H
PD_NOINIT	EQU	00000002H
PD_FIXEDZERO	EQU	00000003H
PD_FIXED	EQU	00000004H
PC_FIXED	EQU	00000008H
PC_LOCKED	EQU	00000080H
PC_LOCKEDIFDP	EQU	00000100H
PC_WRITEABLE	EQU	00020000H
PC_USER	EQU	00040000H
PC_INCR	EQU	40000000H
PC_PRESENT	EQU	80000000H
PC_STATIC	EQU	20000000H
PC_DIRTY	EQU	08000000H
PCC_ZEROINIT	EQU	00000001H
PCC_NOLIN	EQU	10000000H
ifndef _WINNT_

_MEMORY_BASIC_INFORMATION	STRUC
mbi_BaseAddress	DD	?
mbi_AllocationBase	DD	?
mbi_AllocationProtect	DD	?
mbi_RegionSize	DD	?
mbi_State	DD	?
mbi_Protect	DD	?
mbi_Type	DD	?
_MEMORY_BASIC_INFORMATION	ENDS
PAGE_NOACCESS	EQU	01H
PAGE_READONLY	EQU	02H
PAGE_READWRITE	EQU	04H
MEM_COMMIT	EQU	1000H
MEM_RESERVE	EQU	2000H
MEM_FREE	EQU	10000H
MEM_PRIVATE	EQU	20000H
endif

pd_s	STRUC
pd_virginin	DD	?
pd_taintedin	DD	?
pd_cleanout	DD	?
pd_dirtyout	DD	?
pd_virginfree	DD	?
pd_taintedfree	DD	?
pd_dirty	DD	?
pd_type	DD	?
pd_s	ENDS
PD_SWAPPER	EQU	0
PD_PAGERONLY	EQU	1
PD_NESTEXEC	EQU	2
endif
PAGESHIFT	EQU	12
PAGESIZE	EQU	(1 SHL PAGESHIFT)
PAGEMASK	EQU	(PAGESIZE-1)
MAXSYSTEMLADDR	EQU	(0ffbfffffH)
MINSYSTEMLADDR	EQU	(0c0000000H)
MAXSHAREDLADDR	EQU	(0bfffffffH)
MINSHAREDLADDR	EQU	(80000000H)
MAXPRIVATELADDR	EQU	(7fffffffH)
MINPRIVATELADDR	EQU	(00400000H)
MAXDOSLADDR	EQU	(003fffffH)
MINDOSLADDR	EQU	(00000000H)
MAXSYSTEMPAGE	EQU	(MAXSYSTEMLADDR SHR PAGESHIFT)
MINSYSTEMPAGE	EQU	(MINSYSTEMLADDR SHR PAGESHIFT)
MAXSHAREDPAGE	EQU	(MAXSHAREDLADDR SHR PAGESHIFT)
MINSHAREDPAGE	EQU	(MINSHAREDLADDR SHR PAGESHIFT)
MAXPRIVATEPAGE	EQU	(MAXPRIVATELADDR SHR PAGESHIFT)
MINPRIVATEPAGE	EQU	(MINPRIVATELADDR SHR PAGESHIFT)
MAXDOSPAGE	EQU	(MAXDOSLADDR SHR PAGESHIFT)
MINDOSPAGE	EQU	(MINDOSLADDR SHR PAGESHIFT)
CBPRIVATE	EQU	(1+MAXPRIVATELADDR-MINPRIVATELADDR)
CBSHARED	EQU	(1+MAXSHAREDLADDR-MINSHAREDLADDR)
CBSYSTEM	EQU	(1+MAXSYSTEMLADDR-MINSYSTEMLADDR)
CBDOS	EQU	(1+MAXDOSLADDR-MINDOSLADDR)
CPGPRIVATE	EQU	(1+MAXPRIVATEPAGE-MINPRIVATEPAGE)
CPGSHARED	EQU	(1+MAXSHAREDPAGE-MINSHAREDPAGE)
CPGSYSTEM	EQU	(1+MAXSYSTEMPAGE-MINSYSTEMPAGE)
CPGDOS	EQU	(1+MAXDOSPAGE-MINDOSPAGE)
IFDEF DEBUG
DebFar  EQU NEAR PTR
ELSE
DebFar  EQU SHORT
ENDIF

ifndef Not_VxD
SYS_CRITICAL_INIT	EQU	0000H
DEVICE_INIT	EQU	0001H
INIT_COMPLETE	EQU	0002H
SYS_VM_INIT	EQU	0003H
SYS_VM_TERMINATE	EQU	0004H
SYSTEM_EXIT	EQU	0005H
SYS_CRITICAL_EXIT	EQU	0006H
CREATE_VM	EQU	0007H
VM_CRITICAL_INIT	EQU	0008H
VM_INIT	EQU	0009H
VM_TERMINATE	EQU	000AH
VM_NOT_EXECUTEABLE	EQU	000BH
DESTROY_VM	EQU	000CH
VNE_CRASHED_BIT	EQU	00H
VNE_CRASHED	EQU	(1 SHL VNE_CRASHED_BIT)
VNE_NUKED_BIT	EQU	01H
VNE_NUKED	EQU	(1 SHL VNE_NUKED_BIT)
VNE_CREATEFAIL_BIT	EQU	02H
VNE_CREATEFAIL	EQU	(1 SHL VNE_CREATEFAIL_BIT)
VNE_CRINITFAIL_BIT	EQU	03H
VNE_CRINITFAIL	EQU	(1 SHL VNE_CRINITFAIL_BIT)
VNE_INITFAIL_BIT	EQU	04H
VNE_INITFAIL	EQU	(1 SHL VNE_INITFAIL_BIT)
VNE_CLOSED_BIT	EQU	05H
VNE_CLOSED	EQU	(1 SHL VNE_CLOSED_BIT)
VM_SUSPEND	EQU	000DH
VM_RESUME	EQU	000EH
SET_DEVICE_FOCUS	EQU	000FH
BEGIN_MESSAGE_MODE	EQU	0010H
END_MESSAGE_MODE	EQU	0011H
REBOOT_PROCESSOR	EQU	0012H
QUERY_DESTROY	EQU	0013H
DEBUG_QUERY	EQU	0014H
BEGIN_PM_APP	EQU	0015H
BPA_32_BIT	EQU	01H
BPA_32_BIT_FLAG	EQU	1
END_PM_APP	EQU	0016H
DEVICE_REBOOT_NOTIFY	EQU	0017H
CRIT_REBOOT_NOTIFY	EQU	0018H
CLOSE_VM_NOTIFY	EQU	0019H
CVNF_CRIT_CLOSE_BIT	EQU	0
CVNF_CRIT_CLOSE	EQU	(1 SHL CVNF_CRIT_CLOSE_BIT)
POWER_EVENT	EQU	001AH
SYS_DYNAMIC_DEVICE_INIT	EQU	001BH
SYS_DYNAMIC_DEVICE_EXIT	EQU	001CH
CREATE_THREAD	EQU	001DH
THREAD_INIT	EQU	001EH
TERMINATE_THREAD	EQU	001FH
THREAD_Not_Executeable	EQU	0020H
DESTROY_THREAD	EQU	0021H
PNP_NEW_DEVNODE	EQU	0022H
W32_DEVICEIOCONTROL	EQU	0023H
DIOC_GETVERSION	EQU	0H
DIOC_OPEN	EQU	DIOC_GETVERSION
DIOC_CLOSEHANDLE	EQU	-1
SYS_VM_TERMINATE2	EQU	0024H
SYSTEM_EXIT2	EQU	0025H
SYS_CRITICAL_EXIT2	EQU	0026H
VM_TERMINATE2	EQU	0027H
VM_NOT_EXECUTEABLE2	EQU	0028H
DESTROY_VM2	EQU	0029H
VM_SUSPEND2	EQU	002AH
END_MESSAGE_MODE2	EQU	002BH
END_PM_APP2	EQU	002CH
DEVICE_REBOOT_NOTIFY2	EQU	002DH
CRIT_REBOOT_NOTIFY2	EQU	002EH
CLOSE_VM_NOTIFY2	EQU	002FH
GET_CONTENTION_HANDLER	EQU	0030H
KERNEL32_INITIALIZED	EQU	0031H
KERNEL32_SHUTDOWN	EQU	0032H
MAX_SYSTEM_CONTROL	EQU	0032H
BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	70000000H
END_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	7FFFFFFFH
endif
SYSSTATE_PRESYSCRITINIT	EQU	00000000H
SYSSTATE_PREDEVICEINIT	EQU	10000000H
SYSSTATE_PREINITCOMPLETE	EQU	20000000H
SYSSTATE_VXDINITCOMPLETED	EQU	40000000H
SYSSTATE_KERNEL32INITED	EQU	50000000H
SYSSTATE_KERNEL32TERMINATED	EQU	0A0000000H
SYSSTATE_PRESYSVMTERMINATE	EQU	0B0000000H
SYSSTATE_PRESYSTEMEXIT	EQU	0E0000000H
SYSSTATE_PRESYSTEMEXIT2	EQU	0E4000000H
SYSSTATE_PRESYSCRITEXIT	EQU	0F0000000H
SYSSTATE_PRESYSCRITEXIT2	EQU	0F4000000H
SYSSTATE_POSTSYSCRITEXIT2	EQU	0FFF00000H
SYSSTATE_PREDEVICEREBOOT	EQU	0FFFF0000H
SYSSTATE_PRECRITREBOOT	EQU	0FFFFF000H
SYSSTATE_PREREBOOTCPU	EQU	0FFFFFF00H
BeginDoc











































































EndDoc












??_pf_Check equ 1
??_pf_ArgsUsed  equ 2
??_pf_Entered   equ 4
??_pf_Left  equ 8
??_pf_Returned  equ    16

??_pushed       =       0
??_align    =   0
??_ends     equ <>

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0
    ??_aframe = 0
    ??_initaframe = 0
    ??_numargs = 0
    ??_numlocals = 0
    ??_numlocalsymbols = 0
    ??_procflags = 0
    ??_esp = 0
    ??_pushed = 0
    ??_align = 0
    ??_hook = 0
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG
    ??_profile = DFS_PROFILE
    ??_test_cld = DFS_TEST_CLD
ELSE
    ??_log = 0
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
    ??_test_cld = 0
ENDIF
    ??_might_block = 0
    ??_test_reenter = 0
    ??_never_reenter = 0
    ??_not_swapping = 0
    ??_prolog_disabled = 0
    ??_public = 1
    ??_cleanoff = 0
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_w32svc = 0
    ??_fleave = FALSE

    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>


    irp arg, <P1, P2, P3, P4, P5, P6, P7>
        if ??_hookarg
        ??_hookarg = 0
        ??_hookvar equ <arg>
        elseifdef ?&&arg&&_BeginProc
            ?&&arg&&_BeginProc
        elseifdef VxD_&&arg&&_CODE_SEG
        ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
        VxD_&&arg&&_CODE_SEG
        else
        .err <Bad param "&arg" to BeginProc>
        endif
    endm


    ifndef Not_VxD
	ife ??_service
	    ifndef profileall
	      ??_profile = 0
	    endif
	    ifdef VMMSYS
		??_prolog_disabled = 1
	    endif
	else
	    ??_test_cld = DFS_TEST_CLD
	endif

	ife ?_16ICODE
	    ??_prolog_disabled = 1
	else
	ife ?_RCODE
	    ??_prolog_disabled = 1
	else
	    ife ?_PCODE
		??_might_block = DFS_TEST_BLOCK
	    endif
	    if ??_service
		ife ??_async_service
		    ??_test_reenter = DFS_TEST_REENTER
		endif
	    endif
    endif
    endif
    endif

    if ??_esp

	??_basereg equ <esp+??_pushed>
	??_initaframe = 4
    else

	??_basereg equ <ebp>
	??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall


    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
         ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
        ??_dfs = 0
    endif



    ifndef Not_VxD

	if ??_hook
	    if ??_align
	    Dword_Align
	    endif
	    prelabeldata:
	    ifndef ??_hookvar
	    .err <HOOK_PROC requires next arg to be name of dword location>
	    endif
	    jmp short Name
	    jmp [??_hookvar]
	    ifdef DEBUG
	    Profile_Data dd  0
	    endif
	    if ??_align
	    .errnz ($ - prelabeldata) mod 4
	    endif
	endif

	ifdef DEBUG
	    ?prolog_&Name label near
	    if (??_service OR ??_profile) AND (??_hook EQ 0)
	    jmp short Name
	    if ??_align
		Dword_Align
	    endif

	    IF ?_ICODE
	    ifdef profileall
	      ?ProfileHeader_BeginProc Profile_Data, %@filename
	    else
	      Profile_Data dd 0
	    endif
	    ELSE
	      Profile_Data dd 0
	    ENDIF

	    endif
	endif

	if ??_align
	    Dword_Align
	endif

    endif

    Name proc near



    ife ??_pcall or ??_ccall or ??_scall
        if ??_public
            public Name
        else
            ifdef DEBUG
                % ?merge @FileName,$,Name,:
                % ?merge public,,,,,@FileName,$,Name
            endif
        endif
    endif
    if ??_ccall
        if ??_public
            _&Name equ Name
	    ifdef Not_VxD
		 public C Name
	    else
                 public _&Name
	    endif
        endif
    endif
    if ??_pcall
        if ??_public
            ?toupper Name
            ?merge  public,,,,%?upper
        endif
    endif


    ifndef Not_VxD
	ifdef DEBUG
	    if ??_dfs EQ DFS_LOG
		VMMCall Log_Proc_Call
	    else
	    if ??_dfs EQ DFS_TEST_REENTER
		VMMCall Test_Reenter
	    else
	    if ??_dfs or ?_LOCKABLECODE eq 0
		ifdef WIN31COMPAT
		    if ??_dfs AND DFS_LOG
			VMMCall Log_Proc_Call
		    endif
		    if ??_dfs AND DFS_TEST_REENTER
			VMMCall Test_Reenter
		    endif
		else
		    ife ?_LOCKABLECODE
		    ifdef ??_debug_flags
			push    ??_debug_flags
			if ??_dfs
			pushfd
			or  dword ptr [esp+4],??_dfs
			popfd
			endif
			VMMCall _Debug_Flags_Service
		    elseif ??_dfs
			push    ??_dfs
			VMMCall _Debug_Flags_Service
		    endif
		    else
		    push    ??_dfs
		    VMMCall _Debug_Flags_Service
		    endif
		endif
	    else
	      ifdef profileall
		IncProfileCount
	      endif
	    endif
	    endif
	    endif
	endif
    endif



endm






?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
	.erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
	.erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
        inc dword ptr [??_name-4]
    else
        ifndef profileall
        .err <IncProfileCount can be used only in services.>
        endif
    endif
endm
else
IncProfileCount macro
endm
endif
















ArgVar  macro   name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
        ?mkarg  <name>, <length>, <used>, %??_numargs
    else
        ?argvar <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg  macro   name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
        ?argvar <name>, <length>, <used>
        &endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro   name,length,used
    local   a
    ifidni  <length>,<BYTE>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
        ?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
        a = ??_aframe
        ??_aframe =  ??_aframe + ((length + 3)/4)*4
        ?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm






?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
        name equ _inaccessible_NOTUSED_
    else
        name equ value
        ??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm



















LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
        ??_pad = 0
    endif
    ifidni  <length>,<BYTE>
        ??_frame = ??_frame + 1 + 3 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
        ??_frame =  ??_frame + 2 + 2 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
        ??_frame = ??_frame + 4
        a = ??_frame
        ?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
        name equ dword ptr [??_basereg-a]
        name&l equ word ptr [??_basereg-a]
        name&ll equ byte ptr [??_basereg-a]
        name&lh equ byte ptr [??_basereg-a+1]
        name&h equ word ptr [??_basereg-a+2]
        name&hl equ byte ptr [??_basereg-a+2]
        name&hh equ byte ptr [??_basereg-a+3]
    else
        ??_frame =  ??_frame + ((length + 3)/4)*4
        a = ??_frame
        ?deflocal <name>
        name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
        ??_numlocalsymbols = ??_numlocalsymbols + 1
        ?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
        name    equ <__inaccessible__NOTINSCOPE__>
        &endm
    endm
    .xcref  ?dodeflocal



EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
        if ??_public
	    ifdef Not_VxD
                ?merge  %??_name,@,%(??_aframe),,label,near
                ?merge  public,,,,C,%??_name,@,%(??_aframe)
	    else
                ?merge  _,%??_name,@,%(??_aframe),label,near
                ?merge  public,,,,,_,%??_name,@,%(??_aframe)
	    endif
        endif
    endif
    if ??_pcall
        ??_aframe = 0
        ?count = ??_numargs
        rept    ??_numargs
            ?invprg <?MKA>,%?count
            ?count = ?count - 1
        endm
    endif
    ??_fleave = FALSE
    if ??_esp
        if  ??_frame
            sub esp, ??_frame
            ??_pushed = ??_pushed + ??_frame
            ??_fleave = VMM_TRUE
        endif
    else
        if  ??_frame eq 0
            if (??_aframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
                ifdef DEBUG
                    push    ebp
                    mov ebp,esp
                    ??_fleave = VMM_TRUE
                endif
            else
                push    ebp
                mov ebp,esp
                ??_fleave = VMM_TRUE
            endif
        else
            enter   ??_frame, 0
            ??_fleave = VMM_TRUE
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm















LeaveProc macro flags
    if ??_fleave
        if ??_esp
            ifidni <flags>,<PRESERVE_FLAGS>
                lea esp,[esp + ??_frame]
            else
                add esp,??_frame
            endif
        else
            leave
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm







Return  macro
    if  ??_cleanoff OR ??_w32svc
        if  ??_w32svc AND (??_aframe LT 8)
            ret 8
        else
            ret ??_aframe
        endif
    else
        ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm




EndProc macro Name, Flag
    Name endp
if ??_w32svc
    if ??_aframe lt 8
        cparm&Name equ 0
    else
        cparm&Name equ (??_aframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi  <Flag>,<NOCHECK>
    if ??_pushed ne 0
        %out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
        ife ??_procflags AND ??_pf_Entered
            %out Warning: ArgVar/LocalVar without EnterProc in Name
        endif
        ife ??_procflags AND ??_pf_Left
            %out Warning: ArgVar/LocalVar without LeaveProc in Name
        endif
        ife ??_procflags AND ??_pf_Returned
            %out Warning: ArgVar/LocalVar without Return in Name
        endif
    endif
endif
ifdifi  <Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
        ?count = ?count + 1
        ?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm







cCall   macro   name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <flags>
    call    name
    ClearCParams
    endm
    .xcref  cCall






pCall   macro   name, arglst
    local   ??saved
    ife .TYPE name
        ?toupper name
    else
        ?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
        push    x
        ??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall







sCall   macro   name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall





iCall   equ <sCall>














IFNDEF  STANDARD_CCALL
NONSTANDARD_CCALL = 1
ENDIF

PushCParams macro arglst, flags
    ??_argc = 0
IFDEF   NONSTANDARD_CCALL
    ??_popargs = 0
ELSE
    ??_popargs = ??_align EQ 0
ENDIF
    ifidni  <flags>, <SMALL>
        ??_popargs = 1
    elseifidni <flags>, <FAST>
        ??_popargs = 0
    endif

    irp x,<arglst>
        ??_argc = ??_argc + 1
        ?marg   <x>,%??_argc
    endm
    ?count = ??_argc
    rept    ??_argc
        ?invprg <?AM>,%?count
        ?count = ?count - 1
    endm
    endm
















ClearCParams macro fPreserveFlags
	if	??_argc ne 0
	    if (??_popargs) AND (??_argc LE 2)
	      rept ??_argc
		pop	ecx
	      endm
	    else
	      ifidni <fPreserveFlags>, <PRESERVE_FLAGS>
		lea	esp, [esp][??_argc * 4]
	      else
		add	esp,??_argc * 4
	      endif
	    endif
	endif
	??_pushed = ??_pushed - (??_argc * 4)
	endm



?marg   macro   name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
        push    name
        ??_pushed = ??_pushed + 4
        &endm
    endm
    .xcref  ?marg



?invprg macro   name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg



?scall  macro   name1, name2
    CondExtern _&name1&@&name2, near
    call    _&name1&@&name2
    endm
    .xcref  ?scall



?merge  macro   l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm



?toupper macro s
      ?upper equ <>
      irpc x,<s>
        if '&x' GE 'a'
          if '&x' LE 'z'
        ?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
        ?upper catstr ?upper,?t1
          else
        ?upper catstr ?upper,<&x>
          endif
        else
          ?upper catstr ?upper,<&x>
        endif
      endm
    endm
    .xcref






CondExtern macro name,dist
    ifdef MASM6
        ifndef name
        externdef name:dist
        endif
    else
        if2
        ifndef name
            extrn name:dist
        endif
        endif
    endif
endm



SaveReg macro   reglist
    irp reg,<reglist>
        ifidni <reg>, <fd>
            pushfd
            ??_pushed = ??_pushed + 4
        else
        ifidni <reg>, <ad>
            pushad
            ??_pushed = ??_pushed + SIZE Pushad_Struc
        else
            push    reg
            ??_pushed = ??_pushed + 4
        endif
        endif
    endm
endm







RestoreReg macro     reglist
    irp reg,<reglist>
        ifidni <reg>, <fd>
            popfd
            ??_pushed = ??_pushed - 4
        else
        ifidni <reg>, <ad>
            popad
            ??_pushed = ??_pushed - SIZE Pushad_Struc
        else
            pop reg
            ??_pushed = ??_pushed - 4
        endif
        endif
    endm
endm

ifdef DEBUG
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db  'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd  OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd  0
VxD_DATA_ENDS
endif
endm


endif
ifndef Not_VxD
RESERVED_LOW_BOOST	EQU	00000001H
CUR_RUN_VM_BOOST	EQU	00000004H
LOW_PRI_DEVICE_BOOST	EQU	00000010H
HIGH_PRI_DEVICE_BOOST	EQU	00001000H
CRITICAL_SECTION_BOOST	EQU	00100000H
TIME_CRITICAL_BOOST	EQU	00400000H
RESERVED_HIGH_BOOST	EQU	40000000H
PEF_WAIT_FOR_STI_BIT	EQU	0
PEF_WAIT_FOR_STI	EQU	(1 SHL PEF_WAIT_FOR_STI_BIT)
PEF_WAIT_NOT_CRIT_BIT	EQU	1
PEF_WAIT_NOT_CRIT	EQU	(1 SHL PEF_WAIT_NOT_CRIT_BIT)
PEF_DONT_UNBOOST_BIT	EQU	2
PEF_DONT_UNBOOST	EQU	(1 SHL PEF_DONT_UNBOOST_BIT)
PEF_ALWAYS_SCHED_BIT	EQU	3
PEF_ALWAYS_SCHED	EQU	(1 SHL PEF_ALWAYS_SCHED_BIT)
PEF_TIME_OUT_BIT	EQU	4
PEF_TIME_OUT	EQU	(1 SHL PEF_TIME_OUT_BIT)
PEF_WAIT_NOT_HW_INT_BIT	EQU	5
PEF_WAIT_NOT_HW_INT	EQU	(1 SHL PEF_WAIT_NOT_HW_INT_BIT)
PEF_WAIT_NOT_NESTED_EXEC_BIT	EQU	6
PEF_WAIT_NOT_NESTED_EXEC	EQU	(1 SHL PEF_WAIT_NOT_NESTED_EXEC_BIT)
PEF_WAIT_IN_PM_BIT	EQU	7
PEF_WAIT_IN_PM	EQU	(1 SHL PEF_WAIT_IN_PM_BIT)
PEF_THREAD_EVENT_BIT	EQU	8
PEF_THREAD_EVENT	EQU	(1 SHL PEF_THREAD_EVENT_BIT)
PEF_WAIT_FOR_THREAD_STI_BIT	EQU	9
PEF_WAIT_FOR_THREAD_STI	EQU	(1 SHL PEF_WAIT_FOR_THREAD_STI_BIT)
PEF_RING0_EVENT_BIT	EQU	10
PEF_RING0_EVENT	EQU	(1 SHL PEF_RING0_EVENT_BIT)
PEF_WAIT_CRIT_BIT	EQU	11
PEF_WAIT_CRIT	EQU	(1 SHL PEF_WAIT_CRIT_BIT)
PEF_WAIT_CRIT_VM_BIT	EQU	12
PEF_WAIT_CRIT_VM	EQU	(1 SHL PEF_WAIT_CRIT_VM_BIT)
PEF_PROCESS_LAST_BIT	EQU	13
PEF_PROCESS_LAST	EQU	(1 SHL PEF_PROCESS_LAST_BIT)
PEF_WAIT_NOT_TIME_CRIT_BIT	EQU	PEF_WAIT_NOT_HW_INT_BIT
PEF_WAIT_NOT_TIME_CRIT	EQU	PEF_WAIT_NOT_HW_INT
PEF_WAIT_NOT_PM_LOCKED_STACK_BIT	EQU	PEF_WAIT_NOT_NESTED_EXEC_BIT
PEF_WAIT_NOT_PM_LOCKED_STACK	EQU	PEF_WAIT_NOT_NESTED_EXEC
BLOCK_SVC_INTS_BIT	EQU	0
BLOCK_SVC_INTS	EQU	(1 SHL BLOCK_SVC_INTS_BIT)
BLOCK_SVC_IF_INTS_LOCKED_BIT	EQU	1
BLOCK_SVC_IF_INTS_LOCKED	EQU	(1 SHL BLOCK_SVC_IF_INTS_LOCKED_BIT)
BLOCK_ENABLE_INTS_BIT	EQU	2
BLOCK_ENABLE_INTS	EQU	(1 SHL BLOCK_ENABLE_INTS_BIT)
BLOCK_POLL_BIT	EQU	3
BLOCK_POLL	EQU	(1 SHL BLOCK_POLL_BIT)
BLOCK_THREAD_IDLE_BIT	EQU	4
BLOCK_THREAD_IDLE	EQU	(1 SHL BLOCK_THREAD_IDLE_BIT)
BLOCK_FORCE_SVC_INTS_BIT	EQU	5
BLOCK_FORCE_SVC_INTS	EQU	(1 SHL BLOCK_FORCE_SVC_INTS_BIT)

Client_Reg_Struc	STRUC
Client_EDI	DD	?
Client_ESI	DD	?
Client_EBP	DD	?
Client_res0	DD	?
Client_EBX	DD	?
Client_EDX	DD	?
Client_ECX	DD	?
Client_EAX	DD	?
Client_Error	DD	?
Client_EIP	DD	?
Client_CS	DW	?
Client_res1	DW	?
Client_EFlags	DD	?
Client_ESP	DD	?
Client_SS	DW	?
Client_res2	DW	?
Client_ES	DW	?
Client_res3	DW	?
Client_DS	DW	?
Client_res4	DW	?
Client_FS	DW	?
Client_res5	DW	?
Client_GS	DW	?
Client_res6	DW	?
Client_Alt_EIP	DD	?
Client_Alt_CS	DW	?
Client_res7	DW	?
Client_Alt_EFlags	DD	?
Client_Alt_ESP	DD	?
Client_Alt_SS	DW	?
Client_res8	DW	?
Client_Alt_ES	DW	?
Client_res9	DW	?
Client_Alt_DS	DW	?
Client_res10	DW	?
Client_Alt_FS	DW	?
Client_res11	DW	?
Client_Alt_GS	DW	?
Client_res12	DW	?
Client_Reg_Struc	ENDS

Client_Word_Reg_Struc	STRUC
Client_DI	DW	?
Client_res13	DW	?
Client_SI	DW	?
Client_res14	DW	?
Client_BP	DW	?
Client_res15	DW	?
Client_res16	DD	?
Client_BX	DW	?
Client_res17	DW	?
Client_DX	DW	?
Client_res18	DW	?
Client_CX	DW	?
Client_res19	DW	?
Client_AX	DW	?
Client_res20	DW	?
Client_res21	DD	?
Client_IP	DW	?
Client_res22	DW	?
Client_res23	DD	?
Client_Flags	DW	?
Client_res24	DW	?
Client_SP	DW	?
Client_res25	DW	?
Client_res26	DD	5 DUP (?)
Client_Alt_IP	DW	?
Client_res27	DW	?
Client_res28	DD	?
Client_Alt_Flags	DW	?
Client_res29	DW	?
Client_Alt_SP	DW	?
Client_Word_Reg_Struc	ENDS

Client_Byte_Reg_Struc	STRUC
Client_res30	DD	4 DUP (?)
Client_BL	DB	?
Client_BH	DB	?
Client_res31	DW	?
Client_DL	DB	?
Client_DH	DB	?
Client_res32	DW	?
Client_CL	DB	?
Client_CH	DB	?
Client_res33	DW	?
Client_AL	DB	?
Client_AH	DB	?
Client_Byte_Reg_Struc	ENDS
?UnionSize = 0
if size Client_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Reg_Struc
endif
CRS	equ	<(byte ptr 0)>

if size Client_Word_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Word_Reg_Struc
endif
CWRS	equ	<(byte ptr 0)>

if size Client_Byte_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Byte_Reg_Struc
endif
CBRS	equ	<(byte ptr 0)>


tagCLIENT_STRUC	STRUC
	DB	?UnionSize dup(?)
tagCLIENT_STRUC	ENDS

IF 0
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX

endif
DYNA_LINK_INT	EQU	20H












DeclareNonstandardCcallService macro arglst
	irp	x,<arglst>
	    ??_nonstandardccall_&x = 1
	endm
endm







DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page, _Assert_Range>

BeginDoc













EndDoc


BeginDoc








EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd  OFFSET32 vt[sn+jf]
ENDM

GenDD   MACRO   P, vid, snum, jflag
    LOCAL   vtable
IFDEF   @@VxDName&vid
    Deftable    vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd  @@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_nonstandardccall_&P
    PushCParams <Param>, <FAST>
    else
    PushCParams <Param>, <flags>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
    else
	ClearCParams
    endif
    ENDM

VxDJmp  MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc




























EndDoc




VxD_CODE_SEG    EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS   EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT   ENDS
        ENDM




VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT   ENDS
        ENDM




VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
        ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
        ENDM




VxD_INIT_CODE_SEG   MACRO
_ITEXT  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT  ENDS
        ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS




VxD_DATA_SEG    EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS   EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA   ENDS
        ENDM




VxD_IDATA_SEG   MACRO
_IDATA  SEGMENT
        ENDM
VxD_IDATA_ENDS  MACRO
_IDATA  ENDS
        ENDM




VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA   ENDS
        ENDM




VxD_STATIC_CODE_SEG MACRO
_STEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT   ENDS
        ENDM




VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA   ENDS
        ENDM



VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
        ENDM




VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
          ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
           ENDM



VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
          ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
           ENDM

endif
ifndef DDK_VERSION
ifdef WIN31COMPAT
DDK_VERSION	EQU	30AH
else
DDK_VERSION	EQU	400H
endif
endif

VxD_Desc_Block	STRUC
DDB_Next	DD	?
DDB_SDK_Version	DW	DDK_VERSION
DDB_Req_Device_Number	DW	UNDEFINED_DEVICE_ID
DDB_Dev_Major_Version	DB	0
DDB_Dev_Minor_Version	DB	0
DDB_Flags	DW	0
DDB_Name	DB	"        "
DDB_Init_Order	DD	UNDEFINED_INIT_ORDER
DDB_Control_Proc	DD	?
DDB_V86_API_Proc	DD	0
DDB_PM_API_Proc	DD	0
DDB_V86_API_CSIP	DD	0
DDB_PM_API_CSIP	DD	0
DDB_Reference_Data	DD	?
DDB_Service_Table_Ptr	DD	0
DDB_Service_Table_Size	DD	0
DDB_Win32_Service_Table	DD	0
DDB_Prev	DD	'Prev'
DDB_Size	DD	SIZE(VxD_Desc_Block)
DDB_Reserved1	DD	'Rsv1'
DDB_Reserved2	DD	'Rsv2'
DDB_Reserved3	DD	'Rsv3'
VxD_Desc_Block	ENDS
ifndef Not_VxD
DDB_SYS_CRIT_INIT_DONE_BIT	EQU	0
DDB_SYS_CRIT_INIT_DONE	EQU	(1 SHL DDB_SYS_CRIT_INIT_DONE_BIT)
DDB_DEVICE_INIT_DONE_BIT	EQU	1
DDB_DEVICE_INIT_DONE	EQU	(1 SHL DDB_DEVICE_INIT_DONE_BIT)
DDB_HAS_WIN32_SVCS_BIT	EQU	14
DDB_HAS_WIN32_SVCS	EQU	(1 SHL DDB_HAS_WIN32_SVCS_BIT)
DDB_DYNAMIC_VXD_BIT	EQU	15
DDB_DYNAMIC_VXD	EQU	(1 SHL DDB_DYNAMIC_VXD_BIT)
DDB_DEVICE_DYNALINKED_BIT	EQU	13
DDB_DEVICE_DYNALINKED	EQU	(1 SHL DDB_DEVICE_DYNALINKED_BIT)
BeginDoc







EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB    <Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
        Ref_Data_Offset EQU 0
ELSE
        Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db  0dh, 0ah, 'D_E_B_U_G===>'
        db      "&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
             OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
             ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM





























Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd  OFFSET32 ??_cd_&&num
ELSE
    dd  OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc




















EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz  Procedure
ENDIF

ELSE

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF

    ENDM

BYTE_INPUT	EQU	000H
BYTE_OUTPUT	EQU	004H
WORD_INPUT	EQU	008H
WORD_OUTPUT	EQU	00CH
DWORD_INPUT	EQU	010H
DWORD_OUTPUT	EQU	014H
OUTPUT_BIT	EQU	2
OUTPUT	EQU	(1 SHL OUTPUT_BIT)
WORD_IO_BIT	EQU	3
WORD_IO	EQU	(1 SHL WORD_IO_BIT)
DWORD_IO_BIT	EQU	4
DWORD_IO	EQU	(1 SHL DWORD_IO_BIT)
STRING_IO_BIT	EQU	5
STRING_IO	EQU	(1 SHL STRING_IO_BIT)
REP_IO_BIT	EQU	6
REP_IO	EQU	(1 SHL REP_IO_BIT)
ADDR_32_IO_BIT	EQU	7
ADDR_32_IO	EQU	(1 SHL ADDR_32_IO_BIT)
REVERSE_IO_BIT	EQU	8
REVERSE_IO	EQU	(1 SHL REVERSE_IO_BIT)
IO_SEG_MASK	EQU	0FFFF0000H
IO_SEG_SHIFT	EQU	10H
BeginDoc






EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je  Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb  In_Proc
ELSE
    je  Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc







EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM

BeginDoc








EndDoc


VxD_IOT_Hdr	STRUC
VxD_IO_Ports	DW	?
VxD_IOT_Hdr	ENDS

VxD_IO_Struc	STRUC
VxD_IO_Port	DW	?
VxD_IO_Proc	DD	?
VxD_IO_Struc	ENDS
.ERRNZ SIZE VxD_IOT_Hdr - 2
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw  Table_Name&_Entries
ELSE
    dw  ?
ENDIF
ELSE
    dw  Table_Name&_Entries
ENDIF

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6
VxD_IO MACRO Port, Proc_Name
    dw  Port
    dd  OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
        ENDM













Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc














EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc






EndDoc

IFDEF   DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF



PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16











Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM



VxDint  MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
        VMMCall _ExecVxDIntMustComplete
    ENDM



endif
DUPLICATE_DEVICE_ID_BIT	EQU	0
DUPLICATE_DEVICE_ID	EQU	(1 SHL DUPLICATE_DEVICE_ID_BIT)
DUPLICATE_FROM_INT2F_BIT	EQU	1
DUPLICATE_FROM_INT2F	EQU	(1 SHL DUPLICATE_FROM_INT2F_BIT)
LOADING_FROM_INT2F_BIT	EQU	2
LOADING_FROM_INT2F	EQU	(1 SHL LOADING_FROM_INT2F_BIT)
DEVICE_LOAD_OK	EQU	0
ABORT_DEVICE_LOAD	EQU	1
ABORT_WIN386_LOAD	EQU	2
NO_FAIL_MESSAGE_BIT	EQU	15
NO_FAIL_MESSAGE	EQU	(1 SHL NO_FAIL_MESSAGE_BIT)
LDRSRV_GET_PROFILE_STRING	EQU	0
LDRSRV_GET_NEXT_PROFILE_STRING	EQU	1
LDRSRV_RESERVED	EQU	2
LDRSRV_GET_PROFILE_BOOLEAN	EQU	3
LDRSRV_GET_PROFILE_DECIMAL_INT	EQU	4
LDRSRV_GET_PROFILE_HEX_INT	EQU	5
LDRSRV_COPY_EXTENDED_MEMORY	EQU	6
LDRSRV_GET_MEMORY_INFO	EQU	7
LDRSRV_RegOpenKey	EQU	100H
LDRSRV_RegCreateKey	EQU	101H
LDRSRV_RegCloseKey	EQU	102H
LDRSRV_RegDeleteKey	EQU	103H
LDRSRV_RegSetValue	EQU	104H
LDRSRV_RegQueryValue	EQU	105H
LDRSRV_RegEnumKey	EQU	106H
LDRSRV_RegDeleteValue	EQU	107H
LDRSRV_RegEnumValue	EQU	108H
LDRSRV_RegQueryValueEx	EQU	109H
LDRSRV_RegSetValueEx	EQU	10AH
LDRSRV_RegFlushKey	EQU	10BH
LDRSRV_COPY_INIT	EQU	1
LDRSRV_COPY_LOCKED	EQU	2
LDRSRV_COPY_PAGEABLE	EQU	3
RCODE_OBJ	EQU	-1
LCODE_OBJ	EQU	01H
LDATA_OBJ	EQU	02H
PCODE_OBJ	EQU	03H
PDATA_OBJ	EQU	04H
SCODE_OBJ	EQU	05H
SDATA_OBJ	EQU	06H
CODE16_OBJ	EQU	07H
LMSG_OBJ	EQU	08H
PMSG_OBJ	EQU	09H
DBOC_OBJ	EQU	0BH
DBOD_OBJ	EQU	0CH
ICODE_OBJ	EQU	11H
IDATA_OBJ	EQU	12H
ICODE16_OBJ	EQU	13H
IMSG_OBJ	EQU	14H

ObjectLocation	STRUC
OL_LinearAddr	DD	?
OL_Size	DD	?
OL_ObjType	DB	?
ObjectLocation	ENDS
MAXOBJECTS	EQU	25

Device_Location_List	STRUC
DLL_DDB	DD	?
DLL_NumObjects	DB	?
DLL_ObjLocation	DB	SIZE ObjectLocation * 1 DUP (?)
Device_Location_List	ENDS
PE_BIT	EQU	0
PE_MASK	EQU	(1 SHL PE_BIT)
MP_BIT	EQU	1
MP_MASK	EQU	(1 SHL MP_BIT)
EM_BIT	EQU	2
EM_MASK	EQU	(1 SHL EM_BIT)
TS_BIT	EQU	3
TS_MASK	EQU	(1 SHL TS_BIT)
ET_BIT	EQU	4
ET_MASK	EQU	(1 SHL ET_BIT)
PG_BIT	EQU	31
PG_MASK	EQU	(1 SHL PG_BIT)
CF_BIT	EQU	0
CF_MASK	EQU	(1 SHL CF_BIT)
PF_BIT	EQU	2
PF_MASK	EQU	(1 SHL PF_BIT)
AF_BIT	EQU	4
AF_MASK	EQU	(1 SHL AF_BIT)
ZF_BIT	EQU	6
ZF_MASK	EQU	(1 SHL ZF_BIT)
SF_BIT	EQU	7
SF_MASK	EQU	(1 SHL SF_BIT)
TF_BIT	EQU	8
TF_MASK	EQU	(1 SHL TF_BIT)
IF_BIT	EQU	9
IF_MASK	EQU	(1 SHL IF_BIT)
DF_BIT	EQU	10
DF_MASK	EQU	(1 SHL DF_BIT)
OF_BIT	EQU	11
OF_MASK	EQU	(1 SHL OF_BIT)
IOPL_MASK	EQU	3000H
IOPL_BIT0	EQU	12
IOPL_BIT1	EQU	13
NT_BIT	EQU	14
NT_MASK	EQU	(1 SHL NT_BIT)
RF_BIT	EQU	16
RF_MASK	EQU	(1 SHL RF_BIT)
VM_BIT	EQU	17
VM_MASK	EQU	(1 SHL VM_BIT)
AC_BIT	EQU	18
AC_MASK	EQU	(1 SHL AC_BIT)
VIF_BIT	EQU	19
VIF_MASK	EQU	(1 SHL VIF_BIT)
VIP_BIT	EQU	20
VIP_MASK	EQU	(1 SHL VIP_BIT)






IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF

P_SIZE	EQU	1000H
P_PRESBIT	EQU	0
P_PRES	EQU	(1 SHL P_PRESBIT)
P_WRITEBIT	EQU	1
P_WRITE	EQU	(1 SHL P_WRITEBIT)
P_USERBIT	EQU	2
P_USER	EQU	(1 SHL P_USERBIT)
P_ACCBIT	EQU	5
P_ACC	EQU	(1 SHL P_ACCBIT)
P_DIRTYBIT	EQU	6
P_DIRTY	EQU	(1 SHL P_DIRTYBIT)
P_AVAIL	EQU	(P_PRES+P_WRITE+P_USER)
PG_VM	EQU	0
PG_SYS	EQU	1
PG_RESERVED1	EQU	2
PG_PRIVATE	EQU	3
PG_RESERVED2	EQU	4
PG_RELOCK	EQU	5
PG_INSTANCE	EQU	6
PG_HOOKED	EQU	7
PG_IGNORE	EQU	0FFFFFFFFH
D_PRES	EQU	080H
D_NOTPRES	EQU	0
D_DPL0	EQU	0
D_DPL1	EQU	020H
D_DPL2	EQU	040H
D_DPL3	EQU	060H
D_SEG	EQU	010H
D_CTRL	EQU	0
D_GRAN_BYTE	EQU	000H
D_GRAN_PAGE	EQU	080H
D_DEF16	EQU	000H
D_DEF32	EQU	040H
D_CODE	EQU	08H
D_DATA	EQU	0
D_X	EQU	0
D_RX	EQU	02H
D_C	EQU	04H
D_R	EQU	0
D_W	EQU	02H
D_ED	EQU	04H
D_ACCESSED	EQU	1
RW_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_W)
R_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_R)
CODE_TYPE	EQU	(D_PRES+D_SEG+D_CODE+D_RX)
D_PAGE32	EQU	(D_GRAN_PAGE+D_DEF32)
SELECTOR_MASK	EQU	0FFF8H
SEL_LOW_MASK	EQU	0F8H
TABLE_MASK	EQU	04H
RPL_MASK	EQU	03H
RPL_CLR	EQU	(NOT RPL_MASK)
IVT_ROM_DATA_SIZE	EQU	500H
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\vmm2.h ===
//
// VMM2.H
// VMM Call Macros and function prototypes for functions not defined in VMM.H
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.


//
//	Function Prototypes
//
VOID vmmOutDebugString(char *);

VOID vmmOutDebugStringValue(char *, U032);	

VOID	dbgBreakPoint();

U032 vmmAllocateGDTSelector(U032, U032, U032);

U032 vmmAllocateLDTSelector(U032, U032, U032, U032, U032);

VOID vmmBuildDescriptorDWORDs(U032, U032, U032, U032, U032, QUADWORD*);

U032 vmmFreeLDTSelector(U032, U032, U032);

U032 vmmGetSystemTime();

U032 vmmCallPriorityVMEvent(U032, U032, U032, U032, U032, U032);

VOID vmmSimulatePush(U032);

VOID vmmSimulateFarCall(U032, U032);

VOID vmmGetDescriptor(U032, U032, U032, QUADWORD *);

U032 vmmPageCheckLinRange(U032, U032, U032);

U032 vmmLinPageLock(U032, U032, U032);    

U032 vmmLinPageUnLock(U032, U032, U032);

VOID vmmPageAllocate(U032, U032, U032, U032, U032, U032, U032, U032, QUADWORD *);

U032 vmmPageReserve(U032, U032, U032);

U032 vmmPageCommitPhys(U032, U032, U032, U032);

U032 vmmPageDecommit(U032, U032, U032);

VOID vmmPageGetSizeAddr(U032, U032, QUADWORD *);

U032 vmmPageLock(U032, U032, U032, U032);

U032 vmmPageUnLock(U032, U032, U032, U032);

U032 vmmPageFree(U032, U032);

U032 vmmSetDescriptor(U032, U032, U032, U032, U032);

U032 vmmSelectorMapFlat(U032, U032, U032);

U032 vmmGetSysVMHandle(VOID);

U032 vmmGetCritSectionStatus(VOID);

U032 vmmCopyPageTable(U032, U032, U032, U032);

U032 vmmMapPhysToLinear(U032, U032, U032);

U032 vmmGetCurrentContext(VOID);

U032 vmmContextSwitch(U032);

U032 vmmGetProfileHexInt(U032, char *, char *);

U032 vmmGetProfileDecimalInt(U032, char *, char *);

U032 vmmGetSysVMHandle(VOID);

VOID vmmFatalErrorHandler(U032, U032);

VOID vmmCallBackExit(U032);

VOID vmmCallBackEntry(VOID);

VOID vmmRestoreClientState(CRS *);

VOID vmmSaveClientState(CRS *);	

U032 vmmCreateSemaphore(U032);

U032 vmmWaitSemaphore(U032, U032);	

U032 vmmSignalSemaphore(U032);

U032 picGetIRQVirtualizedStatus(U032, U032);

U032 mtrrGetVersion(VOID);

U032 mtrrSetPhysicalCacheTypeRange(U032, U032, U032, U032);

U016 vddGetVersion(VOID);

U032 vddGetDisplayInfo(U032, PDISPLAYINFO, U032);


// This is just like the macro VMMCall in VMM.H, except it doesn't use the GetVxDServiceOrdinal macro, which gets the 
// service number from the service table, which is generated on the fly. We would have to alter the service table macro
// to add more services for that to work.
// the "service" upper word is the device, the lower word is the service
#define CALL_VMM(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (service & 0xff) \
    _asm _emit (service >> 8) & 0xff \
    _asm _emit (service >> 16) & 0xff \
    _asm _emit (service >> 24) & 0xff 

#define VDD_Device_ID          0x0000A
//	Macro for VDD services. Just like CALL_VMM above, except substitue the VDD device number
#define CALL_VDD(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (service & 0xff) \
    _asm _emit (service >> 8) & 0xff \
    _asm _emit (VDD_Device_ID) & 0xff \
    _asm _emit (VDD_Device_ID >> 8) & 0xff 


//	Defines for service numbers. These are services that Microsoft hasn't bothered to define a C-callable service table for.
#define Get_Sys_VM_Handle                   0x00010003
#define Call_Priority_VM_Event              0x00010014
#define Create_Semaphore                    0x00010025
#define Wait_Semaphore                      0x00010027
#define Signal_Semaphore                    0x00010028
#define Get_Crit_Section_Status             0x00010029
#define Get_System_Time                     0x0001003f
#define Simulate_Far_Call                   0x00010048
#define Simulate_Push                       0x0001004d
#define Simulate_Pop                        0x0001004e
#define _PageFree                           0x00010055
#define _PageLock                           0x00010056
#define _PageUnLock                         0x00010057
#define _PageGetSizeAddr                    0x00010058
#define _PageAllocate                       0x00010053
#define _CopyPageTable                      0x00010061
#define _LinPageLock                        0x00010063
#define _LinPageUnLock                      0x00010064
#define _PageCheckLinRange                  0x00010067
#define _MapPhysToLinear                    0x0001006c
#define _SelectorMapFlat                    0x0001006e
#define Allocate_GDT_Selector              0x00010076
#define Allocate_LDT_Selector              0x00010078
#define Free_LDT_Selector                  0x00010079
#define BuildDescriptorDWORDs              0x0001007a
#define _GetDescriptor                      0x0001007b
#define _SetDescriptor                      0x0001007c
#define End_Nest_Exec                       0x00010086
#define Save_Client_State                   0x0001008d
#define Restore_Client_State                0x0001008e
#define Fatal_Error_Handler                 0x000100be
#define Begin_Nest_Exec                     0x00010083
#define Resume_Exec                         0x00010085
#define Get_Profile_Decimal_Int             0x000100ab
#define Get_Profile_Hex_Int                 0x000100af
#define Test_Debug_Installed                0x000100c1
#define Out_Debug_String                    0x000100c2
#define _CreateMutex                        0x00010101
#define _DestroyMutex                       0x00010102
#define _PageReserve                        0x0001011d
#define _PageDecommit                       0x0001011f
#define _PageCommitPhys                     0x00010128
#define _EnterMutex                         0x0001012e
#define _LeaveMutex                         0x0001012f
#define _ContextSwitch                      0x00010132
#define _RegOpenKey                         0x00010148
#define _RegCloseKey                        0x00010149
#define _RegQueryValue                      0x0001014d
#define _GetCurrentContext                  0x00010157
#define _MTRR_Get_Version                   0x004A0000
#define _MTRRSetPhysicalCacheTypeRange      0x004A0001
#define Time_Slice_Sleep                    0x00010161
#define _GARTReserve                        0x000101AE
#define _GARTCommit                         0x000101AF
#define _GARTUncommit                       0x000101B0
#define _GARTFree                           0x000101B1
#define _GARTMemAttributes                  0x000101B2

// VDD services. (doesn't include device number)
#define VDD_Get_Version                     0x0000  // Get version number and ID string ptr
#define VDD_Get_DISPLAYINFO                 0x0014  //get DISPLAYINFO data structure


#define	PG_UNCACHED		    0x00000001		// Uncached memory
#define	PG_WRITECOMBINED	0x00000002		// Write combined memory
            
U032 vmmGARTReserve(U032, U032, U032, U032, U032);
U032 vmmGARTCommit(U032, U032, U032, U032, U032);
U032 vmmGARTUnCommit(U032, U032, U032);
U032 vmmGARTFree(U032);
U032 vmmGARTMemAttributes(U032, U032);

//	VMM Call Macros (inline functions)

#define vmmSimulatePop() CALL_VMM(Simulate_Pop)   

#define vmmBeginNestExecution() CALL_VMM(Begin_Nest_Exec);

#define vmmResumeExec() CALL_VMM(Resume_Exec);

#define vmmEndNestExecution() CALL_VMM(End_Nest_Exec);

#define osSwapStack(newStack, oldStack)	\
	_asm	mov		eax, newStack		\
	_asm	xchg	eax, esp			\
    _asm	mov		oldStack, eax
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VKDPASTE.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	vkdpaste.inc -
;
;   Version:	1.00
;
;   Date:	20-Mar-1989
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   20-Mar-1989 RAP
;   23-Mar-1989 RAP added PM API equates
;
;==============================================================================

;
; structure of entries in paste buffer
;
Paste_Rec STRUC
Paste_Char	    db	?   ; OEM char value
Paste_ScanCode	    db	?   ; keyboard scan code
Paste_ShiftState    dw	?   ; shift state
Paste_Rec ENDS

Paste_Key   equ word ptr Paste_Char


;BeginDoc
;------------------------------------------------------------------------------
;
; API services:
;
VKD_API_Version     equ 0
	;   ENTER:  EAX = 0
	;   EXIT:   AH = major version #
	;	    AL = minor version #
	;	    Carry clear

VKD_Current_Version equ 200h

VKD_Force_Key	    equ 1
	;   ENTER:  EAX = 1
	;	    EBX = VM handle  (0 for current)
	;	    CH = scan code
	;	    CL = repeat count
	;	    EDX = shift state  (-1 means no change)
	;   EXIT:   Carry set, if failed

;
; shift state equates
;
FKSS_Insert_Down    equ 1000000000000000b
FKSS_CapLck_Down    equ 0100000000000000b
FKSS_NumLck_Down    equ 0010000000000000b
FKSS_ScrLck_Down    equ 0001000000000000b
FKSS_Insert_On	    equ 0000000010000000b
FKSS_CapLck_On	    equ 0000000001000000b
FKSS_NumLck_On	    equ 0000000000100000b
FKSS_ScrLck_On	    equ 0000000000010000b
FKSS_Alt_Down	    equ 0000000000001000b
FKSS_Ctrl_Down	    equ 0000000000000100b
FKSS_Shift_Down     equ 0000000000000010b

;EndDoc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMM.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:   1.00
 *
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.  Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE       0       // False
#define VMM_TRUE    (~FALSE)    // The opposite of False!

#define DEBLEVELRETAIL  0
#define DEBLEVELNORMAL  1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef  NEWSTRUCTS      ; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *          EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID       0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID       0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID       0x0000A
#define VSD_DEVICE_ID       0x0000B
#define VMD_DEVICE_ID       0x0000C
#define VKD_DEVICE_ID       0x0000D
#define VCD_DEVICE_ID       0x0000E
#define VPD_DEVICE_ID       0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID       0x0001B
#define VDD2_DEVICE_ID      0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID      0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID       0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID      0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID        0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID         0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID       0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID      0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID   0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS     */
/* #define VNB_DEVICE_ID           0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID        0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID      */

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID      0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID       0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F  /* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID       0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID      0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */

#define AWREDIR_DEVICE_ID   0x00049 /* AtWork Network FSD */

/*
 *   Far East DOS support VxD ID
 */

#define ETEN_Device_ID      0x00060 /* ETEN DOS (Taiwan) driver */
#define CHBIOS_Device_ID    0x00061 /* CHBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */
#define VIME_Device_ID      0x00064 /* Virtual DOS IME */
#define VHBIOSD_Device_ID   0x00065 /* HBIOS (Korean) for HWin31 driver */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */ 
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.  Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER      0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER     0x000000000 /*  but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER          0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER      0x014000000
#define VXDLDR_INIT_ORDER   0x016000000

#define ENUMERATOR_INIT_ORDER   0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER      ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define CONFIGMG_INIT_ORDER ENUMERATOR_INIT_ORDER+0xFFFF    /* After all enumerators */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER      0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER      0x028000000
#define VSD_INIT_ORDER      0x02C000000

#define VCD_INIT_ORDER      0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER      0x034000000
#define VKD_INIT_ORDER      0x038000000
#define VPD_INIT_ORDER      0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER   0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER    0x080000000
#define WIN32_INIT_ORDER    UNDEFINED_INIT_ORDER
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order      0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER      0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;          /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;           /* Client's EDI */
    ULONG Pushad_ESI;           /* Client's ESI */
    ULONG Pushad_EBP;           /* Client's EBP */
    ULONG Pushad_ESP;           /* ESP before pushad */
    ULONG Pushad_EBX;           /* Client's EBX */
    ULONG Pushad_EDX;           /* Client's EDX */
    ULONG Pushad_ECX;           /* Client's ECX */
    ULONG Pushad_EAX;           /* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)  // turn off redefinition warning

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;

#pragma warning (default:4209)  // turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)   __##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG       code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG       data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG   code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG   data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DBOCODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DBODATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG    code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG   code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG  code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG   code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG  code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG  code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG   code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG   code_seg("LOCKABLE", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =   1
??_ICODE    =   2
??_PCODE    =   3
??_SCODE    =   4
??_DBOCODE  =   5
??_16ICODE  =   6
??_RCODE    =   7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE  equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF   MASM6
_FLAT   EQU FLAT
ELSE
_FLAT   EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT      ENDS

_TEXT       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT       ENDS

;*  32 bit pageable code
_PTEXT      SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT      ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB    <classname>
    segname     SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname     SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
        ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB    <grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM                ;; End for each segment

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***    DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***    DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***    CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
        extrn   name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***    MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***    MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or  ??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT      ENDS

;*  32 bit locked data
_LDATA      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA      ENDS

_DATA       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA       ENDS

;*  32 bit pageable data
_PDATA      SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA      ENDS

;*  32 Bit initialization data
_IDATA      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA      ENDS

;*  Created by C8
_BSS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS        ENDS

CONST       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST       ENDS

_TLS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS        ENDS

;*  32 Bit static code for DL-VxDs
_STEXT      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT      ENDS

;*  32 Bit static data for DL-VxDs
_SDATA      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA      ENDS

;*      dummy segment for IsDebugOnlyLoaded
_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS

;*      32 bit debug only code; loaded only if debugger is present
_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS

;*      32 bit debug only data; loaded only if debugger is present
_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL
;*	Start of 32 bit path coverage data
_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS

;*	32 bit path coverage data
_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS

;*	End of 32 bit path coverage data
_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE      SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE      ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP	  GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;       . . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1           ; Only in module where table is
;   INCLUDE     VxD.INC         ; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF   Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID    = 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName  Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName   MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table

Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&Procedure

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
    EXTRN   Procedure:NEAR
      ELSE
    dd  OFFSET32 Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
        IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
        ENDIF
        IFNB <Condition>
    $$&&Procedure extern
       ELSE
    EXTRN   Procedure:NEAR
        ENDIF
        IFNB <Local_Seg>
Local_Seg&&_ENDS
        ELSE
Def_Segment&_CODE_ENDS
        ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
    dd  OFFSET32 Procedure
      ENDIF

          IFDEF Device_Name&_Name_Based
        @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
          ELSE
        @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
          ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF   Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ENDIF

ENDIF

    ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal    macro   reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress    macro   reg,service
    mov reg,OFFSET32 service
    endm


;***    Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.  If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName     - the name of the VxD; it is assumed
;                 that a corresponding Device_ID is
;                 also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;       accepts a service name as its only parameter.
;       This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd  csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
        .erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
        dd  OFFSET32 Name,cparm&&Name
    endif
        @32&&Name equ   ((VxDName&_Device_ID SHL 16) + ??w32svcno)
        ??w32svcno = ??w32svcno + 1
        ENDM
    ENDM


;***    End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName     - the same name passed to
;                 Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***    Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name        - the service name
;       cParms      - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***    Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service     - the name of the service
;       CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)   service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp  VxDJmp

#define SERVICE     __cdecl
#define ASYNC_SERVICE   __cdecl
#define WIN32_SERVICE   void __stdcall
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
        ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status;         /* VM status flags */
    ULONG CB_High_Linear;       /* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56      /* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT    0x00    /* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE        (1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT   0x01    /* VM runs in background */
#define VMSTAT_BACKGROUND       (1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING         (1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT    0x03    /* VM not scheduled */
#define VMSTAT_SUSPENDED        (1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE  (1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC          (1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP           (1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32         (1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC         (1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09   /* High pri background */
#define VMSTAT_HIGH_PRI_BACK    (1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED          (1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT    0x0B    /* Woke up after blocked */
#define VMSTAT_AWAKENING        (1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT   0x0C    /* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT  VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86      (1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D    /* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED    (1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E    /* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT     (1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT         0x0F    /* VM has released time slice */
#define VMSTAT_IDLE             (1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING          (1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11    /* VM suspended by */
#define VMSTAT_TS_SUSPENDED     (1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT    0x12    /* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI        (1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;          /* Thread status flags */
    ULONG   TCB_Reserved1;      /* Used internally by VMM */
    ULONG   TCB_Reserved2;      /* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;      /* Client registers of thread */
    ULONG   TCB_VMHandle;       /* VM that thread is part of */
    USHORT  TCB_ThreadId;       /* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;       /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;      /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;     /* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;           /* reusable; for dword align */
    UCHAR   TCB_pad2;           /* reusable; for dword align */
    UCHAR   TCB_extErrLocus;        /* extended error Locus */
    USHORT  TCB_extErr;         /* extended error Code */
    UCHAR   TCB_extErrAction;       /*      "   "   Action */
    UCHAR   TCB_extErrClass;        /*      "   "   Class */
    ULONG   TCB_extErrPtr;      /*      "   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD         0x42434854    // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT        0x03   // Thread not scheduled
#define THFLAG_SUSPENDED                   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE             (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION             (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED              (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_RING0_THREAD_BIT     0x1C   // thread runs only at ring 0
#define THFLAG_RING0_THREAD	           (1L << THFLAG_RING0_THREAD_BIT)
#define THFLAG_CHARSET_BITS     0x10   // Default character set
#define THFLAG_CHARSET_MASK        (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI            (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM             (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE             (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED            (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES            (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.  
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13   // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE            (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;             // faulting EIP
    WORD  VMFI_CS;              // faulting CS
    WORD  VMFI_Ints;            // interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *              V M M   S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)    // MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define HEAPZEROINIT    0x00000001
#define HEAPZEROREINIT  0x00000002
#define HEAPNOCOPY  0x00000004
#define HEAPLOCKEDIFDP  0x00000100
#define HEAPSWAP    0x00000200
#define HEAPINIT        0x00000400
#define HEAPCLEAN   0x00000800

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT        0x00000001
#define PAGEUSEALIGN        0x00000002
#define PAGECONTIG      0x00000004
#define PAGEFIXED       0x00000008
#define PAGEDEBUGNULFAULT   0x00000010
#define PAGEZEROREINIT      0x00000020
#define PAGENOCOPY      0x00000040
#define PAGELOCKED      0x00000080
#define PAGELOCKEDIFDP      0x00000100
#define PAGESETV86PAGEABLE  0x00000200
#define PAGECLEARV86PAGEABLE    0x00000400
#define PAGESETV86INTSLOCKED    0x00000800
#define PAGECLEARV86INTSLOCKED  0x00001000
#define PAGEMARKPAGEOUT     0x00002000
#define PAGEPDPSETBASE      0x00004000
#define PAGEPDPCLEARBASE    0x00008000
#define PAGEDISCARD     0x00010000
#define PAGEPDPQUERYDIRTY   0x00020000
#define PAGEMAPFREEPHYSREG  0x00040000
#define PAGENOMOVE      0x10000000
#define PAGEMAPGLOBAL       0x40000000
#define PAGEMARKDIRTY       0x80000000

/****************************************************
 *
 *      Flags for _PhysIntoV86,
 *      _MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP       0x00000001


// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL  0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE   0x00000002
#define MMGRHMADISABLE  0x00000004
#define MMGRHMAQUERY    0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT        0
#define LF_ASYNC        (1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP     (1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR      (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP         (LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area, VMM_ICODE)
VMM_Service (_Free_Temp_V86_Data_Area, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign       0x00000001
#define GVDADWordAlign      0x00000002
#define GVDAParaAlign       0x00000004
#define GVDAPageAlign       0x00000008
#define GVDAInstance        0x00000100
#define GVDAZeroInit        0x00000200
#define GVDAReclaim	    0x00000400
#define GVDAInquire	    0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE       260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT  0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT   0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT    0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT   0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT  0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (Set_System_Exit_Code)

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *          D E B U G G I N G   E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)      // Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)       // for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz  @@Test_DBCS_Lead_Byte - 100D1h   ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
#define AFPP_SWAPOUT     0x0001 // physical memory that must be swapped out
                                // and subsequently restored at system exit
/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY      0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS    0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001  /* Privledged instruction */
#define GSDVME_INVALINST    0x00010002  /* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003  /* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004  /* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005  /* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006  /* User requested NUKE of VM */
#define GSDVME_DEVNUKE      0x00010007  /* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008  /* Device specific problem:
                         *   invalid hardware fiddling
                         *   by VM (invalid I/O)
                         */
#define GSDVME_NUKENOMSG    0x00010009  /* Supress standard messages:
                         *   SHELL_Message used for
                         *   custom msg.
                         */
#define GSDVME_OKNUKEMASK   0x80000000  /* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001  /* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002  /* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003  /* XMS Kb Req      - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004  /* EMS Kb Req      - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005  /* Hi DOS V86 mem   - DOSMGR
                         *           V86MMGR
                         */
#define GSDVME_INSMEMVID    0x00020006  /* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007  /* Base VM mem     - VMM
                         *   CB, Inst Buffer
                         */
#define GSDVME_INSMEMDEV    0x00020008  /* Couldn't alloc base VM
                         * memory for device.
                         */
#define GSDVME_CRTNOMSG     0x00020009  /* Supress standard messages:
                         *   SHELL_Message used for
                         *   custom msg.
                         */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001  /* Page directory entry not-present */
#define IPF_V86PG   0x00000002  /* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004  /* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008  /* page has invalid not present type */
#define IPF_PGERR   0x00000010  /* pageswap device failure */
#define IPF_REFLT   0x00000020  /* re-entrant page fault */
#define IPF_VMM     0x00000040  /* Page fault caused by a VxD */
#define IPF_PM      0x00000080  /* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100  /* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (Set_Delete_On_Exit_File)

VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT   0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)      // Debugging only
VMM_Service (Disable_Touch_1st_Meg)     // Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz   @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT         0
#define DFS_LOG             (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT         1
#define DFS_PROFILE         (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT        2
#define DFS_TEST_CLD            (1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT       3
#define DFS_NEVER_REENTER       (1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT        4
#define DFS_TEST_REENTER        (1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT        5
#define DFS_NOT_SWAPPING        (1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT      6
#define DFS_TEST_BLOCK          (1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES	0xFFFFFF80

#define DFS_EXIT_NOBLOCK        (DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK       (DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC	(DFS_RARE_SERVICES+1)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service (Test_VM_Ints_Enabled)
VMM_Service (_BlockOnID)

VMM_Service (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define	MUTEX_MUST_COMPLETE		1L
#define	MUTEX_NO_CLEANUP_THREAD_STATE	2L

/*MACROS*/
VMM_Service (_CreateMutex)

VMM_Service (_DestroyMutex)
VMM_Service (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service (VMMCreateThread)
VMM_Service (_GetThreadExecTime)
VMM_Service (VMMTerminateThread)

VMM_Service (Get_Cur_Thread_Handle)
VMM_Service (Test_Cur_Thread_Handle)
VMM_Service (Get_Sys_Thread_Handle)
VMM_Service (Test_Sys_Thread_Handle)
VMM_Service (Validate_Thread_Handle)
VMM_Service (Get_Initial_Thread_Handle)
VMM_Service (Test_Initial_Thread_Handle)
VMM_Service (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service (Cancel_Call_When_Thread_Switched)
VMM_Service (Get_Next_Thread_Handle)
VMM_Service (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service (_EnterMutex)
VMM_Service (_LeaveMutex)
VMM_Service (Simulate_VM_IO)
VMM_Service (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service (_EnterMustComplete)
VMM_Service (_LeaveMustComplete)
VMM_Service (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND       1L
#define THREAD_TERM_STATUS_NUKE_PEND        2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service (_GetThreadTerminationStatus)
VMM_Service (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE   0       /* no data instanced in range */
#define INSTINFO_SOME   1       /* some data instanced in range */
#define INSTINFO_ALL    2       /* all data instanced in range */

/*MACROS*/
VMM_Service (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service (Call_Priority_Thread_Event)
VMM_Service (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ      // define only if not there already

#define REG_SZ      0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT       0x80000000
#define HKEY_CURRENT_USER       0x80000001
#define HKEY_LOCAL_MACHINE      0x80000002
#define HKEY_USERS          	0x80000003
#define HKEY_PERFORMANCE_DATA   0x80000004
#define HKEY_CURRENT_CONFIG     0x80000005
#define HKEY_DYN_DATA       	0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service (_LocalizeSprintf)
VMM_Service (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE   0       /* no pages in the specified range exist */
#define PHYSINFO_SOME   1       /* some pages in the specified range exist */
#define PHYSINFO_ALL    2       /* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service (Time_Slice_Sys_VM_Idle)
VMM_Service (Time_Slice_Sleep)
VMM_Service (Boost_With_Decay)
VMM_Service (Set_Inversion_Pri)
VMM_Service (Reset_Inversion_Pri)
VMM_Service (Release_Inversion_Pri)
VMM_Service (Get_Thread_Win32_Pri)
VMM_Service (Set_Thread_Win32_Pri)
VMM_Service (Set_Thread_Static_Boost)
VMM_Service (Set_VM_Static_Boost)
VMM_Service (Release_Inversion_Pri_ID)
VMM_Service (Attach_Thread_To_Group)
VMM_Service (Detach_Thread_From_Group)
VMM_Service (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM    0
#define REGTYPE_CLASS   1
#define REGTYPE_VXD     2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN                 0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD   0x00000000
#define ASSERT_RANGE_NULL_OK    0x00000001
#define ASSERT_RANGE_NO_DEBUG   0x80000000
#define ASSERT_RANGE_BITS       0x80000001

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQueryMultipleValues)

// Additional timeslicer services
VMM_Service (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN              0x00000001
#define BOOT_DOSCLEAN           0x00000002
#define BOOT_NETCLEAN           0x00000004
#define BOOT_INTERACTIVE        0x00000008

/*MACROS*/
VMM_Service (Get_Boot_Flags)
VMM_Service (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service (_AddReclaimableItem)
VMM_Service (_SetReclaimableItem)
VMM_Service (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service (Time_Slice_Wake_Sys_VM)
VMM_Service (VMM_Replace_Global_Environment)
VMM_Service (Begin_Non_Serial_Nest_V86_Exec)
VMM_Service (Get_Nest_Exec_Status)
/*ENDMACROS*/

// Bootlogging services

/*MACROS*/
VMM_Service (Open_Boot_Log)
VMM_Service (Write_Boot_Log)
VMM_Service (Close_Boot_Log)
VMM_Service (EnableDisable_Boot_Log)
VMM_Service (_Call_On_My_Stack)
/*ENDMACROS*/

// Another instance data service

/*MACROS*/
VMM_Service (Get_Inst_V86_Int_Vec_Base)
/*ENDMACROS*/

// Case insensitive functions -- SEE WARNINGS IN DOCS BEFORE USING!
/*MACROS*/
VMM_Service (_lstrcmpi)
VMM_Service (_strupr)
/*ENDMACROS*/

/*MACROS*/
VMM_Service (Log_Fault_Call_Out)
VMM_Service (_AtEventTime)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)          // turn on not enough params warning
/*XLATON*/

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM              0x00000001
#define RS_RESTORE              0x00000002
#define RS_DOSARENA             0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;                  // low (< 1meg) address of item
    ULONG   RS_Bytes;                   // size of item in bytes
    ULONG   RS_CallBack;                // callback, if any (zero if none)
    ULONG   RS_RefData;                 // reference data for callback, if any
    ULONG   RS_HookTable;               // real-mode hook table (zero if none)
    ULONG   RS_Flags;                   // 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
struct DemandInfoStruc {
    ULONG DILin_Total_Count;    /* # pages in linear address space */
    ULONG DIPhys_Count;         /* Count of phys pages */
    ULONG DIFree_Count;         /* Count of free phys pages */
    ULONG DIUnlock_Count;       /* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;   /* Base of pageable address space */
    ULONG DILin_Total_Free;     /* Total Count of free linear pages */

    /*
     *  The following 5 fields are all running totals, kept from the time
     *  the system was started
     */
    ULONG DIPage_Faults;        /* total page faults */
    ULONG DIPage_Ins;           /* calls to pagers to page in a page */
    ULONG DIPage_Outs;          /* calls to pagers to page out a page*/
    ULONG DIPage_Discards;      /* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;    /* instance page faults */

    ULONG DIPagingFileMax;      /* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;    /* # of pages of paging file currently in use */

    ULONG DICommit_Count;       /* Total committed memory, in pages */

    ULONG DIReserved[2];        /* Reserved for expansion */
};

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;        /* INIT <0> RESERVED */
    ULONG InstLinkB;        /* INIT <0> RESERVED */
    ULONG InstLinAddr;      /* Linear address of start of block */
    ULONG InstSize;         /* Size of block in bytes */
    ULONG InstType;         /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD     0x100   /* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD    0x200   /* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD  0x400   /* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;      /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;        /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400  /* anywhere in private arena */
#define PR_SHARED   0x80060000  /* anywhere in shared arena */
#define PR_SYSTEM   0x80080000  /* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008  /* don't move during PageReAllocate */
#define PR_4MEG     0x00000001  /* allocate on 4mb boundary */
#define PR_STATIC   0x00000010  /* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001  /* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002  /* swappable uninitialized pages */
#define PD_FIXEDZERO    0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004  /* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008  /* pages are permanently locked */
#define PC_LOCKED   0x00000080  /* pages are made present and locked*/
#define PC_LOCKEDIFDP   0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE    0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000  /* make the pages ring 3 accessible */
#define PC_INCR     0x40000000  /* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000  /* make pages initially present */
#define PC_STATIC   0x20000000  /* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000  /* make pages initially dirty */

/* PageCommitContig additional flags */
#define PCC_ZEROINIT    0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000  /* don't map to any linear address */

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *      clean - page has not been written to since its last page out
 *      dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *      virgin - page has never been written to since it was committed
 *      tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *      For 32-bit EXE code or read-only data:
 *
 *        pd_virginin = routine to load page from an exe file
 *        pd_taintedin = 0
 *        pd_cleanout = 0
 *        pd_dirtyout = 0
 *        pd_virginfree = 0
 *	  pd_taintedfree = 0
 *	  pd_dirty = 0
 *        pd_type = PD_PAGERONLY
 *
 *      For 32-bit EXE writeable data:
 *
 *        pd_virginin = routine to load page from an exe file
 *        pd_taintedin = routine to load page from swap file
 *        pd_cleanout = 0
 *        pd_dirtyout = routine to write a page out to the swap file
 *        pd_virginfree = 0
 *        pd_taintedfree = routine to free page from the swap file
 *        pd_dirty = routine to free page from the swap file
 *        pd_type = PD_SWAPPER
 *
 *      For zero-initialized swappable data:
 *
 *        pd_virginin = routine to zero-fill a page
 *        pd_taintedin = routine to load page from swap file
 *        pd_cleanout = 0
 *        pd_dirtyout = routine to write a page out to the swap file
 *        pd_virginfree = 0
 *        pd_taintedfree = routine to free page from the swap file
 *        pd_dirty = routine to free page from the swap file
 *        pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *  The following four fields are entry points in the pager which
     *  we call to page in or page out a page.  The following parameters
     *  are passed to the pager during these calls:
     *
     *  ppagerdata - pointer to the pager-specific dword of data
     *           stored with the virtual page.  The pager is
     *           free to modify the contents of this dword
     *           DURING the page in or out, but not afterwards.
     *
     *  ppage - pointer to page going in or out (a ring 0 alias
     *      to the physical page).  The pager should use this
     *      address to access the contents of the page.
     *
     *  faultpage - faulting linear page number for page-ins, -1 for
     *          page-outs.  This address should not be accessed
     *          by the pager.  It is provided for information
     *          only.  Note that a single page can be mapped at
     *          more than one linear address because of the
     *          MapIntoV86 and LinMapIntoV86 services.
     *
     *  The pager should return non-0 if the page was successfully
     *  paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *  The pd_*free routines are used to inform the pager when the last
     *  reference to a virtual page controlled by the pager is
     *  decommitted.  A common use of this notification is to
     *  free space in a backing file, or write the page contents
     *  into the backing file.
     *
     *  These calls take the same parameters as the page-out and -in
     *  functions, but no return value is recognized.  The "ppage"
     *  and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *  The pd_dirty routine is used to inform the pager when the
     *  memory manager detects that a page has been written to.  The memory
     *  manager does not detect the write at the instant it occurs, so
     *  the pager should not depend upon prompt notification.  A common
     *  use of this notification might be to invalidate cached data.
     *  If the page was dirtied in more than one memory context,
     *  the pager's pd_dirty routine will be called once for each
     *  context.
     *
     *  These calls take the same parameters as the page-out and -in
     *  functions except that the "ppage" parameter isn't valid and
     *  no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *  The pd_type field gives the sytem information about the
     *  overcommit characteristics of pages controlled by this pager.
     *  The following are allowable values for the field:
     *
     *  PD_SWAPPER - under some conditions, pages of this type
     *		may be paged out into the swap file
     *  PD_PAGERONLY - pages controlled by this pager will never
     *		be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *		functions perform nested excecution or block using the
     *		BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *		specified if the pager does any sort of file i/o to anything
     *		other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER	0   /* pages need direct accounting in swap file */
#define PD_PAGERONLY    1   /* pages will never be swapped */
#define PD_NESTEXEC	2   /* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR      ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR      ((ULONG) 0xc0000000)    /* 3 gig */
#define MAXSHAREDLADDR      ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR      ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR     ((ULONG) 0x003fffff)
#define MINDOSLADDR     ((ULONG) 0x00000000)

#define MAXSYSTEMPAGE       (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE       (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE       (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE       (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE      (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE      (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE      (MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE      (MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE       (1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED        (1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM        (1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS           (1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE      (1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED       (1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM       (1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS          (1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC      (max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC     (max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar  EQU NEAR PTR
ELSE
DebFar  EQU SHORT
ENDIF
*/

#ifndef Not_VxD

/******************************************************************************
 *
 *           EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.  Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000      /* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT     0x0001      /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.  Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE       0x0002      /* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT     0x0003      /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */   
#define SYS_VM_TERMINATE    0x0004      /* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT     0x0005      /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.  SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006      /* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM       0x0007

/*
 *  Second phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT         0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE        0x000A      /* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B      /* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.  EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM      0x000C      /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00        /* VM was crashed */
#define VNE_CRASHED     (1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT       0x01        /* VM was destroyed while active */
#define VNE_NUKED       (1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02        /* Some device failed Create_VM */
#define VNE_CREATEFAIL      (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03        /* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL      (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04        /* Some device failed VM_Init */
#define VNE_INITFAIL        (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT      0x05
#define VNE_CLOSED      (1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND      0x000D      /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME       0x000E      /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.  Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012      /* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY       0x0013      /* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY     0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP        0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT      0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP      0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY    0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *        CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT     0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD  0x001D

/*
 *  Second phase of creating a thread.  EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT    0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 * BUGBUG: need more doc here, describing the interface
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN       DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2        0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2       0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2     0x0029
#define VM_SUSPEND2     0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2     0x002C
#define DEVICE_REBOOT_NOTIFY2   0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER  0x0030

#define KERNEL32_INITIALIZED    0x0031

#define KERNEL32_SHUTDOWN       0x0032

#define MAX_SYSTEM_CONTROL  0x0032

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL	0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

                    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
                    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT      0x10000000
                    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
                    /* INIT_COMPLETE is broadcast */
                    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
                    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
                    /* All initialization completed */
                    /* System running normally */
                    /* System shutdown initiated */
                    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
                    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
                    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT      0xE0000000
                    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
                    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
                    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
                    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
                    /* Return to real mode */
                    /* Alternate path: CAD reboot */
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
                    /* DEVICE_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PRECRITREBOOT      0xFFFFF000
                    /* CRIT_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PREREBOOTCPU       0xFFFFFF00
                    /* REBOOT_PROCESSOR is broadcast */
                    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC              ; Used outside this module (default)
;   LOCAL               ; Local to this module
;   HIGH_FREQ           ; DWORD align procedure
;   SERVICE             ; Routine is called via VxDCall
;   ASYNC_SERVICE           ; Same as "SERVICE" plus routine can
;                   ;   be called under interrupt.
;   HOOK_PROC           ; Proc is a handler installed with
;                   ;   with a call to Hook_xxx_Fault
;                   ;   or Hook_Device_Service.  The
;                   ;   following parameter must be
;                   ;   the label of a DWORD location
;                   ;   which will hold the ptr to next
;                   ;   hook proc. e.g.
;
;                  ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG              ; Disable Queue_Out call logging
;   NO_PROFILE          ; Disable DynaLink profile counts
;   NO_TEST_CLD         ; Disable direction flag check
;
;   TEST_BLOCK          ; Trap if in NOBLOCK state
;                   ;  (default if in pageable code seg)
;   TEST_REENTER            ; Trap if Get_VMM_Reenter_Count != 0
;                   ;  (default for non-async services)
;   NEVER_REENTER           ; Trap if VMM has been reentered
;   NOT_SWAPPING            ; Trap if this thread is swapping
;
;   NO_PROLOG           ; Disable all prolog tests
;
;   ESP             ; Use ESP instead of EBP for stack
;                   ;  frame base
;   PCALL               ; pascal calling convention
;   SCALL               ; stdcall calling convention
;   CCALL               ; "C" calling convention
;   ICALL               ; default calling convention
;   W32SVC              ; Win32 service
;
;   segment type            ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type            ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1       ;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed  equ 2       ;; ArgVars were used
??_pf_Entered   equ 4       ;; EnterProc performed
??_pf_Left  equ 8       ;; LeaveProc performed
??_pf_Returned  equ    16               ;; Return performed

??_pushed       =       0               ;; For WIN31COMPAT
??_align    =   0       ;; For WIN31COMPAT
??_ends     equ <>      ;; BeginProc segment

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0            ;; local frame base
    ??_aframe = 0           ;; argument frame base
    ??_initaframe = 0       ;; initial aframe value
    ??_numargs = 0          ;; number of argvars
    ??_numlocals = 0        ;; number of localvars
    ??_numlocalsymbols = 0      ;; number of local symbols
    ??_procflags = 0        ;; misc. Enter/LeaveProc flags
    ??_esp = 0          ;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0           ;; number of bytes pushed
    ??_align = 0            ;; set if proc should be dword aligned
    ??_hook = 0         ;; set if proc is a Hook_Proc
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG        ;; logging on by default
    ??_profile = DFS_PROFILE    ;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD  ;; test that direction is clear
ELSE
    ??_log = 0          ;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE    ;; service profiling on by default
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
    ??_test_cld = 0         ;; test that direction is clear
ENDIF
    ??_might_block = 0      ;; entering fn might cause VM to block
    ??_test_reenter = 0     ;; don't test for VMM reentry
    ??_never_reenter = 0        ;; don't test for genuine VMM reentry
    ??_not_swapping = 0     ;; don't test that we're not swapping
    ??_prolog_disabled = 0      ;; use a prolog by default
    ??_public = 1           ;; everything's public by default
    ??_cleanoff = 0         ;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0          ;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
        if ??_hookarg
        ??_hookarg = 0
        ??_hookvar equ <arg>
        elseifdef ?&&arg&&_BeginProc
            ?&&arg&&_BeginProc
        elseifdef VxD_&&arg&&_CODE_SEG
        ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
        VxD_&&arg&&_CODE_SEG
        else
        .err <Bad param "&arg" to BeginProc>
        endif
    endm

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
	ife ??_service
	    ifndef profileall
	      ??_profile = 0      ;; only services can be profiled
	    endif
	    ifdef VMMSYS
		??_prolog_disabled = 1
	    endif
	else
	    ??_test_cld = DFS_TEST_CLD
	endif       ; ife ??_service

	ife ?_16ICODE
	    ??_prolog_disabled = 1
	else
	ife ?_RCODE             ;; if real-mode code segment
	    ??_prolog_disabled = 1  ;; don't do anything stupid
	else                ;; else protected mode code segment
	    ife ?_PCODE     ;; if swappable code
		??_might_block = DFS_TEST_BLOCK
	    endif
	    if ??_service
		ife ??_async_service
		    ??_test_reenter = DFS_TEST_REENTER
		endif
	    endif
    endif       ; ife ?_RCODE
    endif       ; ife ?_16ICODE
    endif	; Not_VxD

    if ??_esp
	;; just return address on stack
	??_basereg equ <esp+??_pushed>
	??_initaframe = 4
    else
	;; ret addr and EBP on stack
	??_basereg equ <ebp>
	??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
         ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
        ??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

	if ??_hook
	    if ??_align
	    Dword_Align
	    endif
	    prelabeldata:
	    ifndef ??_hookvar
	    .err <HOOK_PROC requires next arg to be name of dword location>
	    endif
	    jmp short Name
	    jmp [??_hookvar]
	    ifdef DEBUG
	    Profile_Data dd  0
	    endif
	    if ??_align
	    .errnz ($ - prelabeldata) mod 4
	    endif
	endif

	ifdef DEBUG
	    ?prolog_&Name label near
	    if (??_service OR ??_profile) AND (??_hook EQ 0)
	    jmp short Name
	    if ??_align
		Dword_Align     ; This also aligns the proc
	    endif           ;   since Profile_Data is a dd

	    IF ?_ICODE
	    ifdef profileall
	      ?ProfileHeader_BeginProc Profile_Data, %@filename
	    else
	      Profile_Data dd 0
	    endif
	    ELSE
	      Profile_Data dd 0
	    ENDIF

	    endif
	endif

	if ??_align
	    Dword_Align
	endif

    endif	; Not_VxD

    Name proc near		;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;       Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall    ;; if no munging
        if ??_public
            public Name
        else
            ifdef DEBUG
                % ?merge @FileName,$,Name,:
                % ?merge public,,,,,@FileName,$,Name
            endif
        endif
    endif
    if ??_ccall
        if ??_public
            _&Name equ Name
	    ifdef Not_VxD
		 public C Name
	    else
                 public _&Name
	    endif
        endif
    endif
    if ??_pcall
        if ??_public
            ?toupper Name
            ?merge  public,,,,%?upper
        endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;       DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service
    ifndef Not_VxD
	ifdef DEBUG
	    if ??_dfs EQ DFS_LOG
		VMMCall Log_Proc_Call   ;; no test, just log
	    else
	    if ??_dfs EQ DFS_TEST_REENTER
		VMMCall Test_Reenter    ;; no log, just reenter
	    else
	    if ??_dfs or ?_LOCKABLECODE eq 0
		ifdef WIN31COMPAT
		    if ??_dfs AND DFS_LOG
			VMMCall Log_Proc_Call
		    endif
		    if ??_dfs AND DFS_TEST_REENTER
			VMMCall Test_Reenter
		    endif
		else
		    ife ?_LOCKABLECODE
		    ifdef ??_debug_flags
			push    ??_debug_flags
			if ??_dfs
			pushfd
			or  dword ptr [esp+4],??_dfs
			popfd
			endif
			VMMCall _Debug_Flags_Service
		    elseif ??_dfs
			push    ??_dfs
			VMMCall _Debug_Flags_Service
		    endif
		    else
		    push    ??_dfs
		    VMMCall _Debug_Flags_Service
		    endif
		endif
	    else
	      ifdef profileall
		IncProfileCount
	      endif
	    endif           ;if ??_dfs
	    endif           ; if ??_dfs EQ DFS_TEST_REENTER
	    endif           ; if ??_dfs EQ DFS_LOG
	endif ; DEBUG
    endif ; Not_VxD

    ;; Phase 7:  Post-label code
    ;;       <none>
endm

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
	.erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
	.erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
        inc dword ptr [??_name-4]
    else
        ifndef profileall
        .err <IncProfileCount can be used only in services.>
        endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***    ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;        of the argument.  The symbols BYTE, WORD, and DWORD
;        are synonyms for 1, 2, and 4 respectively.
;        NB!  All arguments sizes are rounded up to the nearest
;        multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;        to indicate that the argument will not be used
;        by the procedure.
;

ArgVar  macro   name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
        ?mkarg  <name>, <length>, <used>, %??_numargs
    else
        ?argvar <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg  macro   name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
        ?argvar <name>, <length>, <used>
        &endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro   name,length,used
    local   a
    ifidni  <length>,<BYTE>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
        ?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
        a = ??_aframe
        ??_aframe =  ??_aframe + ((length + 3)/4)*4
        ?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

;***    ?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
        name equ _inaccessible_NOTUSED_
    else
        name equ value
        ??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***    LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;        of the argument.  The symbols BYTE, WORD, and DWORD
;        are synonyms for 1, 2, and 4 respectively.
;        NB!  All arguments sizes are rounded up to the nearest
;        multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;        to suppress the usual padding and aligning of variables
;        PACK is typically used when declaring a bunch of
;        byte or word variables.  Make sure that the total
;        size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
        ??_pad = 0
    endif
    ifidni  <length>,<BYTE>
        ??_frame = ??_frame + 1 + 3 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
        ??_frame =  ??_frame + 2 + 2 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
        ??_frame = ??_frame + 4
        a = ??_frame
        ?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
        name equ dword ptr [??_basereg-a]
        name&l equ word ptr [??_basereg-a]
        name&ll equ byte ptr [??_basereg-a]
        name&lh equ byte ptr [??_basereg-a+1]
        name&h equ word ptr [??_basereg-a+2]
        name&hl equ byte ptr [??_basereg-a+2]
        name&hh equ byte ptr [??_basereg-a+3]
    else
        ??_frame =  ??_frame + ((length + 3)/4)*4
        a = ??_frame
        ?deflocal <name>
        name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
        ??_numlocalsymbols = ??_numlocalsymbols + 1
        ?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
        name    equ <__inaccessible__NOTINSCOPE__>
        &endm
    endm
    .xcref  ?dodeflocal

;***    EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
        if ??_public
	    ifdef Not_VxD
                ?merge  %??_name,@,%(??_aframe),,label,near
                ?merge  public,,,,C,%??_name,@,%(??_aframe)
	    else
                ?merge  _,%??_name,@,%(??_aframe),label,near
                ?merge  public,,,,,_,%??_name,@,%(??_aframe)
	    endif
        endif
    endif
    if ??_pcall
        ??_aframe = 0
        ?count = ??_numargs
        rept    ??_numargs
            ?invprg <?MKA>,%?count
            ?count = ?count - 1
        endm
    endif
    ??_fleave = FALSE
    if ??_esp
        if  ??_frame
            sub esp, ??_frame
            ??_pushed = ??_pushed + ??_frame
            ??_fleave = VMM_TRUE
        endif
    else
        if  ??_frame eq 0
            if (??_aframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
                ifdef DEBUG
                    push    ebp
                    mov ebp,esp
                    ??_fleave = VMM_TRUE
                endif
            else
                push    ebp
                mov ebp,esp
                ??_fleave = VMM_TRUE
            endif
        else
            enter   ??_frame, 0
            ??_fleave = VMM_TRUE
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***    LeaveProc - removes stack frame on exit
;
;	NOTE:	If there are localvar and ESP kind of stack frame
;		LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;		flag is given.  PRESERVE_FLAGS generates bigger, slower
;		code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;        the internal stack depth for the local frame.  This is
;        to allow jumping around the LeaveProc/Return to code
;        after the LeaveProc/Return to use args/local variables,
;        but code that uses the stack frame executed after the
;        LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
        if ??_esp
            ifidni <flags>,<PRESERVE_FLAGS>
                lea esp,[esp + ??_frame]
            else
                add esp,??_frame
            endif
        else
            leave
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***    Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return  macro
    if  ??_cleanoff OR ??_w32svc
        if  ??_w32svc AND (??_aframe LT 8)
            ret 8
        else
            ret ??_aframe
        endif
    else
        ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***    EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp           ;; Masm will provide error msg for us
if ??_w32svc
    if ??_aframe lt 8
        cparm&Name equ 0
    else
        cparm&Name equ (??_aframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi  <Flag>,<NOCHECK>
    if ??_pushed ne 0
        %out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
        ife ??_procflags AND ??_pf_Entered
            %out Warning: ArgVar/LocalVar without EnterProc in Name
        endif
        ife ??_procflags AND ??_pf_Left
            %out Warning: ArgVar/LocalVar without LeaveProc in Name
        endif
        ife ??_procflags AND ??_pf_Returned
            %out Warning: ArgVar/LocalVar without Return in Name
        endif
    endif
endif
ifdifi  <Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
        ?count = ?count + 1
        ?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm

;***    cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall   macro   name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <flags>
    call    name
    ClearCParams
    endm
    .xcref  cCall

;***    pCall - pascal call
;
;   Arguments pushed in pascal order, callie cleans stack
;

pCall   macro   name, arglst
    local   ??saved
    ife .TYPE name
        ?toupper name
    else
        ?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
        push    x
        ??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***    sCall - standard call
;
;   Arguments pushed in "C" order, callie cleans stack,
;   @argc appended to name
;

sCall   macro   name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***    iCall - internal routine call
;
;   Set to what every type we what to use as a default.

iCall   equ <sCall>

;***    PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;       the word FAST if we should prefer speed over size
;
;       The default flag is SMALL, unless the current procedure
;       is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF  STANDARD_CCALL
NONSTANDARD_CCALL = 1           ;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    ??_argc = 0         ;; number of dwords on stack (global)
IFDEF   NONSTANDARD_CCALL
    ??_popargs = 0          ;; establish default
ELSE
    ??_popargs = ??_align EQ 0  ;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
        ??_popargs = 1      ;; size, not speed
    elseifidni <flags>, <FAST>
        ??_popargs = 0      ;; speed, not size
    endif

    irp x,<arglst>
        ??_argc = ??_argc + 1
        ?marg   <x>,%??_argc
    endm
    ?count = ??_argc
    rept    ??_argc
        ?invprg <?AM>,%?count
        ?count = ?count - 1
    endm
    endm

;***    ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;	If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;	This will generate bigger, slower code, so use it only when
;	necessary.

ClearCParams macro fPreserveFlags
	if	??_argc ne 0
	    if (??_popargs) AND (??_argc LE 2)
	      rept ??_argc
		pop	ecx
	      endm
	    else
	      ifidni <fPreserveFlags>, <PRESERVE_FLAGS>
		lea	esp, [esp][??_argc * 4]
	      else
		add	esp,??_argc * 4
	      endif
	    endif
	endif
	??_pushed = ??_pushed - (??_argc * 4)
	endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg   macro   name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
        push    name
        ??_pushed = ??_pushed + 4
        &endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro   name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall  macro   name1, name2
    CondExtern _&name1&@&name2, near
    call    _&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge  macro   l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
        if '&x' GE 'a'
          if '&x' LE 'z'
        ?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
        ?upper catstr ?upper,?t1
          else
        ?upper catstr ?upper,<&x>
          endif
        else
          ?upper catstr ?upper,<&x>
        endif
      endm
    endm
    .xcref

;***    CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
        ifndef name
        externdef name:dist
        endif
    else
        if2
        ifndef name
            extrn name:dist
        endif
        endif
    endif
endm

;***    SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro   reglist         ;; push those registers
    irp reg,<reglist>
        ifidni <reg>, <fd>
            pushfd
            ??_pushed = ??_pushed + 4
        else
        ifidni <reg>, <ad>
            pushad
            ??_pushed = ??_pushed + SIZE Pushad_Struc
        else
            push    reg
            ??_pushed = ??_pushed + 4
        endif
        endif
    endm
endm

;***    RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist    ;; pop those registers
    irp reg,<reglist>
        ifidni <reg>, <fd>
            popfd
            ??_pushed = ??_pushed - 4
        else
        ifidni <reg>, <ad>
            popad
            ??_pushed = ??_pushed - SIZE Pushad_Struc
        else
            pop reg
            ??_pushed = ??_pushed - 4
        endif
        endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.  Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db  'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd  OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd  0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *         S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST    0x00000010
#define HIGH_PRI_DEVICE_BOOST   0x00001000
#define CRITICAL_SECTION_BOOST  0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT        0
#define PEF_WAIT_FOR_STI        (1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT       1
#define PEF_WAIT_NOT_CRIT       (1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT        2
#define PEF_DONT_UNBOOST        (1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT        3
#define PEF_ALWAYS_SCHED        (1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT        4
#define PEF_TIME_OUT            (1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT     (1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT    6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT      7
#define PEF_WAIT_IN_PM          (1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT        8
#define PEF_THREAD_EVENT        (1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT         10
#define PEF_RING0_EVENT         (1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	    11
#define PEF_WAIT_CRIT		(1 << PEF_WAIT_CRIT_BIT)

#define PEF_WAIT_CRIT_VM_BIT	    12
#define PEF_WAIT_CRIT_VM	(1 << PEF_WAIT_CRIT_VM_BIT)

#define PEF_PROCESS_LAST_BIT	    13
#define PEF_PROCESS_LAST	(1 << PEF_PROCESS_LAST_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT       PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK     PEF_WAIT_NOT_NESTED_EXEC


/******************************************************************************
 *       F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *                           E N T E R _ M U T E X
 *             A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT      0
#define BLOCK_SVC_INTS          (1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT    1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT       2
#define BLOCK_ENABLE_INTS       (1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT          3
#define BLOCK_POLL          (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT           4
#define BLOCK_THREAD_IDLE               (1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT        5
#define BLOCK_FORCE_SVC_INTS		(1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;           /* Client's EDI */
    ULONG Client_ESI;           /* Client's ESI */
    ULONG Client_EBP;           /* Client's EBP */
    ULONG Client_res0;          /* ESP at pushall */
    ULONG Client_EBX;           /* Client's EBX */
    ULONG Client_EDX;           /* Client's EDX */
    ULONG Client_ECX;           /* Client's ECX */
    ULONG Client_EAX;           /* Client's EAX */
    ULONG Client_Error;         /* Dword error code */
    ULONG Client_EIP;           /* EIP */
    USHORT Client_CS;           /* CS */
    USHORT Client_res1;         /*   (padding) */
    ULONG Client_EFlags;        /* EFLAGS */
    ULONG Client_ESP;           /* ESP */
    USHORT Client_SS;           /* SS */
    USHORT Client_res2;         /*   (padding) */
    USHORT Client_ES;           /* ES */
    USHORT Client_res3;         /*   (padding) */
    USHORT Client_DS;           /* DS */
    USHORT Client_res4;         /*   (padding) */
    USHORT Client_FS;           /* FS */
    USHORT Client_res5;         /*   (padding) */
    USHORT Client_GS;           /* GS */
    USHORT Client_res6;         /*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;           /* Client's DI */
    USHORT Client_res13;        /*   (padding) */
    USHORT Client_SI;           /* Client's SI */
    USHORT Client_res14;        /*   (padding) */
    USHORT Client_BP;           /* Client's BP */
    USHORT Client_res15;        /*   (padding) */
    ULONG Client_res16;         /* ESP at pushall */
    USHORT Client_BX;           /* Client's BX */
    USHORT Client_res17;        /*   (padding) */
    USHORT Client_DX;           /* Client's DX */
    USHORT Client_res18;        /*   (padding) */
    USHORT Client_CX;           /* Client's CX */
    USHORT Client_res19;        /*   (padding) */
    USHORT Client_AX;           /* Client's AX */
    USHORT Client_res20;        /*   (padding) */
    ULONG Client_res21;         /* Dword error code */
    USHORT Client_IP;           /* Client's IP */
    USHORT Client_res22;        /*   (padding) */
    ULONG Client_res23;         /* CS */
    USHORT Client_Flags;        /* Client's flags (low) */
    USHORT Client_res24;        /*   (padding) */
    USHORT Client_SP;           /* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];      /* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;            /* Client's BL */
    UCHAR Client_BH;            /* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;            /* Client's DL */
    UCHAR Client_DH;            /* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;            /* Client's CL */
    UCHAR Client_CH;            /* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;            /* Client's AL */
    UCHAR Client_AH;            /* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc       CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0   /* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT   0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;	Declare services as conforming to the C calling convention
;	for parameter-passing, but *not* conforming to the C calling
;	convention for register usage.
;
;	Services which do not use the C calling convention for
;	parameter-passing need not be declared as nonstandard.
;
;	arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
	irp	x,<arglst>
	    ??_nonstandardccall_&x = 1
	endm
endm

;
; The following VMM services are nonstandard:
;       _BlockOnID and _LocalizeSprintf modify no registers except flags.
;       _SetLastV86Page modifies no registers except EAX and flags.
;       _Assert_Range returns information in flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page, _Assert_Range>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints      ; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd  OFFSET32 vt[sn+jf]
ENDM

GenDD   MACRO   P, vid, snum, jflag
    LOCAL   vtable
IFDEF   @@VxDName&vid
    Deftable    vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd  @@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_nonstandardccall_&P
    PushCParams <Param>, <FAST>
    else
    PushCParams <Param>, <flags>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
    else
	ClearCParams
    endif
    ENDM

VxDJmp  MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG   defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG    defines start of always present code segment
;VxD_CODE_ENDS   defines end of always present code segment
;VxD_DATA_SEG    defines start of always present data segment
;VxD_DATA_ENDS   defines end of always present data segment
;VxD_LOCKED_CODE_SEG    defines start of always present code segment
;VxD_LOCKED_CODE_ENDS   defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG  defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG    EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS   EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT   ENDS
        ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT   ENDS
        ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
        ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
        ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT  ENDS
        ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG    EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS   EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA   ENDS
        ENDM


;   Protected mode initialization data

VxD_IDATA_SEG   MACRO
_IDATA  SEGMENT
        ENDM
VxD_IDATA_ENDS  MACRO
_IDATA  ENDS
        ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA   ENDS
        ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT   ENDS
        ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA   ENDS
        ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
        ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
          ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
           ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
          ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
           ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A           /* 3.10 */
#else  /* WIN31COMPAT */
#define DDK_VERSION 0x400           /* 4.00 */
#endif

#endif

struct VxD_Desc_Block {
    ULONG DDB_Next;         /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;     /* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;           /* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];          /* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;       /* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;     /* Offset of control procedure */
    ULONG DDB_V86_API_Proc;     /* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;      /* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;     /* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;      /* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;       /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;         /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Size;		/* INIT <SIZE(VxD_Desc_Block)> Reserved */
    ULONG DDB_Reserved1;        /* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;        /* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;        /* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block       *PVMMDDB;
typedef PVMMDDB             *PPVMMDDB;

#ifndef Not_VxD

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE      (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE        (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT      14
#define DDB_HAS_WIN32_SVCS      (1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT     15
#define DDB_DYNAMIC_VXD         (1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED       (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB    <Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
        Ref_Data_Offset EQU 0
ELSE
        Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db  0dh, 0ah, 'D_E_B_U_G===>'
        db      "&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
             OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
             ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,   MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd  OFFSET32 ??_cd_&&num
ELSE
    dd  OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc             ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz  Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT    0x014

#define OUTPUT_BIT  2
#define OUTPUT      (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT    4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT   5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO      (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT  7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT  8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT    0x10            /* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je  Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb  In_Proc
ELSE
    je  Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw  Table_Name&_Entries
ELSE
    dw  ?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw  Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6    ; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw  Port
    dd  OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
        ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;          If compiled with debugging then this will generate a call
;          followed by a return.  If non-debugging version then the
;          specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF   DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint  MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
        VMMCall _ExecVxDIntMustComplete
    ENDM


*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0   /* loaded */
#define DUPLICATE_DEVICE_ID     (1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1   /* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F        (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT      2   /* in the INT 2F device list */
#define LOADING_FROM_INT2F      (1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK      0   /* load protected mode portion */
#define ABORT_DEVICE_LOAD   1   /* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2   /* fatal-error: abort load of Win386 */



#define NO_FAIL_MESSAGE_BIT 15  /* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0   /* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING  1   /* search for next string */
#define LDRSRV_RESERVED         2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3   /* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT  4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5   /* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6   /* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO      7   /* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey       0x100
#define LDRSRV_RegCreateKey     0x101
#define LDRSRV_RegCloseKey      0x102
#define LDRSRV_RegDeleteKey     0x103
#define LDRSRV_RegSetValue      0x104
#define LDRSRV_RegQueryValue        0x105
#define LDRSRV_RegEnumKey       0x106
#define LDRSRV_RegDeleteValue       0x107
#define LDRSRV_RegEnumValue     0x108
#define LDRSRV_RegQueryValueEx      0x109
#define LDRSRV_RegSetValueEx        0x10A
#define LDRSRV_RegFlushKey      0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT        1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED      2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE        3   /* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*           Also Init type objects should be added to the second part of the
*           list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ       -1

#define LCODE_OBJ       0x01
#define LDATA_OBJ       0x02
#define PCODE_OBJ       0x03
#define PDATA_OBJ       0x04
#define SCODE_OBJ       0x05
#define SDATA_OBJ       0x06
#define CODE16_OBJ      0x07
#define LMSG_OBJ        0x08
#define PMSG_OBJ        0x09

#define	DBOC_OBJ	0x0B
#define	DBOD_OBJ	0x0C

#define ICODE_OBJ       0x11
#define IDATA_OBJ       0x12
#define ICODE16_OBJ     0x13
#define IMSG_OBJ        0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  25

/*****************************************************************************
 *
 *      Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT      0   /* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT      1   /* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT      2   /* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT      3   /* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT      4   /* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT      31  /* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT      0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT      2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT      4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT      6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT      7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT      8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT      9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT      10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT      11  /* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT      14  /* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT      16  /* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT      17  /* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT      18  /* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19  /* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20  /* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *              PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE      0x1000      /* page size */

/******************************************************************************
 *
 *              PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES      (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER      (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC       (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM       0
#define PG_SYS      1
#define PG_RESERVED1    2
#define PG_PRIVATE  3
#define PG_RESERVED2    4
#define PG_RELOCK   5       /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES      0x080       /* present in memory */
#define D_NOTPRES   0       /* not present in memory */

#define D_DPL0      0       /* Ring 0 */
#define D_DPL1      0x020       /* Ring 1 */
#define D_DPL2      0x040       /* Ring 2 */
#define D_DPL3      0x060       /* Ring 3 */

#define D_SEG       0x010       /* Segment descriptor */
#define D_CTRL      0       /* Control descriptor */

#define D_GRAN_BYTE 0x000       /* Segment length is byte granular */
#define D_GRAN_PAGE 0x080       /* Segment length is page granular */
#define D_DEF16     0x000       /* Default operation size is 16 bits */
#define D_DEF32     0x040       /* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE      0x08        /* code */
#define D_DATA      0       /* data */

#define D_X     0       /* if code, exec only */
#define D_RX        0x02        /* if code, readable */
#define D_C     0x04        /* if code, conforming */

#define D_R     0       /* if data, read only */
#define D_W     0x02        /* if data, writable */
#define D_ED        0x04        /* if data, expand down */

#define D_ACCESSED  1       /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE    (D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK   0xFFF8      /* selector index */
#define SEL_LOW_MASK    0xF8        /* mask for low byte of sel indx */
#define TABLE_MASK  0x04        /* table bit */
#define RPL_MASK    0x03        /* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()    {__asm cli}

#define SAVE_FLAGS(flags) \
    __asm pushfd \
    __asm pop flags

#define RESTORE_FLAGS(flags) \
    __asm push flags \
    __asm popfd

#define IO_Delay() \
    __asm _emit 0xeb \
    __asm _emit 0x00

#define Touch_Register(Register) _asm xor Register, Register

typedef DWORD   HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)  // turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;      // count of milliseconds

#pragma warning (default:4209)  // turn on redefine warning (with basedef.h)

typedef DWORD   VMM_SEMAPHORE;

#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMMREG.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *   Title:	VMMREG.H - Include file for VMM/Loader Registry Services
 *
 *   Version:	1.00
 *
 ******************************************************************************
 */

#ifndef	_VMMREG_H
#define _VMMREG_H

typedef DWORD	VMMHKEY;
typedef	VMMHKEY	*PVMMHKEY;
typedef DWORD	VMMREGRET;			// return type for the REG Functions

#define	MAX_VMM_REG_KEY_LEN	256	// includes the \0 terminator

#ifndef REG_SZ		// define only if not there already

#define REG_SZ		0x0001
#define REG_BINARY	0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE	// define only if not there already

#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA			0x80000006

#endif


// ERROR CODES returned by Registry
// NOTE THAT THESE ARE ALSO DEFINED IN WINERROR.H 
// and so VMMREG.H should be included after WINERROR.H

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND             2L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

// END ERROR CODES

/*XLATOFF*/
#ifndef Not_VxD

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

struct val_context {
    int valuelen;		// the total length of this value
    PVOID value_context;	// provider's context
    PVOID val_buff_ptr;	// where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalue {		      // Provider supplied value/context.
    PCHAR pv_valuename;          // The value name pointer
    DWORD pv_valuelen;
    PVOID pv_value_context;
    DWORD pv_type;
}PVALUE;

typedef struct pvalue *PPVALUE;

typedef VMMREGRET (_cdecl *PQUERYHANDLER)(PVOID pvKeyContext, PVALCONTEXT pvalcontextValues, DWORD cvalcontextValues, PVOID pbData, DWORD * pcbData, DWORD dwReserved);

#define PROVIDER_KEEPS_VALUE_LENGTH	0x1
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;		// Only PROVIDER_KEEPS_VALUE_LENGTH for now.
}PROVIDER;

typedef PROVIDER *PPROVIDER;

struct value_ent {
    PCHAR ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
};

typedef struct value_ent VALENT;
typedef VALENT *PVALENT;

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#ifndef WIN31COMPAT

#pragma warning (disable:4035)		// turn off no return code warning

#ifndef	WANTVXDWRAPS



VMMREGRET VXDINLINE
VMM_RegOpenKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegOpenKey);
    _asm add  esp, 3*4
}

VMMREGRET VXDINLINE
VMM_RegCloseKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCloseKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegCreateKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateKey);
    _asm add  esp, 3*4
}


VMMREGRET VXDINLINE
VMM_RegCreateDynKey(PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push cpvalueValueInfo
    _asm push ppvalueValueInfo
    _asm push pprovHandlerInfo
    _asm push pvKeyContext
    _asm push lpszSubKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateDynKey);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegQueryMultipleValues (VMMHKEY hKey, PVOID val_list, DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize)
{
    _asm push ldwTotsize
    _asm push lpValueBuf
    _asm push num_vals
    _asm push val_list
    _asm push hKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryMultipleValues);
    _asm add  esp, 5*4
}

VMMREGRET VXDINLINE
VMM_RegDeleteKey(VMMHKEY hkey, PCHAR lpszSubKey)
{
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteKey);
    _asm add  esp, 2*4
}

VMMREGRET VXDINLINE
VMM_RegEnumKey(VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName)
{
    _asm push cchName
    _asm push lpszName
    _asm push iSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumKey);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValue(VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue)
{
    _asm push lpcbValue
    _asm push lpszValue
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValue);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValue(VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData)
{
    _asm push cbData
    _asm push lpszData
    _asm push fdwType
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValue);
    _asm add  esp, 5*4 
}

VMMREGRET VXDINLINE
VMM_RegDeleteValue(VMMHKEY hkey, PCHAR lpszValue)
{
    _asm push lpszValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteValue);
    _asm add  esp, 2*4 
}

VMMREGRET VXDINLINE
VMM_RegEnumValue(VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpcbValue
    _asm push lpszValue
    _asm push iValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumValue);
    _asm add  esp, 8*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValueEx(VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValueEx);
    _asm add  esp, 6*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValueEx(VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PBYTE lpbData, DWORD cbData)
{
    _asm push cbData
    _asm push lpbData
    _asm push fdwType
    _asm push dwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValueEx);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegFlushKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegFlushKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryInfoKey(VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, 
PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime)
{
    _asm push lpftLastWriteTime
    _asm push lpcbSecurityDesc
    _asm push lpcbMaxValueData
    _asm push lpcchMaxValueName
    _asm push lpcValues
    _asm push lpcchMaxClass
    _asm push lpcchMaxSubKey
    _asm push lpcSubKeys
    _asm push lpdwReserved
    _asm push lpcchClass
    _asm push lpszClass
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryInfoKey);
    _asm add  esp, 12*4 
}

#endif	// WANTVXDWRAPS

#pragma warning (default:4035)		// turn on no return code warning

#endif // WIN31COMPAT

#endif // Not_VxD

/*XLATON*/

/* ASM
;**************************************************************
; Macros for Realmode loader registry Services
;
;**************************************************************
LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue		; lpszValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4		; for 8 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
*/
#endif		/* _VMMREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMMTYPES.H ===
/*************************************************************************************
*
*	File: vmmtypes.h
*
*	Revision History:
*		Jeff Westerinen (jsw) - 05/97
*			- Changed QWORD to QUADWORD due to conflict with typedef in basedef.h
*
*************************************************************************************/

#ifndef _VMMTYPES_H_
#define _VMMTYPES_H_

#ifndef NULL
#define NULL               0
#endif
#ifndef VOID
#define VOID               void
#endif
#ifndef PASCAL
#define PASCAL             _pascal
#endif
#ifndef CDECL
#define CDECL              _cdecl
#endif

#ifndef BOOL
#define BOOL                unsigned long
#endif
#ifndef FALSE
#define FALSE              0
#endif
#ifndef TRUE
#define TRUE               (~FALSE)
#endif

#ifndef LONG
#define LONG               long
#endif
typedef unsigned char      BYTE;
typedef unsigned short     WORD;
typedef unsigned long      DWORD;
typedef double             QUADWORD;
typedef unsigned int       UINT;
typedef char *             PSTR;
typedef BYTE *             PBYTE;
typedef int *              PINT;
typedef UINT *             PUINT;
typedef WORD *             PWORD;
typedef DWORD *            PDWORD;
typedef QUADWORD *         PQWORD;

typedef union
{
    QUADWORD Desc64;
    DWORD Desc32[2];
    WORD  Desc16[4];
    BYTE  Desc8[8];
} DESCRIPTOR, *PDESCRIPTOR;

typedef union
{
    QUADWORD HandleAddress;
    struct
    {
        DWORD Handle;
        DWORD Address;
    } ha;
} PAGEALLOC, *PPAGEALLOC;

#ifndef LOBYTE
#define LOBYTE(w)          ((BYTE)(w))
#endif
#ifndef HIBYTE
#define HIBYTE(w)          ((BYTE)(((UINT)(w) >> 8) & 0xFF))
#endif
#ifndef LOWORD
#define LOWORD(l)          ((WORD)(DWORD)(l))
#endif
#ifndef HIWORD
#define HIWORD(l)          ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#endif
#ifndef MAKELONG
#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))
#endif

#endif // _VMMTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VPICD.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

VPICD_STAT_IRET_PENDING	EQU	01H
VPICD_STAT_IRET_PENDING_BIT	EQU	0
VPICD_STAT_IN_SERVICE	EQU	02H
VPICD_STAT_IN_SERVICE_BIT	EQU	1
VPICD_STAT_PHYS_MASK	EQU	04H
VPICD_STAT_PHYS_MASK_BIT	EQU	2
VPICD_STAT_PHYS_IN_SERV	EQU	08H
VPICD_STAT_PHYS_IN_SERV_BIT	EQU	3
VPICD_STAT_VIRT_MASK	EQU	10H
VPICD_STAT_VIRT_MASK_BIT	EQU	4
VPICD_STAT_VIRT_REQ	EQU	20H
VPICD_STAT_VIRT_REQ_BIT	EQU	5
VPICD_STAT_PHYS_REQ	EQU	40H
VPICD_STAT_PHYS_REQ_BIT	EQU	6
VPICD_STAT_VIRT_DEV_REQ	EQU	80H
VPICD_STAT_VIRT_DEV_REQ_BIT	EQU	7
VPICD_STAT_GLOBAL	EQU	100H
VPICD_STAT_GLOBAL_BIT	EQU	8
VPICD_STAT_OWNED_BY_VM	EQU	200H
VPICD_STAT_OWNED_BY_VM_BIT	EQU	9
VPICD_OPT_READ_HW_IRR	EQU	01H
VPICD_OPT_READ_HW_IRR_BIT	EQU	0
VPICD_OPT_CAN_SHARE	EQU	02H
VPICD_OPT_CAN_SHARE_BIT	EQU	1
VPICD_OPT_REF_DATA	EQU	04H
VPICD_OPT_REF_DATA_BIT	EQU	2
VPICD_OPT_VIRT_INT_REJECT	EQU	10H
VPICD_OPT_VIRT_INT_REJECT_BIT	EQU	4
VPICD_OPT_SHARE_PMODE_ONLY	EQU	20H
VPICD_OPT_SHARE_PMODE_ONLY_BIT	EQU	5
VPICD_OPT_ALL	EQU	3FH
VPICD_FDO_NO_CONTENTION	EQU	10000H
VPICD_FDO_NO_CONTENTION_BIT	EQU	16
VPICD_FDO_FAVOR_FOCUS	EQU	20000H
VPICD_FDO_FAVOR_FOCUS_BIT	EQU	17

VPICD_IRQ_Descriptor	STRUC
VID_IRQ_Number	DW	?
VID_Options	DW	0
VID_Hw_Int_Proc	DD	?
VID_Virt_Int_Proc	DD	0
VID_EOI_Proc	DD	0
VID_Mask_Change_Proc	DD	0
VID_IRET_Proc	DD	0
VID_IRET_Time_Out	DD	500
VID_Hw_Int_Ref	DD	?
VPICD_IRQ_Descriptor	ENDS
Begin_Service_Table VPICD
VPICD_Service	 VPICD_Get_Version, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Virtualize_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Set_Int_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Clear_Int_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Phys_EOI, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Complete_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Test_Phys_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Physically_Mask, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Physically_Unmask, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Set_Auto_Masking, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_IRQ_Complete_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_Handle_To_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_IRQ_To_Int, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_Int_To_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Call_When_Hw_Int, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Force_Default_Owner, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Force_Default_Behavior, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Auto_Mask_At_Inst_Swap
VPICD_Service	 VPICD_Begin_Inst_Page_Swap
VPICD_Service	 VPICD_End_Inst_Page_Swap
VPICD_Service	 VPICD_Virtual_EOI, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Virtualization_Count
VPICD_Service	 VPICD_Post_Sys_Critical_Init, LOCAL
VPICD_Service	 VPICD_VM_SlavePIC_Mask_Change, VxD_LOCKED_CODE
End_Service_Table VPICD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VPICD.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/******************************************************************************
 *
 *   Title:	VPICD.H - Include file for Virtual PIC Device
 *
 *   Version:	3.10
 *
 ******************************************************************************/

/*INT32*/

// Equates for result from VPICD_Get_Status

#define	VPICD_STAT_IRET_PENDING     	0x01
#define	VPICD_STAT_IRET_PENDING_BIT 	0
#define	VPICD_STAT_IN_SERVICE	    	0x02
#define	VPICD_STAT_IN_SERVICE_BIT   	1
#define	VPICD_STAT_PHYS_MASK	    	0x04
#define	VPICD_STAT_PHYS_MASK_BIT    	2
#define	VPICD_STAT_PHYS_IN_SERV     	0x08
#define	VPICD_STAT_PHYS_IN_SERV_BIT 	3
#define	VPICD_STAT_VIRT_MASK	    	0x10
#define	VPICD_STAT_VIRT_MASK_BIT    	4
#define	VPICD_STAT_VIRT_REQ	    	0x20
#define	VPICD_STAT_VIRT_REQ_BIT     	5
#define	VPICD_STAT_PHYS_REQ	    	0x40
#define	VPICD_STAT_PHYS_REQ_BIT     	6
#define	VPICD_STAT_VIRT_DEV_REQ     	0x80
#define	VPICD_STAT_VIRT_DEV_REQ_BIT 	7
#define VPICD_STAT_GLOBAL		0x100
#define VPICD_STAT_GLOBAL_BIT		8
#define VPICD_STAT_OWNED_BY_VM		0x200
#define VPICD_STAT_OWNED_BY_VM_BIT	9

// Equates for options in IRQ Descriptor

#define	VPICD_OPT_READ_HW_IRR	    	0x01
#define	VPICD_OPT_READ_HW_IRR_BIT   	0
#define	VPICD_OPT_CAN_SHARE	    	0x02
#define	VPICD_OPT_CAN_SHARE_BIT		1
#define	VPICD_OPT_REF_DATA	    	0x04		// new for 4.0
#define	VPICD_OPT_REF_DATA_BIT		2
#define	VPICD_OPT_VIRT_INT_REJECT    	0x10		// new for 4.0
#define VPICD_OPT_VIRT_INT_REJECT_BIT	4
#define VPICD_OPT_SHARE_PMODE_ONLY	0x20		// new for 4.0
#define VPICD_OPT_SHARE_PMODE_ONLY_BIT	5
#define VPICD_OPT_ALL			0x3F		// Internal use

// Equates for VPICD_Force_Default_Owner service.  Flags passed in high word
// of IRQ number

#define VPICD_FDO_NO_CONTENTION 	0x10000 	// new for 4.0
#define VPICD_FDO_NO_CONTENTION_BIT	16
#define VPICD_FDO_FAVOR_FOCUS		0x20000 	// new for 4.0
#define VPICD_FDO_FAVOR_FOCUS_BIT	17

typedef struct VPICD_IRQ_Descriptor {
    USHORT VID_IRQ_Number;
    USHORT VID_Options;			// INIT<0>
    ULONG VID_Hw_Int_Proc;
    ULONG VID_Virt_Int_Proc;		// INIT<0>
    ULONG VID_EOI_Proc;			// INIT<0>
    ULONG VID_Mask_Change_Proc;		// INIT<0>
    ULONG VID_IRET_Proc;		// INIT<0>
    ULONG VID_IRET_Time_Out;		// INIT<500>
    ULONG VID_Hw_Int_Ref;		// new for 4.0
} VID;

typedef VID *PVID;
typedef ULONG HIRQ;			// IRQ Handle

/*XLATOFF*/
#define	VPICD_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VPICD)

VPICD_Service	(VPICD_Get_Version, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Virtualize_IRQ, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Set_Int_Request, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Clear_Int_Request, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Phys_EOI, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Get_Complete_Status, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Get_Status, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Test_Phys_Request, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Physically_Mask, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Physically_Unmask, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Set_Auto_Masking, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Get_IRQ_Complete_Status, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Convert_Handle_To_IRQ, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Convert_IRQ_To_Int, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Convert_Int_To_IRQ, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Call_When_Hw_Int, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Force_Default_Owner, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Force_Default_Behavior, VxD_LOCKED_CODE)

VPICD_Service	(VPICD_Auto_Mask_At_Inst_Swap)
VPICD_Service	(VPICD_Begin_Inst_Page_Swap)
VPICD_Service	(VPICD_End_Inst_Page_Swap)
VPICD_Service	(VPICD_Virtual_EOI, VxD_LOCKED_CODE)	// 4.0 service
VPICD_Service	(VPICD_Get_Virtualization_Count)
VPICD_Service	(VPICD_Post_Sys_Critical_Init, LOCAL)
VPICD_Service	(VPICD_VM_SlavePIC_Mask_Change, VxD_LOCKED_CODE)

End_Service_Table(VPICD)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning
#pragma warning (disable:4035)		// turn off no return code warning

/*
 *  This function is a macro for efficiency.  The parameters passed are
 *  the variables the version (USHORT), flags (ULONG), and maximum IRQ
 *  number (ULONG) are put.
 *
 */

#define	VPICD_Get_Version(ver, fl, cMaxIRQ) \
{ \
    VxDCall(VPICD_Get_Version) \
    __asm xchg [ver],ax \
    __asm xchg [fl],ebx \
    __asm xchg [cMaxIRQ],ecx \
}

//HIRQ static __inline
HIRQ static
VPICD_Virtualize_IRQ(PVID pvid)
{
    __asm {
	mov edi,[pvid]
	VxDCall(VPICD_Virtualize_IRQ)
    	jnc short vvi10
    	xor eax,eax
    vvi10:
    }
}

void static __inline
VPICD_Set_Int_Request(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Set_Int_Request)
}

void static __inline 
VPICD_Clear_Int_Request(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Clear_Int_Request)
}

void static __inline
VPICD_Phys_EOI(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Phys_EOI)
}

ULONG static __inline
VPICD_Get_Complete_Status(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Get_Complete_Status)
    __asm xchg eax,ecx			// trashed ECX for compiler
}

ULONG static __inline
VPICD_Get_Status(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Get_Status)
    __asm xchg eax,ecx			// trashed ECX for compiler
}

ULONG static __inline
VPICD_Test_Phys_Request(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Test_Phys_Request)
    __asm sbb eax,eax			// EAX == 0, interrupt request clear
}

void static __inline
VPICD_Physically_Mask(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Physically_Mask)
}

void static __inline
VPICD_Physically_Unmask(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Physically_Unmask)
}

void static __inline
VPICD_Set_Auto_Masking(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Set_Auto_Masking)
}

ULONG static __inline
VPICD_Get_IRQ_Complete_Status(ULONG irqn)
{
    __asm xor ecx,ecx
    __asm mov eax,[irqn]
    VxDCall(VPICD_Get_IRQ_Complete_Status)
    __asm xchg eax,ecx			// trashed ECX for compiler
}

ULONG static __inline
VPICD_Convert_Handle_To_IRQ(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Convert_Handle_To_IRQ)
    __asm xchg eax,esi			// trashed ESI for compiler
}

ULONG static __inline
VPICD_Convert_IRQ_To_Int(ULONG irqn, HVM hvm)
{
    __asm {
	mov eax,[irqn]
	mov ebx,[hvm]
	VxDCall(VPICD_Convert_IRQ_To_Int)
	jnc short cii10
	xor eax,eax		// returns 0 if invalid IRQ number
    cii10:
    }
}

ULONG static __inline
VPICD_Convert_Int_To_IRQ(ULONG intn)
{
    __asm {
	mov eax,[intn]
        VxDCall(VPICD_Convert_Int_To_IRQ)
	jnc short cii10
	xor eax,eax
	dec eax			// returns -1 if vector not mapped to any IRQ
    cii10:
    }
}

PFN static __inline
VPICD_Call_When_Hw_Int(PFN pfn)
{
    __asm mov esi,[pfn]
    VxDCall(VPICD_Call_When_Hw_Int)
    __asm mov eax,esi
}

ULONG static __inline
VPICD_Force_Default_Owner(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Force_Default_Owner)
    __asm cmc
    __asm sbb eax,eax		// EAX != 0 success, EAX == 0 failure
}

void static __inline
VPICD_Force_Default_Behavior(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Force_Default_Behavior)
}

ULONG static __inline
VPICD_Auto_Mask_At_Inst_Swap(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Auto_Mask_At_Inst_Swap)
    __asm cmc
    __asm sbb eax,eax		// EAX != 0 success, EAX == 0 failure
}

void static __inline
VPICD_Begin_Inst_Page_Swap(void)
{
    VxDCall(VPICD_Begin_Inst_Page_Swap)
}

void static __inline
VPICD_End_Inst_Page_Swap(void)
{
    VxDCall(VPICD_End_Inst_Page_Swap)
}

ULONG static __inline
VPICD_Get_Virtualization_Count(ULONG intn)
{
    _asm mov	eax,[intn]
    VxDCall(VPICD_Get_Virtualization_Count)
}

#pragma warning (default:4035)		// turn on no return code warning

/*XLATON*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VWIN32.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/******************************************************************************
 *
 *   Title:	vwin32.h
 *
 *   Version:	4.00
 *
 ******************************************************************************/

/*INT32*/

#ifndef Not_VxD

/*XLATOFF*/
#define VWIN32_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VWIN32)

VWIN32_Service	(VWIN32_Get_Version, LOCAL)
VWIN32_Service	(VWIN32_DIOCCompletionRoutine, LOCAL)
VWIN32_Service	(_VWIN32_QueueUserApc)
VWIN32_Service	(_VWIN32_Get_Thread_Context)
VWIN32_Service	(_VWIN32_Set_Thread_Context)
VWIN32_Service	(_VWIN32_CopyMem, LOCAL)
VWIN32_Service	(_VWIN32_Npx_Exception)
VWIN32_Service	(_VWIN32_Emulate_Npx)
VWIN32_Service	(_VWIN32_CheckDelayedNpxTrap)
VWIN32_Service	(VWIN32_EnterCrstR0)
VWIN32_Service	(VWIN32_LeaveCrstR0)
VWIN32_Service	(_VWIN32_FaultPopup)
VWIN32_Service	(VWIN32_GetContextHandle)
VWIN32_Service	(VWIN32_GetCurrentProcessHandle, LOCAL)
VWIN32_Service	(_VWIN32_SetWin32Event)
VWIN32_Service	(_VWIN32_PulseWin32Event)
VWIN32_Service	(_VWIN32_ResetWin32Event)
VWIN32_Service	(_VWIN32_WaitSingleObject)
VWIN32_Service	(_VWIN32_WaitMultipleObjects)
VWIN32_Service	(_VWIN32_CreateRing0Thread)
VWIN32_Service	(_VWIN32_CloseVxDHandle)
VWIN32_Service	(VWIN32_ActiveTimeBiasSet, LOCAL)
VWIN32_Service	(VWIN32_GetCurrentDirectory, LOCAL)
VWIN32_Service	(VWIN32_BlueScreenPopup)
VWIN32_Service	(VWIN32_TerminateApp)
VWIN32_Service	(_VWIN32_QueueKernelAPC)
VWIN32_Service	(VWIN32_SysErrorBox)
VWIN32_Service	(_VWIN32_IsClientWin32)
VWIN32_Service	(VWIN32_IFSRIPWhenLev2Taken, LOCAL)

End_Service_Table(VWIN32)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning
/*XLATON*/

#endif // Not_VxD

//
// structure for VWIN32_SysErrorBox
//

typedef struct vseb_s {
    DWORD vseb_resp;
    WORD vseb_b3;
    WORD vseb_b2;
    WORD vseb_b1;
    DWORD vseb_pszCaption;
    DWORD vseb_pszText;
} VSEB;

typedef VSEB *PVSEB;

// VWIN32_QueueKernelAPC flags

#define KERNEL_APC_IGNORE_MC 		0x00000001
#define KERNEL_APC_STATIC 		0x00000002
#define	KERNEL_APC_WAKE			0x00000004

// for DeviceIOControl support
// On a DeviceIOControl call vWin32 will pass following parameters to
// the Vxd that is specified by hDevice. hDevice is obtained thru an
// earlier call to hDevice = CreateFile("\\.\vxdname", ...);
// ESI = DIOCParams STRUCT (defined below)
typedef struct DIOCParams	{
	DWORD	Internal1;		// ptr to client regs
	DWORD	VMHandle;		// VM handle
	DWORD	Internal2;		// DDB
	DWORD	dwIoControlCode;
	DWORD	lpvInBuffer;
	DWORD	cbInBuffer;
	DWORD	lpvOutBuffer;
	DWORD	cbOutBuffer;
	DWORD	lpcbBytesReturned;
	DWORD	lpoOverlapped;
	DWORD	hDevice;
	DWORD	tagProcess;
} DIOCPARAMETERS;

typedef DIOCPARAMETERS *PDIOCPARAMETERS;

// dwIoControlCode values for vwin32's DeviceIOControl Interface
// all VWIN32_DIOC_DOS_ calls require lpvInBuffer abd lpvOutBuffer to be
// struct * DIOCRegs
#define	VWIN32_DIOC_GETVERSION DIOC_GETVERSION
#define	VWIN32_DIOC_DOS_IOCTL	1
#define	VWIN32_DIOC_DOS_INT25	2
#define	VWIN32_DIOC_DOS_INT26	3
#define	VWIN32_DIOC_DOS_INT13	4
#define VWIN32_DIOC_SIMCTRLC	5
#define	VWIN32_DIOC_CLOSEHANDLE DIOC_CLOSEHANDLE

// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs	{
	DWORD	reg_EBX;
	DWORD	reg_EDX;
	DWORD	reg_ECX;
	DWORD	reg_EAX;
	DWORD	reg_EDI;
	DWORD	reg_ESI;
	DWORD	reg_Flags;		
} DIOC_REGISTERS;

// if we are not included along with winbase.h
#ifndef FILE_FLAG_OVERLAPPED
  // OVERLAPPED structure for DeviceIOCtl VxDs
  typedef struct _OVERLAPPED {
          DWORD O_Internal;
          DWORD O_InternalHigh;
          DWORD O_Offset;
          DWORD O_OffsetHigh;
          HANDLE O_hEvent;
  } OVERLAPPED;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMMREG.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef	_VMMREG_H
_VMMREG_H	EQU	1
MAX_VMM_REG_KEY_LEN	EQU	256
ifndef REG_SZ
REG_SZ	EQU	0001H
REG_BINARY	EQU	0003H
endif
ifndef HKEY_LOCAL_MACHINE
HKEY_CLASSES_ROOT	EQU	80000000H
HKEY_CURRENT_USER	EQU	80000001H
HKEY_LOCAL_MACHINE	EQU	80000002H
HKEY_USERS	EQU	80000003H
HKEY_PERFORMANCE_DATA	EQU	80000004H
HKEY_CURRENT_CONFIG	EQU	80000005H
HKEY_DYN_DATA	EQU	80000006H
endif
ifndef ERROR_FILE_NOT_FOUND
ERROR_FILE_NOT_FOUND	EQU	2
endif
ifndef ERROR_BADDB
ERROR_BADDB	EQU	1009
endif
ifndef ERROR_MORE_DATA
ERROR_MORE_DATA	EQU	234
endif
ifndef ERROR_BADKEY
ERROR_BADKEY	EQU	1010
endif
ifndef ERROR_CANTOPEN
ERROR_CANTOPEN	EQU	1011
endif
ifndef ERROR_CANTREAD
ERROR_CANTREAD	EQU	1012
ERROR_CANTWRITE	EQU	1013
endif
ifndef ERROR_REGISTRY_CORRUPT
ERROR_REGISTRY_CORRUPT	EQU	1015
ERROR_REGISTRY_IO_FAILED	EQU	1016
endif
ifndef ERROR_KEY_DELETED
ERROR_KEY_DELETED	EQU	1018
endif
ifndef ERROR_OUTOFMEMORY
ERROR_OUTOFMEMORY	EQU	14
endif
ifndef ERROR_INVALID_PARAMETER
ERROR_INVALID_PARAMETER	EQU	87
endif
ifndef ERROR_LOCK_FAILED
ERROR_LOCK_FAILED	EQU	167
endif
ifndef ERROR_NO_MORE_ITEMS
ERROR_NO_MORE_ITEMS	EQU	259
endif
ifndef  ERROR_SUCCESS
ERROR_SUCCESS	EQU	0
endif




LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4
ENDM

LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4
ENDM

LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4
ENDM

LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4
ENDM

LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4
ENDM

LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4
ENDM

LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4
ENDM

LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4
ENDM

LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,Offc
bData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4
ENDM

LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4
ENDM

LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4
ENDM

LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4
ENDM


endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VPAGED.H ===
#ifndef _VPAGED_H_
#define _VPAGED_H_
/******** Operating System Interface for NVidia Hardware Simulator  ********\
*                                                                           *
* Module: VPAGED.H                                                          *
*       Header file for Virtual Paging device.                              *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)     05/08/95 - wrote it                   *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define PageSwap_Get_Version    0x0000
#define PageSwap_Test_Create    0x0001
#define PageSwap_Create         0x0002
#define PageSwap_Destroy        0x0003
#define PageSwap_In             0x0004
#define PageSwap_Out            0x0005
#define PageSwap_Test_IO_Valid  0x0006
#define PS_Zero_Init_Mask       0x0001
#define PS_Zero_Init_Bit        0x0000
#define PS_Fixed_Page_Mask      0x0008
#define PS_Fixed_Page_Bit       0x0003
#define PS_First_Page_In_Mask   0x0020
#define PS_First_Page_In_Bit    0x0005
#define PS_Dirty_Mask           0x0040
#define PS_Dirty_Bit            0x0006
#define PS_Ever_Dirty_Mask      0x8000
#define PS_Ever_Dirty_Bit       0x000F
#define PS_NoXchg_Mask          0x80000000
#define PS_NoXchg_Bit           0x001F     // DO NOT xchg phys addrs on PageSwap_Out
#define PS_No_Pager             0x01
#define PS_MSDOS_Pager          0x02
#define PS_HW_Pager             0x03
//
// Buffer descriptor for asynchronous I/O
//
#define SIZE_PS_BD_RESERVED     44
struct PageSwapBufferDesc
{
    DWORD PS_BD_Next;
    WORD  PS_BD_List;
    BYTE  PS_BD_Cmd;
    BYTE  PS_BD_Priority;
    DWORD PS_BD_Page_Number;
    DWORD PS_BD_Buffer_Ptr;
    DWORD PS_BD_File_Page;
    DWORD PS_BD_Call_Back;
    BYTE PS_BD_Reserved[SIZE_PS_BD_RESERVED];
};
//
// List values for PS_BD_List
//
#define PS_BDL_Free         1
#define PS_BDL_Pending_WB   2
#define PS_BDL_Submitted_RA 3
#define PS_BDL_Locked       4
#define PS_BDP_Invalid_Data -1
//
// VPAGED callback routines.
//
#pragma aux VPAGED_INT  modify [EAX EBX ECX EDX];
//
// Make functions to these services.
//
DWORD pagerGetVersion(VOID);
BYTE  pagerGetAccessType(VOID);

#pragma aux pagerGetVersion =                                   \
            CALL_VXD(PageSwap_Device_ID, PageSwap_Get_Version)  \
            value [EAX];

#pragma aux pagerGetAccessType =                                \
            CALL_VXD(PageSwap_Device_ID, PageSwap_Get_Version)  \
            value [BL];
#endif // _VPAGED_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\INT2FAPI.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT2FAPI.INC - Windows/386 V86 Application Program Interface
;
;   Version:	3.00
;
;   Date:	10-Mar-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Mar-1989 RAL Original for 3.0
;   07-Apr-1989 RAL Added device broadcast equate
;
;==============================================================================
;
;   For inforamtion on these APIs please refer to the Windows/386 DDK
;   appendix on the Int 2Fh Application Program Interface.
;
;------------------------------------------------------------------------------

;
;   Interrupt 2Fh is used for Windows/386 API calls.
;
W386_API_Int		EQU	2Fh

;
;   All Windows/386 API Int 2Fh calls must be issued with AH = 16h
;
W386_Int_Multiplex	EQU	16h

;
;   Values for AL for all Windows/386 API calls
;
W386_Get_Version	EQU	00h		; Install check/Get version
W386_Old_Get_VMID_API	EQU	02h		; Version 2.xx get VMID API call
W386_Startup		EQU	05h		; Broadcast when Win386 starting
W386_Exit		EQU	06h		; Broadcast when Win386 exited
W386_Device_Broadcast	EQU	07h		; Broadcast by virtual device
W386_Startup_Complete	EQU	08h		; Broadcast when Win386 start is complete
W386_Begin_Exit 	EQU	09h		; Broadcast when Win386 is starting
						;   a NORMAL exit sequence
W386_Windows_ID 	EQU	0Ah		; Identify windows ver/type
W386_TSR_Identify	EQU	0Bh		; Identify TSRs
W386_ROM_Detect 	EQU	0Ch		; Used by ROM win to detect ROMs

W386_Release_Time	EQU	80h		; Release cur VM's time-slice
W386_Begin_Critical	EQU	81h		; Begin critical section
W386_End_Critical	EQU	82h		; End critical section
W386_Get_Cur_VMID	EQU	83h		; Returns BX = ID of current VM
W386_Get_Device_API	EQU	84h		; Returns ES:DI -> Device API
W386_Switch_And_Call	EQU	85h		; Change VMs and call-back
W386_Test_Int31_Avail	EQU	86h		; Returns AX=0 if Int 31 avail
W386_Get_PM_Switch_Addr EQU	87h		; Get call-back addr for PM
W386_Get_LDT_Base_Sel	EQU	88h		; Get selector to LDT
W386_Win_Kernel_Idle	EQU	89h		; Windows kernel idle call
W386_DPMI_Extension	EQU	8Ah		; DPMI extension Int 2Fh
W386_Set_Focus		EQU	8Bh		; Set focus to specified VM
W386_Restart_Cmd	EQU	8Ch		; Win.Com execs specified app

;
;   Structure for real mode device initialization API.
;
Win386_Startup_Info_Struc STRUC
SIS_Version		db	3, 0		; Structure version
SIS_Next_Ptr		dd	?		; Seg:Off of next dev in list
SIS_Virt_Dev_File_Ptr	dd	0		; Ptr to ASCIZ file name to load
SIS_Reference_Data	dd	?		; Data to be passed to device
SIS_Instance_Data_Ptr	dd	0		; Ptr to instance data list
Win386_Startup_Info_Struc ENDS

;
;   Structure for instance data list.  (List terminated with 0 dword).
;
Instance_Item_Struc STRUC
IIS_Ptr 		dd	?		; Seg:Off of instance item
IIS_Size		dw	?		; Size of instance item in bytes
Instance_Item_Struc ENDS

;
;   Flags passed to the Win_Kernel_Idle call to indicate state of Windows
;   in the BX register.
;
Win_Idle_Mouse_Busy	EQU	00000001b
Win_Idle_Mouse_Busy_Bit EQU	0

;
; Structure for TSR <-> Windows communication
; (W386_TSR_Identify call, AL=0Bh)
;
TSR_Info_Struc	STRUC
    TSR_Next		    dd	?
    TSR_PSP_Segment	    dw	?
    TSR_API_Ver_ID	    dw	100h
    TSR_Exec_Flags	    dw	0
    TSR_Exec_Cmd_Show	    dw	0
    TSR_Exec_Cmd	    dd	0
    TSR_Reserved	    db	4 dup (0)
    TSR_ID_Block	    dd	0
    TSR_Data_Block	    dd	0
TSR_Info_Struc ENDS

;
; TSR_Exec_Flags equates
;
TSR_WINEXEC	EQU	1
TSR_LOADLIBRARY EQU	2
TSR_OPENDRIVER	EQU	4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\OPTTEST.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	OPTTEST.INC - Macros to optimize test instructions
;
;   Version:	1.00
;
;   Date:	28-Jun-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   28-Jun-1990 RAL
;
;==============================================================================


TestMem MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	test	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	test	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	test	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	test	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	test	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	test	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	test	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	test	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM





TestReg MACRO R, Mask

_@TR MACRO Ltr
IFE (Mask) AND 0FFFFFF00h
	test	Ltr&&l, Mask
ELSE
IFE (Mask) AND 0FFFF00FFh
	test	Ltr&&h, ((Mask) SHR 8)
ELSE
IFE (Mask) AND 0FFFF0000h
	test	Ltr&&x, Mask
ELSE
	test	e&&Ltr&&x, Mask
ENDIF
ENDIF
ENDIF
	ENDM


IFIDNI <R>, <EAX>
	_@TR a, Mask
ELSE
IFIDNI <R>, <EBX>
	_@TR b, Mask
ELSE
IFIDNI <R>, <ECX>
	_@TR c, Mask
ELSE
IFIDNI <R>, <EDX>
	_@TR d, Mask
ELSE
IFIDNI <R>, <ESI>
IFE (Mask) AND 0FFFF0000h
	test	si, Mask
ELSE
	test	esi, Mask
ENDIF
ELSE
IFIDNI <R>, <EDI>
IFE (Mask) AND 0FFFF0000h
	test	di, Mask
ELSE
	test	edi, Mask
ENDIF
ELSE
%OUT ERROR:  Bad param to TestReg macro
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM




SetFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	or	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	or	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	or	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	or	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	or	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	or	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	or	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	or	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM



ClrFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	and	BYTE PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FFFF00FFh
	and	BYTE PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	and	BYTE PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	and	BYTE PTR [MemPtr+3], NOT ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	and	WORD PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FF0000FFh
	and	WORD PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	and	WORD PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
	and	DWORD PTR [MemPtr], NOT (M)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\PAGESWAP.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	PageSwap.Inc - Demand Paging Swap Device Services
;
;   Version:	1.00
;
;   Date:	18-Oct-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   18-Oct-1988 RAL Original
;   19-Oct-1990 JEM Added Buffer Descriptor structure
;
;==============================================================================


Begin_Service_Table PageSwap

PageSwap_Service PageSwap_Get_Version, LOCAL
PageSwap_Service PageSwap_Test_Create, LOCAL
PageSwap_Service PageSwap_Create, LOCAL
PageSwap_Service PageSwap_Destroy, LOCAL
PageSwap_Service PageSwap_In, LOCAL
PageSwap_Service PageSwap_Out, LOCAL
PageSwap_Service PageSwap_Test_IO_Valid, LOCAL

End_Service_Table PageSwap

PS_Zero_Init_Mask	EQU	0001h
PS_Zero_Init_Bit	EQU	00h
PS_Fixed_Page_Mask	EQU	0008h
PS_Fixed_Page_Bit	EQU	03h
PS_First_Page_In_Mask	EQU	0020h
PS_First_Page_In_Bit	EQU	05h
PS_Dirty_Mask		EQU	0040h
PS_Dirty_Bit		EQU	06h
PS_Ever_Dirty_Mask	EQU	8000h
PS_Ever_Dirty_Bit	EQU	0Fh

PS_NoXchg_Mask		EQU	80000000h
PS_NoXchg_Bit		EQU	1Fh	; DO NOT xchg phys addrs on PageSwap_Out


; Buffer descriptor for asynchronous I/O

SIZE_PS_BD_RESERVED EQU 44

PageSwapBufferDesc	STRUC
PS_BD_Next		dd	?
PS_BD_List		dw	?
PS_BD_Cmd		db	?
PS_BD_Priority		db	?
PS_BD_Page_Number	dd	?
PS_BD_Buffer_Ptr	dd	?
PS_BD_File_Page 	dd	?
PS_BD_Call_Back 	dd	?
PS_BD_Reserved		db SIZE_PS_BD_RESERVED dup (?)
PageSwapBufferDesc	ENDS

; List values for PS_BD_List

PS_BDL_Free		EQU	1
PS_BDL_Pending_WB	EQU	2
PS_BDL_Submitted_RA	EQU	3
PS_BDL_Locked		EQU	4

PS_BDP_Invalid_Data	EQU	-1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\vwin32.inc ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef Not_VxD
Begin_Service_Table VWIN32
VWIN32_Service	 VWIN32_Get_Version, LOCAL
VWIN32_Service	 VWIN32_DIOCCompletionRoutine, LOCAL
VWIN32_Service	 _VWIN32_QueueUserApc
VWIN32_Service	 _VWIN32_Get_Thread_Context
VWIN32_Service	 _VWIN32_Set_Thread_Context
VWIN32_Service	 _VWIN32_CopyMem, LOCAL
VWIN32_Service	 _VWIN32_Npx_Exception
VWIN32_Service	 _VWIN32_Emulate_Npx
VWIN32_Service	 _VWIN32_CheckDelayedNpxTrap
VWIN32_Service	 VWIN32_EnterCrstR0
VWIN32_Service	 VWIN32_LeaveCrstR0
VWIN32_Service	 _VWIN32_FaultPopup
VWIN32_Service	 VWIN32_GetContextHandle
VWIN32_Service	 VWIN32_GetCurrentProcessHandle, LOCAL
VWIN32_Service	 _VWIN32_SetWin32Event
VWIN32_Service	 _VWIN32_PulseWin32Event
VWIN32_Service	 _VWIN32_ResetWin32Event
VWIN32_Service	 _VWIN32_WaitSingleObject
VWIN32_Service	 _VWIN32_WaitMultipleObjects
VWIN32_Service	 _VWIN32_CreateRing0Thread
VWIN32_Service	 _VWIN32_CloseVxDHandle
VWIN32_Service	 VWIN32_ActiveTimeBiasSet, LOCAL
VWIN32_Service	 VWIN32_GetCurrentDirectory, LOCAL
VWIN32_Service	 VWIN32_BlueScreenPopup
VWIN32_Service	 VWIN32_TerminateApp
VWIN32_Service	 _VWIN32_QueueKernelAPC
VWIN32_Service	 VWIN32_SysErrorBox
VWIN32_Service	 _VWIN32_IsClientWin32
VWIN32_Service	 VWIN32_IFSRIPWhenLev2Taken, LOCAL
End_Service_Table VWIN32
endif

vseb_s	STRUC
vseb_resp	DD	?
vseb_b3	DW	?
vseb_b2	DW	?
vseb_b1	DW	?
vseb_pszCaption	DD	?
vseb_pszText	DD	?
vseb_s	ENDS
KERNEL_APC_IGNORE_MC	EQU	00000001H
KERNEL_APC_STATIC	EQU	00000002H
KERNEL_APC_WAKE	EQU	00000004H

DIOCParams	STRUC
Internal1	DD	?
VMHandle	DD	?
Internal2	DD	?
dwIoControlCode	DD	?
lpvInBuffer	DD	?
cbInBuffer	DD	?
lpvOutBuffer	DD	?
cbOutBuffer	DD	?
lpcbBytesReturned	DD	?
lpoOverlapped	DD	?
hDevice	DD	?
tagProcess	DD	?
DIOCParams	ENDS
VWIN32_DIOC_GETVERSION	EQU	<DIOC_GETVERSION>
VWIN32_DIOC_DOS_IOCTL	EQU	1
VWIN32_DIOC_DOS_INT25	EQU	2
VWIN32_DIOC_DOS_INT26	EQU	3
VWIN32_DIOC_DOS_INT13	EQU	4
VWIN32_DIOC_SIMCTRLC	EQU	5
VWIN32_DIOC_CLOSEHANDLE	EQU	<DIOC_CLOSEHANDLE>

DIOCRegs	STRUC
reg_EBX	DD	?
reg_EDX	DD	?
reg_ECX	DD	?
reg_EAX	DD	?
reg_EDI	DD	?
reg_ESI	DD	?
reg_Flags	DD	?
DIOCRegs	ENDS
ifndef FILE_FLAG_OVERLAPPED

_OVERLAPPED	STRUC
O_Internal	DD	?
O_InternalHigh	DD	?
O_Offset	DD	?
O_OffsetHigh	DD	?
O_hEvent	DD	?
_OVERLAPPED	ENDS
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VXDLDR.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*
;******************************************************************************
;
;   Title:	VXDLDR.H
;
;   Version:	1.00
;
;==============================================================================
*/

#ifndef	_VXDLDR_H
#define	_VXDLDR_H

/*XLATOFF*/
#ifdef __cplusplus
extern "C" {
#endif
/*XLATON*/

#ifndef	Not_VxD

/*XLATOFF*/
#define	VXDLDR_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table	(VXDLDR, VxD)
 VXDLDR_Service	(VXDLDR_GetVersion, LOCAL)
 VXDLDR_Service	(VXDLDR_LoadDevice, LOCAL)
 VXDLDR_Service	(VXDLDR_UnloadDevice, LOCAL)
 VXDLDR_Service	(VXDLDR_DevInitSucceeded, LOCAL)
 VXDLDR_Service	(VXDLDR_DevInitFailed, LOCAL)
 VXDLDR_Service	(VXDLDR_GetDeviceList, LOCAL)
 VXDLDR_Service   (VXDLDR_UnloadMe, LOCAL)

 VXDLDR_Service   (_PELDR_LoadModule, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_GetModuleHandle, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_GetModuleUsage, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_GetEntryPoint, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_GetProcAddress, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_AddExportTable, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_RemoveExportTable, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_FreeModule, VxD_PAGEABLE_CODE)

 VXDLDR_Service   (VXDLDR_Notify, LOCAL)

 VXDLDR_Service   (_PELDR_InitCompleted, VXD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_LoadModuleEx, VxD_PAGEABLE_CODE)

End_Service_Table	(VXDLDR, VxD)
/*ENDMACROS*/

#endif


#define	VXDLDR_INIT_DEVICE	0x000000001

/*
* Error codes returned by VXDLDR
*/

#define	VXDLDR_ERR_OUT_OF_MEMORY	1
#define	VXDLDR_ERR_IN_DOS		2
#define	VXDLDR_ERR_FILE_OPEN_ERROR	3
#define	VXDLDR_ERR_FILE_READ		4
#define	VXDLDR_ERR_DUPLICATE_DEVICE	5
#define	VXDLDR_ERR_BAD_DEVICE_FILE	6
#define	VXDLDR_ERR_DEVICE_REFUSED	7
#define	VXDLDR_ERR_NO_SUCH_DEVICE	8
#define	VXDLDR_ERR_DEVICE_UNLOADABLE	9
#define	VXDLDR_ERR_ALLOC_V86_AREA	10
#define	VXDLDR_ERR_BAD_API_FUNCTION	11

#define	VXDLDR_ERR_MAX			11

/*
* VXDLDR_ObjectNotify notification codes
*/
#define	VXDLDR_NOTIFY_OBJECTUNLOAD	0
#define	VXDLDR_NOTIFY_OBJECTLOAD	1

/*
* API entry point function codes
*/
#define	VXDLDR_APIFUNC_GETVERSION	0
#define	VXDLDR_APIFUNC_LOADDEVICE	1
#define	VXDLDR_APIFUNC_UNLOADDEVICE	2

/*
* Structures used by VXDLDR to maintain the list dynamically loaded vxds
*/

struct	ObjectInfo {
 ULONG OI_LinearAddress;	// start addr of object
 ULONG OI_Size;			// size of object in bytes
 ULONG OI_ObjType;			// obj type, defined in loader.h
 ULONG OI_Resident;		// Static object ?
} ;

struct DeviceInfo {
 struct DeviceInfo		*DI_Next;
 UCHAR 			DI_LoadCount;	// Reference Count
 struct VxD_Desc_Block		*DI_DDB;	// pointer to DDB
 USHORT 			DI_DeviceID;
 CHAR 				*DI_ModuleName;	// module name as stored in LE header
 ULONG 			DI_Signature;	// signature to verify the struc
 ULONG 			DI_ObjCount;	// number of objects
 struct ObjectInfo		*DI_ObjInfo;	// pointer to array of ObjectInfos
 ULONG				DI_V86_API_CSIP;// Save area for v86 api entry point
 ULONG				DI_PM_API_CSIP;	// Save area for pm api entry point
} ;

#define	DI_Loaded	DI_LoadCount

struct _W32IoctlPkt {
 USHORT	W32IO_ErrorCode ;
 USHORT	W32IO_DeviceID ;
 UCHAR		W32IO_ModuleName[1] ;
} ;

#ifndef	Not_VxD

/*XLATOFF*/

typedef	DWORD	VXDLDRRET;

#ifndef	WANTVXDWRAPS

#pragma warning (disable:4035)		// turn off no return code warning

WORD VXDINLINE
DL_GetVersion()
{
	VxDCall(VXDLDR_GetVersion);
}

VXDLDRRET VXDINLINE
DL_LoadDevice(struct VxD_Desc_Block **DDB, struct DeviceInfo **DeviceHandle, PCHAR Filename, BOOL InitDevice)
{
	VXDLDRRET	dlResult;

	_asm	mov	edx, Filename
	_asm	mov	eax, InitDevice
	VxDCall(VXDLDR_LoadDevice);
	_asm	mov	dlResult, eax
	_asm	jc	LoadDeviceError
	_asm	mov	ecx, DDB
	_asm	mov	dword ptr [ecx], eax
	_asm	mov	ecx, DeviceHandle
	_asm	mov	dword ptr [ecx], edx
	_asm	mov	dlResult, 0

LoadDeviceError:
	return(dlResult);
}

VXDLDRRET VXDINLINE
DL_UnloadDevice(USHORT DevID, PCHAR szName)
{
	_asm	mov	bx, DevID
	_asm	mov	edx, szName
	VxDCall(VXDLDR_UnloadDevice);
}

VXDLDRRET VXDINLINE
DL_DevInitSucceeded(struct DeviceInfo *DeviceHandle)
{
	_asm	mov	edx, DeviceHandle
	VxDCall(VXDLDR_DevInitSucceeded);
}

VXDLDRRET VXDINLINE
DL_DevInitFailed(struct DeviceInfo *DeviceHandle)
{
	_asm	mov	edx, DeviceHandle
	VxDCall(VXDLDR_DevInitFailed);
}

struct DeviceInfo VXDINLINE
*DL_GetDeviceList()
{
	VxDCall(VXDLDR_GetDeviceList);
}

#pragma warning (default:4035)		// turn on no return code warning

#endif	// WANTVXDWRAPS

/*XLATON*/

#endif	// Not_VxD

//===========================================================================
//                             PELDR definitions...
//===========================================================================

/*XLATOFF*/

// data types

#ifndef DECLARE_HANDLE
#ifdef STRICT
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ * name
#else   /* STRICT */
#define DECLARE_HANDLE(name)    typedef DWORD name
#endif  /* !STRICT */
#endif

#pragma warning (disable:4209)	// turn off redefinition warning

typedef char *               PSTR ;
typedef void                 *PVOID ;
typedef LONG                 LRESULT ;

#pragma warning (default:4209)	// turn off redefinition warning

// generic reference to a module export table...

DECLARE_HANDLE( HPEEXPORTTABLE ) ;
typedef HPEEXPORTTABLE *PHPEEXPORTTABLE ;

// generic reference to module image

DECLARE_HANDLE( HPEMODULE ) ;
typedef HPEMODULE *PHPEMODULE ;

// generic reference to lists

DECLARE_HANDLE( HLIST ) ;
typedef HLIST *PHLIST ;

/*XLATON*/

// manifest constants

#define PELDR_ERR_NOERROR                0L
#define PELDR_ERR_INVALIDHANDLE          -1L
                                         
#define PELDR_ERR_MEM_NOMEMORY           -2L
                                         
#define PELDR_ERR_FILE_UNABLETOOPEN      -3L
#define PELDR_ERR_FILE_READERROR         -4L
                                         
#define PELDR_ERR_IMAGE_INVALIDSIZE      -5L
#define PELDR_ERR_IMAGE_INVALIDFORMAT    -6L
#define PELDR_ERR_IMAGE_UNKNOWNFIXUP     -7L
#define PELDR_ERR_IMAGE_INVALIDFIXUP     -8L
#define PELDR_ERR_IMAGE_UNDEFINEDIMPORT  -9L

#define PELDR_ERR_EXPORT_DUPLICATE       -10L

#define PELDR_ERR_INIT_WASCOMPLETED      -11L

#define PELDR_LOADFLAG_FREERESOURCES    0x00000001

/*XLATOFF*/

// services:

// function prototypes

LRESULT CDECL PELDR_LoadModule
(
    PHPEMODULE      phl,
    PSTR            pFileName,
    PHLIST          phetl
) ;

LRESULT CDECL PELDR_LoadModuleEx
(
    PHPEMODULE      phl,
    PSTR            pFileName,
    PHLIST          phetl,
    DWORD           dwFlags
) ;

HPEMODULE PELDR_GetModuleHandle
(
    PSTR            pFileName
) ;

LRESULT CDECL PELDR_GetModuleUsage
(
    HPEMODULE       hl
) ;

PVOID PELDR_GetEntryPoint
(
    HPEMODULE       hl
) ;

PVOID CDECL PELDR_GetProcAddress
(
    HPEMODULE       hl,
    PVOID           pFuncName,
    PHLIST          phetl
) ;

LRESULT CDECL PELDR_AddExportTable
(
    PHPEEXPORTTABLE     pht,
    PSTR                pszModuleName,
    ULONG               cExportedFunctions,
    ULONG               cExportedNames,
    ULONG               ulOrdinalBase,
    PVOID               *pExportNameList,
    PUSHORT             pExportOrdinals,
    PVOID               *pExportAddrs,
    PHLIST              phetl
) ;

LRESULT CDECL PELDR_RemoveExportTable
(
    HPEEXPORTTABLE      ht,
    PHLIST              phetl
) ;

LRESULT CDECL PELDR_FreeModule
(
    HPEMODULE       hl,
    PHLIST          phetl
) ;

LRESULT CDECL PELDR_InitCompleted
(
    HPEMODULE       hl
) ;

#ifdef __cplusplus
}
#endif

/*XLATON*/

#endif	// _VXDLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\DEBUG.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

NOBUGBUG	EQU	1










BUGBUG	macro	d, id, note
endm





























IsDebugOnlyLoaded	macro	lab
	local	var, magic
_DBOSTART segment
var	label	byte
_DBOSTART ends
	db	0F7h, 05h
	dd	OFFSET32 magic
magic	dd	OFFSET32 var - (MAXSYSTEMLADDR + 1)
ifnb <lab>
	jz	lab
endif
	endm










DPublic MACRO	arg
if DEBLEVEL GT DEBLEVELRETAIL
	public	arg
endif
        ENDM















Assumes_Fall_Through MACRO L
ifndef MASM6
IF2
 IFDEF profileall
  IF (?prolog_&L - $) GT 3
  %OUT ERROR:  Fall through to &L invalid
  .ERR
  ENDIF
 ELSE
  IF (L - $) GT 3
  %OUT ERROR:  Fall through to &L invalid
  .ERR
  ENDIF
 ENDIF
ENDIF
else
 IFDEF profileall
.errnz ((?prolog_&L - $) GT 3), <ERROR: Fall through to &L invalid>
 ELSE
.errnz ((L - $) GT 3), <ERROR: Fall through to &L invalid>
 ENDIF
endif

     ENDM


ifndef Not_VxD





























??avh_parse_one_arg macro arg
    ifidni <arg>, <USES_FLAGS>
	??_fUsesFlagsPushfd equ <>
	??_fUsesFlagsPopfd equ <>
    elseifnb <arg>
	??_debLevel = arg
    endif
endm

??avh_parse_args macro DL, fUSES_FLAGS
	??_fUsesFlagsPushfd equ <pushfd>
	??_fUsesFlagsPopfd equ <popfd>
	??_debLevel = DEBLEVELNORMAL
	??avh_parse_one_arg <DL>
	??avh_parse_one_arg <fUSES_FLAGS>
endm

Assert_VM_Handle MACRO R, DL, fUSES_FLAGS
	LOCAL l1

IF DEBLEVEL GT DEBLEVELRETAIL

	??avh_parse_args <DL>, <fUSES_FLAGS>

IF DEBLEVEL GE ??_debLevel

IFNDEF WIN31COMPAT
IF DEBLEVEL LT DEBLEVELMAX
	??_fUsesFlagsPushfd
	cmp	[R].CB_Signature, VMCB_ID
	je	SHORT l1
ENDIF
ENDIF

IFDIFI <ebx>,<R>
	push	ebx
	mov	ebx, R
ENDIF
	VMMCall	Debug_Test_Valid_Handle
IFDIFI <ebx>, <R>
	pop	ebx
ENDIF

IFNDEF WIN31COMPAT
IF DEBLEVEL LT DEBLEVELMAX
l1:
	??_fUsesFlagsPopfd
ENDIF
ENDIF

ENDIF

ENDIF
	ENDM




























Assert_Thread_Handle MACRO R, DL, fUSES_FLAGS
	LOCAL l1

IF DEBLEVEL GT DEBLEVELRETAIL

	??avh_parse_args <DL>, <fUSES_FLAGS>

IF DEBLEVEL GE ??_debLevel

IF DEBLEVEL LT DEBLEVELMAX
	??_fUsesFlagsPushfd
	cmp	dword ptr [R.TCB_Signature], SCHED_OBJ_ID_THREAD
	je	SHORT l1
ENDIF

IFDIFI <edi>,<R>
        push    edi
        mov     edi, R
ENDIF
        VMMCall Debug_Test_Valid_Thread_Handle
IFDIFI <edi>,<R>
        pop     edi
ENDIF

IF DEBLEVEL LT DEBLEVELMAX
l1:
	??_fUsesFlagsPopfd
ENDIF

ENDIF

ENDIF
	ENDM

















Assert_Cur_Thread_Handle MACRO R, DL
	LOCAL myDebLevel
	LOCAL	OK

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel EQU DEBLEVELNORMAL
ELSE
	myDebLevel EQU <DL>
ENDIF

IF DEBLEVEL GE myDebLevel

IFDIFI <edi>,<R>
        push    edi
        mov     edi, R
ENDIF
        VMMCall Debug_Test_Cur_Thread
IFDIFI <edi>,<R>
        pop     edi
ENDIF

ENDIF

ENDIF
	ENDM













Debug_Printf	macro	fmt, args, dl
	local	fmtlab, myDebLevel

ife ?_DBOCODE
    ??_fDoit = VMM_TRUE
else
    ??_fDoit = FALSE
endif

if DEBLEVEL GT DEBLEVELRETAIL

ifb <dl>
	myDebLevel EQU <DEBLEVELNORMAL>
else
	myDebLevel EQU <dl>
endif

if DEBLEVEL GE myDebLevel
    ??_fDoit = VMM_TRUE
endif

endif

if ??_fDoit

ife ?_DBOCODE

VxD_DEBUG_ONLY_DATA_SEG
fmtlab	db	fmt, 0
VxD_DEBUG_ONLY_DATA_ENDS

else

ifdef VMMSYS

VMM_LOCKED_DATA_SEG
fmtlab	db	fmt, 0
VMM_LOCKED_DATA_ENDS

else

VxD_LOCKED_DATA_SEG
fmtlab	db	fmt, 0
VxD_LOCKED_DATA_ENDS

endif

endif

	ifb <args>
	VMMCall _Debug_Printf_Service, <(OFFSET32 fmtlab), esp>
	else
	VMMCall _Debug_Printf_Service, <(OFFSET32 fmtlab), esp, args>
	endif

endif

	endm







CHECK_EOL MACRO f, x, ln
	ifdifi <x>,<noeol>
	ifdifi <x>,<no_eol>
	ifdifi <x>,<nocrlf>
	ifdifi <x>,</noeol>
		%OUT Line ln: Unknown symbol (x) in f, taken as NOEOL
	endif
	endif
	endif
	endif

ENDM

??_Gen_String macro lbl:req, str:req
	ife ?_ICODE
	    ??_segName textequ <_IDATA>
	elseife ?_PCODE
	    ??_segName textequ <_PDATA>
	elseife ?_SCODE
	    ??_segName textequ <_SDATA>
	elseife ?_DBOCODE
	    ??_segName textequ <_DBODATA>
	else
	    ??_segName textequ <_LDATA>
	endif

	??_segName segment
	    lbl	db	str
	    ife ??_nocrlf
		db	0dh,0ah
	    endif
		db	0
	??_segName ends
endm


??Trace_Debug_Helper macro typ, str, arg1, arg2
	local	string

    ife ?_DBOCODE
	??_fDoit = VMM_TRUE
    else
	??_fDoit = 0
    endif

    if (DEBLEVEL GT DEBLEVELRETAIL) OR ??_fDoit

	??_nocrlf = 0
	??_debLevel = DEBLEVELNORMAL

	irp x, <arg1, arg2>
	    ifnb <x>
		if ((.TYPE x) AND 20h) GT 0
		    ??_debLevel = x
		else
		    Check_EOL <typ>, <x>, %(@Line)
		    ??_nocrlf = 1
		endif
	    endif
	endm

	if DEBLEVEL GE ??_debLevel
	    ??_fDoit = VMM_TRUE
	endif

    endif

    if ??_fDoit

	irpc c, str
	    ifidn <c>, <">
		??_is_string = 1
	    else
	    ifidni <c>, <'>
		??_is_string = 1
	    else
		??_is_string = 0
	    endif
	    endif
	    exitm
	endm

	if ??_is_string
	    ??_Gen_String string, <str>
	    ??_debug_out_str textequ <OFFSET32 string>
	else
	    ??_debug_out_str textequ <str>
	endif

	ifdef WIN31COMPAT
		pushfd
		pushad
		mov	esi, ??_debug_out_str
		VMMCall Out_Debug_String
	    ifidni <typ>, <Debug_Out>
		VMMCall Test_Debug_Installed
		jz	SHORT $+4
		int	1
	    endif
		popad
		popfd
	else
		push	??_debug_out_str
	    ifidni <typ>, <Debug_Out>
		VMMCall _Debug_Out_Service
	    else
		VMMCall _Trace_Out_Service
	    endif
	endif

    endif

	endm
















irp     cond,<S,C,A,AE,B,BE,E,Z,G,GE,L,LE,O>

Trace_Out&cond macro str, arg1, arg2
	?trace_out <str>,jn&cond, <arg1>, <arg2>
	endm

Trace_OutN&cond macro str, arg1, arg2
	?trace_out <str>,j&cond, <arg1>, <arg2>
	endm

endm

Trace_Out MACRO str, arg1, arg2
	??Trace_Debug_Helper <Trace_Out>, <str>, <arg1>, <arg2>
endm

Trace_OutECXZ   macro str, arg1, arg2
	local	l1,l2
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	jecxz	l1
	jmp	short l2
l1:	Trace_Out <str>, <arg1>, <arg2>
l2:
endif
	endm

Trace_OutECXNZ macro str, arg1, arg2
	?trace_out <str>,jecxz, <arg1>, <arg2>
	endm

Trace_OutEAXz macro str, arg1, arg2
	local	l1
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	or	eax,eax
	jnz	short l1
	Trace_Out <str>, <arg1>, <arg2>
l1:
endif
	endm

Trace_OutEAXnz macro str, arg1, arg2
	local	l1
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	or	eax,eax
	jz	short l1
	Trace_Out <str>, <arg1>, <arg2>
l1:
endif
	endm

?trace_out macro str, jmpop, arg1, arg2
	Local	nomsg
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	jmpop	short nomsg
	Trace_Out <str>,<arg1>,<arg2>
nomsg:
endif
	endm


















irp	cond,<S,C,A,AE,B,BE,E,Z,G,GE,L,LE,O>

Debug_Out&cond &macro str, arg1
	?debug_out <str>,jn&cond,<arg1>
	&endm

Debug_OutN&cond &macro str, arg1
	?debug_out <str>,j&cond,<arg1>
	&endm

endm

Debug_Out MACRO str, arg1, arg2
	??Trace_Debug_Helper <Debug_Out>, <str>, <arg1>, <arg2>
endm

Debug_OutECXZ	macro str, arg1
	local	l1,l2
if DEBLEVEL GT DEBLEVELRETAIL
	jecxz	l1
	jmp	short l2
l1:	Debug_Out <str>, <arg1>
l2:
endif
	endm

Debug_OutECXNZ macro str, arg1
	?debug_out <str>,jecxz, <arg1>
	endm

Debug_OutEAXz macro str, arg1
	local	l1
if DEBLEVEL GT DEBLEVELRETAIL
	or	eax,eax
	jnz	short l1
	Debug_Out <str>, <arg1>
l1:
endif
	endm

Debug_OutEAXnz macro str, arg1
	local	l1
if DEBLEVEL GT DEBLEVELRETAIL
	or	eax,eax
	jz	short l1
	Debug_Out <str>, <arg1>
l1:
endif
	endm

?debug_out macro str,jmpop, arg1
	Local	nomsg
if DEBLEVEL GT DEBLEVELRETAIL
	jmpop	short nomsg
	Debug_Out <str>, <arg1>
nomsg:
endif
	endm








Queue_Out MACRO S, V1, V2, DL
	LOCAL	Str_Off
	LOCAL MyDebLevel

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel

_LDATA SEGMENT
Str_Off db S, 0dh,0ah, 0
_LDATA ENDS

	push	esi
IFNB <V1>
    IF	TYPE V1 GT 0
	push	dword ptr V1
    ELSE
	push	V1
    ENDIF
ELSE
	push	eax
ENDIF
IFNB <V2>
    IF	TYPE V2 GT 0
	push	dword ptr V2
    ELSE
	push	V2
    ENDIF
ELSE
	push	ebx
ENDIF
	mov	esi, OFFSET32 Str_Off
	VMMCall Queue_Debug_String
	pop	esi
ENDIF

ENDIF
	ENDM








Mono_Out MACRO S, nocrlf
	LOCAL	Str_Off
IF DEBLEVEL GT DEBLEVELRETAIL
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0dh,0ah
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	esi, OFFSET32 Str_Off
	VMMCall Out_Mono_String
	popad
	popfd
ENDIF
	ENDM








Mono_Out_At MACRO Row, Col, S, nocrlf
	LOCAL	Str_Off
IF DEBLEVEL GT DEBLEVELRETAIL
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0dh,0ah
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	dx, (Row SHL 8)+Col
	VMMCall Set_Mono_Cur_Pos
	mov	esi, OFFSET32 Str_Off
	VMMCall Out_Mono_String
	popad
	popfd
ENDIF
	ENDM










Assert_Ints_Disabled MACRO DL

IFB <DL>
	??_debLevel = DEBLEVELNORMAL
ELSE
	??_debLevel = DL
ENDIF

IF DEBLEVEL GE ??_debLevel

ifndef ??_aidMessage
	_LDATA segment
	??_aidMessage	db	"ERROR:  Ints enabled at Assert_Ints_Disabled"
			db	0Dh, 0Ah, 0
	_LDATA ends
endif
	pushfd
	test	byte ptr [esp+1], IF_Mask SHR 8
    .if	!ZERO?
	push	OFFSET32 ??_aidMessage
	VMMCall _Debug_Out_Service
    .endif
	popfd
ENDIF
	ENDM








Assert_Ints_Enabled MACRO DL

IFB <DL>
	??_debLevel = DEBLEVELNORMAL
ELSE
	??_debLevel = DL
ENDIF

IF DEBLEVEL GE ??_debLevel

ifndef ??_aieMessage
	_LDATA segment
	??_aieMessage	db	"ERROR:  Ints disabled at Assert_Ints_Enabled"
			db	0Dh, 0Ah, 0
	_LDATA ends
endif
	pushfd
	test	byte ptr [esp+1], IF_Mask SHR 8
    .if	ZERO?
	push	OFFSET32 ??_aieMessage
	VMMCall _Debug_Out_Service
    .endif
	popfd
ENDIF
	ENDM

















Assert_Cur_VM_Handle MACRO R, DL
	LOCAL	OK
	LOCAL myDebLevel

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel

IFDIFI <ebx>,<R>
	push	ebx
	mov	ebx, R
ENDIF
	VMMCall Debug_Test_Cur_VM
IFDIFI <ebx>,<R>
	pop	ebx
ENDIF

ENDIF

ENDIF
	ENDM


Assert_Client_Ptr MACRO Reg, DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel
IFDIFI <ebp>,<Reg>
	push	ebp
	mov	ebp, Reg
ENDIF
	VMMCall Validate_Client_Ptr
IFDIFI <ebp>,<Reg>
	pop	ebp
ENDIF
ENDIF

ENDIF
	ENDM

endif























irp	cond,<s,c,a,ae,b,be,e,z,g,ge,l,le,o>

TRAP&cond &macro
	?trap	jn&cond
	&endm

TRAPn&cond &macro
	?trap	j&cond
	&endm

TRAPFATAL&cond &macro
	?trap	jn&cond, FATAL
	&endm

TRAPFATALn&cond &macro
	?trap	j&cond, FATAL
	&endm
endm

TRAP	macro
if DEBLEVEL GT DEBLEVELRETAIL
	int	3
endif
	endm

TRAPFATAL	macro
	local	l
if DEBLEVEL GT DEBLEVELRETAIL
l:	int	3
	jmp	short l
endif
	endm

TRAPecxz macro
	local	l1,l2
if DEBLEVEL GT DEBLEVELRETAIL
	jecxz	l1
	jmp	short l2
l1:	int	3
l2:
endif
	endm

TRAPecxnz macro
	?trap	jecxz
	endm

?trap	macro	jmpop, fatal
	Local	l, n
if DEBLEVEL GT DEBLEVELRETAIL
	jmpop	short n
l:	int	3
ifnb	<fatal>
	jmp	short l
endif
n:
endif
	endm

ifndef Not_VxD




Dump_Struc_Head MACRO
if DEBLEVEL GT DEBLEVELRETAIL
	Trace_Out "  Base    Address   Offs     Value  Field name"
ENDIF
	ENDM

Dump_Struc MACRO Base, X
if DEBLEVEL GT DEBLEVELRETAIL
	pushfd
	pushad
	lea	esi, [Base]
	mov	ecx, X
	lea	edx, [esi+ecx]

IF SIZE X EQ 6
	mov	bx, WORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #BX:#EAX  &X"
ELSE
IF SIZE X EQ 4
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #EAX  &X"
ELSE
IF SIZE X EQ 2
	mov	ax, WORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX      #AX  &X"
ELSE
	mov	al, BYTE PTR [edx]
	Trace_Out "#ESI  #EDX  #CX        #AL  &X"
ENDIF
ENDIF
ENDIF

	popad
	popfd
ENDIF
	ENDM

BeginDoc



























EndDoc

Begin_Touch_1st_Meg MACRO DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL
IFB <DL>
	myDebLevel = DEBLEVELMAX
ELSE
	myDebLevel = DL
ENDIF
IF DEBLEVEL GE myDebLevel
	VMMCall Enable_Touch_1st_Meg
ENDIF
ENDIF
	ENDM



End_Touch_1st_Meg MACRO DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL
IFB <DL>
	myDebLevel = DEBLEVELMAX
ELSE
	myDebLevel = DL
ENDIF
IF DEBLEVEL GE myDebLevel
	VMMCall Disable_Touch_1st_Meg
ENDIF
ENDIF
	ENDM

endif

IFDEF	DEBUG
TrashThis Macro	l:vararg
    ?TrashThisVal equ <0FFFFFF80h>
    ?TrashThisValSet = 0
    for r, <l>
	or	r, ?TrashThisVal
      ife ?TrashThisValSet
        if (OPATTR r) and 10h
	    ?TrashThisVal equ <r>
	    ?TrashThisValSet = 1
	endif
      endif
    endm
endm
ELSE
TrashThis Macro	l:vararg
endm
ENDIF


ifndef Not_VxD

if DEBLEVEL GT DEBLEVELRETAIL

ENTER_NOBLOCK MACRO
	push	DFS_ENTER_NOBLOCK
	VMMCall _Debug_Flags_Service
	ENDM

EXIT_NOBLOCK MACRO
	push	DFS_EXIT_NOBLOCK
	VMMCall _Debug_Flags_Service
	ENDM

Assert_CLD MACRO
	pushfd
	test	dword ptr [esp], DF_MASK
	Debug_OutNZ "Direction flag is not clear."
	popfd
	ENDM

Assert_Might_Block MACRO
	push	DFS_TEST_BLOCK
	VMMCall _Debug_Flags_Service
	ENDM

Assert_Not_Nest_Exec MACRO
	push	DFS_TEST_NEST_EXEC
	VMMCall _Debug_Flags_Service
	ENDM

ELSE

ENTER_NOBLOCK EQU <>
EXIT_NOBLOCK EQU <>
Assert_CLD EQU <>
Assert_Might_Block EQU <>
Assert_Not_Nest_Exec EQU <>

ENDIF


ifdef Begin_Service_Table
Begin_Service_Table DEBUG
DEBUG_Service	 DEBUG_Get_Version, LOCAL
DEBUG_Service	 DEBUG_Fault, LOCAL
DEBUG_Service	 DEBUG_CheckFault, LOCAL
DEBUG_Service	 _DEBUG_LoadSyms
End_Service_Table DEBUG
endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\CMACROS.INC ===
IFNDEF MASM6
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
ELSE  ;MASM6
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
??CM_Paste macro arg1:req, arg2:req
exitm <arg1&arg2>
endm
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
%out e r r o r ----- msg
.err e r r o r ----- msg
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.30 - Copyright (c) Microsoft Corp. 1984-1991>
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small Model>
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = ?PLM
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ??CM_Paste(?,x))
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ??CM_Paste(?,x))
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ??CM_Paste(?,x)
n=n or ??CM_Paste(?,x)
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?pcc
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmH macro n
?pp <n>,<word>,4,2
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
ife ?pcc
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?pcc
n equ (t ptr [bp][+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc macro po
uconcat <n>,,<equ>,,<(t ptr [bp][+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp][-o-2])
.xcref ?t_&n
?t_&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp][-o])
.xcref ?t_&n
?t_&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ??CM_Paste(?,x) eq ??CM_Paste(?,r)
n equ (byte ptr [bp][-o])
??CM_Paste(?t_,n)=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <%??CM_Paste(seg_,x)>,<word ptr>,2,2,1
?aloc <%??CM_Paste(off_,x)>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp][-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ word ptr n[0]
seg_&n equ word ptr n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?ex2
extrn ??CM_Paste(_,x):&d
x equ ??CM_Paste(_,x)
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ??CM_Paste(?CC,x)
.cref
??CM_Paste(?CC,x)=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?lb2
if ?lblpu
public ??CM_Paste(_,x)
endif
??CM_Paste(_,x) label &d
x equ ??CM_Paste(_,x)
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t_&n
.cref
n macro
	push	s
	push	o
endm
?t_&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i macro
?ap <n>
endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t_&n
ife ?t_&n-1
	push	word ptr (n)
exitm
endif
ife ?t_&n-2
	push	n
exitm
endif
ife ?t_&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t_&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t_&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t_&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 macro arg
purge ?PLMParm0
endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
endm
.xcref ?utpe
?utpe macro
??error <unterminated procedure definition: "&n">
endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,(-2)[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
endm
.cref
endm
assumes macro s,ln
ifdef MS_STARTUP
ifidn <code>,<ln>
assume s&:_TEXT
exitm
elseifidn <CODE>,<ln>
assume s&:_TEXT
exitm
elseifidn <data>,<ln>
assume s&:dgroup
exitm
elseifidn <DATA>,<ln>
assume s&:dgroup
exitm
endif
endif
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
ifnb <grp>
grp group n
?cs3 <ln>,<grp>
ln&OFFSET equ <offset grp:>
ln&BASE equ <grp>
else
?cs3 <ln>,<n>
ln&OFFSET equ <offset>
ln&BASE equ <n>
endif
endm
addseg macro grp,seg
.xcref
.xcref grp&_add
.cref
grp&_add macro s
grp&_in <seg>,s
endm
.xcref
.xcref grp&_in
.cref
grp&_in macro sl,s
ifb <s>
grp group sl
else
grp&_add macro ns
grp&_in <sl,s>,ns
endm
endif
endm
endm
defgrp macro grp,ln
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin macro
?cs2 <ln>,<n>
n segment
.xcref
.xcref ?mf
.cref
?mf macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
endm
endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd macro arg
n ends
purge ?mf
purge sEnd
endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes macro s
assume s:&n
endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
ifnb <x>
.errnz (x),<x>
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
callcrt MACRO funcname
ifdef _QC2
call funcname
else
if sizeC
push cs
call near ptr (funcname)
else
call funcname
endif
endif
ENDM
.cref
ENDIF ;MASM6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VXDLDR.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef	_VXDLDR_H
_VXDLDR_H	EQU	1
ifndef	Not_VxD
Begin_Service_Table	 VXDLDR, VxD
 VXDLDR_Service	 VXDLDR_GetVersion, LOCAL
 VXDLDR_Service	 VXDLDR_LoadDevice, LOCAL
 VXDLDR_Service	 VXDLDR_UnloadDevice, LOCAL
 VXDLDR_Service	 VXDLDR_DevInitSucceeded, LOCAL
 VXDLDR_Service	 VXDLDR_DevInitFailed, LOCAL
 VXDLDR_Service	 VXDLDR_GetDeviceList, LOCAL
 VXDLDR_Service    VXDLDR_UnloadMe, LOCAL
 VXDLDR_Service    _PELDR_LoadModule, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_GetModuleHandle, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_GetModuleUsage, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_GetEntryPoint, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_GetProcAddress, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_AddExportTable, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_RemoveExportTable, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_FreeModule, VxD_PAGEABLE_CODE
 VXDLDR_Service    VXDLDR_Notify, LOCAL
 VXDLDR_Service    _PELDR_InitCompleted, VXD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_LoadModuleEx, VxD_PAGEABLE_CODE
End_Service_Table	 VXDLDR, VxD
endif
VXDLDR_INIT_DEVICE	EQU	000000001H
VXDLDR_ERR_OUT_OF_MEMORY	EQU	1
VXDLDR_ERR_IN_DOS	EQU	2
VXDLDR_ERR_FILE_OPEN_ERROR	EQU	3
VXDLDR_ERR_FILE_READ	EQU	4
VXDLDR_ERR_DUPLICATE_DEVICE	EQU	5
VXDLDR_ERR_BAD_DEVICE_FILE	EQU	6
VXDLDR_ERR_DEVICE_REFUSED	EQU	7
VXDLDR_ERR_NO_SUCH_DEVICE	EQU	8
VXDLDR_ERR_DEVICE_UNLOADABLE	EQU	9
VXDLDR_ERR_ALLOC_V86_AREA	EQU	10
VXDLDR_ERR_BAD_API_FUNCTION	EQU	11
VXDLDR_ERR_MAX	EQU	11
VXDLDR_NOTIFY_OBJECTUNLOAD	EQU	0
VXDLDR_NOTIFY_OBJECTLOAD	EQU	1
VXDLDR_APIFUNC_GETVERSION	EQU	0
VXDLDR_APIFUNC_LOADDEVICE	EQU	1
VXDLDR_APIFUNC_UNLOADDEVICE	EQU	2

ObjectInfo	STRUC
OI_LinearAddress	DD	?
OI_Size	DD	?
OI_ObjType	DD	?
OI_Resident	DD	?
ObjectInfo	ENDS

DeviceInfo	STRUC
DI_Next	DD	?
DI_LoadCount	DB	?
DI_DDB	DD	?
DI_DeviceID	DW	?
DI_ModuleName	DD	?
DI_Signature	DD	?
DI_ObjCount	DD	?
DI_ObjInfo	DD	?
DI_V86_API_CSIP	DD	?
DI_PM_API_CSIP	DD	?
DeviceInfo	ENDS
DI_Loaded	EQU	<DI_LoadCount>

_W32IoctlPkt	STRUC
W32IO_ErrorCode	DW	?
W32IO_DeviceID	DW	?
W32IO_ModuleName	DB	1 DUP (?)
_W32IoctlPkt	ENDS
ifndef	Not_VxD
endif
PELDR_ERR_NOERROR	EQU	0
PELDR_ERR_INVALIDHANDLE	EQU	-1
PELDR_ERR_MEM_NOMEMORY	EQU	-2
PELDR_ERR_FILE_UNABLETOOPEN	EQU	-3
PELDR_ERR_FILE_READERROR	EQU	-4
PELDR_ERR_IMAGE_INVALIDSIZE	EQU	-5
PELDR_ERR_IMAGE_INVALIDFORMAT	EQU	-6
PELDR_ERR_IMAGE_UNKNOWNFIXUP	EQU	-7
PELDR_ERR_IMAGE_INVALIDFIXUP	EQU	-8
PELDR_ERR_IMAGE_UNDEFINEDIMPORT	EQU	-9
PELDR_ERR_EXPORT_DUPLICATE	EQU	-10
PELDR_ERR_INIT_WASCOMPLETED	EQU	-11
PELDR_LOADFLAG_FREERESOURCES	EQU	00000001H
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\MINIVDD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1993
;
;   Title:	minivdd.inc - VDD definitions for other VxD's and multiple VDD's
;
;   Version:	4.00
;
;   Date:
;
;   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
;	    the general include area.  Added services are ONLY for the
;	    use of the Mini-VDD and should therefore not be documented.
;
;------------------------------------------------------------------------------
;==============================================================================
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD

;
;VDD protect mode services for other devices and VMM (Get_Version must be first).
;Only define these if we're assembling either the "main" VDD or one of the
;mini-VDD's.  Don't define this if we're assembling a display driver or other
;caller of the MiniVDD stuff:
;
ifdef MINIVDD
Begin_Service_Table VDD
VDD_Service	VDD_Get_Version 	; Get version number and ID string ptr
VDD_Service	VDD_PIF_State		; Pass video PIF bits to VDD
VDD_Service	VDD_Get_GrabRtn 	; Get routine addr for video grab
VDD_Service	VDD_Hide_Cursor 	; Hide cursor when display is windowed
VDD_Service	VDD_Set_VMType		; Set VM type(windowed, bckgrnd, excl)
VDD_Service	VDD_Get_ModTime 	; Return system time of last mod
VDD_Service	VDD_Set_HCurTrk 	; Track horiz cursor movement in window
VDD_Service	VDD_Msg_ClrScrn 	; Clear screen for sysmodal message
VDD_Service	VDD_Msg_ForColor	; Set Msg_TextOut forground color
VDD_Service	VDD_Msg_BakColor	; Set Msg_TextOut background color
VDD_Service	VDD_Msg_TextOut 	; Output a string
VDD_Service	VDD_Msg_SetCursPos	; Set cursor position
VDD_Service	VDD_Query_Access	; Is it OK to access video now?
VDD_Service	VDD_Check_Update_Soon	; User action may update screen
VDD_Service	VDD_Get_Mini_Dispatch_Table
					; Get addr of dispatch table to mini-VDD
VDD_Service	VDD_Register_Virtual_Port
					; Mini-VDD asks us to setup I/O trap
VDD_Service	VDD_Get_VM_Info 	; Returns CRTC owner and MemC owners
					; and other special VM handles
VDD_Service	VDD_Get_Special_VM_IDs	;returns planar & msg mode IDs
VDD_Service	VDD_Register_Extra_Screen_Selector
					;allows display driver to use second
					;screen selector for block moves
VDD_Service	VDD_Takeover_VGA_Port	;allows MiniVDD to takeover a port
					;in range 3C0H through 3DFH
VDD_Service	VDD_Get_DISPLAYINFO	;get DISPLAYINFO data structure
VDD_Service	VDD_Do_Physical_IO	;perform physical I/O for trapped port
VDD_Service	VDD_Set_Sleep_Flag_Addr ;when display driver can't be interrupted
End_Service_Table VDD
endif	;MINIVDD

IFDEF VDD40
VDD_VerNum	EQU	0400h	;version 4.00
ELSE
VDD_VerNum	=	030ah	;return version 3.10 if Makefile switch not set

IFDEF DEBUG
IFNDEF VGA
IFNDEF EGA
VDD_VerNum = VDD_VerNum + 0FFh
ENDIF ;EGA
ENDIF ;VGA
ENDIF ;DEBUG

ENDIF	;VDD40

;***************
; PIF_State service definitions
;
; These definitions cannot change without changing the PIF editor!!!
;
fVidTxtEmulate	EQU	0001h		; Do INT 10h TTY and cursor emulation
fVidNoTrpTxt	EQU	0002h		; Do not trap text mode apps
fVidNoTrpLRGrfx EQU	0004h		; Do not trap lo res graphics mode apps
fVidNoTrpHRGrfx EQU	0008h		; Do not trap hi res graphics mode apps
fVidTextMd	EQU	0010h		; Allocate text mode mem
fVidLowRsGrfxMd EQU	0020h		; Allocate lo res graphics mode mem
fVidHghRsGrfxMd EQU	0040h		; Allocate hi res graphics mode mem
fVidRetainAllo	EQU	0080h		; Never deallocate once allocated

;
;The following stuff was added for mini-VDD support:
;
;Functions that we can call in the hardware-dependent mini-VDD.  Note that
;these equates are used to create the dispatch table for calling functions
;in the mini-VDD:
;
REGISTER_DISPLAY_DRIVER 	equ	0
GET_VDD_BANK			equ	1
SET_VDD_BANK			equ	2
RESET_BANK			equ	3
PRE_HIRES_TO_VGA		equ	4
POST_HIRES_TO_VGA		equ	5
PRE_VGA_TO_HIRES		equ	6
POST_VGA_TO_HIRES		equ	7
SAVE_REGISTERS			equ	8
RESTORE_REGISTERS		equ	9
MODIFY_REGISTER_STATE		equ	10
ACCESS_VGA_MEMORY_MODE		equ	11
ACCESS_LINEAR_MEMORY_MODE	equ	12
ENABLE_TRAPS			equ	13
DISABLE_TRAPS			equ	14
MAKE_HARDWARE_NOT_BUSY		equ	15
VIRTUALIZE_CRTC_IN		equ	16
VIRTUALIZE_CRTC_OUT		equ	17
VIRTUALIZE_SEQUENCER_IN 	equ	18
VIRTUALIZE_SEQUENCER_OUT	equ	19
VIRTUALIZE_GCR_IN		equ	20
VIRTUALIZE_GCR_OUT		equ	21
SET_LATCH_BANK			equ	22
RESET_LATCH_BANK		equ	23
SAVE_LATCHES			equ	24
RESTORE_LATCHES 		equ	25
DISPLAY_DRIVER_DISABLING	equ	26
SELECT_PLANE			equ	27
PRE_CRTC_MODE_CHANGE		equ	28
POST_CRTC_MODE_CHANGE		equ	29
VIRTUALIZE_DAC_OUT		equ	30
VIRTUALIZE_DAC_IN		equ	31
GET_CURRENT_BANK_WRITE		equ	32
GET_CURRENT_BANK_READ		equ	33
SET_BANK			equ	34
CHECK_HIRES_MODE		equ	35
GET_TOTAL_VRAM_SIZE		equ	36
GET_BANK_SIZE			equ	37
SET_HIRES_MODE			equ	38
PRE_HIRES_SAVE_RESTORE		equ	39
POST_HIRES_SAVE_RESTORE 	equ	40
VESA_SUPPORT			equ	41
GET_CHIP_ID			equ	42
CHECK_SCREEN_SWITCH_OK		equ	43
VIRTUALIZE_BLTER_IO		equ	44
SAVE_MESSAGE_MODE_STATE 	equ	45
SAVE_FORCED_PLANAR_STATE	equ	46
VESA_CALL_POST_PROCESSING	equ	47
;
NBR_MINI_VDD_FUNCTIONS		equ	48	;REMEMBER TO RESET THIS!!!!!!

;
;Following are function codes that can be called via the VDD's
;API entry point. These are mainly for display driver --> VDD communication.
;Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
;(after the Grabber functions) for other VDD API services, we start our
;numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
;
MINIVDD_SVC_BASE_OFFSET 		equ	80h
VDD_DRIVER_REGISTER			equ	0 or MINIVDD_SVC_BASE_OFFSET
VDD_DRIVER_UNREGISTER			equ	1 or MINIVDD_SVC_BASE_OFFSET
VDD_SAVE_DRIVER_STATE			equ	2 or MINIVDD_SVC_BASE_OFFSET
VDD_REGISTER_DISPLAY_DRIVER_INFO	equ	3 or MINIVDD_SVC_BASE_OFFSET
VDD_REGISTER_SSB_FLAGS			equ	4 or MINIVDD_SVC_BASE_OFFSET
VDD_GET_DISPLAY_CONFIG			equ	5 or MINIVDD_SVC_BASE_OFFSET
VDD_PRE_MODE_CHANGE			equ	6 or MINIVDD_SVC_BASE_OFFSET
VDD_POST_MODE_CHANGE			equ	7 or MINIVDD_SVC_BASE_OFFSET
VDD_SET_USER_FLAGS			equ	8 or MINIVDD_SVC_BASE_OFFSET
VDD_SET_BUSY_FLAG_ADDR			equ	9 or MINIVDD_SVC_BASE_OFFSET
;
;Port size equates:
;
BYTE_LENGTHED			equ	1
WORD_LENGTHED			equ	2

;
;Flag equates:
;
GOING_TO_WINDOWS_MODE		equ	1
GOING_TO_VGA_MODE		equ	2
DISPLAY_DRIVER_DISABLED 	equ	4
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local	MiniVDDCallExit, MiniVDDCallLeave
	push	edi			;;save this register for now
ifnb	<SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
	call	dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm

DISPLAYINFO	struc
	diHdrSize		dw	size DisplayInfo
	diInfoFlags		dw	?
	diDevNodeHandle		dd	?
	diDriverName		db	16 dup(?)
	diXRes			dw	?
	diYRes			dw	?
	diDPI			dw	?
	diPlanes		db	?
	diBpp			db	?
	diRefreshRateMax	dw	?
	diRefreshRateMin	dw	?
	diLowHorz		dw	?
	diHighHorz		dw	?
	diLowVert		dw	?
	diHighVert		dw	?
	diMonitorDevNodeHandle	dd	?
	diHorzSyncPolarity	db	?
	diVertSyncPolarity	db	?
DISPLAYINFO	ends
DISPLAYINFO_SIZE	equ	diRefreshRateMax+2-diHdrSize
;
;Following are values and explanations for the diInfoFlags word in DISPLAYINFO:
;
;RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
;or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
;program would get the DISPLAYINFO structure returned to him) caused the VDD
;to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
;insted of actually going out and reading "fresh" data from the Registry.
;
;This flag brings to light the fact that there are some circumstances when the
;VDD cannot go out and read the registry in response to the call to
;VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
;considerations).  In this case, this flag will be set to a 1 to indicate that
;the information being returned isn't "fresh" -- that is -- it may be
;incorrect and obsolete.  The caller should respond accordingly if this flag
;is set.
;
RETURNED_DATA_IS_STALE			equ	01h
;
;MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
;that the MiniVDD didn't match the chipset installed in the machine), the
;MiniVDD didn't load.  Callers can examine this flag and act accordingly.
;
MINIVDD_FAILED_TO_LOAD			equ	02h
;
;MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
;successfully, when the ChipID that the MiniVDD calculated was compared
;against the value saved in the registry, they didn't match.  An example of
;when this would happen is when the user is happily using an S3-911 card
;and then decides to upgrade his display card to an S3-864.  Since both
;cards use S3.VXD, the MiniVDD will load, however, since the card model
;is different, the VDD will return a defect to configuration manager and
;set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
;flag to take appropriate actions to make sure that the user gets his
;configuration correct.
;
MINIVDD_CHIP_ID_DIDNT_MATCH		equ	04h
;
;REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
;from the registry when the VDD tried to read it.
;
REGISTRY_BPP_NOT_VALID			equ	08h
;
;REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
;resolution value from the registry when the VDD tried to read it.
;
REGISTRY_RESOLUTION_NOT_VALID		equ	10h
;
;REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
;DPI value from the registry when the VDD tried to read it.
;
REGISTRY_DPI_NOT_VALID			equ	20h
;
;MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
;GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
;This is certainly not fatal by any means.  It simply means that the
;monitor refresh rate info in the DISPLAYINFO data structure is totally
;invalid!
;
MONITOR_DEVNODE_NOT_ACTIVE		equ	40h
;
;MONITOR_INFO_NOT_VALID indicates that something within the code which
;retrieves and calculates the refresh rate data has failed.  This indicates
;that the values in diRefreshRateMax through diVertSyncPolarity are not
;valid and could contain random data.
;
MONITOR_INFO_NOT_VALID			equ	80h
;
;MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
;string in SYSTEM.INI had a negative number in it or that the string in
;the display's software key (HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate)
;was 0 or a negative number.
;
MONITOR_INFO_DISABLED_BY_USER		equ	100h
;
;REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
;diLowVert, diHighVert, or sync polarity data in the registry.	The
;value returned in diRefreshRateMax is the only refresh rate data that
;we have available.  This was derived either from RefreshRate= in SYSTEM.INI
;or the HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate = string in the
;registry.
;
REFRESH_RATE_MAX_ONLY			equ	200h
;
;CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
;display card manufacturers wishing to extend the capabilities of the chip level
;MiniVDD's ) has successfully been loaded and initialized.
;
CARD_VDD_LOADED_OK			equ	400h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\SHELLFSC.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	SHELLFSC.Inc - EQUATES related to the File Sys Change stuff
;
;   Version:	1.00
;
;   Date:	19-Sep-1988
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Sep-1988 ARR Original
;
;==============================================================================

VDA_FileSysChange	EQU	0400H+20+11

;
; On VDA_FileSysChange, wParam is not used
;   Particular VMDOSAPP instance which gets the message is the VM that has
;   changed the file system
;
; NOTE THERE MUST BE A CALL BACK ON THIS EVENT.
;
; The reference data MUST BE A pointer to a structure of the following type:
;
; It is the responsibility of the caller to "FREE" this structure (if needed)
;   on the call back.
;
; Caller can extend this structure if needed by tacking extra info on the end.
;
MAXFSCINFOSIZE		EQU	256

VMDA_FileSysChng  STRUC
VMDA_FSC_Func		dw	?
VMDA_FSC_Buffer 	db	MAXFSCINFOSIZE DUP(?)
VMDA_FileSysChng  ENDS

;
; equates for VMDA_FSC_Func
;
VMDA_FSC_CREATE 	EQU	0
VMDA_FSC_DELETE 	EQU	1
VMDA_FSC_RENAME 	EQU	2
VMDA_FSC_ATTRIBUTES	EQU	3
VMDA_FSC_NETCONNECT	EQU	4
VMDA_FSC_NETDISCONNECT	EQU	5
VMDA_FSC_REFRESH	EQU	6
VMDA_FSC_MKDIR		EQU	7
VMDA_FSC_RMDIR		EQU	8
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\V86MMGR.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;******************************************************************************
;
;   Title:	V86MMGR.Inc - Public services for V86MMGR
;
;   Version:	2.00
;
;==============================================================================

Begin_Service_Table V86MMGR

V86MMGR_Service 	V86MMGR_Get_Version,		LOCAL
V86MMGR_Service 	V86MMGR_Allocate_V86_Pages,	LOCAL
V86MMGR_Service 	V86MMGR_Set_EMS_XMS_Limits,	LOCAL
V86MMGR_Service 	V86MMGR_Get_EMS_XMS_Limits,	LOCAL
;
;   Services used for API mapping.
;
V86MMGR_Service 	V86MMGR_Set_Mapping_Info, VxD_ICODE
V86MMGR_Service 	V86MMGR_Get_Mapping_Info
V86MMGR_Service 	V86MMGR_Xlat_API
V86MMGR_Service 	V86MMGR_Load_Client_Ptr
V86MMGR_Service 	V86MMGR_Allocate_Buffer
V86MMGR_Service 	V86MMGR_Free_Buffer
V86MMGR_Service 	V86MMGR_Get_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Set_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Get_VM_Flat_Sel
V86MMGR_Service 	V86MMGR_Map_Pages
V86MMGR_Service 	V86MMGR_Free_Page_Map_Region
;***********************************************************
;  END OF 3.00 level services
;
V86MMGR_Service 	V86MMGR_LocalGlobalReg
V86MMGR_Service 	V86MMGR_GetPgStatus,		LOCAL
V86MMGR_Service 	V86MMGR_SetLocalA20,		VxD_ICODE
V86MMGR_Service 	V86MMGR_ResetBasePages, 	LOCAL
V86MMGR_Service 	V86MMGR_SetAvailMapPgs, 	VxD_ICODE
V86MMGR_Service 	V86MMGR_NoUMBInitCalls, 	VxD_ICODE

IFNDEF	WIN31COMPAT

;   Services added post Win 3.1
V86MMGR_Service         V86MMGR_Get_EMS_XMS_Avail,      LOCAL
V86MMGR_Service         V86MMGR_Toggle_HMA
V86MMGR_Service 	V86MMGR_Dev_Init,		LOCAL
V86MMGR_Service 	V86MMGR_Alloc_UM_Page,		LOCAL

ENDIF ;	WIN31COMPAT


End_Service_Table V86MMGR

;
; BITS of returned EAX flags for V86MMGR_GetPgStatus
;
V86PS_ROM       equ     0000000000000001b       ; Page contains global ROM
V86PS_RAM       equ     0000000000000010b       ; Page contains global RAM
V86PS_EMM	equ	0000000010000000b	; Page belongs to EMM driver
V86PS_XMS	equ	0000000100000000b	; Page belongs to XMS driver
V86PS_MAP	equ	0000001000000000b	; Page belongs to mapper
V86PS_UMB       equ     0001000000000000b       ; Page contains imported UMB
                                                ;  (Note that V86PS_XMS is not
                                                ;   necessarily set)

;
; BITS of ECX flags for V86MMGR_Allocate_V86_Pages
;
AV86PLocked			EQU	00000000000000000000000000000001B
AV86PLockedBit			EQU	0	; VM memory is to be
						;   ALWAYS LOCKED regardless of
						;   pager type or whether VM
						;   is suspended.
;
; BITS of ECX flags for V86MMGR_Set_EMS_XMS_Limits
;
; NOTE: If neither Limit_DisableHMA or Limit_EnableHMA is set, the HMA
;	state is not altered.
;
EMS_XMS_Limit_DisableHMA	EQU	00000000000000000000000000000001B
EMS_XMS_Limit_DisableHMABit	EQU	0
EMS_XMS_Limit_EnableHMA 	EQU	00000000000000000000000000000010B
EMS_XMS_Limit_EnableHMABit	EQU	1
EMS_XMS_Limit_XMS_Is_Locked	EQU	00000000000000000000000000000100B
EMS_XMS_Limit_XMS_Is_LockedBit	EQU	2
EMS_XMS_Limit_EMS_Is_Locked	EQU	00000000000000000000000000001000B
EMS_XMS_Limit_EMS_Is_LockedBit	EQU	3



;
;   API mapper equates and macros
;

Xlat_Exec_Int	    EQU     000h
Xlat_Fixed_Len	    EQU     001h
Xlat_Var_Len	    EQU     002h
Xlat_Calc_Len	    EQU     003h
Xlat_ASCIIZ	    EQU     004h
Xlat_Jmp_To_Proc    EQU     005h
Xlat_Return_Ptr     EQU     006h
Xlat_Return_Seg     EQU     007h
Xlat_ASCIIZ_InOut   EQU     008h


Xlat_API_Exec_Int MACRO Int_Number
	db	Xlat_Exec_Int
	db	Int_Number
	ENDM

Xlat_API_Fixed_Len MACRO Ptr_Seg, Ptr_Off, Length
	db	Xlat_Fixed_Len
	dw	Length
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Var_Len MACRO Ptr_Seg, Ptr_Off, Len_Reg
	db	Xlat_Var_Len
	db	Client_&Len_Reg
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Calc_Len MACRO Ptr_Seg, Ptr_Off, Calc_Proc_Addr
	db	Xlat_Calc_Len
	dd	OFFSET32 Calc_Proc_Addr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ_InOut  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ_InOut
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Jmp_To_Proc MACRO Proc_Name
	db	Xlat_Jmp_To_Proc
	dd	OFFSET32 Proc_Name
	ENDM


Xlat_API_Return_Ptr MACRO Ptr_Seg, Ptr_Off
	db	Xlat_Return_Ptr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Return_Seg MACRO Ptr_Seg
	db	Xlat_Return_Seg
	db	Client_&Ptr_Seg
	ENDM

;
; The V86MMGR does W386_Device_Broadcast call outs. The 'subfunction' number
; for these call outs is contained in the CX register. These are the equates
; for the subfunction numbers.
;
V86CallOut_LclA20forGlblHMA	equ	0	; Should A20 state be local
						;   even if HMA is GLOBAL?
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VDD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	vdd.inc - VDD definitions for other VxD's and multiple VDD's
;
;   Version:	1.00
;
;   Date:
;
;   Author: AR, MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jan-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD

;***************
;VDD protect mode services for other devices and VMM(Get_Version must be first)
;
VDD_Service	VDD_Get_Version 	; Get version number and ID string ptr
VDD_Service	VDD_PIF_State		; Pass video PIF bits to VDD
VDD_Service	VDD_Get_GrabRtn 	; Get routine addr for video grab
VDD_Service	VDD_Hide_Cursor 	; Hide cursor when display is windowed
VDD_Service	VDD_Set_VMType		; Set VM type(windowed, bckgrnd, excl)
VDD_Service	VDD_Get_ModTime 	; Return system time of last mod
VDD_Service	VDD_Set_HCurTrk 	; Track horiz cursor movement in window
VDD_Service	VDD_Msg_ClrScrn 	; Clear screen for sysmodal message
VDD_Service	VDD_Msg_ForColor	; Set Msg_TextOut forground color
VDD_Service	VDD_Msg_BakColor	; Set Msg_TextOut background color
VDD_Service	VDD_Msg_TextOut 	; Output a string
VDD_Service	VDD_Msg_SetCursPos	; Set cursor position
VDD_Service	VDD_Query_Access	; Is it OK to access video now?

; New services for 3.1	Not supported for 3.0 VDD's
;
VDD_Service	VDD_Check_Update_Soon,,VGA31 ; User action may update screen

End_Service_Table VDD

IFDEF VGA31
VDD_VerNum	EQU	030Ah		; version 3, 10
ELSE
VDD_VerNum	=	0300h

IFDEF DEBUG
IFNDEF VGA
IFNDEF EGA
VDD_VerNum = VDD_VerNum + 0FFh
ENDIF ;EGA
ENDIF ;VGA
ENDIF ;DEBUG

ENDIF	;VGA31

;***************
; PIF_State service definitions
;
; These definitions cannot change without changing the PIF editor!!!
;
fVidTxtEmulate	EQU	0001h		; Do INT 10h TTY and cursor emulation
fVidNoTrpTxt	EQU	0002h		; Do not trap text mode apps
fVidNoTrpLRGrfx EQU	0004h		; Do not trap lo res graphics mode apps
fVidNoTrpHRGrfx EQU	0008h		; Do not trap hi res graphics mode apps
fVidTextMd	EQU	0010h		; Allocate text mode mem
fVidLowRsGrfxMd EQU	0020h		; Allocate lo res graphics mode mem
fVidHghRsGrfxMd EQU	0040h		; Allocate hi res graphics mode mem
fVidRetainAllo	EQU	0080h		; Never deallocate once allocated
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VDDGRB.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;***************
; Shell_Event definitions for the VDD
;
;   DO NOT CHANGE THESE EVER WITHOUT REDOING THE SHELL AND THE GRABBER
;	AND THE VDD!!!
;
VDA_Type_Chng		EQU	((0400h+20)+2)

VDA_Display_Event	EQU	((0400h+20)+6)
; On VDA_Display_Event event,
;   VMDOSAPP instance which gets the message has display event
;   wParam is a "subfunction code" which identifies the event.
;
VDA_DE_DispChngMin	EQU	0
VDA_DE_DispChngMax	EQU	80
VDA_DE_ControlChngMin	EQU	VDA_DE_DispChngMax
VDA_DE_ControlChngMax	EQU	160
VDA_DE_ScreenGrabMin	EQU	VDA_DE_ControlChngMax
VDA_DE_ScreenGrabMax	EQU	240

VDA_DE_SpecialMin	EQU	0FFAFh
VDA_DE_SpecialMax	EQU	0FFFFh
;
; Subfunctions >= VDA_DE_DispChngMin, < VDA_DE_DispChngMax indicate
;   that the display has changed without a change to the video controller
;   state.
;
; Subfunctions >= VDA_DE_ControlChngMin, < VDA_DE_ControlChngMax indicate
;   that the video controller state has changed.
;
; Subfunctions >= VDA_DE_ScreenGrabMin, < VDA_DE_ScreenGrabMax indicate
;   that a screen grab event has occured.
;
; Subfunctions >= VDA_DE_SpecialMin, < VDA_DE_SpecialMax indicate
;   private GRABBER events which VMDOSAPP just passes through to the
;   GRABBER
;
; This parameter is passed through VMDOSAPP to the display specific GRABBER.
;   "ranges" on the parameter allow specific info to be passed to the GRABBER
;   while allowing VMDOSAPP to know about the general high level aspect of the
;   event.
;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VXDWRAPS.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/****************************************************************************
 *
 *   Title: VXDWRAPS.H - Include file for using VXDWRAPS.LIB
 *
 *   Version:   1.00
 *
 ***************************************************************************/

#ifndef _VXDWRAPS_H
#define _VXDWRAPS_H

#ifdef  _VMM_

#define VMM_MAP_PHYS_TO_LINEAR_INVALID  0xFFFFFFFF

typedef VOID                (_cdecl *VMM_TIMEOUT_HANDLER)();
typedef VOID                (_cdecl *VMM_EVENT_HANDLER)();
typedef ULONG               (_cdecl *VMMSWP)(ULONG frame, ULONG npages);
typedef VOID                (_cdecl *VMMCOMS)(DWORD dwParam);
typedef struct Exception_Handler_Struc  *PVMMEXCEPTION;
//typedef   QWORD               DESCDWORDS;
typedef DWORD               VMMLIST;
typedef PVOID               VMMLISTNODE;
typedef DWORD               SIGNATURE;
typedef SIGNATURE           *PSIGNATURE;    // Pointer to a signature.
typedef struct _vmmmtx {int unused;}    *PVMMMUTEX;
typedef	struct cb_s			*PVMMCB;

#endif  // _VMM_

#define CAT_HELPER(x, y)    x##y
#define CAT(x, y)       CAT_HELPER(x, y)

#ifndef CURSEG
#define CURSEG()        LCODE
#endif

/****************************************************************************
 *
 * There are two types of VxD 'C' wrappers. The ones that are VXDINLINE and
 * the one that have little stubs.
 *
 ***************************************************************************/

/****************************************************************************
 *
 * The following are VxD wrappers done with VXDINLINE. They must return void
 * (to avoid a problem with C++), must take VOID (so that no parameter are
 * used as temporary stack) and all registers are preserved. The two
 * *_Debug_String also fall in that category since they need esp and ebp
 * not to be in a nested stack frame.
 *
 ***************************************************************************/

#ifdef  _VMM_

VOID VXDINLINE
End_Critical_Section(VOID)
{
    VMMCall(End_Critical_Section)
}

VOID VXDINLINE
Fatal_Memory_Handler(VOID)
{
    VMMJmp(Fatal_Memory_Error);
}

VOID VXDINLINE
Begin_Nest_Exec(VOID)
{
    VMMCall(Begin_Nest_Exec)
}

VOID VXDINLINE
End_Nest_Exec(VOID)
{
    VMMCall(End_Nest_Exec)
}

VOID VXDINLINE
Resume_Exec(VOID)
{
    VMMCall(Resume_Exec)
}

VOID VXDINLINE
Enable_Touch_1st_Meg(VOID)
{
    VMMCall(Enable_Touch_1st_Meg)
}

VOID VXDINLINE
Disable_Touch_1st_Meg(VOID)
{
    VMMCall(Disable_Touch_1st_Meg)
}

VOID VXDINLINE
Out_Debug_String(PCHAR psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

VOID VXDINLINE
Queue_Debug_String(PCHAR psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#endif  // _VMM_

#define MAKE_HEADER(RetType, DecType, Function, Parameters) \
extern  RetType DecType CAT(LCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(ICODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(PCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(SCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(DCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(CCODE_, CAT(Function, Parameters));

#define PREPEND(Name)       CURSEG()##_##Name

#ifdef  _VMM_

WORD VXDINLINE
Get_VMM_Version(VOID)
{
    WORD    w;
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(PVOID,_cdecl, _MapPhysToLinear, (ULONG PhysAddr, ULONG nBytes, ULONG flags))
MAKE_HEADER(PVOID,_cdecl,_HeapAllocate, (ULONG Bytes, ULONG Flags))
MAKE_HEADER(ULONG,_cdecl,_HeapFree, (PVOID Address, ULONG Flags))
MAKE_HEADER(PVOID,_cdecl,_HeapReAllocate, (PVOID pOld, ULONG Bytes, ULONG Flags))
MAKE_HEADER(ULONG,_cdecl,_HeapGetSize, (PVOID p, ULONG Flags))
MAKE_HEADER(VOID,_stdcall,Fatal_Error_Handler, (PCHAR pszMessage, DWORD dwExitFlag))
MAKE_HEADER(VOID,_stdcall,Begin_Critical_Section, (ULONG Flags))
MAKE_HEADER(HEVENT,_stdcall,Schedule_Global_Event, (VMM_EVENT_HANDLER pfnEvent, ULONG ulRefData))
MAKE_HEADER(VOID,_stdcall,Cancel_Global_Event, (HEVENT hEvent));
MAKE_HEADER(HVM,_cdecl,Get_Sys_VM_Handle, (VOID))
MAKE_HEADER(DWORD,_stdcall,Get_Profile_Hex_Int, (PCHAR pszSection, PCHAR pszKeyName, DWORD dwDefault))
MAKE_HEADER(BOOL,_stdcall,Get_Profile_Boolean, (PCHAR pszSection, PCHAR pszKeyName, BOOL fDefault))
MAKE_HEADER(VMM_SEMAPHORE,_stdcall,Create_Semaphore, (LONG lTokenCount))
MAKE_HEADER(VOID,_stdcall,Destroy_Semaphore, (VMM_SEMAPHORE vsSemaphore))
MAKE_HEADER(VOID,_stdcall,Signal_Semaphore, (VMM_SEMAPHORE vsSemaphore))
MAKE_HEADER(VOID,_stdcall,Wait_Semaphore, (VMM_SEMAPHORE vsSemaphore, DWORD dwFlags))
MAKE_HEADER(HVM,_cdecl,Get_Execution_Focus, (VOID))
MAKE_HEADER(HTIMEOUT,_stdcall,Set_VM_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(HTIMEOUT,_stdcall,Set_Global_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(VOID,_stdcall,Cancel_Time_Out, (HTIMEOUT htimeout))
MAKE_HEADER(VOID,_stdcall,Update_System_Clock, (ULONG msElapsed))
MAKE_HEADER(BOOL,_stdcall,Install_Exception_Handler, (PVMMEXCEPTION pveException))
MAKE_HEADER(PCHAR,_stdcall,Get_Exec_Path, (PULONG pulPathLength))
MAKE_HEADER(DWORD,_cdecl,Get_Last_Updated_System_Time, (VOID))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Allocate, (VMMLIST List))
MAKE_HEADER(VOID,_stdcall,List_Attach, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Attach_Tail, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VMMLIST,_stdcall,List_Create, (ULONG Flags, ULONG NodeSize))
MAKE_HEADER(VOID,_stdcall,List_Deallocate, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Destroy, (VMMLIST List))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Get_First, (VMMLIST List))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Get_Next, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Insert, (VMMLIST List, VMMLISTNODE NewNode, VMMLISTNODE Node))
MAKE_HEADER(BOOL,_stdcall,List_Remove, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Remove_First, (VMMLIST List))
MAKE_HEADER(PVOID,_cdecl,_PageAllocate, (DWORD nPages, DWORD pType, HVM hvm, DWORD AlignMask, DWORD minPhys, DWORD maxPhys, PVOID *PhysAddr, DWORD flags))
MAKE_HEADER(BOOL,_cdecl,_PageFree, (PVOID hMem, DWORD flags))
MAKE_HEADER(DWORD,_cdecl,_AddFreePhysPage, (ULONG PhysPgNum, ULONG nPages, ULONG flags, VMMSWP pfnSwapOutNotify))

//MAKE_HEADER(WORD,_cdecl,_Allocate_GDT_Selector, (DESCDWORDS DescDWORDS, ULONG flags))
//MAKE_HEADER(DESCDWORDS,_cdecl,_BuildDescriptorDWORDs, (DWORD DESCBase, DWORD DESCLimit, DWORD DESCType, DWORD DESCSize, ULONG flags))
//MAKE_HEADER(BOOL,_cdecl,_Free_GDT_Selector, (WORD Selector, ULONG flags))
MAKE_HEADER(HVM,_cdecl,Get_Cur_VM_Handle, (VOID))
MAKE_HEADER(HVM,_cdecl,_LinPageLock, (DWORD HLinPgNum, DWORD nPages, DWORD flags))
MAKE_HEADER(HVM,_cdecl,_LinPageUnlock, (DWORD HLinPgNum, DWORD nPages, DWORD flags))

#ifdef  WIN40SERVICES

MAKE_HEADER(ULONG,_cdecl,VMM_GetSystemInitState, (VOID))
MAKE_HEADER(VOID,_stdcall,_Trace_Out_Service, (PCHAR psz))
MAKE_HEADER(VOID,_stdcall,_Debug_Out_Service, (PCHAR psz))
MAKE_HEADER(VOID,_stdcall,_Debug_Flags_Service, (ULONG flags))
MAKE_HEADER(VOID,_cdecl,_Debug_Printf_Service, (PCHAR pszfmt, ...))
MAKE_HEADER(HTIMEOUT,_stdcall, Set_Async_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(PVMMDDB,_stdcall,Get_DDB, (WORD DeviceID, PCHAR Name))
MAKE_HEADER(DWORD,_stdcall,Directed_Sys_Control, (PVMMDDB pDDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI))
MAKE_HEADER(BOOL,_cdecl,_Assert_Range, (PVOID p, ULONG ulSize, SIGNATURE sSignature, LONG lSignatureOffset, ULONG ulFlags))
MAKE_HEADER(ULONG,_cdecl,_Sprintf, (PCHAR pszBuf, PCHAR pszFmt, ...))
MAKE_HEADER(PVMMMUTEX,_cdecl,_CreateMutex, (LONG Boost, ULONG Flags))
MAKE_HEADER(BOOL,_cdecl,_DestroyMutex, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_EnterMutex, (PVMMMUTEX hmtx, ULONG Flags))
MAKE_HEADER(PTCB,_cdecl,_GetMutexOwner, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_LeaveMutex, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_SignalID, (DWORD id))
MAKE_HEADER(VOID,_cdecl,_BlockOnID, (DWORD id, ULONG Flags))
MAKE_HEADER(PCHAR,_cdecl,_lstrcpyn,(PCHAR pszDest,const char *pszSrc,DWORD cb))
MAKE_HEADER(ULONG,_cdecl,_lstrlen,(const char *psz))
MAKE_HEADER(ULONG,_cdecl,_lmemcpy,(PVOID pDst, const void *pSrc, DWORD cb))
MAKE_HEADER(DWORD,_cdecl,Get_Boot_Flags, (VOID))
MAKE_HEADER(PTCB,_cdecl,Get_Cur_Thread_Handle, (VOID))
MAKE_HEADER(PVOID,_cdecl,_GetVxDName, (PVOID pLinAddr, PCHAR pBuffer))
MAKE_HEADER(VOID,_cdecl,_Call_On_My_Stack, (VMMCOMS Callback, DWORD LParam, PVOID StackPtr, DWORD StackSize))

#endif  // WIN40SERVICES

#endif  // _VMM_

#ifdef  _SHELL_H

typedef DWORD       SHELL_HINSTANCE;
typedef PVOID       SHELL_FARPROC;

WORD VXDINLINE
SHELL_Get_Version(VOID)
{
    WORD    w;
    VxDCall(SHELL_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(DWORD,_stdcall,SHELL_SYSMODAL_Message, (HVM hvm, DWORD dwMBFlags, PCHAR pszMessage, PCHAR pszCaption))

#ifndef WIN31COMPAT

MAKE_HEADER(APPY_HANDLE,_cdecl,_SHELL_CallAtAppyTime, (APPY_CALLBACK pfnAppyCallBack, DWORD dwRefData, DWORD flAppy, ...))
MAKE_HEADER(BOOL,_cdecl,_SHELL_CancelAppyTimeEvent, (APPY_HANDLE appy_handle))
MAKE_HEADER(BOOL,_cdecl,_SHELL_QueryAppyTimeAvailable, (VOID))
MAKE_HEADER(DWORD,_cdecl,_SHELL_LocalAllocEx, (DWORD fl, DWORD cb, PVOID lpvBuf))
MAKE_HEADER(DWORD,_cdecl,_SHELL_LocalFree, (DWORD hdata))
MAKE_HEADER(DWORD,_cdecl,_SHELL_CallDll, (PCHAR lpszDll, PCHAR lpszProcName, DWORD cbArgs, PVOID lpvArgs))
MAKE_HEADER(DWORD,_cdecl,_SHELL_BroadcastSystemMessage, (DWORD dwFlags, PDWORD lpdwRecipients, DWORD uMsg, DWORD wparam, DWORD lparam))
MAKE_HEADER(SYSBHOOK_HANDLE,_cdecl,_SHELL_HookSystemBroadcast, (SYSBHOOK_CALLBACK pfnSysBHookCallBack, DWORD dwRefData, DWORD dwCallOrder))
MAKE_HEADER(VOID,_cdecl,_SHELL_UnhookSystemBroadcast, (SYSBHOOK_HANDLE SysBHookHandle))
MAKE_HEADER(SHELL_HINSTANCE,_cdecl,_SHELL_LoadLibrary, (PCHAR pszDll))
MAKE_HEADER(VOID,_cdecl,_SHELL_FreeLibrary, (SHELL_HINSTANCE hinstance))
MAKE_HEADER(SHELL_FARPROC,_cdecl,_SHELL_GetProcAddress, (SHELL_HINSTANCE hinstance, PCHAR pszProcName))

#endif  // WIN31COMPAT

#endif  // _SHELL_H

#ifdef  _VMMREG_H

#ifndef WIN31COMPAT

MAKE_HEADER(VMMREGRET,cdecl,_RegOpenKey, (VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegCloseKey, (VMMHKEY hkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegCreateKey, (VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegDeleteKey, (VMMHKEY hkey, PCHAR lpszSubKey))
MAKE_HEADER(VMMREGRET,cdecl,_RegEnumKey, (VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryValue, (VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue))
MAKE_HEADER(VMMREGRET,cdecl,_RegSetValue, (VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegDeleteValue, (VMMHKEY hkey, PCHAR lpszValue))
MAKE_HEADER(VMMREGRET,cdecl,_RegEnumValue, (VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PVOID lpbData, PDWORD lpcbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryValueEx, (VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PVOID lpbData, PDWORD lpcbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegSetValueEx, (VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PVOID lpbData, DWORD cbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegFlushKey, (VMMHKEY hkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryInfoKey, (VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, \
                        PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime))
MAKE_HEADER(VMMREGRET,cdecl,_RegRemapPreDefKey, (VMMHKEY hkey,VMMHKEY hkRootKey))
MAKE_HEADER(ULONG,cdecl,_GetRegistryPath, (PVMMDDB ThisDDB, PVOID pUserBuff, ULONG ulUserBuffSize))
MAKE_HEADER(VMMREGRET,cdecl,_GetRegistryKey, (DWORD dwType, PCHAR lpszDevName, DWORD dwFlags, PVMMHKEY lpHkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegCreateDynKey, (PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryMultipleValues, (VMMHKEY hKey,PVOID val_list,DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize))

#endif  // WIN31COMPAT

#endif  // _VWWREG_H

#ifdef  _VXDLDR_H

typedef struct DeviceInfo   *PDEVICEINFO;
typedef PDEVICEINFO     *PPDEVICEINFO;

WORD VXDINLINE
VXDLDR_GetVersion(VOID)
{
    WORD    w;
    VxDCall(VXDLDR_GetVersion);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_LoadDevice, (PPVMMDDB ppDDB, PPDEVICEINFO ppDeviceHandle, PCHAR Filename, BOOL InitDevice))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_UnloadDevice, (USHORT DevID, PCHAR szName))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_DevInitSucceeded, (PDEVICEINFO DeviceHandle))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_DevInitFailed, (PDEVICEINFO DeviceHandle))
MAKE_HEADER(PDEVICEINFO,_cdecl,VXDLDR_GetDeviceList, (VOID))

#endif  // _VXDLDR_H

#ifdef _VCOMM_H

WORD VXDINLINE
VCOMM_Get_Version(VOID)
{
    WORD    w;
    VxDCall(VCOMM_Get_Version);
    _asm mov [w], ax
    return(w);
}

// VCOMM headers
#ifndef HPORT
    #define HPORT   DWORD
#endif

MAKE_HEADER(BOOL, _cdecl, _VCOMM_Register_Port_Driver, (PFN InitFn))
MAKE_HEADER(ULONG, _cdecl, _VCOMM_Acquire_Port, (HANDLE PHandle, ULONG PortNum, ULONG OwnerVM, ULONG flags, char *PortName))
MAKE_HEADER(void, _cdecl, _VCOMM_Release_Port,(ULONG PortHandle, ULONG OwnerVM))
MAKE_HEADER(HPORT, _cdecl, _VCOMM_OpenComm, (char *PortName, ULONG VMId))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetCommState, (HPORT hPort, _DCB *pDcb, DWORD ActionMask))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommState, (HPORT hPort, _DCB *pDcb))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetupComm, (HPORT hPort,BYTE *RxBase, ULONG RxLength, BYTE *TxBase, ULONG TxLength))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_TransmitCommChar, (HPORT hPort, char ch))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_CloseComm, (HPORT hPort))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommQueueStatus, (HPORT hPort, _COMSTAT *pComStat))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_ClearCommError, (HPORT hPort, _COMSTAT *pComstat, ULONG *perror))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetModemStatus, (HPORT hPort, ULONG *pModemStatus))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommProperties, (HPORT hPort, _COMMPROP *pCommprop))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_EscapeCommFunction, (HPORT hPort, long lFunc, long IData, long OData))
// MAKE_HEADER(BOOL, _cdecl, _VCOMM_DeviceIOControl, (HPORT hPort, long IOCTL, long IData, long cbIData, long OData, long cbOData, long *cbBytesReturned))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_PurgeComm, (HPORT hPort, long QueueType))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetCommEventMask, (HPORT hPort, long EvtMask, long *dwEvents))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommEventMask, (HPORT hPort, long EvtMaskToClear, long *dwEvents))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_WriteComm, (HPORT hPort, char *lpBuf, ULONG ToWrite,ULONG *Written))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_ReadComm, (HPORT hPort, char *lpBuf, long ToRead, long *Read))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_EnableCommNotification, (HPORT hPort, PVOID Fn, long ReferenceData))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_GetLastError, (HPORT hPort))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Steal_Port, (ULONG PortHandle, ULONG VMHandle))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetReadCallBack, (HPORT hPort, ULONG RecvTrigger, PVOID FnReadEvent, ULONG RefData))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetWriteCallBack, (HPORT hPort,ULONG SendTrigger, PVOID FnWriteEvent, ULONG RefData))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Add_Port, (DWORD refData, PFN PortEntry, char *PortName))

#ifndef WIN31COMPAT
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetSetCommTimeouts, (HPORT hPort, LPCOMMTIMEOUTS lpct, DWORD dwAction))
MAKE_HEADER(IORequest * , _cdecl, _VCOMM_SetWriteRequest, (HPORT hPort, IORequest *ioreq, ULONG *lpNumWritten))
MAKE_HEADER(IORequest *, _cdecl, _VCOMM_SetReadRequest, (HPORT hPort,IORequest *ioreq, ULONG *lpNumRead))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Dequeue_Request,(DWORD listElement, PDWORD  lpcbTransfer))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_Enumerate_DevNodes, (void))
MAKE_HEADER(PFN, _cdecl, _VCOMM_Get_Contention_Handler, (char *PortName))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_Map_Name_To_Resource, (char *PortName))
#endif

#endif          // _VCOMM_H

#ifdef      _IRS_H
MAKE_HEADER(void, _cdecl, IOS_Requestor_Service, (ULONG p))
#endif      // _IRS_H

#ifdef      _INC_VPOWERD

WORD VXDINLINE
VPOWERD_Get_Version(VOID)
{
    WORD    w;
    VxDCall(_VPOWERD_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(DWORD, _cdecl, _VPOWERD_Get_APM_BIOS_Version, (VOID))
MAKE_HEADER(DWORD, _cdecl, _VPOWERD_Get_Power_Management_Level, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_Power_Management_Level, (DWORD Power_Management_Level))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_Device_Power_State, (POWER_DEVICE_ID Power_Device_ID, POWER_STATE Power_State))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_System_Power_State, (POWER_STATE Power_State, DWORD Request_Type))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Restore_Power_On_Defaults, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Get_Power_Status, (POWER_DEVICE_ID Power_Device_ID, LPPOWER_STATUS pPower_Status))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Get_Power_State, (POWER_DEVICE_ID Power_Device_ID, LPPOWER_STATE pPower_State))
MAKE_HEADER(VOID, _cdecl, _VPOWERD_OEM_APM_Function, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Register_Power_Handler, (POWER_HANDLER Power_Handler, DWORD Priority))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Deregister_Power_Handler, (POWER_HANDLER Power_Handler));

#endif      // _INC_VPOWERD

#define _MapPhysToLinear        PREPEND(_MapPhysToLinear)
#define _HeapAllocate           PREPEND(_HeapAllocate)
#define _HeapFree           PREPEND(_HeapFree)
#define _HeapReAllocate         PREPEND(_HeapReAllocate)
#define _HeapGetSize            PREPEND(_HeapGetSize)
#define _Trace_Out_Service      PREPEND(_Trace_Out_Service)
#define _Debug_Out_Service      PREPEND(_Debug_Out_Service)
#define _Debug_Flags_Service        PREPEND(_Debug_Flags_Service)
#define _Debug_Printf_Service       PREPEND(_Debug_Printf_Service)
#define Fatal_Error_Handler     PREPEND(Fatal_Error_Handler)
#define Begin_Critical_Section      PREPEND(Begin_Critical_Section)
#define Schedule_Global_Event       PREPEND(Schedule_Global_Event)
#define Cancel_Global_Event     PREPEND(Cancel_Global_Event)
#define Get_Sys_VM_Handle       PREPEND(Get_Sys_VM_Handle)
#define Get_Profile_Hex_Int     PREPEND(Get_Profile_Hex_Int)
#define Get_Profile_Boolean	PREPEND(Get_Profile_Boolean)
#define Create_Semaphore        PREPEND(Create_Semaphore)
#define Destroy_Semaphore       PREPEND(Destroy_Semaphore)
#define Signal_Semaphore        PREPEND(Signal_Semaphore)
#define Wait_Semaphore          PREPEND(Wait_Semaphore)
#define Get_Execution_Focus     PREPEND(Get_Execution_Focus)
#define Set_VM_Time_Out         PREPEND(Set_VM_Time_Out)
#define Set_Global_Time_Out     PREPEND(Set_Global_Time_Out)
#define Cancel_Time_Out         PREPEND(Cancel_Time_Out)
#define Update_System_Clock     PREPEND(Update_System_Clock)
#define Set_Async_Time_Out      PREPEND(Set_Async_Time_Out)
#define Get_Last_Updated_System_Time    PREPEND(Get_Last_Updated_System_Time)
#define List_Allocate           PREPEND(List_Allocate)
#define List_Attach         PREPEND(List_Attach)
#define List_Attach_Tail        PREPEND(List_Attach_Tail)
#define List_Create         PREPEND(List_Create)
#define List_Deallocate         PREPEND(List_Deallocate)
#define List_Destroy            PREPEND(List_Destroy)
#define List_Get_First          PREPEND(List_Get_First)
#define List_Get_Next           PREPEND(List_Get_Next)
#define List_Insert         PREPEND(List_Insert)
#define List_Remove         PREPEND(List_Remove)
#define List_Remove_First       PREPEND(List_Remove_First)
#define Get_DDB             PREPEND(Get_DDB)
#define Directed_Sys_Control        PREPEND(Directed_Sys_Control)
#define Install_Exeption_Handler    PREPEND(Install_Exeption_Handler)
#define _Assert_Range           PREPEND(_Assert_Range)
#define _Sprintf            PREPEND(_Sprintf)
#define _PageAllocate           PREPEND(_PageAllocate)
#define _PageFree           PREPEND(_PageFree)
#define _AddFreePhysPage        PREPEND(_AddFreePhysPage)
#define Get_Cur_VM_Handle       PREPEND(Get_Cur_VM_Handle)
#define _CreateMutex            PREPEND(_CreateMutex)
#define _DestroyMutex           PREPEND(_DestroyMutex)
#define _EnterMutex         PREPEND(_EnterMutex)
#define _GetMutexOwner          PREPEND(_GetMutexOwner)
#define _LeaveMutex         PREPEND(_LeaveMutex)
#define _SignalID           PREPEND(_SignalID)
#define _BlockOnID          PREPEND(_BlockOnID)
#define _lstrcpyn	    PREPEND(_lstrcpyn)
#define _lstrlen	    PREPEND(_lstrlen)
#define _lmemcpy	    PREPEND(_lmemcpy)
#define VMM_GetSystemInitState      PREPEND(VMM_GetSystemInitState)
#define Get_Boot_Flags          PREPEND(Get_Boot_Flags)
#define Get_Cur_Thread_Handle       PREPEND(Get_Cur_Thread_Handle)
#define	_GetVxDName		PREPEND(_GetVxDName)
#define	_Call_On_My_Stack	PREPEND(_Call_On_My_Stack)
#define	_LinPageLock		PREPEND(_LinPageLock)
#define	_LinPageUnlock		PREPEND(_LinPageUnlock)
#define _SHELL_CallAtAppyTime       PREPEND(_SHELL_CallAtAppyTime)
#define _SHELL_CancelAppyTimeEvent  PREPEND(_SHELL_CancelAppyTimeEvent)
#define _SHELL_QueryAppyTimeAvailable   PREPEND(_SHELL_QueryAppyTimeAvailable)
#define _SHELL_LocalAllocEx     PREPEND(_SHELL_LocalAllocEx)
#define _SHELL_LocalFree        PREPEND(_SHELL_LocalFree)
#define _SHELL_CallDll          PREPEND(_SHELL_CallDll)
#define _SHELL_BroadcastSystemMessage   PREPEND(_SHELL_BroadcastSystemMessage)
#define _SHELL_HookSystemBroadcast  PREPEND(_SHELL_HookSystemBroadcast)
#define _SHELL_UnhookSystemBroadcast    PREPEND(_SHELL_UnhookSystemBroadcast)
#define _SHELL_LoadLibrary      PREPEND(_SHELL_LoadLibrary)
#define _SHELL_FreeLibrary      PREPEND(_SHELL_FreeLibrary)
#define _SHELL_GetProcAddress       PREPEND(_SHELL_GetProcAddress)
#define SHELL_SYSMODAL_Message      PREPEND(SHELL_SYSMODAL_Message)
#define _RegOpenKey         PREPEND(_RegOpenKey)
#define _RegCloseKey            PREPEND(_RegCloseKey)
#define _RegCreateKey           PREPEND(_RegCreateKey)
#define _RegCreateDynKey        PREPEND(_RegCreateDynKey)
#define _RegQueryMultipleValues PREPEND(_RegQueryMultipleValues)
#define _RegDeleteKey           PREPEND(_RegDeleteKey)
#define _RegEnumKey         PREPEND(_RegEnumKey)
#define _RegQueryValue          PREPEND(_RegQueryValue)
#define _RegSetValue            PREPEND(_RegSetValue)
#define _RegDeleteValue         PREPEND(_RegDeleteValue)
#define _RegEnumValue           PREPEND(_RegEnumValue)
#define _RegQueryValueEx        PREPEND(_RegQueryValueEx)
#define _RegSetValueEx          PREPEND(_RegSetValueEx)
#define _RegFlushKey            PREPEND(_RegFlushKey)
#define _RegQueryInfoKey        PREPEND(_RegQueryInfoKey)
#define _RegRemapPreDefKey      PREPEND(_RegRemapPreDefKey)
#define _GetRegistryPath        PREPEND(_GetRegistryPath)
#define _GetRegistryKey         PREPEND(_GetRegistryKey)
#define VXDLDR_LoadDevice       PREPEND(VXDLDR_LoadDevice)
#define VXDLDR_UnloadDevice     PREPEND(VXDLDR_UnloadDevice)
#define VXDLDR_DevInitSucceeded     PREPEND(VXDLDR_DevInitSucceeded)
#define VXDLDR_DevInitFailed        PREPEND(VXDLDR_DevInitFailed)
#define VXDLDR_GetDeviceList        PREPEND(VXDLDR_GetDeviceList)
#define Get_Exec_Path           PREPEND(Get_Exec_Path)
#define CM_Initialize           PREPEND(_CONFIGMG_Initialize)
#define CM_Locate_DevNode       PREPEND(_CONFIGMG_Locate_DevNode)
#define CM_Get_Parent           PREPEND(_CONFIGMG_Get_Parent)
#define CM_Get_Child            PREPEND(_CONFIGMG_Get_Child)
#define CM_Get_Sibling          PREPEND(_CONFIGMG_Get_Sibling)
#define CM_Get_Device_ID_Size       PREPEND(_CONFIGMG_Get_Device_ID_Size)
#define CM_Get_Device_ID        PREPEND(_CONFIGMG_Get_Device_ID)
#define CM_Get_Depth            PREPEND(_CONFIGMG_Get_Depth)
#define CM_Get_Private_DWord        PREPEND(_CONFIGMG_Get_Private_DWord)
#define CM_Set_Private_DWord        PREPEND(_CONFIGMG_Set_Private_DWord)
#define CM_Create_DevNode       PREPEND(_CONFIGMG_Create_DevNode)
#define CM_Query_Remove_SubTree     PREPEND(_CONFIGMG_Query_Remove_SubTree)
#define CM_Remove_SubTree       PREPEND(_CONFIGMG_Remove_SubTree)
#define CM_Register_Device_Driver   PREPEND(_CONFIGMG_Register_Device_Driver)
#define CM_Register_Enumerator      PREPEND(_CONFIGMG_Register_Enumerator)
#define CM_Register_Arbitrator      PREPEND(_CONFIGMG_Register_Arbitrator)
#define CM_Deregister_Arbitrator    PREPEND(_CONFIGMG_Deregister_Arbitrator)
#define CM_Query_Arbitrator_Free_Size   PREPEND(_CONFIGMG_Query_Arbitrator_Free_Size)
#define CM_Query_Arbitrator_Free_Data   PREPEND(_CONFIGMG_Query_Arbitrator_Free_Data)
#define CM_Sort_NodeList        PREPEND(_CONFIGMG_Sort_NodeList)
#define CM_Yield            PREPEND(_CONFIGMG_Yield)
#define CM_Lock             PREPEND(_CONFIGMG_Lock)
#define CM_Unlock           PREPEND(_CONFIGMG_Unlock)
#define CM_Add_Empty_Log_Conf       PREPEND(_CONFIGMG_Add_Empty_Log_Conf)
#define CM_Free_Log_Conf        PREPEND(_CONFIGMG_Free_Log_Conf)
#define CM_Get_First_Log_Conf       PREPEND(_CONFIGMG_Get_First_Log_Conf)
#define CM_Get_Next_Log_Conf        PREPEND(_CONFIGMG_Get_Next_Log_Conf)
#define CM_Add_Res_Des          PREPEND(_CONFIGMG_Add_Res_Des)
#define CM_Modify_Res_Des       PREPEND(_CONFIGMG_Modify_Res_Des)
#define CM_Free_Res_Des         PREPEND(_CONFIGMG_Free_Res_Des)
#define CM_Get_Next_Res_Des     PREPEND(_CONFIGMG_Get_Next_Res_Des)
#define CM_Get_Res_Des_Header_Size  PREPEND(_CONFIGMG_Get_Res_Des_Header_Size)
#define CM_Get_Res_Des_Data_Size    PREPEND(_CONFIGMG_Get_Res_Des_Data_Size)
#define CM_Get_Res_Des_Data     PREPEND(_CONFIGMG_Get_Res_Des_Data)
#define CM_Process_Events_Now       PREPEND(_CONFIGMG_Process_Events_Now)
#define CM_Create_Range_List        PREPEND(_CONFIGMG_Create_Range_List)
#define CM_Add_Range            PREPEND(_CONFIGMG_Add_Range)
#define CM_Delete_Range         PREPEND(_CONFIGMG_Delete_Range)
#define CM_Test_Range_Available     PREPEND(_CONFIGMG_Test_Range_Available)
#define CM_Dup_Range_List       PREPEND(_CONFIGMG_Dup_Range_List)
#define CM_Free_Range_List      PREPEND(_CONFIGMG_Free_Range_List)
#define CM_Invert_Range_List        PREPEND(_CONFIGMG_Invert_Range_List)
#define CM_Intersect_Range_List     PREPEND(_CONFIGMG_Intersect_Range_List)
#define CM_First_Range          PREPEND(_CONFIGMG_First_Range)
#define CM_Next_Range           PREPEND(_CONFIGMG_Next_Range)
#define CM_Dump_Range_List      PREPEND(_CONFIGMG_Dump_Range_List)
#define CM_Load_DLVxDs          PREPEND(_CONFIGMG_Load_DLVxDs)
#define CM_Get_DDBs         PREPEND(_CONFIGMG_Get_DDBs)
#define CM_Get_CRC_CheckSum     PREPEND(_CONFIGMG_Get_CRC_CheckSum)
#define CM_Register_DevLoader       PREPEND(_CONFIGMG_Register_DevLoader)
#define CM_Reenumerate_DevNode      PREPEND(_CONFIGMG_Reenumerate_DevNode)
#define CM_Setup_DevNode        PREPEND(_CONFIGMG_Setup_DevNode)
#define CM_Reset_Children_Marks     PREPEND(_CONFIGMG_Reset_Children_Marks)
#define CM_Get_DevNode_Status       PREPEND(_CONFIGMG_Get_DevNode_Status)
#define CM_Remove_Unmarked_Children PREPEND(_CONFIGMG_Remove_Unmarked_Children)
#define CM_ISAPNP_To_CM         PREPEND(_CONFIGMG_ISAPNP_To_CM)
#define CM_CallBack_Device_Driver   PREPEND(_CONFIGMG_CallBack_Device_Driver)
#define CM_CallBack_Enumerator      PREPEND(_CONFIGMG_CallBack_Enumerator)
#define CM_Get_Alloc_Log_Conf       PREPEND(_CONFIGMG_Get_Alloc_Log_Conf)
#define CM_Get_DevNode_Key_Size     PREPEND(_CONFIGMG_Get_DevNode_Key_Size)
#define CM_Get_DevNode_Key      PREPEND(_CONFIGMG_Get_DevNode_Key)
#define CM_Read_Registry_Value      PREPEND(_CONFIGMG_Read_Registry_Value)
#define CM_Write_Registry_Value     PREPEND(_CONFIGMG_Write_Registry_Value)
#define CM_Disable_DevNode      PREPEND(_CONFIGMG_Disable_DevNode)
#define CM_Enable_DevNode       PREPEND(_CONFIGMG_Enable_DevNode)
#define CM_Move_DevNode         PREPEND(_CONFIGMG_Move_DevNode)
#define CM_Set_Bus_Info         PREPEND(_CONFIGMG_Set_Bus_Info)
#define CM_Get_Bus_Info         PREPEND(_CONFIGMG_Get_Bus_Info)
#define CM_Set_HW_Prof          PREPEND(_CONFIGMG_Set_HW_Prof)
#define CM_Recompute_HW_Prof        PREPEND(_CONFIGMG_Recompute_HW_Prof)
#define CM_Get_Device_Driver_Private_DWord  PREPEND(_CONFIGMG_Get_Device_Driver_Private_DWord)
#define CM_Set_Device_Driver_Private_DWord  PREPEND(_CONFIGMG_Set_Device_Driver_Private_DWord)
#define CM_Query_Change_HW_Prof     PREPEND(_CONFIGMG_Query_Change_HW_Prof)
#define CM_Get_HW_Prof_Flags        PREPEND(_CONFIGMG_Get_HW_Prof_Flags)
#define CM_Set_HW_Prof_Flags        PREPEND(_CONFIGMG_Set_HW_Prof_Flags)
#define CM_Read_Registry_Log_Confs  PREPEND(_CONFIGMG_Read_Registry_Log_Confs)
#define CM_Run_Detection        PREPEND(_CONFIGMG_Run_Detection)
#define CM_Call_At_Appy_Time        PREPEND(_CONFIGMG_Call_At_Appy_Time)
#define CM_Fail_Change_HW_Prof      PREPEND(_CONFIGMG_Fail_Change_HW_Prof)
#define CM_Set_Private_Problem      PREPEND(_CONFIGMG_Set_Private_Problem)
#define CM_Debug_DevNode        PREPEND(_CONFIGMG_Debug_DevNode)
#define CM_Get_Hardware_Profile_Info    PREPEND(_CONFIGMG_Get_Hardware_Profile_Info)
#define CM_Register_Enumerator_Function	PREPEND(_CONFIGMG_Register_Enumerator_Function)
#define CM_Call_Enumerator_Function	PREPEND(_CONFIGMG_Call_Enumerator_Function)
#define CM_Add_ID			PREPEND(_CONFIGMG_Add_ID)
#define CM_Find_Range			PREPEND(_CONFIGMG_Find_Range)
#define CM_Get_Global_State		PREPEND(_CONFIGMG_Get_Global_State)
#define CM_Broadcast_Device_Change_Message	PREPEND(_CONFIGMG_Broadcast_Device_Change_Message)
#define CM_Call_DevNode_Handler		PREPEND(_CONFIGMG_Call_DevNode_Handler)
#define CM_Remove_Reinsert_All			PREPEND(_CONFIGMG_Remove_Reinsert_All)

#ifdef _VCOMM_H
#define VCOMM_Register_Port_Driver      PREPEND(_VCOMM_Register_Port_Driver)
#define VCOMM_Acquire_Port              PREPEND(_VCOMM_Acquire_Port)
#define VCOMM_Release_Port              PREPEND(_VCOMM_Release_Port)
#define VCOMM_OpenComm                  PREPEND(_VCOMM_OpenComm)
#define VCOMM_SetCommState              PREPEND(_VCOMM_SetCommState)
#define VCOMM_GetCommState              PREPEND(_VCOMM_GetCommState)
#define VCOMM_SetupComm                 PREPEND(_VCOMM_SetupComm)
#define VCOMM_TransmitCommChar          PREPEND(_VCOMM_TransmitCommChar)
#define VCOMM_CloseComm                 PREPEND(_VCOMM_CloseComm)
#define VCOMM_GetCommQueueStatus        PREPEND(_VCOMM_GetCommQueueStatus)
#define VCOMM_ClearCommError            PREPEND(_VCOMM_ClearCommError)
#define VCOMM_GetModemStatus            PREPEND(_VCOMM_GetModemStatus)
#define VCOMM_GetCommProperties         PREPEND(_VCOMM_GetCommProperties)
#define VCOMM_EscapeCommFunction        PREPEND(_VCOMM_EscapeCommFunction)
// #define VCOMM_DeviceIOControl           PREPEND(_VCOMM_DeviceIOControl)
#define VCOMM_PurgeComm                 PREPEND(_VCOMM_PurgeComm)
#define VCOMM_SetCommEventMask          PREPEND(_VCOMM_SetCommEventMask)
#define VCOMM_GetCommEventMask          PREPEND(_VCOMM_GetCommEventMask)
#define VCOMM_WriteComm                 PREPEND(_VCOMM_WriteComm)
#define VCOMM_ReadComm                  PREPEND(_VCOMM_ReadComm)
#define VCOMM_EnableCommNotification    PREPEND(_VCOMM_EnableCommNotification)
#define VCOMM_GetLastError              PREPEND(_VCOMM_GetLastError)
#define VCOMM_Steal_Port                PREPEND(_VCOMM_Steal_Port)
#define VCOMM_SetReadCallBack           PREPEND(_VCOMM_SetReadCallBack)
#define VCOMM_SetWriteCallBack          PREPEND(_VCOMM_SetWriteCallBack)
#define VCOMM_Add_Port                  PREPEND(_VCOMM_Add_Port)

#ifndef WIN31COMPAT
#define VCOMM_GetSetCommTimeouts        PREPEND(_VCOMM_GetSetCommTimeouts)
#define VCOMM_SetWriteRequest           PREPEND(_VCOMM_SetWriteRequest)
#define VCOMM_SetReadRequest            PREPEND(_VCOMM_SetReadRequest)
#define VCOMM_Dequeue_Request           PREPEND(_VCOMM_Dequeue_Request)
#define VCOMM_Enumerate_DevNodes        PREPEND(_VCOMM_Enumerate_DevNodes)
#define VCOMM_Get_Contention_Handler    PREPEND(_VCOMM_Get_Contention_Handler)
#define VCOMM_Map_Name_To_Resource  PREPEND(_VCOMM_Map_Name_To_Resource)
#endif
#endif // _VCOMM_H

#ifdef      _IRS_H
#define IOS_Requestor_Service       PREPEND(IOS_Requestor_Service)
#endif      // _IRS_H

#ifdef      _INC_VPOWERD

#define _VPOWERD_Get_APM_BIOS_Version       PREPEND(_VPOWERD_Get_APM_BIOS_Version)
#define _VPOWERD_Get_Power_Management_Level PREPEND(_VPOWERD_Get_Power_Management_Level)
#define _VPOWERD_Set_Power_Management_Level PREPEND(_VPOWERD_Set_Power_Management_Level)
#define _VPOWERD_Set_Device_Power_State     PREPEND(_VPOWERD_Set_Device_Power_State)
#define _VPOWERD_Set_System_Power_State     PREPEND(_VPOWERD_Set_System_Power_State)
#define _VPOWERD_Restore_Power_On_Defaults  PREPEND(_VPOWERD_Restore_Power_On_Defaults)
#define _VPOWERD_Get_Power_Status       PREPEND(_VPOWERD_Get_Power_Status)
#define _VPOWERD_Get_Power_State        PREPEND(_VPOWERD_Get_Power_State)
#define _VPOWERD_OEM_APM_Function       PREPEND(_VPOWERD_OEM_APM_Function)
#define _VPOWERD_Register_Power_Handler     PREPEND(_VPOWERD_Register_Power_Handler)
#define _VPOWERD_Deregister_Power_Handler   PREPEND(_VPOWERD_Deregister_Power_Handler)

#endif      // _INC_VPOWERD

#endif  // _VXDWRAPS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VDD2.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	vdd2.inc - VDD definitions for Secondary VDD
;
;   Version:	1.00
;
;   Author: MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   02-Aug-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD2

;***************
;VDD2 services for other devices and VMM(Get_Version must be first)
;
VDD2_Service	VDD2_Get_Version	; Get version number and ID string ptr
End_Service_Table VDD2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VKD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	vkd.inc -
;
;   Version:	1.00
;
;   Date:	10-Aug-1988
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Aug-1988 RAP started re-write of VKD
;   03-Nov-1988 RAP separated internal stuff out into VKDSYS.INC
;
;==============================================================================


Begin_Service_Table VKD

VKD_Service	VKD_Get_Version, LOCAL
VKD_Service	VKD_Define_Hot_Key, LOCAL
VKD_Service	VKD_Remove_Hot_Key, LOCAL
VKD_Service	VKD_Local_Enable_Hot_Key, LOCAL
VKD_Service	VKD_Local_Disable_Hot_Key, LOCAL
VKD_Service	VKD_Reflect_Hot_Key, LOCAL
VKD_Service	VKD_Cancel_Hot_Key_State, LOCAL
VKD_Service	VKD_Force_Keys, LOCAL
VKD_Service	VKD_Get_Kbd_Owner, LOCAL
VKD_Service	VKD_Define_Paste_Mode, LOCAL
VKD_Service	VKD_Start_Paste, LOCAL
VKD_Service	VKD_Cancel_Paste, LOCAL
VKD_Service	VKD_Get_Msg_Key, LOCAL
VKD_Service	VKD_Peek_Msg_Key, LOCAL
VKD_Service	VKD_Flush_Msg_Key_Queue, LOCAL

End_Service_Table VKD


VKD_Version	equ 200h


;******************************************************************************
;
; shift state bits for both global & local shift states
;
		      ;;5432109876543210
SS_Shift	equ	0000000000000001b   ; left or right
SS_LShift	equ	0000000000000010b
SS_RShift	equ	0000001000000000b
SS_Ctrl 	equ	0000000010000000b   ; left or right
SS_LCtrl	equ	0000000000000100b
SS_RCtrl	equ	0000010000000000b
SS_Alt		equ	0000000100000000b   ; left or right
SS_LAlt 	equ	0000000000001000b
SS_RAlt 	equ	0000100000000000b
SS_CapLock	equ	0000000001000000b
SS_NumLock	equ	0000000000100000b
SS_ScrlLock	equ	0000000000010000b
SS_CapLock_Dn	equ	0100000000000000b   ; SS_CapLock shl 8
SS_NumLock_Dn	equ	0010000000000000b   ; SS_NumLock shl 8
SS_ScrlLock_Dn	equ	0001000000000000b   ; SS_ScrlLock shl 8
SS_Unused	equ	1000000000000000b

SS_Toggle_mask	    equ     SS_CapLock + SS_NumLock + SS_ScrlLock
SS_Toggle_Dn_mask   equ     SS_CapLock_Dn + SS_NumLock_Dn + SS_ScrlLock_Dn
SS_LShift_mask	    equ     SS_LShift + SS_LCtrl + SS_LAlt
SS_Shift_mask	    equ     SS_LShift_mask + SS_RShift + SS_RCtrl + SS_RAlt

SS_Either_Shift     equ     SS_LShift + SS_RShift
SS_Either_Ctrl	    equ     SS_LCtrl + SS_RCtrl
SS_Either_Alt	    equ     SS_LAlt + SS_RAlt


; LED state bits
LED_ScLok	equ	1		    ; Scroll Lock
LED_NmLok	equ	2		    ; Num Lock
LED_CpLok	equ	4		    ; Caps Lock
Toggle_To_LED	equ	4		    ; "state shr Toggle_To_LED" converts
					    ; state bits into kybd LED bits


; VKD_Define_Hot_Key equates & macro

ExtendedKey_B	equ 1
ExtendedKey	equ 100h
AllowExtended_B equ 0FFh
AllowExtended	equ 0FF00h


;VKD_Define_Hot_Key flags:

CallOnPress	equ 1		; Call call-back when key press is detected
CallOnRelease	equ 2		; Call call-back when key release is detected
				; (keyboard may still be in hot-key hold state)
CallOnRepeat	equ 4		; Call call-back when repeated press is detected
CallOnComplete	equ 8		; Call call-back when the hot key state is
				; ended (all shift modifier keys are released)
				; or when a different hot key is entered
				; (i.e. pressing ALT 1 2, if both ALT-1
				;  and ALT-2 are defined hot keys, then ALT-1's
				;  call back will be called before ALT-2's to
				;  indicate that the ALT-1 is complete even
				;  though the ALT key is still down)
CallOnUpDwn	equ CallOnPress + CallOnRelease
				; Call call-back on both press and release
CallOnAll	equ 0		; Call call-back on press, release, auto-repeat
				; and complete
PriorityNotify	equ 10h 	; notification calls to the call-back can only
				; happen when interrupts are enabled and
				; the critical section is un-owned
Local_Key	equ 80h 	; key can be locally enabled/disabled

Hot_Key_Pressed     equ 0
Hot_Key_Released    equ 1
Hot_Key_Repeated    equ 2
Hot_Key_Completed   equ 3

Hot_Key_SysVM_Notify	 equ 80h
Hot_Key_SysVM_Notify_bit equ 7

BeginDoc
;******************************************************************************
;
;   ShiftState
;
;   DESCRIPTION:    Macro to aid in setting EBX with the shift state mask and
;		    shift state compare value for calling VKD_Define_Hot_Key.
;
;   USAGE:	    ShiftState mask, compare
;
;		    The mask specifies the shift state bits that should be
;		    excluded before the compare is done.
;
;==============================================================================
EndDoc
ShiftState MACRO mask, compare
	mov	ebx, ((NOT mask) SHL 16) + compare
	   ENDM

; common shift states

HKSS_Shift  equ (NOT (SS_Either_Shift + SS_Toggle_mask)) SHL 16 + SS_Shift
HKSS_Ctrl   equ (NOT (SS_Either_Ctrl + SS_Toggle_mask)) SHL 16 + SS_Ctrl
HKSS_Alt    equ (NOT (SS_Either_Alt + SS_Toggle_mask)) SHL 16 + SS_Alt


; include structure of entries in paste buffer

include VKDpaste.INC


; paste completion flags passed to the paste call-back

Paste_Complete	equ 0	; paste successful
Paste_Aborted	equ 1	; paste aborted by user
Paste_VM_Term	equ 2	; paste aborted because VM terminated

;
; Modifier byte for Message Keys, retrieved with services VKD_Get_Msg_Key and
; VKD_Peek_Msg_Key
;
MK_Shift	equ 00000010b
MK_Ctrl 	equ 00000100b
MK_Alt		equ 00001000b
MK_Extended	equ 10000000b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\RM_AUMGR.H ===
//DOSRM_AU.H contains all the header information for both the
//MPU401 VxD and the ResMan VxD.

// NoteOff priority
//
#define URGENT  0
#define NORMAL 1

#define MAX_NUMVOICES MAX_AUPATCH_INPUT		//max. number of notes for the DOS VxD.

#define	DOSRM_USERNAME	0x6969		//just a random number.

//************ Cut from NV32.H ******************************
	/***** Notification Status Values *****/
	/*
	 * NV sets NvNotification.status to NV_STATUS_DONE_OK if the operation
	 * succeeded.
	 */
	#define NV_STATUS_DONE_OK          0
	/*
	 * Client sets NvNotification.status to NV_STATUS_IN_PROGRESS, NV 
	 * sets to a different value when it notifies.
	 */
	#define NV_STATUS_IN_PROGRESS      255
	/***** NvNotification Structure *****/
	/*
	 * NV objects return information about method completion to clients 
	 * via notification structures in main memory.
	 *
	 * The client sets the status field to NV_STATUS_IN_PROGRESS.
	 * NV sets it to something different when it notifies, after setting 
	 * other fields.  NV fills in the timeStamp; the contents and 
	 * interpretation of the statusInfo, otherInfo32, and OtherInfo16 
	 * fields depend on the status value.  See NV_STATUS_ elsewhere.
	 */
	typedef volatile struct {
	 struct tagNvTimeStamp {
	  U032 nanoseconds[2];           /* Nanoseconds since Jan. 1, 1970 */
	 } timeStamp;                  /*                                 0000-0007*/
	 V032 otherInfo32;             /* info reported depends on method 0008-000b*/
	 V016 otherInfo16;             /* info reported depends on method 000c-000d*/
	 V008 statusInfo;              /* ERROR1 code if (status==ERROR1) 000e-000e*/
	 V008 status;                  /* client sets, NV changes         000f-000f*/
	} NvNotification;

//******************************************

typedef struct {
	NvNotification BufNotify;
} DOSRM_NOTE_STRUC;

//List of possible parameter types accepted by NVChangeParam_HW()
#define VOLUME				0
#define SAMPLE_RATE			1
#define VIBRATO				3
#define TREMOLO				4
#define EFFECTS				5

#define VOICE_UNUSED	(0x0FF)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VKDPASTE.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	vkdpaste.inc -
;
;   Version:	1.00
;
;   Date:	20-Mar-1989
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   20-Mar-1989 RAP
;   23-Mar-1989 RAP added PM API equates
;
;==============================================================================

;
; structure of entries in paste buffer
;
Paste_Rec STRUC
Paste_Char	    db	?   ; OEM char value
Paste_ScanCode	    db	?   ; keyboard scan code
Paste_ShiftState    dw	?   ; shift state
Paste_Rec ENDS

Paste_Key   equ word ptr Paste_Char


;BeginDoc
;------------------------------------------------------------------------------
;
; API services:
;
VKD_API_Version     equ 0
	;   ENTER:  EAX = 0
	;   EXIT:   AH = major version #
	;	    AL = minor version #
	;	    Carry clear

VKD_Current_Version equ 200h

VKD_Force_Key	    equ 1
	;   ENTER:  EAX = 1
	;	    EBX = VM handle  (0 for current)
	;	    CH = scan code
	;	    CL = repeat count
	;	    EDX = shift state  (-1 means no change)
	;   EXIT:   Carry set, if failed

;
; shift state equates
;
FKSS_Insert_Down    equ 1000000000000000b
FKSS_CapLck_Down    equ 0100000000000000b
FKSS_NumLck_Down    equ 0010000000000000b
FKSS_ScrLck_Down    equ 0001000000000000b
FKSS_Insert_On	    equ 0000000010000000b
FKSS_CapLck_On	    equ 0000000001000000b
FKSS_NumLck_On	    equ 0000000000100000b
FKSS_ScrLck_On	    equ 0000000000010000b
FKSS_Alt_Down	    equ 0000000000001000b
FKSS_Ctrl_Down	    equ 0000000000000100b
FKSS_Shift_Down     equ 0000000000000010b

;EndDoc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\SHELL.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	SHELL.Inc - Public services for SHELL
;
;   Version:	1.00
;
;   Date:	30-Nov-1988
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Sep-1988 RAL Original
;   12-Oct-1988 RAL Converted to use VxD_Service macros
;   29-Nov-1988 ARR Redo split from VMCTRL
;
;==============================================================================

Begin_Service_Table SHELL

SHELL_Service  SHELL_Get_Version, LOCAL
SHELL_Service  SHELL_Resolve_Contention
SHELL_Service  SHELL_Event,LOCAL
SHELL_Service  SHELL_SYSMODAL_Message,LOCAL
SHELL_Service  SHELL_Message,LOCAL
;
; Following specific to SHELL version >= 3.10
;
SHELL_Service  SHELL_GetVMInfo, LOCAL

End_Service_Table SHELL

BeginDoc
;
;   Windows Message Box Flags used on SHELL_SYSMODAL_Message and
;	SHELL_Message services
;
MB_OK			 EQU	    00H
MB_OKCANCEL		 EQU	    01H
MB_ABORTRETRYIGNORE	 EQU	    02H
MB_YESNOCANCEL		 EQU	    03H
MB_YESNO		 EQU	    04H
MB_RETRYCANCEL		 EQU	    05H
MB_ICONHAND		 EQU	    010H
MB_ICONEXCLAMATION	 EQU	    030H
MB_ICONASTERISK 	 EQU	    040H
MB_DEFBUTTON1		 EQU	    00H
MB_DEFBUTTON2		 EQU	    0100H
MB_DEFBUTTON3		 EQU	    0200H
MB_APPLMODAL		 EQU	    00H
MB_SYSTEMMODAL		 EQU	    01000H
MB_NOFOCUS		 EQU	    08000H
;
; Following bits are WIN386 SHELL extensions
;
MB_ASAP 		 EQU	    080000000H	; Message is timely, put
						;   up as soon as possible
;
; The following flag bits are 3.10 extensions.
;
MB_NOWINDOW		 EQU	    040000000H	; DO NOT switch to Windows
						;   to do this message, do it
						;   in full screen mode always.
						;   ONLY FOR SHELL_SYSMODAL_Message

MB_HANGSYS		 EQU	    020000000H	; Hang with ints disabled.
						;   This is for especially
						;   severe errors (like parity
						;   errors).
						;   ONLY FOR SHELL_SYSMODAL_Message

;
;   Windows Message Box Return codes used on SHELL_SYSMODAL_Message and
;	SHELL_Message services
;
IDOK                     EQU	1
IDCANCEL                 EQU	2
IDABORT                  EQU	3
IDRETRY                  EQU	4
IDIGNORE                 EQU	5
IDYES                    EQU	6
IDNO                     EQU	7

EndDoc

;
; On SHELL_Event, the wParam in EAX occupies the low 16 bits of EAX. The High 16
;	bits contain extra flags
;
SE_WP_SetFocusBoost	equ	00000000000000010000000000000000b
SE_WP_SetFocusBoostBit	equ	16		; Boost the SYS VM till a
						; Set_Focus call
SE_WP_SwitcherBoost	equ	00000000000000100000000000000000b
SE_WP_SwitcherBoostBit	equ	17		; Boost the SYS VM on Switcher
						;  screen
SE_WP_FilSysChgBoost	equ	00000000000001000000000000000000b
SE_WP_FilSysChgBoostBit equ	18		; Boost the SYS VM till response
						;  to VDA_FileSysChange
SE_WP_ClipAPIBoost	equ	00000000000010000000000000000000b
SE_WP_ClipAPIBoostBit	equ	19		; Boost the SYS VM during clipbrd
						;  API
SE_WP_PrtScBoost	equ	00000000000100000000000000000000b
SE_WP_PrtScBoostBit	equ	20		; Boost the SYS VM during Print screen

SE_WP_DispUpdBoost	equ	00000000001000000000000000000000b
SE_WP_DispUpdBoostBit	equ	21		; Boost the SYS VM during updates

include shellfsc.inc

BeginDoc
;
; Bits of returned EAX flags for SHELL_GetVMInfo service
;
SGVMI_Windowed	  equ 00000000000000000000000000000100B ; Is Windowed
SGVMI_ALTTABdis   equ 00000000000000000000000000100000b ; Alt+Tab is reserved
SGVMI_ALTESCdis   equ 00000000000000000000000001000000b ; Alt+Esc is reserved
SGVMI_ALTSPACEdis equ 00000000000000000000000010000000b ; Alt+Space is reserved
SGVMI_ALTENTERdis equ 00000000000000000000000100000000b ; Alt+Enter is reserved
SGVMI_ALTPRTSCdis equ 00000000000000000000001000000000b ; Alt+PrtSc is reserved
SGVMI_PRTSCdis	  equ 00000000000000000000010000000000b ; PrtSc is reserved
SGVMI_CTRLESCdis  equ 00000000000000000000100000000000b ; Ctrl+Esc is reserved
SGVMI_HasHotKey   equ 00000000000000000100000000000000b ; Has a shortcut key
SGVMI_Polling	  equ 00000000000000000001000000000000b ; Polling detection Enab
SGVMI_FastPaste   equ 00000000000000100000000000000000b ; Allow Fast paste Enab
SGVMI_NoHMA	  equ 00000000000000000010000000000000b ; No HMA
SGVMI_XMS_Lock	  equ 00000000000000010000000000000000b ; XMS Hands Locked
SGVMI_EMS_Lock	  equ 00000000000000001000000000000000b ; EMS Hands Locked
SGVMI_V86_Lock	  equ 00000000000001000000000000000000b ; V86 Memory Locked
SGVMI_ClsExit	  equ 01000000000000000000000000000000b ; Close on Exit Enab

;
; Bits of returned ECX flags for SHELL_GetVMInfo service
;	Currently no bits defined.
;

EndDoc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VMDAVGA.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VMDAVGA.INC
;
;   Version:	3.10
;
;   Date:	15-Aug-1990
;
;   Author: AR, MDW, RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jan-1989 MDW Added service definitions(some from VDAMSG.INC)
;   15-Feb-1989 MDW Memory data structures
;   15-Aug-1990 RAP VGA version of VMDAEGA.INC
;
;==============================================================================



;******************************************************************************
;
;	VDD virtual mode services for the grabber
;
GRB_Get_Version     EQU 0
GRB_Get_Mem	    EQU GRB_Get_Version + 1
GRB_Get_State	    EQU GRB_Get_Mem + 1
GRB_Get_Mod	    EQU GRB_Get_State + 1
GRB_Clear_Mod	    EQU GRB_Get_Mod + 1
GRB_Free_Mem	    EQU GRB_Clear_Mod + 1
GRB_Get_GrbMem	    EQU GRB_Free_Mem + 1
GRB_Free_Grab	    EQU GRB_Get_GrbMem + 1
GRB_Get_GrbState    EQU GRB_Free_Grab + 1
GRB_Unlock_APP	    EQU GRB_Get_GrbState + 1

; New API's for 3.1 display drivers
Private_DspDrvr_1   EQU 0Ah
			    .errnz Private_DspDrvr_1 - GRB_Unlock_APP - 1
DspDrvr_Version     EQU 0Bh
DspDrvr_Addresses   EQU 0Ch


Grabber_VerNum	    EQU     030Ah	    ; version 3, 10


;*******************************************************************************
;
;	Controller state structure
;
VDA_EGA_State	STRUC
    VDA_EGA_Mode    DB	?		; Display mode(0-A)
    VDA_EGA_Colr    DB	?		; Border color
    VDA_EGA_Flags   DB	?		; Flags
    VDA_EGA_Rows    DB	?		; Height of display in lines (text mode)
    VDA_EGA_CurX    DW	?		; Cursor horizontal position
    VDA_EGA_CurY    DW	?		; Cursor vertical position
    VDA_EGA_CurBeg  DW	?		; Cursor start scan line
    VDA_EGA_CurEnd  DW	?		; Cursor end scan line
    VDA_EGA_Pal     DB	16 DUP (?)	; Palettes(6 bits of color mapping)
VDA_EGA_State	ENDS

;*******
;
;	Controller flags
;
fVDA_V_ScOff	    EQU 0001h		; Screen off
fVDA_V_ScOffBit     EQU 0
fVDA_V_HCurTrk	    EQU 0002h		; Horizontal cursor track - keep
fVDA_V_HCurTrkBit   EQU 1		;   cursor position in window
; GEM Ventura programs DAC 0 as white - set if DAC 0 is non-zero
fVDA_V_InvDAC	    EQU 0004h		
fVDA_V_InvDACBit    EQU 2


BeginDoc
;*******************************************************************************
;   EGA/VGA VDD modifications state structure ::= <flag>,<count>,<list>
;
;   <flag> indicates type, list valid and controller change and cursor change.
;   <count> is count of entries(not bytes or words) in list.
;   <list> is type dependent as follows:
;	Type 0 - list is modified pages bit map, 1 bit per displayed 4k page,
;	    count is page count. Bit map is one byte per 32k linear address
;	    space, where byte 0's bits are <page 0 bit>,<page 1 bit>,
;	    ...,<page 7 bit>. byte 1's bits are <page 8 bit>,<page 9 bit>.
;	    A set bit indicates a change in that page.
;
;	    This type is not used for text modes.
;
;	    Modes D and E display is less than two pages long and so the
;	    page count will be two. Mode 10 page count is 7. Modes
;	    11 and 12 page count is 10.
;
;	Type 1 - modified enclosing rectangles, count is rectangle count,
;	    (less than four) , rectangle is two points: <left>,<top> and
;	    <right>,<bottom>. Each point is relative to left, upper
;	    corner which is 0,0 and each value is stored in one word.
;
;	    This type may be used for all modes.
;
;	    For text modes, modes 0-3, there may be a special, scroll rectangle.
;	    If the high bit of R_Left is set in one of these RECTs, then it is
;	    not a rect but a scroll specification.
;		The structure then becomes: <scroll count>,<scroll flags>,
;		<right column>,<left column>,<bottom line>,<top line>,
;		<fill character>,<fill attribute>
;	    Note that all items are byte values and that the scroll event
;		specification takes the same space as an update rectangle.
;
ModListMax	EQU	64		    ; Max size of VDD_Mod_List field
EndDoc
VDD_Mod_State	STRUC

    VDD_Mod_Flag    DW	?		    ; Modified state flag
    VDD_Mod_Count   DW	?		    ; Count of entries in modification list
    VDD_Mod_List    DB	ModListMax dup(?)   ; The modification list(type dependent)

VDD_Mod_State	ENDS

;*******
;
; Masks and bit numbers for VDD_Mod_Flag
;
fVDD_M_Type	EQU 0000000000000111B	; Mask for value field
fVDD_M_TypeBit	EQU 0			; start bit for value field
fVDD_M_Ctlr	EQU 0000000000001000B	; flag indicating controller state chg
fVDD_M_CtlrBit	EQU 3			; bit for controller state change
fVDD_M_VRAM	EQU 0000000000010000B	; flag indicating Video RAM change
fVDD_M_VRAMBit	EQU 4			; bit for Video RAM change
fVDD_M_Curs	EQU 0000000000100000B	; flag indicating Cursor change
fVDD_M_CursBit	EQU 5			; bit for Cursor change
fVDD_M_ScOff	EQU 0000000001000000B	; flag indicating screen is off
fVDD_M_ScOffBit EQU 6			; bit for screen off
fVDD_M_Err	EQU 1000000000000000B	; flag indicating error, can't pass mods
fVDD_M_ErrBit	EQU 15			; bit for error
;
; Values for fVDD_M_TypeMsk field
;
fVDD_M_Type_Page	EQU    0	; Bit field of modified pages
fVDD_M_Type_Rect	EQU    1	; Array of RECT structures

;*******
;
; Structure for accessing RECTs
;
Rect	STRUC
    R_Left  DW	?
    R_Top   DW	?
    R_Right DW	?
    R_Botm  DW	?
Rect	ENDS

;********
;
;	Scroll rect definition
;
; If the high bit of R_Left is set in one of these RECTs, then it is
;  not a rect but a scroll event specification.
;  THIS APPLIES TO TEXT MODE ONLY (modes 0-3)!!
;  A scroll event spec looks like this:
;
ScrollRect STRUC
    ScrCnt  DB	?	    ; Count of lines to scroll in scroll region
    ScrFlgs DB	?	    ; Flags
    ScrRgt  DB	?	    ; Right Col of scroll (0 indexed)(ignore if full width bit set)
    ScrLft  DB	?	    ; Left Col of scroll (0 indexed)(ignore if full width bit set)
    ScrBot  DB	?	    ; Bottom line of scroll (0 indexed)
    ScrTop  DB	?	    ; Top line of scroll (0 indexed)
    ScrFch  DB	?	    ; Fill character for blank lines of scroll
    ScrFatt DB	?	    ; Fill attribute for blank lines of scroll
ScrollRect ENDS

; Masks for ScrFlgs
Scr_M_Scroll	    EQU 10000000B   ; High bit of flags indicates scroll
Scr_M_ScrollBit     EQU 7
Scr_M_FullWid	    EQU 00000001B   ; Set if scroll is full width (ignore Rgt Lft)
Scr_M_FullWidBit    EQU 0
Scr_M_Up	    EQU 00000010B   ; Set if scroll is UP, clear if DOWN
Scr_M_UpBit	    EQU 1

IF2
    IF (SIZE ScrollRect) NE (SIZE Rect)
	%out ERROR -- ScrollRect is wrong size!!!!!
    ENDIF
ENDIF


;*******************************************************************************
;
;	Memory state structure
;
VDA_Mem_State	STRUC
    VDA_Mem_Addr_P0	DD  ?		; Addr of plane 0 video memory
    VDA_Mem_Addr_P1	DD  ?		; Addr of plane 1 video memory
    VDA_Mem_Addr_P2	DD  ?		; Addr of plane 2 video memory
    VDA_Mem_Addr_P3	DD  ?		; Addr of plane 3 video memory
    VDA_Mem_DPagOff	DD  ?		; 32 bit offset to start of display
    VDA_Mem_Size_P0	DD  ?		; Size of plane 0 video memory
    VDA_Mem_Size_P1	DD  ?		; Size of plane 1 video memory
    VDA_Mem_Size_P2	DD  ?		; Size of plane 2 video memory
    VDA_Mem_Size_P3	DD  ?		; Size of plane 3 video memory
    VDA_Mem_DACOff	DD  ?		; address of DAC
VDA_Mem_State	ENDS

VDA_Mem_Addr_Win_State EQU VDA_Mem_Addr_P1  ; In text (0-3,7) modes
VDA_Mem_Size_Win_State EQU VDA_Mem_Size_P1

;*******
;
; ADDRESSING VIDEO DISPLAY
;
; Start of the display memory = VDA_Mem_Addr[plane] + VDA_Mem_DPagOffset
;
;   For modes 0-6, the <plane> is always 0
;
;   Displayed memory within a plane is always contiguous from the start
;	address as computed according to the formula above and the macro below.
;	Addressing the display memory from the computed start is as follows,
;	    where X is 0 based column and Y is 0 based row.
;
;	Mode 0-1: Even byte is char, odd byte is attr, 40 cols, 25 rows
;		   one plane.
;	    ChrByteOff=(X/2)+(Y*80); AttrByteOff=ChrByteOff+1
;
;	Mode 2-3,7: Even byte is char, odd byte is attr, 80 cols, 25 rows,
;		   one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 3,"43": Even byte is char, odd byte is attr, 80 cols,
;		    43 rows on EGA or VGA, one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 3,"50": Even byte is char, odd byte is attr, 80 cols,
;		    50 rows on VGA, one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 4-5: 2 bits per PEL, packed into bytes: bits 7-6 is PEL 0,
;		    bits 5-4 is PEL 1, etc. Where PEL = X MOD 4. Odd rows
;		    offset by 8k from even rows. 320 cols, 200 rows, one plane.
;	    PELByteOff=(X/4)+((Y/2)*80)+((Y MOD 2)*8192)
;
;	Mode 6: 1 bit per PEL, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, bit 5 is PEL 2, etc., where PEL = X MOD 8.
;		    Odd rows offset by 8k from even rows. 640 cols, 200 rows,
;		    one plane.
;	    PELByteOff=(X/8)+((Y/2)*160)+((Y MOD 2)*8192)
;
;	Mode D: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 320 cols,
;		    200 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*80)
;
;	Mode E: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    200 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 10: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    350 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 12: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    480 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 13: 8 bits or one byte per PEL.  320 cols, 200 rows, 1 plane.
;	    PELByteOff=(X)+(Y*160)
;
;
;	DestReg     = 32 bit register to place video memory address
;	MemStateReg = 32 bit register which -> VDA_Mem_State
;	MemStateSeg = SEGMENT REGISTER for MemStateReg
;	PlaneReg    = 32 bit register holding plane number desired
;
; ALL REGISTERS MUST BE SEPARATE!!!!!
;
;
GetStartDispAddr MACRO	 DestReg,MemStateReg,PlaneReg,MemStateSeg
	mov	DestReg,MemStateSeg:[MemStateReg.VDA_Mem_Addr_P0][PlaneReg*4]
	add	DestReg,MemStateSeg:[MemStateReg.VDA_Mem_DPagOff]
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VMM.H ===
#ifndef _VMM_H_
#define _VMM_H_

//---------------------------------------------------------------------------
//
//  vmm.h
//
//              6/21/94   dschmenk    Updated to use Watcom inline functions
//              4/11/95   dschmenk    Updated to use Win 95 extensions
//
//---------------------------------------------------------------------------

#include <vmmtypes.h>

//----------------------------------------------------------------------------
//
//                        Device ID equates
//
//----------------------------------------------------------------------------

#define Undefined_Device_ID    0x00000
#define VMM_Device_ID          0x00001   // Used for dynalink table
#define Debug_Device_ID        0x00002
#define VPICD_Device_ID        0x00003
#define VDMAD_Device_ID        0x00004
#define VTD_Device_ID          0x00005
#define V86MMGR_Device_ID      0x00006
#define PageSwap_Device_ID     0x00007
#define Parity_Device_ID       0x00008
#define Reboot_Device_ID       0x00009
#define VDD_Device_ID          0x0000A
#define VSD_Device_ID          0x0000B
#define VMD_Device_ID          0x0000C
#define VKD_Device_ID          0x0000D
#define VCD_Device_ID          0x0000E
#define VPD_Device_ID          0x0000F
#define BlockDev_Device_ID     0x00010
#define VMCPD_Device_ID        0x00011
#define EBIOS_Device_ID        0x00012
#define BIOSXlat_Device_ID     0x00013
#define VNETBIOS_Device_ID     0x00014
#define DOSMGR_Device_ID       0x00015
#define WINLOAD_Device_ID      0x00016
#define SHELL_Device_ID        0x00017
#define VMPoll_Device_ID       0x00018
#define VPROD_Device_ID        0x00019
#define DOSNET_Device_ID       0x0001A
#define VFD_Device_ID          0x0001B
#define VDD2_Device_ID         0x0001C   // Secondary display adapter
#define WINDEBUG_Device_ID     0x0001D
#define TSRLoad_Device_ID      0x0001E   // TSR instance utility ID
#define BiosHook_Device_ID     0x0001F   // Bios interrupt hooker VxD
#define Int13_Device_ID        0x00020
#define PageFile_Device_ID     0x00021   // Paging File device
#define SCSI_Device_ID         0x00022   // SCSI device
#define MCA_POS_Device_ID      0x00023   // MCA_POS device
#define SCSIFD_Device_ID       0x00024   // SCSI FastDisk device
#define VPEND_Device_ID        0x00025   // Pen device
#define APM_Device_ID          0x00026   // Power Management device
#define VPOWERD_DEVICE_ID      APM_DEVICE_ID   // We overload APM since we replace it
#define VXDLDR_DEVICE_ID       0x00027   // VxD Loader device
#define NDIS_DEVICE_ID         0x00028   // NDIS wrapper
#define BIOS_EXT_DEVICE_ID     0x00029   // Fix Broken BIOS device
#define VWIN32_DEVICE_ID       0x0002A   // for new WIN32-VxD
#define VCOMM_DEVICE_ID        0x0002B   // New COMM device driver
#define SPOOLER_DEVICE_ID      0x0002C   // Local Spooler
#define WIN32S_DEVICE_ID       0x0002D   // Win32S on Win 3.1 driver
#define DEBUGCMD_DEVICE_ID     0x0002E   // Debug command extensions
#define CONFIGMG_DEVICE_ID     0x00033   // Configuration manager (Plug&Play)
#define DWCFGMG_DEVICE_ID      0x00034   // Configuration manager for win31 and DOS
#define SCSIPORT_DEVICE_ID     0x00035   // Dragon miniport loader/driver
#define VFBACKUP_DEVICE_ID     0x00036   // allows backup apps to work with NEC
#define ENABLE_DEVICE_ID       0x00037   // for access VxD
#define VCOND_DEVICE_ID        0x00038   // Virtual Console Device - check vcond.inc
#define ISAPNP_DEVICE_ID       0x0003C   // ISA P&P Enumerator
#define BIOS_DEVICE_ID         0x0003D   // BIOS P&P Enumerator
#define IFSMgr_Device_ID       0x00040   // Installable File System Manager
#define VCDFSD_DEVICE_ID       0x00041   // Static CDFS ID
#define MRCI2_DEVICE_ID        0x00042   // DrvSpace compression engine
#define PCI_DEVICE_ID          0x00043   // PCI P&P Enumerator
#define PELOADER_DEVICE_ID     0x00044   // PE Image Loader
#define EISA_DEVICE_ID         0x00045   // EISA P&P Enumerator
#define DRAGCLI_DEVICE_ID      0x00046   // Dragon network client
#define DRAGSRV_DEVICE_ID      0x00047   // Dragon network server
#define PERF_DEVICE_ID         0x00048   // Config/stat info
#define ETEN_Device_ID         0x00060   // ETEN DOS (Taiwan) driver
#define CHBIOS_Device_ID       0x00061   // CHBIOS DOS (Korean) driver
#define VMSGD_Device_ID        0x00062   // DBCS Message Mode driver
#define VPPID_Device_ID        0x00063   // PC-98 System Control PPI
#define VIME_Device_ID         0x00064   // Virtual DOS IME
#define VHBIOSD_Device_ID      0x00065   // HBIOS (Korean) for HWin31 driver
#define BASEID_FOR_NAMEBASEDVXD        0xF000 // Name based VxD IDs start here
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0FFF // Mask to get the real vxd id

//----------------------------------------------------------------------------
//
//                     Initialization order equates
//
//----------------------------------------------------------------------------

#define VMM_Init_Order         0x000000000
#define PERF_INIT_ORDER        0x000900000
#define APM_Init_Order         0x001000000
#define VPOWERD_INIT_ORDER     APM_INIT_ORDER  // We overload APM since we replace it
#define Debug_Init_Order       0x004000000
#define BiosHook_Init_Order    0x006000000
#define VPROD_Init_Order       0x008000000
#define VPICD_Init_Order       0x00C000000
#define VTD_Init_Order         0x014000000
#define VXDLDR_INIT_ORDER      0x016000000
#define ENUMERATOR_INIT_ORDER  0x016800000
#define ISAPNP_INIT_ORDER      ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER        ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER         ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER        ENUMERATOR_INIT_ORDER+1
#define CONFIGMG_INIT_ORDER    ENUMERATOR_INIT_ORDER+0xFFFF
#define VCDFSD_INIT_ORDER      0x016F00000
#define IOS_INIT_ORDER         0x017000000
#define PageFile_Init_Order    0x018000000
#define PageSwap_Init_Order    0x01C000000
#define Parity_Init_Order      0x020000000
#define Reboot_Init_Order      0x024000000
#define EBIOS_Init_Order       0x026000000
#define VDD_Init_Order         0x028000000
#define VSD_Init_Order         0x02C000000
#define VCD_Init_Order         0x030000000
#define COMMDRVR_INIT_ORDER    (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER       (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER       (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER        (COMMDRVR_INIT_ORDER - 4)
#define VMD_Init_Order         0x034000000
#define VKD_Init_Order         0x038000000
#define VPD_Init_Order         0x03C000000
#define BlockDev_Init_Order    0x040000000
#define MCA_POS_Init_Order     0x041000000
#define SCSIFD_Init_Order      0x041400000
#define SCSIMaster_Init_Order  0x041800000
#define Int13_Init_Order       0x042000000
#define VFD_Init_Order         0x044000000
#define VMCPD_Init_Order       0x048000000
#define BIOSXlat_Init_Order    0x050000000
#define VNETBIOS_Init_Order    0x054000000
#define DOSMGR_Init_Order      0x058000000
#define DOSNET_Init_Order      0x05C000000
#define WINLOAD_Init_Order     0x060000000
#define VMPoll_Init_Order      0x064000000
#define Undefined_Init_Order   0x080000000
#define WINDEBUG_Init_Order    0x081000000
#define VDMAD_Init_Order       0x090000000
#define V86MMGR_Init_Order     0x0A0000000
#define IFSMgr_Init_Order      0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order         0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER         0x50000 + IFSMgr_Init_Order
//
// Device ID for device that must touch memory in 1st MB
// at crit init (after V86mmgr)
//
#define Undef_Touch_Mem_Init_Order 0x0A8000000
#define SHELL_Init_Order           0x0B0000000
//
// VxD load result.
//
#define VXD_FAILURE 0
#define VXD_SUCCESS 1

//----------------------------------------------------------------------------
//
//                      System control call messages
//
//----------------------------------------------------------------------------

#define Sys_Critical_Init     0x0000
#define Device_Init           0x0001
#define Init_Complete         0x0002
#define Sys_VM_Init           0x0003
#define Sys_VM_Terminate      0x0004
#define System_Exit           0x0005
#define Sys_Critical_Exit     0x0006
#define Create_VM             0x0007
#define VM_Critical_Init      0x0008
#define VM_Init               0x0009
#define VM_Terminate          0x000A
#define VM_Not_Executable     0x000B
#define Destroy_VM            0x000C
#define VM_Suspend            0x000D
#define VM_Resume             0x000E
#define Set_Device_Focus      0x000F
#define Begin_Message_Mode    0x0010
#define End_Message_Mode      0x0011

#define Reboot_Processor      0x0012
#define Query_Destroy         0x0013
#define Debug_Query           0x0014

#define Begin_PM_App          0x0015

#define BPA_32_Bit            0x0001
#define BPA_32_Bit_Flag       0x0001

#define End_PM_App            0x0016

#define Device_Reboot_Notify  0x0017
#define Crit_Reboot_Notify    0x0018

#define Close_VM_Notify       0x0019

#define PnP_New_DevNode       0x0022

#define CVNF_Crit_Close       0x0001
#define CNVF_Crit_Close_Bit   0x0000

#define Power_Event           0x001A

//----------------------------------------------------------------------------
//
//                          Service Table definition.
//
//----------------------------------------------------------------------------

#define BeginServiceTable(did) enum { did##_begin = (did##_Device_ID << 16) - 1,
#define EndServiceTable()      did##_end };

//----------------------------------------------------------------------------
//
//                          VMM Service Definitions
//
//----------------------------------------------------------------------------

#if 0
BeginServiceTable(VMM)
    Get_VMM_Version,
    Get_Cur_VM_Handle,
    Test_Cur_VM_Handle,
    Get_Sys_VM_Handle,
    Test_Sys_VM_Handle,
    Validate_VM_Handle,
    Get_VMM_Reenter_Count,
    Begin_Reentrant_Execution,
    End_Reentrant_Execution,
    Install_V86_Break_Point,
    Remove_V86_Break_Point,
    Allocate_V86_Call_Back,
    Allocate_PM_Call_Back,
    Call_When_VM_Returns,
    Schedule_Global_Event,
    Schedule_VM_Event,
    Call_Global_Event,
    Call_VM_Event,
    Cancel_Global_Event,
    Cancel_VM_Event,
    Call_Priority_VM_Event,
    Cancel_Priority_VM_Event,
    Get_NMI_Handler_Addr,
    Set_NMI_Handler_Addr,
    Hook_NMI_Event,
    Call_When_VM_Ints_Enabled,
    Enable_VM_Ints,
    Disable_VM_Ints,
    Map_Flat,
    Map_Lin_To_VM_Addr,
    Adjust_Exec_Priority,
    Begin_Critical_Section,
    End_Critical_Section,
    End_Crit_And_Suspend,
    Claim_Critical_Section,
    Release_Critical_Section,
    Call_When_Not_Critical,
    Create_Semaphore,
    Destroy_Semaphore,
    Wait_Semaphore,
    Signal_Semaphore,
    Get_Crit_Section_Status,
    Call_When_Task_Switched,
    Suspend_VM,
    Resume_VM,
    No_Fail_Resume_VM,
    Nuke_VM,
    Crash_Cur_VM,
    Get_Execution_Focus,
    Set_Execution_Focus,
    Get_Time_Slice_Priority,
    Set_Time_Slice_Priority,
    Get_Time_Slice_Granularity,
    Set_Time_Slice_Granularity,
    Get_Time_Slice_Info,
    Adjust_Execution_Time,
    Release_Time_Slice,
    Wake_Up_VM,
    Call_When_Idle,
    Get_Next_VM_Handle,
    Set_Global_Time_Out,
    Set_VM_Time_Out,
    Cancel_Time_Out,
    Get_System_Time,
    Get_VM_Exec_Time,
    Hook_V86_Int_Chain,
    Get_V86_Int_Vector,
    Set_V86_Int_Vector,
    Get_PM_Int_Vector,
    Set_PM_Int_Vector,
    Simulate_Int,
    Simulate_Iret,
    Simulate_Far_Call,
    Simulate_Far_Jmp,
    Simulate_Far_Ret,
    Simulate_Far_Ret_N,
    Build_Int_Stack_Frame,
    Simulate_Push,
    Simulate_Pop,
    _HeapAllocate,
    _HeapReAllocate,
    _HeapFree,
    _HeapGetSize,
    _PageAllocate,
    _PageReAllocate,
    _PageFree,
    _PageLock,
    _PageUnLock,
    _PageGetSizeAddr,
    _PageGetAllocInfo,
    _GetFreePageCount,
    _GetSysPageCount,
    _GetVMPgCount,
    _MapIntoV86,
    _PhysIntoV86,
    _TestGlobalV86Mem,
    _ModifyPageBits,
    _CopyPageTable,
    _LinMapIntoV86,
    _LinPageLock,
    _LinPageUnLock,
    _SetResetV86Pageable,
    _GetV86PageableArray,
    _PageCheckLinRange,
    _PageOutDirtyPages,
    _PageDiscardPages,
    _GetNulPageHandle,
    _GetFirstV86Page,
    _MapPhysToLinear,
    _GetAppFlatDSAlias,
    _SelectorMapFlat,
    _GetDemandPageInfo,
    _GetSetPageOutCount,
    Hook_V86_Page,
    _Assign_Device_V86_Pages,
    _DeAssign_Device_V86_Pages,
    _Get_Device_V86_Pages_Array,
    MMGR_SetNULPageAddr,
    _Allocate_GDT_Selector,
    _Free_GDT_Selector,
    _Allocate_LDT_Selector,
    _Free_LDT_Selector,
    _BuildDescriptorDWORDs,
    _GetDescriptor,
    _SetDescriptor,
    _MMGR_Toggle_HMA,
    Get_Fault_Hook_Addrs,
    Hook_V86_Fault,
    Hook_PM_Fault,
    Hook_VMM_Fault,
    Begin_Nest_V86_Exec,
    Begin_Nest_Exec,
    Exec_Int,
    Resume_Exec,
    End_Nest_Exec,
    Allocate_PM_App_CB_Area,
    Get_Cur_PM_App_CB,
    Set_V86_Exec_Mode,
    Set_PM_Exec_Mode,
    Begin_Use_Locked_PM_Stack,
    End_Use_Locked_PM_Stack,
    Save_Client_State,
    Restore_Client_State,
    Exec_VxD_Int,
    Hook_Device_Service,
    Hook_Device_V86_API,
    Hook_Device_PM_API,
    System_Control,
    Simulate_IO,
    Install_Mult_IO_Handlers,
    Install_IO_Handler,
    Enable_Global_Trapping,
    Enable_Local_Trapping,
    Disable_Global_Trapping,
    Disable_Local_Trapping,
    List_Create,
    List_Destroy,
    List_Allocate,
    List_Attach,
    List_Attach_Tail,
    List_Insert,
    List_Remove,
    List_Deallocate,
    List_Get_First,
    List_Get_Next,
    List_Remove_First,
    _AddInstanceItem,
    _Allocate_Device_CB_Area,
    _Allocate_Global_V86_Data_Area,
    _Allocate_Temp_V86_Data_Area,
    _Free_Temp_V86_Data_Area,
    Get_Profile_Decimal_Int,
    Convert_Decimal_String,
    Get_Profile_Fixed_Point,
    Convert_Fixed_Point_String,
    Get_Profile_Hex_Int,
    Convert_Hex_String,
    Get_Profile_Boolean,
    Convert_Boolean_String,
    Get_Profile_String,
    Get_Next_Profile_String,
    Get_Environment_String,
    Get_Exec_Path,
    Get_Config_Directory,
    OpenFile,
    Get_PSP_Segment,
    GetDOSVectors,
    Get_Machine_Info,
    GetSet_HMA_Info,
    Set_System_Exit_Code,
    Fatal_Error_Handler,
    Fatal_Memory_Error,
    Update_System_Clock,
    Test_Debug_Installed,
    Out_Debug_String,
    Out_Debug_Chr,
    In_Debug_Chr,
    Debug_Convert_Hex_Binary,
    Debug_Convert_Hex_Decimal,
    Debug_Test_Valid_Handle,
    Validate_Client_Ptr,
    Test_Reenter,
    Queue_Debug_String,
    Log_Proc_Call,
    Debug_Test_Cur_VM,
    Get_PM_Int_Type,
    Set_PM_Int_Type,
    Get_Last_Updated_System_Time,
    Get_Last_Updated_VM_Exec_Time,
    Test_DBCS_Lead_Byte,
    _AddFreePhysPage,
    _PageResetHandlePAddr,
    _SetLastV86Page,
    _GetLastV86Page,
    _MapFreePhysReg,
    _UnmapFreePhysReg,
    _XchgFreePhysReg,
    _SetFreePhysRegCalBk,
    Get_Next_Arena,
    Get_Name_Of_Ugly_TSR,
    Get_Debug_Options,
    Set_Physical_HMA_Alias,
    _GetGlblRng0V86IntBase,
    _Add_Global_V86_Data_Area,
    GetSetDetailedVMError,
    Is_Debug_Chr,
    Clear_Mono_Screen,
    Out_Mono_Chr,
    Out_Mono_String,
    Set_Mono_Cur_Pos,
    Get_Mono_Cur_Pos,
    Get_Mono_Chr,
    Locate_Byte_In_ROM,
    Hook_Invalid_Page_Fault,
    Unhook_Invalid_Page_Fault,
    Set_Delete_On_Exit_File,
    Close_VM,
    Enable_Touch_1st_Meg,
    Disable_Touch_1st_Meg,
    Install_Exception_Handler,
    Remove_Exception_Handler,
    Get_Crit_Status_No_Block,
    _GetLastUpdatedThreadExecTime,
    _Trace_Out_Service,
    _Debug_Out_Service,
    _Debug_Flags_Service,
    VMMAddImportModuleName,
    VMM_Add_DDB,
    VMM_Remove_DDB,
    Test_VM_Ints_Enabled,
    _BlockOnID,
    Schedule_Thread_Event,
    Cancel_Thread_Event,
    Set_Thread_Time_Out,
    Set_Async_Time_Out,
    _AllocateThreadDataSlot,
    _FreeThreadDataSlot,
    _CreateMutex,
    _DestroyMutex,
    _GetMutexOwner,
    Call_When_Thread_Switched,
    VMMCreateThread,
    _GetThreadExecTime,
    VMMTerminateThread,
    Get_Cur_Thread_Handle,
    Test_Cur_Thread_Handle,
    Get_Sys_Thread_Handle,
    Test_Sys_Thread_Handle,
    Validate_Thread_Handle,
    Get_Initial_Thread_Handle,
    Test_Initial_Thread_Handle,
    Debug_Test_Valid_Thread_Handle,
    Debug_Test_Cur_Thread,
    VMM_GetSystemInitState,
    Cancel_Call_When_Thread_Switched,
    Get_Next_Thread_Handle,
    Adjust_Thread_Exec_Priority,
    _Deallocate_Device_CB_Area,
    Remove_IO_Handler,
    Remove_Mult_IO_Handlers,
    Unhook_V86_Int_Chain,
    Unhook_V86_Fault,
    Unhook_PM_Fault,
    Unhook_VMM_Fault,
    Unhook_Device_Service,
    _PageReserve,
    _PageCommit,
    _PageDecommit,
    _PagerRegister,
    _PagerQuery,
    _PagerDeregister,
    _ContextCreate,
    _ContextDestroy,
    _PageAttach,
    _PageFlush,
    _SignalID,
    _PageCommitPhys,
    _Register_Win32_Services,
    Cancel_Call_When_Not_Critical,
    Cancel_Call_When_Idle,
    Cancel_Call_When_Task_Switched,
    _Debug_Printf_Service,
    _EnterMutex,
    _LeaveMutex,
    Simulate_VM_IO,
    Signal_Semaphore_No_Switch,
    _ContextSwitch,
    _PageModifyPermissions,
    _PageQuery,
    _EnterMustComplete,
    _LeaveMustComplete,
    _ResumeExecMustComplete,
    _GetThreadTerminationStatus,
    _GetInstanceInfo,
    _ExecIntMustComplete,
    _ExecVxDIntMustComplete,
    Begin_V86_Serialization,
    Unhook_V86_Page,
    VMM_GetVxDLocationList,
    VMM_GetDDBList,
    Unhook_NMI_Event,
    Get_Instanced_V86_Int_Vector,
    Get_Set_Real_DOS_PSP,
    Call_Priority_Thread_Event,
    Get_System_Time_Address,
    Get_Crit_Status_Thread,
    Get_DDB,
    Directed_Sys_Control,
    _RegOpenKey,
    _RegCloseKey,
    _RegCreateKey,
    _RegDeleteKey,
    _RegEnumKey,
    _RegQueryValue,
    _RegSetValue,
    _RegDeleteValue,
    _RegEnumValue,
    _RegQueryValueEx,
    _RegSetValueEx,
    _CallRing3,
    Exec_PM_Int,
    _RegFlushKey,
    _PageCommitContig,
    _GetCurrentContext,
    _LocalizeSprintf,
    _LocalizeStackSprintf,
    Call_Restricted_Event,
    Cancel_Restricted_Event,
    Register_PEF_Provider, VMM_ICODE,
    _GetPhysPageInfo,
    _RegQueryInfoKey,
    MemArb_Reserve_Pages,
    Time_Slice_Sys_VM_Idle,
    Time_Slice_Sleep,
    Boost_With_Decay,
    Set_Inversion_Pri,
    Reset_Inversion_Pri,
    Release_Inversion_Pri,
    Get_Thread_Win32_Pri,
    Set_Thread_Win32_Pri,
    Set_Thread_Static_Boost,
    Set_VM_Static_Boost,
    Release_Inversion_Pri_ID,
    Attach_Thread_To_Group,
    Detach_Thread_From_Group,
    Set_Group_Static_Boost,
    _GetRegistryPath,
    _GetRegistryKey,
    Cleanup_Thread_State,
    _RegRemapPreDefKey,
    End_V86_Serialization,
    _Assert_Range,
    _Sprintf,
    _PageChangePager,
    _RegCreateDynKey,
    _RegQueryMultipleValues,
    Boost_Thread_With_VM,
    Get_Boot_Flags,
    Set_Boot_Flags,
    _lstrcpyn,
    _lstrlen,
    _lmemcpy,
    _GetVxDName,
    Force_Mutexes_Free,
    Restore_Forced_Mutexes,
    _AddReclaimableItem,
    _SetReclaimableItem,
    _EnumReclaimableItem,
    Time_Slice_Wake_Sys_VM,
    VMM_Replace_Global_Environment,
    Begin_Non_Serial_Nest_V86_Exec,
    Get_Nest_Exec_Status,
    Open_Boot_Log,
    Write_Boot_Log,
    Close_Boot_Log,
    EnableDisable_Boot_Log,
EndServiceTable()
#endif // 0
#define Get_VMM_Version                     0x00010000
#define Get_Cur_VM_Handle                   0x00010001
#define Test_Cur_VM_Handle                  0x00010002
#define Get_Sys_VM_Handle                   0x00010003
#define Test_Sys_VM_Handle                  0x00010004
#define Validate_VM_Handle                  0x00010005
#define Get_VMM_Reenter_Count               0x00010006
#define Begin_Reentrant_Execution           0x00010007
#define End_Reentrant_Execution             0x00010008
#define Install_V86_Break_Point             0x00010009
#define Remove_V86_Break_Point              0x0001000a
#define Allocate_V86_Call_Back              0x0001000b
#define Allocate_PM_Call_Back               0x0001000c
#define Call_When_VM_Returns                0x0001000d
#define Schedule_Global_Event               0x0001000e
#define Schedule_VM_Event                   0x0001000f
#define Call_Global_Event                   0x00010010
#define Call_VM_Event                       0x00010011
#define Cancel_Global_Event                 0x00010012
#define Cancel_VM_Event                     0x00010013
#define Call_Priority_VM_Event              0x00010014
#define Cancel_Priority_VM_Event            0x00010015
#define Get_NMI_Handler_Addr                0x00010016
#define Set_NMI_Handler_Addr                0x00010017
#define Hook_NMI_Event                      0x00010018
#define Call_When_VM_Ints_Enabled           0x00010019
#define Enable_VM_Ints                      0x0001001a
#define Disable_VM_Ints                     0x0001001b
#define Map_Flat                            0x0001001c
#define Map_Lin_To_VM_Addr                  0x0001001d
#define Adjust_Exec_Priority                0x0001001e
#define Begin_Critical_Section              0x0001001f
#define End_Critical_Section                0x00010020
#define End_Crit_And_Suspend                0x00010021
#define Claim_Critical_Section              0x00010022
#define Release_Critical_Section            0x00010023
#define Call_When_Not_Critical              0x00010024
#define Create_Semaphore                    0x00010025
#define Destroy_Semaphore                   0x00010026
#define Wait_Semaphore                      0x00010027
#define Signal_Semaphore                    0x00010028
#define Get_Crit_Section_Status             0x00010029
#define Call_When_Task_Switched             0x0001002a
#define Suspend_VM                          0x0001002b
#define Resume_VM                           0x0001002c
#define No_Fail_Resume_VM                   0x0001002d
#define Nuke_VM                             0x0001002e
#define Crash_Cur_VM                        0x0001002f
#define Get_Execution_Focus                 0x00010030
#define Set_Execution_Focus                 0x00010031
#define Get_Time_Slice_Priority             0x00010032
#define Set_Time_Slice_Priority             0x00010033
#define Get_Time_Slice_Granularity          0x00010034
#define Set_Time_Slice_Granularity          0x00010035
#define Get_Time_Slice_Info                 0x00010036
#define Adjust_Execution_Time               0x00010037
#define Release_Time_Slice                  0x00010038
#define Wake_Up_VM                          0x00010039
#define Call_When_Idle                      0x0001003a
#define Get_Next_VM_Handle                  0x0001003b
#define Set_Global_Time_Out                 0x0001003c
#define Set_VM_Time_Out                     0x0001003d
#define Cancel_Time_Out                     0x0001003e
#define Get_System_Time                     0x0001003f
#define Get_VM_Exec_Time                    0x00010040
#define Hook_V86_Int_Chain                  0x00010041
#define Get_V86_Int_Vector                  0x00010042
#define Set_V86_Int_Vector                  0x00010043
#define Get_PM_Int_Vector                   0x00010044
#define Set_PM_Int_Vector                   0x00010045
#define Simulate_Int                        0x00010046
#define Simulate_Iret                       0x00010047
#define Simulate_Far_Call                   0x00010048
#define Simulate_Far_Jmp                    0x00010049
#define Simulate_Far_Ret                    0x0001004a
#define Simulate_Far_Ret_N                  0x0001004b
#define Build_Int_Stack_Frame               0x0001004c
#define Simulate_Push                       0x0001004d
#define Simulate_Pop                        0x0001004e
#define _HeapAllocate                       0x0001004f
#define _HeapReAllocate                     0x00010050
#define _HeapFree                           0x00010051
#define _HeapGetSize                        0x00010052
#define _PageAllocate                       0x00010053
#define _PageReAllocate                     0x00010054
#define _PageFree                           0x00010055
#define _PageLock                           0x00010056
#define _PageUnLock                         0x00010057
#define _PageGetSizeAddr                    0x00010058
#define _PageGetAllocInfo                   0x00010059
#define _GetFreePageCount                   0x0001005a
#define _GetSysPageCount                    0x0001005b
#define _GetVMPgCount                       0x0001005c
#define _MapIntoV86                         0x0001005d
#define _PhysIntoV86                        0x0001005e
#define _TestGlobalV86Mem                   0x0001005f
#define _ModifyPageBits                     0x00010060
#define _CopyPageTable                      0x00010061
#define _LinMapIntoV86                      0x00010062
#define _LinPageLock                        0x00010063
#define _LinPageUnLock                      0x00010064
#define _SetResetV86Pageable                0x00010065
#define _GetV86PageableArray                0x00010066
#define _PageCheckLinRange                  0x00010067
#define _PageOutDirtyPages                  0x00010068
#define _PageDiscardPages                   0x00010069
#define _GetNulPageHandle                   0x0001006a
#define _GetFirstV86Page                    0x0001006b
#define _MapPhysToLinear                    0x0001006c
#define _GetAppFlatDSAlias                  0x0001006d
#define _SelectorMapFlat                    0x0001006e
#define _GetDemandPageInfo                  0x0001006f
#define _GetSetPageOutCount                 0x00010070
#define Hook_V86_Page                       0x00010071
#define _Assign_Device_V86_Pages            0x00010072
#define _DeAssign_Device_V86_Pages          0x00010073
#define _Get_Device_V86_Pages_Array         0x00010074
#define MMGR_SetNULPageAddr                 0x00010075
#define _Allocate_GDT_Selector              0x00010076
#define _Free_GDT_Selector                  0x00010077
#define _Allocate_LDT_Selector              0x00010078
#define _Free_LDT_Selector                  0x00010079
#define _BuildDescriptorDWORDs              0x0001007a
#define _GetDescriptor                      0x0001007b
#define _SetDescriptor                      0x0001007c
#define _MMGR_Toggle_HMA                    0x0001007d
#define Get_Fault_Hook_Addrs                0x0001007e
#define Hook_V86_Fault                      0x0001007f
#define Hook_PM_Fault                       0x00010080
#define Hook_VMM_Fault                      0x00010081
#define Begin_Nest_V86_Exec                 0x00010082
#define Begin_Nest_Exec                     0x00010083
#define Exec_Int                            0x00010084
#define Resume_Exec                         0x00010085
#define End_Nest_Exec                       0x00010086
#define Allocate_PM_App_CB_Area             0x00010087
#define Get_Cur_PM_App_CB                   0x00010088
#define Set_V86_Exec_Mode                   0x00010089
#define Set_PM_Exec_Mode                    0x0001008a
#define Begin_Use_Locked_PM_Stack           0x0001008b
#define End_Use_Locked_PM_Stack             0x0001008c
#define Save_Client_State                   0x0001008d
#define Restore_Client_State                0x0001008e
#define Exec_VxD_Int                        0x0001008f
#define Hook_Device_Service                 0x00010090
#define Hook_Device_V86_API                 0x00010091
#define Hook_Device_PM_API                  0x00010092
#define System_Control                      0x00010093
#define Simulate_IO                         0x00010094
#define Install_Mult_IO_Handlers            0x00010095
#define Install_IO_Handler                  0x00010096
#define Enable_Global_Trapping              0x00010097
#define Enable_Local_Trapping               0x00010098
#define Disable_Global_Trapping             0x00010099
#define Disable_Local_Trapping              0x0001009a
#define List_Create                         0x0001009b
#define List_Destroy                        0x0001009c
#define List_Allocate                       0x0001009d
#define List_Attach                         0x0001009e
#define List_Attach_Tail                    0x0001009f
#define List_Insert                         0x000100a0
#define List_Remove                         0x000100a1
#define List_Deallocate                     0x000100a2
#define List_Get_First                      0x000100a3
#define List_Get_Next                       0x000100a4
#define List_Remove_First                   0x000100a5
#define _AddInstanceItem                    0x000100a6
#define _Allocate_Device_CB_Area            0x000100a7
#define _Allocate_Global_V86_Data_Area      0x000100a8
#define _Allocate_Temp_V86_Data_Area        0x000100a9
#define _Free_Temp_V86_Data_Area            0x000100aa
#define Get_Profile_Decimal_Int             0x000100ab
#define Convert_Decimal_String              0x000100ac
#define Get_Profile_Fixed_Point             0x000100ad
#define Convert_Fixed_Point_String          0x000100ae
#define Get_Profile_Hex_Int                 0x000100af
#define Convert_Hex_String                  0x000100b0
#define Get_Profile_Boolean                 0x000100b1
#define Convert_Boolean_String              0x000100b2
#define Get_Profile_String                  0x000100b3
#define Get_Next_Profile_String             0x000100b4
#define Get_Environment_String              0x000100b5
#define Get_Exec_Path                       0x000100b6
#define Get_Config_Directory                0x000100b7
#define OpenFile                            0x000100b8
#define Get_PSP_Segment                     0x000100b9
#define GetDOSVectors                       0x000100ba
#define Get_Machine_Info                    0x000100bb
#define GetSet_HMA_Info                     0x000100bc
#define Set_System_Exit_Code                0x000100bd
#define Fatal_Error_Handler                 0x000100be
#define Fatal_Memory_Error                  0x000100bf
#define Update_System_Clock                 0x000100c0
#define Test_Debug_Installed                0x000100c1
#define Out_Debug_String                    0x000100c2
#define Out_Debug_Chr                       0x000100c3
#define In_Debug_Chr                        0x000100c4
#define Debug_Convert_Hex_Binary            0x000100c5
#define Debug_Convert_Hex_Decimal           0x000100c6
#define Debug_Test_Valid_Handle             0x000100c7
#define Validate_Client_Ptr                 0x000100c8
#define Test_Reenter                        0x000100c9
#define Queue_Debug_String                  0x000100ca
#define Log_Proc_Call                       0x000100cb
#define Debug_Test_Cur_VM                   0x000100cc
#define Get_PM_Int_Type                     0x000100cd
#define Set_PM_Int_Type                     0x000100ce
#define Get_Last_Updated_System_Time        0x000100cf
#define Get_Last_Updated_VM_Exec_Time       0x000100d0
#define Test_DBCS_Lead_Byte                 0x000100d1
#define _AddFreePhysPage                    0x000100d2
#define _PageResetHandlePAddr               0x000100d3
#define _SetLastV86Page                     0x000100d4
#define _GetLastV86Page                     0x000100d5
#define _MapFreePhysReg                     0x000100d6
#define _UnmapFreePhysReg                   0x000100d7
#define _XchgFreePhysReg                    0x000100d8
#define _SetFreePhysRegCalBk                0x000100d9
#define Get_Next_Arena                      0x000100da
#define Get_Name_Of_Ugly_TSR                0x000100db
#define Get_Debug_Options                   0x000100dc
#define Set_Physical_HMA_Alias              0x000100dd
#define _GetGlblRng0V86IntBase              0x000100de
#define _Add_Global_V86_Data_Area           0x000100df
#define GetSetDetailedVMError               0x000100e0
#define Is_Debug_Chr                        0x000100e1
#define Clear_Mono_Screen                   0x000100e2
#define Out_Mono_Chr                        0x000100e3
#define Out_Mono_String                     0x000100e4
#define Set_Mono_Cur_Pos                    0x000100e5
#define Get_Mono_Cur_Pos                    0x000100e6
#define Get_Mono_Chr                        0x000100e7
#define Locate_Byte_In_ROM                  0x000100e8
#define Hook_Invalid_Page_Fault             0x000100e9
#define Unhook_Invalid_Page_Fault           0x000100ea
#define Set_Delete_On_Exit_File             0x000100eb
#define Close_VM                            0x000100ec
#define Enable_Touch_1st_Meg                0x000100ed
#define Disable_Touch_1st_Meg               0x000100ee
#define Install_Exception_Handler           0x000100ef
#define Remove_Exception_Handler            0x000100f0
#define Get_Crit_Status_No_Block            0x000100f1
#define _GetLastUpdatedThreadExecTime       0x000100f2
#define _Trace_Out_Service                  0x000100f3
#define _Debug_Out_Service                  0x000100f4
#define _Debug_Flags_Service                0x000100f5
#define VMMAddImportModuleName              0x000100f6
#define VMM_Add_DDB                         0x000100f7
#define VMM_Remove_DDB                      0x000100f8
#define Test_VM_Ints_Enabled                0x000100f9
#define _BlockOnID                          0x000100fa
#define Schedule_Thread_Event               0x000100fb
#define Cancel_Thread_Event                 0x000100fc
#define Set_Thread_Time_Out                 0x000100fd
#define Set_Async_Time_Out                  0x000100fe
#define _AllocateThreadDataSlot             0x000100ff
#define _FreeThreadDataSlot                 0x00010100
#define _CreateMutex                        0x00010101
#define _DestroyMutex                       0x00010102
#define _GetMutexOwner                      0x00010103
#define Call_When_Thread_Switched           0x00010104
#define VMMCreateThread                     0x00010105
#define _GetThreadExecTime                  0x00010106
#define VMMTerminateThread                  0x00010107
#define Get_Cur_Thread_Handle               0x00010108
#define Test_Cur_Thread_Handle              0x00010109
#define Get_Sys_Thread_Handle               0x0001010a
#define Test_Sys_Thread_Handle              0x0001010b
#define Validate_Thread_Handle              0x0001010c
#define Get_Initial_Thread_Handle           0x0001010d
#define Test_Initial_Thread_Handle          0x0001010e
#define Debug_Test_Valid_Thread_Handle      0x0001010f
#define Debug_Test_Cur_Thread               0x00010110
#define VMM_GetSystemInitState              0x00010111
#define Cancel_Call_When_Thread_Switched    0x00010112
#define Get_Next_Thread_Handle              0x00010113
#define Adjust_Thread_Exec_Priority         0x00010114
#define _Deallocate_Device_CB_Area          0x00010115
#define Remove_IO_Handler                   0x00010116
#define Remove_Mult_IO_Handlers             0x00010117
#define Unhook_V86_Int_Chain                0x00010118
#define Unhook_V86_Fault                    0x00010119
#define Unhook_PM_Fault                     0x0001011a
#define Unhook_VMM_Fault                    0x0001011b
#define Unhook_Device_Service               0x0001011c
#define _PageReserve                        0x0001011d
#define _PageCommit                         0x0001011e
#define _PageDecommit                       0x0001011f
#define _PagerRegister                      0x00010120
#define _PagerQuery                         0x00010121
#define _PagerDeregister                    0x00010122
#define _ContextCreate                      0x00010123
#define _ContextDestroy                     0x00010124
#define _PageAttach                         0x00010125
#define _PageFlush                          0x00010126
#define _SignalID                           0x00010127
#define _PageCommitPhys                     0x00010128
#define _Register_Win32_Services            0x00010129
#define Cancel_Call_When_Not_Critical       0x0001012a
#define Cancel_Call_When_Idle               0x0001012b
#define Cancel_Call_When_Task_Switched      0x0001012c
#define _Debug_Printf_Service               0x0001012d
#define _EnterMutex                         0x0001012e
#define _LeaveMutex                         0x0001012f
#define Simulate_VM_IO                      0x00010130
#define Signal_Semaphore_No_Switch          0x00010131
#define _ContextSwitch                      0x00010132
#define _PageModifyPermissions              0x00010133
#define _PageQuery                          0x00010134
#define _EnterMustComplete                  0x00010135
#define _LeaveMustComplete                  0x00010136
#define _ResumeExecMustComplete             0x00010137
#define _GetThreadTerminationStatus         0x00010138
#define _GetInstanceInfo                    0x00010139
#define _ExecIntMustComplete                0x0001013a
#define _ExecVxDIntMustComplete             0x0001013b
#define Begin_V86_Serialization             0x0001013c
#define Unhook_V86_Page                     0x0001013d
#define VMM_GetVxDLocationList              0x0001013e
#define VMM_GetDDBList                      0x0001013f
#define Unhook_NMI_Event                    0x00010140
#define Get_Instanced_V86_Int_Vector        0x00010141
#define Get_Set_Real_DOS_PSP                0x00010142
#define Call_Priority_Thread_Event          0x00010143
#define Get_System_Time_Address             0x00010144
#define Get_Crit_Status_Thread              0x00010145
#define Get_DDB                             0x00010146
#define Directed_Sys_Control                0x00010147
#define _RegOpenKey                         0x00010148
#define _RegCloseKey                        0x00010149
#define _RegCreateKey                       0x0001014a
#define _RegDeleteKey                       0x0001014b
#define _RegEnumKey                         0x0001014c
#define _RegQueryValue                      0x0001014d
#define _RegSetValue                        0x0001014e
#define _RegDeleteValue                     0x0001014f
#define _RegEnumValue                       0x00010150
#define _RegQueryValueEx                    0x00010151
#define _RegSetValueEx                      0x00010152
#define _CallRing3                          0x00010153
#define Exec_PM_Int                         0x00010154
#define _RegFlushKey                        0x00010155
#define _PageCommitContig                   0x00010156
#define _GetCurrentContext                  0x00010157
#define _LocalizeSprintf                    0x00010158
#define _LocalizeStackSprintf               0x00010159
#define Call_Restricted_Event               0x0001015a
#define Cancel_Restricted_Event             0x0001015b
#define Register_PEF_Provider               0x0001015c
#define _GetPhysPageInfo                    0x0001015d
#define _RegQueryInfoKey                    0x0001015e
#define MemArb_Reserve_Pages                0x0001015f
#define Time_Slice_Sys_VM_Idle              0x00010160
#define Time_Slice_Sleep                    0x00010161
#define Boost_With_Decay                    0x00010162
#define Set_Inversion_Pri                   0x00010163
#define Reset_Inversion_Pri                 0x00010164
#define Release_Inversion_Pri               0x00010165
#define Get_Thread_Win32_Pri                0x00010166
#define Set_Thread_Win32_Pri                0x00010167
#define Set_Thread_Static_Boost             0x00010168
#define Set_VM_Static_Boost                 0x00010169
#define Release_Inversion_Pri_ID            0x0001016a
#define Attach_Thread_To_Group              0x0001016b
#define Detach_Thread_From_Group            0x0001016c
#define Set_Group_Static_Boost              0x0001016d
#define _GetRegistryPath, VMM_ICODE         0x0001016e
#define _GetRegistryKey                     0x0001016f
#define Cleanup_Thread_State                0x00010170
#define _RegRemapPreDefKey                  0x00010171
#define End_V86_Serialization               0x00010172
#define _Assert_Range                       0x00010173
#define _Sprintf                            0x00010174
#define _PageChangePager                    0x00010175
#define _RegCreateDynKey                    0x00010176
#define _RegQueryMultipleValues             0x00010177
#define Boost_Thread_With_VM                0x00010178
#define Get_Boot_Flags                      0x00010179
#define Set_Boot_Flags                      0x0001017a
#define _lstrcpyn                           0x0001017b
#define _lstrlen                            0x0001017c
#define _lmemcpy                            0x0001017d
#define _GetVxDName                         0x0001017e
#define Force_Mutexes_Free                  0x0001017f
#define Restore_Forced_Mutexes              0x00010180
#define _AddReclaimableItem                 0x00010181
#define _SetReclaimableItem                 0x00010182
#define _EnumReclaimableItem                0x00010183
#define Time_Slice_Wake_Sys_VM              0x00010184
#define VMM_Replace_Global_Environment      0x00010185
#define Begin_Non_Serial_Nest_V86_Exec      0x00010186
#define Get_Nest_Exec_Status                0x00010187
#define Open_Boot_Log                       0x00010188
#define Write_Boot_Log                      0x00010189
#define Close_Boot_Log                      0x0001018a
#define EnableDisable_Boot_Log              0x0001018b

//----------------------------------------------------------------------------
//
//                    Flags for page allocator calls
//
//----------------------------------------------------------------------------

#define PageZeroInit            0x00000001
#define PageUseAlign            0x00000002
#define PageContig              0x00000004
#define PageFixed               0x00000008
#define PageDEBUGNulFault       0x00000010
#define PageZeroReInit          0x00000020
#define PageNoCopy              0x00000040
#define PageLocked              0x00000080
#define PageLockedIfDP          0x00000100
#define PageSetV86Pageable      0x00000200
#define PageClearV86Pageable    0x00000400
#define PageSetV86IntsLocked    0x00000800
#define PageClearV86IntsLocked  0x00001000
#define PageMarkPageOut         0x00002000
#define PagePDPSetBase          0x00004000
#define PagePDPClearBase        0x00008000
#define PageDiscard             0x00010000
#define PagePDPQueryDirty       0x00020000
//
// New for 3.10
//
#define PageMapFreePhysReg      0x00040000
//
// NOTE: HIGH 8 BITS (bits 24-31) are reserved
//
//----------------------------------------------------------------------------
//
//                         Page table entry bits
//
//----------------------------------------------------------------------------

#define P_SIZE        0x1000  // page size
#define P_PRES        0x01    // page present bit
#define P_PRESBit     0
#define P_WRITE       0x02    // write access bit
#define P_WRITEBit    1
#define P_USER        0x04    // access bit for User mode
#define P_USERBit     2
#define P_ACC         0x20    // page accessed bit
#define P_ACCBit      5
#define P_DIRTY       0x40    // page dirty bit
#define P_DIRTYBit    6
#define P_AVAIL       (P_PRES|P_WRITE|P_USER) // avail to everyone & present

//----------------------------------------------------------------------------
//
// Page types - definition of the OS reserved
//              bits in the page table entry.
//
//----------------------------------------------------------------------------

#define PG_TYPE       0x0E00  // TYPE bits in PTE

//----------------------------------------------------------------------------
//
// Page types for page allocator calls
//
//----------------------------------------------------------------------------

#define PG_VM         0
#define PG_SYS        1
#define PG_RESERVED1  2
#define PG_PRIVATE    3
#define PG_RESERVED2  4
#define PG_RELOCK     5      // PRIVATE to MMGR
#define PG_INSTANCE   6
#define PG_HOOKED     7
#define PG_IGNORE     0x0FFFFFFFF

//----------------------------------------------------------------------------
//
// Types for page table entries
//
//----------------------------------------------------------------------------

#define PgT_VM        (PG_VM << 9)
#define PgT_SYS       (PG_SYS << 9)
#define PgT_RESERVED1 (PG_RESERVED1 << 9)
#define PgT_PRIVATE   (PG_PRIVATE << 9)
#define PgT_RESERVED2 (PG_RESERVED2 << 9)
#define PgT_RELOCK    (PG_RELOCK << 9)
#define PgT_INSTANCE  (PG_INSTANCE << 9)
#define PgT_HOOKED    (PG_HOOKED << 9)

//----------------------------------------------------------------------------
//
// Definitions for the access byte in a descriptor
//
//----------------------------------------------------------------------------

#define D_PRES       0x80     // present in memory
#define D_NOTPRES    0x00     // not present in memory
#define D_DPL0       0x00     // Ring 0
#define D_DPL1       0x20     // Ring 1
#define D_DPL2       0x40     // Ring 2
#define D_DPL3       0x60     // Ring 3
#define D_SEG        0x10     // Segment descriptor
#define D_CTRL       0x00     // Control descriptor
#define D_GRAN_BYTE  0x00     // Segment length is byte granular
#define D_GRAN_PAGE  0x80     // Segment length is page granular
#define D_DEF16      0x00     // Default operation size is 16 bits
#define D_DEF32      0x40     // Default operation size is 32 bits
#define D_CODE       0x08     // code
#define D_DATA       0x00     // data
#define D_RX         0x02     // if code, readable
#define D_X          0x00     // if code, exec only
#define D_ED         0x04     // if expand down
#define D_EU         0x00     // if expand up
#define D_W          0x02     // if data, writable
#define D_R          0x00     // if data, read only
#define D_ACCESSED   0x01     // segment accessed bit
#define RW_Data_Type (D_PRES+D_SEG+D_DATA+D_W)
#define R_Data_Type  (D_PRES+D_SEG+D_DATA+D_R)
#define Code_Type    (D_PRES+D_SEG+D_CODE+D_RX)
#define D_PAGE32     (D_GRAN_PAGE+D_DEF32)
#define SELECTOR_MASK  0xfff8      // selector index
#define SEL_LOW_MASK   0x00f8      // mask for low byte of sel indx
#define TABLE_MASK     0x0004      // table bit
#define RPL_MASK       0x0003      // priviledge bits
#define RPL_CLR        (~0x0003)   // clear ring bits

//----------------------------------------------------------------------------
//
// Flags for List_Create
//
//----------------------------------------------------------------------------

#define LF_Async            0x0001
#define LF_Async_Bit        0
#define LF_Use_Heap         0x0002
#define LF_Use_Heap_Bit     1
#define LF_Alloc_Error      0x0004
#define LF_Alloc_Error_Bit  2

//----------------------------------------------------------------------------
//
// Scheduler Boost Values
//
//----------------------------------------------------------------------------

#define Reserved_Low_Boost      0x00000001
#define Cur_Run_VM_Boost        0x00000004
#define Low_Pri_Device_Boost    0x00000010
#define High_Pri_Device_Boost   0x00001000
#define Critical_Section_Boost  0x00100000
#define Time_Critical_Boost     0x00400000
#define Reserved_High_Boost     0x40000000

//----------------------------------------------------------------------------
//
// Flags for Call_Priority_VM_Event
//
//----------------------------------------------------------------------------

#define PEF_Wait_For_STI       0x0001
#define PEF_Wait_For_STI_Bit   0
#define PEF_Wait_Not_Crit      0x0002
#define PEF_Wait_Not_Crit_Bit  1
#define PEF_Dont_Unboost       0x0004
#define PEF_Dont_Unboost_Bit   2
#define PEF_Always_Sched       0x0008
#define PEF_Always_Sched_Bit   3
#define PEF_Time_Out           0x0010
#define PEF_Time_Out_Bit       4

//----------------------------------------------------------------------------
//
// Flags for Begin_Critical_Section and Wait_Semaphore
//
//----------------------------------------------------------------------------

#define Block_Svc_Ints                0x0001
#define Block_Svc_Ints_Bit            0
#define Block_Svc_If_Ints_Locked      0x0002
#define Block_Svc_If_Ints_Locked_Bit  1
#define Block_Enable_Ints             0x0004
#define Block_Enable_Ints_Bit         2
#define Block_Poll                    0x0008
#define Block_Poll_Bit                3

//----------------------------------------------------------------------------
//
// Data structures
//
//----------------------------------------------------------------------------

typedef struct tagREGS
{
    DWORD  eflags ;
    DWORD  edi ;
    DWORD  esi ;
    DWORD  ebp ;
    DWORD  esp ;
    DWORD  ebx ;
    DWORD  edx ;
    DWORD  ecx ;
    DWORD  eax ;
} REGS, *PREGS ;

#define EFLAGS_CF   0x00000001
#define EFLAGS_PF   0x00000004
#define EFLAGS_AF   0x00000010
#define EFLAGS_ZF   0x00000040
#define EFLAGS_SF   0x00000080

typedef struct tagCRS_32
{
   DWORD  Client_EDI ;
   DWORD  Client_ESI ;
   DWORD  Client_EBP ;
   DWORD  dwReserved_1 ;          // ESP at pushall
   DWORD  Client_EBX ;
   DWORD  Client_EDX ;
   DWORD  Client_ECX ;
   DWORD  Client_EAX ;
   DWORD  Client_Error ;          // DWORD error code
   DWORD  Client_EIP ;
   WORD   Client_CS ;
   WORD   wReserved_2 ;           // (padding)
   DWORD  Client_EFlags ;
   DWORD  Client_ESP ;
   WORD   Client_SS ;
   WORD   wReserved_3 ;           // (padding)
   WORD   Client_ES ;
   WORD   WReserved_4 ;           // (padding)
   WORD   Client_DS ;
   WORD   wReserved_5 ;           // (padding)
   WORD   Client_FS ;
   WORD   wReserved_6 ;           // (padding)
   WORD   Client_GS ;
   WORD   wReserved_7 ;           // (padding)

   DWORD  Client_Alt_EIP ;
   WORD   Client_Alt_CS ;
   WORD   wReserved_8 ;           // (padding)
   DWORD  Client_Alt_EFlags ;
   DWORD  Client_Alt_ESP ;
   WORD   Client_Alt_SS ;
   WORD   wReserved_9 ;           // (padding)
   WORD   Client_Alt_ES ;
   WORD   WReserved_10 ;          // (padding)
   WORD   Client_Alt_DS ;
   WORD   wReserved_11 ;          // (padding)
   WORD   Client_Alt_FS ;
   WORD   wReserved_12 ;          // (padding)
   WORD   Client_Alt_GS ;
   WORD   wReserved_13 ;          // (padding)
} CRS_32, *PCRS_32 ;

typedef struct tagCRS_16
{
   WORD   Client_DI ;
   WORD   wReserved_1 ;           // (padding)
   WORD   Client_SI ;
   WORD   wReserved_2 ;           // (padding)
   WORD   Client_BP ;
   WORD   wReserved_3 ;           // (padding)
   DWORD  dwReserved_4 ;          // ESP at pushall
   WORD   Client_BX ;
   WORD   wReserved_5 ;           // (padding)
   WORD   Client_DX ;
   WORD   wReserved_6 ;           // (padding)
   WORD   Client_CX ;
   WORD   wReserved_7 ;           // (padding)
   WORD   Client_AX ;
   WORD   wReserved_8 ;           // (padding)
   DWORD  dwReserved_9 ;          // DWORD error code
   WORD   Client_IP ;
   WORD   wReserved_10 ;          // (padding)
   WORD   Client_CS ;
   WORD   wReserved_11 ;          // (padding)
   WORD   Client_Flags ;          // flags (loword)
   WORD   wReserved_12 ;          // (padding)
   WORD   Client_SP ;
   WORD   wReserved_13 ;          // (padding)
   WORD   Client_SS ;
   WORD   wReserved_14 ;          // (padding)
   WORD   Client_ES ;
   WORD   wReserved_15 ;          // (padding)
   WORD   Client_DS ;
   WORD   wReserved_16 ;          // (padding)
   WORD   Client_FS ;
   WORD   wReserved_17 ;          // (padding)
   WORD   Client_GS ;
   WORD   wReserved_18 ;          // (padding)

   WORD   Client_Alt_IP ;
   WORD   wReserved_19 ;          // (padding)
   WORD   Client_Alt_CS ;
   WORD   wReserved_20 ;          // (padding)
   WORD   Client_Alt_Flags ;
   WORD   wReserved_21 ;          // (padding)
   WORD   Client_Alt_SP ;
   WORD   wReserved_22 ;          // (padding)
   WORD   Client_Alt_SS ;
   WORD   wReserved_23 ;          // (padding)
   WORD   Client_Alt_ES ;
   WORD   wReserved_24 ;          // (padding)
   WORD   Client_Alt_DS ;
   WORD   wReserved_25 ;          // (padding)
   WORD   Client_Alt_FS ;
   WORD   wReserved_26 ;          // (padding)
   WORD   Client_Alt_GS ;
   WORD   wReserved_27 ;          // (padding)
} CRS_16, *PCRS_16 ;

typedef struct tagCRS_8
{
   WORD   Client_DI ;
   WORD   wReserved_1 ;           // (padding)
   WORD   Client_SI ;
   WORD   wReserved_2 ;           // (padding)
   WORD   Client_BP ;
   WORD   wReserved_3 ;           // (padding)
   DWORD  dwReserved_4 ;          // ESP at pushall
   BYTE   Client_BL ;
   BYTE   Client_BH ;
   WORD   wReserved_5 ;           // (padding)
   BYTE   Client_DL ;
   BYTE   Client_DH ;
   WORD   wReserved_6 ;           // (padding)
   BYTE   Client_CL ;
   BYTE   Client_CH ;
   WORD   wReserved_7 ;           // (padding)
   BYTE   Client_AL ;
   BYTE   Client_AH ;
   WORD   wReserved_8 ;           // (padding)
   DWORD  dwReserved_9 ;          // DWORD error code
   WORD   Client_IP ;
   WORD   wReserved_10 ;          // (padding)
   WORD   Client_CS ;
   WORD   wReserved_11 ;          // (padding)
   WORD   Client_Flags ;          // flags (loword)
   WORD   wReserved_12 ;          // (padding)
   WORD   Client_SP ;
   WORD   wReserved_13 ;          // (padding)
   WORD   Client_SS ;
   WORD   wReserved_14 ;          // (padding)
   WORD   Client_ES ;
   WORD   wReserved_15 ;          // (padding)
   WORD   Client_DS ;
   WORD   wReserved_16 ;          // (padding)
   WORD   Client_FS ;
   WORD   wReserved_17 ;          // (padding)
   WORD   Client_GS ;
   WORD   wReserved_18 ;          // (padding)

   WORD   Client_Alt_IP ;
   WORD   wReserved_19 ;          // (padding)
   WORD   Client_Alt_CS ;
   WORD   wReserved_20 ;          // (padding)
   WORD   Client_Alt_Flags ;
   WORD   wReserved_21 ;          // (padding)
   WORD   Client_Alt_SP ;
   WORD   wReserved_22 ;          // (padding)
   WORD   Client_Alt_SS ;
   WORD   wReserved_23 ;          // (padding)
   WORD   Client_Alt_ES ;
   WORD   wReserved_24 ;          // (padding)
   WORD   Client_Alt_DS ;
   WORD   wReserved_25 ;          // (padding)
   WORD   Client_Alt_FS ;
   WORD   wReserved_26 ;          // (padding)
   WORD   Client_Alt_GS ;
   WORD   wReserved_27 ;          // (padding)
} CRS_8, *PCRS_8 ;

typedef union tagCRS
{
    CRS_32 Regs32;
    CRS_16 Regs16;
    CRS_8  Regs8;
} CRS, *PCRS ;

//----------------------------------------------------------------------------
//
// VM control block structure (VMM)
//
//----------------------------------------------------------------------------

typedef struct tagVMMCB
{
   DWORD  CB_VM_Status ;
   DWORD  CB_High_Linear ;
   DWORD  CB_Client_Pointer ;
   DWORD  CB_VMID ;
} VMMCB, *PVMMCB ;

#define VMCB_ID 0x62634D56      /* VMcb */

// VM status indicates globally interesting VM states

#define VMStat_Exclusive           0x00001 // VM is exclusive mode
#define VMStat_Exclusive_Bit       0x00
#define VMStat_Background          0x00002 // VM runs in background
#define VMStat_Background_Bit      0x01
#define VMStat_Creating            0x00004 // In process of creating
#define VMStat_Creating_Bit        0x02
#define VMStat_Suspended           0x00008 // VM not scheduled
#define VMStat_Suspended_Bit       0x03
#define VMStat_Not_Executeable     0x00010 // VM partially destroyed
#define VMStat_Not_Executeable_Bit 0x04
#define VMStat_PM_Exec             0x00020 // Currently in PM app
#define VMStat_PM_Exec_Bit         0x05
#define VMStat_PM_App              0x00040 // PM app present in VM
#define VMStat_PM_App_Bit          0x06
#define VMStat_PM_Use32            0x00080 // PM app is 32-bit
#define VMStat_PM_Use32_Bit        0x07
#define VMStat_VxD_Exec            0x00100 // Call from VxD
#define VMStat_VxD_Exec_Bit        0x08
#define VMStat_High_Pri_Back       0x00200 // High pri background
#define VMStat_High_Pri_Back_Bit   0x09
#define VMStat_Blocked             0x00400 // Blocked on semaphore
#define VMStat_Blocked_Bit         0x0A
#define VMStat_Awakening           0x00800 // Woke up after blocked
#define VMStat_Awakening_Bit       0x0B
#define VMStat_PageableV86         0x01000 // part of V86 is pageable (PM app)
#define VMStat_PageableV86Bit      0x0C
#define VMStat_V86IntsLocked       0x02000 // Rest of V86 is locked
#define VMStat_V86IntsLockedBit    0x0D    //    regardless of pager type
#define VMStat_TS_Sched            0x04000 // Scheduled by time-slicer
#define VMStat_TS_Sched_Bit        0x0E
#define VMStat_Idle                0x08000 // VM has released time slice
#define VMStat_Idle_Bit            0x0F
#define VMStat_Closing             0x10000 // Close_VM called for VM
#define VMStat_Closing_Bit         0x10

#define VMStat_Use32_Mask          (VMStat_PM_Use32 | VMStat_VxD_Exec)

typedef struct tagTCB
{
    DWORD   TCB_Flags;              // Thread status flags
    DWORD   TCB_Reserved1;          // Used internally by VMM
    DWORD   TCB_Reserved2;          // Used internally by VMM
    DWORD   TCB_Signature;
    DWORD   TCB_ClientPtr;          // Client registers of thread
    DWORD   TCB_VMHandle;           // VM that thread is part of
    WORD    TCB_ThreadId;           // Unique Thread ID
    WORD    TCB_PMLockOrigSS;       // Original SS:ESP before lock stack
    DWORD   TCB_PMLockOrigESP;
    DWORD   TCB_PMLockOrigEIP;      // Original CS:EIP before lock stack
    DWORD   TCB_PMLockStackCount;
    WORD    TCB_PMLockOrigCS;
    WORD    TCB_PMPSPSelector;
    DWORD   TCB_ThreadType;         // dword passed to VMMCreateThread
    WORD    TCB_pad1;               // reusable; for dword align
    BYTE    TCB_pad2;               // reusable; for dword align
    BYTE    TCB_extErrLocus;        // extended error Locus
    WORD    TCB_extErr;             // extended error Code
    BYTE    TCB_extErrAction;       //      "   "   Action
    BYTE    TCB_extErrClass;        //      "   "   Class
    DWORD   TCB_extErrPtr;          //      "   pointer
} TCB, *PTCB;

#define SCHED_OBJ_ID_THREAD         0x42434854    // THCB in ASCII

//
//  Thread status indicates globally interesting thread states.
//  Flags are for information only and must not be modified.
//

#define THFLAG_SUSPENDED_Bit        0x03   // Thread not scheduled
#define THFLAG_SUSPENDED            (1L << THFLAG_SUSPENDED_Bit)
#define THFLAG_NOT_EXECUTEABLE_Bit  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE      (1L << THFLAG_NOT_EXECUTEABLE_Bit)
#define THFLAG_THREAD_CREATION_Bit  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION      (1L << THFLAG_THREAD_CREATION_Bit)
#define THFLAG_THREAD_BLOCKED_Bit   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED       (1L << THFLAG_THREAD_BLOCKED_Bit)
#define THFLAG_CHARSET_Bits         0x10   // Default character set
#define THFLAG_CHARSET_MASK         (3L << THFLAG_CHARSET_Bits)
#define THFLAG_ANSI                 (0L << THFLAG_CHARSET_Bits)
#define THFLAG_OEM                  (1L << THFLAG_CHARSET_Bits)
#define THFLAG_UNICODE              (2L << THFLAG_CHARSET_Bits)
#define THFLAG_RESERVED             (3L << THFLAG_CHARSET_Bits)
#define THFLAG_EXTENDED_HANDLES_Bit 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES     (1L << THFLAG_EXTENDED_HANDLES_Bit)
//
// the win32 loader opens win32 exes with this bit set to notify IFS
// so a defragger won't move these files
// the bit is turned off once the open completes.
// file open flags are overloaded which is why this is here
//
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_Bit 0x13   // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE     (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_Bit)
//
// Protected mode application control blocks
//
typedef struct tagPMCB
{
    DWORD PMCB_Flags;
    DWORD PMCB_Parent;
} PMCB, *PPMCB;
//
//  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
//  GSDVME_INVALFLT) is a pointer to the following fault information structure.
//
typedef struct tagVMFaultInfo
{
    DWORD VMFI_EIP;             // faulting EIP
    WORD  VMFI_CS;              // faulting CS
    WORD  VMFI_Ints;            // interrupts in service, if any
} VMFAULTINFO, *PVMFAULTINFO;

//----------------------------------------------------------------------------
//
// Device descriptor block structure
//
//----------------------------------------------------------------------------

#define DDK_Version 0x400

typedef struct tagVxD_Desc_Block
{
   DWORD  DDB_Next ;                // VMM reserved field
   WORD   DDB_SDK_Version  ;        // VMM reserved field
   WORD   DDB_Req_Device_Number ;   // Required device number
   BYTE   DDB_Dev_Major_Version ;   // Major device number
   BYTE   DDB_Dev_Minor_Version ;   // Minor device number
   WORD   DDB_Flags ;               // Flags for init calls complete
   BYTE   DDB_Name[ 8 ] ;           // Device name
   DWORD  DDB_Init_Order ;          // Initialization Order
   DWORD  DDB_Control_Proc ;        // Offset of control procedure
   DWORD  DDB_V86_API_Proc ;        // Offset of API procedure
   DWORD  DDB_PM_API_Proc ;         // Offset of API procedure
   DWORD  DDB_V86_API_CSIP ;        // CS:IP of API entry point
   DWORD  DDB_PM_API_CSIP ;         // CS:IP of API entry point
   DWORD  DDB_Reference_Data ;      // Reference data from real mode
   DWORD  DDB_Service_Table_Ptr ;   // Pointer to service table
   DWORD  DDB_Service_Table_Size ;  // Number of services
   DWORD  DDB_Win32_Service_Table;  // INIT <0> Pointer to Win32 services
   DWORD  DDB_Prev;                 // INIT <'Prev'> Ptr to prev 4.0 DDB
   DWORD  DDB_Reserved0;            // INIT <0> Reserved
   DWORD  DDB_Reserved1;            // INIT <'Rsv1'> Reserved
   DWORD  DDB_Reserved2;            // INIT <'Rsv2'> Reserved
   DWORD  DDB_Reserved3;            // INIT <'Rsv3'> Reserved
} DDB ;
//
// Flag values for DDB_Flags
//
#define DDB_SYS_CRIT_INIT_DONE_Bit  0
#define DDB_SYS_CRIT_INIT_DONE      (1 << DDB_SYS_CRIT_INIT_DONE_Bit)
#define DDB_DEVICE_INIT_DONE_Bit    1
#define DDB_DEVICE_INIT_DONE        (1 << DDB_DEVICE_INIT_DONE_Bit)
#define DDB_HAS_WIN32_SVCS_Bit      14
#define DDB_HAS_WIN32_SVCS          (1 << DDB_HAS_WIN32_SVCS_Bit)
#define DDB_DYNAMIC_VXD_Bit         15
#define DDB_DYNAMIC_VXD             (1 << DDB_DYNAMIC_VXD_Bit)
#define DDB_DEVICE_DYNALINKED_Bit   13
#define DDB_DEVICE_DYNALINKED       (1 << DDB_DEVICE_DYNALINKED_Bit)

//----------------------------------------------------------------------------
//
// Data structures for vmmInstallMultIOHandlers
//
//----------------------------------------------------------------------------

typedef UINT (CDECL* VXDIOPROC)( DWORD, UINT, UINT, PCRS_32, UINT ) ;

typedef struct tagVXDIOENTRY
{
   WORD       VxD_IO_Port ;
   VXDIOPROC  VxD_IO_Proc ;
} VXDIOENTRY, *PVXDIOENTRY ;

typedef struct tagVXDIOTABLE
{
   WORD        IOT_Ports ;
   VXDIOENTRY  IOT_Entries[] ;
} VXDIOTABLE, *PVXDIOTABLE ;
//
// The following are the definitions for the "type of I/O" parameter passed
// to a I/O trap routine.
//
#define BYTE_INPUT      0x000
#define BYTE_OUTPUT     0x004
#define WORD_INPUT      0x008
#define WORD_OUTPUT     0x00C
#define DWORD_INPUT     0x010
#define DWORD_OUTPUT    0x014
#define OUTPUT_BIT      2
#define OUTPUT          (1 << OUTPUT_BIT)
#define WORD_IO_BIT     3
#define WORD_IO         (1 << WORD_IO_BIT)
#define DWORD_IO_BIT    4
#define DWORD_IO        (1 << DWORD_IO_BIT)
#define STRING_IO_BIT   5
#define STRING_IO       (1 << STRING_IO_BIT)
#define REP_IO_BIT      6
#define REP_IO          (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT  7
#define ADDR_32_IO      (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT  8
#define REVERSE_IO      (1 << REVERSE_IO_BIT)
#define IO_SEG_MASK     0x0FFFF0000     // Use this to get segment
#define IO_SEG_SHIFT    0x10            // Must shift right this many

//----------------------------------------------------------------------------
//
//  The following equates are for flags sent to the real mode
//  initialization portion of a device driver:
//
//----------------------------------------------------------------------------

#define DUPLICATE_DEVICE_ID_BIT     0   // loaded
#define DUPLICATE_DEVICE_ID         (1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1   // loaded from INT 2F list
#define DUPLICATE_FROM_INT2F        (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT      2   // in the INT 2F device list
#define LOADING_FROM_INT2F          (1 << LOADING_FROM_INT2F_BIT)

//----------------------------------------------------------------------------
//
//  The following equates are used to indicate the result of the real mode
//  initialization portion of a device driver:
//
//----------------------------------------------------------------------------

#define DEVICE_LOAD_OK          0   // load protected mode portion
#define ABORT_DEVICE_LOAD       1   // don't load protected mode portion
#define ABORT_WIN386_LOAD       2   // fatal-error: abort load of Win386
#define NO_FAIL_MESSAGE_BIT     15  // set bit to suppress error message
#define NO_FAIL_MESSAGE         (1 << NO_FAIL_MESSAGE_BIT)

//----------------------------------------------------------------------------
//
//  The following equates define the loader services available to the real-mode
//  initialization portion of a device driver:
//
//----------------------------------------------------------------------------

#define LDRSRV_GET_PROFILE_STRING       0   // search SYSTEM.INI for string
#define LDRSRV_GET_NEXT_PROFILE_STRING  1   // search for next string
#define LDRSRV_RESERVED                 2   // RESERVED
#define LDRSRV_GET_PROFILE_BOOLEAN      3   // search SYSTEM.INI for boolean
#define LDRSRV_GET_PROFILE_DECIMAL_INT  4   // search SYSTEM.INI for integer
#define LDRSRV_GET_PROFILE_HEX_INT      5   // search SYSTEM.INI for hex int
#define LDRSRV_COPY_EXTENDED_MEMORY     6   // allocate/init extended memory
#define LDRSRV_GET_MEMORY_INFO          7   // get info about machine memory

//----------------------------------------------------------------------------
//  Registry services for Real mode init time
//
//  The parameters for these are as defined in Windows.h for the
//  corresponding Win Reg API and should be on Stack. These are
//  C Callable except that the function no has to be in AX
//
//----------------------------------------------------------------------------

#define LDRSRV_RegOpenKey           0x100
#define LDRSRV_RegCreateKey         0x101
#define LDRSRV_RegCloseKey          0x102
#define LDRSRV_RegDeleteKey         0x103
#define LDRSRV_RegSetValue          0x104
#define LDRSRV_RegQueryValue        0x105
#define LDRSRV_RegEnumKey           0x106
#define LDRSRV_RegDeleteValue       0x107
#define LDRSRV_RegEnumValue         0x108
#define LDRSRV_RegQueryValueEx      0x109
#define LDRSRV_RegSetValueEx        0x10A
#define LDRSRV_RegFlushKey          0x10B
//
// For the Copy_Extended_Memory service, the following types of memory can be
// requested:
//
#define LDRSRV_COPY_INIT            1   // memory discarded after init
#define LDRSRV_COPY_LOCKED          2   // locked memory
#define LDRSRV_COPY_PAGEABLE        3   // pageable memory

//----------------------------------------------------------------------------
//
//   Object types supported by the vxd loader
//
//  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
//           Also Init type objects should be added to the second part of the
//           list (which starts with ICODE_OBJ).
//
//----------------------------------------------------------------------------

#define RCODE_OBJ           -1
#define LCODE_OBJ           0x01
#define LDATA_OBJ           0x02
#define PCODE_OBJ           0x03
#define PDATA_OBJ           0x04
#define SCODE_OBJ           0x05
#define SDATA_OBJ           0x06
#define CODE16_OBJ          0x07
#define LMSG_OBJ            0x08
#define PMSG_OBJ            0x09
#define DBOC_OBJ            0x0B
#define DBOD_OBJ            0x0C
#define ICODE_OBJ           0x11
#define IDATA_OBJ           0x12
#define ICODE16_OBJ         0x13
#define IMSG_OBJ            0x14
typedef struct tagObjectLocation
{
    DWORD OL_LinearAddr ;
    DWORD OL_Size ;
    BYTE  OL_ObjType ;
} OBJECTLOC, *POBJECTLOC;
#define MAXOBJECTS  30
//
// Device_Location structure
//
typedef struct tagDevice_Location_List {
    DWORD      DLL_DDB ;
    BYTE       DLL_NumObjects ;
    POBJECTLOC DLL_ObjLocation[1];
} DEVLOCLIST, *PDEVLOCLIST;

//----------------------------------------------------------------------------
//
// Data structure for vmmAddInstanceItem
//
//----------------------------------------------------------------------------

typedef struct tagINSTDATASTRUC
{
   DWORD   dwInstLinkF ;      // reserved set to NULL
   DWORD   dwInstLinkB ;      // reserved set to NULL
   DWORD   dwInstLinAddr ;    // linear address of start of block
   DWORD   dwInstSize ;       // size of block in bytes
   DWORD   dwInstType ;       // type of block
} INSTDATASTRUC, *PINSTDATASTRUC ;

// values for dwInstType

#define INDOS_Field   0x0100
#define ALWAYS_Field  0x0200

//----------------------------------------------------------------------------
//
// Data structure for page fault
//
//----------------------------------------------------------------------------

typedef struct tagIPFDATA
{

   DWORD  IPF_LinAddr ;       // CR2 address of fault
   DWORD  IPF_MapPageNum ;    // Possible converted page # of fault
   DWORD  IPF_PTEEntry ;      // Contents of PTE that faulted
   DWORD  IPF_FaultingVM ;    // May not = Current VM (IPF_V86PgH set)
   DWORD  IPF_Flags ;         // Flags
} IPFDATA, *PIPFDATA ;
//
// Page fault flags.
//
#define IPF_PAGE_NOT_PRESENT            0x00000008
#define IPF_PAGE_DIR_NOT_PRESENT        0x00000001
#define IPF_PAGE_SWAP_ERROR             0x00000010
#define IPF_PROTECTED_MODE              0x00000080
#define IPF_REENTRANT_FAULT             0x00000020
#define IPF_V86_MODE                    0x00000100
#define IPF_V86_PAGE_NOT_PRESENT        0x00000002
#define IPF_V86_HIGH_PAGE_NOT_PRESENT   0x00000004
#define IPF_VIRTUAL_DEVICE_FAULT        0x00000040
//
// Flags for other page allocator calls
//
//  NOTE: HIGH 8 BITS (bits 24-31) are reserved
//
#define PAGEZEROINIT            0x00000001
#define PAGEUSEALIGN            0x00000002
#define PAGECONTIG              0x00000004
#define PAGEFIXED               0x00000008
#define PAGEDEBUGNULFAULT       0x00000010
#define PAGEZEROREINIT          0x00000020
#define PAGENOCOPY              0x00000040
#define PAGELOCKED              0x00000080
#define PAGELOCKEDIFDP          0x00000100
#define PAGESETV86PAGEABLE      0x00000200
#define PAGECLEARV86PAGEABLE    0x00000400
#define PAGESETV86INTSLOCKED    0x00000800
#define PAGECLEARV86INTSLOCKED  0x00001000
#define PAGEMARKPAGEOUT         0x00002000
#define PAGEPDPSETBASE          0x00004000
#define PAGEPDPCLEARBASE        0x00008000
#define PAGEDISCARD             0x00010000
#define PAGEPDPQUERYDIRTY       0x00020000
#define PAGEMAPFREEPHYSREG      0x00040000
#define PAGENOMOVE              0x10000000
#define PAGEMAPGLOBAL           0x40000000
#define PAGEMARKDIRTY           0x80000000
//
// Flags for _PhysIntoV86, _MapIntoV86, and _LinMapIntoV86
//
#define MAPV86_IGNOREWRAP       0x00000001
//
// Flag equates for _BuildDescriptorDWORDs
//
#define BDDEXPLICITDPL          0x00000001
//
// Flag equates for _Allocate_LDT_Selector
//
#define ALDTSPECSEL             0x00000001
//
// Flag equates for _MMGR_Toggle_HMA
//
#define MMGRHMAPHYSICAL         0x00000001
#define MMGRHMAENABLE           0x00000002
#define MMGRHMADISABLE          0x00000004
#define MMGRHMAQUERY            0x00000008
//
// Flags used by List_Create
//
#define LF_ASYNC_Bit            0
#define LF_ASYNC                (1 << LF_ASYNC_Bit)
#define LF_USE_HEAP_BIT         1
#define LF_USE_HEAP             (1 << LF_USE_HEAP_Bit)
#define LF_ALLOC_ERROR_BIT      2
#define LF_ALLOC_ERROR          (1 << LF_ALLOC_ERROR_Bit)
//
// Swappable lists must use the heap.
//
#define LF_SWAP                 (LF_USE_HEAP + (1 << 3))
//
// Flag bits for _Allocate_Global_V86_Data_Area
//
#define GVDAWordAlign           0x00000001
#define GVDADWordAlign          0x00000002
#define GVDAParaAlign           0x00000004
#define GVDAPageAlign           0x00000008
#define GVDAInstance            0x00000100
#define GVDAZeroInit            0x00000200
#define GVDAReclaim             0x00000400
#define GVDAInquire             0x00000800
#define GVDAHighSysCritOK       0x00001000
#define GVDAOptInstance         0x00002000
#define GVDAForceLow            0x00004000
//
// Flag bits for _Allocate_Temp_V86_Data_Area
//
#define TVDANeedTilInitComplete 0x00000001
//
// Flags for heap allocator calls
//
#define HeapZeroInit    0x0001
#define HeapZeroReInit  0x0002
#define HeapNoCopy      0x0004
#define HeapLockedIfDP  0x0100
#define HeapSwap        0x0200
#define HeapInit        0x0400
#define HeapClean       0x0800
//
// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.
//
#define VMM_OPENFILE_BUF_SIZE   260
//
// GetMachineInfo flag bits.
//
#define GMIF_80486_Bit          0x10
#define GMIF_80486              (1 << GMIF_80486_Bit)
#define GMIF_PCXT_BIT           0x11
#define GMIF_PCXT               (1 << GMIF_PCXT_Bit)
#define GMIF_MCA_BIT            0x12
#define GMIF_MCA                (1 << GMIF_MCA_Bit)
#define GMIF_EISA_BIT           0x13
#define GMIF_EISA               (1 << GMIF_EISA_Bit)
#define GMIF_CPUID_BIT          0x14
#define GMIF_CPUID              (1 << GMIF_CPUID_Bit)
//
// Bits for the ECX return of Get_Next_Arena
//
#define GNA_HIDOSLINKED         0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS           0x0004 // High DOS arenas do exist
//
// Error code values for the GetSetDetailedVMError service. PLEASE NOTE
// that all of these error code values need to have bits set in the high
// word. This is to prevent collisions with other VMDOSAPP standard errors.
// Also, the low word must be non-zero.
//
// First set of errors (high word = 0001) are intended to be used
// when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
// VM_Not_Executeable).
//
// PLEASE NOTE that each of these errors (high word == 0001) actually
// has two forms:
//
// 0001xxxxh
// 8001xxxxh
//
// The device which sets the error initially always sets the error with
// the high bit CLEAR. The system will then optionally set the high bit
// depending on the result of the attempt to "nicely" crash the VM. This
// bit allows the system to tell the user whether the crash is likely or
// unlikely to destabalize the system.
//
#define GSDVME_PRIVINST         0x00010001  // Privledged instruction
#define GSDVME_INVALINST        0x00010002  // Invalid instruction
#define GSDVME_INVALPGFLT       0x00010003  // Invalid page fault
#define GSDVME_INVALGPFLT       0x00010004  // Invalid GP fault
#define GSDVME_INVALFLT         0x00010005  // Unspecified invalid fault
#define GSDVME_USERNUKE         0x00010006  // User requested NUKE of VM
#define GSDVME_DEVNUKE          0x00010007  // Device specific problem
#define GSDVME_DEVNUKEHDWR      0x00010008  // Device specific problem:
                                            // invalid hardware fiddling
                                            // by VM (invalid I/O)
#define GSDVME_NUKENOMSG        0x00010009  // Supress standard messages:
                                            // SHELL_Message used for
                                            // custom msg.
#define GSDVME_OKNUKEMASK       0x80000000  // "Nice nuke" bit
//
// Second set of errors (high word = 0002) are intended to be used
// when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
// VNE_InitFail bit set on VM_Not_Executeable).
//
#define GSDVME_INSMEMV86        0x00020001  // base V86 mem    - V86MMGR
#define GSDVME_INSV86SPACE      0x00020002  // Kb Req too large - V86MMGR
#define GSDVME_INSMEMXMS        0x00020003  // XMS Kb Req      - V86MMGR
#define GSDVME_INSMEMEMS        0x00020004  // EMS Kb Req      - V86MMGR
#define GSDVME_INSMEMV86HI      0x00020005  // Hi DOS V86 mem   - DOSMGR,V86MMGR
#define GSDVME_INSMEMVID        0x00020006  // Base Video mem   - VDD
#define GSDVME_INSMEMVM         0x00020007  // Base VM mem     - VMM
                                            // CB, Inst Buffer
#define GSDVME_INSMEMDEV        0x00020008  // Couldn't alloc base VM
                                            // memory for device.
#define GSDVME_CRTNOMSG         0x00020009  // Supress standard messages:
                                            // SHELL_Message used for
                                            // custom msg.
//
// Flags for Close_VM service.
//
#define CVF_CONTINUE_EXEC_Bit           0
#define CVF_CONTINUE_EXEC               (1 << CVF_CONTINUE_EXEC_Bit)
//
// Flag equates for _CreateMutex
//
#define MUTEX_MUST_COMPLETE             1
#define MUTEX_NO_CLEANUP_THREAD_STATE   2
//
// Flag equates for _GetThreadTerminationStatus
//
#define THREAD_TERM_STATUS_CRASH_PEND   1
#define THREAD_TERM_STATUS_NUKE_PEND    2
#define THREAD_TERM_STATUS_SUSPEND_PEND 4
//
// Return values for _GetInstanceInfo
//
#define INSTINFO_NONE                   0       // no data instanced in range
#define INSTINFO_SOME                   1       // some data instanced in range
#define INSTINFO_ALL                    2       // all data instanced in range
//
// Get/Set real DOS PSP.
//
#define GSRDP_Set                       0x0001
#ifndef REG_SZ                          // define only if not there already
#define REG_SZ                          0x0001
#define REG_BINARY                      0x0003
#endif
#ifndef HKEY_LOCAL_MACHINE              // define only if not there already
#define HKEY_CLASSES_ROOT               0x80000000
#define HKEY_CURRENT_USER               0x80000001
#define HKEY_LOCAL_MACHINE              0x80000002
#define HKEY_USERS                      0x80000003
#define HKEY_PERFORMANCE_DATA           0x80000004
#define HKEY_CURRENT_CONFIG             0x80000005
#define HKEY_DYN_DATA                   0x80000006
#endif
//
// Return values for _GetPhysPageInfo
//
#define PHYSINFO_NONE   0       // no pages in the specified range exist
#define PHYSINFO_SOME   1       // some pages in the specified range exist
#define PHYSINFO_ALL    2       // all pages in the specified range exist
//
// TYPE definitions for _GetRegistryKey
//
#define REGTYPE_ENUM                0
#define REGTYPE_CLASS               1
#define REGTYPE_VXD                 2
//
// Flag definitions for _GetRegistryKey
//
#define REGKEY_OPEN                 0
#define REGKEY_CREATE_IFNOTEXIST    1
//
// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD       0x00000000
#define ASSERT_RANGE_NULL_OK        0x00000001
#define ASSERT_RANGE_NO_DEBUG       0x80000000
#define ASSERT_RANGE_BITS           0x80000001
//
// Flag definitions for Get_Boot_Flags
//
#define BOOT_CLEAN                  0x00000001
#define BOOT_DOSCLEAN               0x00000002
#define BOOT_NETCLEAN               0x00000004
#define BOOT_INTERACTIVE            0x00000008
//
// Flag definitions for _Add/_Set/_EnumReclaimableItem
//
#define RS_RECLAIM                  0x00000001
#define RS_RESTORE                  0x00000002
#define RS_DOSARENA                 0x00000004
//
// Structure definition for _EnumReclaimableItem
//
typedef struct tagRECLAIMSTRUC
{
    DWORD   RS_Linear;                  // low (< 1meg) address of item
    DWORD   RS_Bytes;                   // size of item in bytes
    DWORD   RS_CallBack;                // callback, if any (zero if none)
    DWORD   RS_RefData;                 // reference data for callback, if any
    DWORD   RS_HookTable;               // real-mode hook table (zero if none)
    DWORD   RS_Flags;                   // 0 or more of the RS_* equates
} RECLAIMSTRUC, *PRECLAIMSTRUC;
//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct tagFRMTX
{
    struct tagFRMTX *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX, *PFRMTX;
typedef struct tagVMMFRINFO
{
    FRMTX vmmfrinfo_frmtxDOS;
    FRMTX vmmfrinfo_frmtxV86;
    FRMTX vmmfrinfo_frmtxOther;
} VMMFRINFO, *PVMMFRINFO;
//
//  Data structure for _GetDemandPageInfo
//
struct tagDemandInfoStruc
{
    DWORD DILin_Total_Count;    // # pages in linear address space
    DWORD DIPhys_Count;         // Count of phys pages
    DWORD DIFree_Count;         // Count of free phys pages
    DWORD DIUnlock_Count;       // Count of unlocked Phys Pages
    DWORD DILinear_Base_Addr;   // Base of pageable address space
    DWORD DILin_Total_Free;     // Total Count of free linear pages
    //
    //  The following 5 fields are all running totals, kept from the time
    //  the system was started
    //
    DWORD DIPage_Faults;        // total page faults
    DWORD DIPage_Ins;           // calls to pagers to page in a page
    DWORD DIPage_Outs;          // calls to pagers to page out a pag
    DWORD DIPage_Discards;      // pages discarded w/o calling pager
    DWORD DIInstance_Faults;    // instance page faults
    DWORD DIPagingFileMax;      // maximum # of pages that could be in paging file
    DWORD DIPagingFileInUse;    // # of pages of paging file currently in use
    DWORD DICommit_Count;       // Total committed memory, in pages
    DWORD DIReserved[2];        // Reserved for expansion
};
//
//  Data structure for _AddInstanceItem
//
struct tagInstDataStruc
{
    DWORD InstLinkF;        // INIT <0> RESERVED
    DWORD InstLinkB;        // INIT <0> RESERVED
    DWORD InstLinAddr;      // Linear address of start of block
    DWORD InstSize;         // Size of block in bytes
    DWORD InstType;         // Type of block
};
//
//  Values for InstType
//
#define INDOS_FIELD     0x100   // Bit indicating INDOS switch requirements
#define ALWAYS_FIELD    0x200   // Bit indicating ALWAYS switch requirements
#define OPTIONAL_FIELD  0x400   // Bit indicating optional instancing requirements
//
// Data structure for Hook_Invalid_Page_Fault handlers.
//
// This is the structure of the "invalid page fault information"
// which is pointed to by EDI when Invalid page fault hookers
// are called.
//
// Page faults can occur on a VM which is not current by touching the VM at
// its high linear address.  In this case, IPF_FaultingVM may not be the
// current VM, it will be set to the VM whos high linear address was touched.
//
struct tagIPF_Data
{
    DWORD IPF_LinAddr;      // CR2 address of fault
    DWORD IPF_MapPageNum;   // Possible converted page # of fault
    DWORD IPF_PTEEntry;     // Contents of PTE that faulted
    DWORD IPF_FaultingVM;   // May not = Current VM (IPF_V86PgH set)
    DWORD IPF_Flags;        // Flags
};
//
//
// Install_Exception_Handler data structure
//
//
struct tagException_Handler_Struc
{
    DWORD EH_Reserved;
    DWORD EH_Start_EIP;
    DWORD EH_End_EIP;
    DWORD EH_Handler;
};
//
// Flags passed in new memory manager functions
//
// PageReserve arena values
//
#define PR_PRIVATE      0x80000400  // anywhere in private arena
#define PR_SHARED       0x80060000  // anywhere in shared arena
#define PR_SYSTEM       0x80080000  // anywhere in system arena
//
// PageReserve flags
//
#define PR_FIXED        0x00000008  // don't move during PageReAllocate
#define PR_4MEG         0x00000001  // allocate on 4mb boundary
#define PR_STATIC       0x00000010  // see PageReserve documentation
//
// PageCommit default pager handle values
//
#define PD_ZEROINIT     0x00000001  // swappable zero-initialized pages
#define PD_NOINIT       0x00000002  // swappable uninitialized pages
#define PD_FIXEDZERO    0x00000003  // fixed zero-initialized pages
#define PD_FIXED        0x00000004  // fixed uninitialized pages
//
// PageCommit flags
//
#define PC_FIXED        0x00000008  // pages are permanently locked
#define PC_LOCKED       0x00000080  // pages are made present and locked
#define PC_LOCKEDIFDP   0x00000100  // pages are locked if swap via DOS
#define PC_WRITEABLE    0x00020000  // make the pages writeable
#define PC_USER         0x00040000  // make the pages ring 3 accessible
#define PC_INCR         0x40000000  // increment "pagerdata" each page
#define PC_PRESENT      0x80000000  // make pages initially present
#define PC_STATIC       0x20000000  // allow commit in PR_STATIC object
#define PC_DIRTY        0x08000000  // make pages initially dirty
//
// PageCommitContig additional flags
//
#define PCC_ZEROINIT    0x00000001  // zero-initialize new pages
#define PCC_NOLIN       0x10000000  // don't map to any linear address
//
// Structure and flags for PageQuery
//
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION
{
    DWORD mbi_BaseAddress;
    DWORD mbi_AllocationBase;
    DWORD mbi_AllocationProtect;
    DWORD mbi_RegionSize;
    DWORD mbi_State;
    DWORD mbi_Protect;
    DWORD mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
#define PAGE_NOACCESS           0x00000001
#define PAGE_READONLY           0x00000002
#define PAGE_READWRITE          0x00000004
#define MEM_COMMIT              0x00001000
#define MEM_RESERVE             0x00002000
#define MEM_FREE                0x00010000
#define MEM_PRIVATE             0x00020000
#endif

//----------------------------------------------------------------------------
//
//                            Pager Descriptor
//
// A PD describes a set of routines to call to bring a page into
// the system or to get it out.  Each committed page in the system
// has an associated PD, a handle to which is stored in the page's
// VP.
//
// For any field that is 0, the pager will not be notified
// when that action takes place.
//
// For the purpose of pagers, a page can be in one of the two states
// describing its current contents:
//
//     clean - page has not been written to since its last page out
//     dirty - page has been written to since its last page out
//
// A page also is in one of two persistent states:
//
//     virgin - page has never been written to since it was committed
//     tainted - page has been written to since it was committed
//
// Note that a tainted page may be either dirty or clean, but a
// virgin page is by definition clean.
//
// Examples of PDs:
//
//     For 32-bit EXE code or read-only data:
//
//       pd_virginin = routine to load page from an exe file
//       pd_taintedin = 0
//       pd_cleanout = 0
//       pd_dirtyout = 0
//       pd_virginfree = 0
//       pd_taintedfree = 0
//       pd_dirty = 0
//       pd_type = PD_PAGERONLY
//
//     For 32-bit EXE writeable data:
//
//       pd_virginin = routine to load page from an exe file
//       pd_taintedin = routine to load page from swap file
//       pd_cleanout = 0
//       pd_dirtyout = routine to write a page out to the swap file
//       pd_virginfree = 0
//       pd_taintedfree = routine to free page from the swap file
//       pd_dirty = routine to free page from the swap file
//       pd_type = PD_SWAPPER
//
//     For zero-initialized swappable data:
//
//       pd_virginin = routine to zero-fill a page
//       pd_taintedin = routine to load page from swap file
//       pd_cleanout = 0
//       pd_dirtyout = routine to write a page out to the swap file
//       pd_virginfree = 0
//       pd_taintedfree = routine to free page from the swap file
//       pd_dirty = routine to free page from the swap file
//       pd_type = PD_SWAPPER
//
//----------------------------------------------------------------------------

typedef DWORD _cdecl FUNPAGE(DWORD * ppagerdata, VOID * ppage, DWORD faultpage);
typedef FUNPAGE * PFUNPAGE;
typedef struct tagPD
{
    //
    // The following four fields are entry points in the pager which
    // we call to page in or page out a page.  The following parameters
    // are passed to the pager during these calls:
    //
    // ppagerdata - pointer to the pager-specific dword of data
    //          stored with the virtual page.  The pager is
    //          free to modify the contents of this dword
    //          DURING the page in or out, but not afterwards.
    //
    // ppage - pointer to page going in or out (a ring 0 alias
    //     to the physical page).  The pager should use this
    //     address to access the contents of the page.
    //
    // faultpage - faulting linear page number for page-ins, -1 for
    //         page-outs.  This address should not be accessed
    //         by the pager.  It is provided for information
    //         only.  Note that a single page can be mapped at
    //         more than one linear address because of the
    //         MapIntoV86 and LinMapIntoV86 services.
    //
    // The pager should return non-0 if the page was successfully
    // paged, or 0 if it failed.
    //
    PFUNPAGE pd_virginin;   // in - while page has never been written to
    PFUNPAGE pd_taintedin;  // in - page written to at least once
    PFUNPAGE pd_cleanout;   // out - page not written to since last out
    PFUNPAGE pd_dirtyout;   // out - page was written to since last out
    //
    // The pd_*free routines are used to inform the pager when the last
    // reference to a virtual page controlled by the pager is
    // decommitted.  A common use of this notification is to
    // free space in a backing file, or write the page contents
    // into the backing file.
    //
    // These calls take the same parameters as the page-out and -in
    // functions, but no return value is recognized.  The "ppage"
    // and "faultpage" parameters will always be 0.
    //
    PFUNPAGE pd_virginfree;  // decommit of never-written-to page
    PFUNPAGE pd_taintedfree; // decommit of page written to at least once
    //
    // The pd_dirty routine is used to inform the pager when the
    // memory manager detects that a page has been written to.  The memory
    // manager does not detect the write at the instant it occurs, so
    // the pager should not depend upon prompt notification.  A common
    // use of this notification might be to invalidate cached data.
    // If the page was dirtied in more than one memory context,
    // the pager's pd_dirty routine will be called once for each
    // context.
    //
    // These calls take the same parameters as the page-out and -in
    // functions except that the "ppage" parameter isn't valid and
    // no return value is recognized.
    //
    PFUNPAGE pd_dirty;
    //
    // The pd_type field gives the sytem information about the
    // overcommit characteristics of pages controlled by this pager.
    // The following are allowable values for the field:
    //
    // PD_SWAPPER - under some conditions, pages of this type
    //      may be paged out into the swap file
    // PD_PAGERONLY - pages controlled by this pager will never
    //      be paged out to the swap file
    //
    // In addition, the following value may be or'ed in to the pd_type field:
    //
    // PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
    //      functions perform nested excecution or block using the
    //      BLOCK_SVC_INTS flag.  To be safe, this flag should always be
    //      specified if the pager does any sort of file i/o to anything
    //      other than the default paging file.
    //
    DWORD pd_type;
} PD, * PPD;
//
// values for pd_type
//
#define PD_SWAPPER          0   // pages need direct accounting in swap file
#define PD_PAGERONLY        1   // pages will never be swapped
#define PD_NESTEXEC         2   // page out funtion uses nested execution
//
// The size of a page of memory
//
#define PAGESHIFT           12
#define PAGESIZE            (1 << PAGESHIFT)
#define PAGEMASK            (PAGESIZE - 1)
#define PAGE(p)             ((DWORD)(p) >> PAGESHIFT)
#define NPAGES(cb)          (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)
//
// Address space (arena) boundaries
//
#define MAXSYSTEMLADDR      0xFFBFFFFF    // 4 GB - 4MB
#define MINSYSTEMLADDR      0xC0000000    // 3 GB
#define MAXSHAREDLADDR      0xBFFFFFFF
#define MINSHAREDLADDR      0x80000000    // 2 GB
#define MAXPRIVATELADDR     0x7FFFFFF
#define MINPRIVATELADDR     0x00400000    // 4 MB
#define MAXDOSLADDR         0x003FFFFF
#define MINDOSLADDR         0x00000000
#define MAXSYSTEMPAGE       (MAXSYSTEMLADDR  >> PAGESHIFT)
#define MINSYSTEMPAGE       (MINSYSTEMLADDR  >> PAGESHIFT)
#define MAXSHAREDPAGE       (MAXSHAREDLADDR  >> PAGESHIFT)
#define MINSHAREDPAGE       (MINSHAREDLADDR  >> PAGESHIFT)
#define MAXPRIVATEPAGE      (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE      (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE          (MAXDOSLADDR     >> PAGESHIFT)
#define MINDOSPAGE          (MINDOSLADDR     >> PAGESHIFT)
#define CBPRIVATE           (1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED            (1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM            (1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS               (1 + MAXDOSLADDR - MINDOSLADDR)
#define CPGPRIVATE          (1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED           (1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM           (1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS              (1 + MAXDOSPAGE - MINDOSPAGE)
//
// Largest object that could theoretically be allocated
//
#define CBMAXALLOC          (max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC         (max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

//----------------------------------------------------------------------------
//
//  EQUATES FOR SYSTEM_CONTROL CALLS
//
//----------------------------------------------------------------------------

//
// SYS_CRITICAL_INIT is a device init call.  Devices that have a
// critical function that needs initializing before interrupts are
// enabled should do it at Sys_Critical_Init.  Devices which REQUIRE a
// certain range of V86 pages to operate (such as the VDD video memory)
// should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
// Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
// load only.
//
#define SYS_CRITICAL_INIT       0x0000      // Devices req'd for virt mode
//
// DEVICE_INIT is where most devices do the bulk of their initialization.
// SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
// aborts device load only.
//
#define DEVICE_INIT             0x0001      // All other devices init
//
// INIT_COMPLETE is the final phase of device init called just before the
// WIN386 INIT pages are released and the Instance snapshot is taken.
// Devices which wish to search for a region of V86 pages >= A0h to use
// should do it at INIT_COMPLETE.
// SYS VM Simulate_Int, Exec_Int activity is allowed.  Returning carry
// aborts device load only.
//
#define INIT_COMPLETE           0x0002      // All devices initialized
//
// --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------
//
//
// Same as VM_Init, except for SYS VM.
//
#define SYS_VM_INIT             0x0003      // Execute the system VM
//
// Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
// exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
// allowed.  This and Sys_VM_Terminate2 are your last chances to access
// and/or lock pageable data.
//
#define SYS_VM_TERMINATE        0x0004      // System VM terminated
//
// System_Exit call is made when WIN386 is exiting either normally or via
// a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
// SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
//
#define SYSTEM_EXIT             0x0005      // Devices prepare to exit
//
// SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
// a crash.  INTERRUPTS ARE DISABLED.  SYS VM Simulate_Int, Exec_Int ACTIVITY
//  IS NOT ALLOWED.
//
#define SYS_CRITICAL_EXIT       0x0006      // System critical devices reset
//
// Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
// Carry will fail the Create_VM.
//
#define CREATE_VM               0x0007
//
// Second phase of Create_VM.  EBX = VM handle of new VM.  Returning
// Carry will cause the VM to go Not_Executeable, then be destroyed.
// VM Simulate_Int, Exec_Int activity is NOT allowed.
//
#define VM_CRITICAL_INIT        0x0008
//
// Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
// Carry will cause the VM to go Not_Executeable, then be destroyed.
// VM Simulate_Int, Exec_Int activity is allowed.
//
#define VM_INIT                 0x0009
//
// NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
// on normal termination of the VM.  Call cannot be failed.  VM
// Simulate_Int, Exec_Int activity is allowed.
//
#define VM_TERMINATE            0x000A      // Still in VM -- About to die
//
// Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
// below).  Note that in the case of destroying a running VM, this is
// the first call made (VM_Terminate call does not occur).  Call cannot
// be failed.  VM Simulate_Int, Exec_Int activity is NOT allowed.
//
#define VM_NOT_EXECUTEABLE      0x000B      // Most devices die (except VDD)
//
// Final phase of Destroy_VM.  EBX = VM Handle.  Note that considerable
// time can elaps between the VM_Not_Executeable call and this call.
// Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
// allowed.
//
#define DESTROY_VM              0x000C      // VM's control block about to go
//
// Flags for VM_Not_Executeable control call (passed in EDX)
//
#define VNE_CRASHED_Bit         0x00        // VM was crashed
#define VNE_CRASHED             (1 << VNE_CRASHED_Bit)
#define VNE_NUKED_Bit           0x01        // VM was destroyed while active
#define VNE_NUKED               (1 << VNE_NUKED_Bit)
#define VNE_CREATEFAIL_Bit      0x02        // Some device failed Create_VM
#define VNE_CREATEFAIL          (1 << VNE_CREATEFAIL_Bit)
#define VNE_CRINITFAIL_Bit      0x03        // Some device failed VM_Critical_Init
#define VNE_CRINITFAIL          (1 << VNE_CRINITFAIL_Bit)
#define VNE_INITFAIL_Bit        0x04        // Some device failed VM_Init
#define VNE_INITFAIL            (1 << VNE_INITFAIL_Bit)
#define VNE_CLOSED_Bit          0x05
#define VNE_CLOSED              (1 << VNE_CLOSED_Bit)
//
// EBX = VM Handle. Call cannot be failed.
//
#define VM_SUSPEND              0x000D      // VM not runnable until resume
//
// EBX = VM Handle. Returning carry fails and backs out the resume.
//
#define VM_RESUME               0x000E      // VM is leaving suspended state
//
// EBX = VM Handle to set device focus to.  EDX = Device ID if device
// specific setfocus, == 0 if device critical setfocus (all devices).
// THIS CALL CANNOT BE FAILED.
//
// NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
// special functions.  Currently Bit 0 being set indicates that this
// Device critical set focus is also "VM critical".  It means that we
// do not want some other VM to take the focus from this app now.  This
// is primarily used when doing a device critical set focus to Windows
// (the SYS VM) it is interpreted by the SHELL to mean "if an old app
// currently has the Windows activation, set the activation to the
// Windows Shell, not back to the old app".  ALSO in the case where Bit
// 0 is set, EDI = The VM handle of the VM that is "having trouble".
// Set this to 0 if there is no specific VM associated with the
// problem.
//
#define SET_DEVICE_FOCUS        0x000F
//
// EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
//
#define BEGIN_MESSAGE_MODE      0x0010
//
// EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
//
#define END_MESSAGE_MODE        0x0011
//
// ----------------------- SPECIAL CONTROL CALLS ---------------------------
//
//
// Request for reboot.  Call cannot be failed.
//
#define REBOOT_PROCESSOR        0x0012
//
// Query_Destroy is an information call made by the SHELL device before
// an attempt is made to initiate a destroy VM sequence on a running VM
// which has not exited normally.  EBX = VM Handle.  Returning carry
// indicates that a device "has a problem" with allowing this.  THE
// DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
// the user.  All this does is indicate that there is a "problem" with
// allowing the destroy.  The device which returns carry should call
// the SHELL_Message service to post an informational dialog about the
// reason for the problem.
//
#define QUERY_DESTROY           0x0013
//
// ----------------------- DEBUGGING CONTROL CALL --------------------------
//
// Special call for device specific DEBUG information display and activity.
//
#define DEBUG_QUERY             0x0014
//
// -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION -------------
//
//  About to run a protected mode application.
//  EBX = Current VM handle.
//  EDX = Flags
//  EDI -> Application Control Block
//  Returning with carry set fails the call.
//
#define BEGIN_PM_APP            0x0015
//
// Flags for Begin_PM_App (passed in EDX)
//
#define BPA_32_BIT              0x01
#define BPA_32_BIT_FLAG         1
//
// Protected mode application is terminating.
// EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
// EDI -> Application Control Block
//
#define END_PM_APP              0x0016
//
// Called whenever system is about to be rebooted.  Allows VxDs to clean
// up in preperation for reboot.
//
#define DEVICE_REBOOT_NOTIFY    0x0017
#define CRIT_REBOOT_NOTIFY      0x0018
//
// Called when VM is about to be terminated using the Close_VM service
// EBX = Current VM handle (Handle of VM to close)
// EDX = Flags
//       CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
//
#define CLOSE_VM_NOTIFY         0x0019
#define CVNF_CRIT_CLOSE_Bit     0
#define CVNF_CRIT_CLOSE         (1 << CVNF_CRIT_CLOSE_Bit)
//
// Power management event notification.
// EBX = 0
// ESI = event notification message
// EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
// EDX is reserved
//
#define POWER_EVENT             0x001A
#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C
//
// Create_THREAD creates a new thread.  EDI = handle of new thread.
// Returning Carry will fail the Create_THREAD. Message is sent in the
// context of the creating thread.
//
#define  CREATE_THREAD          0x001D
//
// Second phase of creating a thread.  EDI = handle of new thread.  Call cannot
// be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
// never allowed in non-initial threads). Message is sent in the context
// of the newly created thread.
//
#define  THREAD_INIT            0x001E
//
// Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
// This occurs on normal termination of the thread.  Call cannot be failed.
// Simulate_Int, Exec_Int activity is allowed.
//
#define  TERMINATE_THREAD       0x001F
//
// Second phase of Destroy_THREAD.  EDI = Handle of thread,
// EDX = flags (see below).  Note that in the case of destroying a
// running thread, this is the first call made (THREAD_Terminate call
// does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
// activity is NOT allowed.
//
#define  THREAD_Not_Executeable 0x0020
//
// Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
// time can elapse between the THREAD_Not_Executeable call and this call.
// Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
// allowed.
//
#define  DESTROY_THREAD         0x0021
//
// -------------------- CALLS FOR PLUG&PLAY -------------------------
//
// Configuration manager or a devloader is telling a DLVxD that a new devnode
// has been created. EBX is the handle of the new devnode and EDX is the load
// type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
// system control call. Contrarily to the other calls, carry flags must be
// set if any error code other than CR_SUCCESS is to be return.
//
#define PNP_NEW_DEVNODE         0x0022
//
// -------------------- CALLS FOR Win32  -------------------------
//
// vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
// BUGBUG: need more doc here, describing the interface
//
#define W32_DEVICEIOCONTROL     0x0023
//
// sub-functions
//
#define DIOC_GETVERSION         0x0
#define DIOC_OPEN               DIOC_GETVERSION
#define DIOC_CLOSEHANDLE        -1
//
// -------------------- MORE SYSTEM CALLS -------------------------
//
// All these messages are sent immediately following the corresponding
// message of the same name, except that the "2" messages are sent
// in *reverse* init order.
//
#define SYS_VM_TERMINATE2       0x0024
#define SYSTEM_EXIT2            0x0025
#define SYS_CRITICAL_EXIT2      0x0026
#define VM_TERMINATE2           0x0027
#define VM_NOT_EXECUTEABLE2     0x0028
#define DESTROY_VM2             0x0029
#define VM_SUSPEND2             0x002A
#define END_MESSAGE_MODE2       0x002B
#define END_PM_APP2             0x002C
#define DEVICE_REBOOT_NOTIFY2   0x002D
#define CRIT_REBOOT_NOTIFY2     0x002E
#define CLOSE_VM_NOTIFY2        0x002F
//
// VCOMM gets Address of Contention handler from VxDs by sending this
// control message
//
#define GET_CONTENTION_HANDLER  0x0030
#define KERNEL32_INITIALIZED    0x0031
#define KERNEL32_SHUTDOWN       0x0032
#define MAX_SYSTEM_CONTROL      0x0032
//
// Dynamic VxD's can communicate with each other using Directed_Sys_Control
// and a private control message in the following range:
//
#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL   0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL     0x7FFFFFFF
//
// Values returned from VMM_GetSystemInitState in EAX.
//
// Comments represent operations performed by VMM; #define's indicate
// what VMM_GetSystemInitState will return if you call it between the
// previous operation and the next.
//
// Future versions of Windows may have additional init states between the
// ones defined here, so you should be careful to use range checks instead
// of test for equality.
//
// Protected mode is entered
//
#define SYSSTATE_PRESYSCRITINIT     0x00000000
//
// SYS_CRITICAL_INIT is broadcast
//
#define SYSSTATE_PREDEVICEINIT      0x10000000
//
// DEVICE_INIT is broadcast
//
#define SYSSTATE_PREINITCOMPLETE    0x20000000
//
// INIT_COMPLETE is broadcast
// VxD initialization complete
//
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
//
// KERNEL32_INITIALIZED is broadcast
//
#define SYSSTATE_KERNEL32INITED     0x50000000
//
// All initialization completed
// System running normally
// System shutdown initiated
// KERNEL32_SHUTDOWN is broadcast
//
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
//
// System shutdown continues
//
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
//
// SYS_VM_TERMINATE is broadcast
//
#define SYSSTATE_PRESYSTEMEXIT      0xE0000000
//
// SYSTEM_EXIT is broadcast
//
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
//
// SYSTEM_EXIT2 is broadcast
//
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
//
// SYS_CRITICAL_EXIT is broadcast
//
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
//
// SYS_CRITICAL_EXIT2 is broadcast
//
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
//
// Return to real mode
// Alternate path: CAD reboot
//
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
//
// DEVICE_REBOOT_NOTIFY is broadcast
//
#define SYSSTATE_PRECRITREBOOT      0xFFFFF000
//
// CRIT_REBOOT_NOTIFY is broadcast
//
#define SYSSTATE_PREREBOOTCPU       0xFFFFFF00
//
// REBOOT_PROCESSOR is broadcast
// Return to real mode
//
//         S C H E D U L E R   B O O S T   V A L U E S
//
#define RESERVED_LOW_BOOST      0x00000001
#define CUR_RUN_VM_BOOST        0x00000004
#define LOW_PRI_DEVICE_BOOST    0x00000010
#define HIGH_PRI_DEVICE_BOOST   0x00001000
#define CRITICAL_SECTION_BOOST  0x00100000
#define TIME_CRITICAL_BOOST     0x00400000
#define RESERVED_HIGH_BOOST     0x40000000
//
//   F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
//
#define PEF_WAIT_FOR_STI_Bit            0
#define PEF_WAIT_FOR_STI                (1 << PEF_WAIT_FOR_STI_Bit)
#define PEF_WAIT_NOT_CRIT_Bit           1
#define PEF_WAIT_NOT_CRIT               (1 << PEF_WAIT_NOT_CRIT_Bit)
#define PEF_DONT_UNBOOST_Bit            2
#define PEF_DONT_UNBOOST                (1 << PEF_DONT_UNBOOST_Bit)
#define PEF_ALWAYS_SCHED_Bit            3
#define PEF_ALWAYS_SCHED                (1 << PEF_ALWAYS_SCHED_Bit)
#define PEF_TIME_OUT_Bit                4
#define PEF_TIME_OUT                    (1 << PEF_TIME_OUT_Bit)
#define PEF_WAIT_NOT_HW_INT_Bit         5
#define PEF_WAIT_NOT_HW_INT             (1 << PEF_WAIT_NOT_HW_INT_Bit)
#define PEF_WAIT_NOT_NESTED_EXEC_Bit    6
#define PEF_WAIT_NOT_NESTED_EXEC        (1 << PEF_WAIT_NOT_NESTED_EXEC_Bit)
#define PEF_WAIT_IN_PM_Bit              7
#define PEF_WAIT_IN_PM                  (1 << PEF_WAIT_IN_PM_Bit)
#define PEF_THREAD_EVENT_Bit            8
#define PEF_THREAD_EVENT                (1 << PEF_THREAD_EVENT_Bit)
#define PEF_WAIT_FOR_THREAD_STI_Bit     9
#define PEF_WAIT_FOR_THREAD_STI         (1 << PEF_WAIT_FOR_THREAD_STI_Bit)
#define PEF_RING0_EVENT_Bit             10
#define PEF_RING0_EVENT                 (1 << PEF_RING0_EVENT_Bit)
#define PEF_WAIT_CRIT_Bit               11
#define PEF_WAIT_CRIT                   (1 << PEF_WAIT_CRIT_Bit)
#define PEF_WAIT_CRIT_VM_Bit            12
#define PEF_WAIT_CRIT_VM                (1 << PEF_WAIT_CRIT_VM_Bit)
//
// synonyms for event restrictions above
//
#define PEF_WAIT_NOT_TIME_CRIT_Bit          PEF_WAIT_NOT_HW_INT_Bit
#define PEF_WAIT_NOT_TIME_CRIT              PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_Bit    PEF_WAIT_NOT_NESTED_EXEC_Bit
#define PEF_WAIT_NOT_PM_LOCKED_STACK        PEF_WAIT_NOT_NESTED_EXEC
//
// FLAGS FOR BEGIN_CRITICAL_SECTION,
// ENTER_MUTEX AND WAIT_SEMAPHORE
//
#define BLOCK_SVC_INTS_Bit              0
#define BLOCK_SVC_INTS                  (1 << BLOCK_SVC_INTS_Bit)
#define BLOCK_SVC_IF_INTS_LOCKED_Bit    1
#define BLOCK_SVC_IF_INTS_LOCKED        (1 << BLOCK_SVC_IF_INTS_LOCKED_Bit)
#define BLOCK_ENABLE_INTS_Bit           2
#define BLOCK_ENABLE_INTS               (1 << BLOCK_ENABLE_INTS_Bit)
#define BLOCK_POLL_Bit                  3
#define BLOCK_POLL                      (1 << BLOCK_POLL_Bit)
#define BLOCK_THREAD_IDLE_Bit           4
#define BLOCK_THREAD_IDLE               (1 << BLOCK_THREAD_IDLE_Bit)
#define BLOCK_FORCE_SVC_INTS_Bit        5
#define BLOCK_FORCE_SVC_INTS            (1 << BLOCK_FORCE_SVC_INTS_Bit)


//----------------------------------------------------------------------------
//
// Function parameter passing/return type defines.
//
//----------------------------------------------------------------------------

#define CARRY       void
#pragma aux VMM_C   "_*" parm caller []         \
                      value no8087 [EAX]        \
                      modify [EAX EBX ECX EDX];
#pragma aux VMM_CTL "*" parm [EAX] [EBX] [EDX]  \
                      modify [EAX EBX ECX EDX];
#pragma aux VMM_CB  "*" parm [EBX] [EDX]  \
                      modify [EAX EBX ECX EDX];
#pragma aux VMM_API "*" parm [EBX] [ECX]        \
                      modify [EAX EBX ECX EDX];

//----------------------------------------------------------------------------
//
// Function prototypes for VMM interface helper functions.
//
//----------------------------------------------------------------------------

#define vmmControlEntry()
CARRY   vmmControlExit(DWORD);
#define vmmCallBackEntry()
CARRY   vmmCallBackExit(DWORD);
VOID    vmmAPIEntry(VOID);
CARRY   vmmAPIExit(DWORD);

//----------------------------------------------------------------------------
//
// VMM interface inline helper functions.
//
//----------------------------------------------------------------------------

#pragma aux vmmControlExit =    \
            "stc"               \
            "or     EAX, EAX"   \
            "jnz    ctlExit"    \
            "clc"               \
            "ctlExit:"          \
            parm [EAX];

#pragma aux vmmCallBackExit =   \
            "stc"               \
            "or     EAX, EAX"   \
            "jnz    cbExit"     \
            "clc"               \
            "cbExit:"           \
            parm [EAX];

#pragma aux vmmAPIEntry =       \
            "mov    ECX, EBP";

#pragma aux vmmAPIExit =        \
            "stc"               \
            "or     EAX, EAX"   \
            "jnz    cbExit"     \
            "clc"               \
            "cbExit:"           \
            parm [EAX];

//----------------------------------------------------------------------------
//
// Function prototypes for VMM API.
//
//----------------------------------------------------------------------------
//
// Win 3.1 services.
//
VOID  vmmAdjustExecPriority(DWORD, DWORD);
VOID  vmmAdjustExecTime(DWORD, DWORD);
DWORD vmmAllocateGDTSelector(DWORD, DWORD, DWORD);
DWORD vmmAllocateLDTSelector(DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmBeginCriticalSection(DWORD);
VOID  vmmBeginNestExecution(VOID);
VOID  vmmBeginNestV86Exec(VOID);
DWORD vmmBeginReentrantExecution(VOID);
VOID  vmmBeginUseLockedPMStack(VOID);
QWORD vmmBuildDescriptorDWORDs(DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmBuildIntStackFrame(DWORD, DWORD);
DWORD vmmCallGlobalEvent(DWORD, DWORD);
DWORD vmmCallPriorityVMEvent(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmCallVMEvent(DWORD, DWORD, DWORD);
DWORD vmmCallWhenIdle(DWORD);
VOID  vmmCallWhenNotCritical(DWORD, DWORD);
VOID  vmmCallWhenVMIntsEnabled(DWORD, DWORD);
VOID  vmmCallWhenVMReturns(DWORD, DWORD, DWORD);
VOID  vmmCancelGlobalEvent(DWORD);
VOID  vmmCancelPriorityVMEvent(DWORD);
VOID  vmmCancelTimeOut(DWORD);
VOID  vmmCancelVMEvent(DWORD, DWORD);
VOID  vmmClaimCriticalSection(DWORD, DWORD);
DWORD vmmCopyPageTable(DWORD, DWORD, DWORD, DWORD);
DWORD vmmCreateSemaphore(DWORD);
VOID  vmmDestroySemaphore(DWORD);
VOID  vmmDisableGlobalTrapping(DWORD);
VOID  vmmDisableLocalTrapping(DWORD, DWORD);
VOID  vmmDisableVMInts(VOID);
VOID  vmmEnableGlobalTrapping(DWORD);
VOID  vmmEnableVMInts(VOID);
DWORD vmmEndCritAndSuspend(VOID);
DWORD vmmEndCriticalSection(VOID);
VOID  vmmEndNestExecution(VOID);
VOID  vmmEndReentrantExecution(DWORD);
VOID  vmmEndUseLockedPMStack(VOID);
VOID  vmmExecInt(DWORD);
VOID  vmmExecVxDInt(DWORD);
VOID  vmmFatalErrorHandler(DWORD, DWORD);
DWORD vmmFreeGDTSelector(DWORD, DWORD);
DWORD vmmFreeLDTSelector(DWORD, DWORD, DWORD);
DWORD vmmGetAppFlatDSAlias(VOID);
PSTR  vmmGetConfigDirectory(VOID);
DWORD vmmGetCritSectionStatus(VOID);
DWORD vmmGetCritStatusNoBlock(VOID);
DWORD vmmGetCurVMHandle();
QWORD vmmGetDescriptor(DWORD, DWORD, DWORD);
PSTR  vmmGetEnvironmentString(PSTR);
PSTR  vmmGetExecPath(VOID);
VOID  vmmGetFaultHookAddrs(DWORD, PDWORD);
QWORD vmmGetFreePageCount(DWORD);
DWORD vmmGetLastUpdatedSystemTime(VOID);
DWORD vmmGetLastUpdatedVMExecTime(VOID);
VOID  vmmGetMachineInfo(PDWORD);
PSTR  vmmGetNextProfileString(PSTR, PSTR);
DWORD vmmGetNulPageHandle(VOID);
DWORD vmmGetProfileBoolean(DWORD, PSTR, PSTR);
DWORD vmmGetProfileDecimalInt(DWORD, PSTR, PSTR);
DWORD vmmGetProfileHexInt(DWORD, PSTR, PSTR);
PSTR  vmmGetProfileString(PSTR, PSTR, PSTR);
DWORD vmmGetPSPSegment(VOID);
DWORD vmmGetSysPageCount(DWORD);
DWORD vmmGetSystemTime(VOID);
DWORD vmmGetSysVMHandle(VOID);
DWORD vmmGetVMExecTime(VOID);
DWORD vmmGetVMMReenterCount(VOID);
WORD  vmmGetVMMVersion(VOID);
QWORD vmmGetVMPgCount(DWORD, DWORD);
BYTE* vmmHeapAllocate(DWORD, DWORD);
DWORD vmmHeapFree(BYTE*, DWORD);
DWORD vmmHeapGetSize(BYTE*, DWORD);
BYTE* vmmHeapReAllocate(BYTE*, DWORD, DWORD);
DWORD vmmHookDevicePMAPI(DWORD, DWORD);
DWORD vmmHookDeviceService(DWORD, DWORD);
DWORD vmmHookDeviceV86API(DWORD, DWORD);
DWORD vmmHookInvalidPageFault(DWORD);
DWORD vmmHookPMFault(DWORD, DWORD);
DWORD vmmHookV86Fault(DWORD, DWORD);
VOID  vmmHookV86IntChain(DWORD, DWORD);
VOID  vmmHookV86Page(DWORD, DWORD);
DWORD vmmHookVMMFault(DWORD, DWORD);
VOID  vmmInstallIOHandler(DWORD, DWORD);
DWORD vmmInstallMultIOHandlers(DWORD*);
DWORD vmmLinMapIntoV86(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmLinPageLock(DWORD, DWORD, DWORD);
DWORD vmmLinPageUnLock(DWORD, DWORD, DWORD);
DWORD vmmMapFlat(DWORD, DWORD);
DWORD vmmMapFreePhysReg(DWORD, DWORD, DWORD);
DWORD vmmMapIntoV86(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
QWORD vmmMapLinToVMAddr(DWORD, DWORD);
DWORD vmmMapPhysToLinear(DWORD, DWORD, DWORD);
DWORD vmmModifyPageBits(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmNoFailResumeVM(DWORD);
DWORD vmmOpenFile(PSTR, PSTR);
VOID  vmmOutDebugString(PSTR);
VOID  vmmOutDebugStringValue(PSTR, DWORD);
QWORD vmmPageAllocate(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageCheckLinRange(DWORD, DWORD, DWORD);
DWORD vmmPageDiscardPages(DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageFree(DWORD, DWORD);
QWORD vmmPageGetAllocInfo(DWORD);
QWORD vmmPageGetSizeAddr(DWORD, DWORD);
DWORD vmmPageLock(DWORD, DWORD, DWORD, DWORD);
QWORD vmmPageReAllocate(DWORD, DWORD, DWORD);
DWORD vmmPageResetHandlePAddr(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageUnLock(DWORD, DWORD, DWORD, DWORD);
DWORD vmmPhysIntoV86(DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmReleaseCriticalSection(DWORD);
DWORD vmmRemoveExceptionHandler(DWORD);
VOID  vmmRestoreClientState(CRS*);
VOID  vmmResumeExec(VOID);
DWORD vmmResumeVM(DWORD);
VOID  vmmSaveClientState(CRS*);
DWORD vmmScheduleGlobalEvent(DWORD, DWORD);
DWORD vmmScheduleVMEvent(DWORD, DWORD, DWORD);
DWORD vmmSelectorMapFlat(DWORD, DWORD, DWORD);
DWORD vmmSetDescriptor(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmSetFrePhysRegCalBk(DWORD, DWORD);
DWORD vmmSetGlobalTimeOut(DWORD, DWORD, DWORD);
DWORD vmmSetResetV86Pageable(DWORD, DWORD, DWORD, DWORD);
VOID  vmmSetV86IntVector(DWORD, WORD, DWORD);
DWORD vmmSetVMTimeOut(DWORD, DWORD, DWORD, DWORD);
VOID  vmmSignalSemaphore(DWORD);
VOID  vmmSimulateFarCall(DWORD, DWORD);
VOID  vmmSimulateFarJmp(DWORD, DWORD);
VOID  vmmSimulateFarRet(VOID);
VOID  vmmSimulateFarRetN(DWORD);
VOID  vmmSimulateFarInt(DWORD);
VOID  vmmSimulateIret(VOID);
DWORD vmmSimulatePop(VOID);
VOID  vmmSimulatePush(DWORD);
VOID  vmmTestReenter(VOID);
DWORD vmmTestSysVMHandle(DWORD);
DWORD vmmUnhookInvalidPageFault(DWORD);
DWORD vmmUnhookPMFault(DWORD, DWORD);
DWORD vmmUnhookV86Fault(DWORD, DWORD);
DWORD vmmUnhookVMMFault(DWORD, DWORD);
DWORD vmmUnmapFreePhysReg(DWORD, DWORD, DWORD);
VOID  vmmWaitSemaphore(DWORD, DWORD);
DWORD vmmXchgFreePhysReg(DWORD, DWORD, DWORD);
//
// Win 4.0 services.
//
DWORD vmmPageCommit(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageCommitContig(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageCommitPhys(DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageDecommit(DWORD, DWORD, DWORD);
DWORD vmmPageReserve(DWORD, DWORD, DWORD);
DWORD vmmAllocatePMCallBack(DWORD, DWORD);
DWORD vmmAllocateV86CallBack(DWORD, DWORD);
DWORD vmmInstallV86BreakPoint(DWORD, DWORD, DWORD);
DWORD vmmRemoveV86BreakPoint(DWORD);
VOID  vmmCancelThreadEvent(DWORD, DWORD);
DWORD vmmScheduleThreadEvent(DWORD, DWORD, DWORD);
DWORD vmmHookNMIEvent(DWORD);
VOID  vmmUnhookNMIEvent(DWORD);
DWORD vmmCallRestrictedEvent(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmCacelRestrictedEvent(DWORD);
DWORD vmmRegisterPEFProvider(DWORD, DWORD);
DWORD vmmGetNMIHandlerAddr(VOID);
VOID  vmmSetNMIHandlerAddr(DWORD);
DWORD vmmGetSystemInitState(VOID);
DWORD vmmRegisterWin32Services(DWORD, DWORD);
DWORD vmmContextCreate(VOID);
DWORD vmmContextDestroy(DWORD);
DWORD vmmContextSwitch(DWORD);
DWORD vmmGetCurrentContext(VOID);
DWORD vmmPageAttach(DWORD, DWORD, DWORD);
DWORD vmmPageQuery(DWORD, DWORD, DWORD);
DWORD vmmGetRegistryKey(DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegCloseKey(DWORD);
DWORD vmmRegCreateDynKey(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegCreateKey(DWORD, DWORD, DWORD);
DWORD vmmRegDeleteKey(DWORD, DWORD);
DWORD vmmRegDeleteValue(DWORD, DWORD);
DWORD vmmRegEnumKey(DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegEnumValue(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegFlushKey(DWORD);
DWORD vmmRegLoadKey(DWORD, DWORD, DWORD);
DWORD vmmRegOpenKey(DWORD, DWORD, DWORD);
DWORD vmmRegQueryInfoKey(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD,
                         DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegQueryMultipleValues(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegQueryValue(DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegQueryValueEx(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegRemapPreDefKey(DWORD, DWORD);
DWORD vmmRegSaveKey(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegSetValue(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegSetValueEx(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmAdjustThreadExecPriority(DWORD, DWORD);
VOID  vmmCallWhenTaskSwitched(DWORD);
VOID  vmmCallWhenThreadSwitched(DWORD);
DWORD vmmCancelCallWhenTaskSwitched(DWORD);
DWORD vmmCancelCallWhenThreadSwitched(DWORD);
DWORD vmmGetLastUdatedThreadExecTime(DWORD);
DWORD vmmGetThreadExecTime(DWORD);
DWORD vmmGetThreadTerminationStatus(DWORD);
DWORD vmmGetCurThreadHandle(VOID);
DWORD vmmGetInitialThreadHandle(DWORD);
DWORD vmmGetNextThreadHandle(VOID);
DWORD vmmGetSysThreadHandle(VOID);
VOID  vmmGetThreadWin32Pri(DWORD, DWORD *, DWORD *, DWORD *, DWORD *);
DWORD vmmGetVMHandleForThread(DWORD);
DWORD vmmAllocateThreadDataSlot(VOID);
VOID  vmmFreeThreadDataSlot(DWORD);
//
// Debug services.
//
VOID  dbgBreakPoint(VOID);

//----------------------------------------------------------------------------
//
// VMM API inline functions.
//
//----------------------------------------------------------------------------

#define CALL_VXD(v,s)       MK_VDDL(DW v, DW s)
#define MK_VDDL(serv, vd)   \
            "int    20h"    \
            #vd             \
            #serv

#define CALL_VMM(s)         MK_VMDL(DD s)
#define MK_VMDL(vs)         \
            "int    20h"    \
            #vs

#pragma aux vmmAdjustExecPriority =                 \
            CALL_VMM(Adjust_Exec_Priority)          \
            parm [EAX] [EBX];

#pragma aux vmmAdjustExecTime =                     \
            CALL_VMM(Adjust_Execution_Time)         \
            parm [EAX] [EBX];

#pragma aux vmmAllocateGDTSelector =                \
            CALL_VMM(_Allocate_GDT_Selector)        \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmAllocateLDTSelector =                \
            CALL_VMM(_Allocate_LDT_Selector)        \
            parm caller []                          \
            value [EAX];

#pragma aux vmmBeginCriticalSection =               \
            CALL_VMM(Begin_Critical_Section)        \
            parm [ECX];

#pragma aux vmmBeginNestExecution =                 \
            CALL_VMM(Begin_Nest_Exec);

#pragma aux vmmBeginNestV86Exec =                   \
            CALL_VMM(Begin_Nest_V86_Exec);

#pragma aux vmmBeginReentrantExecution =            \
            CALL_VMM(Begin_Reentrant_Execution)     \
            value [ECX];

#pragma aux vmmBeginUseLockedPMStack =              \
            CALL_VMM(Begin_Use_Locked_PM_Stack);

#pragma aux vmmBuildDescriptorDWORDs =              \
            CALL_VMM(_BuildDescriptorDWORDs)        \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmBuildIntStackFrame =                 \
            CALL_VMM(Build_Int_Stack_Frame)         \
            parm [ECX] [EDX];

#pragma aux vmmCallGlobalEvent =                    \
            CALL_VMM(Call_Global_Event)             \
            parm [ESI] [EDX]                        \
            value [ESI];

#pragma aux vmmCallPriorityVMEvent =                \
            CALL_VMM(Call_Priority_VM_Event)        \
            parm [EAX] [EBX] [ECX] [EDX] [ESI] [EDI]\
            value [ESI];

#pragma aux vmmCallVMEvent =                        \
            CALL_VMM(Call_VM_Event)                 \
            parm [EBX] [ESI] [EDX]                  \
            value [ESI];

#pragma aux vmmCallWhenIdle =                       \
            CALL_VMM(Call_When_Idle)                \
            "sbb    EAX, EAX"                       \
            parm [ESI]                              \
            value [EAX];

#pragma aux vmmCallWhenNotCritical =                \
            CALL_VMM(Call_When_Not_Critical)        \
            parm [ESI] [EDX];


#pragma aux vmmCallWhenVMIntsEnabled =              \
            CALL_VMM(Call_When_VM_Ints_Enabled)     \
            parm [EDX] [ESI];

#pragma aux vmmCallWhenVMReturns =                  \
            CALL_VMM(Call_When_VM_Returns)          \
            parm [EAX] [EDX] [ESI];

#pragma aux vmmCancelGlobalEvent =                  \
            CALL_VMM(Cancel_Global_Event)           \
            parm [ESI];

#pragma aux vmmCancelPriorityVMEvent =              \
            CALL_VMM(Cancel_Priority_VM_Event)      \
            parm [ESI];

#pragma aux vmmCancelTimeOut =                      \
            CALL_VMM(Cancel_Time_Out)               \
            parm [ESI];

#pragma aux vmmCancelVMEvent =                      \
            CALL_VMM(Cancel_VM_Event)               \
            parm [EBX] [ESI];

#pragma aux vmmClaimCriticalSection =               \
            CALL_VMM(Claim_Critical_Section)        \
            parm [EAX] [ECX];

#pragma aux vmmCopyPageTable =                      \
            CALL_VMM(_CopyPageTable)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCreateSemaphore =                    \
            CALL_VMM(Create_Semaphore)              \
            parm [ECX]                              \
            value [EAX];

#pragma aux vmmDestroySemaphore =                   \
            CALL_VMM(Destroy_Semaphore)             \
            parm [EAX];

#pragma aux vmmDisableGlobalTrapping =              \
            CALL_VMM(Disable_Global_Trapping)       \
            parm [EDX];

#pragma aux vmmDisableLocalTrapping =               \
            CALL_VMM(Disable_Local_Trapping)        \
            parm [EBX] [EDX];

#pragma aux vmmDisableVMInts =                      \
            CALL_VMM(Disable_VM_Ints);

#pragma aux vmmEnableGlobalTrapping =               \
            CALL_VMM(Enable_Global_Trapping)        \
            parm [EDX];

#pragma aux vmmEnableLocalTrapping =                \
            CALL_VMM(Enable_Local_Trapping)         \
            parm [EBX] [EDX];

#pragma aux vmmEnableVMInts =                       \
            CALL_VMM(Enable_VM_Ints);

#pragma aux vmmEndCritAndSuspend =                  \
            CALL_VMM(End_Crit_And_Suspend)          \
            "sbb    EAX, EAX"                       \
            value [EAX];

#pragma aux vmmEndCriticalSection =                 \
            CALL_VMM(End_Critical_Section);

#pragma aux vmmEndNestExecution =                   \
            CALL_VMM(End_Nest_Exec);

#pragma aux vmmEndReentrantExecution =              \
            CALL_VMM(End_Reentrant_Execution)       \
            parm [ECX];

#pragma aux vmmEndUseLockedPMStack =                \
            CALL_VMM(End_Use_Locked_PM_Stack);

#pragma aux vmmExecInt =                            \
            CALL_VMM(Exec_Int)                      \
            parm [EAX];

#pragma aux vmmExecVxDInt =                         \
            CALL_VMM(Exec_VxD_Int)                  \
            parm routine [];

#pragma aux vmmFatalErrorHandler =                  \
            CALL_VMM(Fatal_Error_Handler)           \
            parm [ESI] [EAX];

#pragma aux vmmFreeGDTSelector =                    \
            CALL_VMM(_Free_GDT_Selector)            \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmFreeLDTSelector =                    \
            CALL_VMM(_Free_LDT_Selector)            \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetAppFlatDSAlias =                  \
            CALL_VMM(_GetAppFlatDSAlias)            \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetConfigDirectory =                 \
            CALL_VMM(Get_Config_Directory)          \
            value [EDX];

#pragma aux vmmGetCritSectionStatus =               \
            CALL_VMM(Get_Crit_Section_Status)       \
            value [ECX];

#pragma aux vmmGetCritStatusNoBlock =               \
            CALL_VMM(Get_Crit_Status_No_Block)      \
            value [ECX];

#pragma aux vmmGetCurVMHandle =                     \
            CALL_VMM(Get_Cur_VM_Handle)             \
            value [EBX];

#pragma aux vmmGetDescriptor =                      \
            CALL_VMM(_GetDescriptor)                \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetEnvironmentString =               \
            CALL_VMM(Get_Environment_String)        \
            parm [ESI]                              \
            value [EDX];

#pragma aux vmmGetExecPath =                        \
            CALL_VMM(Get_Exec_Path)                 \
            value [EDX];

#pragma aux vmmGetFaultHookAddrs =                  \
            "mov    EAX, [ESP]"                     \
            CALL_VMM(Get_Fault_Hook_Addrs)          \
            "mov    EBX, [ESP + 4]"                 \
            "mov    [EBX], EDI"                     \
            "mov    [EBX + 4], EDX"                 \
            "mov    [EBX + 8], ESI"                 \
            parm caller [];

#pragma aux vmmGetFreePageCount =                   \
            CALL_VMM(_GetFreePageCount)             \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetLastUpdatedSystemTime =           \
            CALL_VMM(Get_Last_Updated_System_Time)  \
            value [EAX];

#pragma aux vmmGetLastUpdatedVMExecTime =           \
            CALL_VMM(Get_Last_Updated_VM_Exec_Time) \
            value [EAX];

#pragma aux vmmGetMachineInfo =                     \
            CALL_VMM(Get_Machine_Info)              \
            "mov    EDI, [ESP]"                     \
            "mov    [EDI], EAX"                     \
            "mov    [EDI + 4], EBX"                 \
            "mov    [EDI + 8], ECX"                 \
            "mov    [EDI + 12], EDX"                \
            parm []                                 \
            modify [EAX EBX ECX EDX EDI];

#pragma aux vmmGetNextProfileString =               \
            CALL_VMM(Get_Next_Profile_String)       \
            "jnc    gnpsFound"                      \
            "xor    EDX, EDX"                       \
            "gnpsFound:"                            \
            parm [EDX] [EDI]                        \
            value [EDX];

#pragma aux vmmGetNulPageHandle =                   \
            CALL_VMM(_GetNulPageHandle)             \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetProfileBoolean =                  \
            CALL_VMM(Get_Profile_Boolean)           \
            parm [EAX] [ESI] [EDI]                  \
            value [EAX];

#pragma aux vmmGetProfileDecimalInt =               \
            CALL_VMM(Get_Profile_Decimal_Int)       \
            parm [EAX] [ESI] [EDI]                  \
            value [EAX];

#pragma aux vmmGetProfileHexInt =                   \
            CALL_VMM(Get_Profile_Hex_Int)           \
            parm [EAX] [ESI] [EDI]                  \
            value [EAX];

#pragma aux vmmGetProfileString =                   \
            CALL_VMM(Get_Profile_String)            \
            parm [EDX] [ESI] [EDI]                  \
            value [EDX];

#pragma aux vmmGetPSPSegment =                      \
            CALL_VMM(Get_PSP_Segment)               \
            value [EAX];

#pragma aux vmmGetSysPageCount =                    \
            CALL_VMM(_GetSysPageCount)              \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetSystemTime =                      \
            CALL_VMM(Get_System_Time)               \
            value [EAX];

#pragma aux vmmGetSysVMHandle =                     \
            CALL_VMM(Get_Sys_VM_Handle)             \
            value [EBX];

#pragma aux vmmGetVMExecTime =                      \
            CALL_VMM(Get_VM_Exec_Time)              \
            value [EAX];

#pragma aux vmmGetVMMReenterCount =                 \
            CALL_VMM(Get_VMM_Reenter_Count)         \
            value [ECX];

#pragma aux vmmGetVMMVersion =                      \
            CALL_VMM(Get_VMM_Version)               \
            value [EAX];

#pragma aux vmmGetVMPgCount =                       \
            CALL_VMM(_GetVMPgCount)                 \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHeapAllocate =                       \
            CALL_VMM(_HeapAllocate)                 \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHeapFree =                           \
            CALL_VMM(_HeapFree)                     \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHeapGetSize =                        \
            CALL_VMM(_HeapGetSize)                  \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHeapReAllocate =                     \
            CALL_VMM(_HeapReAllocate)               \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHookDevicePMAPI =                    \
            CALL_VMM(Hook_Device_PM_API)            \
            "jnc    hdpaFound"                      \
            "xor    ESI, ESI"                       \
            "hdpaFound:"                            \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookDeviceService =                  \
            CALL_VMM(Hook_Device_Service)           \
            "jnc    hdsFound"                       \
            "xor    ESI, ESI"                       \
            "hdsFound:"                             \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookDeviceV86API =                   \
            CALL_VMM(Hook_Device_V86_API)           \
            "jnc    hdvaFound"                      \
            "xor    ESI, ESI"                       \
            "hdvaFound:"                            \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookPMFault =                        \
            CALL_VMM(Hook_PM_Fault)                 \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookV86Fault =                       \
            CALL_VMM(Hook_V86_Fault)                \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookV86IntChain =                    \
            CALL_VMM(Hook_V86_Int_Chain)            \
            parm [EAX] [ESI];

#pragma aux vmmHookV86Page =                        \
            CALL_VMM(Hook_V86_Page)                 \
            parm [EAX] [ESI];

#pragma aux vmmHookVMMFault =                       \
            CALL_VMM(Hook_VMM_Fault)                \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmInstallIOHandler =                   \
            CALL_VMM(Install_IO_Handler)            \
            parm [ESI] [EDX];

#pragma aux vmmInstallMultIOHandlers =              \
            CALL_VMM(Install_Mult_IO_Handlers)      \
            parm [EDI]                              \
            value [EDX];

#pragma aux vmmLinMapIntoV86 =                      \
            CALL_VMM(_LinMapIntoV86)                \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmLinPageLock =                        \
            CALL_VMM(_LinPageLock)                  \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmLinPageUnLock =                      \
            CALL_VMM(_LinPageUnLock)                \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmMapFlat =                            \
            "mov    AH, AL"                         \
            "mov    AL, BL"                         \
            CALL_VMM(Map_Flat)                      \
            parm [EAX] [EBX]                        \
            value [EAX];

#pragma aux vmmMapFreePhysReg =                     \
            CALL_VMM(_MapFreePhysReg)               \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmMapIntoV86 =                         \
            CALL_VMM(_MapIntoV86)                   \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmMapLinToVMAddr =                     \
            CALL_VMM(Map_Lin_To_VM_Addr)            \
            parm [EAX ECX]                          \
            value no8087 [ECX EDX];


#pragma aux vmmMapPhysToLinear =                    \
            CALL_VMM(_MapPhysToLinear)              \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmModifyPageBits =                     \
            CALL_VMM(_ModifyPageBits)               \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmNoFailResumeVM =                     \
            CALL_VMM(No_Fail_Resume_VM)             \
            parm [EBX];

#pragma aux vmmOpenFile =                           \
            CALL_VMM(OpenFile)                      \
            "jnc    ofFound"                        \
            "xor    EAX, EAX"                       \
            "ofFound:"                              \
            parm [EDX] [EDI]                        \
            value [EAX];

#pragma aux vmmOutDebugString =                     \
            "pushfd"                                \
            "pushad"                                \
            CALL_VMM(Out_Debug_String)              \
            "popad"                                 \
            "popfd"                                 \
            parm [ESI];

#pragma aux vmmOutDebugStringValue =                \
            "pushfd"                                \
            "pushad"                                \
            CALL_VMM(Out_Debug_String)              \
            "popad"                                 \
            "popfd"                                 \
            parm [ESI] [EAX];

#pragma aux vmmPageAllocate =                       \
            CALL_VMM(_PageAllocate)                 \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageCheckLinRange =                  \
            CALL_VMM(_PageCheckLinRange)            \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageDiscardPages =                   \
            CALL_VMM(_PageDiscardPages)             \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageFree =                           \
            CALL_VMM(_PageFree)                     \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageGetAllocInfo =                   \
            CALL_VMM(_PageGetAllocInfo)             \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageGetSizeAddr =                    \
            CALL_VMM(_PageGetSizeAddr)              \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageLock =                           \
            CALL_VMM(_PageLock)                     \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageReAllocate =                     \
            CALL_VMM(_PageReAllocate)               \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageResetHandlePAddr =               \
            CALL_VMM(_PageResetHandlePAddr)         \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageUnLock =                         \
            CALL_VMM(_PageUnLock)                   \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPhysIntoV86 =                        \
            CALL_VMM(_PhysIntoV86)                  \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmReleaseCriticalSection =             \
            CALL_VMM(Release_Critical_Section)      \
            parm [ECX];

#pragma aux vmmRemoveExceptionHandler =             \
            CALL_VMM(Remove_Exception_Handler)      \
            "sbb    EAX, EAX"                       \
            parm [ESI]                              \
            value [EAX];

#pragma aux vmmRestoreClientState =                 \
            CALL_VMM(Restore_Client_State)          \
            parm [ESI];

#pragma aux vmmResumeExec =                         \
            CALL_VMM(Resume_Exec);

#pragma aux vmmResumeVM =                           \
            CALL_VMM(Resume_VM)                     \
            "sbb    EAX, EAX"                       \
            parm [EBX]                              \
            value [EAX];

#pragma aux vmmSaveClientState =                    \
            CALL_VMM(Save_Client_State)             \
            parm [EDI];

#pragma aux vmmScheduleGlobalEvent =                \
            CALL_VMM(Schedule_Global_Event)         \
            parm [ESI] [EDX]                        \
            value [ESI];

#pragma aux vmmScheduleVMEvent =                    \
            CALL_VMM(Schedule_VM_Event)             \
            parm [EBX] [ESI] [EDX]                  \
            value [ESI];

#pragma aux vmmSelectorMapFlat =                    \
            CALL_VMM(_SelectorMapFlat)              \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetDescriptor =                      \
            CALL_VMM(_SetDescriptor)                \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetFreePhysRegCalBk =                \
            CALL_VMM(_SetFreePhysRegCalBk)          \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetGlobalTimeOut =                   \
            CALL_VMM(Set_Global_Time_Out)           \
            parm [EAX] [EDX] [ESI]                  \
            value [ESI];

#pragma aux vmmSetResetV86Pageable =                \
            CALL_VMM(_SetResetV86Pageable)          \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetV86IntVector =                    \
            CALL_VMM(Set_V86_Int_Vector)            \
            parm [EAX] [CX] [EDX];
            
#pragma aux vmmSetVMTimeOut =                       \
            CALL_VMM(Set_VM_Time_Out)               \
            parm [EAX] [EBX] [EDX] [ESI]            \
            value [ESI];

#pragma aux vmmSignalSemaphore =                    \
            CALL_VMM(Signal_Semaphore)              \
            parm [EAX];

#pragma aux vmmSimulateFarCall =                    \
            CALL_VMM(Simulate_Far_Call)             \
            parm [ECX] [EDX];

#pragma aux vmmSimulateFarJmp =                     \
            CALL_VMM(Simulate_Far_Jmp)              \
            parm [ECX] [EDX];

#pragma aux vmmSimulateFarRet =                     \
            CALL_VMM(Simulate_Far_Ret);

#pragma aux vmmSimulateFarRetN =                    \
            CALL_VMM(Simulate_Far_Ret_N)            \
            parm [EAX];

#pragma aux vmmSimulateFarInt =                     \
            CALL_VMM(Simulate_Int)                  \
            parm [EAX];

#pragma aux vmmSimulateIret =                       \
            CALL_VMM(Simulate_Iret);

#pragma aux vmmSimulatePop =                        \
            CALL_VMM(Simulate_Pop)                  \
            value [EAX];

#pragma aux vmmSimulatePush =                       \
            CALL_VMM(Simulate_Push)                 \
            parm [EAX];

#pragma aux vmmTestReenter =                        \
            CALL_VMM(Test_Reenter);

#pragma aux vmmTestSysVMHandle =                    \
            CALL_VMM(Test_Sys_VM_Handle)            \
            "clc"                                   \
            "jz     tsvhYes"                        \
            "stc"                                   \
            "tsvhYes:"                              \
            "sbb    EAX, EAX"                       \
            parm [EBX]                              \
            value [EAX];

#pragma aux vmmUnhookInvalidPageFault =             \
            CALL_VMM(Unhook_Invalid_Page_Fault)     \
            "sbb    EAX, EAX"                       \
            parm [ESI]                              \
            value [EAX];

#pragma aux vmmUnhookV86IntChain =                  \
            CALL_VMM(Unhook_V86_Int_Chain)           \
            parm [EAX] [ESI];


#pragma aux vmmUnmapFreePhysReg =                   \
            CALL_VMM(_UnmapFreePhysReg)             \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmWaitSemaphore =                      \
            CALL_VMM(Wait_Semaphore)                \
            parm [EAX] [ECX];

#pragma aux vmmXchgFreePhysReg =                    \
            CALL_VMM(_XchgFreePhysReg)              \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//----------------------------------------------------------------------------
//
//  END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
//  FOR COMPATIBILITY.
//
//----------------------------------------------------------------------------

#pragma aux vmmPageCommit =                         \
            CALL_VMM(_PageCommit)                   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageCommitContig =                   \
            CALL_VMM(_PageCommitContig)             \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageCommitPhys =                     \
            CALL_VMM(_PageCommitPhys)               \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageDecommit =                       \
            CALL_VMM(_PageDecommit)                 \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageReserve =                        \
            CALL_VMM(_PageReserve)                  \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmAllocatePMCallBack =                 \
            CALL_VMM(Allocate_PM_Call_Back)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmAllocateV86CallBack =                \
            CALL_VMM(Allocate_V86_Call_Back)        \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmInstallV86BreakPoint =               \
            CALL_VMM(Install_V86_Break_Point)       \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRemoveV86BreakPoint =                \
            CALL_VMM(Remove_V86_Break_Point)        \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCancelThreadEvent =                  \
            CALL_VMM(Cancel_Thread_Event)           \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmScheduleThreadEvent =                \
            CALL_VMM(Schedule_Thread_Event)         \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHookNMIEvent =                       \
            CALL_VMM(Hook_NMI_Event)                \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmUnhookNMIEvent =                     \
            CALL_VMM(Unhook_NMI_Event)              \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCallRestrictedEvent =                \
            CALL_VMM(Call_Restricted_Event)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCancelRestrictedEvent =              \
            CALL_VMM(Cancel_Restricted_Event)       \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegisterPEFProvider =                \
            CALL_VMM(Register_PEF_Provider)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetNMIHandlerAddr =                  \
            CALL_VMM(Get_NMI_Handler_Addr)          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetNMIHandlerAddr =                  \
            CALL_VMM(Set_NMI_Handler_Addr)          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetSystemInitState =                 \
            CALL_VMM(VMM_GetSystemInitState)        \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegisterWin32Services =              \
            CALL_VMM(_Register_Win32_Services)      \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmContextCreate =                      \
            CALL_VMM(_ContextCreate)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmContextDestroy =                     \
            CALL_VMM(_ContextDestroy)               \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmContextSwitch =                      \
            CALL_VMM(_ContextSwitch)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetCurrentContext =                  \
            CALL_VMM(_GetCurrentContext)            \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageAttach =                         \
            CALL_VMM(_PageAttach)                   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageQuery =                          \
            CALL_VMM(_PageQuery)                    \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetRegistryKey =                     \
            CALL_VMM(_GetRegistryKey)               \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegCloseKey =                        \
            CALL_VMM(_RegCloseKey)                  \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegCreateDynKey =                    \
            CALL_VMM(_RegCreateDynKey)              \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegCreateKey =                       \
            CALL_VMM(_RegCreateKey)                 \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegDeleteKey =                       \
            CALL_VMM(_RegDeleteKey)                 \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegDeleteValue =                     \
            CALL_VMM(_RegDeleteValue)               \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegEnumKey =                         \
            CALL_VMM(_RegEnumKey)                   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegEnumValue =                       \
            CALL_VMM(_RegEnumValue)                 \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegFlushKey =                        \
            CALL_VMM(_RegFlushKey)                  \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//#pragma aux vmmRegLoadKey =                         \
//            CALL_VMM(Reg_Load_Key)                  \
//            value [EAX]                             \
//            modify [EAX EBX ECX EDX];

#pragma aux vmmRegOpenKey =                         \
            CALL_VMM(_RegOpenKey)                   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegQueryInfoKey =                    \
            CALL_VMM(_RegQueryInfoKey)              \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegQueryMultipleValues =             \
            CALL_VMM(_RegQueryMultipleValues)       \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegQueryValue =                      \
            CALL_VMM(_RegQueryValue)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegQueryValueEx =                    \
            CALL_VMM(_RegQueryValueEx)              \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegRemapPreDefKey =                  \
            CALL_VMM(_RegRemapPreDefKey)            \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//#pragma aux vmmRegSaveKey =                         \
//            CALL_VMM(Reg_Save_Key)                  \
//            value [EAX]                             \
//            modify [EAX EBX ECX EDX];

#pragma aux vmmRegSetValue =                        \
            CALL_VMM(_RegSetValue)                  \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegSetValueEx =                      \
            CALL_VMM(_RegSetValueEx)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmAdjustThreadExecPriority =           \
            CALL_VMM(Adjust_Thread_Exec_Priority)   \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCallWhenTaskSwitched =               \
            CALL_VMM(Call_When_Task_Switched)       \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCallWhenThreadSwitched =             \
            CALL_VMM(Call_When_Thread_Switched)     \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCancelCallWhenTaskSwitched =         \
            CALL_VMM(Cancel_Call_When_Task_Switched)\
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCancelCallWhenThreadSwitched =       \
            CALL_VMM(Cancel_Call_When_Thread_Switched)\
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetLastUpdatedThreadExecTime =       \
            CALL_VMM(_GetLastUpdatedThreadExecTime) \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetThreadExecTime =                  \
            CALL_VMM(_GetThreadExecTime)            \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetThreadTerminationStatus =         \
            CALL_VMM(_GetThreadTerminationStatus)   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetCurThreadHandle =                 \
            CALL_VMM(Get_Cur_Thread_Handle)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetInitialThreadHandle =             \
            CALL_VMM(Get_Initial_Thread_Handle)     \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetNextThreadHandle =                \
            CALL_VMM(Get_Next_Thread_Handle)        \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetSysThreadHandle =                 \
            CALL_VMM(Get_Sys_Thread_Handle)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetThreadWin32Pri =                  \
            CALL_VMM(Get_Thread_Win32_Pri)          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//#pragma aux vmmGetVMHandleForThread =               \
//            CALL_VMM(Get_VM_Handle_For_Thread)      \
//            value [EAX]                             \
//            modify [EAX EBX ECX EDX];

#pragma aux vmmAllocateThreadDataSlot =             \
            CALL_VMM(_AllocateThreadDataSlot)       \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmFreeThreadDataSlot =                 \
            CALL_VMM(_FreeThreadDataSlot)           \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//----------------------------------------------------------------------------
//
//  DEBUG macros.
//
//----------------------------------------------------------------------------

#pragma aux dbgBreakPoint =                         \
            "int 03h";

#endif // _VMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VMMTYPES.H ===
#ifndef _VMMTYPES_H_
#define _VMMTYPES_H_

#ifndef NULL
#define NULL               0
#endif
#ifndef VOID
#define VOID               void
#endif
#ifndef PASCAL
#define PASCAL             _pascal
#endif
#ifndef CDECL
#define CDECL              _cdecl
#endif

#ifndef BOOL
#define BOOL                unsigned long
#endif
#ifndef FALSE
#define FALSE              0
#endif
#ifndef TRUE
#define TRUE               (~FALSE)
#endif

#ifndef LONG
#define LONG               long
#endif
typedef unsigned char      BYTE;
typedef unsigned short     WORD;
typedef unsigned long      DWORD;
typedef double             QWORD;
typedef unsigned int       UINT;
typedef char *             PSTR;
typedef BYTE *             PBYTE;
typedef int *              PINT;
typedef UINT *             PUINT;
typedef WORD *             PWORD;
typedef DWORD *            PDWORD;
typedef QWORD *            PQWORD;

typedef union
{
    QWORD Desc64;
    DWORD Desc32[2];
    WORD  Desc16[4];
    BYTE  Desc8[8];
} DESCRIPTOR, *PDESCRIPTOR;

typedef union
{
    QWORD HandleAddress;
    struct
    {
        DWORD Handle;
        DWORD Address;
    } ha;
} PAGEALLOC, *PPAGEALLOC;

#ifndef LOBYTE
#define LOBYTE(w)          ((BYTE)(w))
#endif
#ifndef HIBYTE
#define HIBYTE(w)          ((BYTE)(((UINT)(w) >> 8) & 0xFF))
#endif
#ifndef LOWORD
#define LOWORD(l)          ((WORD)(DWORD)(l))
#endif
#ifndef HIWORD
#define HIWORD(l)          ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#endif
#ifndef MAKELONG
#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))
#endif

#endif // _VMMTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VNV0D.H ===
#ifndef _VNV0D_H_
#define _VNV0D_H_
/******** Operating System Interface for NVidia Hardware Simulator  ********\
*                                                                           *
* Module: NVRM.H                                                            *
*       Header file for NV0 defines and service exports.                    *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)     06/21/94 - wrote it                   *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

//
// Version numbers.
//
#define NV0_Major_Version  1
#define NV0_Minor_Version  0
//
// Device IDs.
//
#define NV0_Device_ID      0x32DB
//
// Init order.
//
#define NV0_Init_Order     0x70000000
//
// Virtual device services.
//
#define NV0_Get_Version        0
#define NV0_Install_Handlers   1

//---------------------------------------------------------------------------
//
//  Types.
//
//---------------------------------------------------------------------------

//
// Shared communication buffer structure.
//
typedef DWORD CDECL (*RDPROC)(DWORD, DWORD);
typedef DWORD CDECL (*WRPROC)(DWORD, DWORD, DWORD);
typedef VOID  CDECL (*CTPROC)(VOID);
typedef struct
{
    RDPROC memRead;
    WRPROC memWrite;
    RDPROC ioRead;
    WRPROC ioWrite;
    RDPROC cfgRead;
    WRPROC cfgWrite;
    CTPROC Interrupt;
    DWORD  physBase;
    DWORD  linBase;
    DWORD  ufifoBase;
    DWORD  ufifoCount;
} NV0PROCS, *PNV0PROCS;

//---------------------------------------------------------------------------
//
//  Prototypes to call NV0 services.
//
//---------------------------------------------------------------------------

DWORD nvsimGetVersion(VOID);
LONG  nvsimInstallHandlers(DWORD, PNV0PROCS);
#pragma aux nvsimGetVersion =                           \
            CALL_VXD(NV0_Device_ID, NV0_Get_Version)    \
            parm caller []                              \
            value no8087 [EAX]                          \
            modify [EAX EBX ECX EDX];
#pragma aux nvsimInstallHandlers =                          \
            CALL_VXD(NV0_Device_ID, NV0_Install_Handlers)   \
            parm caller []                                  \
            value no8087 [EAX]                              \
            modify [EAX EBX ECX EDX];
#endif // _VNV0D_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VMM.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef _VMM_
_VMM_	EQU	1
FALSE	EQU	0
VMM_TRUE	EQU	(NOT FALSE)
DEBLEVELRETAIL	EQU	0
DEBLEVELNORMAL	EQU	1
DEBLEVELMAX	EQU	2
ifndef DEBLEVEL
ifdef DEBUG
DEBLEVEL	EQU	DEBLEVELNORMAL
else
DEBLEVEL	EQU	DEBLEVELRETAIL
endif
endif
ifndef WIN31COMPAT
WIN40SERVICES	EQU	1
endif
ifdef MASM6
ifndef NO_MASM6_OPTIONS



    option oldmacros
ifndef  NEWSTRUCTS
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif




IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF

UNDEFINED_DEVICE_ID	EQU	00000H
VMM_DEVICE_ID	EQU	00001H
DEBUG_DEVICE_ID	EQU	00002H
VPICD_DEVICE_ID	EQU	00003H
VDMAD_DEVICE_ID	EQU	00004H
VTD_DEVICE_ID	EQU	00005H
V86MMGR_DEVICE_ID	EQU	00006H
PAGESWAP_DEVICE_ID	EQU	00007H
PARITY_DEVICE_ID	EQU	00008H
REBOOT_DEVICE_ID	EQU	00009H
VDD_DEVICE_ID	EQU	0000AH
VSD_DEVICE_ID	EQU	0000BH
VMD_DEVICE_ID	EQU	0000CH
VKD_DEVICE_ID	EQU	0000DH
VCD_DEVICE_ID	EQU	0000EH
VPD_DEVICE_ID	EQU	0000FH
BLOCKDEV_DEVICE_ID	EQU	00010H
VMCPD_DEVICE_ID	EQU	00011H
EBIOS_DEVICE_ID	EQU	00012H
BIOSXLAT_DEVICE_ID	EQU	00013H
VNETBIOS_DEVICE_ID	EQU	00014H
DOSMGR_DEVICE_ID	EQU	00015H
WINLOAD_DEVICE_ID	EQU	00016H
SHELL_DEVICE_ID	EQU	00017H
VMPOLL_DEVICE_ID	EQU	00018H
VPROD_DEVICE_ID	EQU	00019H
DOSNET_DEVICE_ID	EQU	0001AH
VFD_DEVICE_ID	EQU	0001BH
VDD2_DEVICE_ID	EQU	0001CH
WINDEBUG_DEVICE_ID	EQU	0001DH
TSRLOAD_DEVICE_ID	EQU	0001EH
BIOSHOOK_DEVICE_ID	EQU	0001FH
INT13_DEVICE_ID	EQU	00020H
PAGEFILE_DEVICE_ID	EQU	00021H
SCSI_DEVICE_ID	EQU	00022H
MCA_POS_DEVICE_ID	EQU	00023H
SCSIFD_DEVICE_ID	EQU	00024H
VPEND_DEVICE_ID	EQU	00025H
APM_DEVICE_ID	EQU	00026H
VPOWERD_DEVICE_ID	EQU	APM_DEVICE_ID
VXDLDR_DEVICE_ID	EQU	00027H
NDIS_DEVICE_ID	EQU	00028H
BIOS_EXT_DEVICE_ID	EQU	00029H
VWIN32_DEVICE_ID	EQU	0002AH
VCOMM_DEVICE_ID	EQU	0002BH
SPOOLER_DEVICE_ID	EQU	0002CH
WIN32S_DEVICE_ID	EQU	0002DH
DEBUGCMD_DEVICE_ID	EQU	0002EH
CONFIGMG_DEVICE_ID	EQU	00033H
DWCFGMG_DEVICE_ID	EQU	00034H
SCSIPORT_DEVICE_ID	EQU	00035H
VFBACKUP_DEVICE_ID	EQU	00036H
ENABLE_DEVICE_ID	EQU	00037H
VCOND_DEVICE_ID	EQU	00038H
ISAPNP_DEVICE_ID	EQU	0003CH
BIOS_DEVICE_ID	EQU	0003DH
IFSMgr_Device_ID	EQU	00040H
VCDFSD_DEVICE_ID	EQU	00041H
MRCI2_DEVICE_ID	EQU	00042H
PCI_DEVICE_ID	EQU	00043H
PELOADER_DEVICE_ID	EQU	00044H
EISA_DEVICE_ID	EQU	00045H
DRAGCLI_DEVICE_ID	EQU	00046H
DRAGSRV_DEVICE_ID	EQU	00047H
PERF_DEVICE_ID	EQU	00048H
AWREDIR_DEVICE_ID	EQU	00049H
ETEN_Device_ID	EQU	00060H
CHBIOS_Device_ID	EQU	00061H
VMSGD_Device_ID	EQU	00062H
VPPID_Device_ID	EQU	00063H
VIME_Device_ID	EQU	00064H
VHBIOSD_Device_ID	EQU	00065H
BASEID_FOR_NAMEBASEDVXD	EQU	0f000H
BASEID_FOR_NAMEBASEDVXD_MASK	EQU	0fffH
VMM_INIT_ORDER	EQU	000000000H
DEBUG_INIT_ORDER	EQU	000000000H
DEBUGCMD_INIT_ORDER	EQU	000000000H
PERF_INIT_ORDER	EQU	000900000H
APM_INIT_ORDER	EQU	001000000H
VPOWERD_INIT_ORDER	EQU	APM_INIT_ORDER
BIOSHOOK_INIT_ORDER	EQU	006000000H
VPROD_INIT_ORDER	EQU	008000000H
VPICD_INIT_ORDER	EQU	00C000000H
VTD_INIT_ORDER	EQU	014000000H
VXDLDR_INIT_ORDER	EQU	016000000H
ENUMERATOR_INIT_ORDER	EQU	016800000H
ISAPNP_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
EISA_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
PCI_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
BIOS_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+1
CONFIGMG_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+0FFFFH
VCDFSD_INIT_ORDER	EQU	016F00000H
IOS_INIT_ORDER	EQU	017000000H
PAGEFILE_INIT_ORDER	EQU	018000000H
PAGESWAP_INIT_ORDER	EQU	01C000000H
PARITY_INIT_ORDER	EQU	020000000H
REBOOT_INIT_ORDER	EQU	024000000H
EBIOS_INIT_ORDER	EQU	026000000H
VDD_INIT_ORDER	EQU	028000000H
VSD_INIT_ORDER	EQU	02C000000H
VCD_INIT_ORDER	EQU	030000000H
COMMDRVR_INIT_ORDER	EQU	(VCD_INIT_ORDER-1)
PRTCL_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-2)
MODEM_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-3)
PORT_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-4)
VMD_INIT_ORDER	EQU	034000000H
VKD_INIT_ORDER	EQU	038000000H
VPD_INIT_ORDER	EQU	03C000000H
BLOCKDEV_INIT_ORDER	EQU	040000000H
MCA_POS_INIT_ORDER	EQU	041000000H
SCSIFD_INIT_ORDER	EQU	041400000H
SCSIMASTER_INIT_ORDER	EQU	041800000H
INT13_INIT_ORDER	EQU	042000000H
VMCPD_INIT_ORDER	EQU	048000000H
BIOSXLAT_INIT_ORDER	EQU	050000000H
VNETBIOS_INIT_ORDER	EQU	054000000H
DOSMGR_INIT_ORDER	EQU	058000000H
DOSNET_INIT_ORDER	EQU	05C000000H
WINLOAD_INIT_ORDER	EQU	060000000H
VMPOLL_INIT_ORDER	EQU	064000000H
UNDEFINED_INIT_ORDER	EQU	080000000H
WIN32_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
VCOND_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
WINDEBUG_INIT_ORDER	EQU	081000000H
VDMAD_INIT_ORDER	EQU	090000000H
V86MMGR_INIT_ORDER	EQU	0A0000000H
IFSMgr_Init_Order	EQU	10000H+V86MMGR_Init_Order
FSD_Init_Order	EQU	00100H+IFSMgr_Init_Order
VFD_INIT_ORDER	EQU	50000H+IFSMgr_Init_Order
UNDEF_TOUCH_MEM_INIT_ORDER	EQU	0A8000000H
SHELL_INIT_ORDER	EQU	0B0000000H






IO_Delay    macro
jmp $+2
ENDM

VXD_FAILURE	EQU	0
VXD_SUCCESS	EQU	1

Pushad_Struc	STRUC
Pushad_EDI	DD	?
Pushad_ESI	DD	?
Pushad_EBP	DD	?
Pushad_ESP	DD	?
Pushad_EBX	DD	?
Pushad_EDX	DD	?
Pushad_ECX	DD	?
Pushad_EAX	DD	?
Pushad_Struc	ENDS
ifndef Not_VxD
??_CUR_CODE_SEG = 0

??_LCODE    =   1
??_ICODE    =   2
??_PCODE    =   3
??_SCODE    =   4
??_DBOCODE  =   5
??_16ICODE  =   6
??_RCODE    =   7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE  equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS





IFDEF   MASM6
_FLAT   EQU FLAT
ELSE
_FLAT   EQU USE32
ENDIF


_LTEXT      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT      ENDS

_TEXT       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT       ENDS


_PTEXT      SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT      ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>

IFNB    <classname>
    segname     SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname     SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
        ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB    <grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM











DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM









DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM





CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
        extrn   name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM






MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM






MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or  ??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM



_ITEXT      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT      ENDS


_LDATA      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA      ENDS

_DATA       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA       ENDS


_PDATA      SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA      ENDS


_IDATA      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA      ENDS


_BSS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS        ENDS

CONST       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST       ENDS

_TLS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS        ENDS


_STEXT      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT      ENDS


_SDATA      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA      ENDS


_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS


_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS


_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL

_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS


_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS


_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif


_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS


_RCODE      SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE      ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP	  GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc





































EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF   Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID    = 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName  Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName   MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table

Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&Procedure

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
    EXTRN   Procedure:NEAR
      ELSE
    dd  OFFSET32 Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
        IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
        ENDIF
        IFNB <Condition>
    $$&&Procedure extern
       ELSE
    EXTRN   Procedure:NEAR
        ENDIF
        IFNB <Local_Seg>
Local_Seg&&_ENDS
        ELSE
Def_Segment&_CODE_ENDS
        ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
    dd  OFFSET32 Procedure
      ENDIF

          IFDEF Device_Name&_Name_Based
        @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
          ELSE
        @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
          ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    ENDM

ELSE



IFDEF   Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ENDIF

ENDIF

    ENDM



End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal    macro   reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress    macro   reg,service
    mov reg,OFFSET32 service
    endm


















Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd  csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
        .erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
        dd  OFFSET32 Name,cparm&&Name
    endif
        @32&&Name equ   ((VxDName&_Device_ID SHL 16) + ??w32svcno)
        ??w32svcno = ??w32svcno + 1
        ENDM
    ENDM










End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM











Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM












Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM







Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
        ENDM


BeginDoc

















EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h


cb_s	STRUC
CB_VM_Status	DD	?
CB_High_Linear	DD	?
CB_Client_Pointer	DD	?
CB_VMID	DD	?
CB_Signature	DD	?
cb_s	ENDS
VMCB_ID	EQU	62634D56H
VMSTAT_EXCLUSIVE_BIT	EQU	00H
VMSTAT_EXCLUSIVE	EQU	(1 SHL VMSTAT_EXCLUSIVE_BIT)
VMSTAT_BACKGROUND_BIT	EQU	01H
VMSTAT_BACKGROUND	EQU	(1 SHL VMSTAT_BACKGROUND_BIT)
VMSTAT_CREATING_BIT	EQU	02H
VMSTAT_CREATING	EQU	(1 SHL VMSTAT_CREATING_BIT)
VMSTAT_SUSPENDED_BIT	EQU	03H
VMSTAT_SUSPENDED	EQU	(1 SHL VMSTAT_SUSPENDED_BIT)
VMSTAT_NOT_EXECUTEABLE_BIT	EQU	04H
VMSTAT_NOT_EXECUTEABLE	EQU	(1 SHL VMSTAT_NOT_EXECUTEABLE_BIT)
VMSTAT_PM_EXEC_BIT	EQU	05H
VMSTAT_PM_EXEC	EQU	(1 SHL VMSTAT_PM_EXEC_BIT)
VMSTAT_PM_APP_BIT	EQU	06H
VMSTAT_PM_APP	EQU	(1 SHL VMSTAT_PM_APP_BIT)
VMSTAT_PM_USE32_BIT	EQU	07H
VMSTAT_PM_USE32	EQU	(1 SHL VMSTAT_PM_USE32_BIT)
VMSTAT_VXD_EXEC_BIT	EQU	08H
VMSTAT_VXD_EXEC	EQU	(1 SHL VMSTAT_VXD_EXEC_BIT)
VMSTAT_HIGH_PRI_BACK_BIT	EQU	09H
VMSTAT_HIGH_PRI_BACK	EQU	(1 SHL VMSTAT_HIGH_PRI_BACK_BIT)
VMSTAT_BLOCKED_BIT	EQU	0AH
VMSTAT_BLOCKED	EQU	(1 SHL VMSTAT_BLOCKED_BIT)
VMSTAT_AWAKENING_BIT	EQU	0BH
VMSTAT_AWAKENING	EQU	(1 SHL VMSTAT_AWAKENING_BIT)
VMSTAT_PAGEABLEV86BIT	EQU	0CH
VMSTAT_PAGEABLEV86_BIT	EQU	VMSTAT_PAGEABLEV86BIT
VMSTAT_PAGEABLEV86	EQU	(1 SHL VMSTAT_PAGEABLEV86BIT)
VMSTAT_V86INTSLOCKEDBIT	EQU	0DH
VMSTAT_V86INTSLOCKED_BIT	EQU	VMSTAT_V86INTSLOCKEDBIT
VMSTAT_V86INTSLOCKED	EQU	(1 SHL VMSTAT_V86INTSLOCKEDBIT)
VMSTAT_IDLE_TIMEOUT_BIT	EQU	0EH
VMSTAT_IDLE_TIMEOUT	EQU	(1 SHL VMSTAT_IDLE_TIMEOUT_BIT)
VMSTAT_IDLE_BIT	EQU	0FH
VMSTAT_IDLE	EQU	(1 SHL VMSTAT_IDLE_BIT)
VMSTAT_CLOSING_BIT	EQU	10H
VMSTAT_CLOSING	EQU	(1 SHL VMSTAT_CLOSING_BIT)
VMSTAT_TS_SUSPENDED_BIT	EQU	11H
VMSTAT_TS_SUSPENDED	EQU	(1 SHL VMSTAT_TS_SUSPENDED_BIT)
VMSTAT_TS_MAXPRI_BIT	EQU	12H
VMSTAT_TS_MAXPRI	EQU	(1 SHL VMSTAT_TS_MAXPRI_BIT)
VMSTAT_USE32_MASK	EQU	(VMSTAT_PM_USE32 OR VMSTAT_VXD_EXEC)

tcb_s	STRUC
TCB_Flags	DD	?
TCB_Reserved1	DD	?
TCB_Reserved2	DD	?
TCB_Signature	DD	?
TCB_ClientPtr	DD	?
TCB_VMHandle	DD	?
TCB_ThreadId	DW	?
TCB_PMLockOrigSS	DW	?
TCB_PMLockOrigESP	DD	?
TCB_PMLockOrigEIP	DD	?
TCB_PMLockStackCount	DD	?
TCB_PMLockOrigCS	DW	?
TCB_PMPSPSelector	DW	?
TCB_ThreadType	DD	?
TCB_pad1	DW	?
TCB_pad2	DB	?
TCB_extErrLocus	DB	?
TCB_extErr	DW	?
TCB_extErrAction	DB	?
TCB_extErrClass	DB	?
TCB_extErrPtr	DD	?
tcb_s	ENDS
SCHED_OBJ_ID_THREAD	EQU	42434854H
THFLAG_SUSPENDED_BIT	EQU	03H
THFLAG_SUSPENDED	EQU	(1 SHL THFLAG_SUSPENDED_BIT)
THFLAG_NOT_EXECUTEABLE_BIT	EQU	04H
THFLAG_NOT_EXECUTEABLE	EQU	(1 SHL THFLAG_NOT_EXECUTEABLE_BIT)
THFLAG_THREAD_CREATION_BIT	EQU	08H
THFLAG_THREAD_CREATION	EQU	(1 SHL THFLAG_THREAD_CREATION_BIT)
THFLAG_THREAD_BLOCKED_BIT	EQU	0AH
THFLAG_THREAD_BLOCKED	EQU	(1 SHL THFLAG_THREAD_BLOCKED_BIT)
THFLAG_RING0_THREAD_BIT	EQU	1CH
THFLAG_RING0_THREAD	EQU	(1 SHL THFLAG_RING0_THREAD_BIT)
THFLAG_CHARSET_BITS	EQU	10H
THFLAG_CHARSET_MASK	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_ANSI	EQU	(0 SHL THFLAG_CHARSET_BITS)
THFLAG_OEM	EQU	(1 SHL THFLAG_CHARSET_BITS)
THFLAG_UNICODE	EQU	(2 SHL THFLAG_CHARSET_BITS)
THFLAG_RESERVED	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_EXTENDED_HANDLES_BIT	EQU	12H
THFLAG_EXTENDED_HANDLES	EQU	(1 SHL THFLAG_EXTENDED_HANDLES_BIT)
THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT	EQU	13H
THFLAG_OPEN_AS_IMMOVABLE_FILE	EQU	(1 SHL THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

pmcb_s	STRUC
PMCB_Flags	DD	?
PMCB_Parent	DD	?
pmcb_s	ENDS

VMFaultInfo	STRUC
VMFI_EIP	DD	?
VMFI_CS	DW	?
VMFI_Ints	DW	?
VMFaultInfo	ENDS
Begin_Service_Table VMM, VMM
VMM_Service  Get_VMM_Version, LOCAL
VMM_Service  Get_Cur_VM_Handle
VMM_Service  Test_Cur_VM_Handle
VMM_Service  Get_Sys_VM_Handle
VMM_Service  Test_Sys_VM_Handle
VMM_Service  Validate_VM_Handle
VMM_Service  Get_VMM_Reenter_Count
VMM_Service  Begin_Reentrant_Execution
VMM_Service  End_Reentrant_Execution
VMM_Service  Install_V86_Break_Point
VMM_Service  Remove_V86_Break_Point
VMM_Service  Allocate_V86_Call_Back
VMM_Service  Allocate_PM_Call_Back
VMM_Service  Call_When_VM_Returns
VMM_Service  Schedule_Global_Event
VMM_Service  Schedule_VM_Event
VMM_Service  Call_Global_Event
VMM_Service  Call_VM_Event
VMM_Service  Cancel_Global_Event
VMM_Service  Cancel_VM_Event
VMM_Service  Call_Priority_VM_Event
VMM_Service  Cancel_Priority_VM_Event
VMM_Service  Get_NMI_Handler_Addr
VMM_Service  Set_NMI_Handler_Addr
VMM_Service  Hook_NMI_Event
VMM_Service  Call_When_VM_Ints_Enabled
VMM_Service  Enable_VM_Ints
VMM_Service  Disable_VM_Ints
VMM_Service  Map_Flat
VMM_Service  Map_Lin_To_VM_Addr
VMM_Service  Adjust_Exec_Priority
VMM_Service  Begin_Critical_Section
VMM_Service  End_Critical_Section
VMM_Service  End_Crit_And_Suspend
VMM_Service  Claim_Critical_Section
VMM_Service  Release_Critical_Section
VMM_Service  Call_When_Not_Critical
VMM_Service  Create_Semaphore
VMM_Service  Destroy_Semaphore
VMM_Service  Wait_Semaphore
VMM_Service  Signal_Semaphore
VMM_Service  Get_Crit_Section_Status
VMM_Service  Call_When_Task_Switched
VMM_Service  Suspend_VM
VMM_Service  Resume_VM
VMM_Service  No_Fail_Resume_VM
VMM_Service  Nuke_VM
VMM_Service  Crash_Cur_VM
VMM_Service  Get_Execution_Focus
VMM_Service  Set_Execution_Focus
VMM_Service  Get_Time_Slice_Priority
VMM_Service  Set_Time_Slice_Priority
VMM_Service  Get_Time_Slice_Granularity
VMM_Service  Set_Time_Slice_Granularity
VMM_Service  Get_Time_Slice_Info
VMM_Service  Adjust_Execution_Time
VMM_Service  Release_Time_Slice
VMM_Service  Wake_Up_VM
VMM_Service  Call_When_Idle
VMM_Service  Get_Next_VM_Handle
VMM_Service  Set_Global_Time_Out
VMM_Service  Set_VM_Time_Out
VMM_Service  Cancel_Time_Out
VMM_Service  Get_System_Time
VMM_Service  Get_VM_Exec_Time
VMM_Service  Hook_V86_Int_Chain
VMM_Service  Get_V86_Int_Vector
VMM_Service  Set_V86_Int_Vector
VMM_Service  Get_PM_Int_Vector
VMM_Service  Set_PM_Int_Vector
VMM_Service  Simulate_Int
VMM_Service  Simulate_Iret
VMM_Service  Simulate_Far_Call
VMM_Service  Simulate_Far_Jmp
VMM_Service  Simulate_Far_Ret
VMM_Service  Simulate_Far_Ret_N
VMM_Service  Build_Int_Stack_Frame
VMM_Service  Simulate_Push
VMM_Service  Simulate_Pop
VMM_Service  _HeapAllocate
VMM_Service  _HeapReAllocate
VMM_Service  _HeapFree
VMM_Service  _HeapGetSize
HEAPZEROINIT	EQU	00000001H
HEAPZEROREINIT	EQU	00000002H
HEAPNOCOPY	EQU	00000004H
HEAPLOCKEDIFDP	EQU	00000100H
HEAPSWAP	EQU	00000200H
HEAPINIT	EQU	00000400H
HEAPCLEAN	EQU	00000800H
VMM_Service  _PageAllocate
VMM_Service  _PageReAllocate
VMM_Service  _PageFree
VMM_Service  _PageLock
VMM_Service  _PageUnLock
VMM_Service  _PageGetSizeAddr
VMM_Service  _PageGetAllocInfo
VMM_Service  _GetFreePageCount
VMM_Service  _GetSysPageCount
VMM_Service  _GetVMPgCount
VMM_Service  _MapIntoV86
VMM_Service  _PhysIntoV86
VMM_Service  _TestGlobalV86Mem
VMM_Service  _ModifyPageBits
VMM_Service  _CopyPageTable
VMM_Service  _LinMapIntoV86
VMM_Service  _LinPageLock
VMM_Service  _LinPageUnLock
VMM_Service  _SetResetV86Pageable
VMM_Service  _GetV86PageableArray
VMM_Service  _PageCheckLinRange
VMM_Service  _PageOutDirtyPages
VMM_Service  _PageDiscardPages
PAGEZEROINIT	EQU	00000001H
PAGEUSEALIGN	EQU	00000002H
PAGECONTIG	EQU	00000004H
PAGEFIXED	EQU	00000008H
PAGEDEBUGNULFAULT	EQU	00000010H
PAGEZEROREINIT	EQU	00000020H
PAGENOCOPY	EQU	00000040H
PAGELOCKED	EQU	00000080H
PAGELOCKEDIFDP	EQU	00000100H
PAGESETV86PAGEABLE	EQU	00000200H
PAGECLEARV86PAGEABLE	EQU	00000400H
PAGESETV86INTSLOCKED	EQU	00000800H
PAGECLEARV86INTSLOCKED	EQU	00001000H
PAGEMARKPAGEOUT	EQU	00002000H
PAGEPDPSETBASE	EQU	00004000H
PAGEPDPCLEARBASE	EQU	00008000H
PAGEDISCARD	EQU	00010000H
PAGEPDPQUERYDIRTY	EQU	00020000H
PAGEMAPFREEPHYSREG	EQU	00040000H
PAGENOMOVE	EQU	10000000H
PAGEMAPGLOBAL	EQU	40000000H
PAGEMARKDIRTY	EQU	80000000H
MAPV86_IGNOREWRAP	EQU	00000001H
VMM_Service  _GetNulPageHandle
VMM_Service  _GetFirstV86Page
VMM_Service  _MapPhysToLinear
VMM_Service  _GetAppFlatDSAlias
VMM_Service  _SelectorMapFlat
VMM_Service  _GetDemandPageInfo
VMM_Service  _GetSetPageOutCount
GSPOC_F_GET	EQU	00000001H
VMM_Service  Hook_V86_Page
VMM_Service  _Assign_Device_V86_Pages
VMM_Service  _DeAssign_Device_V86_Pages
VMM_Service  _Get_Device_V86_Pages_Array
VMM_Service  MMGR_SetNULPageAddr
VMM_Service  _Allocate_GDT_Selector
VMM_Service  _Free_GDT_Selector
VMM_Service  _Allocate_LDT_Selector
VMM_Service  _Free_LDT_Selector
VMM_Service  _BuildDescriptorDWORDs
VMM_Service  _GetDescriptor
VMM_Service  _SetDescriptor
BDDEXPLICITDPL	EQU	00000001H
ALDTSPECSEL	EQU	00000001H
VMM_Service  _MMGR_Toggle_HMA
MMGRHMAPHYSICAL	EQU	00000001H
MMGRHMAENABLE	EQU	00000002H
MMGRHMADISABLE	EQU	00000004H
MMGRHMAQUERY	EQU	00000008H
VMM_Service  Get_Fault_Hook_Addrs
VMM_Service  Hook_V86_Fault
VMM_Service  Hook_PM_Fault
VMM_Service  Hook_VMM_Fault
VMM_Service  Begin_Nest_V86_Exec
VMM_Service  Begin_Nest_Exec
VMM_Service  Exec_Int
VMM_Service  Resume_Exec
VMM_Service  End_Nest_Exec
VMM_Service  Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service  Get_Cur_PM_App_CB
VMM_Service  Set_V86_Exec_Mode
VMM_Service  Set_PM_Exec_Mode
VMM_Service  Begin_Use_Locked_PM_Stack
VMM_Service  End_Use_Locked_PM_Stack
VMM_Service  Save_Client_State
VMM_Service  Restore_Client_State
VMM_Service  Exec_VxD_Int
VMM_Service  Hook_Device_Service
VMM_Service  Hook_Device_V86_API
VMM_Service  Hook_Device_PM_API
VMM_Service  System_Control
VMM_Service  Simulate_IO
VMM_Service  Install_Mult_IO_Handlers
VMM_Service  Install_IO_Handler
VMM_Service  Enable_Global_Trapping
VMM_Service  Enable_Local_Trapping
VMM_Service  Disable_Global_Trapping
VMM_Service  Disable_Local_Trapping
VMM_Service  List_Create
VMM_Service  List_Destroy
VMM_Service  List_Allocate
VMM_Service  List_Attach
VMM_Service  List_Attach_Tail
VMM_Service  List_Insert
VMM_Service  List_Remove
VMM_Service  List_Deallocate
VMM_Service  List_Get_First
VMM_Service  List_Get_Next
VMM_Service  List_Remove_First
LF_ASYNC_BIT	EQU	0
LF_ASYNC	EQU	(1 SHL LF_ASYNC_BIT)
LF_USE_HEAP_BIT	EQU	1
LF_USE_HEAP	EQU	(1 SHL LF_USE_HEAP_BIT)
LF_ALLOC_ERROR_BIT	EQU	2
LF_ALLOC_ERROR	EQU	(1 SHL LF_ALLOC_ERROR_BIT)
LF_SWAP	EQU	(LF_USE_HEAP+(1 SHL 3))
VMM_Service  _AddInstanceItem
VMM_Service  _Allocate_Device_CB_Area
VMM_Service  _Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service  _Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service  _Free_Temp_V86_Data_Area, VMM_ICODE
GVDAWordAlign	EQU	00000001H
GVDADWordAlign	EQU	00000002H
GVDAParaAlign	EQU	00000004H
GVDAPageAlign	EQU	00000008H
GVDAInstance	EQU	00000100H
GVDAZeroInit	EQU	00000200H
GVDAReclaim	EQU	00000400H
GVDAInquire	EQU	00000800H
GVDAHighSysCritOK	EQU	00001000H
GVDAOptInstance	EQU	00002000H
GVDAForceLow	EQU	00004000H
TVDANeedTilInitComplete	EQU	00000001H
VMM_Service  Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service  Convert_Decimal_String, VMM_ICODE
VMM_Service  Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service  Convert_Fixed_Point_String, VMM_ICODE
VMM_Service  Get_Profile_Hex_Int, VMM_ICODE
VMM_Service  Convert_Hex_String, VMM_ICODE
VMM_Service  Get_Profile_Boolean, VMM_ICODE
VMM_Service  Convert_Boolean_String, VMM_ICODE
VMM_Service  Get_Profile_String, VMM_ICODE
VMM_Service  Get_Next_Profile_String, VMM_ICODE
VMM_Service  Get_Environment_String, VMM_ICODE
VMM_Service  Get_Exec_Path, VMM_ICODE
VMM_Service  Get_Config_Directory, VMM_ICODE
VMM_Service  OpenFile, VMM_ICODE
VMM_OPENFILE_BUF_SIZE	EQU	260
VMM_Service  Get_PSP_Segment, VMM_ICODE
VMM_Service  GetDOSVectors, VMM_ICODE
VMM_Service  Get_Machine_Info
GMIF_80486_BIT	EQU	10H
GMIF_80486	EQU	(1 SHL GMIF_80486_BIT)
GMIF_PCXT_BIT	EQU	11H
GMIF_PCXT	EQU	(1 SHL GMIF_PCXT_BIT)
GMIF_MCA_BIT	EQU	12H
GMIF_MCA	EQU	(1 SHL GMIF_MCA_BIT)
GMIF_EISA_BIT	EQU	13H
GMIF_EISA	EQU	(1 SHL GMIF_EISA_BIT)
GMIF_CPUID_BIT	EQU	14H
GMIF_CPUID	EQU	(1 SHL GMIF_CPUID_BIT)
VMM_Service  GetSet_HMA_Info
VMM_Service  Set_System_Exit_Code
VMM_Service  Fatal_Error_Handler
VMM_Service  Fatal_Memory_Error
VMM_Service  Update_System_Clock
VMM_Service  Test_Debug_Installed
VMM_Service  Out_Debug_String
VMM_Service  Out_Debug_Chr
VMM_Service  In_Debug_Chr
VMM_Service  Debug_Convert_Hex_Binary
VMM_Service  Debug_Convert_Hex_Decimal
VMM_Service  Debug_Test_Valid_Handle
VMM_Service  Validate_Client_Ptr
VMM_Service  Test_Reenter
VMM_Service  Queue_Debug_String
VMM_Service  Log_Proc_Call
VMM_Service  Debug_Test_Cur_VM
VMM_Service  Get_PM_Int_Type
VMM_Service  Set_PM_Int_Type
VMM_Service  Get_Last_Updated_System_Time
VMM_Service  Get_Last_Updated_VM_Exec_Time
VMM_Service  Test_DBCS_Lead_Byte
.errnz  @@Test_DBCS_Lead_Byte - 100D1h

VMM_Service  _AddFreePhysPage, VMM_ICODE
VMM_Service  _PageResetHandlePAddr
VMM_Service  _SetLastV86Page, VMM_ICODE
VMM_Service  _GetLastV86Page
VMM_Service  _MapFreePhysReg
VMM_Service  _UnmapFreePhysReg
VMM_Service  _XchgFreePhysReg
VMM_Service  _SetFreePhysRegCalBk, VMM_ICODE
VMM_Service  Get_Next_Arena, VMM_ICODE
VMM_Service  Get_Name_Of_Ugly_TSR, VMM_ICODE
VMM_Service  Get_Debug_Options, VMM_ICODE
AFPP_SWAPOUT	EQU	0001H
PCP_CHANGEPAGER	EQU	1H
PCP_CHANGEPAGERDATA	EQU	2H
PCP_VIRGINONLY	EQU	4H
GNA_HIDOSLINKED	EQU	0002H
GNA_ISHIGHDOS	EQU	0004H
VMM_Service  Set_Physical_HMA_Alias, VMM_ICODE
VMM_Service  _GetGlblRng0V86IntBase, VMM_ICODE
VMM_Service  _Add_Global_V86_Data_Area, VMM_ICODE
VMM_Service  GetSetDetailedVMError
GSDVME_PRIVINST	EQU	00010001H
GSDVME_INVALINST	EQU	00010002H
GSDVME_INVALPGFLT	EQU	00010003H
GSDVME_INVALGPFLT	EQU	00010004H
GSDVME_INVALFLT	EQU	00010005H
GSDVME_USERNUKE	EQU	00010006H
GSDVME_DEVNUKE	EQU	00010007H
GSDVME_DEVNUKEHDWR	EQU	00010008H
GSDVME_NUKENOMSG	EQU	00010009H
GSDVME_OKNUKEMASK	EQU	80000000H
GSDVME_INSMEMV86	EQU	00020001H
GSDVME_INSV86SPACE	EQU	00020002H
GSDVME_INSMEMXMS	EQU	00020003H
GSDVME_INSMEMEMS	EQU	00020004H
GSDVME_INSMEMV86HI	EQU	00020005H
GSDVME_INSMEMVID	EQU	00020006H
GSDVME_INSMEMVM	EQU	00020007H
GSDVME_INSMEMDEV	EQU	00020008H
GSDVME_CRTNOMSG	EQU	00020009H
VMM_Service  Is_Debug_Chr
VMM_Service  Clear_Mono_Screen
VMM_Service  Out_Mono_Chr
VMM_Service  Out_Mono_String
VMM_Service  Set_Mono_Cur_Pos
VMM_Service  Get_Mono_Cur_Pos
VMM_Service  Get_Mono_Chr
VMM_Service  Locate_Byte_In_ROM, VMM_ICODE
VMM_Service  Hook_Invalid_Page_Fault
VMM_Service  Unhook_Invalid_Page_Fault
IPF_PGDIR	EQU	00000001H
IPF_V86PG	EQU	00000002H
IPF_V86PGH	EQU	00000004H
IPF_INVTYP	EQU	00000008H
IPF_PGERR	EQU	00000010H
IPF_REFLT	EQU	00000020H
IPF_VMM	EQU	00000040H
IPF_PM	EQU	00000080H
IPF_V86	EQU	00000100H
VMM_Service  Set_Delete_On_Exit_File
VMM_Service  Close_VM
CVF_CONTINUE_EXEC_BIT	EQU	0
CVF_CONTINUE_EXEC	EQU	(1 SHL CVF_CONTINUE_EXEC_BIT)
VMM_Service  Enable_Touch_1st_Meg
VMM_Service  Disable_Touch_1st_Meg
VMM_Service  Install_Exception_Handler
VMM_Service  Remove_Exception_Handler
VMM_Service  Get_Crit_Status_No_Block

.errnz   @@Get_Crit_Status_No_Block - 100F1h

ifdef WIN40SERVICES
VMM_Service  _GetLastUpdatedThreadExecTime
VMM_Service  _Trace_Out_Service
VMM_Service  _Debug_Out_Service
VMM_Service  _Debug_Flags_Service
endif
DFS_LOG_BIT	EQU	0
DFS_LOG	EQU	(1 SHL DFS_LOG_BIT)
DFS_PROFILE_BIT	EQU	1
DFS_PROFILE	EQU	(1 SHL DFS_PROFILE_BIT)
DFS_TEST_CLD_BIT	EQU	2
DFS_TEST_CLD	EQU	(1 SHL DFS_TEST_CLD_BIT)
DFS_NEVER_REENTER_BIT	EQU	3
DFS_NEVER_REENTER	EQU	(1 SHL DFS_NEVER_REENTER_BIT)
DFS_TEST_REENTER_BIT	EQU	4
DFS_TEST_REENTER	EQU	(1 SHL DFS_TEST_REENTER_BIT)
DFS_NOT_SWAPPING_BIT	EQU	5
DFS_NOT_SWAPPING	EQU	(1 SHL DFS_NOT_SWAPPING_BIT)
DFS_TEST_BLOCK_BIT	EQU	6
DFS_TEST_BLOCK	EQU	(1 SHL DFS_TEST_BLOCK_BIT)
DFS_RARE_SERVICES	EQU	0FFFFFF80H
DFS_EXIT_NOBLOCK	EQU	(DFS_RARE_SERVICES+0)
DFS_ENTER_NOBLOCK	EQU	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)
DFS_TEST_NEST_EXEC	EQU	(DFS_RARE_SERVICES+1)
ifdef WIN40SERVICES
VMM_Service  VMMAddImportModuleName
VMM_Service  VMM_Add_DDB
VMM_Service  VMM_Remove_DDB
VMM_Service  Test_VM_Ints_Enabled
VMM_Service  _BlockOnID
VMM_Service  Schedule_Thread_Event
VMM_Service  Cancel_Thread_Event
VMM_Service  Set_Thread_Time_Out
VMM_Service  Set_Async_Time_Out
VMM_Service  _AllocateThreadDataSlot
VMM_Service  _FreeThreadDataSlot
MUTEX_MUST_COMPLETE	EQU	1
MUTEX_NO_CLEANUP_THREAD_STATE	EQU	2
VMM_Service  _CreateMutex
VMM_Service  _DestroyMutex
VMM_Service  _GetMutexOwner
VMM_Service  Call_When_Thread_Switched
VMM_Service  VMMCreateThread
VMM_Service  _GetThreadExecTime
VMM_Service  VMMTerminateThread
VMM_Service  Get_Cur_Thread_Handle
VMM_Service  Test_Cur_Thread_Handle
VMM_Service  Get_Sys_Thread_Handle
VMM_Service  Test_Sys_Thread_Handle
VMM_Service  Validate_Thread_Handle
VMM_Service  Get_Initial_Thread_Handle
VMM_Service  Test_Initial_Thread_Handle
VMM_Service  Debug_Test_Valid_Thread_Handle
VMM_Service  Debug_Test_Cur_Thread
VMM_Service  VMM_GetSystemInitState
VMM_Service  Cancel_Call_When_Thread_Switched
VMM_Service  Get_Next_Thread_Handle
VMM_Service  Adjust_Thread_Exec_Priority
VMM_Service  _Deallocate_Device_CB_Area
VMM_Service  Remove_IO_Handler
VMM_Service  Remove_Mult_IO_Handlers
VMM_Service  Unhook_V86_Int_Chain
VMM_Service  Unhook_V86_Fault
VMM_Service  Unhook_PM_Fault
VMM_Service  Unhook_VMM_Fault
VMM_Service  Unhook_Device_Service
VMM_Service  _PageReserve
VMM_Service  _PageCommit
VMM_Service  _PageDecommit
VMM_Service  _PagerRegister
VMM_Service  _PagerQuery
VMM_Service  _PagerDeregister
VMM_Service  _ContextCreate
VMM_Service  _ContextDestroy
VMM_Service  _PageAttach
VMM_Service  _PageFlush
VMM_Service  _SignalID
VMM_Service  _PageCommitPhys
VMM_Service  _Register_Win32_Services
VMM_Service  Cancel_Call_When_Not_Critical
VMM_Service  Cancel_Call_When_Idle
VMM_Service  Cancel_Call_When_Task_Switched
VMM_Service  _Debug_Printf_Service
VMM_Service  _EnterMutex
VMM_Service  _LeaveMutex
VMM_Service  Simulate_VM_IO
VMM_Service  Signal_Semaphore_No_Switch
VMM_Service  _ContextSwitch
VMM_Service  _PageModifyPermissions
VMM_Service  _PageQuery
VMM_Service  _EnterMustComplete
VMM_Service  _LeaveMustComplete
VMM_Service  _ResumeExecMustComplete
THREAD_TERM_STATUS_CRASH_PEND	EQU	1
THREAD_TERM_STATUS_NUKE_PEND	EQU	2
THREAD_TERM_STATUS_SUSPEND_PEND	EQU	4
VMM_Service  _GetThreadTerminationStatus
VMM_Service  _GetInstanceInfo
INSTINFO_NONE	EQU	0
INSTINFO_SOME	EQU	1
INSTINFO_ALL	EQU	2
VMM_Service  _ExecIntMustComplete
VMM_Service  _ExecVxDIntMustComplete
VMM_Service  Begin_V86_Serialization
VMM_Service  Unhook_V86_Page
VMM_Service  VMM_GetVxDLocationList
VMM_Service  VMM_GetDDBList
VMM_Service  Unhook_NMI_Event
VMM_Service  Get_Instanced_V86_Int_Vector
VMM_Service  Get_Set_Real_DOS_PSP
GSRDP_Set	EQU	0001H
VMM_Service  Call_Priority_Thread_Event
VMM_Service  Get_System_Time_Address
VMM_Service  Get_Crit_Status_Thread
VMM_Service  Get_DDB
VMM_Service  Directed_Sys_Control
VMM_Service  _RegOpenKey
VMM_Service  _RegCloseKey
VMM_Service  _RegCreateKey
VMM_Service  _RegDeleteKey
VMM_Service  _RegEnumKey
VMM_Service  _RegQueryValue
VMM_Service  _RegSetValue
VMM_Service  _RegDeleteValue
VMM_Service  _RegEnumValue
VMM_Service  _RegQueryValueEx
VMM_Service  _RegSetValueEx
ifndef REG_SZ
REG_SZ	EQU	0001H
REG_BINARY	EQU	0003H
endif
ifndef HKEY_LOCAL_MACHINE
HKEY_CLASSES_ROOT	EQU	80000000H
HKEY_CURRENT_USER	EQU	80000001H
HKEY_LOCAL_MACHINE	EQU	80000002H
HKEY_USERS	EQU	80000003H
HKEY_PERFORMANCE_DATA	EQU	80000004H
HKEY_CURRENT_CONFIG	EQU	80000005H
HKEY_DYN_DATA	EQU	80000006H
endif
VMM_Service  _CallRing3
VMM_Service  Exec_PM_Int
VMM_Service  _RegFlushKey
VMM_Service  _PageCommitContig
VMM_Service  _GetCurrentContext
VMM_Service  _LocalizeSprintf
VMM_Service  _LocalizeStackSprintf
VMM_Service  Call_Restricted_Event
VMM_Service  Cancel_Restricted_Event
VMM_Service  Register_PEF_Provider, VMM_ICODE
VMM_Service  _GetPhysPageInfo
VMM_Service  _RegQueryInfoKey
VMM_Service  MemArb_Reserve_Pages
PHYSINFO_NONE	EQU	0
PHYSINFO_SOME	EQU	1
PHYSINFO_ALL	EQU	2
VMM_Service  Time_Slice_Sys_VM_Idle
VMM_Service  Time_Slice_Sleep
VMM_Service  Boost_With_Decay
VMM_Service  Set_Inversion_Pri
VMM_Service  Reset_Inversion_Pri
VMM_Service  Release_Inversion_Pri
VMM_Service  Get_Thread_Win32_Pri
VMM_Service  Set_Thread_Win32_Pri
VMM_Service  Set_Thread_Static_Boost
VMM_Service  Set_VM_Static_Boost
VMM_Service  Release_Inversion_Pri_ID
VMM_Service  Attach_Thread_To_Group
VMM_Service  Detach_Thread_From_Group
VMM_Service  Set_Group_Static_Boost
VMM_Service  _GetRegistryPath, VMM_ICODE
VMM_Service  _GetRegistryKey
REGTYPE_ENUM	EQU	0
REGTYPE_CLASS	EQU	1
REGTYPE_VXD	EQU	2
REGKEY_OPEN	EQU	0
REGKEY_CREATE_IFNOTEXIST	EQU	1
ASSERT_RANGE_NULL_BAD	EQU	00000000H
ASSERT_RANGE_NULL_OK	EQU	00000001H
ASSERT_RANGE_NO_DEBUG	EQU	80000000H
ASSERT_RANGE_BITS	EQU	80000001H
VMM_Service  Cleanup_Thread_State
VMM_Service  _RegRemapPreDefKey
VMM_Service  End_V86_Serialization
VMM_Service  _Assert_Range
VMM_Service  _Sprintf
VMM_Service  _PageChangePager
VMM_Service  _RegCreateDynKey
VMM_Service  _RegQueryMultipleValues
VMM_Service  Boost_Thread_With_VM
BOOT_CLEAN	EQU	00000001H
BOOT_DOSCLEAN	EQU	00000002H
BOOT_NETCLEAN	EQU	00000004H
BOOT_INTERACTIVE	EQU	00000008H
VMM_Service  Get_Boot_Flags
VMM_Service  Set_Boot_Flags
VMM_Service  _lstrcpyn
VMM_Service  _lstrlen
VMM_Service  _lmemcpy
VMM_Service  _GetVxDName
VMM_Service  Force_Mutexes_Free
VMM_Service  Restore_Forced_Mutexes
VMM_Service  _AddReclaimableItem
VMM_Service  _SetReclaimableItem
VMM_Service  _EnumReclaimableItem
VMM_Service  Time_Slice_Wake_Sys_VM
VMM_Service  VMM_Replace_Global_Environment
VMM_Service  Begin_Non_Serial_Nest_V86_Exec
VMM_Service  Get_Nest_Exec_Status
VMM_Service  Open_Boot_Log
VMM_Service  Write_Boot_Log
VMM_Service  Close_Boot_Log
VMM_Service  EnableDisable_Boot_Log
VMM_Service  _Call_On_My_Stack
VMM_Service  Get_Inst_V86_Int_Vec_Base
VMM_Service  _lstrcmpi
VMM_Service  _strupr
VMM_Service  Log_Fault_Call_Out
VMM_Service  _AtEventTime
endif
End_Service_Table VMM, VMM
RS_RECLAIM	EQU	00000001H
RS_RESTORE	EQU	00000002H
RS_DOSARENA	EQU	00000004H

ReclaimStruc	STRUC
RS_Linear	DD	?
RS_Bytes	DD	?
RS_CallBack	DD	?
RS_RefData	DD	?
RS_HookTable	DD	?
RS_Flags	DD	?
ReclaimStruc	ENDS

frmtx	STRUC
frmtx_pfrmtxNext	DD	?
frmtx_hmutex	DD	?
frmtx_cEnterCount	DD	?
frmtx_pthcbOwner	DD	?
frmtx_htimeout	DD	?
frmtx	ENDS

vmmfrinfo	STRUC
vmmfrinfo_frmtxDOS	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxV86	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxOther	DB	SIZE frmtx DUP (?)
vmmfrinfo	ENDS

DemandInfoStruc	STRUC
DILin_Total_Count	DD	?
DIPhys_Count	DD	?
DIFree_Count	DD	?
DIUnlock_Count	DD	?
DILinear_Base_Addr	DD	?
DILin_Total_Free	DD	?
DIPage_Faults	DD	?
DIPage_Ins	DD	?
DIPage_Outs	DD	?
DIPage_Discards	DD	?
DIInstance_Faults	DD	?
DIPagingFileMax	DD	?
DIPagingFileInUse	DD	?
DICommit_Count	DD	?
DIReserved	DD	2 DUP (?)
DemandInfoStruc	ENDS

InstDataStruc	STRUC
InstLinkF	DD	0
InstLinkB	DD	0
InstLinAddr	DD	?
InstSize	DD	?
InstType	DD	?
InstDataStruc	ENDS
INDOS_FIELD	EQU	100H
ALWAYS_FIELD	EQU	200H
OPTIONAL_FIELD	EQU	400H

IPF_Data	STRUC
IPF_LinAddr	DD	?
IPF_MapPageNum	DD	?
IPF_PTEEntry	DD	?
IPF_FaultingVM	DD	?
IPF_Flags	DD	?
IPF_Data	ENDS

Exception_Handler_Struc	STRUC
EH_Reserved	DD	?
EH_Start_EIP	DD	?
EH_End_EIP	DD	?
EH_Handler	DD	?
Exception_Handler_Struc	ENDS
PR_PRIVATE	EQU	80000400H
PR_SHARED	EQU	80060000H
PR_SYSTEM	EQU	80080000H
PR_FIXED	EQU	00000008H
PR_4MEG	EQU	00000001H
PR_STATIC	EQU	00000010H
PD_ZEROINIT	EQU	00000001H
PD_NOINIT	EQU	00000002H
PD_FIXEDZERO	EQU	00000003H
PD_FIXED	EQU	00000004H
PC_FIXED	EQU	00000008H
PC_LOCKED	EQU	00000080H
PC_LOCKEDIFDP	EQU	00000100H
PC_WRITEABLE	EQU	00020000H
PC_USER	EQU	00040000H
PC_INCR	EQU	40000000H
PC_PRESENT	EQU	80000000H
PC_STATIC	EQU	20000000H
PC_DIRTY	EQU	08000000H
PCC_ZEROINIT	EQU	00000001H
PCC_NOLIN	EQU	10000000H
ifndef _WINNT_

_MEMORY_BASIC_INFORMATION	STRUC
mbi_BaseAddress	DD	?
mbi_AllocationBase	DD	?
mbi_AllocationProtect	DD	?
mbi_RegionSize	DD	?
mbi_State	DD	?
mbi_Protect	DD	?
mbi_Type	DD	?
_MEMORY_BASIC_INFORMATION	ENDS
PAGE_NOACCESS	EQU	01H
PAGE_READONLY	EQU	02H
PAGE_READWRITE	EQU	04H
MEM_COMMIT	EQU	1000H
MEM_RESERVE	EQU	2000H
MEM_FREE	EQU	10000H
MEM_PRIVATE	EQU	20000H
endif

pd_s	STRUC
pd_virginin	DD	?
pd_taintedin	DD	?
pd_cleanout	DD	?
pd_dirtyout	DD	?
pd_virginfree	DD	?
pd_taintedfree	DD	?
pd_dirty	DD	?
pd_type	DD	?
pd_s	ENDS
PD_SWAPPER	EQU	0
PD_PAGERONLY	EQU	1
PD_NESTEXEC	EQU	2
endif
PAGESHIFT	EQU	12
PAGESIZE	EQU	(1 SHL PAGESHIFT)
PAGEMASK	EQU	(PAGESIZE-1)
MAXSYSTEMLADDR	EQU	(0ffbfffffH)
MINSYSTEMLADDR	EQU	(0c0000000H)
MAXSHAREDLADDR	EQU	(0bfffffffH)
MINSHAREDLADDR	EQU	(80000000H)
MAXPRIVATELADDR	EQU	(7fffffffH)
MINPRIVATELADDR	EQU	(00400000H)
MAXDOSLADDR	EQU	(003fffffH)
MINDOSLADDR	EQU	(00000000H)
MAXSYSTEMPAGE	EQU	(MAXSYSTEMLADDR SHR PAGESHIFT)
MINSYSTEMPAGE	EQU	(MINSYSTEMLADDR SHR PAGESHIFT)
MAXSHAREDPAGE	EQU	(MAXSHAREDLADDR SHR PAGESHIFT)
MINSHAREDPAGE	EQU	(MINSHAREDLADDR SHR PAGESHIFT)
MAXPRIVATEPAGE	EQU	(MAXPRIVATELADDR SHR PAGESHIFT)
MINPRIVATEPAGE	EQU	(MINPRIVATELADDR SHR PAGESHIFT)
MAXDOSPAGE	EQU	(MAXDOSLADDR SHR PAGESHIFT)
MINDOSPAGE	EQU	(MINDOSLADDR SHR PAGESHIFT)
CBPRIVATE	EQU	(1+MAXPRIVATELADDR-MINPRIVATELADDR)
CBSHARED	EQU	(1+MAXSHAREDLADDR-MINSHAREDLADDR)
CBSYSTEM	EQU	(1+MAXSYSTEMLADDR-MINSYSTEMLADDR)
CBDOS	EQU	(1+MAXDOSLADDR-MINDOSLADDR)
CPGPRIVATE	EQU	(1+MAXPRIVATEPAGE-MINPRIVATEPAGE)
CPGSHARED	EQU	(1+MAXSHAREDPAGE-MINSHAREDPAGE)
CPGSYSTEM	EQU	(1+MAXSYSTEMPAGE-MINSYSTEMPAGE)
CPGDOS	EQU	(1+MAXDOSPAGE-MINDOSPAGE)
IFDEF DEBUG
DebFar  EQU NEAR PTR
ELSE
DebFar  EQU SHORT
ENDIF

ifndef Not_VxD
SYS_CRITICAL_INIT	EQU	0000H
DEVICE_INIT	EQU	0001H
INIT_COMPLETE	EQU	0002H
SYS_VM_INIT	EQU	0003H
SYS_VM_TERMINATE	EQU	0004H
SYSTEM_EXIT	EQU	0005H
SYS_CRITICAL_EXIT	EQU	0006H
CREATE_VM	EQU	0007H
VM_CRITICAL_INIT	EQU	0008H
VM_INIT	EQU	0009H
VM_TERMINATE	EQU	000AH
VM_NOT_EXECUTEABLE	EQU	000BH
DESTROY_VM	EQU	000CH
VNE_CRASHED_BIT	EQU	00H
VNE_CRASHED	EQU	(1 SHL VNE_CRASHED_BIT)
VNE_NUKED_BIT	EQU	01H
VNE_NUKED	EQU	(1 SHL VNE_NUKED_BIT)
VNE_CREATEFAIL_BIT	EQU	02H
VNE_CREATEFAIL	EQU	(1 SHL VNE_CREATEFAIL_BIT)
VNE_CRINITFAIL_BIT	EQU	03H
VNE_CRINITFAIL	EQU	(1 SHL VNE_CRINITFAIL_BIT)
VNE_INITFAIL_BIT	EQU	04H
VNE_INITFAIL	EQU	(1 SHL VNE_INITFAIL_BIT)
VNE_CLOSED_BIT	EQU	05H
VNE_CLOSED	EQU	(1 SHL VNE_CLOSED_BIT)
VM_SUSPEND	EQU	000DH
VM_RESUME	EQU	000EH
SET_DEVICE_FOCUS	EQU	000FH
BEGIN_MESSAGE_MODE	EQU	0010H
END_MESSAGE_MODE	EQU	0011H
REBOOT_PROCESSOR	EQU	0012H
QUERY_DESTROY	EQU	0013H
DEBUG_QUERY	EQU	0014H
BEGIN_PM_APP	EQU	0015H
BPA_32_BIT	EQU	01H
BPA_32_BIT_FLAG	EQU	1
END_PM_APP	EQU	0016H
DEVICE_REBOOT_NOTIFY	EQU	0017H
CRIT_REBOOT_NOTIFY	EQU	0018H
CLOSE_VM_NOTIFY	EQU	0019H
CVNF_CRIT_CLOSE_BIT	EQU	0
CVNF_CRIT_CLOSE	EQU	(1 SHL CVNF_CRIT_CLOSE_BIT)
POWER_EVENT	EQU	001AH
SYS_DYNAMIC_DEVICE_INIT	EQU	001BH
SYS_DYNAMIC_DEVICE_EXIT	EQU	001CH
CREATE_THREAD	EQU	001DH
THREAD_INIT	EQU	001EH
TERMINATE_THREAD	EQU	001FH
THREAD_Not_Executeable	EQU	0020H
DESTROY_THREAD	EQU	0021H
PNP_NEW_DEVNODE	EQU	0022H
W32_DEVICEIOCONTROL	EQU	0023H
DIOC_GETVERSION	EQU	0H
DIOC_OPEN	EQU	DIOC_GETVERSION
DIOC_CLOSEHANDLE	EQU	-1
SYS_VM_TERMINATE2	EQU	0024H
SYSTEM_EXIT2	EQU	0025H
SYS_CRITICAL_EXIT2	EQU	0026H
VM_TERMINATE2	EQU	0027H
VM_NOT_EXECUTEABLE2	EQU	0028H
DESTROY_VM2	EQU	0029H
VM_SUSPEND2	EQU	002AH
END_MESSAGE_MODE2	EQU	002BH
END_PM_APP2	EQU	002CH
DEVICE_REBOOT_NOTIFY2	EQU	002DH
CRIT_REBOOT_NOTIFY2	EQU	002EH
CLOSE_VM_NOTIFY2	EQU	002FH
GET_CONTENTION_HANDLER	EQU	0030H
KERNEL32_INITIALIZED	EQU	0031H
KERNEL32_SHUTDOWN	EQU	0032H
MAX_SYSTEM_CONTROL	EQU	0032H
BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	70000000H
END_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	7FFFFFFFH
endif
SYSSTATE_PRESYSCRITINIT	EQU	00000000H
SYSSTATE_PREDEVICEINIT	EQU	10000000H
SYSSTATE_PREINITCOMPLETE	EQU	20000000H
SYSSTATE_VXDINITCOMPLETED	EQU	40000000H
SYSSTATE_KERNEL32INITED	EQU	50000000H
SYSSTATE_KERNEL32TERMINATED	EQU	0A0000000H
SYSSTATE_PRESYSVMTERMINATE	EQU	0B0000000H
SYSSTATE_PRESYSTEMEXIT	EQU	0E0000000H
SYSSTATE_PRESYSTEMEXIT2	EQU	0E4000000H
SYSSTATE_PRESYSCRITEXIT	EQU	0F0000000H
SYSSTATE_PRESYSCRITEXIT2	EQU	0F4000000H
SYSSTATE_POSTSYSCRITEXIT2	EQU	0FFF00000H
SYSSTATE_PREDEVICEREBOOT	EQU	0FFFF0000H
SYSSTATE_PRECRITREBOOT	EQU	0FFFFF000H
SYSSTATE_PREREBOOTCPU	EQU	0FFFFFF00H
BeginDoc











































































EndDoc












??_pf_Check equ 1
??_pf_ArgsUsed  equ 2
??_pf_Entered   equ 4
??_pf_Left  equ 8
??_pf_Returned  equ    16

??_pushed       =       0
??_align    =   0
??_ends     equ <>

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0
    ??_aframe = 0
    ??_initaframe = 0
    ??_numargs = 0
    ??_numlocals = 0
    ??_numlocalsymbols = 0
    ??_procflags = 0
    ??_esp = 0
    ??_pushed = 0
    ??_align = 0
    ??_hook = 0
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG
    ??_profile = DFS_PROFILE
    ??_test_cld = DFS_TEST_CLD
ELSE
    ??_log = 0
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
    ??_test_cld = 0
ENDIF
    ??_might_block = 0
    ??_test_reenter = 0
    ??_never_reenter = 0
    ??_not_swapping = 0
    ??_prolog_disabled = 0
    ??_public = 1
    ??_cleanoff = 0
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_w32svc = 0
    ??_fleave = FALSE

    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>


    irp arg, <P1, P2, P3, P4, P5, P6, P7>
        if ??_hookarg
        ??_hookarg = 0
        ??_hookvar equ <arg>
        elseifdef ?&&arg&&_BeginProc
            ?&&arg&&_BeginProc
        elseifdef VxD_&&arg&&_CODE_SEG
        ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
        VxD_&&arg&&_CODE_SEG
        else
        .err <Bad param "&arg" to BeginProc>
        endif
    endm


    ifndef Not_VxD
	ife ??_service
	    ifndef profileall
	      ??_profile = 0
	    endif
	    ifdef VMMSYS
		??_prolog_disabled = 1
	    endif
	else
	    ??_test_cld = DFS_TEST_CLD
	endif

	ife ?_16ICODE
	    ??_prolog_disabled = 1
	else
	ife ?_RCODE
	    ??_prolog_disabled = 1
	else
	    ife ?_PCODE
		??_might_block = DFS_TEST_BLOCK
	    endif
	    if ??_service
		ife ??_async_service
		    ??_test_reenter = DFS_TEST_REENTER
		endif
	    endif
    endif
    endif
    endif

    if ??_esp

	??_basereg equ <esp+??_pushed>
	??_initaframe = 4
    else

	??_basereg equ <ebp>
	??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall


    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
         ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
        ??_dfs = 0
    endif



    ifndef Not_VxD

	if ??_hook
	    if ??_align
	    Dword_Align
	    endif
	    prelabeldata:
	    ifndef ??_hookvar
	    .err <HOOK_PROC requires next arg to be name of dword location>
	    endif
	    jmp short Name
	    jmp [??_hookvar]
	    ifdef DEBUG
	    Profile_Data dd  0
	    endif
	    if ??_align
	    .errnz ($ - prelabeldata) mod 4
	    endif
	endif

	ifdef DEBUG
	    ?prolog_&Name label near
	    if (??_service OR ??_profile) AND (??_hook EQ 0)
	    jmp short Name
	    if ??_align
		Dword_Align
	    endif

	    IF ?_ICODE
	    ifdef profileall
	      ?ProfileHeader_BeginProc Profile_Data, %@filename
	    else
	      Profile_Data dd 0
	    endif
	    ELSE
	      Profile_Data dd 0
	    ENDIF

	    endif
	endif

	if ??_align
	    Dword_Align
	endif

    endif

    Name proc near



    ife ??_pcall or ??_ccall or ??_scall
        if ??_public
            public Name
        else
            ifdef DEBUG
                % ?merge @FileName,$,Name,:
                % ?merge public,,,,,@FileName,$,Name
            endif
        endif
    endif
    if ??_ccall
        if ??_public
            _&Name equ Name
	    ifdef Not_VxD
		 public C Name
	    else
                 public _&Name
	    endif
        endif
    endif
    if ??_pcall
        if ??_public
            ?toupper Name
            ?merge  public,,,,%?upper
        endif
    endif


    ifndef Not_VxD
	ifdef DEBUG
	    if ??_dfs EQ DFS_LOG
		VMMCall Log_Proc_Call
	    else
	    if ??_dfs EQ DFS_TEST_REENTER
		VMMCall Test_Reenter
	    else
	    if ??_dfs or ?_LOCKABLECODE eq 0
		ifdef WIN31COMPAT
		    if ??_dfs AND DFS_LOG
			VMMCall Log_Proc_Call
		    endif
		    if ??_dfs AND DFS_TEST_REENTER
			VMMCall Test_Reenter
		    endif
		else
		    ife ?_LOCKABLECODE
		    ifdef ??_debug_flags
			push    ??_debug_flags
			if ??_dfs
			pushfd
			or  dword ptr [esp+4],??_dfs
			popfd
			endif
			VMMCall _Debug_Flags_Service
		    elseif ??_dfs
			push    ??_dfs
			VMMCall _Debug_Flags_Service
		    endif
		    else
		    push    ??_dfs
		    VMMCall _Debug_Flags_Service
		    endif
		endif
	    else
	      ifdef profileall
		IncProfileCount
	      endif
	    endif
	    endif
	    endif
	endif
    endif



endm






?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
	.erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
	.erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
        inc dword ptr [??_name-4]
    else
        ifndef profileall
        .err <IncProfileCount can be used only in services.>
        endif
    endif
endm
else
IncProfileCount macro
endm
endif
















ArgVar  macro   name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
        ?mkarg  <name>, <length>, <used>, %??_numargs
    else
        ?argvar <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg  macro   name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
        ?argvar <name>, <length>, <used>
        &endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro   name,length,used
    local   a
    ifidni  <length>,<BYTE>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
        ?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
        a = ??_aframe
        ??_aframe =  ??_aframe + ((length + 3)/4)*4
        ?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm






?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
        name equ _inaccessible_NOTUSED_
    else
        name equ value
        ??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm



















LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
        ??_pad = 0
    endif
    ifidni  <length>,<BYTE>
        ??_frame = ??_frame + 1 + 3 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
        ??_frame =  ??_frame + 2 + 2 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
        ??_frame = ??_frame + 4
        a = ??_frame
        ?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
        name equ dword ptr [??_basereg-a]
        name&l equ word ptr [??_basereg-a]
        name&ll equ byte ptr [??_basereg-a]
        name&lh equ byte ptr [??_basereg-a+1]
        name&h equ word ptr [??_basereg-a+2]
        name&hl equ byte ptr [??_basereg-a+2]
        name&hh equ byte ptr [??_basereg-a+3]
    else
        ??_frame =  ??_frame + ((length + 3)/4)*4
        a = ??_frame
        ?deflocal <name>
        name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
        ??_numlocalsymbols = ??_numlocalsymbols + 1
        ?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
        name    equ <__inaccessible__NOTINSCOPE__>
        &endm
    endm
    .xcref  ?dodeflocal



EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
        if ??_public
	    ifdef Not_VxD
                ?merge  %??_name,@,%(??_aframe),,label,near
                ?merge  public,,,,C,%??_name,@,%(??_aframe)
	    else
                ?merge  _,%??_name,@,%(??_aframe),label,near
                ?merge  public,,,,,_,%??_name,@,%(??_aframe)
	    endif
        endif
    endif
    if ??_pcall
        ??_aframe = 0
        ?count = ??_numargs
        rept    ??_numargs
            ?invprg <?MKA>,%?count
            ?count = ?count - 1
        endm
    endif
    ??_fleave = FALSE
    if ??_esp
        if  ??_frame
            sub esp, ??_frame
            ??_pushed = ??_pushed + ??_frame
            ??_fleave = VMM_TRUE
        endif
    else
        if  ??_frame eq 0
            if (??_aframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
                ifdef DEBUG
                    push    ebp
                    mov ebp,esp
                    ??_fleave = VMM_TRUE
                endif
            else
                push    ebp
                mov ebp,esp
                ??_fleave = VMM_TRUE
            endif
        else
            enter   ??_frame, 0
            ??_fleave = VMM_TRUE
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm















LeaveProc macro flags
    if ??_fleave
        if ??_esp
            ifidni <flags>,<PRESERVE_FLAGS>
                lea esp,[esp + ??_frame]
            else
                add esp,??_frame
            endif
        else
            leave
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm







Return  macro
    if  ??_cleanoff OR ??_w32svc
        if  ??_w32svc AND (??_aframe LT 8)
            ret 8
        else
            ret ??_aframe
        endif
    else
        ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm




EndProc macro Name, Flag
    Name endp
if ??_w32svc
    if ??_aframe lt 8
        cparm&Name equ 0
    else
        cparm&Name equ (??_aframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi  <Flag>,<NOCHECK>
    if ??_pushed ne 0
        %out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
        ife ??_procflags AND ??_pf_Entered
            %out Warning: ArgVar/LocalVar without EnterProc in Name
        endif
        ife ??_procflags AND ??_pf_Left
            %out Warning: ArgVar/LocalVar without LeaveProc in Name
        endif
        ife ??_procflags AND ??_pf_Returned
            %out Warning: ArgVar/LocalVar without Return in Name
        endif
    endif
endif
ifdifi  <Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
        ?count = ?count + 1
        ?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm







cCall   macro   name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <flags>
    call    name
    ClearCParams
    endm
    .xcref  cCall






pCall   macro   name, arglst
    local   ??saved
    ife .TYPE name
        ?toupper name
    else
        ?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
        push    x
        ??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall







sCall   macro   name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall





iCall   equ <sCall>














IFNDEF  STANDARD_CCALL
NONSTANDARD_CCALL = 1
ENDIF

PushCParams macro arglst, flags
    ??_argc = 0
IFDEF   NONSTANDARD_CCALL
    ??_popargs = 0
ELSE
    ??_popargs = ??_align EQ 0
ENDIF
    ifidni  <flags>, <SMALL>
        ??_popargs = 1
    elseifidni <flags>, <FAST>
        ??_popargs = 0
    endif

    irp x,<arglst>
        ??_argc = ??_argc + 1
        ?marg   <x>,%??_argc
    endm
    ?count = ??_argc
    rept    ??_argc
        ?invprg <?AM>,%?count
        ?count = ?count - 1
    endm
    endm
















ClearCParams macro fPreserveFlags
	if	??_argc ne 0
	    if (??_popargs) AND (??_argc LE 2)
	      rept ??_argc
		pop	ecx
	      endm
	    else
	      ifidni <fPreserveFlags>, <PRESERVE_FLAGS>
		lea	esp, [esp][??_argc * 4]
	      else
		add	esp,??_argc * 4
	      endif
	    endif
	endif
	??_pushed = ??_pushed - (??_argc * 4)
	endm



?marg   macro   name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
        push    name
        ??_pushed = ??_pushed + 4
        &endm
    endm
    .xcref  ?marg



?invprg macro   name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg



?scall  macro   name1, name2
    CondExtern _&name1&@&name2, near
    call    _&name1&@&name2
    endm
    .xcref  ?scall



?merge  macro   l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm



?toupper macro s
      ?upper equ <>
      irpc x,<s>
        if '&x' GE 'a'
          if '&x' LE 'z'
        ?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
        ?upper catstr ?upper,?t1
          else
        ?upper catstr ?upper,<&x>
          endif
        else
          ?upper catstr ?upper,<&x>
        endif
      endm
    endm
    .xcref






CondExtern macro name,dist
    ifdef MASM6
        ifndef name
        externdef name:dist
        endif
    else
        if2
        ifndef name
            extrn name:dist
        endif
        endif
    endif
endm



SaveReg macro   reglist
    irp reg,<reglist>
        ifidni <reg>, <fd>
            pushfd
            ??_pushed = ??_pushed + 4
        else
        ifidni <reg>, <ad>
            pushad
            ??_pushed = ??_pushed + SIZE Pushad_Struc
        else
            push    reg
            ??_pushed = ??_pushed + 4
        endif
        endif
    endm
endm







RestoreReg macro     reglist
    irp reg,<reglist>
        ifidni <reg>, <fd>
            popfd
            ??_pushed = ??_pushed - 4
        else
        ifidni <reg>, <ad>
            popad
            ??_pushed = ??_pushed - SIZE Pushad_Struc
        else
            pop reg
            ??_pushed = ??_pushed - 4
        endif
        endif
    endm
endm

ifdef DEBUG
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db  'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd  OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd  0
VxD_DATA_ENDS
endif
endm


endif
ifndef Not_VxD
RESERVED_LOW_BOOST	EQU	00000001H
CUR_RUN_VM_BOOST	EQU	00000004H
LOW_PRI_DEVICE_BOOST	EQU	00000010H
HIGH_PRI_DEVICE_BOOST	EQU	00001000H
CRITICAL_SECTION_BOOST	EQU	00100000H
TIME_CRITICAL_BOOST	EQU	00400000H
RESERVED_HIGH_BOOST	EQU	40000000H
PEF_WAIT_FOR_STI_BIT	EQU	0
PEF_WAIT_FOR_STI	EQU	(1 SHL PEF_WAIT_FOR_STI_BIT)
PEF_WAIT_NOT_CRIT_BIT	EQU	1
PEF_WAIT_NOT_CRIT	EQU	(1 SHL PEF_WAIT_NOT_CRIT_BIT)
PEF_DONT_UNBOOST_BIT	EQU	2
PEF_DONT_UNBOOST	EQU	(1 SHL PEF_DONT_UNBOOST_BIT)
PEF_ALWAYS_SCHED_BIT	EQU	3
PEF_ALWAYS_SCHED	EQU	(1 SHL PEF_ALWAYS_SCHED_BIT)
PEF_TIME_OUT_BIT	EQU	4
PEF_TIME_OUT	EQU	(1 SHL PEF_TIME_OUT_BIT)
PEF_WAIT_NOT_HW_INT_BIT	EQU	5
PEF_WAIT_NOT_HW_INT	EQU	(1 SHL PEF_WAIT_NOT_HW_INT_BIT)
PEF_WAIT_NOT_NESTED_EXEC_BIT	EQU	6
PEF_WAIT_NOT_NESTED_EXEC	EQU	(1 SHL PEF_WAIT_NOT_NESTED_EXEC_BIT)
PEF_WAIT_IN_PM_BIT	EQU	7
PEF_WAIT_IN_PM	EQU	(1 SHL PEF_WAIT_IN_PM_BIT)
PEF_THREAD_EVENT_BIT	EQU	8
PEF_THREAD_EVENT	EQU	(1 SHL PEF_THREAD_EVENT_BIT)
PEF_WAIT_FOR_THREAD_STI_BIT	EQU	9
PEF_WAIT_FOR_THREAD_STI	EQU	(1 SHL PEF_WAIT_FOR_THREAD_STI_BIT)
PEF_RING0_EVENT_BIT	EQU	10
PEF_RING0_EVENT	EQU	(1 SHL PEF_RING0_EVENT_BIT)
PEF_WAIT_CRIT_BIT	EQU	11
PEF_WAIT_CRIT	EQU	(1 SHL PEF_WAIT_CRIT_BIT)
PEF_WAIT_CRIT_VM_BIT	EQU	12
PEF_WAIT_CRIT_VM	EQU	(1 SHL PEF_WAIT_CRIT_VM_BIT)
PEF_PROCESS_LAST_BIT	EQU	13
PEF_PROCESS_LAST	EQU	(1 SHL PEF_PROCESS_LAST_BIT)
PEF_WAIT_NOT_TIME_CRIT_BIT	EQU	PEF_WAIT_NOT_HW_INT_BIT
PEF_WAIT_NOT_TIME_CRIT	EQU	PEF_WAIT_NOT_HW_INT
PEF_WAIT_NOT_PM_LOCKED_STACK_BIT	EQU	PEF_WAIT_NOT_NESTED_EXEC_BIT
PEF_WAIT_NOT_PM_LOCKED_STACK	EQU	PEF_WAIT_NOT_NESTED_EXEC
BLOCK_SVC_INTS_BIT	EQU	0
BLOCK_SVC_INTS	EQU	(1 SHL BLOCK_SVC_INTS_BIT)
BLOCK_SVC_IF_INTS_LOCKED_BIT	EQU	1
BLOCK_SVC_IF_INTS_LOCKED	EQU	(1 SHL BLOCK_SVC_IF_INTS_LOCKED_BIT)
BLOCK_ENABLE_INTS_BIT	EQU	2
BLOCK_ENABLE_INTS	EQU	(1 SHL BLOCK_ENABLE_INTS_BIT)
BLOCK_POLL_BIT	EQU	3
BLOCK_POLL	EQU	(1 SHL BLOCK_POLL_BIT)
BLOCK_THREAD_IDLE_BIT	EQU	4
BLOCK_THREAD_IDLE	EQU	(1 SHL BLOCK_THREAD_IDLE_BIT)
BLOCK_FORCE_SVC_INTS_BIT	EQU	5
BLOCK_FORCE_SVC_INTS	EQU	(1 SHL BLOCK_FORCE_SVC_INTS_BIT)

Client_Reg_Struc	STRUC
Client_EDI	DD	?
Client_ESI	DD	?
Client_EBP	DD	?
Client_res0	DD	?
Client_EBX	DD	?
Client_EDX	DD	?
Client_ECX	DD	?
Client_EAX	DD	?
Client_Error	DD	?
Client_EIP	DD	?
Client_CS	DW	?
Client_res1	DW	?
Client_EFlags	DD	?
Client_ESP	DD	?
Client_SS	DW	?
Client_res2	DW	?
Client_ES	DW	?
Client_res3	DW	?
Client_DS	DW	?
Client_res4	DW	?
Client_FS	DW	?
Client_res5	DW	?
Client_GS	DW	?
Client_res6	DW	?
Client_Alt_EIP	DD	?
Client_Alt_CS	DW	?
Client_res7	DW	?
Client_Alt_EFlags	DD	?
Client_Alt_ESP	DD	?
Client_Alt_SS	DW	?
Client_res8	DW	?
Client_Alt_ES	DW	?
Client_res9	DW	?
Client_Alt_DS	DW	?
Client_res10	DW	?
Client_Alt_FS	DW	?
Client_res11	DW	?
Client_Alt_GS	DW	?
Client_res12	DW	?
Client_Reg_Struc	ENDS

Client_Word_Reg_Struc	STRUC
Client_DI	DW	?
Client_res13	DW	?
Client_SI	DW	?
Client_res14	DW	?
Client_BP	DW	?
Client_res15	DW	?
Client_res16	DD	?
Client_BX	DW	?
Client_res17	DW	?
Client_DX	DW	?
Client_res18	DW	?
Client_CX	DW	?
Client_res19	DW	?
Client_AX	DW	?
Client_res20	DW	?
Client_res21	DD	?
Client_IP	DW	?
Client_res22	DW	?
Client_res23	DD	?
Client_Flags	DW	?
Client_res24	DW	?
Client_SP	DW	?
Client_res25	DW	?
Client_res26	DD	5 DUP (?)
Client_Alt_IP	DW	?
Client_res27	DW	?
Client_res28	DD	?
Client_Alt_Flags	DW	?
Client_res29	DW	?
Client_Alt_SP	DW	?
Client_Word_Reg_Struc	ENDS

Client_Byte_Reg_Struc	STRUC
Client_res30	DD	4 DUP (?)
Client_BL	DB	?
Client_BH	DB	?
Client_res31	DW	?
Client_DL	DB	?
Client_DH	DB	?
Client_res32	DW	?
Client_CL	DB	?
Client_CH	DB	?
Client_res33	DW	?
Client_AL	DB	?
Client_AH	DB	?
Client_Byte_Reg_Struc	ENDS
?UnionSize = 0
if size Client_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Reg_Struc
endif
CRS	equ	<(byte ptr 0)>

if size Client_Word_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Word_Reg_Struc
endif
CWRS	equ	<(byte ptr 0)>

if size Client_Byte_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Byte_Reg_Struc
endif
CBRS	equ	<(byte ptr 0)>


tagCLIENT_STRUC	STRUC
	DB	?UnionSize dup(?)
tagCLIENT_STRUC	ENDS

IF 0
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX

endif
DYNA_LINK_INT	EQU	20H












DeclareNonstandardCcallService macro arglst
	irp	x,<arglst>
	    ??_nonstandardccall_&x = 1
	endm
endm







DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page, _Assert_Range>

BeginDoc













EndDoc


BeginDoc








EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd  OFFSET32 vt[sn+jf]
ENDM

GenDD   MACRO   P, vid, snum, jflag
    LOCAL   vtable
IFDEF   @@VxDName&vid
    Deftable    vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd  @@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_nonstandardccall_&P
    PushCParams <Param>, <FAST>
    else
    PushCParams <Param>, <flags>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
    else
	ClearCParams
    endif
    ENDM

VxDJmp  MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc




























EndDoc




VxD_CODE_SEG    EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS   EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT   ENDS
        ENDM




VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT   ENDS
        ENDM




VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
        ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
        ENDM




VxD_INIT_CODE_SEG   MACRO
_ITEXT  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT  ENDS
        ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS




VxD_DATA_SEG    EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS   EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA   ENDS
        ENDM




VxD_IDATA_SEG   MACRO
_IDATA  SEGMENT
        ENDM
VxD_IDATA_ENDS  MACRO
_IDATA  ENDS
        ENDM




VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA   ENDS
        ENDM




VxD_STATIC_CODE_SEG MACRO
_STEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT   ENDS
        ENDM




VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA   ENDS
        ENDM



VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
        ENDM




VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
          ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
           ENDM



VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
          ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
           ENDM

endif
ifndef DDK_VERSION
ifdef WIN31COMPAT
DDK_VERSION	EQU	30AH
else
DDK_VERSION	EQU	400H
endif
endif

VxD_Desc_Block	STRUC
DDB_Next	DD	?
DDB_SDK_Version	DW	DDK_VERSION
DDB_Req_Device_Number	DW	UNDEFINED_DEVICE_ID
DDB_Dev_Major_Version	DB	0
DDB_Dev_Minor_Version	DB	0
DDB_Flags	DW	0
DDB_Name	DB	"        "
DDB_Init_Order	DD	UNDEFINED_INIT_ORDER
DDB_Control_Proc	DD	?
DDB_V86_API_Proc	DD	0
DDB_PM_API_Proc	DD	0
DDB_V86_API_CSIP	DD	0
DDB_PM_API_CSIP	DD	0
DDB_Reference_Data	DD	?
DDB_Service_Table_Ptr	DD	0
DDB_Service_Table_Size	DD	0
DDB_Win32_Service_Table	DD	0
DDB_Prev	DD	'Prev'
DDB_Size	DD	SIZE(VxD_Desc_Block)
DDB_Reserved1	DD	'Rsv1'
DDB_Reserved2	DD	'Rsv2'
DDB_Reserved3	DD	'Rsv3'
VxD_Desc_Block	ENDS
ifndef Not_VxD
DDB_SYS_CRIT_INIT_DONE_BIT	EQU	0
DDB_SYS_CRIT_INIT_DONE	EQU	(1 SHL DDB_SYS_CRIT_INIT_DONE_BIT)
DDB_DEVICE_INIT_DONE_BIT	EQU	1
DDB_DEVICE_INIT_DONE	EQU	(1 SHL DDB_DEVICE_INIT_DONE_BIT)
DDB_HAS_WIN32_SVCS_BIT	EQU	14
DDB_HAS_WIN32_SVCS	EQU	(1 SHL DDB_HAS_WIN32_SVCS_BIT)
DDB_DYNAMIC_VXD_BIT	EQU	15
DDB_DYNAMIC_VXD	EQU	(1 SHL DDB_DYNAMIC_VXD_BIT)
DDB_DEVICE_DYNALINKED_BIT	EQU	13
DDB_DEVICE_DYNALINKED	EQU	(1 SHL DDB_DEVICE_DYNALINKED_BIT)
BeginDoc







EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB    <Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
        Ref_Data_Offset EQU 0
ELSE
        Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db  0dh, 0ah, 'D_E_B_U_G===>'
        db      "&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
             OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
             ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM





























Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd  OFFSET32 ??_cd_&&num
ELSE
    dd  OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc




















EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz  Procedure
ENDIF

ELSE

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF

    ENDM

BYTE_INPUT	EQU	000H
BYTE_OUTPUT	EQU	004H
WORD_INPUT	EQU	008H
WORD_OUTPUT	EQU	00CH
DWORD_INPUT	EQU	010H
DWORD_OUTPUT	EQU	014H
OUTPUT_BIT	EQU	2
OUTPUT	EQU	(1 SHL OUTPUT_BIT)
WORD_IO_BIT	EQU	3
WORD_IO	EQU	(1 SHL WORD_IO_BIT)
DWORD_IO_BIT	EQU	4
DWORD_IO	EQU	(1 SHL DWORD_IO_BIT)
STRING_IO_BIT	EQU	5
STRING_IO	EQU	(1 SHL STRING_IO_BIT)
REP_IO_BIT	EQU	6
REP_IO	EQU	(1 SHL REP_IO_BIT)
ADDR_32_IO_BIT	EQU	7
ADDR_32_IO	EQU	(1 SHL ADDR_32_IO_BIT)
REVERSE_IO_BIT	EQU	8
REVERSE_IO	EQU	(1 SHL REVERSE_IO_BIT)
IO_SEG_MASK	EQU	0FFFF0000H
IO_SEG_SHIFT	EQU	10H
BeginDoc






EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je  Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb  In_Proc
ELSE
    je  Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc







EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM

BeginDoc








EndDoc


VxD_IOT_Hdr	STRUC
VxD_IO_Ports	DW	?
VxD_IOT_Hdr	ENDS

VxD_IO_Struc	STRUC
VxD_IO_Port	DW	?
VxD_IO_Proc	DD	?
VxD_IO_Struc	ENDS
.ERRNZ SIZE VxD_IOT_Hdr - 2
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw  Table_Name&_Entries
ELSE
    dw  ?
ENDIF
ELSE
    dw  Table_Name&_Entries
ENDIF

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6
VxD_IO MACRO Port, Proc_Name
    dw  Port
    dd  OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
        ENDM













Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc














EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc






EndDoc

IFDEF   DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF



PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16











Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM



VxDint  MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
        VMMCall _ExecVxDIntMustComplete
    ENDM



endif
DUPLICATE_DEVICE_ID_BIT	EQU	0
DUPLICATE_DEVICE_ID	EQU	(1 SHL DUPLICATE_DEVICE_ID_BIT)
DUPLICATE_FROM_INT2F_BIT	EQU	1
DUPLICATE_FROM_INT2F	EQU	(1 SHL DUPLICATE_FROM_INT2F_BIT)
LOADING_FROM_INT2F_BIT	EQU	2
LOADING_FROM_INT2F	EQU	(1 SHL LOADING_FROM_INT2F_BIT)
DEVICE_LOAD_OK	EQU	0
ABORT_DEVICE_LOAD	EQU	1
ABORT_WIN386_LOAD	EQU	2
NO_FAIL_MESSAGE_BIT	EQU	15
NO_FAIL_MESSAGE	EQU	(1 SHL NO_FAIL_MESSAGE_BIT)
LDRSRV_GET_PROFILE_STRING	EQU	0
LDRSRV_GET_NEXT_PROFILE_STRING	EQU	1
LDRSRV_RESERVED	EQU	2
LDRSRV_GET_PROFILE_BOOLEAN	EQU	3
LDRSRV_GET_PROFILE_DECIMAL_INT	EQU	4
LDRSRV_GET_PROFILE_HEX_INT	EQU	5
LDRSRV_COPY_EXTENDED_MEMORY	EQU	6
LDRSRV_GET_MEMORY_INFO	EQU	7
LDRSRV_RegOpenKey	EQU	100H
LDRSRV_RegCreateKey	EQU	101H
LDRSRV_RegCloseKey	EQU	102H
LDRSRV_RegDeleteKey	EQU	103H
LDRSRV_RegSetValue	EQU	104H
LDRSRV_RegQueryValue	EQU	105H
LDRSRV_RegEnumKey	EQU	106H
LDRSRV_RegDeleteValue	EQU	107H
LDRSRV_RegEnumValue	EQU	108H
LDRSRV_RegQueryValueEx	EQU	109H
LDRSRV_RegSetValueEx	EQU	10AH
LDRSRV_RegFlushKey	EQU	10BH
LDRSRV_COPY_INIT	EQU	1
LDRSRV_COPY_LOCKED	EQU	2
LDRSRV_COPY_PAGEABLE	EQU	3
RCODE_OBJ	EQU	-1
LCODE_OBJ	EQU	01H
LDATA_OBJ	EQU	02H
PCODE_OBJ	EQU	03H
PDATA_OBJ	EQU	04H
SCODE_OBJ	EQU	05H
SDATA_OBJ	EQU	06H
CODE16_OBJ	EQU	07H
LMSG_OBJ	EQU	08H
PMSG_OBJ	EQU	09H
DBOC_OBJ	EQU	0BH
DBOD_OBJ	EQU	0CH
ICODE_OBJ	EQU	11H
IDATA_OBJ	EQU	12H
ICODE16_OBJ	EQU	13H
IMSG_OBJ	EQU	14H

ObjectLocation	STRUC
OL_LinearAddr	DD	?
OL_Size	DD	?
OL_ObjType	DB	?
ObjectLocation	ENDS
MAXOBJECTS	EQU	25

Device_Location_List	STRUC
DLL_DDB	DD	?
DLL_NumObjects	DB	?
DLL_ObjLocation	DB	SIZE ObjectLocation * 1 DUP (?)
Device_Location_List	ENDS
PE_BIT	EQU	0
PE_MASK	EQU	(1 SHL PE_BIT)
MP_BIT	EQU	1
MP_MASK	EQU	(1 SHL MP_BIT)
EM_BIT	EQU	2
EM_MASK	EQU	(1 SHL EM_BIT)
TS_BIT	EQU	3
TS_MASK	EQU	(1 SHL TS_BIT)
ET_BIT	EQU	4
ET_MASK	EQU	(1 SHL ET_BIT)
PG_BIT	EQU	31
PG_MASK	EQU	(1 SHL PG_BIT)
CF_BIT	EQU	0
CF_MASK	EQU	(1 SHL CF_BIT)
PF_BIT	EQU	2
PF_MASK	EQU	(1 SHL PF_BIT)
AF_BIT	EQU	4
AF_MASK	EQU	(1 SHL AF_BIT)
ZF_BIT	EQU	6
ZF_MASK	EQU	(1 SHL ZF_BIT)
SF_BIT	EQU	7
SF_MASK	EQU	(1 SHL SF_BIT)
TF_BIT	EQU	8
TF_MASK	EQU	(1 SHL TF_BIT)
IF_BIT	EQU	9
IF_MASK	EQU	(1 SHL IF_BIT)
DF_BIT	EQU	10
DF_MASK	EQU	(1 SHL DF_BIT)
OF_BIT	EQU	11
OF_MASK	EQU	(1 SHL OF_BIT)
IOPL_MASK	EQU	3000H
IOPL_BIT0	EQU	12
IOPL_BIT1	EQU	13
NT_BIT	EQU	14
NT_MASK	EQU	(1 SHL NT_BIT)
RF_BIT	EQU	16
RF_MASK	EQU	(1 SHL RF_BIT)
VM_BIT	EQU	17
VM_MASK	EQU	(1 SHL VM_BIT)
AC_BIT	EQU	18
AC_MASK	EQU	(1 SHL AC_BIT)
VIF_BIT	EQU	19
VIF_MASK	EQU	(1 SHL VIF_BIT)
VIP_BIT	EQU	20
VIP_MASK	EQU	(1 SHL VIP_BIT)






IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF

P_SIZE	EQU	1000H
P_PRESBIT	EQU	0
P_PRES	EQU	(1 SHL P_PRESBIT)
P_WRITEBIT	EQU	1
P_WRITE	EQU	(1 SHL P_WRITEBIT)
P_USERBIT	EQU	2
P_USER	EQU	(1 SHL P_USERBIT)
P_ACCBIT	EQU	5
P_ACC	EQU	(1 SHL P_ACCBIT)
P_DIRTYBIT	EQU	6
P_DIRTY	EQU	(1 SHL P_DIRTYBIT)
P_AVAIL	EQU	(P_PRES+P_WRITE+P_USER)
PG_VM	EQU	0
PG_SYS	EQU	1
PG_RESERVED1	EQU	2
PG_PRIVATE	EQU	3
PG_RESERVED2	EQU	4
PG_RELOCK	EQU	5
PG_INSTANCE	EQU	6
PG_HOOKED	EQU	7
PG_IGNORE	EQU	0FFFFFFFFH
D_PRES	EQU	080H
D_NOTPRES	EQU	0
D_DPL0	EQU	0
D_DPL1	EQU	020H
D_DPL2	EQU	040H
D_DPL3	EQU	060H
D_SEG	EQU	010H
D_CTRL	EQU	0
D_GRAN_BYTE	EQU	000H
D_GRAN_PAGE	EQU	080H
D_DEF16	EQU	000H
D_DEF32	EQU	040H
D_CODE	EQU	08H
D_DATA	EQU	0
D_X	EQU	0
D_RX	EQU	02H
D_C	EQU	04H
D_R	EQU	0
D_W	EQU	02H
D_ED	EQU	04H
D_ACCESSED	EQU	1
RW_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_W)
R_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_R)
CODE_TYPE	EQU	(D_PRES+D_SEG+D_CODE+D_RX)
D_PAGE32	EQU	(D_GRAN_PAGE+D_DEF32)
SELECTOR_MASK	EQU	0FFF8H
SEL_LOW_MASK	EQU	0F8H
TABLE_MASK	EQU	04H
RPL_MASK	EQU	03H
RPL_CLR	EQU	(NOT RPL_MASK)
IVT_ROM_DATA_SIZE	EQU	500H
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VDD.H ===
#ifndef _VDD_H_
#define _VDD_H_
/************ Operating System Interface for NVidia Hardware ***************\
*                                                                           *
* Module: VDD.H                                                             *
*       Header file for Virtual Display device.                             *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)      7/22/95 - wrote it                   *
*                                                                           *
\*********************** Copyright 1995 NVidia, Inc. ***********************/
//***************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title: minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:   4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//      the general include area.  Added services are ONLY for the
//      use of the Mini-VDD and should therefore not be documented.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------
//
// VDD services.
//
#define VDD_Get_Version                     0x0000  // Get version number and ID string ptr
#define VDD_PIF_State                       0x0001  // Pass video PIF bits to VDD
#define VDD_Get_GrabRtn                     0x0002  // Get routine addr for video grab
#define VDD_Hide_Cursor                     0x0003  // Hide cursor when display is windowed
#define VDD_Set_VMType                      0x0004  // Set VM type(windowed, bckgrnd, excl)
#define VDD_Get_ModTime                     0x0005  // Return system time of last mod
#define VDD_Set_HCurTrk                     0x0006  // Track horiz cursor movement in window
#define VDD_Msg_ClrScrn                     0x0007  // Clear screen for sysmodal message
#define VDD_Msg_ForColor                    0x0008  // Set Msg_TextOut forground color
#define VDD_Msg_BakColor                    0x0009  // Set Msg_TextOut background color
#define VDD_Msg_TextOut                     0x000A  // Output a string
#define VDD_Msg_SetCursPos                  0x000B  // Set cursor position
#define VDD_Query_Access                    0x000C  // Is it OK to access video now?
#define VDD_Check_Update_Soon               0x000D  // User action may update screen
#define VDD_Get_Mini_Dispatch_Table         0x000E  // Get addr of dispatch table to mini-VDD
#define VDD_Register_Virtual_Port           0x000F  // Mini-VDD asks us to setup I/O trap
#define VDD_Get_VM_Info                     0x0010  // Returns CRTC owner and MemC owners
                                                    // and other special VM handles
#define VDD_Get_Special_VM_IDs              0x0011  // returns planar & msg mode IDs
#define VDD_Register_Extra_Screen_Selector  0x0012  // allows display driver to use second
                                                    // screen selector for block moves
#define VDD_Takeover_VGA_Port               0x0013  //allows MiniVDD to takeover a port
                                                    // in range 3C0H through 3DFH
#define VDD_Get_DISPLAYINFO                 0x0014  //get DISPLAYINFO data structure
#define VDD_Do_Physical_IO                  0x0015  //perform physical I/O for trapped port
#define VDD_Set_Sleep_Flag_Addr             0x0016  //when display driver can't be interrupted
//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9 | MINIVDD_SVC_BASE_OFFSET)
typedef struct
{
    WORD  HdrSize;
    WORD  InfoFlags;
    DWORD DevNodeHandle;
    BYTE  DriverName[16];
    WORD  XRes;
    WORD  YRes;
    WORD  DPI;
    BYTE  Planes;
    BYTE  Bpp;
    WORD  RefreshRateMax;
    WORD  RefreshRateMin;
    WORD  LowHorz;
    WORD  HighHorz;
    WORD  LowVert;
    WORD  HighVert;
    DWORD MonitorDevNodeHandle;
    BYTE  HorzSyncPolarity;
    BYTE  VertSyncPolarity;
} DISPLAYINFO, * PDISPLAYINFO;
//
// Following are values and explanations for the diInfoFlags word in DISPLAYINFO:
//
// RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
// or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
// program would get the DISPLAYINFO structure returned to him) caused the VDD
// to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
// insted of actually going out and reading "fresh" data from the Registry.
//
// This flag brings to light the fact that there are some circumstances when the
// VDD cannot go out and read the registry in response to the call to
// VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
// considerations).  In this case, this flag will be set to a 1 to indicate that
// the information being returned isn't "fresh" -- that is -- it may be
// incorrect and obsolete.  The caller should respond accordingly if this flag
// is set.
//
#define RETURNED_DATA_IS_STALE          0x0001
//
// MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
// that the MiniVDD didn't match the chipset installed in the machine), the
// MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
#define MINIVDD_FAILED_TO_LOAD          0x0002
//
// MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
// successfully, when the ChipID that the MiniVDD calculated was compared
// against the value saved in the registry, they didn't match.  An example of
// when this would happen is when the user is happily using an S3-911 card
// and then decides to upgrade his display card to an S3-864.  Since both
// cards use S3.VXD, the MiniVDD will load, however, since the card model
// is different, the VDD will return a defect to configuration manager and
// set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
// flag to take appropriate actions to make sure that the user gets his
// configuration correct.
//
#define MINIVDD_CHIP_ID_DIDNT_MATCH     0x0004
//
// REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
// from the registry when the VDD tried to read it.
//
#define REGISTRY_BPP_NOT_VALID          0x0008
//
// REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
// resolution value from the registry when the VDD tried to read it.
//
#define REGISTRY_RESOLUTION_NOT_VALID   0x0010
//
// REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
// DPI value from the registry when the VDD tried to read it.
//
#define REGISTRY_DPI_NOT_VALID          0x0020
//
// MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
// GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
// This is certainly not fatal by any means.  It simply means that the
// monitor refresh rate info in the DISPLAYINFO data structure is totally
// invalid!
//
#define MONITOR_DEVNODE_NOT_ACTIVE      0x0040
//
// MONITOR_INFO_NOT_VALID indicates that something within the code which
// retrieves and calculates the refresh rate data has failed.  This indicates
// that the values in diRefreshRateMax through diVertSyncPolarity are not
// valid and could contain random data.
//
#define MONITOR_INFO_NOT_VALID          0x0080
//
// MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
// string in SYSTEM.INI had a negative number in it or that the string in
// the display's software key (HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate)
// was 0 or a negative number.
//
#define MONITOR_INFO_DISABLED_BY_USER   0x0100
//
// REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
// diLowVert, diHighVert, or sync polarity data in the registry.    The
// value returned in diRefreshRateMax is the only refresh rate data that
// we have available.  This was derived either from RefreshRate= in SYSTEM.INI
// or the HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate = string in the
// registry.
//
#define REFRESH_RATE_MAX_ONLY           0x0200
//
// CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
// display card manufacturers wishing to extend the capabilities of the chip level
// MiniVDD's ) has successfully been loaded and initialized.
//
#define CARD_VDD_LOADED_OK              0x0400
//
// Make functions to these services.
//
WORD  vddGetVersion(VOID);
DWORD vddGetDisplayInfo(PDISPLAYINFO, DWORD);

#pragma aux vddGetVersion =                                 \
            CALL_VXD(VDD_Device_ID, VDD_Get_Version)        \
            value [AX];

#pragma aux vddGetDisplayInfo =                             \
            CALL_VXD(VDD_Device_ID, VDD_Get_DISPLAYINFO)    \
            parm [EAX] [ECX]                                \
            value [EAX]                                     \
            modify [EBX ECX EDX ESI EDI];
#endif // _VDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VPAGED.H ===
#ifndef _VPAGED_H_
#define _VPAGED_H_
/******** Operating System Interface for NVidia Hardware Simulator  ********\
*                                                                           *
* Module: VPAGED.H                                                          *
*       Header file for Virtual Paging device.                              *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)     05/08/95 - wrote it                   *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define PageSwap_Get_Version    0x0000
#define PageSwap_Test_Create    0x0001
#define PageSwap_Create         0x0002
#define PageSwap_Destroy        0x0003
#define PageSwap_In             0x0004
#define PageSwap_Out            0x0005
#define PageSwap_Test_IO_Valid  0x0006
#define PS_Zero_Init_Mask       0x0001
#define PS_Zero_Init_Bit        0x0000
#define PS_Fixed_Page_Mask      0x0008
#define PS_Fixed_Page_Bit       0x0003
#define PS_First_Page_In_Mask   0x0020
#define PS_First_Page_In_Bit    0x0005
#define PS_Dirty_Mask           0x0040
#define PS_Dirty_Bit            0x0006
#define PS_Ever_Dirty_Mask      0x8000
#define PS_Ever_Dirty_Bit       0x000F
#define PS_NoXchg_Mask          0x80000000
#define PS_NoXchg_Bit           0x001F     // DO NOT xchg phys addrs on PageSwap_Out
#define PS_No_Pager             0x01
#define PS_MSDOS_Pager          0x02
#define PS_HW_Pager             0x03
//
// Buffer descriptor for asynchronous I/O
//
#define SIZE_PS_BD_RESERVED     44
struct PageSwapBufferDesc
{
    DWORD PS_BD_Next;
    WORD  PS_BD_List;
    BYTE  PS_BD_Cmd;
    BYTE  PS_BD_Priority;
    DWORD PS_BD_Page_Number;
    DWORD PS_BD_Buffer_Ptr;
    DWORD PS_BD_File_Page;
    DWORD PS_BD_Call_Back;
    BYTE PS_BD_Reserved[SIZE_PS_BD_RESERVED];
};
//
// List values for PS_BD_List
//
#define PS_BDL_Free         1
#define PS_BDL_Pending_WB   2
#define PS_BDL_Submitted_RA 3
#define PS_BDL_Locked       4
#define PS_BDP_Invalid_Data -1
//
// VPAGED callback routines.
//
#pragma aux VPAGED_INT  modify [EAX EBX ECX EDX];
//
// Make functions to these services.
//
DWORD pagerGetVersion(VOID);
BYTE  pagerGetAccessType(VOID);

#pragma aux pagerGetVersion =                                   \
            CALL_VXD(PageSwap_Device_ID, PageSwap_Get_Version)  \
            value [EAX];

#pragma aux pagerGetAccessType =                                \
            CALL_VXD(PageSwap_Device_ID, PageSwap_Get_Version)  \
            value [BL];
#endif // _VPAGED_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VNV0D.INC ===
;******** Operating System Interface for NVidia Hardware Simulator  ********;
;                                                                           ;
; Module: NV0.INC                                                           ;
;       Header file for NV0 defines and service exports.                    ;
;                                                                           ;
;---------------------------------------------------------------------------;
;                                                                           ;
; History:                                                                  ;
;        David Schmenk (dschmenk)     11/19/93 - wrote it                   ;
;                                                                           ;
;*********************** Copyright 1993 NVidia, Inc. ***********************;

;
; Version numbers.
;

NV0_Major_Version  EQU     01h
NV0_Minor_Version  EQU     00h

;
; Device IDs.
;

NV0_Device_ID      EQU     032DBh

;
; Init order.
;

NV0_Init_Order     EQU     070000000h

;===========================================================================;
;                                                                           ;
;                     Virtual device services.                              ;
;                                                                           ;
;       The virtual device services are declared here, along with their     ;
;       cod segments.  The service entrypoints are declared with a preceding;
;       underscore, the service is a C based function with stack based      ;
;       parameters.  Otherwise, it is an assembly based function with       ;
;       register based parameters.                                          ;
;                                                                           ;
;===========================================================================;

Begin_Service_Table     NV0
        NV0_Service     _nv0GetVersion,         LOCAL
        NV0_Service     _nv0InstallHandlers,    LOCAL
End_Service_Table       NV0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VPICD.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

VPICD_STAT_IRET_PENDING	EQU	01H
VPICD_STAT_IRET_PENDING_BIT	EQU	0
VPICD_STAT_IN_SERVICE	EQU	02H
VPICD_STAT_IN_SERVICE_BIT	EQU	1
VPICD_STAT_PHYS_MASK	EQU	04H
VPICD_STAT_PHYS_MASK_BIT	EQU	2
VPICD_STAT_PHYS_IN_SERV	EQU	08H
VPICD_STAT_PHYS_IN_SERV_BIT	EQU	3
VPICD_STAT_VIRT_MASK	EQU	10H
VPICD_STAT_VIRT_MASK_BIT	EQU	4
VPICD_STAT_VIRT_REQ	EQU	20H
VPICD_STAT_VIRT_REQ_BIT	EQU	5
VPICD_STAT_PHYS_REQ	EQU	40H
VPICD_STAT_PHYS_REQ_BIT	EQU	6
VPICD_STAT_VIRT_DEV_REQ	EQU	80H
VPICD_STAT_VIRT_DEV_REQ_BIT	EQU	7
VPICD_STAT_GLOBAL	EQU	100H
VPICD_STAT_GLOBAL_BIT	EQU	8
VPICD_STAT_OWNED_BY_VM	EQU	200H
VPICD_STAT_OWNED_BY_VM_BIT	EQU	9
VPICD_OPT_READ_HW_IRR	EQU	01H
VPICD_OPT_READ_HW_IRR_BIT	EQU	0
VPICD_OPT_CAN_SHARE	EQU	02H
VPICD_OPT_CAN_SHARE_BIT	EQU	1
VPICD_OPT_REF_DATA	EQU	04H
VPICD_OPT_REF_DATA_BIT	EQU	2
VPICD_OPT_VIRT_INT_REJECT	EQU	10H
VPICD_OPT_VIRT_INT_REJECT_BIT	EQU	4
VPICD_OPT_SHARE_PMODE_ONLY	EQU	20H
VPICD_OPT_SHARE_PMODE_ONLY_BIT	EQU	5
VPICD_OPT_ALL	EQU	3FH
VPICD_FDO_NO_CONTENTION	EQU	10000H
VPICD_FDO_NO_CONTENTION_BIT	EQU	16
VPICD_FDO_FAVOR_FOCUS	EQU	20000H
VPICD_FDO_FAVOR_FOCUS_BIT	EQU	17

VPICD_IRQ_Descriptor	STRUC
VID_IRQ_Number	DW	?
VID_Options	DW	0
VID_Hw_Int_Proc	DD	?
VID_Virt_Int_Proc	DD	0
VID_EOI_Proc	DD	0
VID_Mask_Change_Proc	DD	0
VID_IRET_Proc	DD	0
VID_IRET_Time_Out	DD	500
VID_Hw_Int_Ref	DD	?
VPICD_IRQ_Descriptor	ENDS
Begin_Service_Table VPICD
VPICD_Service	 VPICD_Get_Version, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Virtualize_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Set_Int_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Clear_Int_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Phys_EOI, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Complete_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Test_Phys_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Physically_Mask, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Physically_Unmask, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Set_Auto_Masking, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_IRQ_Complete_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_Handle_To_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_IRQ_To_Int, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_Int_To_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Call_When_Hw_Int, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Force_Default_Owner, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Force_Default_Behavior, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Auto_Mask_At_Inst_Swap
VPICD_Service	 VPICD_Begin_Inst_Page_Swap
VPICD_Service	 VPICD_End_Inst_Page_Swap
VPICD_Service	 VPICD_Virtual_EOI, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Virtualization_Count
VPICD_Service	 VPICD_Post_Sys_Critical_Init, LOCAL
VPICD_Service	 VPICD_VM_SlavePIC_Mask_Change, VxD_LOCKED_CODE
End_Service_Table VPICD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\THKTYPES.H ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       thktypes.h
 *  Content:	base types used by thunk compiler
 *
 ***************************************************************************/
typedef unsigned short USHORT;
typedef          short  SHORT;
typedef unsigned long  ULONG;
typedef          long   LONG;
typedef unsigned int   UINT;
typedef          int    INT;
typedef unsigned char  UCHAR;
//typedef hinstance HINSTANCE;
//typedef		int	BOOL;

//typedef void    VOID;
typedef void   *PVOID;
typedef void   *LPVOID;
typedef UCHAR   BYTE;
typedef USHORT  WORD;
typedef ULONG   DWORD;
typedef UINT    HANDLE;
typedef char   *LPSTR;
typedef BYTE   *PBYTE;
typedef BYTE   *LPBYTE;
typedef USHORT  SEL;
typedef INT    *LPINT;
typedef UINT   *LPUINT;
typedef DWORD  *LPDWORD;
typedef LONG   *LPLONG;
typedef WORD   *LPWORD;

typedef HANDLE  HWND;
typedef HANDLE  HDC;
typedef HANDLE  HBRUSH;
typedef HANDLE  HBITMAP;
typedef HANDLE  HRGN;
typedef HANDLE  HFONT;
typedef HANDLE  HCURSOR;
typedef HANDLE  HMENU;
typedef HANDLE  HPEN;
typedef HANDLE  HICON;
typedef HANDLE  HUSER;      /* vanilla user handle */
typedef HANDLE  HPALETTE;
typedef HANDLE  HMF;
typedef HANDLE  HEMF;
typedef HANDLE	HCOLORSPACE;
typedef HANDLE  HMEM;
typedef HANDLE  HGDI;       /* vanilla gdi handle */
typedef HANDLE  HGLOBAL;
typedef HANDLE  HRSRC;
typedef HANDLE  HACCEL;

typedef WORD    ATOM;

typedef struct tagRECTL {
    LONG         left;
    LONG         top;
    LONG         right;
    LONG         bottom;
} RECTL;
typedef RECTL *LPRECTL;

typedef struct tagRECT {
    UINT         left;
    UINT         top;
    UINT         right;
    UINT         bottom;
} RECT;
typedef RECT *LPRECT;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\modehw.h ===
//
// MODEHW.H - Header file for OS specific portions of mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines for accessing NV registers in the 'C' based modeset code.
//                
//
VOID OEMEnableExtensions(VOID);
VOID OEMDisableExtensions(VOID);
VOID WriteFb32(U032 datum, U032 addr);
U032 ReadFb32(U032 addr);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WriteIndexed(U032 addr, U016 datum);
VOID WritePriv08(U032 addr, U008 datum);
U016 ReadIndexed(U032 addr, U008 reg);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\MODESET.C ===
//
// modeset.c -  Program to set a VESA mode. Assumes the controller is
//              already initialized.
//
// Copyright (c) 1997-2000 - NVidia Corporation. All Rights Reserved.
//
#ifdef DOS_COMPILE
#include    <stdio.h>
#include    <stdlib.h>
#else
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <vga.h>
#include <i2c.h>
#endif // DOS_COMPILE
                
#include    "modes.h"
#include    "modedata.c"
#include	"modehw.h"
#include "nvhw.h"
#include "dac.h"
#include "nvcm.h"

#define ERR_I2C_MODE    1
#define ERR_I2C_COMM    2
#define ERR_I2C_UNKNOWN 3


U016 setI2C(MODEDESC *);
VOID ProgramTV(	U008 tvmode );
U016 programBrooktree(U016 TVmode);
U016 programChrontel(U016 TVmode);
VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides);
VOID output(U016, U008);
U008 input(U016);
VOID DDCout(U008);
U008 DDCin();
VOID FlatPanelCrtc();
U008 getDisplayType();
// U032 GetDefaultPosition();
// VOID SaveDefaultPosition();

//JJV-New Registry Process extern char strDevNodeDisplay[];
//JJV-New Registry Process extern char strDisplayType[];
//JJV-New Registry Process extern char strTVtype[];

//U008        DisplayType;
#ifndef PAL // just in case you want to default to PAL
U008        TVformat = NTSC;    
#else
U008        TVformat = PAL;
#endif

//
// VBE Function 02h - Vesa SetMode routine.
//
// Used to set a VESA mode. This routine will not accept standard
// VGA Mode numbers, nor will it load/support fonts. This means that
// TTY output is DISABLED.
//
// Entry:   U016 mode             // VESA mode to be set
//
//          +------------------ Don't clear screen (1=Save Screen)
//          |+----------------- Linear Frame Buffer (1=Enable)
//          ||++--------------- Reserved for VBE/AF 
//          ||||+-------------- User Refresh (1=User Specified)
//          |||||++------------ Reserved
//          |||||||+-++++++++-- Mode Number
//          VVVVVVVV VVVVVVVV
//          00000000 00000000
//
//          111111           
//          54321098 76543210
//
//          CRTCInfoBlk *cib        // Pointer to CRTCInfoBlock Structure
//
// Exit:    U016 rc               // VESA Error Status
//                                                  

U016 VBESetMode(U016 mode, PGTF_TIMINGS timings, PDMT_OVERRIDES pDMTOverrides, U016 UseDmtFlag)
{
    MODEDESC    *minfo;             // Mode Information
    U016        wv;
    U016        rc = 0x014F;        // Default to FAIL
    U016        status;
    U016        shadow, data;
    U032        data32;
    U008        data8;

    // initDac has set the pDev variable to the correct display type based on what the bios says.
    // If it is TV, setup the format.
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
    {
        mode &= ~0x800;     // do not use custom refresh rates
        if(pDev->Framebuffer.MonitorType == MONITOR_TYPE_PAL)
        {
            TVformat = PAL;
        }
        else       
        {
            TVformat = NTSC;
        }
    }        

    // check for registry override for TV type (PAL/NTSC)
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strTVtype, &data32) == RM_OK)
    {
        if (data32 == 0)
            TVformat = NTSC;
        if (data32 == 1)
        {
            TVformat = PAL;
            pDev->Framebuffer.MonitorType = MONITOR_TYPE_PAL;   // tell display driver what type of display
        }
    }
    // check for registry override for display type (TV/MONITOR/BOTH)
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strDisplayType, &data32) == RM_OK)
    {
        switch (data32)
        {
            case DISPLAY_TYPE_MONITOR:
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_MONITOR;
                // we're overriding, so change to monitor timing. The following code assumes this is set correctly.
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data8);
                data8 &= 0x3f;
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data8);
                pDev->Framebuffer.MonitorType = MONITOR_TYPE_VGA;   // tell display driver what type of display
                break;
            case DISPLAY_TYPE_TV:
                mode &= ~0x800;     // do not use custom refresh rates
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_TV;
                // we're overriding, so change to TV timing. The following code assumes this is set correctly.
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data8);
                if (TVformat == NTSC)
                {
                    data8 |= 0x80; 
                    pDev->Framebuffer.MonitorType = MONITOR_TYPE_NTSC;   // tell display driver what type of display
                }
                else
                {
//                    data8 |= 0xc0; // PAL                   
                    data8 |= 0x80; // not in NV4, bit 6 is overscan color
                    pDev->Framebuffer.MonitorType = MONITOR_TYPE_PAL;   // tell display driver what type of display
                }
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data8);
                break;
            case DISPLAY_TYPE_DUALSURFACE:
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_DUALSURFACE;
                break;
            case DISPLAY_TYPE_FLAT_PANEL:        
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_FLAT_PANEL;
                pDev->Framebuffer.MonitorType = MONITOR_TYPE_FLAT_PANEL;   // tell display driver what type of display
                break;
            default:
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_MONITOR;
        }
    }
    // check whether monitor is a flat panel
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_FLAT_PANEL)
    {
             // de-couple vertical sync from flat panel while setting mode
            data32 = REG_RD32(NV_PRAMDAC_FP_DEBUG_0); // usual macro won't help us here
            data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
            REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32);
    }
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "Setting mode ",mode);

    OEMEnableExtensions();          // Unlock the registers
    shadow = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x21);        // read shadow lock (is there really no define for this reg?)

    data = shadow | 0xC800;         // Enable loading of CRTC's: bit 7 Horiz shadow, bit 3 Vert shadow
                                    // bit 6 = scanline doubling shadow
    WriteIndexed(NV_PRMCIO_CRX__COLOR, data);

    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_FLAT_PANEL)
    {
        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        data = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09);         // read scanline double
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (data &= ~0x8000));   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        while (REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
        while (!(REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start
    
        // shadow = CR21
        shadow &= ~0x4000;  // shadow the scanline double bit
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (shadow |= 0x8800)); // allow horiz & vert write-thru
    }    
    if ((minfo = ValidateMode((U016)(mode & 0x1FF))) != NULL)
    {                                
        // If we are requested to do DualSurface, check that the bit depth is 16.
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_DUALSURFACE)
            if (minfo->mdBPP != 16)
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_MONITOR;  // if not 16 bpp, we can't do it, so use monitor only
        // Program the TV encoder thru the I2C port.
        status = setI2C(minfo);  // Set up encoder. 
        if (status)
        {
            switch (status)
            {
                case ERR_I2C_MODE:
                    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "Can't program the TV encoder for mode ",mode);
                    break;
                case ERR_I2C_COMM:
                    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "I2C error programming mode ",mode);
                    break;
                case ERR_I2C_UNKNOWN:
                    DBG_PRINT_STRING (DEBUGLEVEL_WARNINGS, "NVRM: I2C error. Unknown encoder\n");
                    break;
            }                
            if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)      // if flat panel, leave it that way.
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_MONITOR;  // I2C failed, set up for monitor
        }
        // Mode is maintained here, for the linear/regen flags
        // minfo now points to everything we need to program the mode.
        
        // Set the mode
        ATCOff();                   // Screen off
        OEMPreSetRegs();            // Set up DAC for programming palette.
        
        SetRegs(minfo);             // Set the VGA Registers
                                    // Always set the same packed pixel mode 
                                    // (the CRTC's will be overwritten for the particular mode later)
        FullCpuOn();
        
        OEMSetRegs(minfo);          // Set the OEM Registers
                                    //   if TV, use TV table to adjust timings).
        LoadPalette(minfo);
        
        DualSurfaceDesktop((U016)pDev->Framebuffer.DisplayType);    // Setup the DAC scan out and possibly video scalar.

        // Mode now successfully set
        // Use DMT override values instead of GTF timings
        if (UseDmtFlag && (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_MONITOR))
            {
            // Mode now successfully set .. Set DMT override values
            SetDMTOverrideValues(pDMTOverrides);            
            }
            
        else
            {
            
            // Mode now successfully set .. Set GTF timings
            if ((mode & 0x0800) && timings && (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_MONITOR))  // See if bit 11 is set for VBE Refresh
              VBESetRefresh(timings);        // Set the VBE 3.0 Refresh
            }
              
        FullCpuOff();
        ATCOn();

        // Save the retrace start/end values (display position default)
        dacSaveMonitorDefaultPosition(pDev);

        // See if there are any registry overrides for the desktop positioning.
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_MONITOR)
        {
            U032 cbLen;
            NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS position;

            cbLen = 4 * sizeof(U032);
            status = dacReadDesktopPositionFromRegistry(pDev, 
                                                        TRUE,  // isMonitor
                                                        (U008 *) &(position.HRetraceStart),
                                                        &cbLen);
            if (status == RM_OK)
            {
                // Program the new values.
                dacSetMonitorPosition(pDev, 
                                      position.HRetraceStart, position.HRetraceEnd,
                                      position.VRetraceStart, position.VRetraceEnd);
            }
        }
        // See if there are any registry overrides for the TV desktop positioning.
        // We currently only have adjustments for Brooktree.
        if ((pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV) 
        && (TV_ENCODER_FAMILY(pDev->Framebuffer.EncoderType) == TV_ENCODER_BROOKTREE))
        {
            U032 cbLen;
            NV_CFGEX_DESKTOP_POSITION_TV_PARAMS position;

            cbLen = 4 * sizeof(NV_CFGEX_DESKTOP_POSITION_TV_PARAMS);
            status = dacReadDesktopPositionFromRegistry(pDev, 
                                                        FALSE,  // isMonitor
                                                        (U008 *) &(position.HRetraceStart),
                                                        &cbLen);
            if (status == RM_OK)
            {
                // Program the new values.
                dacSetTVPosition(pDev, position.HRetraceStart, position.HRetraceEnd, position.VRetraceStart, 
                        position.VRetraceEnd, position.reg0x80, position.reg0x82, position.reg0x92, position.reg0x98, 
                        position.reg0x9A, position.reg0xC8, position.reg0xCA, position.reg0xCC);
            }
        }
        // Set the default mode if the display type is flat panel.
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_FLAT_PANEL)
        {
            U032 fpMode, fpMaxX, fpMaxY;
            status = dacGetFlatPanelInfo(pDev, &fpMode, &fpMaxX, &fpMaxY, 
                                         TRUE /* from registry */);
            if (status == RM_OK)
            {
                dacSetFlatPanelMode(pDev, fpMode, FALSE /* don't commit changes */);
            }
        }
                
        // Clear the DPMS State
        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
        wv &= 0x3FFF;                   // Strip to standard DAC settings
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

        // blank monitor if TV
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
            FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF);
        else
            FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON);

        rc &= 0x00FF;               // Clear error status
    }                                   
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
    {
        shadow &= ~0x8000;          // shadow Horiz only
        WriteIndexed(NV_PRMCIO_CRX__COLOR, shadow);     // restore the shadow lock
    }
    OEMDisableExtensions();         // Lock the registers
    
    return(rc);                     // Mode Not Supported
}          

//
// Program the CRTC timing values given by the GTF parameters
//
// WARNING: This is not going to be pretty!!
// TODO: Clean the code to be more straightforward.
//
U016 VBESetRefresh(PGTF_TIMINGS timings)
{

    U032 val32;
    U016 val16, val16b, val16c;
    U008 val08;
    U016 pixperclk;
    U016 border;
    U008 ov07, ov25, ov2D;
    U016 horiz_total;
    U016 hbe;


    //
    // Program the new clocks
    //
    OEMSetClock((U016)(timings->dot_clock / 10000));

    /*
        ; Program new horizontal sync polarity
        mov     bl, [edi].CRTCInfoBlock.HorizontalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 040h
@@:
        ; Program new vertical sync polarity
        mov     bl, [edi].CRTCInfoBlock.VerticalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 080h
@@:
        mov     dx, MISC_OUTPUT
        LOG_GO  dx, al
    */
    //
    // Program the sync polarities
    //
    val32 = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    if (timings->flags & GTF_FLAGS_HSYNC_NEGATIVE)
        val32 |= 0x40;
    if (timings->flags & GTF_FLAGS_VSYNC_NEGATIVE)
        val32 |= 0x80;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: PRMVIO_MISC=",(U008)val32);

    /*
        ;---------------------------------------------------------
        ; Compute CRTC settings
        call    PixPerCharClk
        mov     si, ax
    */
    // 
    // Get the pixels per char settings
    //
    if (ReadIndexed(NV_PRMVIO_SRX, NV_PRMVIO_SR_CLOCK_INDEX) & 0x0100)
        pixperclk = 8;
    else
        pixperclk = 9;    

    /*
        ; Another way to compute vertical border would be to
        ; subtract current CR12 (VDE[0:7]) from CR15 (VBS[0:7])
        call    GetCRTCAddr
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bh, ah
        mov     al, 015h
        call    GetIndexRegister        ; VBS[7:0]
        sub     ah, bh
        ;add    ah, 1-1                 ; VGA adjustments cancel
        xor     al, al
        or      ah, ah
        jz      @f
        inc     al                      ; 1 character horizontal
@@:
        mov     bx, [edi].CRTCInfoBlock.RefreshRate
        cmp     bx, 7200
        jle     @f
        xor     ax,ax                   ; No boarder for refresh above 72Hz
@@:
        mov     bp, ax                  ; Save boarders in bp
    */
    //
    // Get the border setting
    //
    border = (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x15) & 0xFF00;
    border -= (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) & 0xFF00;
    border &= 0xFF00;
    if (border & 0xFF00)
        border++;
    if (timings->refresh > 7200)
        border = 0;
    
    /*        
        ;---------------------------------------------------------
        ; Store CRTC settings
        ; Get overflow values to accumulate
        mov     al, 007h
        call    GetIndexRegister
        mov     ch, ah                  ; Save off overflow register
        and     ch, 01010010b           ; Mask bits to save
        mov     al, 025h
        call    GetIndexRegister
        mov     cl, ah                  ; Save off extra bits screen register
        and     cl, 11100010b           ; Mask bits to save
IFDEF NVIDIA_SPECIFIC
        ; Load original 02Dh
        mov     al,02Dh
        call    GetIndexRegister
        and     ah,0E2h         ; Save unused bits and HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Get the overflow bits
    //
    ov07 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07) >> 8;
    ov07 &= 0x52;
    ov25 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25) >> 8;
    ov25 &= 0xE2;
    ov2D = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x2D) >> 8;
    ov2D &= 0xE2;
    
    /*
        ; cl = CRTC[25] overflow
        ; ch = CRTC[07] overflow
        ; upper cl = CRTC[2D] overflow
        ; dx = CRTC I/O address
        ; si = pixels per character
        ; es:di = pointer to CRTCInfoBlock
        ; ds = seg0
        ; bp = boarder
        mov     ax, [edi].CRTCInfoBlock.HorizontalTotal
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax                  ; Save original
        sub     ax, 5                   ; VGA HT adjustment
IFDEF NVIDIA_SPECIFIC
        ; Do bit 8 of HT
        and     ah,1            ; mask out bit 8
        ;shl     ah,0-0          ; already in position 0
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        ; CRTC[00]
        mov     ah, al
        mov     al, 000h
        LOG_GO  dx, ax
    */
    //
    // Calculate and program horizontal total (CR00)
    //
    horiz_total = timings->horiz_total / pixperclk;
    val16 = horiz_total - 5;
    val16 &= 0x01FF;
    ov2D |= (U008)(val16 >> 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)((val16 << 8) & 0xFF00));
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR00=",(U008)val16);
    
    /*            
IFDEF NVIDIA_SPECIFIC
        ; CRTC[39]
        ; Note, we are assuming that the 9th bit of interlace half field start is always 0
        mov     ax, bx
        shr     ax, 1           ; Compute horizontal total divided by 2
        mov     ah, [edi].CRTCInfoBlock.Flags
        and     ah,00000010b    ; ?Interlaced mode
        jnz     @f              ; Y: Leave ah at 1/2 HT
        mov     al, 0FFh        ; N: Disable interlace
@@:
        mov     ah, al
        mov     al, 039h
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program interlace half-field value (CR39)
    //
    if (timings->flags & GTF_FLAGS_INTERLACED)
        val16 = (((horiz_total >> 1) << 8) & 0xFF00) | 0x39;
    else
        val16 = 0xFF39;   // disabled
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR39=",(U008)(val16>>8));
    
    /*            
        mov     ax, bp
        xor     ah, ah                  ; Make into word
        sub     bx, ax                  ; Subtract boarder from HT
        ; CRTC[03]
        mov     al, 003h
        call    GetIndexRegister
        and     ah, 11100000b
        dec     bl                      ; VGA HBE Adjustment
        mov     bh, bl                  ; save HBE
        and     bl, 00011111b           ; HBE[4:0]
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking end (CR03)
    //
    val16 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x03);
    val16 &= 0xE0FF;
    hbe = horiz_total - (border & 0xFF) - 1;
    val16 |= ((hbe & 0x1F) << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR03=",(U008)(val16>>8));
    
    /*        
        ; CRTC[05]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncEnd
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bl, al
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bl              ; VGA HSE adjustment is +2
        .endif
        inc     bl                      ; Native HSE adjustment is +1
        mov     al, 005h
        call    GetIndexRegister
        and     ah, 01100000b
        and     bl, 00011111b           ; HSE[4:0]
        or      ah, bl
        mov     bl, bh                  ; restore HBE
        and     bl, 00100000b           ; HBE[5]
        shl     bl, 7-5                 ; Move from bit 5 to bit 7
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace end (CR05)
    //
    val16 = timings->horiz_end / pixperclk;
    val16++;    // always native mode
    val16 &= 0x1F;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05);
    val16b &= 0x60FF;
    val16b |= (val16 << 8);
    val16 = (hbe & 0x20) << 2;
    val16b |= (val16 << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR05=",(U008)(val16b>>8));
    
    /*        
IFDEF NVIDIA_SPECIFIC
        and     bh, 01000000b
        shr     bh, 6-4
        ; MSK - Assume HBE[6] can always be set, but only takes effect if LC ignore flag is set
        or      cl, bh                  ; HBE[6]
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Modify overflow25
    //
    ov25 |= ((hbe & 0x40) >> 2);
    
    /*
        ; CRTC[02]
        mov     al, 001h
        call    GetIndexRegister        ; HDE[0:7]
        mov     al, ah
IFDEF NVIDIA_SPECIFIC
        ; Get bit 8 of HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah, cl
        ror     ecx,16          ; switch back to lower part of ECX
        and     ah, 2           ; mask out bit 1
        shr     ah, 1-0         ; shift into position 0
ELSE ; NVIDIA_SPECIFIC
        xor     ah, ah
ENDIF ; NVIDIA_SPECIFIC
        ;
        inc     ax                      ; VGA HDE adjustment
        mov     bx, bp
        xor     bh, bh
        add     ax, bx
        dec     ax                      ; VGA HBS Adjustment
IFDEF NVIDIA_SPECIFIC
        ; Store bit 8 of HBS
        and     ah,1            ; mask out bit 8
        shl     ah,2-0          ; shift into position 2
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, al
        mov     al, 002h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking start (CR02)
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x01) >> 8) & 0x00FF;
    val16 |= ((U016)(ov2D & 2) << 7) & 0xFF00;
    val16++;
    val16 += (border & 0xFF);
    val16--;
    val08 = ((val16 >> 8) & 1) << 2;
    ov2D |= (U016)val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR02=",(U008)(val16>>8));
    
    /*
        ; CRTC[04]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncStart
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bx              ; VGA HSS adjustment is +2
        .endif
        inc     bx                      ; Native HSS adjustment is +1
IFDEF NVIDIA_SPECIFIC
        ; do bit 8 of HRS
        and     bh,1            ; mask out bit 8
        shl     bh,3-0          ; shift into position 3
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,bh
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, bl
        mov     al, 004h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace start (CR04)
    //
    val16 = timings->horiz_start / pixperclk;
    val16++;    // always native mode
    val08 = ((val16 >> 8) & 1) << 3;
    ov2D |= val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR04=",(U008)(val16>>8));
    
    /*    
IFDEF NVIDIA_SPECIFIC
        ; CRTC[2D]
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah,cl
        ror     ecx,16          ; switch back to lower part of ECX
        mov     al,02Dh
        SIM_NO  dx,ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program CR2D
    //
    val16 = ((((U016)ov2D) << 8) & 0xFF00) | 0x2D;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR2D=",(U008)(val16>>8));
    
    /* 
        ; CRTC[16]
        mov     bx, [edi].CRTCInfoBlock.VerticalTotal
        mov     ax, bp
        mov     al, ah
        xor     ah, ah
        sub     ax, bx
        neg     ax
        mov     ah, al
        mov     al, 016h
        dec     ah                      ; VGA VBE Adjustment
        LOG_GO  dx, ax                  ; VBE[0:7]
    */
    //
    // Program vertical blanking end (CR16)
    //
    val16 = (border >> 8) - timings->vertical_total;
    val16 = -val16;
    val16--;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR16=",(U008)(val16>>8));
    
    /*            
        ; CRTC[06]
        mov     al, 006h
        sub     bx, 2                   ; VGA VT Adjustement
        mov     ah, bl
        LOG_GO  dx, ax                  ; VT[0:7]
    */
    //
    // Program the vertical total (CR06)
    //
    val16 = timings->vertical_total - 2;        
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR06=",(U008)(val16>>8));
    
    /*
        mov     bl, bh
        and     bl, 00000001b
        ;shl    0-(8-8)
        or      ch, bl                  ; VT[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ch, bl                  ; VT[9]
        and     bh, 00000100b
        shr     bh, (10-8)-0
        or      cl, bh                  ; VT[10]
        ; CRTC[15]
        mov     ah, cl                  ; CRTC[25]
        and     ah, 00000010b
        shl     ah, (10-8)-1
        mov     bh, ah                  ; VDE[10]
        mov     al, ch                  ; CRTC[7]
        and     al, 01000000b
        shr     al, 6-(9-8)
        or      bh, al                  ; VDE[9]
        mov     ah, ch                  ; CRTC[7]
        and     ah, 00000010b
        shr     ah, 1-(8-8)
        or      bh, ah                  ; VDE[8]
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bl, ah
        inc     bx                      ; VGA VDE adjustment
        mov     ax, bp                  ; Adjust boarder
        mov     al, ah
        xor     ah, ah
        add     bx, ax
        mov     al, 015h
        dec     bx                      ; VGA VBS adjustment
        mov     ah, bl
        LOG_GO  dx, ax                  ; VBS[0:7]
    */
    //
    // Program vertical blanking start (CR15)
    //
    val16 = timings->vertical_total - 2;
    val08 = (val16 >> 8) & 0x01;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x02;
    val08 <<= 4;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x04;
    val08 >>= 2;
    ov25 |= (U016)val08;
    
    val08 = (ov25 & 0x02) << 1;
    val16 = (U016)val08 << 8;
    val08 = (ov07 & 0x40) >> 5;
    val16 |= (U016)val08 << 8;
    val08 = (ov07 & 0x02) >> 1;
    val16 |= (U016)val08 << 8;
    
    val16 &= 0xFF00;
    val16 |= (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
    val16++;
    val16 += (border >> 8);
    val16--;
    val16c = val16;                     // save for later
    val16b = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR15=",(U008)(val16b>>8));
    
    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 3-(8-8)
        or      ch, bl                  ; VBS[8]
    */
    val08 = ((val16 >> 8) & 1) << 3;
    ov07 |= val08;
    
    /*        
        ; CRTC[09]
        ; MSK - 5/15/97
        ; To allow a double scan mode to be non double scanned, we need to preserve the
        ; double scan bit so we can check it later
        ; We need to adjust VDE based on the old and new double scan bits
        ; We also need the original VDE
        ; NOTE: alternate way would be to get the value from the mode tables

        mov     al, 009h
        call    GetIndexRegister
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     ah,10000000b    ; Old double scan mode
        shr     ah,7-0
        and     bl,00000001b    ; ?Double scan mode
        cmp     bl, ah
        .if     (!zero?)        ; Mismatch
    */
    //
    // Is the current doublescan status different from the requested flag?
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16 >>= 7;
    // this takes advantage that the flag is 0x01
    if ((timings->flags & GTF_FLAGS_DOUBLE_SCANNED) != (U008)val16)
    {
     
        /*               
                ; New mode had different double scan setting from old mode
                ; We have to multiply or divide VDE by 2

                mov     bl, ch          ; CR[7].1
                and     bl, 00000010b
                shr     bl, 1-0         ; move to bit 0

                mov     ah, ch          ; CR[7].6
                and     ah, 01000000b
                shr     ah, 6-1         ; move to bit 1
                or      bl, ah

                mov     ah, cl          ; CR[25].1
                and     ah, 00000010b
                shl     ah, 2-1         ; Move to bit 2
                or      bl, ah
        */
        //
        // Adjust VDE
        //
        val08 = (ov07 & 0x02) >> 1;
        val08 |= (ov07 & 0x40) >> 5;
        val08 |= (ov25 & 0x02) << 1;
        
        /*
                mov     al, 012h
                call    GetIndexRegister
                mov     al, [edi].CRTCInfoBlock.Flags
                and     al, 00000001b   ; Is new mode a double scan mode?
                .if (zero?)
                        ; was double scan, now is not, so divide by 2
                        shr     bl, 1           ; Divide by 2
                        rcr     ah, 1
                .else
                        ; was not double scan, now is, so multiply by 2
                        shl     ah, 1           ; Multiply by 2
        BUG? =>         rcr     bl, 1
                        inc     ah              ; Make lsb set

                .endif
                mov     al, 012h

                LOG_GO  dx, ax          ; VDE[0:7]
        */
        
        val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
        val16 |= (U016)val08 << 8;
        if (!(timings->flags & GTF_FLAGS_DOUBLE_SCANNED))
        {
            val16 >>= 1;
        } 
        else 
        {
            val16 <<= 1;
            val16++;
        }            
        val16b = ((val16 << 8) & 0xFF00) | 0x12;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);
                        
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR12=",(U008)(val16b>>8));
                        
        /*
                and     ch, NOT 01000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000001b
                shl     al, 1-0         ; move to bit 1
                or      ch, al          ; CR[7].1
                mov     al, bl
                and     al, 00000010b
                shl     al, 6-1         ; move to bit 6
                or      ch, al          ; CR[7].1

                and     cl, NOT 00000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000100b
                shr     al, 2-1         ; move to bit 1
                or      cl, al          ; CR[25].1

        .endif
        ; End MSK - 5/15/97
        */
        //
        // Adjust the overflows based on the new VDE
        //
        ov07 &= 0xBD;   
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x01) << 1;
        ov07 |= val08;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x02) << 5;
        ov07 |= val08;
        ov25 &= 0xFD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x04) >> 1;
        ov25 |= val08;
    }        

    /*
        mov     al, 009h
        call    GetIndexRegister
        and     ah, NOT 10100000b
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     bl,00000001b    ; ?Double scan mode
        jz      @f              ; N: Leave clear
        or      ah, 10000000b   ; Y: Set double scan
@@:
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ah, bl                  ; VBS[9]
        LOG_GO  dx, ax
    */        
    //
    //
    val16b = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16b &= 0x5F;
    if (timings->flags & GTF_FLAGS_DOUBLE_SCANNED)
        val16b |= 0x80;
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x02) << 4;
    val16b |= (U016)val08;    
    val16 = ((val16b << 8) & 0xFF00) | 0x09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR09=",(U008)(val16>>8));
    
    /*
        and     bh, 00000100b
        shl     bh, 3-(10-8)
        or      cl, bh                  ; VBS[10]
        ; CRTC[10]
        mov     al, 010h
        mov     bx, [edi].CRTCInfoBlock.VerticalSyncStart
        mov     ah, bl
        LOG_GO  dx, ax                  ; VSS[0:7]
    */
    //
    // 
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x04) << 1;
    ov25 |= val08;
    val16 = timings->vertical_start;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR10=",(U008)(val16>>8));
    
    /*        
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 2-(8-8)
        or      ch, bl                  ; VSS[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 7-(9-8)
        or      ch, bl                  ; VSS[9]
        and     bh, 00000100b
        ;shl     bh, 2-(10-8)
        or      cl, bh                  ; VSS[10]
        ; CRTC[11]
        mov     al, 011h
        call    GetIndexRegister
        and     ah, 11110000b
        mov     bl, byte ptr [edi].CRTCInfoBlock.VerticalSyncEnd
        and     bl, 00001111b
        or      ah, bl
        LOG_GO  dx, ax                  ; VSE[0:3]
    */
    //
    // 
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x01) << 2;
    ov07 |= val08;    
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x02) << 6;
    ov07 |= val08;    
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = val08 & 0x04;
    ov25 |= val08;    
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);
    val16b &= 0xF0FF;
    val16b |= (timings->vertical_end & 0x000F) << 8;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR11=",(U008)(val16b>>8));
    
    /*        
        ; Store overflow registers
        ; CRTC[7]
        mov     al, 007h
        mov     ah, ch
        LOG_GO  dx, ax
    */
    val16 = ((((U016)ov07) << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
            
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR07=",(U008)(val16>>8));
            
    /*        
        ; CRTC[25]
IFDEF NVIDIA_SPECIFIC
        mov     al, 025h
        mov     ah, cl
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    val16 = ((((U016)ov25) << 8) & 0xFF00) | 0x25;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR25=",(U008)(val16>>8));

    return(0);
}

//*****************************************************************************
//
// Function: SetDMTOverrideValues()
//
// Description:
//    
//      Do VESA 1.0 rev 0.7 DMT timings for the following modes:
//
//      DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7 
//      Monitor Timing Specifications and D.Reed's NV3 CRTC spreadsheet.
//
//           1600 x 1200 @ 60,70,75,85
//           1280 x 1024 @ 60,75,85
//           1152 x  864 @ 75
//           1024 x  768 @ 60,70,75,85
//            800 x  600 @ 60,72,75,85
//            640 x  480 @ 60,72,75,85
//
//      DMT_Overrides_structure
//
//          U016	DotClock;
//          U016    Polarity;
//          U016    CR0;
//          U016    CR2;
//          U016    CR3;
//          U016    CR4;
//          U016    CR5;
//          U016    CR6;
//          U016    CR7;
//          U016    CR10;
//          U016    CR11;
//          U016    CR15;
//          U016    CR16;
//  
//*****************************************************************************


VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides)            

{

    U032 val32;
    U016 val16;
    U016  wv;                     

    //
    // Program the new clocks
    //

    OEMSetClock((U016)(((U032)(pDMTOverrides->DotClock))));

    //
    // Program the sync polarity
    //

    val32   = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    val32  &= 0xf3;
    val32  |= 0x8;
    val32  |= pDMTOverrides->Polarity;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    //
    // Clear the crtc protection bit.
    //
    
    val16 = 0x0011;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR0
    //

    val16 = pDMTOverrides->CR0;
    val16 = ((val16 << 8) & 0xFF00) | 0x00;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR2
    //

    val16 = pDMTOverrides->CR2;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR3
    //

    val16 = pDMTOverrides->CR3;
    val16 = ((val16 << 8) & 0xFF00) | 0x03;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR4
    //

    val16 = pDMTOverrides->CR4;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR5
    //

    val16 = pDMTOverrides->CR5;
    val16 = ((val16 << 8) & 0xFF00) | 0x05;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR6
    //

    val16 = pDMTOverrides->CR6;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR7
    //

    val16 = pDMTOverrides->CR7;
    val16 = ((val16 << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR10
    //

    val16 = pDMTOverrides->CR10;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    //
    // Update CR11
    //

    val16 = pDMTOverrides->CR11;
    val16 = ((val16 << 8) & 0xFF00) | 0x11;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR15
    //

    val16 = pDMTOverrides->CR15;
    val16 = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR16
    //

    val16 = pDMTOverrides->CR16;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

}


//       OEMSetRegs - Set extended registers (standard VGA has been set)
//
//       Entry:  ES:DI = Standard VGA parameter pointer
//               DS = Seg0
//       Exit:   None
//
VOID OEMSetRegs(MODEDESC *mi)
{
    U016  wv;                     // Write value    
    U016  i, c;
    U032   lwv;
    U032   lrv;
    U008   cv;

    if (mi->mdCMode != 0xFF)        // Do we have a CRTC Override Table?
    {
        // Yep - program it
        WritePriv08(NV_PRMVIO_MISC__WRITE, crt_override[mi->mdCMode].CO_Misc);
                                                                      
        wv = crt_override[mi->mdCMode].CO_ClockMode;
        wv <<= 8;
        wv |= 0x01;
        WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01
        
        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);    // Read CR11
        wv &= 0x7FFF;               // Unlock CR0-7
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR11
        
        // Do CR0-CR8 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, 8, (U008 *)&(crt_override[mi->mdCMode].HTotal));
        
        wv = crt_override[mi->mdCMode].CO_CellHeight;
        wv <<= 8;
        wv |= 0x09;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR09
        
        // Do CR10-CR12 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x10, 0x03, (U008 *)&(crt_override[mi->mdCMode].CO_VSyncStart));
        
        // Do CR15-CR16 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x15, 0x02, (U008 *)&(crt_override[mi->mdCMode].CO_VBlankStart));
    }
    
    // Program Extended Registers
    
    wv = eregs[mi->mdEMode].xrOffset;
    wv <<= 13;              
    wv &= 0xE000;                   // Clear start address bits
    wv |= 0x19;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR19
                                                       
    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    wv &= 0xC0FF;                   // Preserve sync disables
    wv |= 0x3800;                   // Set reserved bits and text mode
                    
    c = (eregs[mi->mdEMode].xrFlags);
         
    if (c & 0x01)
        wv |= 0x0100;               // Set address wrap
        
    i = (eregs[mi->mdEMode].xrVOver);
    i &= 0x20;
    i >>= 0x03;
    wv |= (i << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A
    
    // Default Fifo
    wv = 0x011B;                    // Default CR1B value for VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1B
                                                        
    wv = c;
    wv &= 0x06; 
    wv <<= 8;
    wv |= 0x1C;                     // CR1C
    
    i = (eregs[mi->mdEMode].xrPixFmt);
    i &= 0x30;                      // Mask off chain-4 optimize bits
    i >>= 1;            // (shr 4-3?)
    
    wv |= (i << 8);                 // Set chain 4 optimize bits
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A
    
    
    wv = 0x001D;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1D
    
    wv = 0x001E;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1E
    
    wv = 0x1020;                    // Fifo Setting for Standar VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set low water mark at CR20
    
    c = (eregs[mi->mdEMode].xrVOver); // Vertical Overflow
    c &= 0x1F;                      // Mask our bits                                               
    
    i = (eregs[mi->mdEMode].xrOffset);
    i &= 0x08;                      // Bit 3
    i <<= 2;                        // Move to bit 5
    c |= i;
    wv =  (c << 8) | 0x25;          // Write data to CR25
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR25
                                               
    
    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv &= 0xF8FF;                   // Preserve sync disables
             
    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0x07;                      // Set bits [2:0] - clear rest
    wv |= (c << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR28
                                                   
    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0xC0;
    c >>= 6;
    
    i = eregs[mi->mdEMode].xrVOver;
    i &= 0xC0;
    i >>= 4;
    c |= i;
    wv = ((c << 8) | 0x2D);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR2D
                                                      
    wv = 0x29;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
    wv = 0x2A;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
    
    // Do CR29-33
    /*
    for (i = 0x30; i <= 0x33; i++)
    {                      
        wv = (U016)i;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
    } 
    */                                          
    
    wv = (((eregs[mi->mdEMode].xrIntlace) << 8) | 0x39);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
    
    // Set dot clock
    //OEMSetClock(eregs[mi->mdEMode].xrClkSel);
    if (pDev->Framebuffer.MonitorType != MONITOR_TYPE_FLAT_PANEL)
        OEMSetClock(tblClockFreq[eregs[mi->mdEMode].xrClkSel]);

    wv = (((eregs[mi->mdEMode].xrVOffset) << 8) | 0x13);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
                                                     
    pDev->Framebuffer.CursorAdjust = 0;   // default to no adjustment of cursor position
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
    {
        ProgramTV( mi->mdTVMode );              // CRTC tweaks for TV
        // plus some additional tweaks for pixel/line doubled modes
        if (mi->mdTVMode <= TV_MODE_400x300)    // if clock doubling
        {
            WritePriv32(0x01030700, NV_PRAMDAC_PLL_COEFF_SELECT);   // clock doubled mode
        }
        else
            WritePriv32(0x10030700, NV_PRAMDAC_PLL_COEFF_SELECT);
    }
    else    
    {
        // Not TV, if flat panel, we may need to adjust CRTC's
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_FLAT_PANEL)
            FlatPanelCrtc(mi->mdXRes);
        else
            WritePriv32(0x10000700, NV_PRAMDAC_PLL_COEFF_SELECT);
    }        

    // if flat panel, leave DAC alone
    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_FLAT_PANEL)
    {
        lrv = ReadPriv32(NV_PRAMDAC_GENERAL_CONTROL);
    
        lrv &= (U032)(((1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE)) |
             (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE)) |
             (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC))) ^ -1L);
        
        lrv |= (U032)(1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE));
        
        wv = (eregs[mi->mdEMode].xrOffset);
        lwv = (U032)(wv & 0x80);       // Set 565 Mode
    
        lwv <<= (DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE) - 7L);
        
        lrv |= lwv; 
    
        cv = (eregs[mi->mdEMode].xrFlags);
        cv ^= (U008)-1;
        cv &= 0x08;                 // Isolate DAC width
    
        lwv = (U032)(cv);          // Dac Width
        lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC) - 3L);
                                       
        lrv |= lwv; 
        
        cv = (eregs[mi->mdEMode].xrPixFmt);
        cv ^= (U008)-1;                   // Invert
        cv &= 0x02;                 // Isolate index/gamma bit
                             
        lwv = (U032)(cv);
        
        //KJK lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE) - 1L);
        lrv |= lwv; 
    
        WritePriv32(lrv, NV_PRAMDAC_GENERAL_CONTROL);
    }
        
    WritePriv08(NV_PRMCIO_CRX__COLOR, 0x18);    // Select CR18 (why?)
}

//  
//  The H/V timings may have to be adjusted for TV.
//  Also, the fifo low water mark should be set for TV.
//
VOID ProgramTV
(
	U008	tvmode
)
{
 
	U008	data;
    U016    data16 = 0;
    U008    hbeAdjust;
        
    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x20);     // if TV, we can fix low water mark at 20.

    //  fix up CRTC timing for NV4
    if (TV_ENCODER_FAMILY(pDev->Framebuffer.EncoderType) == TV_ENCODER_CHRONTEL)
    {
        if (TVformat == NTSC)
        {
            CRTC_WR(NV_CIO_CR_HDT_INDEX, CRTC_CH_NTSC[ tvmode ].CR00);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, CRTC_CH_NTSC[ tvmode ].CR04);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, CRTC_CH_NTSC[ tvmode ].CR06);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, CRTC_CH_NTSC[ tvmode ].CR07);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, CRTC_CH_PAL[ tvmode ].CR08);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, CRTC_CH_NTSC[ tvmode ].CR10);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, CRTC_CH_NTSC[ tvmode ].CR12);
            CRTC_WR(NV_CIO_CRE_LSR_INDEX, CRTC_CH_NTSC[ tvmode ].CR25);
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data);      // read pixel format
            data |= CRTC_CH_NTSC[ tvmode ].CR28;        // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((CRTC_CH_NTSC[ tvmode ].SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
        }
        else // its PAL
        {
            CRTC_WR(NV_CIO_CR_HDT_INDEX, CRTC_CH_PAL[ tvmode ].CR00);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, CRTC_CH_PAL[ tvmode ].CR04);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, CRTC_CH_PAL[ tvmode ].CR06);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, CRTC_CH_PAL[ tvmode ].CR07);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, CRTC_CH_PAL[ tvmode ].CR08);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, CRTC_CH_PAL[ tvmode ].CR10);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, CRTC_CH_PAL[ tvmode ].CR12);
            CRTC_WR(NV_CIO_CRE_LSR_INDEX, CRTC_CH_PAL[ tvmode ].CR25);
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data);      // read pixel format
            data |= CRTC_CH_PAL[ tvmode ].CR28;           // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((CRTC_CH_PAL[ tvmode ].SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
        }
    }
    else if (TV_ENCODER_FAMILY(pDev->Framebuffer.EncoderType) == TV_ENCODER_BROOKTREE)
    {
        if (TVformat == NTSC)
        {
            // write Seq 01
            if (CRTC_BT[ tvmode ].SR01 != 0xff) // if table entry exists, do these adjustments
            {
                WriteIndexed(NV_PRMVIO_SRX, (U016) ((CRTC_BT[ tvmode ].SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
        
                // Adjust Horiz and Vert totals
                CRTC_WR(NV_CIO_CR_HDT_INDEX, CRTC_BT[ tvmode ].CR00);
                CRTC_WR(NV_CIO_CR_HRS_INDEX, CRTC_BT[ tvmode ].CR04);
                CRTC_WR(NV_CIO_CR_VDT_INDEX, CRTC_BT[ tvmode ].CR06);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, CRTC_BT[ tvmode ].CR07);
                CRTC_WR(NV_CIO_CR_RSAL_INDEX, CRTC_BT[ tvmode ].CR08);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, CRTC_BT[ tvmode ].CR10);
                CRTC_WR(NV_CIO_CR_VDE_INDEX, CRTC_BT[ tvmode ].CR12);
                if (tvmode == TV_MODE_320x200)  // 320 modes require additional adjustment for HDE
                {
                    CRTC_RD(NV_CIO_CR_HRS_INDEX, data);       // read CR04
                    CRTC_WR(NV_CIO_CR_HDE_INDEX, data-2);                
                    CRTC_WR(NV_CIO_CR_HBS_INDEX, data-2);                
                }
                if (tvmode == TV_MODE_320x240)  // 320 modes require additional adjustment for HDE
                {
                    CRTC_RD(NV_CIO_CR_HRS_INDEX, data);       // read CR04
                    CRTC_WR(NV_CIO_CR_HDE_INDEX, data-3);                
                    CRTC_WR(NV_CIO_CR_HBS_INDEX, data-3);                
                }
            }
        }
        else    // Brooktree PAL
        {
                
            // write Seq 01
            if (CRTC_BT_PAL[ tvmode ].SR01 != 0xff) // if table entry exists, do these adjustments
            {
                WriteIndexed(NV_PRMVIO_SRX, (U016) ((CRTC_BT[ tvmode ].SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
        
                // Adjust Horiz and Vert totals
                CRTC_WR(NV_CIO_CR_HDT_INDEX, CRTC_BT_PAL[ tvmode ].CR00);
                CRTC_WR(NV_CIO_CR_HRS_INDEX, CRTC_BT_PAL[ tvmode ].CR04);
                CRTC_WR(NV_CIO_CR_VDT_INDEX, CRTC_BT_PAL[ tvmode ].CR06);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, CRTC_BT_PAL[ tvmode ].CR07);
                CRTC_WR(NV_CIO_CR_RSAL_INDEX, CRTC_BT_PAL[ tvmode ].CR08);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, CRTC_BT_PAL[ tvmode ].CR10);
                CRTC_WR(NV_CIO_CR_VDE_INDEX, CRTC_BT_PAL[ tvmode ].CR12);
                if (tvmode <= TV_MODE_320x400)  // 320 modes require additional adjustment for HDE
                {
                    CRTC_RD(NV_CIO_CR_HRS_INDEX, data);       // read CR04
                    CRTC_WR(NV_CIO_CR_HDE_INDEX, data-5);                
                    CRTC_WR(NV_CIO_CR_HBS_INDEX, data-5);                
                }
            }
        }        
    } // encoder specific

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data);              // get CR28
    data &= ~0x38;
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data);              // clear the pixel shift 

    if (tvmode <= TV_MODE_320x400)
    {
        // adjust HBE = HT. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16);           // get HT (CR0)
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data);             // HBE 4:0
        pDev->Framebuffer.CursorAdjust = 8;
    }
    else
    {
        if (tvmode == TV_MODE_400x300)
        {
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data);          // get CR28
            data &= ~0x38;
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (5<<3)); // bits[5:3] shift 5 pixels right        
            pDev->Framebuffer.CursorAdjust = 0;
            if (TVformat == NTSC)   // PAL 400x300 requires special case for HBE for cursor position
                hbeAdjust = 4;
            else                
                hbeAdjust = 2;
        }
        else
        {
            pDev->Framebuffer.CursorAdjust = 5;
            hbeAdjust = 4;
        }
        // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16);           // get HT (CR0)
        CRTC_RD(NV_CIO_CRE_HEB__INDEX, data);           // MS bit HT (CR2D)            
        if (data & 1)
            data16 |= 0x100;
        data16 += hbeAdjust;                            // HT effective

        CRTC_RD(NV_CIO_CR_HBE_INDEX, data);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data);             // HBE 4:0

        CRTC_RD(NV_CIO_CR_HRE_INDEX, data);             // CR05
        data &= ~0x80;                                  // lose the HBE bit
        if (data16 & 0x20)
            data |= 0x80;
        CRTC_WR(NV_CIO_CR_HRE_INDEX, data);             // HBE 5
                            
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, data);            // CR25
        data & ~0x10;
        if (data16 & 0x40)
            data |= 0x10;
        CRTC_WR(NV_CIO_CRE_LSR_INDEX, data);            // HBE 6
    }
    // adjust VBE = VT + 1. This lets the cursor move vertically through the whole screen.
    CRTC_RD(NV_CIO_CR_VDT_INDEX, data);             // CR6
    data += 1;
    CRTC_WR(NV_CIO_CR_VBE_INDEX, data);             // CR16

    // adjust normally scanline doubled modes which are not doubled for TV
    if ((tvmode == TV_MODE_512x384) | (tvmode == TV_MODE_480x360))
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40);
        
}

//
//       LoadPalette - Load the system palette and the user defined palette if there is one
//
//       Entry:  DS = Seg0
//               ES:DI = Pointer to parameter entry
//       Exit:   None
VOID LoadPalette(MODEDESC *mi)
{
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif 
    
    //
    // Load default internal palette
    //
    LoadDefaultATCAndSavePtr((vga_tbl[mi->mdIMode].PT_ATC));
                             
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    
    WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!
                                           
    //
    // Load default external palette
    //
    LoadDefaultRAMDAC(mi);
 
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
        
}

//
//       LoadDefaultATCAndSavePtr - Load a the default ATC registers and store them in the saveptr area if necessary
//
//       Entry:  ES:SI = Pointer to palette data
//               DX = I/O Address of Input Status Register
//               DS = Seg0
//       Exit:   None
//
//       AX, CX, SI are trashed
//       DX is preserved
//
VOID LoadDefaultATCAndSavePtr(U008 *pal)
{
    U008  i;
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif    
     
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    
    for (i = 0; i < 20; i++)
    {
        WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }
                                                
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif    
}

//
//       LoadDefaultRAMDAC - Load the default palette
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed
//

// #define DAC_MASK 0x3C6

VOID LoadDefaultRAMDAC(MODEDESC *mi)
{
    WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask
    // outp(DAC_MASK, 0xFFh);
    
    switch(mi->mdBPP)
    {
    case    4:          // 4bpp - Planar
        LoadColorDACTable();
        break;
        
    case    8:          // 8bpp - Packed
        LoadColor256DAC();
        break;
        
    case    16:         // 16bpp - Packed
    case    32:         // 16bpp - Packed
    default:
        LoadIdentityDAC();
        break;
    }       
}                        

//
//       LoadColorDACTable - Load the DAC for the 16-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       WARNING! This routine must follow "LoadColorTextDACTable"!
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadColorDACTable(VOID)
{
    U008  i;
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif    
    
    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        WriteColor(i);
        
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif    
}
    
//
//       LoadColor256DAC - Load the DAC for the 256-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
extern U008 CompatColors[];
                         
//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
extern U008 GrayColors[];
                                                                              
//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
extern U008 FixupColors[];
                                                                       
//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
extern U008 IntenseTable[];                              
                                                                   
VOID LoadColor256DAC(VOID)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif    
    
    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        WriteColor(CompatColors[i]);
    
    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }                                                
        
    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //
    
    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {                       
    
        // I know these could probably be a function, but for now...
        // (this is getting tedious).
        
        // Traverse(blue, red);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            red++;                                          
        } while (red < blue);
        
        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            blue--;
        } while (blue);
        
        // Traverse(red, green);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            green++;
        } while (green < red);
                         
        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            red--;
        } while (red);
                 
            
        // Traverse(green, blue);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            blue++;
        } while (blue < green);
                         
        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            green--;
        } while (green);
    }                
             
    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);
    
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif    
    
}

//
//       WriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               BL = 6 bit color (R'G'B'RGB)
//       Exit:   None
//
//       AX is trashed
//
VOID WriteColor(U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write
    
    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component
        
        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;
    
        WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}        
        
//
//       WriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               CS:BX points to intensity table
//               SI = Red index (0 to 4)
//               DI = Green index (0 to 4)
//               CX = Blue index (0 to 4)
//
//       Exit:   None
//
//       AL is trashed
//
VOID WriteColor2(U016 red, U016 green, U016 blue, U016 tblidx)
{
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       LoadIdentityDAC - Load the DAC with a gamma ramp
//
//       Entry:  DS = Seg0
//               ES = _TEXT
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadIdentityDAC(VOID)
{
    U016  i;
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif    
    
    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
                                                  
    for (i = 0; i < 256; i++)
    {           
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
    }                                     
    
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif    
}
 
//       OEMSetClock - Set the clock chip to the requested frequency
//
//       Entry:  AL = Clock select index
//       Exit:   None
//
//       All registers are preserved.
VOID OEMSetClock(U016 clock)
{
    U032   mnp;
    
    //clock = tblClockFreq[csel];         // Get selected clock value 
    FixLowWaterMark(clock);             // Set low water mark.
    mnp = CalcMNP(&clock);              // Get the MNP of frequency
    
    // mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
    
//  AL = M parameter
//  AH = N parameter
//  DL = P parameter

    SetDACClock(mnp);
}

//       SetDACClock - Set the VPLL parameters in the NVidia DAC
//
//  Entry:  mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
//       Entry:  AL = M parameter
//               AH = N parameter
//               DL = P parameter
//       Exit:   None
//
VOID SetDACClock(U032 mnp)
{
    // NOTE: if we need to support divide by two, use msb of p parameter
    // Set the MNP VPLL parameters in the DAC
    WritePriv32(mnp, NV_PRAMDAC_VPLL_COEFF);
}

//
//       FixLowWaterMark
//
//       Entry:  AX = Dot clock frequency in kHz*100
//       Exit:   None
//
VOID FixLowWaterMark(U016 clock)
{
    U016  wv;
    U016  i;
    U032  clockMHz;
    
    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv >>= 8;
    wv &= 0x03;       // mask pixel format bits
    
    // Check dac format
    if (wv)
    {
        wv--;
        clockMHz = clock;
        clockMHz <<= (U008)wv;
        clockMHz /= 100;
        
        for (i = 0; clockMHz > DACFifoTable[i].Freq ; i++)
            ;   // Find the proper FIFO value
        
        if (pDev->Dac.InputWidth == 128)
        {
            // 128 bit
            // Do WV first, as I get's blown away
            wv = ((DACFifoTable[i].LowWaterMark128) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize128) << 8) | 0x1B; 
            
        }                                                   
        else
        {
            // 64 bit   
            wv = ((DACFifoTable[i].LowWaterMark64) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize64) << 8) | 0x1B;
        }                                                  
        
        WriteIndexed(NV_PRMCIO_CRX__COLOR, i);
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);         // otherwise, we have an optimum value
    }
}   

//       CalcMNP - Set the clock chip to the requested frequency
//
//       Entry:  AX = Clock frequency in 100 kHz
//       Exit:   AL = M parameter
//               AH = N parameter
//               DL = P parameter
//               BX = Closest clock frequency in 100 kHz
//
//      Returns: long lwv = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
U032 CalcMNP(U016 *clock)
{
    U016  crystalFreq;
    U032   vclk;
    U016  vclkClosest;
    U016  deltaOld;
    U016  bestM;
    U016  bestP;
    U016  bestN;
    U016  lowM;
    U016  highM;
    
    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032   lwv;
    
    U032   edx;
    U016  dx, cx, bx;
    U016  lwvs, vclks;
    U016  t;
    
    vclk = (U032)(*clock * 10);     // Make KHz
    
    deltaOld = 0xFFFF;
                                    
    lwv = ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040;
    
    if (lwv)
    {
        // 14.3Khz
        dx = CRYSTAL_FREQ143KHZ;
        cx = 1;
        bx = 14;
    }
    else
    {
        // 13.5Khz
        dx = CRYSTAL_FREQ135KHZ;
        cx = 1;
        bx = 13;
    }                      
    
    lowM = cx;
    highM = bx;
    crystalFreq = dx;
                                              
    // Register usage below
    // eax = scratch
    // ebx = scratch
    // edx = scratch
    // si = m
    // di = n
    
    // P Loop
    for (powerP = 0; powerP <= 4; powerP++) // Init Power of P
    {                             
        // M Loop
        for (m = lowM; m <= highM; m++)
        {                          
            lwv = vclk << powerP;   // vclk * P
            
            // Compare with internal range of DAC
            if ((lwv >= 128000) && (lwv <= 350000))
            //if (1)
            {
                lwv *= (U032)m;    // vclk * P * M
                
                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);
                
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                
                lwv *= crystalFreq; // N * crystal
                   
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                
                i = m;
                j = m;
                
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                                       
                
//                   ; upper part of ebx should still be 0
//                   mov     bx, m
//                   ; Note: edx should be zero from multiply above
//                   mov     dx, bx
//                   shr     dx, 1           ; m / 2
//                   add     eax, edx        ; This will round better
//                   xor     dx, dx
//                   div     ebx             ; Freq=N*crystal/P/M
//                   
//                   mov     edx, eax        ; Save a copy        

                edx = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                
                if (lwvs < vclks)
                {               
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }            
                    
                lwvs -= vclks;      // ABS(Freq-Vclk);
                
                // lwvs is ax
                // vclks is bx
                if (((vclk / lwvs) > 500) && ((*clock) < 25000))
                {
                    bestP = powerP;
                    bestM = m;
                    bestN = n;
                    edx /= 10;
                    vclkClosest = (U016)(edx & 0xFFFF);
                    lwv = bestP;
                    lwv <<= 16;
                    lwv |= ((bestN << 8) | (bestM));
                    
                   
                    // mov     bx, vclkClosest
                    *clock = vclkClosest;
                    
                    return(lwv);
                
                }                
                else  if (lwvs < deltaOld)
                {
                    // Closer match
                    deltaOld = lwvs;
                    
                    bestP = powerP;
                    bestM = m;
                    bestN = n;
                            
                    //         mov     deltaOld, ax
                    //         mov     bestP, powerP
                    //         mov     ax, m  
                    //         mov     bestM, al
                    //         mov     ax, n
                    //         mov     bestN, al
                    
                    edx /= 10;
                    
                    //         mov     eax,edx
                    //         xor     edx,edx
                    //         mov     ebx,10
                    //         div     ebx             ; Convert
                    //         mov     vclkClosest,ax
                    vclkClosest = (U016)(edx & 0xFFFF);
                }
            }
        }
    }                             
    
  //  lwv = ((bestP << 16) | (bestN << 8) | (bestM));
    lwv = bestP;
    lwv <<= 16;
    lwv |= ((bestN << 8) | (bestM));
    
   
    // mov     bx, vclkClosest
    *clock = vclkClosest;
    
    return(lwv);
} 

//       FullCpuOn - Give the CPU full bandwidth to video memory
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOn(VOID)
{
    U016  datum;
    
    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum |= 0x2000;                            // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
} 
                                                   
//       FullCpuOff - Share the CPU bandwidth with the CRTC
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOff(VOID)
{            
    U016  datum;
    
    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum &= 0xDFFF;                            // Full Bandwidth bit OFF
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit            
} 

//
//       SetRegs - Set VGA registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID SetRegs(MODEDESC *mi)
{                    
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset
    
    WritePriv08(NV_PRMVIO_MISC__WRITE, vga_tbl[mi->mdIMode].PT_Misc);
                                                   
    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    LoadIndexRange(NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(vga_tbl[mi->mdIMode].seq_regs));
                                            
    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset
                                  
    // Load CRTC's
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x2011);  // Unlock CR0-7
                                            
    // Load CRTC, beginning at CR0, for all CR's (CR0-18), from the mode table
    LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, sizeof(CRTC), (U008 *)&(vga_tbl[mi->mdIMode].crtc_regs));
                                                                                                   
    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    LoadIndexRange(NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(vga_tbl[mi->mdIMode].gr_regs));
}                                           

VOID LoadIndexRange(U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;
    
    // Program SR1-4
    for (i = 0; i < count; i++)
    {               
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }               
}                                  

//       OEMPreSetRegs - Make special preparations to load registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID OEMPreSetRegs(VOID)
{                      
    U016  rc;
    
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    rc &= 0xF8FF;                   // Strip to standard DAC settings
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);
    
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    rc |= 0x0200;                   // Use 6-bit DAC
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);
}                               

//
//       ATCOff - Turn off Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOff(VOID)
{
    U016  flags = 0;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax            // Save flags 
    _asm    cli;                    // No interrupts during this!
#endif    
    
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Turn off screen at AR
    
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf
#endif    
}

//
//       ATCOn - Turn on Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOn(VOID)    
{
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm
    {
        pushf
        pop ax
        mov flags,ax
        cli
    }
#endif    
    
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x20);   // Turn off screen at AR
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE    
    _asm
    {
        mov ax,flags
        push ax
        popf
    }
#endif        
}

//
// ValidateMode - Validate the passed mode is valid, and if it is,
//                return the pointer to the mode information block.
//
//  Entry:  U016  mode            // VESA Mode Number to validate
//
//  Exit:   MODEDESC *mi            // Mode Information Block Pointer
//                                  // NULL if error (invalid mode)
//  NOTES:  This function must also verify the operational mode,
//          and return failure status if not valid on TV
//

MODEDESC *ValidateMode(U016 mode)
{
    MODEDESC    *mi;
    
    for (mi = &mib[0]; mi->mdVMode != 0xFFFF; mi++)
    {
        if (mi->mdVMode == mode)
        {
            if (OEMValidateMode(mi))
                return(mi);            
            break;      // Out of the for - report error
        }   
    }   
    return(NULL);
}

// From OEMIsModeAvailable - validate the mode from the OEM perspective.
//
U008 OEMValidateMode(MODEDESC *m)
{
    U032   memory;
            
    // Are we running tv mode? If so, we need an additional filter
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
    {
        if (m->mdTVMode == 0xFF)
            return((U008)0);
    }
    
    // Validate we have enough memory
    // (XRes * YRes * Bpp)/8
    //           +--- XRes / 8
    //           V
    memory = (((m->mdXRes >> 3) * m->mdBPP) * m->mdYRes);
    memory += 0xFFFF;               // Take to next 64K bank size
    memory >>= 16;                  // Divide by 64K for number of banks
    
    // memory now has the 64K blocks necessary for this mode.
    
    if (((U016)memory) > OEMGetMemSize())
        return((U008)0);
    return((U008)1);
}

// some CRTC bit definitions
// CR07
#define VT08    1
#define VT09    0x20
#define VRS08   0x04
#define VRS09   0x80
#define EXT_VRS 0x84
#define VDE08   0x02
#define VDE09   0x40
#define VBS08   0x08
// CR09
#define VBS09   0x20
// CR25
#define VT10    0x01
#define VDE10   0x02
#define VRS10   0x04
#define VBS10   0x08

VOID FlatPanelCrtc( XRes )
{
U032    DacHcrtc, DacHt, Ht, Hrs, Hre, DacVcrtc, DacVt, Vt, Vrs, Vre, Vbs, data32;
U016    Attr, Seq;
U008    Cr07, Cr09, Cr11, Cr25;

    // check for pixel doubled modes
    if (XRes < 640)
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }        
    // Make sure attr is set correctly
    Cr07 = REG_RD08(NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    REG_WR08(NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    REG_WR08(NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    Ht = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x00)>>8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)((Ht-3)<<8 | 0x04));   // HRS
    Hre = ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05)>>8) & 0xe0);    // read CR05 and mask 4:0
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(((Ht-2) | Hre)<<8 | 0x05));   // HRE = Ht - 2, CR04[4:0]
    
    // gather VT bits
    Vt = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x06)>>8);
    Cr07 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07)>>8);
    Cr25 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25)>>8);
    if (Cr07 & VT08)
        Vt |= 0x0100;
    if (Cr07 & VT09)
        Vt |= 0x0200;
    if (Cr25 & VT10)
        Vt |= 0x0400;

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vrs<<8 | 0x10));
    Cr07 &= ~EXT_VRS;
    if (Vrs & 0x100) Cr07 |= VRS08;
    if (Vrs & 0x200) Cr07 |= VRS09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    if (Vrs & 0x400) Cr25 |= VRS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));
    
    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    Cr11 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11)>>8);
    Vre |= (Cr11 & 0xf0);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vre<<8 | 0x11));
    
    // VBS = VRS
    Cr09 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09)>>8);
    Vbs = Vrs;
                
    // write VBS            
    Cr07 &= ~VBS08;
    if (Vbs & 0x100) Cr07 |= VBS08;
    Cr09 &= ~VBS09;
    if (Vbs & 0x200) Cr09 |= VBS09;
    Cr25 &= ~VBS10;
    if (Vbs & 0x400) Cr25 |= VBS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vbs<<8 | 0x15));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr09<<8 | 0x09));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));
            
    // wait for vsync
    while (REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
    while (!(REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start
    
    data32 = REG_RD32(NV_PRAMDAC_FP_DEBUG_0);           // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32);
}

U008 getDisplayType(VOID)
{
    U016   rc;
               
    OEMEnableExtensions();          // Unlock the registers
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    if (rc & 0x8000)    // is VGA slaved to something?
    {
        rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x33);
        if (rc & 0x0100)
            return DISPLAY_TYPE_FLAT_PANEL;   
        else
            return DISPLAY_TYPE_TV;      
    }
    else
        return DISPLAY_TYPE_MONITOR;    
}

U008 isTV(VOID)
{
    U016   rc;
               
    OEMEnableExtensions();          // Unlock the registers
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    return((U008)((rc >> 8) & 0x80));
}

U008 isPAL(VOID)
{
    U016   rc;
               
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x2C);   // BIOS sets 2c bit 5 for PAL, bit 4 for NTSC
    return((U008)((rc >> 8) & 0x20));
}

//
//       OEMGetMemSize - Return the pre-calculated memory size
//
//       Entry:  None
//       Exit:   AX = Number of 64K blocks
//
U016 OEMGetMemSize(VOID)
{

#ifdef DEBUG
    // This should never happen, since RamSize was set during initMapping
    if (!pDev->Framebuffer.RamSize) {
        DBG_BREAKPOINT();
    }
#endif

    return (pDev->Framebuffer.RamSize >> 16);
}          


/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
    
// And the following routines will become "throwaway" code, as they
// deal with the saving and restoring of the IO state during the
// accesses to the PRIV_IO.

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
//       SaveNVAccessState - Save the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//       Exit:   cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//               Real mode access registers set to address
VOID SaveNVAccessState(ACCESS_STATE *as)
{                      
    U008   rc;
    
    U016  wval;
    U032   dval;
           
/*            
    as->crtc_addr = 0x3D4;           // Set 3D4 by default
    as->access_reg = 0x38;           // Set CR38
                                            
    // rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x38);
    dval = NV_PRMCIO_CRX__COLOR;
                           
    // Output the MSW of the address    
    outpw(0x3D2, (U016)((dval >> 16) & 0xFFFF));
                           
    // and the LSW of the address   
    outpw(0x3D0, (U016)(dval & 0xFFFF));
                                
    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));
                                                                     
    outp(0x3D0, 0x38);              // Select the register
    wval = inpw(0x3D0);             // This data is Byte/Word accessable
    
    as->access_reg = (U008)(wval & 0xFF);
    as->access_bits = (U008)((wval >> 8) & 0xFF);
                               
    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));
                                                                     
    as->data_low = inpw(0x3D0);      // Save lsw of 32-bit data
                               
    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));
                                                                        
    as->nv_address = inpw(0x3D2);    // Read MSW of address
    as->nv_address <<= 16;           // Put in high word.
    as->nv_address |= inpw(0x3D0);   // Read LSW of address
*/
    
}


//       RestoreNVAccessState - Restore the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//               cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//       Exit:   none
VOID RestoreNVAccessState(ACCESS_STATE *as)
{
/*
    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));
    outpw(0x3D2, (U016)(as->nv_address >> 16));       // MSW of address
    outpw(0x3D0, (U016)(as->nv_address & 0xFFFF));    // LSW of address

    // Select the buffered data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA32) << 8) | (as->access_reg)));
                                                                       
    outpw(0x3D0, as->data_low);     // LSW of address
    
    outpw(as->crtc_addr, (((as->access_bits) << 8) | (as->access_reg)));
*/    
}

/**********************************************************************/
/**********************************************************************/

//
// POST the chip, just like the BIOS normally does
//
#ifdef KJK
//
// Needs completely rewritten for NV4
//
VOID NvPost()
{
    U032 memconfig;
    U032 val32;

    //////////////////////////////////////////////
    //
    // Taken from BIOS POST sequence
    //
    
    //
    // Enable requisite engines
    //
    WritePriv32(0x11111111, NV_PMC_ENABLE);
    
    //
    // Program 100MHz MPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);    
    else
        WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);    

    //
    // Program PFB Config to defaults
    //
    WritePriv32( DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED), NV_PFB_CONFIG_0);
    
    //
    // Program VPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x00028D0E, NV_PRAMDAC_MPLL_COEFF);    
    else
        WritePriv32(0x0001400C, NV_PRAMDAC_MPLL_COEFF);    
    
    //
    // Program PFB Power control
    //
    WritePriv32(DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED), NV_PFB_GREEN_0);    

    //
    // Program memory timings based on framebuffer size
    //
    //
    
    //
    // Determine how wide/deep is the framebuffer
    //
    /*  
     Memory layout:

           4mb 128-bit     33221100 77665544 bbaa9988 ffeeddcc
           2mb 128-bit     33221100 77665544 xxxxxxxx xxxxxxxx

           128-bit covers address 0-3fffff in both 2mb and 4mb configs,
           but the second 2 dwords are garbage on 2mb boards.
              
           4mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc
           2mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc

           64-bit covers address 0-3fffff in 4mb configs, while
           64-bit covers address 0-1fffff in 2mb configs. All bytes are
           addressed.
    */
    
    memconfig = ReadPriv32(NV_PFB_BOOT_0);
    memconfig &= 0xFFFFFFFC;
    memconfig |= DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _DEFAULT); // mask to 4meg, keep bus width
  
    //
    // Poke the framebuffer based on bus width
    //    
    if (memconfig & DRF_DEF(_PFB, _BOOT_0, _RAM_WIDTH_128, _ON))
    {
        //
        // 128bit test
        //
        WriteFb32('NV3A', 0x00200008);  // 2meg+8
    
        //
        // 4meg?
        //
        if (ReadFb32(0x00200008) != 'NV3A')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);
    
    } else {
    
        //
        // 64bit test
        //
        WriteFb32('NV3A', 0x00100000);  // 1meg
        WriteFb32('NV3B', 0x00300000);  // 3meg
        
        //
        // 4meg?
        //
        if (ReadFb32(0x00300000) != 'NV3B')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);
        
            //
            // 2meg?
            //
            if (ReadFb32(0x00100000) != 'NV3A')
                //
                // Assume 1meg
                //
                ;//memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _1MB);
        
    }
    
    //
    // Write the memory config
    //
    WritePriv32(memconfig, NV_PFB_BOOT_0);
    
    // 
    // Now program the appropriate memory timings
    //
    if ((memconfig & 3) == DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB))
    {
        //
        // 2meg timings
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);
                  
        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);
                  
        WritePriv32(DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT) 
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON), NV_PFB_CONFIG_1);
                  
        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);
                  
        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);    
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);    
                  
    } else {
        //
        // 4meg
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);
                  
        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);
    
        WritePriv32(DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT) 
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON), NV_PFB_CONFIG_1);
    
        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);
    
        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);    
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);    
    
    }
    
    //
    // Enable clocking
    //
    WritePriv32(DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_DLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_SOURCE,_PROG)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_SOURCE,_DEFAULT)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_BYPASS,_FALSE) 
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_PCLK_SOURCE,_VPLL)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VCLK_RATIO,_DB1), NV_PRAMDAC_PLL_COEFF_SELECT);
            
    //
    // Setup optimal PCI interface
    //
    WritePriv32(DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP)
              | DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO), NV_PBUS_DEBUG_1);                  


    //
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A) & 0x3FFF) | 0x0000);
    
    //
    // Boot with TV off, and set for NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28) & 0x00FF) | 0x0000);
    
    //
    // Float DDC pins high (not touched during a mode set or save/restore state)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3300);

    //
    // Disable DDC
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3200);

    //
    // Program NTSC TV settings
    //
    WritePriv32(0x00000006, NV_PRAMDAC_VSERR_WIDTH); 
    WritePriv32(0x0000000C, NV_PRAMDAC_VEQU_END);
    WritePriv32(0x0000000C, NV_PRAMDAC_VBBLANK_END);
    WritePriv32(0x00000024, NV_PRAMDAC_VBLANK_END);
    WritePriv32(0x0000020C, NV_PRAMDAC_VBLANK_START);
    WritePriv32(0x00000206, NV_PRAMDAC_VBBLANK_START);
    WritePriv32(0x00000207, NV_PRAMDAC_VEQU_START);
    WritePriv32(0x0000020D, NV_PRAMDAC_VTOTAL);
    WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
    WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
    WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
    WritePriv32(0x0000034A, NV_PRAMDAC_HBLANK_START);
    WritePriv32(0x00000088, NV_PRAMDAC_HBLANK_END);
    WritePriv32(0x0000035A, NV_PRAMDAC_HTOTAL);
    WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
    WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);

    //
    // If strapped to PAL, program PAL TV settings
    //
    if ((ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000180) == 0x00000100)
    {
    
        WritePriv32(0x00000005, NV_PRAMDAC_VSERR_WIDTH);
        WritePriv32(0x0000000A, NV_PRAMDAC_VEQU_END);
        WritePriv32(0x0000000A, NV_PRAMDAC_VBBLANK_END);
        WritePriv32(0x0000002C, NV_PRAMDAC_VBLANK_END);
        WritePriv32(0x0000026C, NV_PRAMDAC_VBLANK_START);        
        WritePriv32(0x00000269, NV_PRAMDAC_VBBLANK_START);
        WritePriv32(0x0000026C, NV_PRAMDAC_VEQU_START);
        WritePriv32(0x00000271, NV_PRAMDAC_VTOTAL);
        WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
        WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
        WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
        WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START);
        WritePriv32(0x00000092, NV_PRAMDAC_HBLANK_END);
        WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL);
        WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
        WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);
    }
    
}
#endif // KJK

/**********************************************************************/
/**********************************************************************/


//
// The following MAIN() routine is only used for standalone DOS compiles
//                                   
#ifdef DOS_COMPILE                                                 
VOID main(U016 ac, U008 **av)
{
    U016  mode;                   // Mode to be set
    U016  rc;                     // Return code
    
    printf("NVIDIA MODESET V1.00\n\n");
    
    if (ac < 2)
    {
        printf("Usage: modeset vmode\n");
        printf("       vmode - Vesa Mode Number\n");
        exit(1);
    }           
    
    if ((mode = h2i(*(++av))) == 0xFFFF)
    {
        printf("Error! Bad Vesa Mode Number\n");
        exit(2);
    }        
    
    printf("Setting Mode 0x%02X\n", mode);
    getchar();
    
    rc = VBESetMode(mode);
    
    if (((rc & 0xFF) != 0x4F) || ((rc & 0xFF00) >> 8))
    {
        printf("Error! Could Not Set Mode 0x%02X [rc=%04X]\n", mode, rc);
        exit(3);
    }        
                                                      
    exit(0);
}

//
// h2i - convert Hex string to an Unsigned Integer
U016 h2i(U008 *str)                 
{
    U016  sus = 0;                // Starting unsigned short
    U016  i;
    U016  val;                    // Conversion value
    
    // Since we only do U016's, we have a max of 0xFFFF-1
    if ((i = strlen(str)) > 4)
        return(0xFFFF);
    
    while (i--)
    {    
        val = toupper(*str) - 0x30;  // Convert Hex 0-9
        if (val > 9)
        {
            val -= 7;               // Take 7 more to convert A-F
            if (val < 0x0A || val > 0x0F)
                return(0xFFFF);     // Error!
        }                                  
        sus *= 16;                  // Shift by 4
        sus += val;             
        str++;
    }                                                 
    return(sus);
}
#endif // DOS_COMPILE
 


//****************************************************************************************
//
//  Program the I2C device for a display mode
//  returns:    status word
U016 setI2C(MODEDESC *minfo)
{
U016     status;

#ifdef IKOS
    return ERR_I2C_COMM;
#endif
    // Identify which part: Chrontel or Brooktree?
    // ID was done at fbinit.
    i2cInit(pDev->Dac.TVOutPortID);
    switch (pDev->Framebuffer.EncoderID)
    {
        case 0x88:
        case 0x8A:
            status = programBrooktree(minfo->mdTVMode);
            break;
        case 0xEA:
        case 0xEC:
            status = programChrontel(minfo->mdTVMode);
            break;                        
    }
    return (status);
}

#define	HSYNCWIDTH	0x3f	// bits we must preserve	
//****************************************************************************************
//
//  Program the Brooktree device for a display mode
//  args:       internal TV mode
//  returns:    status word
U016 programBrooktree(U016 TVmode)
{
U016    i, status;
U008    *strptr;
U008    Data, Adr;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV)    // can be MONITOR, TV, or FLAT PANEL
    {
        TVmode = TV_MODE_640x480;   // program the encoder anyway, to get synched display on TV
    }        

    // send an init string
    i2cStart(pDev->Dac.TVOutPortID);                       // start state for I2C
    strptr = (U008 *)&BT_Init;          // send init sequence
    status = i2cSendByte(pDev->Dac.TVOutPortID, (U008)pDev->Framebuffer.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev->Dac.TVOutPortID);                         // end state for I2C

    // get a pointer to the string to write to the I2C controller
    if (TVformat == NTSC)
        strptr = (U008 *)BT_NTSC[TVmode];
    else
        strptr = (U008 *)BT_PAL[TVmode];

    // send a timing string
    i2cStart(pDev->Dac.TVOutPortID);                       // start state for I2C
    status = i2cSendByte(pDev->Dac.TVOutPortID, (U008)pDev->Framebuffer.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev->Dac.TVOutPortID);                           // end state for I2C

    // If not TV, blank TV image
    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV)    // can be MONITOR, TV, or FLAT PANEL
    {
        Data = 0x07;                // set luminance to 0 gain
        Adr = 0xca;
        i2cWrite(pDev->Dac.TVOutPortID, (U008)(pDev->Framebuffer.EncoderID >> 1), (U016) 1, &Adr, 1, &Data);
        Data = 0x07;                // set chroma to 0 gain
        Adr = 0xcc;
        i2cWrite(pDev->Dac.TVOutPortID, (U008)(pDev->Framebuffer.EncoderID >> 1), (U016) 1, &Adr, 1, &Data);
    }
    return (status);
}

//****************************************************************************************
//
//  Program the Chrontel device for a display mode
//  args:       internal TV mode
//  returns:    status word
U016 programChrontel(U016 TVmode)
{    
U016    i, status;
U008    *strptr;
U008    *initptr;

    if (pDev->Framebuffer.EncoderType != NV_ENCODER_CHRONTEL_7003) 
    {
        // The only Chrontel encoder we know how to program is 7003.
        return ERR_I2C_UNKNOWN;
    }

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    if ((pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV) | (TVmode == 0xff))    // can be MONITOR, NTSC, or PAL
    {
        TVmode = TV_MODE_640x480;   // program the encoder anyway, to get synched display on TV
    }        
    
    // send an init string
    i2cStart(pDev->Dac.TVOutPortID);                   // start state for I2C
    strptr = (U008 *)&I2C_Init;     // send init sequence
    status = i2cSendByte(pDev->Dac.TVOutPortID, (U008)pDev->Framebuffer.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
//      DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, " ", *initptr);
        status = i2cSendByte(pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev->Dac.TVOutPortID);                     // end state for I2C

    // get a pointer to the string to write to the I2C controller
    if (TVformat == NTSC)
        strptr = (U008 *)i2c_NTSC[TVmode];
    else
        strptr = (U008 *)i2c_PAL[TVmode];
            
    // send a timing string
    i2cStart(pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev->Dac.TVOutPortID, (U008)pDev->Framebuffer.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
//        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, " ", *strptr);
        status = i2cSendByte(pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev->Dac.TVOutPortID);                     // end state for I2C
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\WATCOM.H ===
#ifndef _WATCOM_H_
#define _WATCOM_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/*************************** OS Specific Module ****************************\
*                                                                           *
* Module: WATCOM.H                                                          *
*       WATCOM and Windows specific defines and pragmas.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)     1/06/95 - copied from nvrm.h.          *
*                                                                           *
\***************************************************************************/
//
// Special pragmas for the WATCOM VxD build environment.
//
#ifdef _LGROUP
#pragma data_seg( "_LDATA", "CODE" )
#endif
#ifdef _IGROUP
#pragma data_seg( "_IDATA", "ICODE" )
#endif
#endif // _WATCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nvidia.inc ===
;       (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
;       Portions Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.
;
;       NVIDIA.INC - Include file for MiniVDD definitions
;
;       Written by:     Mark Stephen Krueger
;       Date:           10/1/96
;
;       $Revision: 6 $
;       $Date: 5/05/98 6:36p $
;       $Logfile: /resman.050/win96/vdd/nvidia.inc $
;       $Log: /resman.050/win96/vdd/nvidia.inc $
; 
; 6     5/05/98 6:36p Jhinman
; Removed Weitek simulation equates.
; 
; 5     1/14/98 3:04p Jhinman
; Moved API functions to 1xx.
; 
; 4     1/09/98 2:03p Jhinman
; Added some equates for API definitions.
; 
; 3     11/07/97 6:42p Jhinman
; Add equate for nv_device_id.
; 
; 2     10/27/97 3:02p Jhinman
; Define RM_OK (status).
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 6     1/23/97 11:02a Markk
; Removed tabs.
; 
; 5     1/14/97 3:42p Markk
; Added EXT_NV_PDAC_GEN_CTRL and EXT_NV_PFB_CONFIG_0 to save
; corresponding NV3 registers.
; 
; 4     11/15/96 6:05p Markk
; Put in NVIDIA_COMMON stuff for simulating.
; 
; 3     11/13/96 12:28p Markk
; Updated PerVMData for NV3.
; Fixed PCI_DWORD_* constants.
; Added other PCI commands and error codes.
; 
; 2     10/21/96 7:02p Markk
; Added more VGA register definitions.
; Added flag to save structure to know when values saved.
; 
; 1     10/16/96 9:16a Markk
; Include file for the NVidia Mini-VDD.
;

; OS Version numbers
VERS_MILLENNIUM    EQU     045ah
VERS_WIN98         EQU     040AH

; Definitions of ACPI power states. Should be (but aren't) defined in CONFIGMG.INC.
CM_POWERSTATE_D3   EQU     8   
CM_POWERSTATE_D2   EQU     4
CM_POWERSTATE_D1   EQU     2
CM_POWERSTATE_D0   EQU     1
CM_POWERSTATE_HIBERNATE   EQU     10h

; Resource Manager API functions
NVRM_API_ARCHITECTURE_32 equ 1000+73
NVRM_API_DISPLAY         equ 1000+75
NVRM_API_ACPI_ENABLED    equ 1000+82

NVRM_API_ALLOC_FIFO equ     1000+1
NVRM_API_MAP_FIFO   equ     1000+3
MAP_LINEAR          equ     1
NVRM_API_INIT       equ     1000+100
NVRM_API_ENABLEVGA  equ     1000+101
NVRM_API_ENABLEHIRES equ    1000+102
NVRM_API_DEV_HANDLE equ     1000+103
NVRM_API_DEV_HANDLE_2 equ   1000+104
NVRM_API_POWER_UP   equ     1000+105
NVRM_API_POWER_DOWN equ     1000+106
NVRM_API_EXIT       equ     1000+107
NVRM_API_POWER_D1   equ     1000+108
NVRM_API_POWER_D2   equ     1000+109
NVRM_API_READ_EDID  equ     1000+112
NVRM_API_NUM_HEADS  equ     1000+113
NVRM_API_GET_DDC_CAPS equ   1000+114
NVRM_API_HIBERNATE  equ     1000+115
NVRM_API_SET_MONITOR_POWER equ 1000+116
NVRM_API_BLANK_SECONDARY   equ 1000+117   
NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP      equ     1000+118
; RM display types
DISPLAY_TYPE_MONITOR    equ 0
DISPLAY_TYPE_TV         equ 1
DISPLAY_TYPE_FLAT_PANEL equ 3

;
;Chip ID equates:
;
NV31A           equ     DRF_DEF(_PMC,_BOOT_0,_IMPLEMENTATION,_NV3) OR \
                        DRF_DEF(_PMC,_BOOT_0,_MASK_REVISION_A) OR \
                        DRF_DEF(_PMC,_BOOT_0,_FIB_REVISION_0)
  
RM_OK                   equ             0

NV3_DEVICE_ID   EQU             0018H

;
; I/O addresses
;
CRTC_INDEX_MONO         equ     03B4h
CRTC_DATA_MONO          equ     03B5h
CRTC_INDEX_COLOR        equ     03D4h
CRTC_DATA_COLOR         equ     03D5h
INPUT_STATUS_MONO       equ     CRTC_INDEX_MONO + 6
INPUT_STATUS_COLOR      equ     CRTC_INDEX_COLOR + 6
OUTPUT_FC_MONO          equ     CRTC_INDEX_MONO + 6
OUTPUT_FC_COLOR         equ     CRTC_INDEX_COLOR + 6
ATC_INDEX               equ     03C0h
ATC_RDATA               equ     03C1h
MISC_OUTPUT             equ     03C2h
FEAT_STATUS             equ     03C2h
SUBSYS_ENABLE           equ     03C3h
SEQ_INDEX               equ     03C4h
SEQ_DATA                equ     03C5h
DAC_MASK                equ     03C6h
DAC_RINDEX              equ     03C7h
DAC_WINDEX              equ     03C8h
DAC_DATA                equ     03C9h
FC_INPUT                equ     03CAh
MISC_INPUT              equ     03CCh
GDC_INDEX               equ     03CEh
GDC_DATA                equ     03CFh
;
BIOS_SCRATCH1       equ     2Ch         ; BIOS SCRATCH REG
BIOS_PGRM_TV        equ     2           ; BIOS will program TV encoder when CLEAR
NVRM_ACCESS         equ     038h
NVRM_ACCESS_MASK    equ     001h
NVRM_IDENT          equ     000h
NVRM_ADDRESS        equ     002h
NVRM_DATA           equ     004h
NVRM_DATA32         equ     006h
NVRM_SELECT_MASK    equ     006h        ; Mask for decode bits
NVRM_SELECT         equ     1           ; Least signifcant bit is 1


;----------------------------------------------------------------------------
unlock_extension_regs           macro

        mov     edx,SEQ_INDEX           ; EDX -> SR index register
        in      al,dx                   ; get current SR index
        ror     eax,8                   ; save it

        mov     ax,05706h               ; this will unlock the extension regs
        out     dx,ax                   ;
;
        rol     eax,8                   ; get the index
        out     dx,al                   ; restore SR index
        endm


;
;The PerVMData structure.  This structure represents the our reserved space
;in the so-called CB data structure.  The CB data structure is created for
;each VM started in the system.  We can therefore, save states that we need
;to remember on a per-VM basis.  This data will vary for every mini-VDD.
;The NVidia chipsets requires a few registers states for its extension registers
;to be saved.
;
PerVMData       struc
        Latch0                  db      ?               ; Graphics controller latches
        Latch1                  db      ?
        Latch2                  db      ?
        Latch3                  db      ?
        SeqReg06                db      ?
IFDEF NVIDIA_SPECIFIC
        EXT_Repaint0NV          db      ?               ; CRTC[19]
        EXT_Repaint1NV          db      ?               ; CRTC[1A]
        EXT_Repaint1NVSet       db      ?               ; CRTC[1A] Set?
        EXT_FifoBurst           db      ?               ; CRTC[1B]
        EXT_Repaint3NV          db      ?               ; CRTC[1C]
ENDIF ; NVIDIA_SPECIFIC
        EXT_WriteBank           db      ?               ; CRTC[1D]
        EXT_ReadBank            db      ?               ; CRTC[1E]
        EXT_Unlock              db      ?               ; CRTC[1F]
IFDEF NVIDIA_SPECIFIC
        EXT_FifoLowWaterMark    db      ?               ; CRTC[20]
        EXT_ExtraBits           db      ?               ; CRTC[25]
        EXT_PixelFormat         db      ?               ; CRTC[28]
        EXT_TVDecimation        db      ?               ; CRTC[29]
        EXT_OverscanHigh        db      ?               ; CRTC[2A]
        EXT_HorizontalExtra     db      ?               ; CRTC[2D]
ENDIF ; NVIDIA_SPECIFIC
        EXT_HWCursorAddress0    db      ?               ; CRTC[30]
        EXT_HWCursorAddress1    db      ?               ; CRTC[31]
IFDEF NVIDIA_SPECIFIC
        EXT_VideoWindow0        db      ?               ; CRTC[32]
        EXT_VideoWindow1        db      ?               ; CRTC[33]
ENDIF ; NVIDIA_SPECIFIC
IFDEF NVIDIA_COMMON
        EXT_RealModeAccess      db      ?               ; CRTC[38]
ENDIF ; NVIDIA_COMMON
IFDEF NVIDIA_SPECIFIC
        EXT_Interlace           db      ?               ; CRTC[39]
ENDIF ; NVIDIA_SPECIFIC
            EXT_CanopusTVReg    db      ?               ; Canopus TV Flag register (which ever it is. )
IFDEF NVIDIA_COMMON
        EXT_RealModeAddress     dd      ?               ; Real mode address
        EXT_RealModeData32      dw      ?               ; Latched word for real mode data
;        EXT_VpllM               db      ?               ; VPLL M
;        EXT_VpllN               db      ?               ; VPLL N
;        EXT_VpllP               db      ?               ; VPLL P
        EXT_NV_VPLL_COEFF       dd      ?               ; VPLL Coefficients        
        EXT_NV_PRAMDAC          dd      ?               ; NV_PRAMDAC_PLL_COEFF_SELECT
        EXT_NV_PDAC_GEN_CTRL    dd      ?               ; NV_PRAMDAC_GENERAL_CONTROL
        EXT_NV_PFB_CONFIG_0     dd      ?               ; NV_PFB_CONFIG_0
        EXT_NV_VPLL2_COEFF      dd      ?               ; VPLL Coefficients        
ENDIF ; NVIDIA_COMMON
        Majic                   dd      ?               ; Used for debugging
        StdCRTC                 db      25 dup (?)      ; CRTC 0-18h
;;;;;;;;SR1                     db      ?               ; Sequencer 1
        GoingFullscreen         db      ?               ; set in PostHiresToVGA, cleared in RestoreRegs
IFDEF NVIDIA_SPECIFIC
        EXT_HeadOwner           db      ?               ; CRTC[44]
ENDIF ; NVIDIA_SPECIFIC
PerVMData       ends
;
;FALSE           equ     TRUE
TRUE            equ     (NOT FALSE)
;
PCI_MECH1_CNT           record  PCI_ENABLE_CONFIG1:1, PCI_RESA1:7, PCI_BUS1:8, \
                                PCI_DEVICE1:5, PCI_FUNCTION1:3, PCI_DWORD1:6, PCI_RESB1:2
;PCI_DEVICE_MAX          equ     32      
;PCI_DEVICE_LOW_BIT      equ     11      
PCI_MECH1_ADDR          equ     00CF8h
PCI_MECH1_DATA          equ     00CFCh
;
PCI_MECH2_CSE         equ     00CF8h
PCI_MECH2_FORWARD     equ     00CFAh
PCI_MECH2_BASE        equ     0C000h
PCI_MECH2_ADDR          record  PCI_RESA2:4, PCI_DEVICE2:4, PCI_DWORD2:6, PCI_RESB2:2
PCI_MECH2_CNT           record  PCI_ENABLE_CONFIG2:4, PCI_FUNCTION2:3, PCI_SCE2:1
PCI_MECH2_KEY_ENABLE    equ     00Fh
;PCI_ENABLE_CONFIG_MASK  equ     080000000h
;PCI_VENDOR_ID_MASK      equ     0FFFFh
;PCI_BASE_ADDR_MASK      equ     0FFFFFFF0h
;PCI_FUNC_LOW_BIT        equ     8
PCI_CONF_00             record  PCI_DEV_ID:16, PCI_VENDOR_ID:16
PCI_CONF_01             record  PCI_STATUS:16, PCI_COMMAND:16
PCI_CONF_02             record  PCI_CLASS:24, PCI_REV:8
PCI_CONF_03             record  PCI_BIST:8, PCI_HEADER_TYPE:8, PCI_LATENCY:8, PCI_CACHE_LINE:8
PCI_CONF_11             record  PCI_SUB_ID:16, PCI_SUB_VENDOR_ID:16
PCI_CONF_15             record  PCI_MAX_LAT:8, PCI_MIN_GNT:8, PCI_INT_PIN:8, PCI_INT_LINE:8
PCI_BAR                 record  PCI_ADDR:28, PCI_PREFETCH:1, PCI_TYPE:2, PCI_MEM:1
PCI_CMD                 record  PCI_CMD_RES:6, PCI_CMD_FAST_BB:1, PCI_CMD_SERR:1, PCI_CMD_WAIT_CC:1, \
                                PCI_CMD_PARITY:1, PCI_CMD_PALETTE:1, PCI_CMD_MWI:1, PCI_CMD_SCM:1, \
                                PCI_CMD_MASTER:1, PCI_CMD_MEM:1, PCI_CMD_IO:1
;
PCI_DWORD_0             equ     0
PCI_DWORD_1             equ     1
PCI_DWORD_2             equ     2
PCI_DWORD_3             equ     3
PCI_DWORD_4             equ     4
PCI_DWORD_5             equ     5
PCI_DWORD_6             equ     6
PCI_DWORD_7             equ     7
PCI_DWORD_8             equ     8
PCI_DWORD_9             equ     9
PCI_DWORD_10            equ     10
PCI_DWORD_11            equ     11
PCI_DWORD_12            equ     12
PCI_DWORD_13            equ     13
PCI_DWORD_14            equ     14
PCI_DWORD_15            equ     15
;
NV_DEFAULT              equ     0CC000000h
;
PCI_FUNCTION_ID         equ     0B1h
PCI_BIOS_PRESENT        equ     001h
FIND_PCI_DEVICE         equ     002h
FIND_PCI_CLASS_CODE     equ     003h
GENERATE_SPECIAL_CYCLE  equ     006h
READ_CONFIG_BYTE        equ     008h
READ_CONFIG_WORD        equ     009h
READ_CONFIG_DWORD       equ     00Ah
WRITE_CONFIG_BYTE       equ     00Bh
WRITE_CONFIG_WORD       equ     00Ch
WRITE_CONFIG_DWORD      equ     00Dh
;
PCI_SUCCESSFUL          equ     000h
PCI_FUNC_NOT_SUPPORTED  equ     081h
PCI_BAD_VENDOR_ID       equ     083h
PCI_DEVICE_NOT_FOUND    equ     086h
PCI_BAD_REGISTER_NUMBER equ     087h
;
RefreshRateStruct       struc
VetricalRefreshRate             dd      ?               ; Vertical refresh rate in Hz
HorizontalRefreshRate           dd      ?               ; Horizontal refresh rate in Hz
crtcInfoBlockForced             CRTCInfoBlock   <>      ; CRTCInfoBlock        
RefreshRateStruct       ends
;
PRefreshRateStruct      typedef ptr RefreshRateStruct
;
; Clock rates that must be in the NVidia BIOS clock table
DC_031_500              equ     3150
DC_025_175              equ     2518
DC_049_500              equ     4950
DC_050_000              equ     5000
DC_040_000              equ     4000
DC_036_000              equ     3600
DC_078_750              equ     7875
DC_075_000              equ     7500
DC_065_000              equ     6500
DC_044_900              equ     4490
DC_135_000              equ     13500
DC_108_500              equ     10850

;;;;typedef struct def_rmusrapi_struct {
;;;;  U032  function;       
;;;;  U032  device; 
;;;;} RMUSRAPI_STRUCT,*PRMUSRAPI_STRUCT;
minivdd_CALLRM_rmusrapi_Struct struct
  rmusrapi_function           dd      0
  rmusrapi_device             dd      0
minivdd_CALLRM_rmusrapi_Struct ends
DEFAULT_PRIMARY_HDEV          equ 1
DISPLAY_TYPE_MONITOR          equ 0
DISPLAY_TYPE_TV               equ 1
DISPLAY_TYPE_DUALSURFACE      equ 2
DISPLAY_TYPE_FLAT_PANEL       equ 3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VPICD.H ===
#ifndef _VPICD_H_
#define _VPICD_H_
/******** Operating System Interface for NVidia Hardware Simulator  ********\
*                                                                           *
* Module: VPICD.H                                                           *
*       Header file for Virtual PIC device.                                 *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)     10/12/94 - wrote it                   *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

//
// Output of picGetStatus()
//
#define VPICD_Stat_IRET_Pending     0x01
#define VPICD_Stat_IRET_Pending_Bit 0
#define VPICD_Stat_In_Service	    0x02
#define VPICD_Stat_In_Service_Bit   1
#define VPICD_Stat_Phys_Mask	    0x04
#define VPICD_Stat_Phys_Mask_Bit    2
#define VPICD_Stat_Phys_In_Serv     0x08
#define VPICD_Stat_Phys_In_Serv_Bit 3
#define VPICD_Stat_Virt_Mask	    0x10
#define VPICD_Stat_Virt_Mask_Bit    4
#define VPICD_Stat_Virt_Req         0x20
#define VPICD_Stat_Virt_Req_Bit     5
#define VPICD_Stat_Phys_Req	        0x40
#define VPICD_Stat_Phys_Req_Bit     6
#define VPICD_Stat_Virt_Dev_Req     0x80
#define VPICD_Stat_Virt_Dev_Req_Bit 7
//
// Options in IRQ Descriptor
//
#define VPICD_Opt_Read_Hw_IRR       0x01
#define VPICD_Opt_Read_Hw_IRR_Bit   0
#define VPICD_Opt_Can_Share         0x02
#define VPICD_Opt_Can_Share_Bit     1
//
// IRQ descriptor.
//
struct VPICD_IRQ_Descriptor
{
    WORD  VID_IRQ_Number;
    WORD  VID_Options;
    DWORD VID_Hw_Int_Proc;
    DWORD VID_Virt_Int_Proc;
    DWORD VID_EOI_Proc;
    DWORD VID_Mask_Change_Proc;
    DWORD VID_IRET_Proc;
    DWORD VID_IRET_Time_Out;
};
//
// VPICD service defines.
//
#define VPICD_Get_Version               0x0000
#define VPICD_Virtualize_IRQ            0x0001
#define VPICD_Set_Int_Request           0x0002
#define VPICD_Clear_Int_Request         0x0003
#define VPICD_Phys_EOI                  0x0004
#define VPICD_Get_Complete_Status       0x0005
#define VPICD_Get_Status                0x0006
#define VPICD_Test_Phys_Request         0x0007
#define VPICD_Physically_Mask           0x0008
#define VPICD_Physically_Unmask         0x0009
#define VPICD_Set_Auto_Masking          0x000A
#define VPICD_Get_IRQ_Complete_Status   0x000B
#define VPICD_Convert_Handle_To_IRQ     0x000C
#define VPICD_Convert_IRQ_To_Int        0x000D
#define VPICD_Convert_Int_To_IRQ        0x000E
#define VPICD_Call_When_Hw_Int          0x000F
#define VPICD_Force_Default_Owner       0x0010
#define VPICD_Force_Default_Behavior    0x0011
#define VPICD_Auto_Mask_At_Inst_Swap    0x0012
#define VPICD_Begin_Inst_Page_Swap      0x0013
#define VPICD_End_Inst_Page_Swap        0x0014
//
// VID callback routines.
//
#pragma aux VPICD_INT   parm [EAX] [EBX];
//
// Make functions to these services.
//
WORD  picGetVersion(VOID);
DWORD picVirtualizeIRQ(struct VPICD_IRQ_Descriptor *);
VOID  picSetIntRequest(DWORD, DWORD);
VOID  picClearIntRequest(DWORD, DWORD);
VOID  picPhysEOI(DWORD);
DWORD picGetCompleteStatus(DWORD, DWORD);
DWORD picGetStatus(DWORD, DWORD);
DWORD picTestPhysRequest(DWORD);
VOID  picPhysicallyMask(DWORD);
VOID  picPhysicallyUnmask(DWORD);
VOID  picSetAutoMasking(DWORD);
DWORD picGetIRQCompleteStatus(DWORD, DWORD);
DWORD picGetIRQVirtualizedStatus(DWORD, DWORD);
DWORD picConvertHandleToIRQ(DWORD);
DWORD picConvertIRQToInt(DWORD, DWORD);
DWORD picConvertntToIRQ(DWORD);
DWORD picCallWhenHwInt(DWORD);
DWORD picForceDefaultOwner(DWORD, DWORD);
VOID  picForceDefaultBehavior(DWORD);

#pragma aux picGetVersion =                                 \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_Version)    \
            value [AX];

#pragma aux picVirtualizeIRQ =                              \
            CALL_VXD(VPICD_Device_ID, VPICD_Virtualize_IRQ) \
            parm [EDI]                                      \
            value [EAX];

#pragma aux picSetIntRequest =                              \
            CALL_VXD(VPICD_Device_ID, VPICD_Set_Int_Request)\
            parm [EAX] [EBX];

#pragma aux picClearIntRequest =                            \
            CALL_VXD(VPICD_Device_ID, VPICD_Clear_Int_Request)\
            parm [EAX] [EBX];

#pragma aux picPhysEOI =                                    \
            CALL_VXD(VPICD_Device_ID, VPICD_Phys_EOI)       \
            parm [EAX];

#pragma aux picGetCompleteStatus =                          \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_Complete_Status)\
            parm [EAX] [EBX]                                \
            value [ECX];

#pragma aux picGetStatus =                                  \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_Status)     \
            parm [EAX] [EBX]                                \
            value [ECX];

#pragma aux picTestPhysRequest =                            \
            CALL_VXD(VPICD_Device_ID, VPICD_Test_Phys_Request)\
            parm [EAX]                                      \
            value [EAX];

#pragma aux picPhysicallyMask =                             \
            CALL_VXD(VPICD_Device_ID, VPICD_Physically_Mask)\
            parm [EAX];

#pragma aux picPhysicallyUnmask =                           \
            CALL_VXD(VPICD_Device_ID, VPICD_Physically_Unmask)\
            parm [EAX];

#pragma aux picSetAutoMasking =                             \
            CALL_VXD(VPICD_Device_ID, VPICD_Set_Auto_Masking)\
            parm [EAX];

#pragma aux picGetIRQCompleteStatus =                       \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_IRQ_Complete_Status)\
            parm [EAX] [EBX]                                 \
            value [ECX];

#pragma aux picGetIRQVirtualizedStatus =                       \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_IRQ_Complete_Status)\
            "sbb    EAX, EAX"                               \
            parm [EAX] [EBX]                                 \
            value [EAX];

#pragma aux picConvertHandleToIRQ =                         \
            CALL_VXD(VPICD_Device_ID, VPICD_Convert_Handle_To_IRQ)\
            parm [EAX]                                      \
            value [ESI];

#pragma aux picConvertIRQToInt =                            \
            CALL_VXD(VPICD_Device_ID, VPICD_Convert_IRQ_To_Int)\
            parm [EAX] [EBX]                                \
            value [EAX];
            
#pragma aux picConvertIntToIRQ =                            \
            CALL_VXD(VPICD_Device_ID, VPICD_Convert_Int_To_IRQ)\
            parm [EAX]                                      \
            value [EAX];

#pragma aux picCallWhenHwInt =                              \
            CALL_VXD(VPICD_Device_ID, VPICD_Call_When_Hw_Int)\
            parm [ESI]                                      \
            value [ESI];

#pragma aux picForceDefaultOwner =                          \
            CALL_VXD(VPICD_Device_ID, VPICD_Force_Default_Owner)\
            parm [EAX] [EBX]                                \
            value [EAX];

#pragma aux picForceDefaultBehavior =                      \
            CALL_VXD(VPICD_Device_ID, VPICD_Force_Default_Behavior)\
            parm [EAX];

#endif // _VPICD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\modehw.c ===
//
// modehw.c -  OS specific NV register access routines for mode set code.
//
// These routines utilize IO to access the NV3 controller. To use
// the modeset code in a non-IO based environment, the following
// routines must be modified to access the NV3 through the PCI
// addressing.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//
#include <nv_ref.h>
#include <nvrm.h>
#include "nvhw.h"
#include "modes.h"


//
// Enable Register Extensions
//
VOID OEMEnableExtensions(VOID)
{
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x571F);
}                            

//
// Disable Register Extensions
// 
VOID OEMDisableExtensions(VOID)
{       
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x991F);
}                                 

//       WriteFb32 - Write a dword value to a fb address
//
//       Entry:  EAX = Value to write
//               ESI = fb offset
//       Exit:   None
//
VOID WriteFb32(U032 datum, U032 addr)
{
    fbAddr->Reg032[addr] = datum;       // MEM_WR32/PDFB macros resolve to this
}                          


//       ReadFb32 - Read a dword value from a fb address
//
//       Entry:  ESI = fb offset
//       Exit:   EAX = Value read
//
U032 ReadFb32(U032 addr)
{               
    return fbAddr->Reg032[addr];        // MEM_RD32/PDFB macros resolve to this
}                          


//       WritePriv32 - Write a dword value to an NV register
//
//       Entry:  EAX = Value to write
//               ESI = NV register address
//               Extended CRTC registers unlocked
//       Exit:   None
//
VOID WritePriv32(U032 datum, U032 addr)
{
    REG_WR32(addr, datum);
}                          


//       ReadPriv32 - Read a dword value from an NV register
//
//       Entry:  ESI = NV register address
//               Extended CRTC registers unlocked
//       Exit:   EAX = Value read
//
U032 ReadPriv32(U032 addr)
{               
    return(REG_RD32(addr));
}                          

// Write a data word to Priveledged IO
//
// Entry: U032 addr                // Address of Controller Register
//        U016 datum              // Data to write to SR/GR/CR
//
// Exit:  none
//
VOID WriteIndexed(U032 addr, U016 datum)
{                                    
    //
    // Keep it 8bit to be safe; index in lower byte, data in upper
    //
    REG_WR08(addr, datum & 0xFF);
    REG_WR08(addr+1, (datum >> 8) & 0xFF);
}                          


// Write a data byte to Priveledged IO
//
// Entry: U032 addr                // Address of Controller Register
//        U008 datum               // Data to write to SR/GR/CR
//
// Exit:  none
//
VOID WritePriv08(U032 addr, U008 datum)
{                                    
    REG_WR08(addr, datum);
}                          

//
// Read a data word from Priveledged IO
//
// Entry: U032 addr                // Address of controller register
//        U008 reg                 // CR/GR/SR register to read
//
// Exit:  index/data pair
//
U016 ReadIndexed(U032 addr, U008 reg)
{      
    U016 datum;
              
    //
    // Return the data in the upper byte, index in the lower
    //
    REG_WR08(addr, reg);
    datum = (REG_RD08(addr+1) << 8) & 0xFF00;
    datum |= reg;
    
    return(datum);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\MODEDATA.C ===
//
// modedata.c - Data tables used for setting extended VESA modes.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    "modes.h"
#endif // DOS_COMPILE

//  Basic VGA mode. This setup is used initially in all mode sets.
VGATBL   vga_tbl[] =
{
    // U008   columns;
    // U008   rows;
    // U008   char_height;
    // U016  RegenLenght;
    // SEQ     seq_regs;              // SR1-4
    // U008   PT_Misc;               // Misc Register
    // CRTC    crtc_regs;             // CR0-18
    // U008   PT_ATC[20];            // Attribute Controller
    // GR      gr_regs;               // GR0-8

    // Basic CRTC Table for Packed Pixel Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},               // Seq
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,    // CR0-18
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,    // Attr
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,    // GR
     0x05, 0x0F, 0xFF}
    },
     
    // Basic CRTC Table for Planar Graphics Modes.
    // We never use this! (ported this code from BIOS)
    {0x50, 0x1D, 0x10,
     0xA000,
    {0x01, 0x0F, 0x00, 0x06},
     0xE3,
    {0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C,
     0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B,
     0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x05, 0x0F, 0xFF}
    }
};   


//  Mode Information Block
//  This is the starting point for a mode set (after vga_tbl). 
//  This shows which crtc_override and e_regs (extended register) table to use.
//  This is converted from the BIOS, and therefore has some unused fields.

//  define some special cases
#define TV_MODE_320x200 0
#define TV_MODE_320x240 1
#define TV_MODE_320x400 2
#define TV_MODE_400x300 3
#define TV_MODE_480x360 4
#define TV_MODE_512x384 5
#define TV_MODE_640x480 6   // tv_modetbl entry for 640x480

MODEDESC mib[] =             // Our Mode List
{                                       
//    +------- vmode                                max DCLK     ------+
//    |      +----- imode                           row offset   -----+|
//    |      |      +----- std_modetbl              y resolution ----+||
//    |      |      |      +----- ext_modetbl       x resolution ---+|||
//    |      |      |      |     +----- tv_modetbl                  ||||
//    |      |      |      |     |     +----- crtc_override         ||||
//    |      |      |      |     |     |     +----- bits per pixel  ||||
//    |      |      |      |     |     |     |    +-----------------+|||
//    |      |      |      |     |     |     |    |     +------------+||
//    |      |      |      |     |     |     |    |     |     +-------+|
//    |      |      |      |     |     |     |    |     |     |    +---+
//    V      V      V      V     V     V     V    V     V     V    V    
    {0x100, 0x5B, PACKED, 0x11, 0x06, 0x06,  8,  640,  400,  640, MAX_DCLK},  // Mode 100 - 640x400    8bpp
    {0x101, 0x5F, PACKED, 0x01, 0x07, 0xFF,  8,  640,  480,  640, MAX_DCLK},  // Mode 101 - 640x480    8bpp
//    {0x102, 0x58, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode 102 - 800x600    4bpp
//    {0x102, 0x6A, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode  6A - 800x600    4bpp
    {0x103, 0x5C, PACKED, 0x03, 0x08, 0x08,  8,  800,  600,  800, MAX_DCLK},  // Mode 103 - 800x600    8bpp
//    {0x104, 0x5D, PLANAR, 0x04, 0x03, 0x0A,  4, 1024,  768, 1024, MAX_ATC },  // Mode 104 - 1024x768   4bpp
    {0x105, 0x5E, PACKED, 0x05, 0xff, 0x0B,  8, 1024,  768, 1024, MAX_DCLK},  // Mode 105 - 1024x768   8bpp
//    {0x106, 0x5A, PLANAR, 0x06, 0x03, 0x0D,  4, 1280, 1024,  160, MAX_ATC },  // Mode 106 - 1280x1024  4bpp
    {0x107, 0x6B, PACKED, 0x07, 0xff, 0x0E,  8, 1280, 1024, 1280, MAX_DCLK},  // Mode 107 - 1280x1024  8bpp
    {0x10E, 0x78, PACKED, 0x0D, 0x00, 0x00, 16,  320,  200,  640, MAX_DCLK},  // Mode 10E - 320x200   16bpp
    {0x10F, 0x20, PACKED, 0x12, 0x00, 0x00, 32,  320,  200, 1280, MAX_DCLK},  // Mode 10F - 320x200 32bpp
    {0x111, 0x6E, PACKED, 0x0E, 0x07, 0xFF, 16,  640,  480, 1280, MAX_DCLK},  // Mode 111 - 640x480 16bpp
    {0x112, 0x21, PACKED, 0x19, 0x07, 0xFF, 32,  640,  480, 2560, MAX_DCLK},  // Mode 112 - 640x480 32bpp
    {0x114, 0x6F, PACKED, 0x0F, 0x08, 0x08, 16,  800,  600, 1600, MAX_DCLK},  // Mode 114 - 800x600 16bpp
    {0x115, 0x22, PACKED, 0x1A, 0x08, 0x08, 32,  800,  600, 3200, MAX_DCLK},  // Mode 115 - 800x600 32bpp
    {0x117, 0x72, PACKED, 0x10, 0xff, 0x0B, 16, 1024,  768, 2048, MAX_DCLK},  // Mode 117 - 1024x768 16bpp
    {0x118, 0x3F, PACKED, 0x1C, 0xff, 0x0B, 32, 1024,  768, 4096, MAX_DCLK},  // Mode 118 - 1024x768 32bpp
    {0x11A, 0x44, PACKED, 0x2F, 0xff, 0x0E, 16, 1280, 1024, 2560, MAX_DCLK},  // Mode 11A - 1280x1024 16bbp
    {0x130, 0x30, PACKED, 0x1E, 0x00, 0x00,  8,  320,  200,  320, MAX_DCLK},  // Mode 130 - 320x200  8bbp
    {0x131, 0x31, PACKED, 0x1F, 0x02, 0x02,  8,  320,  400,  320, MAX_DCLK},  // Mode 131 - 320x400 8bpp
    {0x132, 0x32, PACKED, 0x27, 0x02, 0x02, 16,  320,  400,  640, MAX_DCLK},  // Mode 132 - 320x400 16bpp
    {0x133, 0x33, PACKED, 0x13, 0x02, 0x02, 32,  320,  400, 1280, MAX_DCLK},  // Mode 133 - 320x400 32bpp
    {0x134, 0x34, PACKED, 0x20, 0x01, 0x01,  8,  320,  240,  320, MAX_DCLK},  // Mode 134 - 320x240 8bpp
    {0x135, 0x35, PACKED, 0x28, 0x01, 0x01, 16,  320,  240,  640, MAX_DCLK},  // Mode 135 - 320x240 16
    {0x136, 0x36, PACKED, 0x14, 0x01, 0x01, 32,  320,  240, 1280, MAX_DCLK},  // Mode 136 - 320x240 32
    {0x137, 0x37, PACKED, 0x21, 0x03, 0x03,  8,  400,  300,  400, MAX_DCLK},  // Mode 137 - 400x300 8
    {0x138, 0x38, PACKED, 0x29, 0x03, 0x03, 16,  400,  300,  800, MAX_DCLK},  // Mode 138 - 400x300 16
    {0x139, 0x39, PACKED, 0x15, 0x03, 0x03, 32,  400,  300, 1600, MAX_DCLK},  // Mode 139 - 400x300 32
    {0x13A, 0x3A, PACKED, 0x23, 0x05, 0x05,  8,  512,  384,  512, MAX_DCLK},  // Mode 13A - 512x384 8
    {0x13B, 0x3B, PACKED, 0x2B, 0x05, 0x05, 16,  512,  384, 1024, MAX_DCLK},  // Mode 13B - 512x384 16
    {0x13C, 0x3C, PACKED, 0x17, 0x05, 0x05, 32,  512,  384, 2048, MAX_DCLK},  // Mode 13C - 512x384 32
    {0x13D, 0x3D, PACKED, 0x2C, 0x06, 0x06, 16,  640,  400, 1280, MAX_DCLK},  // Mode 13D - 640x400 16
    {0x13E, 0x3E, PACKED, 0x18, 0x06, 0x06, 32,  640,  400, 2560, MAX_DCLK},  // Mode 13E - 640x400 32
    {0x141, 0x41, PACKED, 0x25, 0xff, 0x0C,  8, 1152,  864, 1152, MAX_DCLK},  // Mode 141 - 1152x864 8
    {0x142, 0x42, PACKED, 0x2E, 0xff, 0x0C, 16, 1152,  864, 2304, MAX_DCLK},  // Mode 142 - 1152x864 16
    {0x143, 0x43, PACKED, 0x1D, 0xff, 0x0C, 32, 1152,  864, 4608, MAX_DCLK},  // Mode 143 - 1152x864 32
    {0x145, 0x45, PACKED, 0x26, 0xFF, 0x0F,  8, 1600, 1200, 1600, MAX_DCLK},  // Mode 145 - 1600x1200 8
    {0x146, 0x46, PACKED, 0x30, 0xFF, 0x0F, 16, 1600, 1200, 3200, MAX_DCLK},  // Mode 146 - 1600x1200 16
    // more TV modes?
    {0x147, 0x47, PACKED, 0x22, 0x04, 0x04,  8,  480,  360,  480, MAX_DCLK},  // Mode 147 - 480x360 8
    {0x148, 0x48, PACKED, 0x2A, 0x04, 0x04, 16,  480,  360,  960, MAX_DCLK},  // Mode 148 - 480x360 16
    {0x149, 0x49, PACKED, 0x16, 0x04, 0x04, 32,  480,  360, 1920, MAX_DCLK},  // Mode 149 - 480x360 32
    {0x14A, 0x4A, PACKED, 0x24, 0xff, 0x09,  8,  960,  720,  960, MAX_DCLK},  // Mode 14A - 960x720 8
    {0x14B, 0x4B, PACKED, 0x2D, 0xff, 0x09, 16,  960,  720, 1920, MAX_DCLK},  // Mode 14B - 960x720 16
    {0x14C, 0x4C, PACKED, 0x1B, 0xff, 0x09, 32,  960,  720, 3840, MAX_DCLK},  // Mode 14C - 960x720 32
    {0x14D, 0x4D, PACKED, 0x31, 0xff, 0x0E, 32, 1280, 1024, 5120, MAX_DCLK},  // Mode 14D - 1280x1024 32
    {0x14E, 0x4E, PACKED, 0x32, 0xFF, 0x0F, 32, 1600, 1200, 6400, MAX_DCLK},  // Mode 14E - 1600x1200 32

	// JJV - New Modes
    {0x14F, 0x80, PACKED, 0x33, 0xFF, 0x10,  8, 1800, 1440, 1800, MAX_DCLK},    // Mode 14F - 1800x1440 8
    {0x150, 0x81, PACKED, 0x34, 0xFF, 0x11, 16, 1800, 1440, 3600, MAX_DCLK},    // Mode 150 - 1800x1440 16
    {0x151, 0x82, PACKED, 0x35, 0xFF, 0x12,  8, 1920, 1080, 1920, MAX_DCLK},    // Mode 151 - 1920x1080 8
    {0x152, 0x83, PACKED, 0x36, 0xFF, 0x13, 16, 1920, 1080, 3840, MAX_DCLK},    // Mode 152 - 1920x1080 16
    {0x153, 0x84, PACKED, 0x37, 0xFF, 0x14, 32, 1920, 1080, 7680, MAX_DCLK},    // Mode 153 - 1920x1080 32
    {0x154, 0x85, PACKED, 0x38, 0xFF, 0x15,  8, 1920, 1200, 1920, MAX_DCLK},    // Mode 154 - 1920x1200 8
    {0x155, 0x86, PACKED, 0x39, 0xFF, 0x16, 16, 1920, 1200, 3840, MAX_DCLK},    // Mode 155 - 1920x1200 16
    {0x156, 0x87, PACKED, 0x3A, 0xFF, 0x17, 32, 1920, 1200, 7680, MAX_DCLK},    // Mode 156 - 1920x1200 32
    
    {0x157, 0x88, PACKED, 0x3B, 0xFF, 0x18, 32, 1800, 1440, 1800, MAX_DCLK},    // Mode 157 - 1800x1440 32
    {0x158, 0x89, PACKED, 0x3C, 0xFF, 0x19,  8, 2048, 1536, 2048, MAX_DCLK},    // Mode 158 - 2048x1536 8
    {0x159, 0x8A, PACKED, 0x3D, 0xFF, 0x1A, 16, 2048, 1536, 2048, MAX_DCLK},    // Mode 159 - 2048x1536 16
    {0x15A, 0x8B, PACKED, 0x3E, 0xFF, 0x1B, 32, 2048, 1536, 2048, MAX_DCLK},    // Mode 15A - 2048x1536 32
    // JJV - New Modes

    {0xFFFF,0xFF, 0xFF,   0xFF, 0xFF, 0xFF,  0,    0,    0,    0, 0}          // List Terminator
};                                 

//  Table of extended (NV only) CRTC registers
//  The data is in packed format (bits from several regs combined in each byte)
//
//  Array of xrFlags, xrOffset, xrVOver, xrPixFmt, xrVOffset, xrIntlace, xrRegenLength,
//  xrClkSel.  See MODES.H for bit definitions.
//
EXTREGS eregs[] =    // Extended Register Tables
{                                      
    {0x49, 0x00, 0x20, 0x30, 0xFF, 0xFF, 0x0000, CLKID_25_175}, // 00: VGA Modes	  00:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 08: Mode 5F/101	  01:
    {0x48, 0x00, 0x20, 0x30, 0x32, 0xFF, 0xFA00, CLKID_40},     // 09: Mode 58/6A/102 02:
    {0x4C, 0x00, 0x20, 0x39, 0x64, 0xFF, 0xFFFF, CLKID_40},     // 0A: Mode 5C/103	  03:
    {0x48, 0x00, 0x20, 0x30, 0x40, 0xFF, 0xFFFF, CLKID_65},     // 0B: Mode 5D/104	  04:
    {0x4C, 0x00, 0x20, 0x39, 0x80, 0xFF, 0xFFFF, CLKID_65},     // 0C: Mode 5E/105	  05:
    {0x08, 0x00, 0x15, 0x30, 0x50, 0xFF, 0xFFFF, CLKID_108_5},  // 0F: Mode 5A/106	  06:
    {0x0C, 0x00, 0x15, 0x39, 0xA0, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107	  07:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 08:                             
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 09:                             
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0A:                             
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0B:                             
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0C:                             
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 22: Mode 78		  0D:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 23: Mode 6E		  0E:
    {0x44, 0x80, 0x20, 0x3A, 0xC8, 0xFF, 0xFFFF, CLKID_40},     // 24: Mode 6F		  0F:
    {0x54, 0x81, 0x20, 0x3A, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72		  10:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B		  11:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20		  12:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20		  13:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20		  14:
    {0x44, 0x00, 0x20, 0x3B, 0xC8, 0xFF, 0xFFFF, CLKID_20},     // 27: Mode 20		  15:
    {0x44, 0x00, 0x20, 0x3B, 0xF0, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72		  16:
    {0x54, 0x01, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72		  17:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B		  18:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 28: Mode 21		  19:
    {0x54, 0x01, 0x20, 0x3B, 0x90, 0xFF, 0xFFFF, CLKID_40},     // 29: Mode 22		  1A:
    {0x54, 0x01, 0x20, 0x3B, 0xE0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72		  1B:
    {0x64, 0x02, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72		  1C:
    {0x24, 0x02, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72		  1D:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x4000, CLKID_12_588}, // 27: Mode 20		  1E:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x8000, CLKID_12_588}, // 27: Mode 20		  1F:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x5000, CLKID_12_588}, // 27: Mode 20		  20:
    {0x4C, 0x00, 0x20, 0x39, 0x32, 0xFF, 0x8000, CLKID_20},     // 27: Mode 20		  21:
    {0x4C, 0x00, 0x20, 0x39, 0x3C, 0xFF, 0xB000, CLKID_27_93},  // 25: Mode 72		  22:
    {0x4C, 0x00, 0x20, 0x39, 0x40, 0xFF, 0xD000, CLKID_32_5},   // 25: Mode 72		  23:
    {0x4C, 0x00, 0x20, 0x39, 0x78, 0xFF, 0xFFFF, CLKID_55_86},  // 0C: Mode 5E/105	  24:
    {0x0C, 0x00, 0x20, 0x39, 0x90, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72		  25:
    {0x0C, 0x00, 0x0F, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72		  26:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20		  27:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xA000, CLKID_12_588}, // 27: Mode 20		  28:
    {0x44, 0x80, 0x20, 0x3A, 0x64, 0xFF, 0xF000, CLKID_20},     // 27: Mode 20		  29:
    {0x44, 0x80, 0x20, 0x3A, 0x78, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72		  2A:
    {0x44, 0x80, 0x20, 0x3A, 0x80, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72		  2B:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B		  2C:
    {0x44, 0x80, 0x20, 0x3A, 0xF0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72		  2D:
    {0x14, 0x81, 0x20, 0x3A, 0x20, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72		  2E:
    {0x14, 0x81, 0x15, 0x3A, 0x40, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107	  2F:
    {0x14, 0x81, 0x0F, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72		  30:
    {0x24, 0x02, 0x15, 0x3B, 0x80, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107	  31:
    {0x24, 0x03, 0x0F, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72		  32:
																					  
	// JJV - New Modes (I think this starts at 0x33 ??)								  
    {0x0C, 0x40, 0x0F, 0x79, 0xE1, 0xFF, 0xFFFF, CLKID_219_566}, // 33: 1800X1440X8	  
    {0x0C, 0x41, 0x0F, 0x7A, 0xC2, 0xFF, 0xFFFF, CLKID_219_566}, // 34: 1800X1440X16	  
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_172_798}, // 35: 1920X1080X8	  
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_172_798}, // 36: 1920X1080X16	  
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_172_798}, // 37: 1920X1080X32	  
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_193_156}, // 38: 1920X1200X8	  
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_193_156}, // 39: 1920X1200X16	  
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_193_156}, // 3A: 1920X1200X32	  
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_219_566}, // 3B: 1800x1440x32
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_266_95},  // 3C: 2048x1536x8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_266_95},  // 3D: 2048x1536x16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_266_95}   // 3E: 2048x1536x32
	// JJV - New Modes																  
																					  
};                                             										  

//  Table of Std CRTC settings for all modes.
//
//  Array of override values for the following registers:
//  cols, rows, height, misc, SR1, CR00, CR01, CR02, CR03, CR04, CR05, CR06
//  CR07, CR09, CR10, CR11, CR12, CR15, CR16.
//
//  See MODES.H for bit definitions.
//
CRTC_OVERRIDE crt_override[] =       // Mode overide table for CRTC
{
    // 0. Mode 20h, 78h / VESA Mode 10Eh, 10Fh
    //    320x200 16-bit/32-bit color graphics
    { 0x28, 0x18, 0x08, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0xC0, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },
      
    // 1. Mode 34h,35h,36h / VESA Mode 134h,135h,136h
    //       320x240 16-bit Color Graphics (8x8 font, 40x30 "Text")
    { 0x28, 0x1D, 0x08, 0xE3, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0x0B, 0x3E, 0xC0, 0xEA, 0x0C, 0xDF, 0xDF, 0x0C },    
                                                      
    // 2. Mode 31h,32h,33h / VESA Mode 131h,132h,133h
    //    320x400 16-bit Color Graphics (8x16 font, 40x25 "Text")
    { 0x28, 0x18, 0x10, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },
      
    // 3. Mode 37h,38h,39h / VESA Mode 137h,138h,139h
    //       400x300 16-bit Color Graphics (8x8 font, 50x37 "Text")
    { 0x32, 0x24, 0x08, 0x2B, 0x01, 0x3D, 0x31, 0x31, 0x81, 0x35, 0x1D,
      0x72, 0xF0, 0xE0, 0x59, 0x0D, 0x57, 0x57, 0x73 },
                                                    
    // 4. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       480x360 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x3C, 0x2C, 0x08, 0xEB, 0x01, 0x49, 0x3B, 0x3B, 0x8D, 0x40, 0x08,
      0xE8, 0xF0, 0xE0, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },
                                                    
    // 5. Mode 3Ah,3Bh,3Ch / VESA Mode 13Ah,13Bh,13Ch
    //       512x384 16-bit Color Graphics (8x8 font, 64x48 "Text")
    { 0x40, 0x2F, 0x08, 0xEB, 0x01, 0x4F, 0x3F, 0x3F, 0x93, 0x43, 0x0B,
      0x24, 0xF5, 0xE0, 0x03, 0x09, 0xFF, 0xFF, 0x25 },
                                                    
    // 6. Mode 5Bh / VESA Mode 100h / Internal Mode 26h
    //       640x400 8-bit Color Graphics (8x16 font, 80x25 "Text")
    { 0x50, 0x18, 0x10, 0x63, 0x01, 0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },
                                                    
    // 7. Internal Mode 9
    // Mode 58 / VESA Mode 6A / VESA Mode 102 800x600x4
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6B, 0x1B,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },
                                                    
    // 8. Mode 6F / VESA Mode 114h / Internal Mode 24h
    //       800x600 16-bit Color Graphics (8x16 font, 100x37 "Text")
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6A, 0x1A,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },
                                                    
    // 9. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       960x720 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x78, 0x2C, 0x10, 0xEB, 0x01, 0x97, 0x77, 0x77, 0x9B, 0x7F, 0x0B,
      0xE8, 0xF0, 0x60, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },
                                                    
    // A. Mode B
    // Mode 5D / VESA Mode 104 1024x768x4
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x85, 0x96,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },
                                                    
    // B. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       1024x768 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x84, 0x95,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },
                                                    
    // C. Mode 41h/42h/43h / VESA Mode 141,142,143
    // 1152x864x16
    { 0x90, 0x35, 0x10, 0x2B, 0x01, 0xB9, 0x8F, 0x8F, 0x9D, 0x9A, 0x89,
      0x7D, 0xFF, 0x60, 0x61, 0x04, 0x5F, 0x5F, 0x7E },
                                                    
    // D. Internal Mode F
    // Mode 5A / VESA Mode 106 1280x1024x4
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xAA, 0x1A,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },
                                                    
    // E. Internal Mode 10
    // Mode 6B / VESA Mode 107 1280x1024x8
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xA9, 0x19,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },
                                                    
    // F. Mode 45h/46h / VESA Mode 145,146
    // 1600x1200x16
    { 0xC8, 0x4A, 0x10, 0x2B, 0x01, 0x03, 0xC7, 0xC7, 0x87, 0xD1, 0x09,
      0xE0, 0x10, 0x40, 0xB1, 0x04, 0xAF, 0xAF, 0xE1 },
         
    // JJV - Start                                                
    // 10. Mode ?
    // 1880x1440x8
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },
                                                    
    // 11. Mode ?
    // 1880x1440x16
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },
                                                    
    // 12. Mode ?
    // 1920x1080x8
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },
                                                    
    // 13. Mode ?
    // 1920x1080x16
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },
                                                    
    // 14. Mode ?
    // 1920x1080x32
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },
                                                    
    // 15. Mode ?
    // 1920x1200x8
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
                                                    
    // 16. Mode ?
    // 1920x1200x16
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 17. Mode ?
    // 1920x1200x32
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 18. Mode ?
    // 1800x1440x32
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 19. Mode ?
    // 2048x1536x8
    { 0xFF, 0x5F, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 1A. Mode ?
    // 2048x1536x16
    { 0xFF, 0x5F, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 1B. Mode ?
    // 2048x1536x32
    { 0xFF, 0x5F, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 }
      
    // JJV - End
                                                    
};


//
// Fifo/Watermark settings (100MHz/100MHz operation)
//
//    Freq;                   // Maximum frequency for these water marks
//    LowWaterMark64;         // Low water mark for 64 bit bus
//    BurstSize64;            // Burst size for 64 bit bus
//    LowWaterMark128;        // Low water mark for 128 bit bus
//    BurstSize128;           // Burst size for 128 bit bus
MODESET_FIFO DACFifoTable[] =
{
    { 440, 0x20, 0x03, 0x20, 0x04 },
    { 460, 0x21, 0x03, 0x21, 0x04 },
    { 480, 0x23, 0x03, 0x23, 0x04 },
    { 500, 0x26, 0x03, 0x26, 0x04 },
    { 520, 0x27, 0x03, 0x27, 0x04 },
    { 540, 0x27, 0x03, 0x27, 0x04 },
    { 560, 0x29, 0x03, 0x29, 0x04 },
    { 580, 0x2b, 0x03, 0x2b, 0x04 },
    { 600, 0x2e, 0x03, 0x2e, 0x04 },
    { 620, 0x31, 0x03, 0x31, 0x04 },
    { 640, 0x32, 0x02, 0x32, 0x04 },
    { 660, 0x32, 0x02, 0x32, 0x04 },
    { 680, 0x33, 0x02, 0x33, 0x04 },
    { 700, 0x34, 0x02, 0x34, 0x04 },
    { 720, 0x36, 0x02, 0x36, 0x04 },
    { 740, 0x3a, 0x01, 0x3a, 0x04 },
    {0xFFFF, 0x3f, 0x01, 0x3f, 0x04 }       // max marker
};                                  

//
// Mode clock frequencies
//
U016 tblClockFreq[] =
{
    5035,       // 00: 50.350
    5664,       // 01: 56.644
    3325,       // 02: 33.250
    5200,       // 03: 52.000
    8000,       // 04: 80.000
    6300,       // 05: 63.000
    0000,       // 06: Ext
    7500,       // 07: 75.000 (1024x768@70)
    2518,       // 08: 25.175 (VGA)
    2832,       // 09: 28.322 (VGA)
    3150,       // 0A: 31.500 (640x480@72)
    3600,       // 0B: 36.000 (800x600@56)
    4000,       // 0C: 40.000 (800x600@60)
    4490,       // 0D: 44.900 (1024x768@87i)
    5000,       // 0E: 50.000 (800x600@72)
    6500,       // 0F: 65.000 (1024x768@60)
    10800,      // 10: 108.000/2 (1280x1024@60) use clock doubler
    13500,      // 11: 135.000/2 (1280x1024@75) use clock doubler
    4950,       // 12: 49.500
    5625,       // 13: 56.250
    7875,       // 14: 78.750
    9450,       // 15: 94.500
    10850,      // 16: 108.500/2 use clock doubler
    3550,       // 17: 35.500
    15800,      // 18: 158.000/2 use clock doubler
    5586,       // 19: 55.860
    2000,       // 1A: 20.000
    2793,       // 1B: 27.930
    3250,       // 1C: 32.500
    1259,       // 1D: 12.588 (VGA/2)
    8162,       // 1E: 81.624
    21957,		// 1F: 219.566
    17280,		// 20: 172.798
    19316,		// 21: 193.156
    22950,      // 22: 229.50 (for max dot clock)
    26695       // 23: 266.95
};

//
//  TV  register adjustments
//

//
//  NV4 TV CRTC adjustments for Chrontel
//
CH_ADJ CRTC_CH_NTSC[] =
{
//  SR01   CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR25  CR28
    {0x09, 0x2b, 0x2a, 0x0c, 0x3e, 0x60, 0xc0, 0x8f, 0x00, 0x98},     // Mode 0 - 320x200
    {0x09, 0x2b, 0x2b, 0x3c, 0x3e, 0x60, 0xe4, 0xdf, 0x00, 0x88},     // Mode 1 - 320x240
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},     // Mode 2 - 320x400
    {0x09, 0x3d, 0x3d, 0x72, 0xf0, 0x00, 0x59, 0x57, 0x00, 0x80},     // Mode 3 - 400x300
    {0x01, 0x49, 0x40, 0x20, 0xB3, 0x00, 0x90, 0x67, 0x00, 0x80},     // Mode 4 - 480x360
//    {0x01, 0x4f, 0x43, 0x24, 0xf5, 0xff, 0xff, 0x00, 0x80},     // Mode 5 - 512x384
    {0x01, 0x58, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x7f, 0x00, 0x80},     // Mode 5 - use 640x400 and adjust 9 and 12
    {0x01, 0x58, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x8f, 0x00, 0x80},     // Mode 6 - 640x400
    {0x01, 0x58, 0x57, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x00, 0x80},     // Mode 7 - 640x480
    {0x01, 0x75, 0x6f, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x00, 0x80},     // Mode 8 - 800x600
};
//
CH_ADJ  CRTC_CH_PAL[] =
{
//  SR01   CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR25  CR28
    {0x09, 0x2c, 0x28, 0x0c, 0x3e, 0x60, 0xc0, 0x8f, 0x00, 0x98},     // Mode 0 - 320x200
    {0x09, 0x2c, 0x28, 0x3c, 0x3e, 0x60, 0xe4, 0xdf, 0x00, 0x88},     // Mode 1 - 320x240
    {0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff},     // Mode 2 - 320x400
    {0x09, 0x3d, 0x3d, 0xb0, 0xf0, 0x00, 0x57, 0x57, 0x00, 0x80},     // Mode 3 - 400x300
    {0x01, 0x49, 0x40, 0xf0, 0xB2, 0x00, 0x90, 0x67, 0x00, 0x80},     // Mode 4 - 480x360
//    {0x01, 0x4f, 0x43, 0x0b, 0xf5, 0xff, 0xff, 0x00, 0x80},     // Mode 5 - 512x384
    {0x01, 0x58, 0x57, 0x0e, 0x3e, 0x60, 0xc0, 0x7f, 0x00, 0x80},     // Mode 5 - 640x400, adjust 9 and 12
    {0x01, 0x58, 0x55, 0x0C, 0x3e, 0x00, 0xc0, 0x8f, 0x00, 0x80},     // Mode 6 - 640x400
    {0x01, 0x58, 0x55, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x00, 0x80},     // Mode 7 - 640x480
    {0x01, 0x75, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x00, 0x80},     // Mode 8 - 800x600
};
    
//
//  CRTC adjustments for Brooktree 
//
BT_ADJ    CRTC_BT[] =
{   
//   SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12
    {0x09, 0x2b, 0x26, 0x0c, 0x3e, 0x60, 0xc0, 0x8f},       // Mode 0 - 320x200
    {0x09, 0x2b, 0x26, 0x3c, 0x3e, 0x60, 0xe4, 0xdf},       // Mode 1 - 320x240
    {0x09, 0x2c, 0x29, 0x3c, 0x3e, 0x00, 0xe4, 0xdf},       // Mode 2 - 320x400
    {0x09, 0x3d, 0x3d, 0xb0, 0xf0, 0x00, 0x59, 0x57},       // Mode 3 - 400x300
    {0x01, 0x49, 0x40, 0xe4, 0xB2, 0x00, 0x90, 0x67},       // Mode 4 - 480x360
//    {0x01, 0x4f, 0x43, 0x24, 0xf5, 0x03, 0x7f},       // Mode 5 - 512x384 -- USE WHEN WE HAVE CORRECT 512X384 ENCODER VALUES
    {0x01, 0x57, 0x50, 0x0c, 0x3e, 0x00, 0xc0, 0x7f},       // Mode 5 - 640x400   -- USE 640X400 BECAUSE THE ENCODER IS PROGRAMMED
                                                      // FOR THIS MODE. THEN SET CR09 AND CR12 (CR12 IS ADJUSTED HERE)
    {0x01, 0x57, 0x50, 0x0c, 0x3e, 0x00, 0xc0, 0x8f},       // Mode 6 - 640x400
    {0x01, 0x5c, 0x53, 0x0b, 0x3e, 0x00, 0xbf, 0xdf},       // Mode 7 - 640x480
    {0x01, 0x72, 0x72, 0xb0, 0xf0, 0x00, 0x5b, 0x57},       // Mode 8 - 800x600
};    
BT_ADJ    CRTC_BT_PAL[] =
{   
//   SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12
    {0x09, 0x2d, 0x29, 0x0c, 0x3e, 0x60, 0xc0, 0x8f},       // Mode 0 - 320x200
    {0x09, 0x2d, 0x29, 0x3c, 0x3e, 0x60, 0xe4, 0xdf},       // Mode 1 - 320x240
    {0x09, 0x2c, 0x29, 0x3c, 0x3e, 0x00, 0xe4, 0xdf},       // Mode 2 - 320x400
    {0x09, 0x35, 0x35, 0xb4, 0xf0, 0x00, 0x59, 0x57},       // Mode 3 - 400x300
    {0x01, 0x49, 0x40, 0xe4, 0xB2, 0x00, 0x90, 0x67},       // Mode 4 - 480x360
//    {0x01, 0x4f, 0x43, 0x24, 0xf5, 0x03, 0x7f},       // Mode 5 - 512x384 -- USE WHEN WE HAVE CORRECT 512X384 ENCODER VALUES  
    {0x01, 0x57, 0x50, 0x0c, 0x3e, 0x00, 0xc0, 0x7f},       // Mode 5 - 640x400   -- USE 640X400 BECAUSE THE ENCODER IS PROGRAMMED
                                                      // FOR THIS MODE. THEN SET CR09 AND CR12 (CR12 IS ADJUSTED HERE)
    {0x01, 0x57, 0x50, 0x0c, 0x3e, 0x00, 0xc0, 0x8f},       // Mode 6 - 640x400
    {0x01, 0x57, 0x50, 0x3c, 0x3e, 0x00, 0xea, 0xdf},       // Mode 7 - 640x480
    {0x01, 0x76, 0x70, 0xb7, 0xf0, 0x00, 0x59, 0x57},       // Mode 8 - 800x600
};    

//
//  I2C tables
//

BT_string  BT_NULL_STRING =
{   0xff    };
I2C_string  NULL_STRING =
{   0xff    };

//
// Brooktree strings
//

//  Init string
U008    BT_Init[] = { 0x8A, 0xC4, 0x01, 0x98, 0x18, 0xC0, 0xC0, 0x18, 0xff };

//  First byte is device ID, followed by 3 bytes of centering data, followed by 00 01, followed by 33 bytes of 
//  resolution data, terminated by ff (not sent).
//  line/pixel doubled modes use the double resolution (e.g. 320x200 = 640x400)
//  NTSC
BT_string BT_NTSC320X200 =    
{   0X8A, 0x6e, 0x1f, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
BT_string BT_NTSC320X240 =
{   0X8A, 0x6e, 0x8f, 0xc2,
    0x00, 0x01,
    0X20, 0X90, 0X86, 0X98, 0X64, 0X7F, 0X24, 0XD0, 0X27, 0X00, 0XF8, 0X5A, 0X02, 0X76, 0X53, 0XF0, 
    0X36, 0X66, 0X56, 0X58, 0XC1, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XFC, 0X08, 0XEE, 0X1F, 0X00, 
    0XFF
};
BT_string BT_NTSC320X400 =    
{   0X8A, 0x6e, 0x1f, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
//  400x300 = 800x600
BT_string BT_NTSC400X300 =
{   0X8A, 0x6e, 0x8f, 0xc2,
    0x00, 0x01,
    0xA0, 0x20, 0xB6, 0xCE, 0xB4, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x44, 0x03, 0xDF, 0x56, 0x58,
    0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA, 0xE8, 0xA2, 0x17, 0x00,
    0XFF
};
//  these are 640x400 values--use until we get real 480x360 values
BT_string BT_NTSC480X360 =
{   0X8A, 0x6e, 0x86, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
//  these are 640x400 values--use until we get real 512x384 values
BT_string BT_NTSC512X384 =
{   0X8A, 0x6e, 0x86, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
BT_string BT_NTSC640X400 =
{   0X8A, 0x6e, 0x50, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
#if 1
/* new initialization values based on code from brooktree (jsun) */
BT_string BT_NTSC640X480 =
{   0X8A, 0x6e, 0xd4, 0xc2,
    0x00, 0x01,
/*  76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94 */
    0X00, 0X80, 0X84, 0X96, 0X60, 0X7D, 0X22, 0XD4, 0X27, 0X00, 0X10, 0X7E, 0X03, 0X58, 0X4B, 0XE0, 
/*  96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE    B0    B2    B4    B6 */
    0X36, 0X92, 0X54, 0X0E, 0X88, 0X0C, 0X0A, 0XE5, 0X76, 0X79, 0X44, 0X85, 0X00, 0X00, 0X80, 0X20, 0X00, 
    0XFF
};
#else
BT_string BT_NTSC640X480 =
{   0X8A, 0x6e, 0xd4, 0xc2,
    0x00, 0x01,
    0X20, 0X90, 0X86, 0X98, 0X64, 0X7F, 0X24, 0XD0, 0X27, 0X00, 0XF8, 0X5A, 0X02, 0X76, 0X53, 0XF0, 
    0X36, 0X66, 0X56, 0X58, 0XC1, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XFC, 0X08, 0XEE, 0X1F, 0X00, 
    0XFF
};
#endif
#if 1
/* new initialization values based on code from brooktree (jsun) */
BT_string BT_NTSC800X600 =
{   0X8A, 0x6e, 0xe2, 0xc2,
    0x00, 0x01,
/*  76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94 */
    0xA0, 0x20, 0xB6, 0xCE, 0xB4, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF, 0x56, 0x58,
/*  96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE    B0    B2    B4    B6 */
    0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA, 0xE8, 0xA2, 0x17, 0x00,
    0XFF
};
#else
BT_string BT_NTSC800X600 =
{   0X8A, 0x6e, 0xe2, 0xc2,
    0x00, 0x01,
    0xA0, 0x20, 0xB6, 0xCE, 0xB4, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x44, 0x03, 0xDF, 0x56, 0x58,
    0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA, 0xE8, 0xA2, 0x17, 0x00,
    0XFF
};
#endif

//  PAL 
BT_string BT_PAL320X200 =    
{   0X8A, 0x6e, 0x24, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
BT_string BT_PAL320X240 =
{   0X8A, 0x6e, 0x54, 0x02,
    0x00, 0x01,
    0x90, 0x90, 0x8e, 0xaa, 0x6e, 0xcd, 0x2a, 0xfa, 0x27, 0x00, 0xc8, 0x11, 0x0b, 0x71, 0x52, 0xf0,
    0x36, 0x00, 0x50, 0xc7, 0x71, 0x0d, 0x24, 0xf0, 0x58, 0x81, 0x49, 0x8c, 0xea, 0x57, 0x85, 0x25, 0x00,
    0XFF
};
BT_string BT_PAL320X400 =    
{   0X8A, 0x6e, 0x24, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
//  400x300 = 800x600
BT_string BT_PAL400X300 =
{   0X8A, 0x6e, 0x00, 0x02,
    0x00, 0x01,
    0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 0x5F, 0x58, 
    0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18, 0x28, 0x87, 0x1F, 0x00,
    0XFF
};
//  using 640x400 for now
BT_string BT_PAL480X360 =
{   0X8A, 0x6e, 0x7c, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
//  using 640x400 for now
BT_string BT_PAL512X384 =
{   0X8A, 0x6e, 0x7c, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
BT_string BT_PAL640X400 =
{   0X8A, 0x6e, 0x40, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
#if 0   // seem to be invalid -- TV doesn't recognize this as PAL
/* new initialization values based on code from brooktree (jsun) */
BT_string BT_PAL640X480 =
{   0X8A, 0x6e, 0x80, 0x02,
    0x00, 0x01,
/*  76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94 */
    0x60, 0x80, 0x8A, 0xA6, 0x68, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 0x5A, 0xE0,
/*  96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE    B0    B2    B4    B6 */
    0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x04, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C, 0x8C, 0x79, 0x26, 0x00,
    0XFF
};
#else
BT_string BT_PAL640X480 =
{   0X8A, 0x6e, 0x80, 0x02,
    0x00, 0x01,
    0x90, 0x90, 0x8e, 0xaa, 0x6e, 0xcd, 0x2a, 0xfa, 0x27, 0x00, 0xc8, 0x11, 0x0b, 0x71, 0x52, 0xf0,
    0x36, 0x00, 0x50, 0xc7, 0x71, 0x0d, 0x24, 0xf0, 0x58, 0x81, 0x49, 0x8c, 0xea, 0x57, 0x85, 0x25, 0x00,
    0XFF
};
#endif
#if 0   // seem to be invalid -- TV doesn't recognize this as PAL
/* new initialization values based on code from brooktree (jsun) */
BT_string BT_PAL800X600 =
{   0X8A, 0x6e, 0xfa, 0xc1,
    0x00, 0x01,
/*  76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94 */
    0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 0x5F, 0x58, 
/*  96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE    B0    B2    B4    B6 */
    0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x04, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18, 0x28, 0x87, 0x1F, 0x00,
    0XFF
};
#else
BT_string BT_PAL800X600 =
{   0X8A, 0x6e, 0xfa, 0xc1,
    0x00, 0x01,
    0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 0x5F, 0x58, 
    0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18, 0x28, 0x87, 0x1F, 0x00,
    0XFF
};
#endif


// Brooktree I2C tables for TV modes 0..8
BT_string *BT_NTSC[] = {&BT_NTSC320X200, &BT_NTSC320X240, &BT_NTSC320X400, &BT_NTSC400X300, &BT_NTSC480X360, 
    &BT_NTSC512X384, &BT_NTSC640X400, &BT_NTSC640X480, &BT_NTSC800X600};

BT_string *BT_PAL[]  = {&BT_PAL320X200, &BT_PAL320X240, &BT_PAL320X400, &BT_PAL400X300, &BT_PAL480X360, 
    &BT_PAL512X384, &BT_PAL640X400, &BT_PAL640X480, &BT_PAL800X600};

//
//  Chrontel strings
//

//  The I2C init string
U008    I2C_Init[] = { 0xea, 0x04, 0x05, 0x06, 0x40, 0x0d, 0x07, 0xff };

//  The I2C disable string
U008    I2C_Disable[] = { 0xea, 0x0d, 0x03, 0x0e, 0x09, 0xff };

//
// Chrontel I2C timing tables. All resolutions are multiples of these modes.
// Reg A is horizontal position; Reg B is vertical position
// DEVICE REG 0       REG 7       REG A       REG B       REG13, AUTOINC TO REG 15
I2C_string  NTSC320X200 =
{   0xea, 0x00, 0x49, 0x07, 0x70, 0x0a, 0x30, 0x0b, 0x00, 0x53, 0x00, 0x0b, 0x16, 0xff };  // NTSC 320x200 (640x400)
I2C_string  NTSC320X240 =
{   0xea, 0x00, 0x6a, 0x07, 0x5c, 0x0a, 0x28, 0x0b, 0x04, 0x53, 0x00, 0x3f, 0x7e, 0xff };  // NTSC 320x240 (640x480)
I2C_string NTSC400X300 =
{   0xea, 0x00, 0x8D, 0x07, 0x8c, 0x0a, 0x34, 0x0b, 0xe8, 0x53, 0x02, 0x59, 0x2E, 0xff };  // NTSC 400x300 (800x600)
I2C_string  NTSC480X360 =
{   0xea, 0x00, 0x49, 0x07, 0x70, 0x0a, 0x34, 0x0b, 0x16, 0x53, 0x00, 0x0b, 0x16, 0xff };  // NTSC 480x360 (640x400) 
I2C_string  NTSC512X384 = 
//{   0xea, 0x00, 0x09, 0x07, 0xd4, 0x0a, 0x0a, 0x0b, 0x00, 0x53, 0x00, 0x63, 0x16, 0xff };  // NTSC 512x384
{   0xea, 0x00, 0x49, 0x07, 0x70, 0x0a, 0x48, 0x0b, 0x10, 0x53, 0x00, 0x0b, 0x16, 0xff };  // use NTSC 640x400 
I2C_string  NTSC640X400 =
{   0xea, 0x00, 0x49, 0x07, 0x70, 0x0a, 0x34, 0x0b, 0x10, 0x53, 0x00, 0x0b, 0x16, 0xff };  // NTSC 640x400 
I2C_string  NTSC640X480 = 
{   0xea, 0x00, 0x6A, 0x07, 0x5c, 0x0a, 0x2a, 0x0b, 0x00, 0x53, 0x00, 0x3F, 0x7E, 0xff };  // NTSC 640x480
I2C_string  NTSC800X600 = 
{   0xea, 0x00, 0x8D, 0x07, 0x8c, 0x0a, 0x3c, 0x0b, 0x00, 0x53, 0x02, 0x59, 0x2E, 0xff };  // NTSC 800x600

// PAL values 
I2C_string  PAL320X200 =
{   0xea, 0x00, 0x40, 0x07, 0xc8, 0x0a, 0x34, 0x0b, 0x08, 0x53, 0x00, 0x3d, 0x6c, 0xff };  // PAL 320x200 (640x400)
I2C_string  PAL320X240 =
{   0xea, 0x00, 0x61, 0x07, 0xc0, 0x0a, 0x38, 0x0b, 0x00, 0x53, 0x00, 0x04, 0x09, 0xff };  // PAL 320x240 (640x480)
I2C_string  PAL400X300 = 
{   0xea, 0x00, 0x83, 0x07, 0xc0, 0x0a, 0x40, 0x0b, 0x00, 0x53, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 (800x600)
I2C_string  PAL480X360 = 
{   0xea, 0x00, 0x40, 0x07, 0x5c, 0x0a, 0x30, 0x0b, 0x10, 0x53, 0x00, 0x3d, 0x6c, 0xff };  // PAL  480x360 (640x400)
I2C_string  PAL512X384 = 
{   0xea, 0x00, 0x40, 0x07, 0x5c, 0x0a, 0x30, 0x0b, 0x10, 0x53, 0x00, 0x3d, 0x6c, 0xff };  // PAL  512x384 (640x400)
I2C_string  PAL640X400 = 
{   0xea, 0x00, 0x40, 0x07, 0x5c, 0x0a, 0x2e, 0x0b, 0x10, 0x53, 0x00, 0x3d, 0x6c, 0xff };  // PAL  640x400 100
I2C_string  PAL640X480 = 
{   0xea, 0x00, 0x61, 0x07, 0x70, 0x0a, 0x38, 0x0b, 0x00, 0x53, 0x00, 0x04, 0x09, 0xff };  // PAL  640x480 101
I2C_string  PAL800X600 = 
{   0xea, 0x00, 0x83, 0x07, 0xc0, 0x0a, 0x40, 0x0b, 0x00, 0x53, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 103

// Chrontel I2C strings for TV modes 0..8 (no mode 2)
I2C_string *i2c_NTSC[] = {&NTSC320X200, &NTSC320X240, &NULL_STRING, &NTSC400X300, &NTSC480X360, &NTSC512X384, 
    &NTSC640X400, &NTSC640X480, &NTSC800X600};
I2C_string *i2c_PAL[]  = {&PAL320X200, &PAL320X240, &NULL_STRING, &PAL400X300, &PAL480X360, &PAL512X384, 
    &PAL640X400, &PAL640X480, &PAL800X600};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\MODES.H ===
//
// MODES.H - Header file for mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines and structures for use with the 'C' based modeset code.
//                
//

//  TVformat types
#define NTSC    0
#define PAL     1
//  TV encoders
#define NO_ENCODER 0
#define BROOKTREE  1
#define CHRONTEL   2
#define BROOKTREE_ID    0x8A
#define CHRONTEL_ID     0xEA

#ifdef DOS_COMPILE
typedef unsigned long U032;
typedef unsigned short U016;
typedef unsigned char U008;
typedef unsigned long V032;
typedef unsigned short V016;
typedef unsigned char V008;
#define VOID void
#endif


#define PACKED  0
#define PLANAR  1

#define NVRM_ACCESS         0x38
#define NVRM_ACCESS_MASK    0x01
#define NVRM_IDENT          0x00
#define NVRM_ADDRESS        0x02
#define NVRM_DATA           0x04
#define NVRM_DATA32         0x06
#define NVRM_SELECT_MASK    0x06    // Mask for decode bits
#define NVRM_SELECT         0x01    // Least signifcant bit is 1

#ifdef DOS_COMPILE
//                                           
// These defines are the standard NV defines... the appropriate include
// file should be utilized, rather than these values.
//
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define NV_PDFB_DATA032                    0x01000000 /* RW-4A */
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB       0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB       0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB       0x00000002 /* RW--V */
#define NV_PRMVIO_MISC__WRITE              0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                      0x000C03c4 /* RW-1R */
#define NV_PRMVIO_GRX                      0x000C03ce /* RW-1R */
#define NV_PFB_BOOT_0                      0x00100000 /* RW-4R */
#define NV_PFB_CONFIG_0                    0x00100200 /* RW-4R */
#define NV_PRMCIO_ARX                      0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ         0x006013c1 /* R--1R */
#define NV_PRMCIO_CRX__COLOR               0x006013d4 /* RW-1R */
#define NV_PRMCIO_INP0__COLOR              0x006013da /* R--1R */
#define NV_PRAMDAC_VPLL_COEFF              0x00680508 /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT        0x0068050C /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL         0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX        5:4  /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE     8:8  /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE     12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC          20:20 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK             0x006813C6 /* RWI1R */
#define NV_USER_DAC_READ_MODE_ADDRESS      0x006813C7 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS     0x006813C8 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA           0x006813C9 /* RW-1R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE 16:16 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING                  12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DISABLED    0x00000001 /* RWI-V */

#define NV_PRAMDAC_VPLL_COEFF              0x00680508 /* RW-4R */
#define NV_PRMVIO_MISC__READ               0x000C03CC 
#define NV_PRMVIO_SR_CLOCK_INDEX           0x000C03C5
#define NV_CIO_CRE_ILACE__INDEX            0x039
#define NV_CIO_CR_VRE_INDEX                0x011
#define NV_CIO_CRE_PIXEL_INDEX             0x028
#define NV_CIO_CRE_DEC__INDEX              0x029
#define NV_CIO_CR_HDT_INDEX                0x0
#define NV_CIO_CR_HDE_INDEX                0x1
#define NV_CIO_CR_HBS_INDEX                0x2
#define NV_CIO_CR_HBE_INDEX                0x3
#define NV_CIO_CR_HRS_INDEX                0x4
#define NV_CIO_CR_HRE_INDEX                0x5
#define NV_CIO_CR_VDT_INDEX                0x6
#define NV_CIO_CR_OVL_INDEX                0x7
#define NV_CIO_CR_VRS_INDEX                0x10
#define NV_CIO_CR_VDE_INDEX                0x12
#define NV_CIO_CR_VBS_INDEX                0x15
#define NV_CIO_CR_VBE_INDEX                0x16
#define NV_PRAMDAC_HSYNC_WIDTH             0x00680720 /* RW-4R */
#define NV_PRAMDAC_HBURST_START            0x00680724 /* RW-4R */
#define NV_PRAMDAC_HBLANK_START            0x0068072C /* RW-4R */
#define NV_PRAMDAC_HTOTAL                  0x00680734 /* RW-4R */
#define NV_PRAMDAC_HEQU_WIDTH              0x00680738 /* RW-4R */
#define NV_PRAMDAC_HSERR_WIDTH             0x0068073C /* RW-4R */
#define NV_PMC_ENABLE                      0x00000200 /* RW-4R */
#define NV_PEXTDEV_BOOT_0                  0x00101000 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF              0x00680504 /* RW-4R */
#define NV_USER_DAC_PIXEL_MASK             0x006813C6 /* RWI1R */
#define NV_USER_DAC_READ_MODE_ADDRESS      0x006813C7 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS     0x006813C8 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA           0x006813C9 /* RW-1R */
#endif // DOS_COMPILE

                                                   
#define CRYSTAL_FREQ143         14318180           // 14.318,180 MHz
#define CRYSTAL_FREQ135         13500000           // 13.500,180 MHz
#define CRYSTAL_FREQ143KHZ      14318              // 14318 kHz
#define CRYSTAL_FREQ135KHZ      13500              // 13500 kHz

//
// VBE3.0-based CRTC Timings Table
//
typedef struct gtf_timings_structure
{
    U016	horiz_total;
	U016	horiz_start;
	U016	horiz_end;
	U016	vertical_total;
	U016	vertical_start;
	U016	vertical_end;
	U008	flags;
	U032	dot_clock;
	U016	refresh;
} GTF_TIMINGS, *PGTF_TIMINGS;

//
// DMT Override Table
//
typedef struct DMT_Overrides_structure
{
    U016    DotClock;
    U016    Polarity;
    U016    CR0;
    U016    CR2;
    U016    CR3;
    U016    CR4;
    U016    CR5;
    U016    CR6;
    U016    CR7;
    U016    CR10;
    U016    CR11;
    U016    CR15;
    U016    CR16;

} DMT_OVERRIDES, *PDMT_OVERRIDES;

//
// State flags for GTF structure
//
#define GTF_FLAGS_SINGLE_SCANNED    0x00
#define GTF_FLAGS_DOUBLE_SCANNED    0x01
#define GTF_FLAGS_NON_INTERLACED    0x00
#define GTF_FLAGS_INTERLACED        0x02
#define GTF_FLAGS_HSYNC_POSITIVE    0x00
#define GTF_FLAGS_HSYNC_NEGATIVE    0x04 
#define GTF_FLAGS_VSYNC_POSITIVE    0x00
#define GTF_FLAGS_VSYNC_NEGATIVE    0x08

// Indexes into the clock table 
#define MAX_DCLK    0x1F            // 229.50 Mhz
#define MAX_ATC     0x16            // 108 Mhz
                                   
#define    CLKID_50_35     0x00
#define    CLKID_56_64     0x01
#define    CLKID_33_25     0x02
#define    CLKID_52        0x03
#define    CLKID_80        0x04
#define    CLKID_63        0x05
#define    CLKID_EXT       0x06
#define    CLKID_75        0x07
#define    CLKID_25_175    0x08
#define    CLKID_28_322    0x09
#define    CLKID_31_5      0x0A
#define    CLKID_36        0x0B
#define    CLKID_40        0x0C
#define    CLKID_44_9      0x0D
#define    CLKID_50        0x0E
#define    CLKID_65        0x0F
#define    CLKID_108       0x10        // Requires clock doubler
#define    CLKID_135       0x11        // Requires clock doubler
#define    CLKID_49_5      0x12            
#define    CLKID_56_25     0x13
#define    CLKID_78_75     0x14
#define    CLKID_94_5      0x15
#define    CLKID_108_5     0x16        // Requires clock doubler
#define    CLKID_35_5      0x17            
#define    CLKID_158       0x18        // Requires clock doubler
#define    CLKID_55_86     0x19            
#define    CLKID_20        0x1A
#define    CLKID_27_93     0x1B
#define    CLKID_32_5      0x1C
#define    CLKID_12_588    0x1D
#define    CLKID_81_62     0x1E            
#define    CLKID_219_566   0x1F            
#define    CLKID_172_798   0x20            
#define    CLKID_193_156   0x21            
#define    CLKID_229_5     0x22
#define    CLKID_266_95    0x23

// Video Mode Control Structure
typedef struct _vmode_
{
    U016  mdVMode;                // Mode Number of this mode
    U008   mdMode;                 // Internal Mode Number
    U008   mdIMode;                // Standard Mode Table Index
    U008   mdEMode;                // Extended Mode Table Index
    U008   mdTVMode;               // TV Mode Table Index
    U008   mdCMode;                // Extended CRTC Override Index
    U008   mdBPP;                  // Bits per Pixel
    U016  mdXRes;                 // X resolutio
    U016  mdYRes;                 // Y resolutionn
    U016  mdRowOff;               // Scanline Row Offset
    U016  mdMaxDotClock;          // Maximum DCLK
    
} MODEDESC;                            

  
typedef struct _ext_regs_
{
                            // ++++------- Reserved
                            // |||| +----- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| |+---- CR1C[2] - Sequential Chain 4
                            // |||| ||+--- CR1C[1] - Page Select Control
                            // |||| |||+-- CR1A[0] - Address Wrap
    U008   xrFlags;         // VVVV VVVV
                            // 7654 3210
                            
                            // +---------- NV_PRAMDAC_GENERAL_CONTROL[12] - 565_MODE
                            // |+++------- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| +----- CR25[5] - Bit 11 of offset
                            // |||| |+++-- CR19[7:5] - Bits 8->10 of Offset
    U008   xrOffset;        // VVVV VVVV               
                            // 7654 3210
                            
                            // ++--------- CR2D[3:2] - Bit 8 of HRetrace & HBlank Starts
                            // ||+-------- CR1A[2] - Large Screen bit
                            // |||+------- CR25[4] - Bit 6 of HBlank End
                            // |||| ++---- Bit 10 of VBlank & VRetrace Start
                            // |||| ||++-- VDisp End, VTotal
    U008   xrVOver;         // VVVV VVVV                         
                            // 7654 3210

                            // ++--------- CR2D[1:0] - Bit 8 of DHisp End and HTotoal
                            // ||++------- CR1C[4:3] - Optimized chain-4 write/read access
                            // |||| +----- CR28[3] - NV_PRAMDAC_PLL_COEFF_SELECT[28]
                            // |||| |                VCLK Divide by 1 or 2
                            // |||| |+---- CR28[2] - Linear/Tile mode
                            // |||| ||++-- CR28[1:0] - Pixel Format
    U008   xrPixFmt;        // VVVV VVVV                         
                            // 7654 3210
                            
    U008   xrVOffset;      // CR13 - VGA Offset register
    U008   xrIntlace;      // CR39 - Interlace Half Field Start
    U016  xrRegenLength;   // Override of PT_RegenLength (res+color depth specific)
    U008   xrClkSel;       // Pixel Clock Select
    
} EXTREGS;                              

typedef struct _tv_regs_
{
    U008   tvIntlace;              // CRTC[39] (Interlace Half Field Start)
    U008   tvDecimate_NTSC;        // CRTC[29] (Decimate for TV)
    U008   tvHT_NTSC;              // CRTC[00] (Horiztonal total for NTSC)
    U008   tvHRS_NTSC;             // CRTC[04] (Horizontal retrace start for NTSC)
    U008   tvVT_NTSC;              // CRTC[06] (Vertical total for NTSC)
    U008   tvVO_NTSC;              // CRTC[07] (Vertical overflow for NTSC)
    U008   tvVRS_NTSC;             // CRTC[10] (Vertical retrace start for NTSC)
    U008   tvHDE_NTSC;             // CRTC[01] (Horizontal Display End)
    U008   tvHBS_NTSC;             // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_NTSC;             // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_NTSC;             // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_NTSC;             // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_NTSC;             // CRTC[12] (Vertical Display End)
    U008   tvVBS_NTSC;             // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_NTSC;             // CRTC[16] (Vertical Blank End)
    U008   tvDecimate_PAL;         // CRTC[29] (Decimate for TV)
    U008   tvHT_PAL;               // CRTC[00] (Horiztonal total for PAL)
    U008   tvHRS_PAL;              // CRTC[04] (Horizontal retrace start for PAL)
    U008   tvVT_PAL;               // CRTC[06] (Vertical total for PAL)
    U008   tvVO_PAL;               // CRTC[07] (Vertical overflow for PAL)
    U008   tvVRS_PAL;              // CRTC[10] (Vertical retrace start for PAL)
    U008   tvHDE_PAL;              // CRTC[01] (Horizontal Display End)
    U008   tvHBS_PAL;              // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_PAL;              // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_PAL;              // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_PAL;              // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_PAL;              // CRTC[12] (Vertical Display End)
    U008   tvVBS_PAL;              // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_PAL;              // CRTC[16] (Vertical Blank End)
    
} TVREGS;

typedef struct _vesamodeentry_
{
    U016    vesa_mode_number;
    U008    tv_mode_number;
} VESAMODEENTRY;

 
// CRTC Override Structure. This structure overrides the settings selected
// from the standard modeset mode table.
//
typedef struct _crtc_ovr_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U008   CO_Misc;                // Misc Register
    U008   CO_ClockMode;           // SR1
    U008   HTotal;                 // CR00
    U008   HDispEnd;               // CR01
    U008   HBlankS;                // CR02
    U008   HBlankE;                // CR03
    U008   HSyncS;                 // CR04
    U008   HSyncE;                 // CR05
    U008   VTotal;                 // CR06
    U008   Overflow;               // CR07
    U008   CO_CellHeight;          // CR09
    U008   CO_VSyncStart;          // CR10
    U008   VSyncE;                 // CR11
    U008   VDispE;                 // CR12
    U008   CO_VBlankStart;         // CR15
    U008   VBlandE;                // CR16
                                              
}CRTC_OVERRIDE;

//
// Fifo settings
//
typedef struct _modeset_fifo_
{
    U016  Freq;                   // Maximum frequency for these water marks
    U008   LowWaterMark64;         // Low water mark for 64 bit bus
    U008   BurstSize64;            // Burst size for 64 bit bus
    U008   LowWaterMark128;        // Low water mark for 128 bit bus
    U008   BurstSize128;           // Burst size for 128 bit bus
                                      
} MODESET_FIFO;

//
// CRTC access state (for dos compile)
//
typedef struct _save_astate_
{
    U016   crtc_addr;          // CRTC Address
    U032   nv_address;         // 32-bit NV address
    U008   access_bits;        // Access Control Bits
    U008   access_reg;         // Access Register (NVRM_ACCESS)
    U016   data_low;           // Low 32-bits of data register
} ACCESS_STATE;

//  I2C defines

#define DEBUG0                  0	// print download byte
#define DEBUG1                  0	// print bit
#define DEBUG2                  0	// print ack/no ack
#define DEBUG3                  0	// create strobe on pins 16 & 17
#define DEBUG4                  0	// print reback diags

#define CRTC_INDEX  0x3D4
#define CRTC_DATA   0x3D5
#define DDC_STATUS  0x3E
#define DDC_WRITE   0x3F    // bit 5 = clock, bit 4 = data, bit 0 = enable

#define write_port	0x3d5   // 
#define read_port	0x3d5	// 

#define SCLOCK		0x04	// read scl
#define SDATA		0x20	// read sda (latched data)
#define SDATA_BIT   5
#define clockhi		0x21	// 'or' to set high
#define clocklo		0xDF	// 'and' to set low
#define clrdata		0xEF	// 'and' this to clear the data bit
#define setdata		0x11	// 'or' this to set the data bit

#define i2c_state0	0x31	// clock and data high
#define i2c_state1	0x21	// clock high, data low
#define i2c_state2	0x01	// clock and data low

#define clock0_lo	0x01	// clock and data low
#define clock0_hi	0x11	// clock low, data hi
#define clock1_lo	0x21	// clock high, data low
#define clock1_hi	0x31	// clock and data high

#define ack_state0	0x11	// clock low, data hi
#define ack_state1	0x31	// clock and data high
#define ack_state2	0x11	// clock low, data hi

#define data_in     0x08    // SDA
#define clock_in    0x04    // SCL

//#define KHz400		1250/200
#define I2C_DELAY		1250/200


//
// Modeset function prototypes
//
VOID NvPost(VOID);
U016 VBESetMode(U016, PGTF_TIMINGS,PDMT_OVERRIDES,U016);         // VESA SetMode
U016 VBESetRefresh(PGTF_TIMINGS);
MODEDESC *ValidateMode(U016 );    // Validate VESA Mode
U008 isTV(VOID);
U008 isPAL(VOID);
U008 OEMValidateMode(MODEDESC *);
U016 OEMGetMemSize(VOID);
VOID SaveNVAccessState(ACCESS_STATE *);
VOID RestoreNVAccessState(ACCESS_STATE *);
//KYH U032 ReadPriv32(U032 );
//KYH U016 ReadIndexed(U032 , U008 );
VOID OEMDisableExtensions(VOID);
VOID OEMEnableExtensions(VOID);
VOID WriteIndexed(U032, U016);
VOID OEMPreSetRegs(VOID);
VOID SetRegs(MODEDESC *);
VOID LoadIndexRange(U032, U008, U008, U008 *);
VOID ATCOff(VOID);
VOID ATCOn(VOID);
VOID OEMSetRegs(MODEDESC *);
VOID FullCpuOn(VOID);
VOID FullCpuOff(VOID);
U032 CalcMNP(U016 *);
VOID OEMSetClock(U016 );
//KYH VOID WritePriv32(U032 , U032 );
VOID LoadDefaultATCAndSavePtr(U008 *);
VOID LoadDefaultRAMDAC(MODEDESC *);
VOID LoadPalette(MODEDESC *);
VOID LoadColorDACTable(VOID);
VOID LoadColor256DAC(VOID);
VOID LoadIdentityDAC(VOID);
VOID WriteColor(U008 );
VOID WriteColor2(U016 , U016 , U016 , U016 );
VOID FixLowWaterMark(U016 );
VOID SetDACClock(U032 );
//KYH VOID WritePriv08(U032 , U008 );
U016 h2i(U008 *);                // Hex 2 Integer

typedef struct
{
    U008    SR01;
    U008    CR00;
    U008    CR04;
    U008    CR06;
    U008    CR07;
    U008    CR08;
    U008    CR10;
    U008    CR12;
    U008    CR25;
    U008    CR28;
} CH_ADJ;      

typedef struct
{
    U008    SR01;
    U008    CR00;
    U008    CR04;
    U008    CR06;
    U008    CR07;
    U008    CR08;
    U008    CR10;
    U008    CR12;
} BT_ADJ;

//typedef struct _I2C_string_struct_
typedef struct 
{
    U008    Dev;
    U008    Reg0;
    U008    Data0;
    U008    Reg7;
    U008    Data7;
    U008    Reg8;
    U008    Data8;
    U008    RegA;
    U008    DataA;
    U008    RegB;
    U008    DataB;
    U008    Reg13;
    U008    Data13;
    U008    Data14;
    U008    Data15;
} I2C_string, *PI2C_string;
    
    
//  Brooktree values -- 1 byte device ID, 6 bytes centering info, 33 bytes resolution info
typedef struct 
{
    U008    Dev;
    U008    btc1;
    U008    btc2;
    U008    btc3;
    U008    btc4;
    U008    btc5;
    U008    btc6;
    U008    bt1;
    U008    bt2;
    U008    bt3;
    U008    bt4;
    U008    bt5;
    U008    bt6;
    U008    bt7;
    U008    bt8;
    U008    bt9;
    U008    bt10;
    U008    bt11;
    U008    bt12;
    U008    bt13;
    U008    bt14;
    U008    bt15;
    U008    bt16;
    U008    bt17;
    U008    bt18;
    U008    bt19;
    U008    bt20;
    U008    bt21;
    U008    bt22;
    U008    bt23;
    U008    bt24;
    U008    bt25;
    U008    bt26;
    U008    bt27;
    U008    bt28;
    U008    bt29;
    U008    bt30;
    U008    bt31;
    U008    bt32;
    U008    bt33;
    U008    termination;
} BT_string, *PBT_string;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\nvpeos.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvpeos.c
 *
 *  NVPE miniVDD code.
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

// MS includes
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>
#include <vwin32.h>

// NV includes 
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>
#include <nvrmr0api.h>

#include "ddkmmini.h"
#include "nvpeos.h"

//
// prototypes
//
VP_STATUS   NVPEProcessCommand      (PVOID, PVIDEO_REQUEST_PACKET);
VP_STATUS   NVPProcessState         (PHW_DEVICE_EXTENSION, int, BOOL);
DWORD       NVPCompleteTransfer     (PVOID);
VOID        _vwin32ResetWin32Event  (PVOID);
VOID        _vwin32SetWin32Event    (PVOID);


/*----------------------------------------------------------------------------*/
/*
 * globals
 */
struct _HW_DEVICE_EXTENSION nvpeDevExtension;
struct _VIDEO_REQUEST_PACKET nvpeRequestPacket;
#ifdef DEBUG
int cur_debuglevel = DBG_LEVEL_DEFAULTS;    // all modules set to warning level
#endif

/*----------------------------------------------------------------------------*/
/*
 * nvpeVDDCmdHandler()
 *
 *      Initial NVPE_COMMAND IOCTL handler.  Called from nvmini.asm.
 */

DWORD nvpeVDDCmdHandler(
    PDIOCPARAMETERS  pDIOC)
{

    /*
     * repackage IOCTL parameters and call the real NVPE handler
     */
    nvpeRequestPacket.IoControlCode = pDIOC->dwIoControlCode;
    nvpeRequestPacket.StatusBlock = 0;
    nvpeRequestPacket.InputBuffer = (PVOID)(pDIOC->lpvInBuffer);
    nvpeRequestPacket.InputBufferLength = pDIOC->cbInBuffer;
    nvpeRequestPacket.OutputBuffer = (PVOID)(pDIOC->lpvOutBuffer);
    nvpeRequestPacket.OutputBufferLength = pDIOC->cbOutBuffer;

    NVPEProcessCommand(&nvpeDevExtension, &nvpeRequestPacket);

    /*
     * nvmini.asm uses a return value of 1 to signal failure
     */
    if (nvpeRequestPacket.StatusBlock == 0) {
        return 0;
    }
    else {
        return 1;
    }

}

/*----------------------------------------------------------------------------*/
/*
 * VideoField0Notify()
 *
 *      Callback function for Field 0 capture.  Called by the RM.
 */

void VideoField0Notify()
{

    NVPProcessState(&nvpeDevExtension, 0, FALSE);

}

/*----------------------------------------------------------------------------*/
/*
 * VideoField1Notify()
 *
 *      Callback function for Field 1 capture.  Called by the RM.
 */

void VideoField1Notify()
{

    NVPProcessState(&nvpeDevExtension, 1, FALSE);

}

/*----------------------------------------------------------------------------*/
/*
 * VBIField0Notify()
 *
 *      Callback function for VBI Field 0 capture.  Called by the RM.
 */

void VBIField0Notify()
{

    NVPProcessState(&nvpeDevExtension, 0, TRUE);

}

/*----------------------------------------------------------------------------*/
/*
 * VBIField1Notify()
 *
 *      Callback function for VBI Field 1 capture.  Called by the RM.
 */

void VBIField1Notify()
{

    NVPProcessState(&nvpeDevExtension, 1, TRUE);

}

/*----------------------------------------------------------------------------*/
/*
 * NVPTransferNotify()
 *
 *      Callback function VBI/Video Transfer code.  Called by the RM.
 */

void NVPTransferNotify()
{
    NVPCompleteTransfer(&nvpeDevExtension);
}

/*----------------------------------------------------------------------------*/
/*
 * Misc os dependent utility functions.
 *
 */

U032 osNVPAllocDmaBuffer(
    PVOID pContext, 
    DWORD dwSize, 
    PVOID *pBuffer)
{

    *pBuffer = _HeapAllocate(dwSize, 0);
    if (*pBuffer == NULL) {
        return 1;
    }
    else {
        return 0;
    }

}

void osNVPReleaseDmaBuffer(
    PVOID pContext, 
    PVOID pBuffer)
{
    _HeapFree((BYTE *)pBuffer, 0);
}

void osNVPClearEvent(void* hEvent)
{
    _vwin32ResetWin32Event(hEvent);
}

U032 osNVPSetEvent(void *hEvent)
{
    _vwin32SetWin32Event(hEvent);
    return 0;
}

U032 rmNVPAllocContextDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    U032 base,
    U032 limit)
{

    return NvRmR0AllocContextDma(hClient, hDma, hClass, flags, (PVOID) base, limit);

}

U032 rmNVPAllocChannelDma(
    U032 hClient,
    U032 hDevice,
    U032 hDmaChannel,
    U032 hClass,
    U032 hErrorContext,
    U032 hDataContext,
    U032 offset,
    U032 *ppControl)
{

    return NvRmR0AllocChannelDma(hClient, hDevice, hDmaChannel, hClass, hErrorContext, hDataContext, offset, (PVOID) ppControl);

}

U032 rmNVPAllocObject(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass)
{

    return NvRmR0AllocObject(hClient, hChannel, hObject, hClass);

}

U032 rmNVPAlloc(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass,
    PVOID pAllocParms)
{

    return NvRmR0Alloc(hClient, hChannel, hObject, hClass, pAllocParms);

}

U032 rmNVPFree(
    U032 hClient,
    U032 hParent,
    U032 hObject)
{

    return NvRmR0Free(hClient, hParent, hObject);

}

U032 rmNVPAllocEvent(
    NVOS10_PARAMETERS *pEvent)
{
    return NvRmR0AllocEvent(pEvent->hRoot, 
                            pEvent->hObjectParent, 
                            pEvent->hObjectNew, 
                            pEvent->hClass, 
                            pEvent->index, 
                            (PVOID)(pEvent->hEvent.low));
}

U032 rmNVPInterrupt(
    U032 hClient,
    U032 hDevice)
{
    return NvRmR0Interrupt(hClient, hDevice);
}

void nvpeVDDClearState()
{
    DWORD   i;
    unsigned char *pBuf;

    // clear our global HwDevExt manually since we can't use bzero()
    pBuf = (unsigned char*) &nvpeDevExtension;
    for (i = 0; i < sizeof(nvpeDevExtension); i++ ) {
        pBuf[i] = 0;
    }
}

#if DEBUG

//---------------------------------------------------------------------------
//
//  Debugging support.
//
//---------------------------------------------------------------------------

VOID osDbgPrintf_va(
    int     module,
    int     debuglevel,
    const char *printf_format,
    va_list arglist)
{
    int     moduleValue = cur_debuglevel;
    char    nv_error_string[MAX_ERROR_STRING];
    char    *p = nv_error_string;
    int     chars_written;

    // get the module
    // put the module we want in the first 2 bits
    moduleValue = moduleValue >> (module * 2);

    // get the value of those two bits
    // mask off the last 30 bits
    moduleValue = moduleValue & 0x00000003;

   if (debuglevel >= moduleValue)
   {
        chars_written = nvDbgSprintf(p, printf_format, arglist);

        _Debug_Printf_Service(p);
   }
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\nvpekmvt.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvpekmvt.c
 *
 *      NVPE Kernel Mode Video Transport code for the miniVDD.  These functions 
 *      are called from kmvtdisp.asm.
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

// MS includes
#include "windows.h"
#include "ddraw.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
#include "minivdd.h"
#include "ddkmmini.h"

// NV includes 
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>
#include "nvrmr0api.h"
#include "nvpeos.h"

//
// prototypes
//
DWORD   SkipNextField   (PVOID, PNVP_DDSKIPNEXTFIELDINFO, PVOID);
DWORD   BobNextField    (PVOID, PNVP_DDBOBNEXTFIELDINFO, PVOID);
DWORD   SetState        (PVOID, PNVP_DDSETSTATEININFO, PNVP_DDSETSTATEOUTINFO);
DWORD   LockSurface     (PVOID, PNVP_DDLOCKININFO, PNVP_DDLOCKOUTINFO);
DWORD   FlipOverlay     (PVOID, PNVP_DDFLIPOVERLAYINFO, PVOID);
DWORD   FlipVideoPort   (PVOID, PNVP_DDFLIPVIDEOPORTINFO, PVOID);
DWORD   GetPolarity     (PVOID, PNVP_DDGETPOLARITYININFO, PNVP_DDGETPOLARITYOUTINFO);
DWORD   GetCurrentAutoflip(PVOID, PNVP_DDGETCURRENTAUTOFLIPININFO, PNVP_DDGETCURRENTAUTOFLIPOUTINFO);
DWORD   GetPreviousAutoflip(PVOID, PNVP_DDGETPREVIOUSAUTOFLIPININFO, PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO);
DWORD   NVPTransfer     (PVOID, PNVP_DDTRANSFERININFO, PNVP_DDTRANSFEROUTINFO);
DWORD   NVPGetTransferStatus(PVOID, PVOID, PNVP_DDGETTRANSFEROUTINFO);

extern struct _HW_DEVICE_EXTENSION nvpeDevExtension;

/*
;   DESCRIPTION: If the Mini VDD is already managing the IRQ, this
;          function returns that information; otherwise, it returns the
;          IRQ number assigned to the device so DDraw can manage the IRQ.
;
;          The returning the IRQ number, it is important that it get the
;          value assigned by the Config Manager rather than simply get
;          the value from the hardware (since it can be remapped by PCI).
*/
U032 vddGetIRQInfo(
    U032 dwMiniVDDContext, 
    U032 dummy, 
    DDGETIRQINFO* pGetIrqInfo) 
{
    pGetIrqInfo->dwFlags = IRQINFO_HANDLED;
    return 0;
}

/*
;   DESCRIPTION: Called when the VDD's IRQ handled is triggered.  This
;          determines if the IRQ was caused by our VGA and if so, it
;          clears the IRQ and returns which event(s) generated the IRQ.
*/
U032 vddIsOurIRQ(
    U032 dwMiniVDDContext, 
    U032 dummy) 
{
    return 1;
}

U032 vddEnableIRQ(
    U032 dwMiniVDDContext, 
    DDENABLEIRQINFO* pEnableIrqInfo, 
    U032 dummy) 
{

    nvpeDevExtension.dwIRQSources = pEnableIrqInfo->dwIRQSources;
    nvpeDevExtension.IRQCallback = (PVOID) (pEnableIrqInfo->IRQCallback);
    nvpeDevExtension.dwIRQContext = pEnableIrqInfo->dwContext;

    return 0;
}

U032 vddSkipNextField(
    U032 dwMiniVDDContext, 
    DDSKIPINFO* pSkipInfo, 
    U032 dummy) 
{
    return SkipNextField(&nvpeDevExtension, pSkipInfo, NULL);
}


U032 vddBobNextField(
    U032 dwMiniVDDContext, 
    DDBOBINFO* pBobInfo, 
    U032 dummy) 
{
    return BobNextField(&nvpeDevExtension, pBobInfo, NULL);
}

U032 vddSetState(
    U032 dwMiniVDDContext, 
    DDSTATEININFO* pSetStateInfoIn, 
    DDSTATEOUTINFO* pSetStateInfoOut) 
{
    return SetState(&nvpeDevExtension, pSetStateInfoIn, pSetStateInfoOut);
}

U032 vddLock(
    U032 dwMiniVDDContext, 
    DDLOCKININFO* pLockInfoIn, 
    DDLOCKOUTINFO* pLockInfoOut) 
{
    return LockSurface(&nvpeDevExtension, pLockInfoIn, pLockInfoOut);
}

U032 vddFlipOverlay(
    U032 dwMiniVDDContext, 
    DDFLIPOVERLAYINFO* pFlipOverlayInfo, 
    U032 dummy) 
{
    return FlipOverlay(&nvpeDevExtension, pFlipOverlayInfo, NULL);
}

U032 vddFlipVideoPort(
    U032 dwMiniVDDContext, 
    U032* pFlipVideoPort, 
    U032 dummy) 
{
    return FlipVideoPort(&nvpeDevExtension, (PNVP_DDFLIPVIDEOPORTINFO) pFlipVideoPort, NULL);
}

U032 vddGetFieldPolarity(
    U032 dwMiniVDDContext, 
    DDPOLARITYININFO* pGetPolarityInInfo, 
    DDPOLARITYOUTINFO* pGetPolarityOutInfo) 
{
    return GetPolarity(&nvpeDevExtension, pGetPolarityInInfo, pGetPolarityOutInfo);
}

U032 vddSetSkipPattern(
    U032 dwMiniVDDContext, 
    DDSETSKIPINFO* pSetSkipInfo, 
    U032 dummy) 
{
	return 1;
}

U032 vddGetCurrentAutoFlip(
    U032 dwMiniVDDContext, 
    DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, 
    DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut) 
{
    return GetCurrentAutoflip(&nvpeDevExtension, pGetAutoFlipInfoIn, pGetAutoFlipInfoOut);
}

U032 vddGetPreviousAutoFlip(
    U032 dwMiniVDDContext, 
    DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, 
    DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut) 
{
    return GetPreviousAutoflip(&nvpeDevExtension, pGetAutoFlipInfoIn, pGetAutoFlipInfoOut);
}

U032 vddTransfer(
    U032 dwMiniVddContext, 
    DDTRANSFERININFO* pTransferInInfo, 
    DDTRANSFEROUTINFO* pTransferOutInfo ) 
{
    return NVPTransfer(&nvpeDevExtension, pTransferInInfo, pTransferOutInfo);
}

U032 vddGetTransferStatus(
    U032 dwMiniVddContext, 
    U032 dummy, 
    DDGETTRANSFERSTATUSOUTINFO* pGetTransStatusInfo ) 
{
    return NVPGetTransferStatus(&nvpeDevExtension, NULL, pGetTransStatusInfo);
} 


U032 kmvtNVPCallbackDxApi(void *pContext, U032 dwIRQSource)
{
    HW_DEVICE_EXTENSION *pHwDevCtx = (HW_DEVICE_EXTENSION *) pContext;
    U032 dwIRQContext;

    // can we pass on the interrupt !
    if (pHwDevCtx->IRQCallback)
    {
        dwIRQContext = (U032)(pHwDevCtx->dwIRQContext);
        _asm mov eax, dwIRQSource
        _asm mov ebx, dwIRQContext
        ((PNVP_DX_IRQCALLBACK)(pHwDevCtx->IRQCallback))();
    }
    
    return 0;
}

// A mechanism to populate the WDM prescale values
// This is a back door mechanism and should not really be in this module.
U032 vddWriteVPEPrescale(U032 ulX, U032 ulY, U032 ulCap, U032 ulVPNotUseOverlay, U032 ulFlag)
{
	PNVP_CONTEXT pVPEContext;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "nvpekmvt: vddWriteVPEPrescale()\n");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(nvpeDevExtension.avpContexts[0]);
	
	if(ulFlag & 0x8){
		pVPEContext->ulVPECapturePrescaleXFactor=ulX;
	}

	if(ulFlag & 0x4){
		pVPEContext->ulVPECapturePrescaleYFactor=ulY;
	}

	if(ulFlag & 0x2){
		pVPEContext->ulVPECaptureFlag=ulCap;
	}

	if(ulFlag & 0x1){
		pVPEContext->ulVPNotUseOverSurf=ulVPNotUseOverlay;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\kmvtdisp.asm ===
page            ,132
title		Mini VDD Kernel Mode Video Transport (VPE ring 0) dispatch 
.386p
;
;
.xlist
include	VMM.INC
include	VMMREG.INC
include	VWIN32.INC
include 	MINIVDD.INC
include	DDKMMINI.INC
include  DEBUG.INC
include  SURFACES.INC
.list

extrn _vddGetIRQInfo:near
extrn _vddEnableIRQ:near
extrn _vddIsOurIRQ:near
extrn _vddFlipVideoPort:near
extrn _vddFlipOverlay:near
extrn _vddBobNextField:near
extrn _vddSetState:near
extrn _vddLock:near
extrn _vddSkipNextField:near
extrn _vddGetFieldPolarity:near
extrn _vddSetSkipPattern:near
extrn _vddGetCurrentAutoFlip:near
extrn _vddGetPreviousAutoFlip:near
;  these are the nvidia specific functions
extrn _vddgetStoragePointer:near
extrn _vddhandleBufferInterrupts:near
extrn _vddSetCallback:near
extrn _vddTransfer:near
extrn _vddGetTransferStatus:near
IFDEF   NV4_HW
extrn _vddSetVidTexSuf:near
ENDIF    ;NV4_HW

VxD_LOCKED_DATA_SEG
;
; Many of these functions are called at interrupt time
; So all data must be allocated in a locked (non-swappable) segment
;


;CODE
; until we have use for the context..... ignore
;extrn MMIOLinearAddrBase:dword
                   
VxD_LOCKED_DATA_ENDS

VxD_DATA_SEG
VxD_DATA_ENDS

VxD_LOCKED_CODE_SEG

;****************************************************************************
;
;   GetDDHAL
;
;   DESCRIPTION: This function fills in the function table supplied
;	by DDRAW with functions that their VxD can call fro kernel mode
;	DirectDraw support.  The MiniVDD can fill in the dwContext field
;	with a value that will always be passed back when called.
;
;   ENTRY:
;	   ESI  Ptr to DIOCParams
;		ESI+18h  Ptr to output buffer
;		ESI+1Ch  Size of output buffer
;		ESI+20h  Amount of data we write into output buffer
;
;   EXIT:
;          EAX	0 = success
;
;****************************************************************************

public  GetDDHAL
BeginProc GetDDHAL

	; get the size of the DDMINIVDDTABLE from the OutBuffer
	; compare with known size and error if there is a problem
	mov	ebx, [esi.DIOCParams.cbOutBuffer]
	cmp	ebx, SIZE _DDMINIVDDTABLE
	jl	GetDDHAL_Error

	; confirm that the input buffer has size of 4 bytes
	mov	ebx, [esi.DIOCParams.cbInBuffer]
	cmp	ebx, 4
	jl	GetDDHAL_Error


	; put address of output buffer in ebx
	mov	ebx, [esi.DIOCParams.lpvOutBuffer]

	;load context... and then the offset addresses of the various functions

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]
	; grab first U032 of InBuffer
	mov	eax,[eax]
	; store that as the context
	mov	[ebx._DDMINIVDDTABLE.dwMiniVDDContext], eax
	
	
	; load up the various function offsets
	mov	eax, OFFSET32 DDGetIRQInfo
	mov	[ebx._DDMINIVDDTABLE.vddGetIRQInfo], eax
	mov	eax, OFFSET32 DDIsOurIRQ
	mov	[ebx._DDMINIVDDTABLE.vddIsOurIRQ], eax
	mov	eax, OFFSET32 DDEnableIRQ
	mov	[ebx._DDMINIVDDTABLE.vddEnableIRQ], eax
	mov	eax, OFFSET32 DDSkipNextField
	mov	[ebx._DDMINIVDDTABLE.vddSkipNextField], eax
	mov	eax, OFFSET32 DDBobNextField
	mov	[ebx._DDMINIVDDTABLE.vddBobNextField], eax
	mov	eax, OFFSET32 DDSetState
	mov	[ebx._DDMINIVDDTABLE.vddSetState], eax
	mov	eax, OFFSET32 DDLock
	mov	[ebx._DDMINIVDDTABLE.vddLock], eax
	mov	eax, OFFSET32 DDFlipOverlay
	mov	[ebx._DDMINIVDDTABLE.vddFlipOverlay], eax
	mov	eax, OFFSET32 DDFlipVideoPort
	mov	[ebx._DDMINIVDDTABLE.vddFlipVideoPort], eax
	mov	eax, OFFSET32 DDGetFieldPolarity
	mov	[ebx._DDMINIVDDTABLE.vddGetPolarity], eax
	mov	eax, OFFSET32 DDSetSkipPattern
	mov	[ebx._DDMINIVDDTABLE.vddReserved1], eax
	mov	eax, OFFSET32 DDGetCurrentAutoflipSurface
	mov	[ebx._DDMINIVDDTABLE.vddGetCurrentAutoflip], eax
	
	mov	eax, OFFSET32 DDGetPreviousAutoflipSurface
	mov	[ebx._DDMINIVDDTABLE.vddGetPreviousAutoflip], eax
	
	mov	eax, OFFSET32 DDTransfer
	mov	[ebx._DDMINIVDDTABLE.vddTransfer], eax
	
	mov	eax, OFFSET32 DDGetTransferStatus
	mov	[ebx._DDMINIVDDTABLE.vddGetTransferStatus], eax
	
	mov	ebx, [esi.DIOCParams.lpcbBytesReturned]
	mov	eax, SIZE _DDMINIVDDTABLE
	mov	[ebx], eax

	Debug_Printf    "XXXXXXXXXXXXXXXXXXXXXX  Calling Fill the DD HAL table\n\r", eax, DEBLEVELMAX
        
; zero out the return value are return
	sub	eax, eax
	ret

GetDDHAL_Error:
;    this next one is probably left over from debugging
;    INT3
	mov	eax, 1
	ret
 
EndProc GetDDHAL

;****************************************************************************
;
;   NvFillTable
;
;   DESCRIPTION: This function will fill in a table with all of the Nvidia 
;   specific functions which allow us to work between ring3 and ring0 VPE stuff
;
;   ENTRY:
;	   ESI  Ptr to DIOCParams
;		ESI+18h  Ptr to output buffer
;		ESI+1Ch  Size of output buffer
;		ESI+20h  Amount of data we write into output buffer
;
;   EXIT:
;          EAX	0 = success
;
;****************************************************************************

public  NvFillTable
BeginProc NvFillTable

	; get the size of the NVVDDPROCTABLE from the OutBuffer
	; compare with known size and error if there is a problem
	
	mov	ebx, [esi.DIOCParams.cbOutBuffer]
	cmp	ebx, SIZE _NVVDDPROCTABLE
	jl	NvFillTable_Error

	; confirm that the input buffer has size of 4 bytes
	mov	ebx, [esi.DIOCParams.cbInBuffer]
	cmp	ebx, 4
	jl	NvFillTable_Error

	; put address of output buffer in ebx
	mov	ebx, [esi.DIOCParams.lpvOutBuffer]

	;load context... and then the offset addresses of the various functions

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]

	; grab first U032 of InBuffer  this is the pointer to the direct draw drivers
	mov	eax,[eax]

	; store that as the context
	mov	[ebx._NVVDDPROCTABLE.dwPDDDriver], eax
	
	
	; load up the various function offsets
	mov	eax, OFFSET32 VDhandleBufferInterrupts
	mov	[ebx._NVVDDPROCTABLE.handleBufferInterrupts], eax

	mov	eax, OFFSET32 VDgetStoragePointer
	mov	[ebx._NVVDDPROCTABLE.getStoragePointer], eax

; zero out the return value are return
	sub	eax, eax
	ret

NvFillTable_Error:
	mov	eax, 1
	ret
 

EndProc NvFillTable

;****************************************************************************
;
;   NVSetVidTexSuf
;
;   DESCRIPTION: This function records a pointer passed in from an APP.  Pointer points to some surface data
;
;   ENTRY:
;	   ESI  Ptr to DIOCParams
;		ESI+18h  Ptr to output buffer
;		ESI+1Ch  Size of output buffer
;		ESI+20h  Amount of data we write into output buffer
;
;   EXIT:
;          EAX	0 = success
;
;****************************************************************************

public  NVSetVidTexSuf
BeginProc NVSetVidTexSuf
	
	mov	ebx, [esi.DIOCParams.cbOutBuffer]
	cmp	ebx, 4
	jl	NVSetVidTexSuf_Error

	; confirm that the input buffer has size of 4 bytes
	mov	ebx, [esi.DIOCParams.cbInBuffer]
	cmp	ebx, 4
	jl	NVSetVidTexSuf_Error

	; put address of output buffer in ebx
	mov	ebx, [esi.DIOCParams.lpvOutBuffer]

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]

IFDEF   NV4_HW
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    eax	; struct pointer
    push    ebx    ; vmm context
;    call    _vddSetVidTexSuf
    pop    ebx    ; vmm context
    pop    ebx    ; vmm context
    
	 pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve

	; eax contain return value... no big deal we already filled output buffer
	 
; zero out the return value are return
	sub	eax, eax
	ret
ENDIF  ;  NV4_HW


NVSetVidTexSuf_Error:
	mov	eax, 1
	ret
 
EndProc NVSetVidTexSuf


;****************************************************************************
;
;   NVGetSetCallback
;
;   DESCRIPTION: This function fills in a record about callbacks
;
;   ENTRY:
;	   ESI  Ptr to DIOCParams
;		ESI+18h  Ptr to output buffer
;		ESI+1Ch  Size of output buffer
;		ESI+20h  Amount of data we write into output buffer
;
;   EXIT:
;          EAX	0 = success
;
;****************************************************************************

public  NVGetSetCallback
BeginProc NVGetSetCallback
	
	mov	ebx, [esi.DIOCParams.cbOutBuffer]
	cmp	ebx, 4
	jl	NvGetSetCallBack_Error

	; confirm that the input buffer has size of 4 bytes
	mov	ebx, [esi.DIOCParams.cbInBuffer]
	cmp	ebx, 4
	jl	NvGetSetCallBack_Error

	; put address of output buffer in ebx
	mov	ebx, [esi.DIOCParams.lpvOutBuffer]

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]

	mov	eax,  OFFSET32 _vddSetCallback
	mov	[ebx], eax

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]
    
	; eax contain return value... no big deal we already filled output buffer
	 
; zero out the return value are return
	sub	eax, eax
	ret

NvGetSetCallBack_Error:
	mov	eax, 1
	ret
 
EndProc NVGetSetCallback

public  NVSetCallback

BeginProc NVSetCallback
	
    call    _vddSetCallback
    ret

EndProc NVSetCallback

BeginProc VDhandleBufferInterrupts, RARE
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddhandleBufferInterrupts
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc VDhandleBufferInterrupts

BeginProc VDgetStoragePointer, RARE
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddgetStoragePointer
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc VDgetStoragePointer

;****************************************************************************
;
;   DDGetIRQInfo
;
;   DESCRIPTION: If the Mini VDD is already managing the IRQ, this
;          function returns that information; otherwise, it returns the
;          IRQ number assigned to the device so DDraw can manage the IRQ.
;
;          The returning the IRQ number, it is important that it get the
;          value assigned by the Config Manager rather than simply get
;          the value from the hardware (since it can be remapped by PCI).
;
;   ENTRY:
;	   ESI	NULL
;	   EDI  LPDDGETIRQINFO
;		    DWORD dwSize;
;		    DWORD dwFlags;
;		    DWORD dwIRQNum;
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDGetIRQInfo, RARE
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetIRQInfo
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDGetIRQInfo



;****************************************************************************
;
;   DDEnableIRQ
;
;   DESCRIPTION: Notifies the Mini VDD which IRQs should be enabled.  If
;          a previously enabled IRQ is not specified in this call,
;          it should be disabled.
;
;   ENTRY:
;	   ESI	LPDDENABLEIRQINFO
;		    DWORD dwSize
;		    DWORD dwIRQSources
;		    DWORD dwLine
;		    DWORD IRQCallback
;		    DWORD dwContext
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDEnableIRQ, RARE
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddEnableIRQ
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDEnableIRQ

;****************************************************************************
;
;   DDIsOurIRQ
;
;   DESCRIPTION: Called when the VDD's IRQ handled is triggered.  This
;          determines if the IRQ was caused by our VGA and if so, it
;          clears the IRQ and returns which event(s) generated the IRQ.
;
;   ENTRY:
;	   ESI	NULL
;
;   EXIT:
;	   EDI  IRQ source flags
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDIsOurIRQ, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddIsOurIRQ
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDIsOurIRQ


;****************************************************************************
;
;   DDFlipVideoPort
;
;   DESCRIPTION: Flips the video port to the target surface.
;
;   ENTRY:
;	   ESI	LPDDFLIPVIDEOPORTINFO
;		    DWORD dwSize
;		    LPDDVIDEOPORTDATA video port info
;		    LPDDSURFACEDATA current surface
;		    LPDDSURFACEDATA target surface
;		    DWORD dwFlipVPFlags
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDFlipVideoPort, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddFlipVideoPort
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDFlipVideoPort

;****************************************************************************
;
;   DDFlipOverlay
;
;   DESCRIPTION: Flips the overlay to the target surface.
;  
;   ENTRY:
;	   ESI	LPDDFLIPOVERLAYINFO
;		    DWORD dwSize
;		    LPDDSURFACEDATA current surface
;		    LPDDSURFACEDATA target surface
;		    DWORD flags
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDFlipOverlay, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; dummy
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddFlipOverlay
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; dummy	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDFlipOverlay


;****************************************************************************
;
;   DDBobNextInterleavedEvenOverlayField
;
;   DESCRIPTION: Called when "bob" is used and a VPORT VSYNC occurs that does
;       not cause a flip to occur (e.g. bobbing while interleaved).  When
;       bobbing, the overlay must adjust itself on every VSYNC, so this
;       function notifies it of the VSYNCs that it doesn't already know
;       about (e.g. VSYNCs that trigger a flip to occur).
;
;   ENTRY:
;	   ESI	LPDDBOBINFO
;		    DWORD dwSize
;		    LPDDSURFACE lpSurface
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDBobNextField, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; dummy
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddBobNextField
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; dummy	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDBobNextField


;****************************************************************************
;
;   DDSetState
;
;   DESCRIPTION: Called when the client wants to switch from bob to weave.
;	The overlay flags indicate which state to use. Only called for interleaved
;   surfaces.
;
;	NOTE: When this is called, the specified surface may not be
;	displaying the overlay (due to a flip).  Instead of failing
;	the call, change the bob/weave state for the overlay that would
;	be used if the overlay was flipped again to the specified surface.
;
;   ENTRY:
;	   ESI	LPDDSTATEININFO
;		    DWORD dwSize
;		    LPDDSURFACEDATA overlay surface
;	   EDI  LPDDSTATEOUTINFO
;		    DWORD dwSize
;		    DWORD dwSoftwareAutoflip
;		    DWORD dwSurfaceIndex        ; Return Current hardware autoflip
;
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDSetState, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddSetState
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDSetState


;****************************************************************************
;
;   DDLock
;
;   DESCRIPTION: Called when the client wants to lock the surface to
;	access the frame buffer. The driver doens't have to do anything,
;       but it can if it needs to.
;
;   ENTRY:
;	   ESI	LPDDLOCKININFO
;		    DWORD dwSize
;		    LPDDSURFACEDATA surface
;	   EDI  LPDDLOCKOUTINFO
;		    DWORD dwSize
;		    DWORD Pointer to a pointer to the surface
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDLock, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddLock
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDLock


;****************************************************************************
;
;   DDSkipNextVideoPortField
;
;   DESCRIPTION: Called when they want to skip the next field, usually
;       to undo a 3:2 pulldown but also for decreasing the frame rate.
;       The driver should not lose the VBI lines if dwVBIHeight contains
;       a valid value.
;
;   ENTRY:
;	   ESI	LPDDSKIPINFO
;		    DWORD dwSize
;		    LPDDVIDEOPORTDATA video port
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDSkipNextField, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddSkipNextField
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDSkipNextField

;****************************************************************************
;
;   DDGetFieldPolarity
;
;   DESCRIPTION: Returns the polarity of the current field being written
;	to the specified video port.
;
;   ENTRY:
;	   ESI	LPDDPOLARITYININFO
;		    DWORD dwSize
;		    LPDDVIDEOPORTDATA
;	   EDI  LPDDPOLARITYOUTINFO
;		    DWORD dwSize
;		    DWORD bPolority (even field = TRUE, odd field = FALSE)
;
;   EXIT:
;          EAX	0 = success, 1 = error
;          ECX  0 = odd,     1 = even
;
;****************************************************************************

BeginProc DDGetFieldPolarity, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetFieldPolarity
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
	 mov		ecx,eax	;  more the value to ECX
	 xor     eax,eax	;  zero out the return value since we always return sucess
	 ret

EndProc DDGetFieldPolarity

;****************************************************************************
;
;   DDSetSkipPattern
;
;   DESCRIPTION: Sets the skip pattern in hardware
;
;   ENTRY:
;	   ESI	LPDDSETSKIPINFO
;		    DWORD 		dwSize
;		    LPDDVIDEOPORTDATA	lpVideoPortData
;		    DWORD		dwPattern
;		    DWORD		dwPatternSize
;	   EDI  LPDDPOLARITYOUTINFO
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDSetSkipPattern, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddSetSkipPattern
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDSetSkipPattern



;****************************************************************************
;
;   DDGetCurrentAutoflipSurface
;
;   DESCRIPTION: Returns the current surface receiving data from the
;	video port while autoflipping is taking palce.  Only called when
;   hardware autoflipping.
;
;   ENTRY:
;	   ESI	LPDDGETAUTOFLIPINFO
;		    DWORD 		dwSize
;	   EDI	LPDDGETAUTOFLIPINFO
;		    DWORD 		dwSize
;		    DWORD		dwSurfaceIndex
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDGetCurrentAutoflipSurface, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetCurrentAutoflip
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDGetCurrentAutoflipSurface
;****************************************************************************
;
;   DDGetPreviousAutoflipSurface
;
;   DESCRIPTION: Returns the surface that received the data from the
;	previous field of video port while autoflipping is taking palce. Only
;   called for hardware autoflipping.
;
;   ENTRY:
;	   ESI	LPDDGETAUTOFLIPINFO
;		    DWORD 		dwSize
;	   EDI	LPDDGETAUTOFLIPINFO
;		    DWORD 		dwSize
;		    DWORD		dwSurfaceIndex
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDGetPreviousAutoflipSurface, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetPreviousAutoFlip
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDGetPreviousAutoflipSurface

;****************************************************************************
;
;   DDTransfer
;
;   DESCRIPTION: Returns the surface that received the data from the
;	previous field of video port while autoflipping is taking palce. Only
;   called for hardware autoflipping.
;
;   ENTRY:
;	   ESI	DDTRANSFERININFO
;
;	   EDI	DDTRANSFEROUTINFO
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDTransfer, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddTransfer
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDTransfer


;****************************************************************************
;
;   DDGetTransferStatus
;
;
;   ENTRY:
;	   ESI	DDGETTRANSFERSTATUSOUTINFO
;
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDGetTransferStatus, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetTransferStatus
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDGetTransferStatus


public _vwin32SetWin32Event
public _vwin32ResetWin32Event
public _vwin32WaitSingleObject
public _vwin32TimeSliceSleep

BeginProc _vwin32SetWin32Event, CCALL, PUBLIC

ArgVar hEvent, DWORD

		EnterProc

    
    VMMCall Test_Sys_VM_Handle              ;is it the system VM?
    ; if not the system vm don't call this func
    jnz    NotGoingtoHappen
    
    ; 
		pushad
    
		mov		eax, [hEvent]

		VxDCall _VWIN32_SetWin32Event 

		popad

NotGoingtoHappen:
		LeaveProc
		return

EndProc _vwin32SetWin32Event


BeginProc _vwin32ResetWin32Event, CCALL, PUBLIC

ArgVar hEvent, DWORD

		EnterProc

		pushad
    
		; It already comes in EAX
        ;mov		eax, [hEvent]

		VxDCall _VWIN32_ResetWin32Event 

		popad

		LeaveProc
		return

EndProc _vwin32ResetWin32Event

BeginProc _vwin32WaitSingleObject, CCALL, PUBLIC

ArgVar hEvent, DWORD
ArgVar timeOut, DWORD
ArgVar dwFlag, DWORD

		EnterProc

		pushad
    
    mov		eax, [dwFlag]
    mov		edx, [timeOut]
    mov		ebx, [hEvent]

		VxDCall _VWIN32_WaitSingleObject 
    
    popad

		LeaveProc
		return

EndProc _vwin32WaitSingleObject

BeginProc _vwin32TimeSliceSleep, CCALL, PUBLIC

ArgVar dwTimeOut, DWORD

		EnterProc

		pushad
    
    mov		eax, [dwTimeOut]
    
		VMMCall Time_Slice_Sleep 
    
    popad

		LeaveProc
		return

EndProc _vwin32TimeSliceSleep


VxD_LOCKED_CODE_ENDS
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\nvpeos.h ===
/*----------------------------------------------------------------------------*/
/*
 * nvpeos.h
 *
 * Include file for miniVDD side of NVPE
 */

#ifndef _NVPEOS_H
#define _NVPEOS_H

#define NVPE_WIN9X  1

#include "nvpecntx.h"

// debug levels and modules
#include <nv_dbg.h>


//
// prototypes
//
U032 osNVPAllocDmaBuffer    (VOID *pContext,U032 dwSize,VOID **pBuffer);
VOID osNVPReleaseDmaBuffer  (VOID *pContext,VOID *pBuffer);
VOID osNVPClearEvent        (VOID *hEvent);
U032 osNVPSetEvent          (VOID *hEvent);
U032 rmNVPAllocContextDma   (U032 hClient,U032 hDma,U032 hClass,U032 flags,U032 selector,U032 base,U032 limit);
U032 rmNVPAllocChannelDma   (U032 hClient,U032 hDevice,U032 hDmaChannel,U032 hClass,U032 hErrorContext,U032 hDataContext,U032 offset,U032 *ppControl);
U032 rmNVPAllocObject       (U032 hClient,U032 hChannel,U032 hObject,U032 hClass);
U032 rmNVPAllocEvent        (NVOS10_PARAMETERS *pEvent);
U032 rmNVPAlloc             (U032 hClient,U032 hChannel,U032 hObject,U032 hClass,PVOID pAllocParms);
U032 rmNVPFree              (U032 hClient,U032 hParent,U032 hObject);
U032 rmNVPInterrupt         (U032 hClient, U032 hDevice);

/* 
 * primary NVPE command IOCTL (must mirror ioctl define in nvpeos.inc) 
 *
 * XXX - need to move this define to a higher level shared include file (jsun) 
 */ 
     
#define VDD_IOCTL_NVPE_COMMAND      0x300CAFE0
 
/*
 * Win9x equivalents for some typedefs used in Win2K
 */
 
typedef struct _HW_DEVICE_EXTENSION {

    PVOID       IRQCallback;
    PVOID       pIRQData;
	ULONG		dwIRQSources;
	ULONG		dwIRQContext;

	NVP_CONTEXT	avpContexts[NVP_MAX_VPORTS];

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

typedef struct _VIDEO_REQUEST_PACKET {

    ULONG IoControlCode;
    ULONG StatusBlock;      // really a PSTATUS_BLOCK
    PVOID InputBuffer;
    ULONG InputBufferLength;
    PVOID OutputBuffer;
    ULONG OutputBufferLength;

} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;


/*
 * XXX misc things that might need to be put elsewhere
 */
 
typedef LONG VP_STATUS;

#ifndef NO_ERROR
#define	NO_ERROR			0	/* Success */
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER     87
#endif

// 
// XXX taken from NT's dxmini.h and ddraw.h
// 
#define DX_OK                                   0x0
#define DXERR_UNSUPPORTED                       0x80004001
#define DXERR_GENERIC                           0x80004005
#define DXERR_OUTOFCAPS                         0x88760168

#define DDOVER_AUTOFLIP                       	0x00100000l
#define DDOVER_BOB                       	0x00200000l
#define DDOVER_OVERRIDEBOBWEAVE			0x00400000l
#define DDOVER_INTERLEAVED			0x00800000l

//
// silly typedef because microsoft can't name things the same between NT and Win9x
//
typedef DDVIDEOPORTDATA            * PNVP_DDVIDEOPORTDATA;
typedef DDSKIPINFO                 * PNVP_DDSKIPNEXTFIELDINFO;
typedef DDBOBINFO                  * PNVP_DDBOBNEXTFIELDINFO;
typedef DDSTATEININFO              * PNVP_DDSETSTATEININFO;
typedef DDSTATEOUTINFO             * PNVP_DDSETSTATEOUTINFO;
typedef DDLOCKININFO               * PNVP_DDLOCKININFO;
typedef DDLOCKOUTINFO              * PNVP_DDLOCKOUTINFO;
typedef DDFLIPOVERLAYINFO          * PNVP_DDFLIPOVERLAYINFO;
typedef DDFLIPVIDEOPORTINFO        * PNVP_DDFLIPVIDEOPORTINFO;
typedef DDPOLARITYININFO           * PNVP_DDGETPOLARITYININFO;
typedef DDPOLARITYOUTINFO          * PNVP_DDGETPOLARITYOUTINFO;
typedef DDGETAUTOFLIPININFO        * PNVP_DDGETCURRENTAUTOFLIPININFO;
typedef DDGETAUTOFLIPOUTINFO       * PNVP_DDGETCURRENTAUTOFLIPOUTINFO;
typedef DDGETAUTOFLIPININFO        * PNVP_DDGETPREVIOUSAUTOFLIPININFO;
typedef DDGETAUTOFLIPOUTINFO       * PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO;
typedef DDTRANSFERININFO           * PNVP_DDTRANSFERININFO;
typedef DDTRANSFEROUTINFO          * PNVP_DDTRANSFEROUTINFO;
typedef DDGETTRANSFERSTATUSOUTINFO * PNVP_DDGETTRANSFEROUTINFO;

typedef VOID (*PNVP_DX_IRQCALLBACK)(void);

#endif  /* _NVPEOS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\colorctl.c ===
#ifndef NV3_HW
#define COMPILEDINVDD
#else
#undef COMPILEDINVDD
#endif 

#ifdef COMPILEDINVDD


#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif


#ifdef DEBUG
#define TIMEOUT_DMA_XFER 500
#else
#define TIMEOUT_DMA_XFER 42
#endif

// ------------------------------------------------------------------------------------------
// YUV422ColourControl
//      Simulates colour controls on YUV422 surfaces.
//      Returns TRUE if success

#ifdef COMPILEDINVDD //------------------------------------------------------
#define NV_WIN_DEVICE                            0x00002002

#define NV4
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"

#include "vmm.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"

#include "nvddobj.h"
#include "surfaces.h"
#include "timing.h"


extern vpSurfaces             MySurfaces;

extern DWORD vwin32WaitSingleObject( DWORD, DWORD, DWORD );
extern DWORD vwin32ResetWin32Event(DWORD);
extern DWORD vwin32TimeSliceSleep(DWORD);

// requires just the handle passed in

//#undef POLLINGMODE
#define POLLINGMODE

#ifdef POLLINGMODE
#define R0SLEEP(a)        \
{                         \
     _asm { \
    emms \
   }; \
vwin32TimeSliceSleep(a);   \
}
#endif


#define PDRIVERDATA (MySurfaces.pDriverData)

#define WAIT_FOR_FIFO(n) { \
        while (videoFreeCount < n) { \
            NvRmR0Interrupt (((GLOBALDATA*)(MySurfaces.pDriverData))->ROOTHANDLE, NV_WIN_DEVICE); \
            videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE); \
        } \
        videoFreeCount -= n; }

#ifdef POLLINGMODE
#define RESET_OCC_EVENT { \
       while(pPioColourControlEventNotifier[1].status == NV_IN_PROGRESS)  { \
             NvRmR0Interrupt (((GLOBALDATA*)(MySurfaces.pDriverData))->ROOTHANDLE, NV_WIN_DEVICE); \
             R0SLEEP(0)  \
       } \
        pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS; }

#else
#define RESET_OCC_EVENT { \
   _asm { \
    emms \
   }; \
  (vwin32ResetWin32Event((U032)lpProcInfo->hOCCSyncEvent0)); \
  }
#endif

#ifdef POLLINGMODE

#if 1
#define  COLORCTL_039_NOTIFYVALUE     NV039_BUFFER_NOTIFY_WRITE_ONLY
#define WAIT_FOR_OCC_EVENT  while(pPioColourControlEventNotifier[1].status == NV_IN_PROGRESS)  { \
     NvRmR0Interrupt (((GLOBALDATA*)(MySurfaces.pDriverData))->ROOTHANDLE, NV_WIN_DEVICE); \
     R0SLEEP(0)  \
} 
#else
#define  COLORCTL_039_NOTIFYVALUE     NV039_BUFFER_NOTIFY_WRITE_ONLY
#define WAIT_FOR_OCC_EVENT  while(pPioColourControlEventNotifier[1].status == NV_IN_PROGRESS)  { \
      \
} 
#endif

#else
#define  COLORCTL_039_NOTIFYVALUE     NV039_BUFFER_NOTIFY_WRITE_THEN_AWAKEN
#define WAIT_FOR_OCC_EVENT { \
  NvRmR0Interrupt(((GLOBALDATA*)(MySurfaces.pDriverData))->ROOTHANDLE,NV_WIN_DEVICE); \
   _asm { \
    emms \
   }; \
}
#endif


//MarkTiming (WAITOCCCOLORCTL, vwin32WaitSingleObject((U032)lpProcInfo->hOCCSyncEvent0,TIMEOUT_DMA_XFER,0), 1); 
  





BOOL YUV422ColourControl(DWORD  dwPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwSrcOffset, DWORD dwDstOffset, LPDDCOLORCONTROL lpDDCC)
#else  //COMPILEDINVDD ------------------------------------------------------

extern DWORD WaitForIdle(BOOL bWait, BOOL bZeroFreeCount, BOOL bUseEvent);

#define PDRIVERDATA (pDriverData)
#define WAIT_FOR_FIFO(n) { \
        while (videoFreeCount < n) { \
            videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE); \
            if (videoFreeCount < n) NV_SLEEP; \
        } \
        videoFreeCount -= n; }
#define RESET_OCC_EVENT (ResetEvent((HANDLE)lpProcInfo->hOCCSyncEvent3))
#define WAIT_FOR_OCC_EVENT (WaitForSingleObject((HANDLE)lpProcInfo->hOCCSyncEvent3, TIMEOUT_DMA_XFER))

BOOL __stdcall YUV422ColourControl(LPDDRAWI_DDRAWSURFACE_GBL lpGbl, DWORD dwWidth, DWORD dwHeight, DWORD dwSrcOffset, DWORD dwDstOffset, LPDDCOLORCONTROL lpDDCC)

#endif //COMPILEDINVDD ------------------------------------------------------
{

NvNotification *pPioColourControlEventNotifier = PDRIVERDATA->pPioColourControlEventNotifierFlat;
#ifndef COMPILEDINVDD
DDPIXELFORMAT *lpPixelFormat = &lpGbl->ddpfSurface;
#endif //COMPILEDINVDD
DWORD overlayFourCC = 0;
BOOL bOverContrast;
DWORD dwContrast, dwBrightness, cnt, brt;
short hue, sat;

FAST Nv3ChannelPio *npDevVideo = (Nv3ChannelPio *)PDRIVERDATA->NvDevVideoFlatPio;
FAST long videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
DWORD dwYPhase, dwSrcPitch, dwDstPitch;
BOOL doContrastBlt, doLuma, doChroma;
DWORD dwChromaOffset;
LPPROCESSINFO lpProcInfo = NULL;

#ifndef COMPILEDINVDD
    lpProcInfo = pmGetProcess(GetCurrentProcessId());    
#endif
    
#ifdef POLLINGMODE
    if (!PDRIVERDATA->vpp.regOverlayColourControlEnable ||
        !PDRIVERDATA->vpp.fpOverlayShadow)
#else
    if (!PDRIVERDATA->vpp.regOverlayColourControlEnable ||
        !PDRIVERDATA->vpp.fpOverlayShadow ||
        !lpProcInfo ||
        !lpProcInfo->hOCCSyncEvent3)
#endif
        return FALSE;

#ifdef COMPILEDINVDD
    if( (PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags & 0x01 ) != 0x01) {
      // if bit zero is zero this means we should simply return... ie not run
      return 0;
    }
    
    // note there is an assumption here that there is no other way to exit this routine between
    // here and the final return!!!!!!
    // set bit 1 meaning we're now in operation
    PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags = PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags | 0x02;
#endif   

    MarkTiming(ENTERCOLORCTL,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,0);
        
    if (lpDDCC->lContrast > 0xFF) {
        cnt = lpDDCC->lContrast >> 1;
        bOverContrast = TRUE;
    } else {
        cnt = lpDDCC->lContrast;
        bOverContrast = FALSE;
    }
    if(lpDDCC->lBrightness  < 0 ) {
      brt = -lpDDCC->lBrightness;
    } else {
      brt = lpDDCC->lBrightness;
    }
    hue = (short) lpDDCC->lHue;
    sat = (short) lpDDCC->lSaturation;

#ifndef COMPILEDINVDD
    dwSrcPitch = lpGbl->lPitch;
#else
    dwSrcPitch = dwPitch;
#endif
    
#ifndef COMPILEDINVDD
    if (lpPixelFormat->dwFlags & DDPF_FOURCC) {
        overlayFourCC = lpPixelFormat->dwFourCC;
        if (overlayFourCC == MAKEFOURCC('U','Y','V','Y') ||
            overlayFourCC == MAKEFOURCC('U','Y','N','V')) {
            dwContrast   = (cnt << 8) | (cnt << 24) | 0x00FF00FF;
            dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
            dwYPhase = 1;
        } else {
            dwContrast   = cnt | (cnt << 16) | 0xFF00FF00;
            dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
            dwYPhase = 0;
        }
        if (overlayFourCC == MAKEFOURCC('Y','V','1','2') ||
            overlayFourCC == MAKEFOURCC('Y','V','U','9') ||
            overlayFourCC == MAKEFOURCC('I','F','0','9') ||
            overlayFourCC == MAKEFOURCC('I','V','3','1') ||
            overlayFourCC == MAKEFOURCC('I','V','3','2')) {
            dwSrcPitch <<= 1;
            WaitForIdle(TRUE, FALSE, TRUE);   // wait for prior ConvertOverlay to finish
        }
    } else {
        dwContrast   = 0xFFFFFFFF;
        dwBrightness = 0;
        bOverContrast = FALSE;
        dwYPhase = 0;
    }
#else
    dwContrast   = (cnt << 8) | (cnt << 24) | 0x00FF00FF;
    dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
    // dwYPhase is used to act on information about which field we're on in interleaved surfaces
    // So, we need to program it appropriately
    dwYPhase = 1;
#endif //COMPILEDINVDD

    dwDstPitch = dwSrcPitch >> 1;
    dwWidth = (dwWidth + 1) & ~1;      // width must be even
    //if (dwWidth > dwDstPitch)
    //   dwWidth -= 2;

    doContrastBlt = (dwContrast != 0xFFFFFFFF);
    doLuma        = (dwBrightness != 0 || bOverContrast);
    doChroma      = (hue != 0 || sat != 0x100);

#ifndef COMPILEDINVDD
    NV_DD_DMA_PUSHER_SYNC();
#else
    // perhaps should do something here to sync up the dma pushers.... ?
#endif
    
    
    if (pPioColourControlEventNotifier[1].status == NV_IN_PROGRESS)
        WAIT_FOR_OCC_EVENT;
    
    if (doChroma) {
        // Apply a chroma vector scale and rotation
        // [U'] = [ sat*cos(hue)  sat*sin(hue)] [U]
        // [V']   [-sat*sin(hue)  sat*cos(hue)] [V]
        NvNotification *NvPioBufferNotifier = PDRIVERDATA->pDmaBufferNotifierFlat;
        short sinhue, coshue;
        __int64 c1, c2;
        static const __int64 bOneTwentyEight = 0x8080808080808080;
        static const __int64 evenMask        = 0x00FF00FF00FF00FF;
        static const __int64 oddMask         = 0xFF00FF00FF00FF00;
        static const __int64 zero            = 0;
        DWORD dwAdjWidth, j;
        LPBYTE qPtr;
        // sin table normalized to 256
        
        static const short sintable[91] = {  0,  4,  9, 13, 18, 22, 27, 31,
                                            36, 40, 44, 49, 53, 58, 62, 66,
                                            71, 75, 79, 83, 88, 92, 96,100,
                                           104,108,112,116,120,124,128,132,
                                           136,139,143,147,150,154,158,161,
                                           165,168,171,175,178,181,184,187,
                                           190,193,196,199,202,204,207,210,
                                           212,215,217,219,222,224,226,228,
                                           230,232,234,236,237,239,241,242,
                                           243,245,246,247,248,249,250,251,
                                           252,253,254,254,255,255,255,256,
                                           256,256,256 };

        dwChromaOffset = dwDstPitch * dwHeight;

        // move chroma data to system memory
        RESET_OCC_EVENT;
        WAIT_FOR_FIFO(48);

        pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;

        npDevVideo->dDrawSpare.SetObject = NV_VPP_V2OSH_FORMAT_IID;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwSrcOffset + (dwYPhase ^ 1);
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwChromaOffset;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwDstPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwSrcPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x102;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;

        // coefficient calculations
        // possible MMX multiply overflow later, so halve the coefficients now
        // and double the result later with saturation
        if (lpDDCC->lHue <= 90) {
            sinhue = ((long)sat * sintable[hue]) >> 9;
            coshue = ((long)sat * sintable[90 - hue]) >> 9;
        } else if (lpDDCC->lHue <= 180) {
            sinhue = ((long)sat * sintable[180 - hue]) >> 9;
            coshue = ((long)sat * -sintable[hue - 90]) >> 9;
        } else if (lpDDCC->lHue <= 270) {
            sinhue = ((long)sat * -sintable[hue - 180]) >> 9;
            coshue = ((long)sat * -sintable[270 - hue]) >> 9;
        } else {
            sinhue = ((long)sat * -sintable[360 - hue]) >> 9;
            coshue = ((long)sat * sintable[hue - 270]) >> 9;
        }

        // c1 = sat*cos(hue), sat*cos(hue), sat*cos(hue), sat*cos(hue)
        c1 = (__int64)coshue & 0xFFFF;
        c1 |= c1 << 16;
        c1 |= c1 << 32;
        // c2 = -sat*sin(hue), sat*sin(hue), -sat*sin(hue), sat*sin(hue)
        c2 = (__int64)sinhue & 0xFFFF;
        c2 |= ((__int64)-sinhue & 0xFFFF) << 16;
        c2 |= c2 << 32;

        // init MMX const data
        qPtr       = (LPBYTE) (PDRIVERDATA->vpp.fpOverlayShadow + dwChromaOffset);
        dwAdjWidth = (dwWidth + 7) / 8;
        _asm {
            movq        mm0, zero
            movq        mm1, bOneTwentyEight 
		    }

        // while we are doing some host MMX things, overlap with some luma operations
        // since we are main memory throughput bound, DO NOT overlap with operations that touch main memory
        if (doContrastBlt) {
            WAIT_FOR_FIFO(40);

            /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_CONTEXT_BETA4;
            npDevVideo->dDrawSpare.nv4ContextBeta.SetBetaFactor = dwContrast;
            npDevVideo->dDrawSpare.SetObject = NV_DD_SURFACES_2D_A8R8G8B8;
            npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetPitch = (dwSrcPitch << 16) | dwSrcPitch;
            npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetSource = dwSrcOffset;
            if (doLuma)
                // more stuff to do later, do this in place
                npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwSrcOffset;
            else
                npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwDstOffset;
            npDevVideo->dDrawSpare.SetObject = NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT;
            npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointIn = 0;
            npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointOut = 0;
            npDevVideo->dDrawSpare.nv4ImageBlit.Size = (dwHeight << 16) | (dwWidth >> 1);
            PDRIVERDATA->dDrawSpareSubchannelObject = 0;
        }

        if (!doContrastBlt && !doLuma) {
            // luma has not and will not move, do that now
            WAIT_FOR_FIFO(36);

            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwSrcOffset + dwYPhase;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + dwYPhase;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwSrcPitch;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x202;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = 0;
        }

        // wait for chroma to arrive in system memory
        WAIT_FOR_OCC_EVENT;
        //MarkTiming(WAITCHROMAARRIVE,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,10);
        
/*      // commented out because this appears to cause a cache coherency problem (bug in BX?)
        // preload the first 8 scan lines into the cache
        for (j=0; j<8; j++) {
            _asm {
                        mov     esi, qPtr
                        mov     ecx, dwAdjWidth
                        shr     ecx, 2
                preld1: mov     eax, [esi]
                        mov     eax, 0
                        add     esi, 32
                        dec     ecx
                        jnz     preld1
            }
            qPtr += dwDstPitch;
        }
*/
        // do the chroma vector scale and rotation, 2.25 cycles/pixel
        // mm0 = 0
        // mm1 = 128
        // mm2 = sign mask
        // mm3 = data quad / expanded data / result high
        // mm4 = expanded data / result low
        // mm5 = expanded data, UV swapped
        // mm6 = UV swapped quad / expanded swapped data
        // mm7 = work space
        if (PDRIVERDATA->vpp.regOverlayColourControlEnable == 2) {
            // full chroma resolution
            for (j=0; j<dwHeight; j++) {
                _asm {
                            mov         ecx, dwAdjWidth
                            mov         esi, qPtr
                            mov         edi, qPtr
                            mov         ebx, dwDstPitch
                    ;        shl         ebx, 3
                            movq        mm3, [esi]
                            psubb       mm3, mm1
                            movq        mm2, mm0
                            pcmpgtb     mm2, mm3
                            movq        mm4, mm3
                            movq        mm7, mm3
                            punpcklbw   mm4, mm2
                    nextc:  mov         eax, [esi+ebx]  ; U  ; preload cache for next scan line
                            mov         eax, 0          ; V  ; ensure OOE works
                            pmullw      mm4, c1         ; U  ; mm4 = c1 * low(UV)
                            movq        mm6, mm3        ; V  ; mm6 = copy of quad data-128
                            add         esi, 8          ; U  ; next source address
                            psrlq       mm6, 8          ; V  ; mm6 >>= 8
                            pand        mm6, evenMask   ; U  ; mm6 &= 0x00FF00FF00FF00FF
                            psllq       mm7, 8          ; V  ; mm7 <<= 8
                            pand        mm7, oddMask    ; U  ; mm7 &= 0xFF00FF00FF00FF00
                            punpckhbw   mm3, mm2        ; V  ; mm3 = unpacked signed high data
                            pmullw      mm3, c1         ; U  ; mm3 = c1 * high(UV)
                            por         mm6, mm7        ; V  ; mm6 |= mm7, UV are now swapped
                            movq        mm5, mm6        ; U  ; mm5 = quad data with UV swapped
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            add         edi, 8          ; U  ; next destination address
                            pcmpgtb     mm2, mm6        ; V  ; mm2 = sign bits of swapped UV
                            punpcklbw   mm5, mm2        ; U  ; mm5 = unpacked signed low VU data
                            movq        mm7, mm3        ; V  ; move result to mm7 so we can reuse mm3 early
                            movq        mm3, [esi]      ; U  ; mm3 = new data quad
                            punpckhbw   mm6, mm2        ; V  ; mm6 = unpacked signed high VU data
                            pmullw      mm5, c2         ; U  ; mm5 = c2 * low(VU)
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            pmullw      mm6, c2         ; U  ; mm6 = c2 * high(VU)
                            psubb       mm3, mm1        ; V  ; mm3 -= 128
                            paddsw      mm5, mm4        ; U  ; mm5 += mm4
                            paddsw      mm6, mm7        ; V  ; mm6 += mm7
                            dec         ecx             ; U  ; decrement loop count
                            psraw       mm5, 7          ; V  ; downshift result and multiply by 2
                            psraw       mm6, 7          ; U  ; downshift result and multiply by 2
                            pcmpgtb     mm2, mm3        ; V  ; mm2 = sign bits
                            packsswb    mm5, mm6        ; U  ; mm5 = packed(mm5,mm6)
                            paddb       mm5, mm1        ; V  ; mm5 += 128
                            movq        mm7, mm3        ; U  ; mm7 = copy of quad data-128
                            movq        mm4, mm3        ; V  ; mm4 = copy of quad data-128
                            movq        [edi-8], mm5    ; U  ; store data from mm5
                            punpcklbw   mm4, mm2        ; V  ; mm4 = unpacked signed low UV data
                            jnz         nextc
                }
                qPtr += dwDstPitch;
            }
        } else {
            // vertical chroma subsample
            // in this case, ESI is used for source and in-place destination, and EDI is used for next line in destination
            for (j=0; j<dwHeight; j+=2) {
                _asm {
                            mov         ecx, dwAdjWidth
                            mov         esi, qPtr
                            mov         edi, qPtr
                            add         edi, dwDstPitch
                            mov         ebx, dwDstPitch
                            shl         ebx, 1
                    ;        shl         ebx, 3
                            movq        mm3, [esi]
                            psubb       mm3, mm1
                            movq        mm2, mm0
                            pcmpgtb     mm2, mm3
                            movq        mm4, mm3
                            movq        mm7, mm3
                            punpcklbw   mm4, mm2
                    nextc2: mov         eax, [esi+ebx]  ; U  ; preload cache for next scan line
                            mov         eax, 0          ; V  ; ensure OOE works
                            pmullw      mm4, c1         ; U  ; mm4 = c1 * low(UV)
                            movq        mm6, mm3        ; V  ; mm6 = copy of quad data-128
                            add         esi, 8          ; U  ; next source address
                            psrlq       mm6, 8          ; V  ; mm6 >>= 8
                            pand        mm6, evenMask   ; U  ; mm6 &= 0x00FF00FF00FF00FF
                            psllq       mm7, 8          ; V  ; mm7 <<= 8
                            pand        mm7, oddMask    ; U  ; mm7 &= 0xFF00FF00FF00FF00
                            punpckhbw   mm3, mm2        ; V  ; mm3 = unpacked signed high data
                            pmullw      mm3, c1         ; U  ; mm3 = c1 * high(UV)
                            por         mm6, mm7        ; V  ; mm6 |= mm7, UV are now swapped
                            movq        mm5, mm6        ; U  ; mm5 = quad data with UV swapped
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            add         edi, 8          ; U  ; next destination address
                            pcmpgtb     mm2, mm6        ; V  ; mm2 = sign bits of swapped UV
                            movq        mm7, mm3        ; U  ; move result to mm7 so we can reuse mm3 early
                            punpcklbw   mm5, mm2        ; V  ; mm5 = unpacked signed low VU data
                            movq        mm3, [esi]      ; U  ; mm3 = new data quad
                            punpckhbw   mm6, mm2        ; V  ; mm6 = unpacked signed high VU data
                            pmullw      mm5, c2         ; U  ; mm5 = c2 * low(VU)
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            pmullw      mm6, c2         ; U  ; mm6 = c2 * high(VU)
                            psubb       mm3, mm1        ; V  ; mm3 -= 128
                            paddsw      mm5, mm4        ; U  ; mm5 += mm4
                            paddsw      mm6, mm7        ; V  ; mm6 += mm7
                            dec         ecx             ; U  ; decrement loop count
                            psraw       mm5, 7          ; V  ; downshift result and multiply by 2
                            psraw       mm6, 7          ; U  ; downshift result and multiply by 2
                            pcmpgtb     mm2, mm3        ; V  ; mm2 = sign bits
                            packsswb    mm5, mm6        ; U  ; mm5 = packed(mm5,mm6)
                            paddb       mm5, mm1        ; V  ; mm5 += 128
                            movq        mm7, mm3        ; U  ; mm7 = copy of quad data-128
                            movq        mm4, mm3        ; V  ; mm4 = copy of quad data-128
                            movq        [edi-8], mm5    ; U  ; store data from mm5
                            punpcklbw   mm4, mm2        ; V  ; mm4 = unpacked signed low UV data
                            movq        [esi-8], mm5    ; U  ; store same data on next line
                            jnz         nextc2          ; V
                }
                qPtr += dwDstPitch << 1;
            }
        }

        if (!doLuma) {
          // move chroma data to back to video memory
          RESET_OCC_EVENT;
          WAIT_FOR_FIFO(48);
  
          PDRIVERDATA->dDrawSpareSubchannelObject = 0;
          pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;
  
          npDevVideo->dDrawSpare.SetObject = NV_VPP_OSH2V_FORMAT_IID;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwChromaOffset;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + (dwYPhase ^ 1);
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwDstPitch;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x201;
          if (!doLuma) {
              npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;
              WAIT_FOR_OCC_EVENT;
              //MarkTiming(WAITCHROMARETURN,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,20);
            
          } else {
              npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = 0;
          }
        } 
        
    } else if (doContrastBlt) {
        // Contrast Blit, since the hardware can only do multiplies up to one (0xFF),
        // and if the contrast is from 100% to 200%, then divide contrast by 2 and worry
        // about left shift and saturation in the MMX routines below
        WAIT_FOR_FIFO(40);

        /* Trash spare subchannel */
        npDevVideo->dDrawSpare.SetObject = NV_DD_CONTEXT_BETA4;
        npDevVideo->dDrawSpare.nv4ContextBeta.SetBetaFactor = dwContrast;
        npDevVideo->dDrawSpare.SetObject = NV_DD_SURFACES_2D_A8R8G8B8;
        npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetPitch = (dwSrcPitch << 16) | dwSrcPitch;
        npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetSource = dwSrcOffset;
        if (doLuma)
            // more stuff to do later, do this in place
            npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwSrcOffset;
        else
            npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwDstOffset;
        npDevVideo->dDrawSpare.SetObject = NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT;
        npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointIn = 0;
        npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointOut = 0;
        npDevVideo->dDrawSpare.nv4ImageBlit.Size = (dwHeight << 16) | (dwWidth >> 1);
        PDRIVERDATA->dDrawSpareSubchannelObject = 0;
    }

    // OverContrast and Brightness calculations
    if (doLuma) {
        static const __int64 shiftMask   = 0xFEFEFEFEFEFEFEFE;
        static const __int64 cmpOverflow = 0xFFFFFFFFFFFFFFFF;
        DWORD j, dwAdjWidth;
        LPBYTE qPtr;

        // move Y data to system memory
        RESET_OCC_EVENT;
        WAIT_FOR_FIFO(48);

        pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;

        npDevVideo->dDrawSpare.SetObject = NV_VPP_V2OSH_FORMAT_IID;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwSrcOffset + dwYPhase;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = 0;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwDstPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwSrcPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x102;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;

        if (!doChroma) {
            // chroma has not and will not move, do that now
            WAIT_FOR_FIFO(36);

            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwSrcOffset + (dwYPhase ^ 1);
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + (dwYPhase ^ 1);
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwSrcPitch;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x202;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = 0;
        }

        // init MMX const data
        qPtr       = (LPBYTE) PDRIVERDATA->vpp.fpOverlayShadow;
        dwAdjWidth = (dwWidth + 15) / 16;
        _asm {
            movd        mm0, dwBrightness
            punpckldq   mm0, dwBrightness
            movq        mm2, shiftMask
            movq        mm3, cmpOverflow 
		    }

        // wait for luma data to arrive in system memory
        WAIT_FOR_OCC_EVENT;
        //MarkTiming(WAITLUMAARIVE,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,30);
        
        
        if(doChroma) {  
          // move chroma data to back to video memory
          RESET_OCC_EVENT;
          WAIT_FOR_FIFO(48);
  
          PDRIVERDATA->dDrawSpareSubchannelObject = 0;
          pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;
  
          npDevVideo->dDrawSpare.SetObject = NV_VPP_OSH2V_FORMAT_IID;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwChromaOffset;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + (dwYPhase ^ 1);
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwDstPitch;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x201;
          if (!doLuma) {
              npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;
              WAIT_FOR_OCC_EVENT;
              //MarkTiming(WAITCHROMARETURN,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,20);
            
          } else {
              npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = 0;
          }
        }
        
/*
        // preload the first 8 scan lines into the cache
        for (j=0; j<8; j++) {
            _asm {
                        mov     esi, qPtr
                        mov     ecx, dwAdjWidth
                        shr     ecx, 1
                preld2: mov     eax, [esi]
                        mov     eax, 0
                        add     esi, 32
                        dec     ecx
                        jnz     preld2
            }
            qPtr += dwDstPitch;
        }
*/
        // do brightness and/or overcontrast
        // mm0 = brightness
        // mm1 = quad data chunk
        // mm2 = shift mask
        // mm3 = overflow compare value
        // mm4 = compare register
        // mm5 = next quad data chunk
        // mm6 = next compare register
        if (lpDDCC->lBrightness >= 0) {
            if (bOverContrast) {
                // overcontrast and positive brightness, 0.6875 cycles/pixel
                // AND is commented out for performance -> noise in the lowest bit of precision
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwDstPitch
                       ;         shl     ebx, 3
                                movq    mm1, [esi]
                                movq    mm4, mm3
                        nextq1: movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                pcmpgtb mm4, mm1        ; Vi    ; mm4 = sign bit of data[i]
                                add     esi, 16         ; U     ; next source address
                                movq    mm6, mm3        ; Vi+   ; mm6 = overflow compare value
                                add     edi, 16         ; U     ; next destination address
                                psll    mm1, 1          ; Vi    ; mm1 <<= 1
                                pcmpgtb mm6, mm5        ; Ui+   ; mm6 = sign bit of data[i+1]
                       ;         pand    mm1, mm2        ; i    ; mm1 &= 0xFE (since there is no PSLLB)
                                por     mm4, mm1        ; Vi    ; mm4 |= mm1 (saturated result[i])

                                psll    mm5, 1          ; Ui+   ; mm5 <<= 1
                                paddusb mm4, mm0        ; Vi    ; mm4 += brightness
                       ;         pand    mm5, mm2        ; i+   ; mm5 &= 0xFE
                                movq    [edi-16], mm4   ; Ui    ; store result[i]
                                por     mm6, mm5        ; Vi+   ; mm6 |= mm5 (saturated result[i+1])
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                paddusb mm6, mm0        ; Vi+   ; mm6 += brightness
                                dec     ecx             ; U     ; decrement loop count
                                movq    mm4, mm3        ; Vi    ; mm4 = overflow compare value
                                movq    [edi-8], mm6    ; Ui+   ; store result[i+1]
                                jnz     nextq1          ; V
                    }
                    qPtr += dwDstPitch;
                }
            } else {
                // positive brightness only
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwDstPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                        nextq2: movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                paddusb mm1, mm0        ; Vi    ; mm1 += brightness
                                add     esi, 16         ; U     ; next source address
                                add     edi, 16         ; V     ; next destination address
                                dec     ecx             ; U     ; decrement loop count
                                movq    [edi-16], mm1   ; Ui    ; store result[i]
                                paddusb mm5, mm0        ; Vi+   ; mm5 += brightness
                                movq    [edi-8], mm5    ; Ui+   ; store result[i+1]
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                jnz     nextq2          ; V
                    }
                    qPtr += dwDstPitch;
                }
            }
        } else {
            if (bOverContrast) {
                // overcontrast and negative brightness
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwDstPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                                movq    mm4, mm3
                        nextq3: movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                pcmpgtb mm4, mm1        ; Vi    ; mm4 = sign bit of data[i]
                                add     esi, 16         ; U     ; next source address
                                movq    mm6, mm3        ; Vi+   ; mm6 = overflow compare value
                                add     edi, 16         ; U     ; next destination address
                                psll    mm1, 1          ; Vi    ; mm1 <<= 1
                                pcmpgtb mm6, mm5        ; Ui+   ; mm6 = sign bit of data[i+1]
                       ;         pand    mm1, mm2        ; i    ; mm1 &= 0xFE (since there is no PSLLB)
                                por     mm4, mm1        ; Vi    ; mm4 |= mm1 (saturated result[i])

                                psll    mm5, 1          ; Ui+   ; mm5 <<= 1
                                psubusb mm4, mm0        ; Vi    ; mm4 -= brightness
                       ;         pand    mm5, mm2        ; i+   ; mm5 &= 0xFE
                                movq    [edi-16], mm4   ; Ui    ; store result[i]
                                por     mm6, mm5        ; Vi+   ; mm6 |= mm5 (saturated result[i+1])
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                psubusb mm6, mm0        ; Vi+   ; mm6 -= brightness
                                dec     ecx             ; U     ; decrement loop count
                                movq    mm4, mm3        ; Vi    ; mm4 = overflow compare value
                                movq    [edi-8], mm6    ; Ui+   ; store result[i+1]
                                jnz     nextq3          ; V
                    }
                    qPtr += dwDstPitch;
                }
            } else {
                // negative brightness only
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwDstPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                        nextq4: movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                psubusb mm1, mm0        ; Vi    ; mm1 -= brightness
                                add     esi, 16         ; U     ; next source address
                                add     edi, 16         ; V     ; next destination address
                                dec     ecx             ; U     ; decrement loop count
                                movq    [edi-16], mm1   ; Ui    ; store result[i]
                                psubusb mm5, mm0        ; Vi+   ; mm5 -= brightness
                                movq    [edi-8], mm5    ; Ui+   ; store result[i+1]
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                jnz     nextq4          ; V
                    }
                    qPtr += dwDstPitch;
                }
            }
        }

        // move Y data to back to video memory
        RESET_OCC_EVENT;
        WAIT_FOR_FIFO(48);

        pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;

        npDevVideo->dDrawSpare.SetObject = NV_VPP_OSH2V_FORMAT_IID;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = 0;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + dwYPhase;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwDstPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x201;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;
        PDRIVERDATA->dDrawSpareSubchannelObject = 0;

        WAIT_FOR_OCC_EVENT;
        //MarkTiming(WAITLUMARETURN,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,40);
        
    }

    _asm { 
		  emms 
	  };

#ifdef COMPILEDINVDD
    // reset bit 1 meaning we're no longer in operation
    PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags = PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags & 0xFFFFFFFD;
#endif   
    MarkTiming(LEAVECOLORCTL,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,50);
    
    return doContrastBlt || doLuma || doChroma;
}


BOOL WillDoYUV422ColourControl( LPDDCOLORCONTROL lpDDCC)
{

  BOOL bOverContrast;
  DWORD dwContrast, dwBrightness, cnt, brt;
  short hue, sat;
  
  BOOL doContrastBlt, doLuma, doChroma;
  LPPROCESSINFO lpProcInfo = NULL;

#ifndef COMPILEDINVDD
  lpProcInfo = pmGetProcess(GetCurrentProcessId());    
#endif
    
#ifdef POLLINGMODE
  if (!PDRIVERDATA->vpp.regOverlayColourControlEnable ||
      !PDRIVERDATA->vpp.fpOverlayShadow)
#else
  if (!PDRIVERDATA->vpp.regOverlayColourControlEnable ||
      !PDRIVERDATA->vpp.fpOverlayShadow ||
      !lpProcInfo ||
      !lpProcInfo->hOCCSyncEvent3)
#endif
    return FALSE;
  
  if (lpDDCC->lContrast > 0xFF) {
    cnt = lpDDCC->lContrast >> 1;
    bOverContrast = TRUE;
  } else {
    cnt = lpDDCC->lContrast;
    bOverContrast = FALSE;
  }
  if(lpDDCC->lBrightness  < 0 ) {
    brt = -lpDDCC->lBrightness;
  } else {
    brt = lpDDCC->lBrightness;
  }
  hue = (short) lpDDCC->lHue;
  sat = (short) lpDDCC->lSaturation;
  
  
  dwContrast   = (cnt << 8) | (cnt << 24) | 0x00FF00FF;
  dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
  
  doContrastBlt = (dwContrast != 0xFFFFFFFF);
  doLuma        = (dwBrightness != 0 || bOverContrast);
  doChroma      = (hue != 0 || sat != 0x100);
  
  return doContrastBlt || doLuma || doChroma;
}


#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nvmini.asm ===
;       (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
;       Portions Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.
;
;       NVidia Mini-VDD
;
;       Written by:     Mark Stephen Krueger
;       Date:           10/1/96
;               JohnH 10/15/97  spun off version for release 2
;
;       $Revision: 6 $
;       $Date: 6/04/98 6:08p $
;       $Logfile: /resman.050/win96/vdd/nv4.asm $
;       $Log: /resman.050/win96/vdd/nv4.asm $
;
; 6     6/04/98 6:08p Jhinman
; Added WaitTicks call to POST_HIRESTOVGA and POST_VGATOHIRES.
;
; 5     6/02/98 3:49p Schaefer
; partway complete change to enable another level of indirection with the
; setcallback system.
;
; -C-
;
; 4     5/28/98 4:47p Schaefer
; * added callback routines for VBI and Image field completion
;
; 3     5/28/98 10:36a Schaefer
; add functionality for VPE support,  moved data structres into Ring0
; space
;
; 2     5/14/98 4:35p Schaefer
; updated to include KMVT functions in VDD
;
; 1     5/07/98 1:00p Jhinman
; Name change.
;
; 1     5/05/98 5:14p Jhinman
; Gave the mini-VDD a non-chip-specific name.
;
; 28    4/29/98 11:51p Kevink
; Cleaned up NV4 naming (again)
;
; 27    4/29/98 11:14p Kevink
; Fixed an IFDEF
;
; 26    4/28/98 6:20p Kevink
; Added NV4 naming
;
; 24    4/23/98 8:00p Jhinman
; Set DisplayEnabledFlag in PostCRTCModeChange, in case GetVDDBank does
; not get called.
;
; 23    4/16/98 9:07p Jhinman
; Set displayenabledflag in DisplayDriverDisabling and check it in
; RestoreRegisters.
;
; 22    4/01/98 12:09p Jhinman
; Move system vm handle to ebx before save registers/save message mode
; state.
;
; 21    3/30/98 8:40p Jvito
; Don't bother with the cursor HW address registers on a restore.
;
; 20    3/10/98 10:36a Jhinman
; Added comment which fixes "line too long" error.
;
; 19    3/09/98 5:49p Jhinman
; Do the saveRegisters/SaveMessageModeState at pnp_new_devnode.
;
; 18    2/26/98 5:08p Jhinman
; Pass the address of PostCRTCModeChange to the resource manager, so it
; can notify us when a mode change has taken place, and we will save
; registers.
;
; 17    2/24/98 11:22p Jvito
; Code changes to allow the MiniVDD to monitor mode changes in the RM.
;
; 16    2/18/98 3:58p Jvito
; Exit the minivdd_restoreregisters routine if entered by the system.
;
; 15    2/13/98 2:27p Jhinman
; Add device number to the call to resource manager to map device. Add
; amount of video RAM to GetTotalVRAMsize. Add SaveRegisters to
; PostCRTCModeChange.
;
; 14    1/14/98 3:05p Jhinman
; Handle SYSTEM_EXIT message.
;
; 13    1/09/98 2:01p Jhinman
; Split miniVDD from the resource manager again. Load RM and communicate
; with it through its API.
;
; 12    12/17/97 2:29p Jhinman
; Check for Windows 98 before hooking turnVGAon/off. Don't do FindNV3.
;
; 11    12/10/97 11:05a Jhinman
; Enable VGATurnOff/On.
;
; 10    12/02/97 6:10p Jhinman
; pnp_new_devnode: jmp to minivdd_pnp_done if error.
;
; 8     11/21/97 5:56p Jhinman
; Check addresses and IRQ are nonzero before we call rmConfigStart.
;
; 7     11/15/97 11:37a Jhinman
; Enable pnp_new_devnode, but do not hook the pnp handler. Get the config
; from config manager and call configStart in pnp_new_devnode.
;
; 6     11/07/97 6:44p Jhinman
; If P_N_P defined, do plug and play stuff.
;
; 5     10/30/97 6:44p Jhinman
; Changed the way miniVDD communicates the addresses to RM (nvAddr,
; nvPhys, etc. are global).
;
; 4     10/29/97 4:53p Waynek
; Add new Memphis MiniVDD entry points to allow the minivdd to turn off
; access to the VGA resources.
;
; 3     10/29/97 4:29p Jhinman
; Removed the ifdef UNIFY_VXDS and added some debug messages in Plug and
; Play handler.
;
; 2     10/27/97 3:07p Jhinman
; Unified miniVDD/resource manager.
;
;
page            ,132
title           NVidia NV3 Mini-VDD Support Functions
.386p
;

VESA20  equ 1   ; turn on fixup of VBE DDC functions: 
                ; 1) create 1.x EDID from a 2.0 EDID,
                ; 2) read from alternate device addresses (A6, A2, A0)
RM_GET_DDC_CAPS equ     1       ; let RM handle GET DDC CAPABILITES instead of the BIOS

;
.xlist
MINIVDD                 EQU             1               ; this must be defined for minivdd.inc

include         VMM.INC
include         SHELL.INC
include         VWIN32.INC                      ; used for IOCTL for KMVT
include                 VXDLDR.INC
include         DEBUG.INC
include         MINIVDD.INC
include         configmg.inc
include         VNVRMD.INC
include         V86MMGR.INC
include         NVDEF.INC
include         VBE30.INC
include         NVIDIA.INC
IFDEF NVIDIA_COMMON
include         NV_REF.INC
include         NV_MAC.INC
include         NV_SIM.INC
ENDIF ; NVIDIA_COMMON
include         SURFACES.INC
IFDEF NVPE
include         NVPEOS.INC
ENDIF
include         ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

IFDEF   DIOC
extrn           GetDDHAL:near
extrn           NvFillTable:near
extern          NVGetSetCallback:near
extern          NVSetVidTexSuf:near
ENDIF   ;DIOC

IFDEF NVPE
extrn           _nvpeVDDCmdHandler:near
extrn           _nvpeVDDClearState:near
extrn               _nvpeVDDInit:near
ENDIF

IFDEF   I2C
extrn           _vddI2COpen:near
extrn           _vddI2CAccess:near
NOCHANNEL       equ     -1
ENDIF   ;I2C

public                  MiniVDD_BroadcastHandler


; defines needed for Canopus TV extensions

TVB_VBE_FCT             equ 04f14h  ; VBE OEM function number
TVB_VBE_TV_GET          equ 00102h  ; sub function to get the TV flag
TVB_VBE_TV_SET          equ 00202h  ; sub function to set the TV flag
TVB_VBE_TV_CRTC         equ 00302h  ; sub function to get the TV flag CRTC index
TVF_WINDOWS             equ 040h    ; marker for our mini VDD
TVF_INACTIVE            equ 080h    ; no hardware initialisation (of the Chrontel chip)

CANOPUS_TV_REG                  equ             02bh    ;; TV flag register index

; defines needed for Advanced Power Management

WM_POWERBROADCAST                               EQU 218h

PBT_APMQUERYSUSPEND             EQU 0
PBT_APMQUERYSTANDBY             EQU 1

PBT_APMQUERYSUSPENDFAILED       EQU 2
PBT_APMQUERYSTANDBYFAILED       EQU 3

PBT_APMSUSPEND                  EQU 4
PBT_APMSTANDBY                  EQU 5

PBT_APMRESUMECRITICAL           EQU 6
PBT_APMRESUMESUSPEND            EQU 7
PBT_APMRESUMESTANDBY            EQU 8

PBTF_APMRESUMEFROMFAILURE       EQU 1

PBT_APMBATTERYLOW               EQU 9
PBT_APMPOWERSTATUSCHANGE        EQU 0Ah

PBT_APMOEMEVENT                 EQU 0Bh
PBT_APMRESUMEAUTOMATIC          EQU 12h

.list

;**************************************************************************************************************************
subttl          Virtual Device Declaration
page +
;       Then MiniVDD must have the UNDEFINED_DEVICE_ID
;       and it is a dynamic load VxD, so it cannot have a service table.
Declare_Virtual_Device  NVMINI, \
                        3,      \
                        1,      \
                        MiniVDD_Control,        \
                        UNDEFINED_DEVICE_ID,    \
                        VDD_INIT_ORDER,         \
                                                ,                                               \
                        ,                                       \
                        ,

;
;
;**************************************************************************************************************************
subttl          Initialization Data
page +
VxD_IDATA_SEG

VxD_IDATA_ENDS
;
;**************************************************************************************************************************
subttl          Locked Data Area
page +
VxD_LOCKED_DATA_SEG
PUBLIC  dwCallbacksSelector, pfnLockOffscreen, pfnUnlockOffscreen, pfnPowerOn, pfnPowerOff
dwCallbacksSelector     DD      0
pfnLockOffscreen        DD      0
pfnUnlockOffscreen      DD      0
pfnPowerOn              DD      0
pfnPowerOff             DD      0
pfnCurrentCall          DD      0

GetMonInfoCount         DD      -1
dwInt10EntryCount       DD      -1

PUBLIC  dwDisplayDevnodeHandle
dwDisplayDevnodeHandle  DD      0

PUBLIC  szEnumAndMore
szEnumAndMore           DB      "Enum\"
szAndMore               DB      128 DUP(0)
szAllowMightyModes      DB      "AllowMightyModes",0
dwAllowMightyModes      DD      0

PUBLIC  szLocalDisplayPath, szLocalDisplayPathEnd
szLocalDisplayPath      DB      "System\CurrentControlSet\Services\Class\"
szLocalDisplayPathEnd   DB      32 DUP(0)

PUBLIC  szDriver
szDriver        DB      "Driver",0

PUBLIC  szDisplayEndPath
szDisplayEndPath        DB      32 DUP(0)

ALIGN 4
PUBLIC  dwCBType, dwCBLen, hKey
dwCBType        DD      0
dwCBLen         DD      0
hKey            DD      0

EDID1_HEADER    DB      0,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0

; Need to rewrite ReenumerateDevNode routine
; when increase this number!!!
MAX_CRTCS       equ     2
LogicalDevice   DD      MAX_CRTCS DUP (0)

PUBLIC  pDDrawFullScreenDOSActive
pDDrawFullScreenDOSActive       DD      0
VxD_LOCKED_DATA_ENDS
;
;**************************************************************************************************************************
subttl          General Data Area
page +
VxD_DATA_SEG
;
IFDEF DEBUG_LOG
public  DebugOn
DebugOn                 dd      1               ;Should routines log debug info?
;
ENDIF ; DEBUG_LOG
public  WindowsVMHandle
WindowsVMHandle         dd      ?               ;init'd at Device_Init
;
public  PlanarStateID, MessageModeID
PlanarStateID           dd      ?               ;init'd at RegisterPlanarState
MessageModeID           dd      ?               ;init'd at RegisterMessageMode
;
public  OSVersion
OSVersion               dw      ?               ;init'd at Device_Init

public  TotalMemorySize
TotalMemorySize         dd      ?               ;init'd at Sys_Critical_Init
;
public  Vid_PhysA0000
Vid_PhysA0000           dd      0               ;
;
public  OurCBDataPointer
OurCBDataPointer        dd      ?               ;init'd at Device_Init
;
public  MessageModeCBData
MessageModeCBData       db      size PerVMData dup(0)
;
public  ForcedPlanarCBData
ForcedPlanarCBData      db      size PerVMData dup(0)
;
public  MemoryMappedSelector
MemoryMappedSelector    dd      0               ;init'd at RegisterDisplayDriver
;
public  ChipID                                  ;NVidia specific variable!
ChipType                db      3               ;init'd at pnp_new_devnode
;

public  ModeChangeFlags
ModeChangeFlags         db      ?               ;=FFH when in BIOS mode change

public  DosBoxActive
DosBoxActive            db      ?
; Equate used by for API to the RM
NVRM_API_SIGNAL_MODE_SAVE       equ     1000+71
;
public  DisplayEnabledFlag
DisplayEnabledFlag      db      0               ;=FFH when display in HiRes mode
;
public  SuperVGAModeFlag
SuperVGAModeFlag        db      0               ;=FFH when NOT running VGA mode
;
public  MsgModeInitDone
MsgModeInitDone         db      0               ;=FFH when collecting states
;
public  VGAModeFlag
VGAModeFlag             db      0               ;=FFh when in 16 color mode (VGA driver)
;
public  InRefreshSetMode
InRefreshSetMode        db      0               ;=FFH when in int 10 already

SeqIdx                  db      ?
LockValue               db      ?

ResManAPI               dd      0                               ; NVRM API entry point
;
nvPhys                  dd      0                               ; physical address given us by Configuration Manager
fbPhys                  dd      0                               ;         "
fbLength                dd      0               ; 16 or 32 MB
nvIRQ                   dd      0                               ; physical irq       "
nvAddr                  dd      0                               ; linear address used everywhere to access chip
fbAddr                  dd      0
nvCustomer              dd      0                               ; bitmask of current customer support
NVCUSTOMER_CANOPUS      EQU     1
NVCUSTOMER_TOSHIBA      EQU     2
fbBuffer                dd      0
fpDDC                   dd      0
NumUnits                dd      0               ; number of "units" or heads
cursor_pos              dw      0
ChipID                  dd      0                               ; master control boot register
hDev                    dd      0
NVRM_String             db      'NVCORE.VXD',0   ; filename of the resource manager
DevCtlRet               dd      0               ; Dev IOCTL function ret val
ACPI_state              db      0               ; ACPI state 0-3
configStartDone         db      0               ; Flag to protect duplicate call to CONFIG_START
public  DoNotSimulate
DoNotSimulate           db      0
RestoreStdCrtc          db      0
DisplayChanged          db      0
DDC_Caps                dw      0       ; Save DDC Caps
BuffOff                 dw      0       ; V86 buffer passed in to VESASupport
BuffSeg                 dw      0       ;  "
Edid2Map                dw      0
DetTimOff               dw      0
DDCAddrFake             dw      0       ; DDC address map
pEdid1                  dd      0       ; pointer to caller's 128 byte EDID buffer
pEdid2                  dd      0       ; pointer to V86 buffer alloc'd for 256 byte EDID
TempEdidBufOff          dw      0       ; real mode address of our EDID buffer
TempEdidBufSeg          dw      0       ;
EdidAddress             db      0       ; Save device address when retrying EDID reads
DontRecurse             db      0       ; when != just pass down
nDetTim                 db      0
numDevice               db      0       ; number of devices = number of times map config called

; Canopus globals
InFullScreen            db      0
bCanopusTVReg           db      0

; resource manager parameter passing structure.
minivdd_RM_Parameter_Struct struct
  callrm_device_handle        dd      0
  callrm_modechange_callback  dd      0
  callrm_irq_bus              dd      0
  callrm_fbphys               dd      0
  callrm_nvphys               dd      0
  callrm_registry_path        dd      0
minivdd_RM_Parameter_Struct ends
callrm_struct minivdd_RM_Parameter_Struct <>
callrm_rmusrapi minivdd_CALLRM_rmusrapi_Struct <>

;
public  DisplayInfoStructure, refreshRates
DisplayInfoStructure    DISPLAYINFO     <>
;
refreshRates    PRefreshRateStruct Refresh640,Refresh800,Refresh1024,Refresh1280
;
Refresh640      RefreshRateStruct<75,37,<0840,0656,0656+064,0500,0481,0481+3,'-','-',0,DC_031_500,7500>>
                RefreshRateStruct<60,31,<0800,0656,0656+096,0525,0490,0490+2,'-','-',0,DC_025_175,6000>>
                dd      0
;
Refresh800      RefreshRateStruct<75,46,<1056,0816,0816+080,0625,0601,0601+3,'+','+',0,DC_049_500,7500>>
                RefreshRateStruct<72,48,<1040,0856,0856+120,0666,0637,0637+6,'+','+',0,DC_050_000,7200>>
                RefreshRateStruct<60,37,<1056,0840,0840+128,0628,0601,0601+4,'+','+',0,DC_040_000,6000>>
                RefreshRateStruct<56,35,<1024,0824,0824+072,0625,0601,0601+2,'+','+',0,DC_036_000,5600>>
                dd      0
;
Refresh1024     RefreshRateStruct<75,60,<1312,1040,1040+096,0800,0769,0769+3,'+','+',0,DC_078_750,7500>>
                RefreshRateStruct<70,56,<1328,1048,1048+136,0806,0771,0771+6,'-','-',0,DC_075_000,7000>>
                RefreshRateStruct<60,48,<1344,1048,1048+136,0806,0771,0771+6,'-','-',0,DC_065_000,6000>>
                RefreshRateStruct<43,35,<1264,1032,1032+176,0817,0768,0768+4,'+','+',1,DC_044_900,4300>> ; Interlaced
                dd      0
;
Refresh1280     RefreshRateStruct<60,64,<1696,1344,1344+016,1066,1025,1025+3,'+','+',0,DC_108_500,6000>>
                RefreshRateStruct<75,79,<1688,1296,1296+144,1066,1025,1025+3,'+','+',0,DC_135_000,7500>>
                dd      0
;
; EDID 1.0 template
; for creating a phony version 1 EDID when the actual EDID is version 2
EdidTemp        db      0,0ffh,0ffh,0ffh,0ffh,0ffh,0ffh,0   ; header
                db      0,0,0,0,0,0,0,0,1,10                ; vendor/product ID
                db      1,0                                 ; EDID version
                db      0ch,20h,18h,0beh,0e8h               ; display parameters
                db      0e1h,062h,09eh,055h,04ah,098h,027h,012h,048h,04fh ; color characteristics
                db      3   dup(0)                          ; established timings
                db      16  dup(0)                          ; standard timing
                db      72  dup(0)                          ; detailed timing
                db      0                                   ; extension flag
                db      0                                   ; checksum
; end of EDID

EDID1_VENDOR    equ     8
EDID1_SIZE      equ     128
EDID1_DET_TIMING        equ 36h     ;offset to detailed timing

EDID2_VENDOR    equ     1
EDID2_SIZE      equ     256
; EDID 2 offsets and bit defs
EDID2_MAP               equ 7eh     ;offset to map
EDID2_TIMING_START      equ 80h     ;offset to timing
EDID2_LUM_TABLE_EXIST   equ 20h
EDID2_LUM_ENTRIES       equ 1fh
EDID2_LUMX3             equ 80h
EDID2_RL                equ 1ch
EDID2_RL_SHIFT          equ 2
EDID2_DRL               equ 3
EDID2_TIMING_CODES      equ 0f8h
EDID2_TC_SHIFT          equ 3
EDID2_DET_TIMINGS       equ 07h

; DDC bit defs
DDC_ADDR_A0             equ 03h     ; DDC address is A0 (DDC 1 or DDC 2)
DDC_ADDR_A2             equ 08h     ; DDC address is A2 (DDC 2)
DDC_ADDR_A6             equ 10h     ; DDC address is A6 (DDC 2)
DDC_SUBF_1              equ 1       ; DDC read EDID at A0
DDC_SUBF_3              equ 3       ; DDC read EDID at A2
DDC_SUBF_4              equ 4       ; DDC read EDID at A6


VxD_DATA_ENDS
;
;
;**************************************************************************************************************************
subttl          Device Initialization
page +
VxD_ICODE_SEG

;
public  MiniVDD_Dynamic_Init
BeginProc MiniVDD_Dynamic_Init

;
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
;       If success, return NC.
;       If failure, return CY.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_Dyanmic_Init", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx                     ;save Windows VM handle in EBX
        push    ebp
        mov     WindowsVMHandle,ebx     ;save the Windows VM handle
        mov     ModeChangeFlags,0       ;initialize this
        mov     DosBoxActive,0
;ifdef  SEPARATE_RM
;
;       We are the primary display
;       load NV ResMan
;
        mov             edx, OFFSET32 NVRM_String
        mov             eax, VXDLDR_INIT_DEVICE
        VxDcall VXDLDR_LoadDevice
        jc              MVDIErrorExit                   ;failed, nothing we can do

;       returns DDB address in eax and device handle in edx
;       save the API entry
        mov             eax, [eax].DDB_PM_API_Proc
        mov             ResManAPI, eax
;endif  ;SEPARATE_RM

;       Correct the string for multihead configuration
;       Change %s\Unit%d --> %s\U%d
        push    ecx
        push    edx
        push    edi
        mov     eax,0ah
        xor     edi,edi
        VMMCall Get_DDB
        or      ecx,ecx
        jz      @F
        lea     edi,[ecx+18h]
        mov     edx,ASSERT_RANGE_NO_DEBUG OR ASSERT_RANGE_NULL_BAD
        VMMCall _Assert_Range,<edi,4,0,0,edx>
        or      eax,eax
        jz      @F
        mov     edi,[edi]
        lea     edi,[edi+13fch]
        VMMCall _Assert_Range,<edi,4,2574696eh,0,edx>
        or      eax,eax
        jz      @F
        mov     ecx,6425h               ; '%d'
        mov     [edi],ecx
@@:
        ; Initialize LogicalDevice structure.
        lea     edi,LogicalDevice
        sub     ecx,ecx

@@:
        mov     [edi],ecx
        inc     ecx
        add     edi,4
        cmp     ecx,MAX_CRTCS
        jb      @B

        pop     edi
        pop     edx
        pop     ecx
;
;Get the linear address of physical A0000H addressable for 64K:
;
        VMMCall _MapPhysToLinear,<0A0000h,10000h,0>
        cmp     eax,-1                  ;was there an error?
        je      MVDIErrorExit           ;yes, better not load!
        mov     Vid_PhysA0000,eax       ;save this off!

;       clear VPE's global state
        call _nvpeVDDClearState

;       initialize WDM prescale values
        call _nvpeVDDInit
;
public  MVDIGetSpecialVMs
MVDIGetSpecialVMs:
;
;There are two special VM states that the "main" VDD establishes.  The
;first is the planar state which is simply a state that the "main" VDD
;restores to establish the VGA 4 plane mode.  When we restore the states
;at MiniVDD_RestoreRegisterState, we check for the special identifier which
;flags that we're restoring this state.  If we find that we are restoring
;the planar state, we have the opportunity to special case the register
;state restore.
;
;Similarly, there is a special state called "Message Mode".  This is the
;state when the Shell VxD is displaying a full-screen message (usually
;with a blue background) telling the user of a serious anomaly in the
;running state of Windows.  We also retrieve the special VM handle
;for the "Message Mode" state so we can handle it special too if needed.
;
        VxDCall VDD_Get_Special_VM_IDs  ;go get special VM information
        mov     PlanarStateID,esi       ;save off returned identifiers
        mov     MessageModeID,edi       ;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    ":PlanarStateID:%08lX", esi, DEBLEVELMAX
                Debug_Printf    ":MessageModeID:%08lX", edi, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
;
public  MVDIDispatch
MVDIDispatch:
;
;We want to allocate space in the per-VM CB data structure.  This will
;be used by the mini-VDD to store per-VM data relating to states of registers.
;
        VMMCall _Allocate_Device_CB_Area,<<size PerVMData>,0>
        mov     OurCBDataPointer,eax    ;save offset of our VxD's area
        or      eax,eax                 ;was call sucessful?
        jz      MVDIErrorExit           ;nope, leave fatally!
;
;The "master" VDD (VDD.386) contains all of the routines and procedures
;that are necessary to virtualize a standard VGA environment on high
;resolution super-VGA cards.  This "mini-VDD" provides some simple
;services which provide support which are peculiar to the chipset
;that we're providing support for.
;
;We must register the entry point addresses of our chipset-dependent
;routines with the "master" VDD.  To do this, we call a service in the
;"master" VDD, which returns the address of a dispatch table of the
;which is an array of the format:
;
;               dd      Address of support routine in this mini-VDD.
;                       This address will be initialized to 0 by the "master"
;                       VDD.  If we need to implement this functionality,
;                       we fill in the address of our routine.
;
;Then, when the "master" VDD needs to call this function, it'll see if we've
;filled in the address field in for the function's entry and will call our
;routine if the address is filled in.  Otherwise, the VDD will skip the call
;and continue on its way without calling us.
;
;The following function calls the "master" VDD and returns a pointer to the
;dispatch table documented above in EDI and the number of functions
;supported in ECX. If the number of functions returned by the "master" VDD
;is less than what we think it is, we return an error and don't allow
;Windows to continue running.
;
        VxDCall VDD_Get_Mini_Dispatch_Table
        cmp     ecx,NBR_MINI_VDD_FUNCTIONS      ;perform a cursory version check
        jb      MVDIErrorExit                   ;oops, versions don't match!
;
public  MVDIFillInTable
MVDIFillInTable:
;
;Fill in the addresses of all the functions that we need to handle in this
;mini-VDD in the table provided by the "master" VDD whose address is
;contained in EDI.  Note that if you do not need to support a function,
;you do not need to fill in the dispatch table entry for that function.
;If you do not fill in an entry, the "master" VDD won't try to call
;this mini-VDD to support the function.  It'll just handle it in a
;default manner.
;
        MiniVDDDispatch REGISTER_DISPLAY_DRIVER,RegisterDisplayDriver
; if we don't support vitualizing planar mode, we don't need the following 2 functions:
        MiniVDDDispatch GET_VDD_BANK,GetVDDBank
        MiniVDDDispatch SET_VDD_BANK,SetVDDBank
        MiniVDDDispatch RESET_BANK,ResetBank
;We still need these routines for ourselves in RestoreLatches, but the
;main VDD should never call them because we have SaveLatches and
;RestoreLatches.
        MiniVDDDispatch SET_LATCH_BANK,SetLatchBank
        MiniVDDDispatch RESET_LATCH_BANK,ResetLatchBank
;        MiniVDDDispatch SAVE_LATCHES,SaveLatches
;        MiniVDDDispatch RESTORE_LATCHES,RestoreLatches
        MiniVDDDispatch PRE_HIRES_TO_VGA,PreHiResToVGA
        MiniVDDDispatch POST_HIRES_TO_VGA,PostHiResToVGA
        MiniVDDDispatch PRE_VGA_TO_HIRES,PreVGAToHiRes
        MiniVDDDispatch POST_VGA_TO_HIRES,PostVGAToHiRes
        MiniVDDDispatch SAVE_REGISTERS,SaveRegisters
        MiniVDDDispatch RESTORE_REGISTERS,RestoreRegisters
        MiniVDDDispatch DISPLAY_DRIVER_DISABLING,DisplayDriverDisabling
        MiniVDDDispatch GET_TOTAL_VRAM_SIZE,GetTotalVRAMSize
        MiniVDDDispatch GET_CURRENT_BANK_WRITE,GetCurrentBankWrite
        MiniVDDDispatch GET_CURRENT_BANK_READ,GetCurrentBankRead
        MiniVDDDispatch GET_BANK_SIZE,GetBankSize
        MiniVDDDispatch SET_BANK,SetBank
        MiniVDDDispatch PRE_HIRES_SAVE_RESTORE,PreHiResSaveRestore
        MiniVDDDispatch POST_HIRES_SAVE_RESTORE,PostHiResSaveRestore
        MiniVDDDispatch CHECK_SCREEN_SWITCH_OK,CheckScreenSwitchOK
        MiniVDDDispatch GET_CHIP_ID,GetChipID
        MiniVDDDispatch VIRTUALIZE_SEQUENCER_OUT,VirtSeqOut
        MiniVDDDispatch VIRTUALIZE_SEQUENCER_IN,VirtSeqIn
        MiniVDDDispatch ENABLE_TRAPS,EnableTraps
        MiniVDDDispatch DISABLE_TRAPS,DisableTraps
        MiniVDDDispatch MAKE_HARDWARE_NOT_BUSY,MakeHardwareNotBusy
        MiniVDDDispatch VIRTUALIZE_CRTC_OUT,VirtCRTCOut
        MiniVDDDispatch VIRTUALIZE_CRTC_IN,VirtCRTCIn
        MiniVDDDispatch PRE_CRTC_MODE_CHANGE,PreCRTCModeChange
        MiniVDDDispatch POST_CRTC_MODE_CHANGE,PostCRTCModeChange
        MiniVDDDispatch SAVE_FORCED_PLANAR_STATE,SaveForcedPlanarState
        MiniVDDDispatch SAVE_MESSAGE_MODE_STATE,SaveMessageModeState
        MiniVDDDispatch VESA_SUPPORT,VESASupport
        MiniVDDDispatch GET_MONITOR_INFO,GetMonitorInfo
        ;===============================================
        ;
        ; new Win98 functions...
        ;
        VMMcall Get_VMM_Version
        mov OSVersion,ax        ; save OS version
        jc  PreWin98
        cmp   ax,VERS_WIN98
        jb    PreWin98
;         cmp   ax,045ah
;         jb    PreMillen
IFDEF   I2C
        ;I2C functions
          MiniVDDDispatch I2C_OPEN, I2COpen
          MiniVDDDispatch I2C_ACCESS, I2CAccess
ENDIF   ;I2C
        ;These are required for multi-display support
          MiniVDDDispatch TURN_VGA_OFF,TurnVgaOff
          MiniVDDDispatch TURN_VGA_ON,TurnVgaOn
        ;This is required if the device supports multiple displays
          MiniVDDDispatch GET_NUM_UNITS,GetNumUnits
        ;These are for power management. We don't need the monitor functions, since Windows will use VESA calls
        ; if we don't hook them.
;ifdef   ON_NOW
        pushad
        mov     eax,OFFSET32 DisplayInfoStructure
        mov     ecx,SIZE DISPLAYINFO    ;pass size in ECX, address in EAX
        mov     [eax].diHdrSize,cx      ;fill in this entry
        push    eax                     ;save EAX --> DisplayInfoStructure
        VxDCall VDD_Get_DISPLAYINFO     ;get information from the VDD
        pop     edi                     ;restore EAX --> DisplayInfoStructure
        mov     VGAModeFlag,0
        cmp     [edi].diBpp,4           ;16 color?
        je      SkipAdapterPM
        
        popad

        MiniVDDDispatch SET_MONITOR_POWER_STATE,SetMonitorPowerState
        MiniVDDDispatch GET_MONITOR_POWER_STATE_CAPS,GetMonitorPowerStateCaps
        MiniVDDDispatch SET_ADAPTER_POWER_STATE,SetAdapterPowerState
        MiniVDDDispatch GET_ADAPTER_POWER_STATE_CAPS,GetAdapterPowerStateCaps
        jmp     PreWin98

SkipAdapterPM:
        popad
;endif
PreWin98:
        ;===============================================

;
public  MVDI_SetupPortTrapping
MVDI_SetupPortTrapping:
;Trapping ports 3D0-3D3 is required on Win95 because it splits word accesses into bytes.
;Our HW cannot deal with bytes accesses, so I trap the access and reconstruct byte I/O
;into word I/O. If the system VM is the owner, it's windowed DOS, and I do not let the I/O thru.
;Win95 gives us system_exit, sys_vm_terminate, etc. so when windows exits, we let the I/O thru
;even if it is the system VM. However, Win98 & later OS's don't give us the sys_VM_terminate msg.
;Since we don't have a means to detect system exit, we better not trap. Fortunately, these OS's
;also don't split up the I/O.

        mov   ax,OSVersion
        cmp   ax,VERS_WIN98     
        jae   @f                

;
;Now comes the hard part (conceptually).  We must call the "master" VDD to
;setup port trapping for any port that the Windows display driver would
;write to (or read from) in order to draw onto the display when it's
;running in Windows Hi-Res mode.  For example, on the IBM 8514/A display
;card, the hardware BLTer is used to draw onto the screen.  Ports such as
;9AE8H, E2E8H, BEE8H are used on the 8514/A to perform the drawing.  The
;VDD "system" must set I/O port traps on these registers so that we are
;informed that the Windows display driver is writing or reading these
;ports. Only set traps on those ports which the display driver would
;write or read in the process of drawing.
;
; On NV chips, the CRTC extended registers are used, along with the linear
; frame buffer and the 64KB memory mapped channel to the NV chip FIFO.
; The display driver will register the channel and linear frame buffer, but
; we have to register the NV VGA real mode access registers that the BIOS
; uses. These remained trapped while Windows is running, but our port simulator
; routine checks whether it has been called from the Windows VM (in which case it ignores
; the trap) or someone else (it accesses the register).
IFDEF NVIDIA_COMMON
        mov     edx,003D0h              ;register port 003D0h
        mov     ecx,OFFSET32 MiniVDD_VirtualRealModeAccess
        VxDCall VDD_Takeover_VGA_Port
        mov     edx,003D1h              ;register port 003D1h
        mov     ecx,OFFSET32 MiniVDD_VirtualRealModeAccess
        VxDCall VDD_Takeover_VGA_Port
        mov     edx,003D2h              ;register port 003D2h
        mov     ecx,OFFSET32 MiniVDD_VirtualRealModeAccess
        VxDCall VDD_Takeover_VGA_Port
        mov     edx,003D3h              ;register port 003D3h
        mov     ecx,OFFSET32 MiniVDD_VirtualRealModeAccess
        VxDCall VDD_Takeover_VGA_Port
ENDIF ; NVIDIA_COMMON
@@:
        mov             eax, OFFSET32 MiniVDD_BroadcastHandler
        VxDcall _SHELL_HookSystemBroadcast, < eax, 0, 0 >

        ; Hook Int 10 so we can intercept the DDC calls
        mov     eax, 10h
        mov     esi, OFFSET32 MiniVDD_Int10Handler
        VxDcall Hook_V86_Int_Chain
;
; CANOPUS SUPPORT - detect if TV interface is present
;
;   Because we might need to change the CRTC index register we use to support TV, we
;       will get it from the bios and dynamicly handle the one we get.
MVDI_GetCanopusTVIndex:
        push    bx                      ;--- save regs

        mov ax, TVB_VBE_FCT             ; VBE OEM function
        mov     bx, TVB_VBE_TV_CRTC     ; get CRTC index to flag register
        push    010h                    ; call int 0x10
        VMMCall Exec_VxD_Int            ; execute interrupt

        cmp ax, 0004fh                  ; success ???
        je  MVDI_SaveTVIndex            ; yes, go on and save index
        xor bl, bl                      ; just set it to zero to mark, that we don't support it
MVDI_SaveTVIndex:
        mov bCanopusTVReg, bl           ; just save the value

        pop bx                          ;--- restore regs

;
MVDIGoodExit:
        clc                             ;return success
        jmp     MVDIExit                ;
;
MVDIErrorExit:
        stc
;
MVDIExit:
        pop     ebp
        pop     ebx                     ;restore Windows VM handle to EBX
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_Dynamic_Init
;

; Imhoff - Message handler for broadcast messages... We are interested in
; the WM_POWERBROADCAST message in order to do some kind of simple blanking
; of the monitor during suspend/standby... This addresses a problem we have seen
; under Win95 OSR2 where the monitor does not get blanked at all...

; JohnH - besides blanking the screen, which we do in the RM, this also prevents a problem on the Dell Optiplex system:
; a few seconds after going into Suspend, we get a Resume message. Adding this handler prevents us from leaving Suspend
; too soon.
; Apparently the sequence is this: RM gets Suspend (VxD Control message). Mini-VDD gets Suspend (System message).
; RM gets Resume (Control message). Mini-VDD gets another Suspend (System message). The second System Suspend message
; lets us blank the screen again after the RM Resume turned on the screen, so we will suspend until activity causes us
; to get a legitimate Resume.
; This may be a bug in APM in one of the other device's drivers on the Dell Optiplex. It doesn't occur like this on most
; machines.
;--------------------------------------------------------------------------
BeginProc       MiniVDD_BroadcastHandler, DOSVM

ArgVar  dwMessage, DWORD
ArgVar  dwParam, DWORD
ArgVar  dwlParam, DWORD
ArgVar  dwRef, DWORD

                EnterProc

                cmp     ACPI_state,0
                jne     PS_Exit

                cmp     dwMessage, WM_POWERBROADCAST ;218h
                jnz     PS_Exit


                cmp     dwParam, PBT_APMRESUMESUSPEND
                jz      PS_Resume

                cmp     dwParam, PBT_APMSUSPEND
                jz              PS_Suspend

                cmp     dwParam, PBT_APMRESUMESTANDBY
                jz      PS_Resume

                cmp     dwParam, PBT_APMSTANDBY
                jz              PS_Suspend

                jmp     PS_Exit

PS_Suspend:
                
                REG_RD08(NV_PRMCIO_CRX__COLOR)  ; Save Index
                mov ah, al

                mov al, 1Fh                                             ; Unlock Extended Regs
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                mov al, 57h
                REG_WR08(NV_PRMCIO_CRE__COLOR)

                ; Determine what type of display is being driven                
                mov al,28h
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  
                test al,80h
                jz  PS_CRT
                
                mov al,33h
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  
                test al,1h
                jz  PS_TV      ; it's not a DFP, it's a TV
                
                ; It's a DFP                
                push eax
                REG_RD32(NV_PRAMDAC_FP_DEBUG_0)
                or  eax,010000000h                                      ; assert PWRDOWN_FPCLK
                REG_WR32(NV_PRAMDAC_FP_DEBUG_0)
                pop  eax
                jmp skip_nvt1

PS_TV:          ; We need to turn off the TV encoder. This is problematic, so unless we're asked
                ; to do so by a customer, just treat it like a CRT.
                                

PS_CRT:                
                ; If we disable syncs, turn off DAC also
                ; a signal on RGB with syncs off may confuse the CRT
                push eax
                REG_RD32(NV_PRAMDAC_TEST_CONTROL)
                or  eax,00010000h                                       ; assert PWRDWN_DAC
                REG_WR32(NV_PRAMDAC_TEST_CONTROL)
                pop  eax
                                                
                mov al, 1Ah
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  ; Turn Off Vert Sync
                or al, 40h

                ; Canopus/Toshiba workaround due to ACPI patents
                ;
                ; do this always
                ;
                ;test nvCustomer, NVCUSTOMER_TOSHIBA
                ;jnz  skip_nvt1
                or al, 0c0h

skip_nvt1:

                REG_WR08(NV_PRMCIO_CRE__COLOR)

                mov al, 1Fh                                             ; Lock Extended Regs
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                mov al, 0
                REG_WR08(NV_PRMCIO_CRE__COLOR)

                mov al, ah
                REG_WR08(NV_PRMCIO_CRX__COLOR)  ; Restore Index

                jmp             PS_Exit

PS_Resume:
                REG_RD08(NV_PRMCIO_CRX__COLOR)  ; Save Index
                mov ah, al

                mov al, 1Fh                                             ; Unlock Extended Regs
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                mov al, 57h
                REG_WR08(NV_PRMCIO_CRE__COLOR)
                
                ; Determine what type of display is being driven                
                mov al,28h
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  
                test al,80h
                jz  PSR_CRT
                
                mov al,33h
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  
                test al,1h
                jz  PSR_TV      ; it's not a DFP, it's a TV
                
                ; It's a DFP                
                push eax
                REG_RD32(NV_PRAMDAC_FP_DEBUG_0)
                and  eax,0EFFFFFFFh                                      ; deassert PWRDOWN_FPCLK
                REG_WR32(NV_PRAMDAC_FP_DEBUG_0)
                pop  eax
                jmp skip_nvt2

PSR_TV:         ; We need to turn off (in suspend) & on the TV encoder. This is problematic, so unless we're asked
                ; to do so by a customer, just treat it like a CRT.
                                

PSR_CRT:                
                ; power the DAC up
                push eax
                REG_RD32(NV_PRAMDAC_TEST_CONTROL)
                and  eax,0FFFEFFFFh                                     ; deassert PWRDWN_DAC
                REG_WR32(NV_PRAMDAC_TEST_CONTROL)
                pop  eax

                mov al, 1Ah
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)
                and al, not 40h

                ; Canopus/Toshiba workaround due to ACPI patents
                ;
                ; do this always
                ;
                ;test nvCustomer, NVCUSTOMER_TOSHIBA
                ;jnz skip_nvt2
                and al, not 0c0h
skip_nvt2:

                REG_WR08(NV_PRMCIO_CRE__COLOR)

                mov al, 1Fh                                             ; Lock Extended Regs
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                mov al, 0
                REG_WR08(NV_PRMCIO_CRE__COLOR)

                mov al, ah
                REG_WR08(NV_PRMCIO_CRX__COLOR)  ; Restore Index

PS_Exit:

                mov             eax, 1

                LeaveProc
                Return

EndProc         MiniVDD_BroadcastHandler

;----------------------------------------
public  MiniVDD_TurnVgaOff
BeginProc       MiniVDD_TurnVgaOff, DOSVM

                push    eax
                push    esi

                ;Disable VGA through the VGA Enable IO register.
                REG_RD08(NV_PRMVIO_VSE2)
                and al,0feh
                REG_WR08(NV_PRMVIO_VSE2)

                ; This comment is only here to fix a line too long compiler error.

                ;Disable NV PCI IO, bit0 = 0.
                REG_RD32(NV_PBUS_PCI_NV_1)
                and     al,0feh
                REG_WR32(NV_PBUS_PCI_NV_1)

                ;Disable NV interrupts.
;                xor     eax,eax
;                REG_WR32(NV_PMC_INTR_EN_0)


                pop     esi
                pop     eax

                ret
EndProc         MiniVDD_TurnVgaOff
;
;----------------------------------------
public  MiniVDD_TurnVgaOn
BeginProc       MiniVDD_TurnVgaOn, DOSVM

                push    eax
                push    esi

                ;Enable NV PCI IO, bit0 = 1.
                REG_RD32(NV_PBUS_PCI_NV_1)
                or      al,01h
                REG_WR32(NV_PBUS_PCI_NV_1)

                ;Enable VGA through the VGA Enable IO register.
                REG_RD08(NV_PRMVIO_VSE2)
                or al,01h
                REG_WR08(NV_PRMVIO_VSE2)

                ;Enable NV interrupts.
                xor     eax,eax
                mov     al,1
                REG_WR32(NV_PMC_INTR_EN_0)

                pop     esi
                pop     eax

                ret
EndProc         MiniVDD_TurnVgaOn

;----------------------------------------
;Entry: none
;Exit:  ax = number of heads (crtc's)
public MiniVDD_GetNumUnits
BeginProc       MiniVDD_GetNumUnits, DOSVM
                pushad
;               Ask the RM how many heads are supported
                mov     ebx, DEFAULT_PRIMARY_HDEV
                mov     eax, NVRM_API_NUM_HEADS     ; load up the function number
                call    CallRM                      ; go to RM's API procedure
                mov     eax,ebx                     ; return in eax
                mov     NumUnits,eax                ; save in static area

;               We cannot run dual heads in VGA mode. Find out if we are in 16 color mode.
                cmp     eax,2                   ; dual CRTC device?
                jl      NumUnitsGotten          ; no, then the mode doesn't matter

;               Get Display Info from VDD
                push    ecx
                push    edi
                mov     eax,OFFSET32 DisplayInfoStructure
                mov     ecx,SIZE DISPLAYINFO    ;pass size in ECX, address in EAX
                mov     [eax].diHdrSize,cx      ;fill in this entry
                push    eax                     ;save EAX --> DisplayInfoStructure
                VxDCall VDD_Get_DISPLAYINFO     ;get information from the VDD
                pop     edi                     ;restore EAX --> DisplayInfoStructure
                mov     VGAModeFlag,0
                cmp     [edi].diBpp,4           ;16 color?
                jne     @f
                mov     VGAModeFlag,0FFh
                mov     NumUnits,1              ;Don't allow dual head if VGA.DRV is running!
@@:
                pop     edi
                pop     ecx
NumUnitsGotten:

                popad
                mov     eax,NumUnits            ;restore eax
                ret
EndProc         MiniVDD_GetNumUnits
;
VxD_ICODE_ENDS
;
;**************************************************************************************************************************
subttl          Dispatch Table for VMM Calling This Mini-VDD
page +
VxD_LOCKED_CODE_SEG
;
;
Begin_Control_Dispatch  MiniVDD
        Control_Dispatch SYS_DYNAMIC_DEVICE_INIT, MiniVDD_Dynamic_Init  ;init function for dynamic VXD
        Control_Dispatch PnP_New_DevNode, MiniVDD_PnP_New_DevNode ;init function for new pnp devnode
;        Control_Dispatch DEVICE_INIT, MiniVDD_Device_Init                              ;init function for static VXD (not us!)
        Control_Dispatch SYSTEM_EXIT, MiniVDD_System_Exit
        Control_Dispatch SYS_VM_TERMINATE, MiniVDD_Sys_VM_Terminate             ;try to release traps here
        Control_Dispatch CREATE_VM, MiniVDD_CreateVM
        Control_Dispatch DESTROY_VM, MiniVDD_DestroyVM


IFDEF DIOC
            Control_Dispatch W32_DEVICEIOCONTROL, MiniVDD_W32_DIOC
ENDIF ;DIOC

End_Control_Dispatch MiniVDD
;

PUBLIC  MiniVDD_GetMonitorInfo
BeginProc       MiniVDD_GetMonitorInfo,CCALL
ArgVar  pDevNode, DWORD
ArgVar  nUnitNum, DWORD
ArgVar  pEdidBuf, DWORD

        EnterProc
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi

        ; Stop enumeration if there is no heads anymore.
        mov     ecx,nUnitNum
        cmp     ecx,NumUnits
        mov     eax,CR_FAILURE
        jge     DoneGMI

        ; Use the logical unit number to get the physical head from
        ; the LogicalDevice table.
        lea     ebx,LogicalDevice
        shl     ecx,2
        mov     ecx,ds:[ebx + ecx]

        ; Let Windows gets EDID from the ZERO head only once.
        ; This allow Windows to show RRates list in
        ; the property page -> settings -> adapter tab.
        cmp     GetMonInfoCount,-1
        jne     @F

        ; Provide the head number for Int10Handler
        mov     GetMonInfoCount,ecx

        ; Force VESAReadEDID call
        mov     eax,CR_DEFAULT
        jmp     DoneGMI
@@:
        ; ecx = Head number
        push    pEdidBuf
        push    ecx
        push    pDevNode
        call    GetEdidAndRemapIt
        add     esp,0CH

DoneGMI:
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        LeaveProc
        Return
EndProc MiniVDD_GetMonitorInfo


PUBLIC  GetEdidAndRemapIt
BeginProc       GetEdidAndRemapIt,CCALL
ArgVar  pDevNode, DWORD
ArgVar  nPhysHeadNum, DWORD
ArgVar  pEdidBuf, DWORD

        EnterProc
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi

        mov     eax,NVRM_API_READ_EDID
        mov     ebx,DEFAULT_PRIMARY_HDEV
        mov     ecx,nPhysHeadNum
        call    CallRM

        ; Returns a ptr to the EDID in eax. If NULL, no EDID
        or      eax,eax
        je      ZeroEdid

        push    pEdidBuf
        push    eax
        call    CopyEdidOrTranslate2To1
        add     esp,8
        cmp     eax,CR_SUCCESS
        jne     ZeroEdid

        ; If the AllowMightyModes key exists, then we munge the EDID.
        ; We keep the manufacturer, etc, but change the EDID so that
        ; pretty much any mode is OK.

        push    pDevNode
        call    BuildDisplayPathXXXX
        add     esp,4

        ; Copy the path "System\CurrentControlSet....\Display\000X"
        ; into szAndMore
        lea     edx,szLocalDisplayPath
        lea     ebx,szAndMore
@@:     mov     al,[edx]
        inc     edx
        mov     [ebx],al
        inc     ebx
        or      al,al
        jne     @B

        ; Now tack on the "Display" path
        dec     ebx
        mov     byte ptr ds:[ebx + 00],'\'
        mov     byte ptr ds:[ebx + 01],'N'
        mov     byte ptr ds:[ebx + 02],'V'
        mov     byte ptr ds:[ebx + 03],'i'
        mov     byte ptr ds:[ebx + 04],'d'
        mov     byte ptr ds:[ebx + 05],'i'
        mov     byte ptr ds:[ebx + 06],'a'
        mov     byte ptr ds:[ebx + 07],'\'
        mov     byte ptr ds:[ebx + 08],'D'
        mov     byte ptr ds:[ebx + 09],'i'
        mov     byte ptr ds:[ebx + 10],'s'
        mov     byte ptr ds:[ebx + 11],'p'
        mov     byte ptr ds:[ebx + 12],'l'
        mov     byte ptr ds:[ebx + 13],'a'
        mov     byte ptr ds:[ebx + 14],'y'
        mov     byte ptr ds:[ebx + 15],0

        mov     hKey,0
        mov     esi,OFFSET szAndMore
        mov     eax,OFFSET hkey
        VMMCall _RegOpenKey, <HKEY_LOCAL_MACHINE,esi,eax>
        or      eax,eax
        mov     eax,CR_SUCCESS
        jne     DoneGER

        ; Now Read the display sub path
        mov     dwAllowMightyModes,0
        mov     dwCBType,REG_BINARY
        mov     dwCBLen,4
        mov     eax,OFFSET dwCBType
        mov     ebx,OFFSET dwAllowMightyModes
        mov     ecx,OFFSET dwCBLen
        mov     edx,OFFSET szAllowMightyModes
        VMMCall _RegQueryValueEx, <hKey, edx, 0, eax, ebx, ecx>

        ; CLose the key and zero it out.
        VMMCall _RegCloseKey, <hKey>
        mov     hKey,0

        ; So did we get back something non-0?
        mov     eax,CR_SUCCESS
        cmp     dwAllowMightyModes,0
        je      DoneGER

        ; OK, to allow all modes, we must dummy up an EDID
        push    pEdidBuf
        call    BuildMightyVersion1Edid
        add     esp,4
        mov     eax,CR_SUCCESS
        jmp     DoneGER

ZeroEdid:
        ; OK, we didn't get and EDID for this head. Unfortunately,
        ; we can't return CR_FAILURE in this case since I have
        ; found that if we return CR_FAILURE for nUnitNum=0, then
        ; we don't even get called for nUnitNum=1 (even if we are
        ; on a multihead board.) So, zero out the EDID buffer and
        ; return CR_SUCCESS.
        mov     ecx,80H / 4
        sub     eax,eax
        mov     edi,pEdidBuf
        rep     stosd
        mov     eax,CR_SUCCESS

DoneGER:
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        LeaveProc
        Return
EndProc GetEdidAndRemapIt


PUBLIC  CopyEdidOrTranslate2To1
BeginProc CopyEdidOrTranslate2To1,CCALL
ArgVar  pSrcBuf, DWORD
ArgVar  pDstBuf, DWORD

        EnterProc
        push    esi
        push    edi

        ; We got an EDID. The main VDD can only handle Version 1
        ; EDIDs, though, so if this is a version 2, then convert
        ; it to a version 1.
        mov     esi,pSrcBuf
        lea     edi,EDID1_HEADER
        mov     edx,esi
        mov     ecx,8
        repe    cmpsb
        je      DO_CopyEdid1
        cmp     byte ptr [edx],2
        je      DO_XlatEdid2

        ; Neither kind so return failure.
        mov     eax,CR_FAILURE
        jmp     Done_COT

DO_CopyEdid1:
        ; Copy EDID from SrcBuf to Dst Buf
        mov     esi,pSrcBuf
        mov     edi,pDstBuf
        mov     ecx,80H
        rep     movsb
        mov     eax,CR_SUCCESS
        jmp     Done_COT

DO_XlatEdid2:
        push    pDstBuf
        push    pSrcBuf
        call    TranslateEdid2ToEdid1
        add     esp,8
        mov     eax,CR_SUCCESS

Done_COT:
        pop     edi
        pop     esi
        LeaveProc
        Return
EndProc CopyEdidOrTranslate2To1


PUBLIC  TranslateEdid2ToEdid1
BeginProc TranslateEdid2ToEdid1,CCALL
ArgVar  pSrcBuf, DWORD
ArgVar  pDstBuf, DWORD

        EnterProc
        push    esi
        push    edi

        ; For xlatting, do minimum work needed to make VDD happy.
        ; This includes the product/vendor ID and some detailed timings.

        ; copy template
        mov     edi,pDstBuf
        mov     esi,offset32 EdidTemp
        mov     ecx,EDID1_SIZE
        rep     movsb

        ; copy vendor/product ID
        mov     esi,pSrcBuf
        mov     edi,pDstBuf
        mov     ax,[esi+EDID2_VENDOR]
        mov     [edi+EDID1_VENDOR],ax

        ; Copy detailed timings.
        ; We have to parse a bunch of fields to find them first.
        ; map of timing info tells where to start

        mov     ax,[esi+EDID2_MAP]
        mov     Edid2Map,ax
        mov     ecx,EDID2_TIMING_START

        ; any lum tables?
        test    al, EDID2_LUM_TABLE_EXIST
        jz      AEdid_rl

        ; advance beyond lum table
        mov     ah,[esi+ecx]            ; get 1st byte of timing table
        mov     al,ah
        and     al,EDID2_LUM_ENTRIES    ; get # of lum tables entries
        test    ah,EDID2_LUMX3          ; triple lum tables?
        jz      @f
        mov     bl,3
        mul     bl                      ; triple entries
@@:     add     al,1                    ; bump index beyond lum table
        add     cl,al

AEdid_rl:
        mov     ax,Edid2Map
        and     al,EDID2_RL             ; any range limits?
        jz      AEdid_drl

        ; advance beyond range limits
        shr     al,EDID2_RL_SHIFT
        mov     bl,8
        mul     bl                      ; 8-byte range limits
        add     cl,al

AEdid_drl:
        mov     ax,Edid2Map
        test    al,EDID2_DRL            ; any detailed range limits?
        jz      AEdid_tc

        ; advance beyond detailed range limits
        and     al,EDID2_DRL
        mov     bl,27
        mul     bl                      ; 27-byte detailed range limits
        add     cl,al

AEdid_tc:
        mov     ax,Edid2Map             ; get 2nd byte of map
        and     ah,EDID2_TIMING_CODES
        jz      AEdid2_dt
        shr     ah,EDID2_TC_SHIFT
        mov     al,ah
        mov     bl,4
        mul     bl                      ; 4-byte timing codes
        add     cl,al

AEdid2_dt:
        ; now we are finally at the detailed timings
        mov     ax,Edid2Map
        and     ah,EDID2_DET_TIMINGS
        mov     al,ah
        mov     bl,18
        mul     bl                      ; 18-byte detailed timings
        mov     nDetTim,al
        mov     DetTimOff,cx            ; offset within edid2 struct
                                        ;   to detailed timings

        ; copy all detailed timings to edid1
        add     edi,EDID1_DET_TIMING    ; point to edid1 detailed timings
        add     esi,ecx                 ; point to edid2 detailed timings
        xor     ecx,ecx
        mov     cl,nDetTim
        rep     movsb

        ; generate 8 bit checksum
        mov     ecx,EDID1_SIZE
        mov     edi,pEdid1
        xor     ax,ax
AEdidCs:
        add     al,[edi+ecx-1]
        loop    AEdidCs
        neg     al
        mov     [edi+EDID1_SIZE-1],al

        pop     edi
        pop     esi
        LeaveProc
        Return
EndProc TranslateEdid2ToEdid1

; We currently have a version 1 EDID.
; Change it so that it says it can do pretty much any mode.
; Let's try making one of the timing descriptors handle anything.
PUBLIC  BuildMightyVersion1Edid
BeginProc BuildMightyVersion1Edid,CCALL
ArgVar  pEdidBuf, DWORD

        EnterProc
        push    ebx
        push    esi
        push    edi

        ; ebx should point to first of 4 detailed desc
        mov     ebx,pEdidBuf
        add     ebx,36H

        ; Change a detailed timing to something big
        ; We have to parse a bunch of fields to find them first.
        ; map of timing info tells where to start

        ; In Version 1 EDIDs, the detailed timing desc / Monitor desc
        ; begins at offset 36H.  There are 4 of them and each one is
        ; 12H bytes long.

        sub     ecx,ecx
        mov     edx,0FF00H

LoopOnDesc:
        ; if the desc is of type FD (monitor range limits),
        ; then replace with our MIGHTY range limits

        ; If this is a detailed timing and not a special desc
        ; then skip it.
        mov     eax,ds:[ebx]
        and     eax,0FFFFFFH
        je      CheckDescriptor

        ; Replace the detailed timing with a detailed timing for
        ; 2048x1536@60Hz. Please note this is a GTF timing.
        mov     byte ptr ds:[ebx + 00H], 047H
        mov     byte ptr ds:[ebx + 01H], 068H
        mov     byte ptr ds:[ebx + 02H], 000H
        mov     byte ptr ds:[ebx + 03H], 0F0H
        mov     byte ptr ds:[ebx + 04H], 082H
        mov     byte ptr ds:[ebx + 05H], 000H
        mov     byte ptr ds:[ebx + 06H], 035H
        mov     byte ptr ds:[ebx + 07H], 060H
        mov     byte ptr ds:[ebx + 08H], 013H
        mov     byte ptr ds:[ebx + 09H], 0E0H
        mov     byte ptr ds:[ebx + 0AH], 013H
        mov     byte ptr ds:[ebx + 0BH], 000H
        jmp     NextDesc

CheckDescriptor:
        ; Speical desc -- but what type?
        cmp     dword ptr ds:[ebx],0FD000000H
        jne     NotFD

        mov     byte ptr ds:[ebx + 00H], 000H
        mov     byte ptr ds:[ebx + 01H], 000H
        mov     byte ptr ds:[ebx + 02H], 000H
        mov     byte ptr ds:[ebx + 03H], 0FDH
        mov     byte ptr ds:[ebx + 04H], 000H
        mov     byte ptr ds:[ebx + 05H], 03CH ; min vert in hertz
        mov     byte ptr ds:[ebx + 06H], 0C8H ; max vert in hertz
        mov     byte ptr ds:[ebx + 07H], 018H ; min horz in KHZ
        mov     byte ptr ds:[ebx + 08H], 064H ; max horz in KHZ
        ; max pix clock in MHZ / 10 so 28H = 400MHZ
        mov      byte ptr ds:[ebx + 09H], 028H
        mov      byte ptr ds:[ebx + 0AH], 000H
        mov      byte ptr ds:[ebx + 0BH], 00AH
        mov      byte ptr ds:[ebx + 0CH], 020H
        mov      byte ptr ds:[ebx + 0DH], 020H
        mov      byte ptr ds:[ebx + 0EH], 020H
        mov      byte ptr ds:[ebx + 0FH], 020H
        mov      byte ptr ds:[ebx + 10H], 020H
        mov      byte ptr ds:[ebx + 11H], 020H
        mov     dl,1

NotFD:
        cmp     dword ptr ds:[ebx],00F900000H
        je      @F
        cmp     dword ptr ds:[ebx],00FB00000H
        jne     NextDesc
@@:     mov     dh,cl

NextDesc:
        add     ebx,12H
        inc     ecx
        cmp     ecx,4
        jb      LoopOnDesc

        ; Did we replace a range desc with the new one?
        or      dl,dl
        jne     DoneFD

        ; No, we didn't. We need to replace some other desc.
        ; Did we find one that we can replace?
        cmp     dh,0FFH
        je      DoneFD

        ; dh holds the index of the desc which we can use
        sub     ebx,4 * 12H
        movzx   edx,dl
        imul    edx,12H
        add     ebx,edx
        mov     byte ptr ds:[ebx + 00H], 000H
        mov     byte ptr ds:[ebx + 01H], 000H
        mov     byte ptr ds:[ebx + 02H], 000H
        mov     byte ptr ds:[ebx + 03H], 0FDH
        mov     byte ptr ds:[ebx + 04H], 000H
        mov     byte ptr ds:[ebx + 05H], 03CH ; min vert in hertz
        mov     byte ptr ds:[ebx + 06H], 0C8H ; max vert in hertz
        mov     byte ptr ds:[ebx + 07H], 018H ; min horz in KHZ
        mov     byte ptr ds:[ebx + 08H], 064H ; max horz in KHZ
        ; max pix clock in MHZ / 10 so 28H = 400MHZ
        mov      byte ptr ds:[ebx + 09H], 028H
        mov      byte ptr ds:[ebx + 0AH], 000H
        mov      byte ptr ds:[ebx + 0BH], 00AH
        mov      byte ptr ds:[ebx + 0CH], 020H
        mov      byte ptr ds:[ebx + 0DH], 020H
        mov      byte ptr ds:[ebx + 0EH], 020H
        mov      byte ptr ds:[ebx + 0FH], 020H
        mov      byte ptr ds:[ebx + 10H], 020H
        mov      byte ptr ds:[ebx + 11H], 020H

DoneFD:
        ; Now we need to checksum the EDID.
        mov     ebx,pEdidBuf
        mov     cx,7FH
        sub     al,al

ChecksumEdid:
        add     al,byte ptr ds:[ebx]
        inc     ebx
        loop    ChecksumEdid

        neg     al
        mov     byte ptr ds:[ebx],al

        pop     edi
        pop     esi
        pop     ebx
        LeaveProc
        Return

EndProc BuildMightyVersion1Edid


PUBLIC  BuildDisplayPathXXXX
BeginProc BuildDisplayPathXXXX,CCALL
ArgVar  pDevNode, DWORD

        EnterProc
        push    ebx
        push    esi
        push    edi
        mov     ebx,pDevNode

    ; Get the correct display path in the registry
    mov     eax,[ebx + 4]
    mov     esi,OFFSET szAndMore

    ; eax now points to a string that we concatenate onto
    ; "Enum\\".  We look up this path in HKEY_LOCAL_MACHINE
@@: mov     cl,[eax]
    inc     eax
    mov     [esi],cl
    inc     esi
    or      cl,cl
    jne     @B

    ; Now open the key
    mov     hKey,0
    mov     esi,OFFSET szEnumAndMore
    mov     eax,OFFSET hkey
    VMMCall _RegOpenKey, <HKEY_LOCAL_MACHINE,esi,eax>
    or      eax,eax
    jne     UseDefaultKey

    ; Now Read the display sub path
    mov     szDisplayEndPath,0
    mov     dwCBType,REG_SZ
    mov     dwCBLen,32
    mov     eax,OFFSET dwCBType
    mov     ebx,OFFSET szDisplayEndPath
    mov     ecx,OFFSET dwCBLen
    mov     edx,OFFSET szDriver
    VMMCall _RegQueryValueEx, <hKey, edx, 0, eax, ebx, ecx>

    ; CLose the key and zero it out.
    VMMCall _RegCloseKey, <hKey>
    mov     hKey,0

    ; Now, did we get a valid string (like "DISPLAY\0005")
    cmp     szDisplayEndPath,0
    je      UseDefaultKey

    ; Make the complete path
    mov     eax,OFFSET szDisplayEndPath
    mov     ebx,OFFSET szLocalDisplayPathEnd
@@:
    mov     cl,[eax]
    inc     eax
    mov     [ebx],cl
    inc     ebx
    or      cl,cl
    jne     @B
    jmp     GotRegPath

UseDefaultKey:
    mov     eax,OFFSET szLocalDisplayPathEnd
    mov     dword ptr [eax + 0],'PSID'
    mov     dword ptr [eax + 4],'\YAL'
    mov     dword ptr [eax + 8],'0000'
    mov     byte ptr [eax + 12],0

GotRegPath:
        pop     edi
        pop     esi
        pop     ebx
        LeaveProc
        Return
EndProc BuildDisplayPathXXXX


PUBLIC  MiniVDD_CreateVM
BeginProc MiniVDD_CreateVM
        mov     eax,pfnLockOffscreen
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc MiniVDD_CreateVM

PUBLIC  MiniVDD_DestroyVM
BeginProc MiniVDD_DestroyVM
        mov     eax,pfnUnlockOffscreen
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc MiniVDD_DestroyVM


;==============================================================================
;
; Function:     DisplayDriverPowerUp
;
; Purpose:      This function call GN_PowerOn routine of display driver
;
; Arguments:    None
;
; Returns:      None
;==============================================================================
PUBLIC  DisplayDriverPowerUp
BeginProc DisplayDriverPowerUp
        mov     eax,pfnPowerOn
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc DisplayDriverPowerUp


;==============================================================================
;
; Function:     DisplayDriverPowerDown
;
; Purpose:      This function call GN_PowerOff routine of display driver
;
; Arguments:    None
;
; Returns:      None
;==============================================================================
PUBLIC  DisplayDriverPowerDown
BeginProc DisplayDriverPowerDown
        mov     eax,pfnPowerOff
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc DisplayDriverPowerDown


;==============================================================================
;
; Function:     FlashOffscreenBitmaps
;
; Purpose:      This function moves offscreen bitmaps into system memory
;
; Arguments:    None
;
; Returns:      None
;==============================================================================
PUBLIC  FlashOffscreenBitmaps
BeginProc FlashOffscreenBitmaps
        mov     eax,pfnLockOffscreen
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc FlashOffscreenBitmaps



; Function:     NestedCallBack
;
; Purpose:      This function simulates a far jump in a nested
;               execution block.
;
; Arguments:    None
;
; Returns:      None
;==============================================================================
PUBLIC NestedCallBack
BeginProc NestedCallBack
        pushad

        ; If we are not in the system VM, then we cannot do this!
        ; Unfortunately, then the offscreen allocations will not be
        ; flushed and there may be problems. However, I have never
        ; seen this occur. It appears that whenever we get a CreateVM
        ; or DestroyVM message and this routine gets called, that
        ; we are always in the system VM, so everything should be cool.

        VMMCall Get_Cur_VM_Handle
        push    ebx

        VMMCall Get_Sys_VM_Handle
        pop     eax

        cmp     ebx,eax
        jne     DoneNC
        cmp     dwCallbacksSelector,0
        je      DoneNC
        cmp     pfnCurrentCall,0
        je      DoneNC

        ; Save the client state and unlock all critical sections
        ; so we can get back into ring-3 code
        Push_Client_State
        VMMCall Begin_Nest_Exec

        ; Call the lock or unlock routine
        mov     ecx,dwCallbacksSelector
        mov     edx,pfnCurrentCall
        VMMCall Simulate_Far_Call
        VMMCall Resume_Exec

        ; Restore the critical section status and the execution state
        VMMCall End_Nest_Exec
        Pop_Client_State

DoneNC:
        popad
        clc
        ret

EndProc NestedCallBack


;******************************************************************************
;
;   GetBusDeviceAndFunctionNumber
;
;   DESCRIPTION:
;       Locates the device on the PCI Bus and returns the Bus, Device and Function Numbers.
;
;   ENTRY:
;       EBX = nvPhys
;       ECX = fbPhys
;       EDX = nvIRQ
;
;   EXIT:
;       EAX = EDX will now contain the needed info.
;         EDX xxxxxxxx xxxxxxxx xxxxx  xxx  xxxxxxxx
;             00000000    Bus # Device Func        IRQ # 
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================
BASE0_OFFSET EQU 10h
BASE1_OFFSET EQU 14h
IRQ_OFFSET       EQU 3ch
BeginProc GetBusDeviceAndFunctionNumber

  local bus_number:BYTE
  local device_number:BYTE
  local function_number:BYTE
  local base0:DWORD
  local base1:DWORD
  local irq:BYTE
  local return_val:DWORD

  pushad

  mov   base0, ebx
  mov   base1, ecx
  mov   irq, dl
  ; Check all buses devices and functions for the memory windows and IRQ input.
  mov   bus_number,0
  .repeat
    mov   device_number,0
    .repeat
      mov   function_number,0
      .repeat
        ; Read the PCI bus and check if we have a match.
        xor   eax,eax
        mov   al, bus_number
        shl   eax,16
        mov   ah, device_number
        shl   ah,3
        or    ah, function_number
        mov   al, BASE0_OFFSET
        or    eax, 80000000h           ; eax will now contain the configuration address for the PCI read.
        ReadPCI                                ; Returns the Dword read from the PCI Config space in edx.
        and   dl,0
        .if(edx == base0)
          mov   al, BASE1_OFFSET
          ReadPCI                                  ; Returns the Dword read from the PCI Config space in edx.
          and   dl,0
          .if(edx == base1)
            mov   al, IRQ_OFFSET
            ReadPCI                                ; Returns the Dword read from the PCI Config space in edx.
            .if(dl == irq)
              ; WOW ! It works. Lets get out and return this stuff
              and   eax,00FFFF00h          ; AND off the config bit and offset.
              mov   al, irq                        ; OR in the irq
              mov   return_val, eax
              jmp   we_gots_a_match
            .endif
          .endif
        .endif
        inc   function_number
      .until function_number == 08h
      inc   device_number
    .until device_number == 01fh
    inc   bus_number
  .until bus_number == 0ffh

  mov  return_val,-1

  we_gots_a_match:
  exit_out:

  popad
  mov  edx, return_val
  ret

EndProc   GetBusDeviceAndFunctionNumber

;==============================================================================
;   DoConfigStart
;
;   DESCRIPTION:
;       Handles the CONFIG_START message.
;
;   ENTRY:
;       EBX = Devnode handle
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================

BeginProc DoConfigStart

    .ERRNZ  SIZE Config_Buff_s MOD 4

    sub     esp, SIZE Config_Buff_s
    mov     edi, esp                ; alloc buffer on stack

    xor eax, eax
    cmp ConfigStartDone, 0
    jne DoConfigStartDone

    mov     dwDisplayDevnodeHandle,ebx

;   call the Configuration Manager to get the device config.
    
    VxDcall _CONFIGMG_Get_Alloc_Log_Conf, <edi, ebx, CM_GET_ALLOC_LOG_CONF_ALLOC>
    test    eax, eax
    jz      @F
    Debug_Out "MiniVDD:  Unexpected config manager error #EAX"
    jmp     DoConfigStartDone

@@:
    push        ebx
    call        BuildDisplayPathXXXX
    add         esp,4

;   We got the device config; now parse the info and call the resource manager to map it.

    ;mov    esi, [dwRefData]        ; ESI -> adapter reference data

    ;
    ; Our device should be given four or five memory windows
    ;
    ;   two for VGA (A0000 and B0000)
    ;   two for the PCI Bars (NV and FB)
    ;   one for AGP aperture/ROM (optional)
    ;
    ; We should find NV at index 2 and FB at index 3, but let's
    ; parse to make sure.
    ;
    xor             ebx,ebx
start_1:    
    ; starting with NV 4.5, we may optionally have a 32 MB fb 
    ; NV10 goes up to 128MB, so we'll check for that size too
    cmp     [edi.dMemLength][ebx*4], 08000000h      ; don't expect to find fb first, but just in case
    je      found_fb
    cmp     [edi.dMemLength][ebx*4], 02000000h      ; don't expect to find fb first, but just in case
    je      found_fb
    cmp     [edi.dMemLength][ebx*4], 01000000h
    je      @F
    inc     ebx
    cmp     bx, [edi.wNumMemWindows]
    jl      start_1
    mov     eax, CR_DEVICE_NOT_THERE
    jmp     DoConfigStartDone

@@:
    ;
    ; Found a 16meg window.  Which one is it?
    ; We should always find nv first and fb second--this is the order in the PCI config
    ; The config manager doesn't always return attrib = 5 (prefetchable) for fb, although this is set in PCI space,
    ; so we won't depend on it.
    ; We will test which window is which by reading some nv register in InitMapping (in the resource manager).
;   cmp     [edi.wMemAttrib][ebx*2], 0005h
    mov     eax, [edi.dMemBase][ebx*4]
;   je      @F
    mov     nvPhys, eax                ; nv has attrib of 1
    jmp     short start_2

; 32 or 128MB window -- must be fb
found_fb:
    mov     eax, [edi.dMemBase][ebx*4]
    mov     fbPhys, eax                ; fb has attrib of 5 (PF)
    mov     eax, [edi.dMemLength][ebx*4]
    mov     fbLength, eax
    
start_2:
    ;
    ; Find the next nv window
    ;
    inc     ebx
    cmp     bx, [edi.wNumMemWindows]    ; at end?
    jl      @F
    mov     eax, CR_DEVICE_NOT_THERE    ; fail
    jmp     DoConfigStartDone
@@:
    cmp     [edi.dMemLength][ebx*4], 08000000h      ; NV10
    je      @f
    cmp     [edi.dMemLength][ebx*4], 04000000h      ; NV20
    je      @f
    cmp     [edi.dMemLength][ebx*4], 02000000h      ; NV5
    je      @f
    cmp     [edi.dMemLength][ebx*4], 01000000h      ; NV4
    jne     start_2
    ;
    ; Found another 16meg window.  Which one is it?
    ;
@@:
; Don't count on attrib = 5! (might be fixed in Win98 final)
;    cmp     [edi.wMemAttrib][ebx*2], 0005h
    mov     eax, [edi.dMemBase][ebx*4]
;    je      @F
;       jne             @f                                                      ; yes, it must be fb
;    mov     _nvPhys, eax                ; nv has attrib of 1
;    jmp     short start_3
    cmp     fbPhys, 0
    je      @f
    mov     nvPhys, eax                 ; fb first!
    jmp     start_3
;   fb second (expected)
@@:
    mov     fbPhys, eax
    mov     eax, [edi.dMemLength][ebx*4]
    mov     fbLength, eax
        
start_3:
    ;
    ; We now have our two memory windows.  Let's look for the IRQ.
    ;
    cmp     [edi.wNumIRQs], 1
    je      @F
    mov     eax, CR_DEVICE_NOT_THERE    ; more than one irq?  ooops.
    jmp     DoConfigStartDone
@@:
    xor     eax, eax
    mov     al, [edi.bIRQRegisters][0]
    mov     nvIRQ, eax

;       check that we got something (shouldn't ever be 0 unless PCI error)
    mov     eax, CR_DEVICE_NOT_THERE    ; assume failure
    cmp     nvPhys, 0
    jz      DoConfigStartDone
    cmp     fbPhys, 0
    jz      DoConfigStartDone
    cmp     nvIRQ, 0
    jz      DoConfigStartDone

;
;   Map the physical addresses to linear addresses and install interrupt
;   Addresses should be in correct order, but we'll check in InitMapping.
map_config:

;   make a c-type call: ResManAPI(func, addr1, addr2, irq)
    push    ebx
    push    ecx
    push    edx
    push    edi
    push    esi
    mov     esi, offset32 MiniVDD_PostCRTCModeChange
    mov     edx, nvIRQ
    mov     ecx, fbPhys
    mov     ebx, nvPhys                                     ; pass physical config to RM
    ; Before we initialize in the RM, Lets pass in the Bus, Device and Function numbers along with the IRQ.
    ; This will be helpful later when we may need to turn on the device.
    ; This function will fill edx with the PCI bus, device and function info along with the IRQ.
    call    GetBusDeviceAndFunctionNumber
    mov     eax, fbLength
    shr     eax, 16
    or      ecx, eax                    ; put the upper word of the length (ie # of 64k blocks) in the lower word
    
    mov     eax, esi
    mov     esi, offset callrm_struct
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_device_handle, 1
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_modechange_callback, eax
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_irq_bus, edx
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_fbphys, ecx
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_nvphys, ebx
    lea     eax, szLocalDisplayPath
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_registry_path, eax

    mov     nvAddr, ebx                                     ; return with logical address to NV
    mov     hDev, ecx                   ; and a RM handle to the device.
    mov     fbAddr, edx                                     ; and a logical address to framebuffer
    mov     nvCustomer, edi             ; and a bitmask of customers
            
    mov     ebx, DEFAULT_PRIMARY_HDEV
    mov     eax, NVRM_API_INIT          ; load up the function number
    call    CallRM                      ; go to RM's API procedure
                                        ; do mapping to logical addresses and installing interrupt      
    mov     nvAddr, ebx                 ; return with logical address to NV
    mov     hDev, ecx                   ; and a RM handle to the device.
    mov     fbAddr, edx                 ; and a logical address to framebuffer
    mov     nvCustomer, edi             ; and a bitmask of customers
    mov     fpDDC, esi                  ; and the location of the flat panel's DDC port
    inc     numDevice                   ; track the number of times called
    pop     esi
    pop     edi
    pop     edx
    pop     ecx
    pop     ebx

    cmp     eax, RM_OK                                      
    je      @F                          ; Success.
    
    mov     eax, CR_INVALID_LOG_CONF
    jmp     DoConfigStartDone
    
@@:
    ;
    ; Everything is as it should be!!
    ;

        ; Leave comment in to handle assembler problmem

    REG_RD32(NV_PMC_BOOT_0)
    ; Decide what type of chip this is
    shr     ax, 12          ; no equates for NV4 in include yet
    cmp     ax, 4           ; is it NV4?
    jne     @f
    mov     ChipType,4      ; this won't be right for NV10, but it also doesn't look used
@@:
;
; CANOPUS TV Programming Change -- only use if customer is Canopus
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
;
        test nvCustomer, NVCUSTOMER_CANOPUS
        jz   PHRTV_NoCanopus01

        mov     al, bCanopusTVReg       ;-- first check, if the BIOS supports Canopus TV
        or      al, al                  
        jz      PHRTV_NoCanopus01       ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read TV Flag register
        mov     edi,ebx                 ;get pointer to our CB data area
        add     edi,OurCBDataPointer    ;EDI --> our CB data area for this VM
        mov     ah,[edi].PerVMData.EXT_CanopusTVReg
        test    ah, 040h                ; already initialized ???
        jnz @F                          ; yes, go on

        mov al, bCanopusTVReg           ; else get the current register contents
        out dx, al
        inc dx          
        in      al, dx
        dec dx
        mov ah, al                      ; and modify this one...
@@:
        and ah, 07fh                    ; clear the INACTIVE flag (TV_FLAG_REGISTER)
        mov al, bCanopusTVReg                   
        out dx, ax                      ; and write the new value back...
        jmp short PHRTV_NoCanopus02
        
PHRTV_NoCanopus01:
;
PHRTV_NoCanopus02:     

        ; Initialize LogicalDevice structure.
        ; LPL - pretty sure these regs aren't in use at this point,
        ; but I'm gonna push/pop 'em anyway
        push    eax
        push    ebx
        push    ecx
        push    edx

        lea     edi,LogicalDevice
        sub     ecx,ecx

@@:
IF 0
        mov     [edi],ecx       ;old way: just initialize with index
ELSE
        mov     eax, NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP
        mov     ebx, DEFAULT_PRIMARY_HDEV
        push    ecx                                                     ; use counter as lookup index
        push    edi
        call    CallRM                      ; go to RM's API procedure
        pop             edi
        pop             ecx
        mov     [edi],eax                   ; return in eax
ENDIF
        inc     ecx
        add     edi,4
        cmp     ecx,MAX_CRTCS
        jb      @B

        pop             edx
        pop             ecx
        pop             ebx
        pop             eax


;We might never get the SaveMessageModeState call if running Win98, because of a bug. We should save registers here,
;because the current mode will correspond to message mode. Is this true for far east versions as well? (mode 12).
    push    ebx
    mov     ebx, WindowsVMHandle        ;save regs to system VM CB data
    call    MiniVDD_SaveRegisters
    call    MiniVDD_SaveMessageModeState ;copy to message mode VM CB data
    pop     ebx
    
    mov ConfigStartDone, 1
    mov eax, CR_SUCCESS
    
;       end up here after success or fail
DoConfigStartDone:
    add     esp, SIZE Config_Buff_s                 ; adjust stack
    cmp     eax, CR_SUCCESS
    je      DoConfigStartExit

DoConfigStartError:
    mov nvPhys, 0
    mov fbPhys, 0
    mov nvIRQ,  0
    Debug_Out "MiniVDD:  MiniVDD PnP_New_Devnode failed"
    stc
DoConfigStartExit:
    ret

EndProc DoConfigStart

;******************************************************************************
;
;   MiniVDD_PnP_New_DevNode
;
;   DESCRIPTION:
;       Handles system control calls for PnP_NEW_DEVNODE.  This routine
;       allocates the reference data for the adapter, and registers as the
;       driver for the devnode.
;
;   ENTRY:
;       EBX = Devnode handle
;       EDX = Subfunction (should always be LOAD_DRIVER)
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================

BeginProc MiniVDD_PnP_New_DevNode

        cmp     edx, DLVXD_LOAD_DRIVER  ; Q: Is this the driver?
        jne     SSND_Error              ;    N: Strange!!!

;       it seems CM_Register_Device_Driver causes a problem in the Win95 VDD. The VDD won't do the VESA DDC call (4F15).
;       Avoid doing it (CM_Register_Device_Driver) in Win95.

IF 0
;   Well. It does not work on Win98 also! So Just do it the old way. The code to register for
;   config manager messages is left here commented out. Maybe someday Microsoft will fix this
;   and we can do it the documented way :-)
    VMMcall     Get_VMM_Version
    .if (!(carry?) && (ax == 040ah))
       ; This is win98. Register to get config messages.
       VxDcall _CONFIGMG_Register_Device_Driver, <ebx, OFFSET32 MiniVDD_Config_Handler, 0, CM_REGISTER_DEVICE_DRIVER_STATIC>
           .ERRNZ       CR_SUCCESS
           test eax, eax
           jnz  SSND_Couldnt_Reg_Driver
       ; Register succeeded. Clear carry and return
           clc
           jmp MiniVDD_new_devnode_Exit
    .endif
    
    ; This is win95. Can't register for config messages. So just do the config_start here.
ENDIF

    ; Just do the init here for both win95 and win98.
    call DoConfigStart
    cmp eax, CR_SUCCESS
    jne SSND_Error
    jmp MiniVDD_new_devnode_Exit
    
;   Unable to register driver.
SSND_Couldnt_Reg_Driver:
        Debug_Out "MiniVDD:  Register device driver failed for devnode #EDI"

SSND_Error:
        Debug_Out "MiniVDD:  MiniVDD PnP_New_Devnode failed"
        mov     eax, CR_FAILURE
        stc
MiniVDD_new_devnode_Exit:
        ret

EndProc MiniVDD_PnP_New_Devnode

;******************************************************************************
;
;   MiniVDD_Config_Handler
;
;   DESCRIPTION:
;       This is the plug and play driver entry point for the MiniVDD.
;       This routine is called by the config manager to notify this driver
;       of configuration related actions.
;
;   THIS PROC IS NOT USED NOW. To enable this procedure, uncomment the code
;   to register for config manager messages in MiniVDD_PnP_New_Devnode.
;
;   ENTRY:
;       cfFuncName = The function to perform.
;       sbfSubFuncName = The subfunction to perform.
;       dnToDevNode = Handle of the devnode being called.
;       dnAboutDevNode = Handle of the subject of the event.
;       ulFlags = Flags value.
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

BeginProc MiniVDD_Config_Handler, CCALL

ArgVar  cfFuncName, DWORD
ArgVar  scfSubFuncName, DWORD
ArgVar  dnDevNode, DWORD
ArgVar  dwRefData, DWORD
ArgVar  ulFlags, DWORD

        EnterProc
        push    ebx
        push    esi
        push    edi

        .IF ([cfFuncName] == CONFIG_FILTER)

           ;> Filter logical configurations for controller.
           ;> This is called before start and may not be required.

           mov eax, CR_SUCCESS

        .ELSEIF ([cfFuncName] == CONFIG_START)

           Debug_Out "MiniVDD:  PnP Start"
       ; We get called twice with CONFIG_START. Once with a subfunction of CONFIG_START_FIRST_START
       ; and once with a subfunction of CONFIG_START_DYNAMIC_START. We will only pay attention
       ; to CONFIG_STAR_FIRST_START.
       .IF ([scfSubFuncName] == CONFIG_START_FIRST_START)
          mov ebx, [dnDevNode]
          call DoConfigStart
       .ENDIF

        .ELSEIF ([cfFuncName] == CONFIG_STOP)

       Debug_Out "MiniVDD:  PnP Stop"
       ; need to add code to handle this.
       mov eax, CR_SUCCESS
       
        .ELSEIF ([cfFuncName] == CONFIG_TEST)

           Debug_Out "MiniVDD:  PnP Test"
       ; need to add code to handle this.
           mov  eax, CR_REMOVE_VETOED           ; if we are primary display, we can't be removed now
    
        .ELSEIF ([cfFuncName] == CONFIG_REMOVE)

       Debug_Out "MiniVDD:  PnP Remove"
           ;> The controller devnode is being removed, this driver must stop
           ;> using the allocated configuration.  Any allocated data for this
           ;> devnode should be freed.  If the driver is dynamically loaded it
           ;> will be unloaded by the config manager.  This driver will not be
           ;> called again after this call.

           ; If the user removes the device from the registry via the Device Manager,
           ; and we are the primary display, we can't just unload. We should keep displaying and the Config Manager should 
           ; take care of the registry and ask if we want to restart.
       ;        call    _rmConfigStop
           ;VMMcall _HeapFree, <dwRefData, 0>
       ;        jmp     MiniVDDPnP_Success
       ;        mov     eax, CR_REMOVE_VETOED           ; if we are primary display, we can't be removed now
       ;        jmp MiniVDDPnP_Exit
       
       ; need to add code to handle this.
           mov  eax, CR_FAILURE         ; don't allow removal

    .ELSE
       mov eax, CR_DEFAULT
    
    .ENDIF

        .ERRNZ CR_SUCCESS

; Exit with eax = status
        pop     edi
        pop     esi
        pop     ebx
        LeaveProc
        Return

EndProc MiniVDD_Config_Handler

;******************************************************************************
;
;   MiniVDD_System Exit
;
;   DESCRIPTION:        Windows is shutting down. The resource manager left the VGA
;           in an unsatisfactory state, so we should do a mode set to clean it up.
;           This is important if we are doing an exit to DOS (as opposed to a 
;           shutdown or restart).
;
;   ENTRY:
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

public  MiniVDD_System_Exit
BeginProc MiniVDD_System_Exit
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
;
; CANOPUS TV Programming Changes -- only use if customer is Canopus
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
        test nvCustomer, NVCUSTOMER_CANOPUS
        jz   PHRTV_NoCanopus04
            
        push    dx
        mov     al, bCanopusTVReg       ;-- first check, if the BIOS supports Canopus TV 
        or          al, al
        jz          PHRTV_NoCanopus03   ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read TV Flag register
        mov         edi,ebx                     ;get pointer to our CB data area
        add         edi,OurCBDataPointer        ;EDI --> our CB data area for this VM
        mov         ah,[edi].PerVMData.EXT_CanopusTVReg
        test    ah, 040h                ; already initialized ???
        jnz     @F                      ; yes, go on

        mov     al, bCanopusTVReg       ; else get the current register contents
        out     dx, al
        inc     dx
        in          al, dx
        dec     dx
        mov     ah, al                  ; and modify this one...
@@:
        and     ah, 07fh                ; clear the INACTIVE flag (TV_FLAG_REGISTER)
        mov     al, bCanopusTVReg
        out     dx, ax                  ; and write the new value back...
PHRTV_NoCanopus03:
        pop     dx
        jmp short PHRTV_NoCanopus05
PHRTV_NoCanopus04:

;   tell the BIOS to program the TV encoder
        call    TellBIOSProgramTV
PHRTV_NoCanopus05:

        cmp             ACPI_state,0                    ; in power-down state?
        jne             @f                                              ; then don't call BIOS (chip may be disabled)

        cmp     OSVersion, VERS_MILLENNIUM  ; leave Millennium in current mode
        jge     @f

        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; Set mode 3 via VESA in case the Japanese language driver is running and trapping int 10.
        ; We need to do a modeset to get back to a state in which the DOS mouse driver will not try to display a cursor,
        ; and if the Japanese driver traps int 10, it won't happen, and the mouse driver will be activated and cause screen corruption.
        mov     ax,4f02h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        mov     ax,3
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,ax
        ; do an int 10
        mov     eax,010h
        VMMCall Exec_Int
        
        ; set mode 3 by standard int10 to get Japanese language driver into proper state
        mov     ax,03h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        ; do an int 10
        mov     eax,010h
        VMMCall Exec_Int

        VMMCall End_Nest_Exec
        Pop_Client_State
@@:
        ret
EndProc MiniVDD_System_Exit
;

;******************************************************************************
;
;   MiniVDD_Sys_VM_Terminate
;
;   DESCRIPTION:        Windows is shutting down. We set a mode 3 to prepare for the Windows shutting down message
;
;   ENTRY:
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

public  MiniVDD_Sys_VM_Terminate
BeginProc MiniVDD_Sys_VM_Terminate
;We are leaving Windows and going to text mode
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
        
;       Set DoNotSimulate flag to TRUE
        mov     DoNotSimulate,1         ; signal i/o trap routine that even though this is the system VM
                                        ; we should not simulate, but do I/O, so BIOS can write to DAC and CONFIG regs

        ; Unhook the Int 10 handler
        mov     eax, 10h
        mov     esi, OFFSET32 MiniVDD_Int10Handler
        VxDcall Unhook_V86_Int_Chain
        
        cmp     ACPI_state,0            ; in power-down state?
        jne     @f                      ; then don't call BIOS (chip may be disabled)

        cmp     OSVersion, VERS_MILLENNIUM  ; leave Millennium in current mode
        jge     @f

        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; set mode 3
        mov     ax,03h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        ; do an int 10
        mov     eax,010h
        VMMCall Exec_Int

        VMMCall End_Nest_Exec
        Pop_Client_State
@@:
        ret
EndProc MiniVDD_Sys_VM_Terminate
;
;******************************************************************************
;
;   MiniVDD_Device_Reboot_Notify
;
;   DESCRIPTION:        Windows 98 is shutting down. We set a mode 3 to prepare for the Windows shutting down message
;
;   ENTRY:
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

public  MiniVDD_Device_Reboot_Notify
BeginProc MiniVDD_Device_Reboot_Notify
;We are leaving Windows and going to text mode
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
        
;       Set DoNotSimulate flag to TRUE
        mov     DoNotSimulate,1         ; signal i/o trap routine that even though this is the system VM
                                        ; we should not simulate, but do I/O, so BIOS can write to DAC and CONFIG regs

        cmp     ACPI_state,0            ; in power-down state?
        jne     @f                      ; then don't call BIOS (chip may be disabled)

        cmp     OSVersion, VERS_MILLENNIUM  ; leave Millennium in current mode
        jge     @f

        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; set mode 3
        mov     ax,03h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        ; do an int 10
        mov     eax,010h
        VMMCall Exec_Int

        VMMCall End_Nest_Exec
        Pop_Client_State
@@:
        ret
EndProc MiniVDD_Device_Reboot_Notify

subttl          Utility routines
page +
IFDEF DEBUG_LOG
public  DumpRegisters
BeginProc DumpRegisters
        pushf
        pushad
        mov     edx,MISC_INPUT
        xor     eax,eax
        in      al,dx
        Debug_Printf    "    MISC:%02lX\n\r", eax, DEBLEVELMAX
        mov     edx,FC_INPUT
        xor     eax,eax
        in      al,dx
        Debug_Printf    "    FC:%02lX\n\r", eax, DEBLEVELMAX
        mov     edx,FEAT_STATUS
        xor     eax,eax
        in      al,dx
        Debug_Printf    "    FEAT:%02lX\n\r", eax, DEBLEVELMAX
        mov     edx,INPUT_STATUS_COLOR
        xor     eax,eax
        in      al,dx
        Debug_Printf    "    INPUT_STATUS:%02lX\n\r", eax, DEBLEVELMAX
        ;
        ; DUMP Sequencer
        Debug_Printf    "    SEQ:", eax, DEBLEVELMAX
        xor     ecx,ecx
        xor     eax,eax
        mov     edx,SEQ_INDEX
        in      al,dx           ;save sequencer index
        push    eax
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,6
        jbe     @b
        pop     eax             ;restore sequencer index
        out     dx,al
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        ; DUMP CRTC
        xor     ecx,ecx
        xor     eax,eax
        call    GetCRTCPort
        in      al,dx           ;save CRTC index
        push    eax
        ;
        Debug_Printf    "    CRTC:", eax, DEBLEVELMAX
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,00Fh
        jbe     @b
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        Debug_Printf    "         ", eax, DEBLEVELMAX
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,01Fh
        jbe     @b
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        Debug_Printf    "         ", eax, DEBLEVELMAX
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,02Fh
        jbe     @b
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        Debug_Printf    "         ", eax, DEBLEVELMAX
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,03Fh
        jbe     @b
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        pop     eax             ;restore CRTC index
        out     dx,al
        ;
        ; Attribute controller
        Debug_Printf    "    AC:", eax, DEBLEVELMAX
        xor     ecx,ecx
        xor     eax,eax
        call    GetCRTCPort
        in      al,dx
        push    eax             ;save CRTC index
        mov     al,024h         ;AT flip-flop register
        out     dx,al
        inc     edx             ;edx --> CRTC data
        in      al,dx
        dec     edx             ;edx --> CRTC index
        push    eax             ;save AT flip flop
        mov     al,026h         ;AT index register
        out     dx,al
        inc     edx             ;edx --> CRTC data
        in      al,dx
        dec     edx             ;edx --> CRTC index
        push    eax             ;save AT index
        ;
@@:
        mov     edx,INPUT_STATUS_COLOR
        in      al,dx           ;clear the flip-flop
        mov     edx,ATC_INDEX
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> ATC read
        in      al,dx
        dec     edx             ;edx --> ATC write
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,014h
        jbe     @b
        ;
        mov     edx,INPUT_STATUS_COLOR
        in      al,dx           ;clear the flip-flop
        pop     eax             ;restore attribute index
        mov     edx,ATC_INDEX
        out     dx,al           ;restores index and sets flip-flop to data
        pop     eax             ;restore attribute flip-flop
        or      al,al           ;if al is zero, go back to address
        jnz     @f
        mov     edx,INPUT_STATUS_COLOR
        in      al,dx           ;clear the flip-flop
@@:
        pop     eax             ;restore CRTC index
        call    GetCRTCPort
        out     dx,al
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        ; Graphics controller
        Debug_Printf    "    GC:", eax, DEBLEVELMAX
        xor     ecx,ecx
        xor     eax,eax
        mov     edx,GDC_INDEX
        in      al,dx           ;save sequencer index
        push    eax
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,8
        jbe     @b
        pop     eax             ;restore sequencer index
        out     dx,al
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
IFDEF NVIDIA_SIMULATE
        call    NVDumpSimulate
ENDIF ; NVIDIA_SIMULATE
        popad
        popf
        ret
EndProc DumpRegisters
;
;       
ENDIF ; DEBUG_LOG
;
;

public  GetCRTCPort
BeginProc GetCRTCPort
;
;       GetCRTCPort - Get the actual address of the CRTC (independent of BIOS vars)
;
;       Entry:  None
;       Exit:   DX = Address of CRTC (3D4h = color, 3B4h = mono)
;
;       Assume the VGA is awake.
;
;
        push    ax
        mov     dx,MISC_INPUT
        in      al,dx
        mov     edx,CRTC_INDEX_MONO             ; Assume mono CRTC
        test    al,1                            ; Is CRTC mono?
        jz      GetCRTCAddr_exit                ;  Yes: Go exit
        mov     edx,CRTC_INDEX_COLOR            ;  No: Return color CRTC
GetCRTCAddr_exit:
        pop     ax
        ret
EndProc GetCRTCPort
;
VxD_LOCKED_CODE_ENDS

;**************************************************************************************************************************
VxD_DATA_SEG

VDDBank                 db      ?               ;init'd at GetVDDBank
;;VDDBankControl          db      ?               ;init'd at GetVDDBank
BankRegSaveLow          db      0ffh            ;this flag must be init'd!
BankRegSaveHigh         db      0ffh            ;this flag must be init'd!
VDDPageOffsetFromBank   db      ?               ;
LatchSaveLow            db      ?               ;
LatchSaveHigh           db      ?               ;
;
LastByteInAddr                  dw              0                               ;save address of 3d0-3d3 for byte->word integration
LastByteOutAddr                 dw              0                               ;save address of 3d0-3d3 for byte->word integration
LastByteOut                             db              0                               ;save the data to output
rmState                                 db              0
rmArray                                 label   word
NvPtr                                   dd              0
NvData                                  dd              0

VxD_DATA_ENDS

;**************************************************************************************************************************
VXD_LOCKED_CODE_SEG
;
subttl          Return ChipID To Main VDD
page +
Public  MiniVDD_GetChipID
BeginProc MiniVDD_GetChipID
;
;Entry:
;       Nothing assumed.
;Exit:
;       EAX contains the ChipID.
;       Preserve ALL other registers.
;
;This routine is used by the Main VDD's Plug&Play code to determine whether
;a card has been changed since the last time that Windows was booted.  We
;are called to return to ChipID.  This assures us that Plug&Play will detect
;a different card, even if both cards use this same MiniVDD.  If the ChipID
;has changed, Plug&Play will get wind of it and will take appropriate action.
;
        push    esi
        REG_RD32(NV_PMC_BOOT_0)
        pop     esi
        ret                             ;
EndProc MiniVDD_GetChipID

public  MiniVdd_GetMonitorPowerStateCaps
BeginProc MiniVdd_GetMonitorPowerStateCaps, RARE
;
;Entry:
;       DevNode.
;Exit:
;       The CAPS of adapter
        ArgVar  DevNode, DWORD          ;message number
        EnterProc

        ; We have to support D2 because in case monitor timeout = 1 min, screensaver = 15min
        ; Windows would try to set monitor to D2 state after 1 min so we would observe
        ; screen saver if we won't support D2 (see the bug #34277).
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D2 or CM_POWERSTATE_D3)
        LeaveProc
        Return
EndProc MiniVdd_GetMonitorPowerStateCaps

public  MiniVdd_SetMonitorPowerState
BeginProc MiniVdd_SetMonitorPowerState, RARE
;Entry:
;       DevNode.
;       PowerState.
;Exit:
;       CR_DEFAULT  - OS should POST the device
;   CR_SUCCESS  - OS should do nothing
        ArgVar  DevNode, DWORD
        ArgVar  PowerState, DWORD

        EnterProc
        push    ebx
        push    ecx
        push    edx
        
        mov     ebx,PowerState
;
;
; state n = bit n
        test    ebx,CM_POWERSTATE_D0
        jz      SMPS_D23

SMPS_D0:
                
        ; Top bit of 0 indicates that we are in a fullscreen
        ; DOS box, or in a state were DDraw shouldn't touch the HW.
        ;
        ; Top bit of 1 indicates that we are in the Windows VM. The
        ; low 31bits are individual 'enable' bits that D3D will clear
        ; as each sub-system reinits itself on returning to the Windows
        ; VM from fullscreen DOS.
        mov     eax,pDDrawFullScreenDOSActive
        or      eax,eax
        je      @F
        or      dword ptr [eax],80000000H
@@:

;       call RM to start up (use API)
        mov     eax, NVRM_API_SET_MONITOR_POWER
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        mov     ecx,0
        call    CallRM

        jmp     SMPS_Ret

SMPS_D23:

        ; After the RM-EnableVGA, the RM has forced GET=PUT and
        ; all channels are idle. To make sure that no one renders
        ; anything or attempts to touch the HW, set some shared
        ; flags that say 'We are in a fullscreen DOS BOX -- don't
        ; do any rendering.'
        ;
        ; Top bit of 0 indicates that we are in a fullscreen
        ; DOS box. Top bit of 1 indicates that we are in
        ; the Windows VM. The low 31bits are individual 'enable'
        ; bits that D3D will clear as each sub-system reinits
        ; itself on returning to the Windows VM from fullscreen DOS.
        mov     eax,pDDrawFullScreenDOSActive
        or      eax,eax
        je      @F
        mov     dword ptr [eax],7FFFFFFFH
@@:

;       call RM to shut down (use API)
        mov     eax, NVRM_API_SET_MONITOR_POWER
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        mov     ecx,3
        call    CallRM
        
SMPS_Ret:
        pop     edx
        pop     ecx
        pop     ebx
        mov     eax,CR_SUCCESS
        LeaveProc
        Return
EndProc MiniVdd_SetMonitorPowerState

public  MiniVdd_GetAdapterPowerStateCaps
BeginProc MiniVdd_GetAdapterPowerStateCaps, RARE
;
;Entry:
;       DevNode.
;Exit:
;       The CAPS of adapter
        ArgVar  DevNode, DWORD          ;message number
        EnterProc

;       Notify the RM that ACPI is supported on the adapter
;       And that we can expect ACPI traffic (we'll ignore APM)
        mov     ebx, DEFAULT_PRIMARY_HDEV
        mov     eax, NVRM_API_ACPI_ENABLED  ; load up the function number
        call    CallRM                      ; go to RM's API procedure

        cmp     OSVersion,VERS_MILLENNIUM
        jb      ACPI_Win98              ;Millennium or Win98?
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D3 or CM_POWERSTATE_D1 or CM_POWERSTATE_HIBERNATE)
        jmp     GAPSC_Done
ACPI_Win98:
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D3 or CM_POWERSTATE_D1)
GAPSC_Done:
        LeaveProc
        Return
EndProc MiniVdd_GetAdapterPowerStateCaps

subttl          Set adapter Power State
page +

public  MiniVdd_SetAdapterPowerState
BeginProc MiniVdd_SetAdapterPowerState, RARE
;Entry:
;       DevNode.
;       PowerState.
;Exit:
;       CR_DEFAULT  - OS should POST the device
;   CR_SUCCESS  - OS should do nothing
        ArgVar  DevNode, DWORD
        ArgVar  PowerState, DWORD

        EnterProc
        push    ebx
        push    ecx
        push    edx

        mov     ebx,PowerState
;       cmp     ebx,AdapterState                ; Are we already in this mode?
;       jz      SAPS_Success                    ; Yes, do nothing
;
; Check for restoring to D0, if not we must be going to D1, D2, or D3.
;
; state n = bit n
        test    ebx,CM_POWERSTATE_D3
        jnz     SAPS_D3
        test    ebx,CM_POWERSTATE_D2
        jnz     SAPS_D2
        test    ebx,CM_POWERSTATE_D1
        jnz     SAPS_D1
        test    ebx,CM_POWERSTATE_HIBERNATE
        jnz     SAPS_HIBERNATE

;   if we are going to state 3, we shut down.
;   if we are coming back to state 0, we must start up.
SAPS_D0:
        cmp     ACPI_state,0                           ; already here?
        jz      SAPS_Success
        mov     ACPI_state,0
                
;       call RM to start up (use API)
        mov     eax, NVRM_API_POWER_UP
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        call    CallRM

        call    DisplayDriverPowerUp
        jmp     SAPS_Success

SAPS_HIBERNATE:
        call    DisplayDriverPowerDown

        mov     eax, NVRM_API_HIBERNATE
        mov     ebx, DEFAULT_PRIMARY_HDEV
        call    CallRM
        mov     ACPI_state,3

        jmp     SAPS_Success
SAPS_D3:
        cmp     ACPI_state,3        ; already here?
        jz      SAPS_Success
        mov     ACPI_state,3

        call    DisplayDriverPowerDown

;       point the real mode access at PBUS_DEBUG_1 in case the BIOS gets called to start up
        call    unlock_ext
        mov     dx,3d4h
        mov     ax,338h         ; address mode
        out     dx,ax
        mov     dx,3d0h
        mov     ax,1084h        ; lsw PBUS_DEBUG_1
        out     dx,ax
        mov     ax,0            ; msw PBUS_DEBUG_1
        mov     dx,3d2h
        out     dx,ax
        mov     dx,3d4h
        mov     ax,538h         ; data mode
        out     dx,ax
        
;       call RM to shut down (use API)
        mov     eax, NVRM_API_POWER_DOWN
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        call    CallRM

        jmp     SAPS_Success

SAPS_D2:
;   not supported
if 0
        cmp     ACPI_state,2
        jz      SAPS_Success
        mov     ACPI_state,2
        mov     eax, NVRM_API_POWER_D2
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        call    CallRM
        jmp     SAPS_Success
endif
        mov     eax,CR_DEFAULT
        jmp     SAPS_Ret
SAPS_D1:
        cmp     ACPI_state,1
        jz      SAPS_Success
        mov     ACPI_state,1

        call    DisplayDriverPowerDown

        mov     eax, NVRM_API_POWER_D1
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        call    CallRM
        
SAPS_Success:
        mov     eax,CR_SUCCESS

SAPS_Ret:
        pop     edx
        pop     ecx
        pop     ebx
        LeaveProc
        Return
EndProc MiniVdd_SetAdapterPowerState

page +
public  MiniVDD_RegisterDisplayDriver
BeginProc MiniVDD_RegisterDisplayDriver, RARE
;Called from VDD's REGISTER_DISPLAY_DRIVER_INFO function
;
;Oft-times, the display driver must set flags whenever it is doing
;certain things to a hardware BLTer (such as "I'm in the middle of
;transferring a source bitmap").  This routine is called to allow
;this mini-VDD to get data (usually containing addresses inside the
;display driver's Data segment) directly from the display driver.
subttl          Register Display Driver Dependent Data

;We can also save appropriately needed states here.
;
;       The only client registers that are reserved (and cannot be used
;to pass data in) are EAX (which contains the function code which the
;display driver uses to call the "main" VDD) and EBX (which contains the
;Windows VM handle).  When we get called by the "main" VDD, we'll be
;passed a flag in Client_AL which will be set to non-zero if the VFLATD
;VxD is being used for banked support or zero if VFLATD is NOT involved in
;this session.
;
;Entry:
;       EBP --> the Client Register Structure (documented in VMM.INC)
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_RegisterDisplayDriver", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

        mov     InFullScreen, 0h        ; I believe, we're no longer in full screen dos mode ;-)  CANOPUS

        ; The new architecture display driver needs some functions
        ; which can only be performed at the VxD level. I made a
        ; simple interface for these services out of the minivdd
        ; function RegisterDisplayDriver. The Client_EAX register
        ; is used up because it must hold the special code
        ; VDD_REGISTER_DISPLAY_DRIVER_INFO in order to get here,
        ; and Client_EBX is used up holding the system VM handle.
        ; The other registers are all free, so:
        ; CLIENT_ecx    - sub-function
        ; All other registers are sub-function specific.
        ;
        ; I placed the sub-function constants in nvrmarch at
        ; the time I wrote this code.
        mov     eax,[ebp].Client_Reg_Struc.Client_ECX
        cmp     eax,MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS
        je      SetLockAndUnlockFuncs
        cmp     eax,MVDD_REENUMERATE_DEVNODE
        je      ReenumerateDevNode
        cmp     eax,MVDD_SET_POWER_MANAGEMENT_CALLBACKS
        je      SetPowerManagementCallbacks
        jmp     MRDDExit

SetLockAndUnlockFuncs:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_SET_POWER_MANAGEMENT_CALLBACKS -- this service sets
        ; the routine that should be called when a power state is changed.
        ; Parameters:
        ; Client_ECX = MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS
        ; Client_EDX = selector for both the lock and unlock routine
        ; Client_ESI = offset of the lock routine (called on VM_Create)
        ; Client_EDI = offset of the unlock routine (called on VM_Destroy)
        ;
        ; Returns:      None

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        mov     dwCallbacksSelector,eax
        mov     eax,[ebp].Client_Reg_Struc.Client_ESI
        mov     pfnLockOffscreen,eax
        mov     eax,[ebp].Client_Reg_Struc.Client_EDI
        mov     pfnUnlockOffscreen,eax
        jmp     MRDDExit

SetPowerManagementCallbacks:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS -- this service sets
        ; the routine that should be called when a DOS box is created
        ; and destroyed.
        ; Parameters:
        ; Client_ECX = MVDD_SET_POWER_MANAGEMENT_CALLBACKS
        ; Client_EDX = selector for both the PowerOn and PowerOff routine
        ; Client_ESI = offset of the PowerOn routine (called on S0)
        ; Client_EDI = offset of the PowerOff routine (called on S1,S3,S4)
        ;
        ; Returns:      None

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        mov     dwCallbacksSelector,eax
        mov     eax,[ebp].Client_Reg_Struc.Client_ESI
        mov     pfnPowerOn,eax
        mov     eax,[ebp].Client_Reg_Struc.Client_EDI
        mov     pfnPowerOff,eax
        jmp     MRDDExit

ReenumerateDevNode:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_REENUMERATE_DEVNODE -- This service sets the physical
        ; head into the array LogicalDevice using the logical device
        ; as an index into the array. It then calls Windows to
        ; reenumerate the DevNode. This service is called everytime
        ; the display driver receives an Enable call.
        ; Client_ECX = MVDD_REENUMERATE_DEVNODE
        ; Client_EDX = physical head
        ; Client_ESI = logical device index

        push    ebx
        push    ecx

        mov     edx,[ebp].Client_Reg_Struc.Client_EDX   ; physical head
        mov     eax,edx                                 ; if high bit set,
        and     eax,NOT 80000000H                       ; then call reenum

        mov     ecx,[ebp].Client_Reg_Struc.Client_ESI   ; logical index
        shl     ecx,2                                   ; convert to dwords
        lea     ebx,LogicalDevice

        ; This routine realized for MAX_CRTCS == 2 case only!!!!
        mov     ds:[ebx + ecx],eax
        xor     eax,MAX_CRTCS - 1
        xor     ecx,(MAX_CRTCS-1)*4
        mov     ds:[ebx + ecx],eax

        test    edx,80000000H
        jz      @F
        VxDcall _CONFIGMG_Reenumerate_DevNode, <dwDisplayDevnodeHandle, 0>
@@:
        pop     ecx
        pop     ebx
        jmp     MRDDExit

MRDDExit:
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_RegisterDisplayDriver
;
;
subttl          Calculate and Save Banking Register Values
page +
public  MiniVDD_GetVDDBank
BeginProc MiniVDD_GetVDDBank, DOSVM
;Called from VDD's REGISTER_DISPLAY_DRIVER function
;
;In order to virtualize VGA graphics mode applications in a window on the
;Windows desktop, the VDD requires you to reserve at least 32K of off-screen
;video memory for the exclusive use of the VDD.  Although it's best to
;allocate a full 64K of off-screen video memory, the VDD can work with a
;minimum of 32K.  This function is called by the "main" VDD when the
;display driver registers with it.  This function must calculate the
;correct bank of the off-screen memory and the offset within that bank of
;the VDD reserved memory.  Note that it's best if the offset value returned
;is zero (that is, you start on a bank boundry).
;
;The mini-VDD saves the banking register values locally for later
;use during VGA virtualization.
;
;Note that the "main" VDD assumes that the hardware banks are 64K in length.
;
;Entry:
;       EBX contains the Windows VM handle (which must be preserved).
;       ECX contains the byte offset of where in video memory the VDD
;           memory is to be placed (this will be the first byte of
;           off-screen memory).
;Exit:
;       AH contains the page offset from start of bank of virtualization area.
;       EBX must still contain the Windows VM handle.
;       ECX contains the starting address of the VDD virtualization area
;       EDX contains the amount of memory that we allocated to
;       the VDD virtualization area.  We set EDX == ECX if we are in
;       a "memory shy" configuration.  That is, to tell the "main"
;       VDD that we cannot support VGA 4 plane graphics in the background.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetVDDBank", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        mov     DisplayEnabledFlag,0ffh ;flag that we're in HiRes mode
        mov     SuperVGAModeFlag,0ffh   ;indicate that display driver is not VGA
        mov     BankRegSaveLow,0ffh     ;re-init this to "no banking"

;               return memory shy config
                mov             edx,0
                mov             ecx,edx

IF 0
;We won't use the following strategy. It's not worth sacrificing hi resolution 32 bit modes on a 2 Meg card just so we
;can virtualize 4 plane modes (a pretty useless exercise). The display driver will declare that we don't support 4 plane
;modes. This seems to have no effect, so we return memory-shy configuration here to tell VDD we are not supporting planar 
;emulation.
;There is also a question about the resolution of the window into the bank. The page registers seem to open a 256k window,
;so we may not be able to place the buffer on the 64k boundary which we want, effectively wasting 128k (265k - 64k instance 
; - 64k VDD buffer).

;For NV3 we are going to ignore the starting address passed by the VDD and use the space
;at the end of the framebuffer, just before the instance memory. This is because the display
;driver doesn't know how much memory is available yet, and it wants to see contiguous
;display memory, without this emulation buffer in the way.
;When we are running on a TV we do not allow planar modes, so we should never have both VDD buffer and TV filter buffer.
;               0--------------------------Framebuffer--------------------------------------- 4 Meg
;               |                       |                                                       |                               |                       |                  |
;        display buf   other bufs (direct draw)          TV bufs           VDD buf        Instance
;johnh
                pushad
                mov             eax,2                                                   ; subfunction 2
                push    eax
                VXDCall NVRM_GetAddress                                 ; return offset to VDD planar mode emulation buffer
                mov             PlanarBuf,eax
                pop             eax
                popad    
                mov             ecx,PlanarBuf                                   ; get address (already 64k aligned)
        cmp             cx,0                                                    ; well, lets make sure
        jz              @f
        xor             cx,cx                                                   ; move DOWN to 64k align
;               we are assured of 64k of aligned memory for the planar mode buffer
;               we return to the VDD the bank offset (64k) of the buffer, and save the bank number for the SetVDDBank routine.
@@:             mov             eax,ecx
                shr             eax,16                                                  ; addr/64k = bank number
                mov             VddBank,al                                              ; save bank #0
                xchg    ah,al                                                   ; return bank in ah
                mov             edx,10000h                                              ; return 64k buffer size
;               should be all there is to it
ENDIF   ; 0
                
;               this is the way to do it if we let the display driver tell us where the buffer starts (just after the display buffer).
IFDEF   OLD_BANK_STRATEGY
;
;Let's find out in which 64K bank the off-screen memory starts:
;
; MSK - TODO - DEBUG!!!!
;        mov     ecx,0001C0000h          ;Force memory available to 64KB*4planes for debugging
; MSK - TODO - DEBUG!!!!
        mov     eax,ecx                 ;get start address of off-screen memory
        shr     eax,16                  ;divide by 64K per bank -- AL has bank #
;
;At this point:
;       AL contains the bank number of the start of off-screen memory
;       CX contains the offset within the bank of the start of
;          off-screen memory.
;
;It is desirable for us to start the VDD memory area on an even bank
;boundry.  This is possible if we have at least one full 64K bank
;of video memory remaining.  To determine this, we must calculate
;the total number of banks available in video memory.  If there's
;at least one more than what's in AL, we can start on an even bank
;boundry!
;
        or      cx,cx                   ;are we already on an even bank boundry?
        jz      MGVBCalcAmountToUse     ;yes, go see if we can alloc 64K
        mov     edx,TotalMemorySize     ;get total amount of video memory
        shr     edx,16                  ;now DL has total banks on system
        dec     dl                      ;now DL has last possible bank nbr
IFNDEF ALLOW_32K_VIRTUALIZATION
        cmp     al,dl                   ;can we start on an even bank boundry?
        jae     MGVBMemoryShy           ;nope, turn off VGA virtualization
        inc     al                      ;no, put ourselves at next bank boundry
        xor     cx,cx                   ;zero the offset in low word of ECX
        add     ecx,10000h              ;and set ECX = new start of VDD area
ELSE ; ALLOW_32K_VIRTUALIZATION
        cmp     al,dl                   ;do we have any room at all?
        ja      MGVBMemoryShy           ;nope, turn off VGA virtualization
        jne     MGVBEvenBank            ;we can start on an even bank boundry.
        cmp     cx,08000h               ;do we have at least 32K left
        ja      MGVBMemoryShy           ;start above 32K, so less than 32K
        mov     cx,08000h               ;start at 32K offset
        jmp     @f
MGVBEvenBank:
        inc     al                      ;no, put ourselves at next bank boundry
        xor     cx,cx                   ;zero the offset in low word of ECX
        add     ecx,10000h              ;and set ECX = new start of VDD area
@@:
ENDIF ; ALLOW_32K_VIRTUALIZATION
;
public  MGVBCalcAmountToUse
MGVBCalcAmountToUse:
;
;At this point:
;       AL contains the bank number for VDD use.
;       ECX contains the 32 bit address of the start of this memory.
;
        mov     edx,TotalMemorySize     ;get total amount of video memory
        sub     edx,ecx                 ;EDX = amount of memory from start
                                        ;of VDD bank till end of video memory
; MSK - I added this apparently missing check for no memory left.
        jz      MGVBMemoryShy           ;do we have any memory left?
        cmp     edx,64*1024             ;do we have more than 64K left?
        mov     edx,64*1024             ;(assume we do have more than 64K left)
; MSK - I changed this to jae from ja because exactly 64K should be just fine.
; MSK - TODO - DEBUG - change to ja to debug 32K setup!!!
        jae      MGVBGetBankingValues   ;we can use an entire 64K bank for VDD!
        mov     edx,32*1024             ;we can only use 32K for the VDD!
;
public  MGVBGetBankingValues
MGVBGetBankingValues:
;
;At this point:
;       AL contains the bank number for the VDD virtualization bank.
;       ECX contains the 32 bit start address of the VDD virtualization area.
;       EDX contains the size of the VDD virtualization area (either 32K,
;           64K, or -1 indicating a memory shy configuration).
;
;We should setup the values for the NVidia banking registers so that we can set
;them quickly when called upon by the "main" VDD to do so:
;
        push    edx                     ;save size of VDD area for now
        push    ebx                     ;we need this as a work register
        mov     BankRegSaveLow,0ffh     ;make sure this wasn't messed up
                                        ;by board initialization
;        
;When the MemC is in 4 plane mode (such as when virtualizing 4 plane
;VGA apps in a window), we must actually divide the bank number that
;we calculated above (currently in AL) by 4.  If our bank number isn't
;easily divisible by 4, we must return the odd number to the main VDD
;so it can adjust accordingly:
;
        mov     ah,al                   ;copy bank number to AH for odd calc
        shr     al,2                    ;this is the physical bank that we use
        and     ah,03h                  ;this is page offset from bank's start
        shl     ah,2                    ;convert from 64K bank offset to
                                        ;number of pages (4Kx4planes=16K)
IFDEF ALLOW_32K_VIRTUALIZATION
        mov     ebx,ecx                   ;get offset into 64K bank (16Kx4planes)
        shr     ebx,14                   ;convert from bytes to pages (4Kx4planes=16K=2^14)
        add     ah,bl                   ;add to page offset
ENDIF ; ALLOW_32K_VIRTUALIZATION
        mov     VDDPageOffsetFromBank,ah
                                        ;save this for SetVDDBank
        mov     bl,al                   ;copy bank number to BL & BH for now
        shl     bl,1                    ;get bank bits in place
        mov     VDDBank,bl              ;save this for use in virtualization
        pop     ebx                     ;restore saved registers
        pop     edx                     ;
        jmp     MGVBExit                ;
;
public  MGVBMemoryShy
MGVBMemoryShy:
;
;If we reach this point, it means that the Windows visible screen overlaps
;into the very last bank of available video memory.  This creates a
;"memory-shy" configuration which prohibits us from running windowed
;and background EGA/VGA graphics mode apps.
;
;At this point:
;       ECX contains the value passed in at the beginning of the routine.
;
        mov     edx,ecx                 ;indicate a "memory-shy" configuration
;
ENDIF   ;OLD_BANK_STRATEGY

MGVBExit:
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_GetVDDBank
;
;
subttl          Banking Handling Code for VGA Virtualization
page +
public  MiniVDD_SetVDDBank
BeginProc MiniVDD_SetVDDBank, DOSVM
;
;This routine is called when we need to virtualize something in the
;off-screen region of the video memory.  You should save the current
;state of the banking registers and then set your banking registers to
;the off-screen memory region.
;
;Entry:
;       EBX contains the MemC owner's VM handle.
;Exit:
;       Save any registers that you use.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SetVDDBank", DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     BankRegSaveLow,0ffh     ;are we already set to the VDD bank?
        jne     MSTVExit                ;yes! don't do it again!
        cmp     SuperVGAModeFlag,0      ;running in 4 plane VGA mode?
        je      MSTVExit                ;yes, don't do anything here
        push    eax                     ;
        push    edx                     ;
;
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current CRTC index
        ror     eax,8                   ;save it in top byte of EAX
;
;Let's make sure that the NVidia extended registers are unlocked.  This is
;probably not necessary when our CRTC VM is the Windows VM but could happen
;when the CRTC VM is not the Windows VM:
;
;        unlock_extension_regs
        call    unlock_ext

        mov     al,01Dh                 ;set to banking register
        out     dx,al                   ;
        inc     edx                     ;
        in      al,dx                   ;now AL has current bank state
        mov     BankRegSaveLow,al       ;save this for later restore
;
        mov     al,VDDBank              ;now, set the VDD bank
        out     dx,al                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        mov     al,01Eh                 ;set to other banking register
        out     dx,al
        inc     edx                     ;
        in      al,dx                   ;now AL has current bank state
        mov     BankRegSaveHigh,al      ;save this for later restore
;
        mov     al,VDDBank              ;now, set the VDD bank
        out     dx,al                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        rol     eax,8                   ;AL now contains saved CRTC index value
        out     dx,al                   ;

                call    restore_lock
        pop     edx                     ;restore saved registers
        pop     eax                     ;
;
MSTVExit:
        ret                             ;
EndProc MiniVDD_SetVDDBank
;
;
public  MiniVDD_ResetBank
BeginProc MiniVDD_ResetBank, DOSVM
;
;This routine is called when the VDD is done using the off-screen memory
;and we want to restore to the bank that we were in before we started using
;the off-screen memory.  Note that if the bank that's currently set in the
;hardware's banking registers is NOT the VDD bank, that we do not wish to
;reset the banking since someone else purposely changed it and we don't
;want to override those purposeful changes.
;
;Entry:
;       EBX contains the VM handle.
;Exit:
;       Save anything that you use.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_ResetBank", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     BankRegSaveLow,0ffh     ;is there any banking to restore?
        je      MRBExit                 ;nope, skip this!
;
;We may need to do something.  Save off the current CRTC index register state:
;
        push    eax                     ;
        push    edx                     ;
;
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current CRTC index
        ror     eax,8                   ;save it in top byte of EAX
;
;Probably not necessary when our CRTC VM is the Windows VM but most likely
;is when the CRTC VM is not the Windows VM:
;
;        unlock_extension_regs
        call    unlock_ext
;
;Get the values of the banking register so we can see if its still
;set to "our" bank.  If it isn't, then Windows has already switched
;it to something for its own purposes and we'd best not restore it!
;
        mov     al,01Eh                 ;this is the NVidia banking register
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        cmp     al,VDDBank              ;are we still set to VDD bank?
        jne     MRBResetBankSaveFlags   ;nope, don't physically reset bank regs
;
        mov     al,01Dh                 ;this is the NVidia banking register
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        cmp     al,VDDBank              ;are we still set to VDD bank?
        jne     MRBResetBankSaveFlags   ;nope, don't physically reset bank regs
;
;It's safe to restore the banking registers!
;
;At this point:
;       EDX -> CRTC Data Register
;
        mov     al,01Dh                 ;this is the NVidia banking register
        mov     ah,BankRegSaveLow       ;get bank to restore
        out     dx,ax                   ;
;
        mov     al,01Eh                 ;set to other banking register
        mov     ah,BankRegSaveHigh      ;get bank to restore
        out     dx,ax                   ;
;
public  MRBResetBankSaveFlags
MRBResetBankSaveFlags:
        mov     BankRegSaveLow,0ffh     ;flag that we're not set to VDD bank
        mov     BankRegSaveHigh,0ffh     ;flag that we're not set to VDD bank
;
                call    restore_lock
;Lastly, restore the CRTC index register that we saved earlier.
        rol     eax,8                   ;AL now contains saved CRTC index value
        out     dx,al                   ;
        pop     edx                     ;restore saved registers
        pop     eax                     ;
;
MRBExit:
        ret                             ;
EndProc MiniVDD_ResetBank
;
;
subttl          Set To Latch Scratchpad Bank
page +
public  MiniVDD_SetLatchBank
BeginProc MiniVDD_SetLatchBank, DOSVM
;
;When virtualizing the VGA 4 plane mode, we have to save and restore the
;latches occasionally.  This routine allows you to set to an off-screen
;bank (in this case and in most cases, the VDD bank) in order to prepare
;for restoring the VGA latches.  This routine is NOT called for saving
;the latches since this is done by simply using the standard VGA CRTC
;register 22H which all super-VGA's possess (we hope).
;
;Entry:
;       Nothing assumed.
;Exit:
;       Save anything that you use.
;
;;IFDEF DEBUG_LOG
;;        .if (DebugOn != 0)
;;                push    eax
;;                Debug_Printf    "MiniVDD_SetLatchBank", DEBLEVELMAX
;;                pop     eax
;;        .endif
;;ENDIF ; DEBUG_LOG
        push    eax                     ;save registers that we use
        push    edx                     ;
        cmp     SuperVGAModeFlag,0      ;running in 4 plane VGA mode?
        je      MSLBExit                ;yes, don't do anything here
;
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current CRTC index
        ror     eax,8                   ;save it in top byte of EAX
;
;Let's make sure that the NVidia extended registers are unlocked.  This is
;probably not necessary when our CRTC VM is the Windows VM but most likely
;is when the CRTC VM is not the Windows VM:
;
;        unlock_extension_regs
        call    unlock_ext
;
        mov     al,01Dh                 ;set to banking register
        out     dx,al                   ;
        inc     edx                     ;
        in      al,dx                   ;now AL has current bank state
        mov     LatchSaveLow,al         ;save this for later restore
;
        mov     al,VDDBank              ;now, set the VDD bank
        out     dx,al                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        mov     al,01Eh                 ;set to other banking register
        out     dx,al
        inc     edx                     ;
        in      al,dx                   ;now AL has current bank state
        mov     LatchSaveHigh,al        ;save this for later restore
;
        mov     al,VDDBank              ;now, set the VDD bank
        out     dx,al                   ;
        dec     edx                     ;EDX --> CRTC index register
;
                call    restore_lock
        rol     eax,8                   ;AL now contains saved CRTC index value
        out     dx,al                   ;

;
MSLBExit:
        pop     edx                     ;restore saved registers
        pop     eax                     ;
        ret                             ;
EndProc MiniVDD_SetLatchBank
;
;
subttl          Reset Banking After Latch Operations
page +
public  MiniVDD_ResetLatchBank
BeginProc MiniVDD_ResetLatchBank, DOSVM
;
;This routine reverses the latch save that we did prior to restoring the
;latches.  Just restore the states that you saved.
;
;Entry:
;       Nothing assumed.
;Exit:
;       Save anything that you use.
;
;;IFDEF DEBUG_LOG
;;        .if (DebugOn != 0)
;;                push    eax
;;                Debug_Printf    "MiniVDD_ResetLatchBank", DEBLEVELMAX
;;                pop     eax
;;        .endif
;;ENDIF ; DEBUG_LOG
        push    eax                     ;save registers that we use
        push    edx                     ;
        cmp     SuperVGAModeFlag,0      ;are we running NVIDIA.DRV?
        je      MRLBExit                ;nope, don't do anything here
;
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get and save CRTC index value
        ror     eax,8                   ;

;Let's make sure that the NVidia extended registers are unlocked.  This is
;probably not necessary when our CRTC VM is the Windows VM but most likely
;is when the CRTC VM is not the Windows VM:
;
;        unlock_extension_regs
        call    unlock_ext
;
;Restore banking-enabling register:
;
        mov     al,01Dh                 ;set to new banking register
        mov     ah,LatchSaveLow         ;get bank to restore
        out     dx,ax                   ;
;
        mov     al,01Eh                 ;set to other banking register
        mov     ah,LatchSaveHigh        ;get bank to restore
        out     dx,ax

                call    restore_lock
;
;Restore the CRTC index register:
;
        rol     eax,8                   ;
        out     dx,al                   ;
;
MRLBExit:
        pop     edx                     ;restore saved registers
        pop     eax                     ;
        ret                             ;
EndProc MiniVDD_ResetLatchBank
;
;
subttl          Prepare to Enter a Standard VGA Mode from HiRes Mode
page +
public  MiniVDD_PreHiResToVGA
BeginProc MiniVDD_PreHiResToVGA, DOSVM
;
;When the VDD is about to switch from Windows HiRes mode to any of the
;standard VGA modes (for real -- not virtualized), this routine will be
;called.  You need to determine exactly what your hardware requires in
;order to accomplish this task.  For example, you should disable trapping
;on registers that the mini-VDD is specifically handling (such as 4AE8H
;in the case of the S3 chipset), make sure that the hardware is "ready"
;to undergo a mode transition (make sure that your hardware's graphics
;engine isn't in the middle of an operation that can't be interrupted)
;etc.  If your hardware does not return to a standard VGA mode via
;a call to INT 10H, function 0, you should also make sure to do whatever
;it takes to restore your hardware to a standard VGA mode at this time.
;Try not to touch video memory during your transition to standard VGA as
;this will disturb the reliability of the system.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
          push    eax
          Debug_Printf    "MiniVDD_PreHiResToVGA", DEBLEVELMAX
          pop     eax
        .endif
ENDIF ; DEBUG_LOG
        or      ModeChangeFlags,GOING_TO_VGA_MODE
        mov     DosBoxActive,1          ; DOS box active, let int 10 go thru in dual head mode

    ;
    ; CANOPUS Programming changes -- only use if customer == CANOPUS
    ;
    test nvCustomer, NVCUSTOMER_CANOPUS
    jz   dos_can1

        ; We flush OffScreen cache at this point.
        ; Our modified display driver ignores notify from CreateVM/DestroyVM.
        ; It should not disable OffScreen for windowed dos prompt.
DISABLE_OFF_SCREEN  equ 4050h
        pushad
        VMMcall Get_Cur_VM_Handle
        xchg    eax,ebx
        VMMCall Get_Sys_VM_Handle
        cmp     eax,ebx
        jne     @f

        mov     ebp,[ebx.CB_Client_Pointer]         ; EBP = Windows VM client regs ptr
        Push_Client_State                           ; allocate client regs area
        VMMcall Begin_Nest_Exec                     ; prepare to execute INT2Fh notification
        mov     [ebp.Client_AX],DISABLE_OFF_SCREEN  ; AX = high-res to VGA mode
        mov     eax,2Fh                             ; EAX = INT2Fh interrupt call
        VMMcall Exec_Int                            ; notify driver of entering VGA mode
        VMMcall End_Nest_Exec                       ;
        Pop_Client_State                            ; deallocate client regs area
@@:
        popad
dos_can1:

;
;       call RM to enable VGA (use API)

;       LPL: call below occured before flags had been set indicating
;       a switch to DOS mode, which caused race conditions (specifically,
;       when using hardware DVD players we have seen the system lock up
;       because FIFO activity continues after this disable of context switching,
;       and the system then hangs waiting for the FIFOs to empty (see bug 20000601-184547)).
;       There is a call to this same routine later in the switch to DOS.
;       We believe it's safe to remove this one.
;
;        push    ebx 
;        mov     ebx, DEFAULT_PRIMARY_HDEV
;        mov     eax, NVRM_API_ENABLEVGA
;        call    CallRM
;        pop     ebx
        
; Blank the secondary display on a dual-head adapter in case this is message mode
        push    ebx 
        mov     ebx, DEFAULT_PRIMARY_HDEV
        mov     eax, NVRM_API_BLANK_SECONDARY
        call    CallRM
        pop     ebx

        ; After the RM-EnableVGA, the RM has forced GET=PUT and
        ; all channels are idle. To make sure that no one renders
        ; anything, set some shared flags that say 'We are in a
        ; fullscreen DOS BOX -- don't do any rendering.'
        ; Top bit of 0 indicates that we are in a fullscreen
        ; DOS box. Top bit of 1 indicates that we are in
        ; the Windows VM. The low 31bits are individual 'enable'
        ; bits that D3D will clear as each sub-system reinits
        ; itself on returning to the Windows VM from fullscreen DOS.
        mov     eax,pDDrawFullScreenDOSActive
        or      eax,eax
        je      @F
        mov     dword ptr [eax],7FFFFFFFH
@@:

;
; CANOPUS TV Programming -- only use if customer is CANOPUS
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
;
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      PHRTV_NoCanopus13

        mov     al, bCanopusTVReg       ;-- first check, if the BIOS supports Canopus TV 
        or          al, al                      
        jz          PHRTV_NoCanopus14   ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read TV Flag register
        mov         edi,ebx                     ;get pointer to our CB data area
        add         edi,OurCBDataPointer        ;EDI --> our CB data area for this VM
        mov         ah,[edi].PerVMData.EXT_CanopusTVReg
        test    ah, 040h                ; already initialized ???
        jnz     @F                      ; yes, go on

        mov     al, bCanopusTVReg       ; else get the current register contents
        out     dx, al
        inc     dx              
        in          al, dx
        dec     dx
        mov     ah, al                  ; and modify this one...
@@:
        and     ah, 07fh                ; clear the INACTIVE flag (TV_FLAG_REGISTER)
        mov     al, bCanopusTVReg                       
        out     dx, ax                  ; and write the new value back...
        jmp     short PHRTV_NoCanopus14
PHRTV_NoCanopus13:
;   tell the BIOS to program the TV encoder
        call    TellBIOSProgramTV
;
PHRTV_NoCanopus14:

;
MHTVExit:
        ret
EndProc MiniVDD_PreHiResToVGA
;
;
public  MiniVDD_PostHiResToVGA
BeginProc MiniVDD_PostHiResToVGA, DOSVM
;
;Entry:
;       EBX contains the VM handle of the new CRTC owner.
;
;This routine will be called if we're running VGA.DRV, SUPERVGA.DRV, or
;NVIDIA.DRV and applies to all drivers.
;
;This routine is called after the ROM BIOS call is made to place the hardware
;back in the standard VGA state.  You should reenable trapping and do any
;other post-processing that your hardware might need:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PostHiResToVGA", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        mov     ModeChangeFlags,0       ;flag that we're done with mode change
        mov     InFullScreen, 0ffh      ; mark that we're now in full screen mode  CANOPUS

        call    unlock_ext
        call    GetCRTCPort             ; EDX --> CRTC index register

;   MOVED TO PREVGATOHIRES to allow mode switches to take effect in full screen DOS.
;   tell the BIOS NOT to program the TV encoder
;        call    GetCRTCPort
;        mov     al,BIOS_SCRATCH1          ; BIOS scratch reg
;        out     dx,al
;        inc     dx
;        in      al,dx
;        or      al,BIOS_PGRM_TV           ; set bit 1 (do not program TV encoder)
;        out     dx,al

;   Switch to VGA-compatible timing (RM modeset sets non-VGA timing for DirectX compatibility)
        mov     al,21h
        out     dx,al
        inc     dx
        in      al,dx
        and     al,0feh
        out     dx,al

        push    ebx
        add     ebx, OurCBDataPointer
        mov     [ebx].PerVMData.GoingFullscreen, 1
        pop     ebx

        ;
        ; Refresh MessageModeCBData
        ;
        ; save real mode window state
        push    eax
        push    ebx
        push    esi
        push    edx
        call    SaveNVAccessState
        mov     ebx,OFFSET32 MessageModeCBData
        mov     [ebx].PerVMData.EXT_RealModeAccess,al
        mov     [ebx].PerVMData.EXT_RealModeAddress,esi
        mov     [ebx].PerVMData.EXT_RealModeData32,dx
        ; save dac
        REG_RD32(NV_PRAMDAC_VPLL_COEFF)
        mov     [ebx].PerVMData.EXT_NV_VPLL_COEFF,eax
        REG_RD32(NV_PRAMDAC_VPLL2_COEFF)
        mov     [ebx].PerVMData.EXT_NV_VPLL2_COEFF,eax
        ; save VCLK/2
        REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT)
        mov     [ebx].PerVMData.EXT_NV_PRAMDAC,eax
        ; Save DAC General Control
        REG_RD32(NV_PRAMDAC_GENERAL_CONTROL)
        mov     [ebx].PerVMData.EXT_NV_PDAC_GEN_CTRL,eax
        ;
        pop     edx
        pop     esi
        pop     ebx
        pop     eax

;ifdef DISPLAY_SWITCH
                cmp             DisplayChanged,0                ;set in PostCRTCModeChange
                je              DispNC
                mov             DisplayChanged,0
;If display type changed, save the standard crtc regs;
;The BIOS was called to set the mode for this display, but the VDD will mess things up,
;so we'll save the CRTC's here and restore them in RestoreRegisters.
                mov             RestoreStdCRTC,1                        ; set flag for RestoreRegisters

        mov     edi,ebx                 ;get pointer to our CB data area
        add     edi,OurCBDataPointer    ;EDI --> our CB data area for this VM
                push    ebx

;;;             mov             dx,3c4h                                 ;save sequencer 1
;;;             mov             al,1
;;;             out             dx,al
;;;             inc     dx
;;;             in              al,dx
;;;             mov             [edi].PerVMData.SR1,al

                mov             dx,3d4h
                xor             ebx,ebx

;RYAN@TV: We want to save the timing regs, not the VGA regs.
;(Subtle but important difference.)  To that end, enable reading of
;the true CRTC registers
                mov             ax, 013Dh
                out             dx, ax

;       save 0-18h
savstd:
                mov             al,bl
                out             dx,al
                inc             dx
                in              al,dx
                dec             dx
                mov             [edi+ebx].PerVMData.StdCRTC,al
                inc             bx
                cmp             bx,19h
                jne             savstd

;RYAN@TV: Now, re-enable reading of the "fake" CRTC registers.
                mov             ax, 003Dh
                out             dx, ax

                pop             ebx
DispNC:
;endif ; DISPLAY_SWITCH


        call    restore_lock
;
;We have just entered a full screen VGA DOS box and none of the CRTC registers
;were trapped.  We need to get a snapshot of the NV extended registers in
;this new CRTC mode since we may have inappropriate states saved.
;
                cmp         ebx,MessageModeID   ;are we switching to Message Mode?
                je          @f                                  ;yes, don't do the save!
                call    MiniVDD_SaveRegisters   ;go save new state of registers
@@:

;IFDEF SUPER_VGA_FIX
;       may need to copy framebuffer from our save buffer
                cmp             fbBuffer,0
                jz              copyfb_done

                mov             esi,fbBuffer
                mov             edi,fbAddr
                mov             ecx,(08000h/4 - 1)
                rep     movsd
                VMMCall _HeapFree, <fbBuffer, 0>
                mov             fbBuffer,0
copyfb_done:
;ENDIF ;SUPER_VGA_FIX

MPHVExit:
        ret                             ;
EndProc MiniVDD_PostHiResToVGA
;
;
subttl          Prepare to Enter HiRes Mode From a Standard VGA Mode
page +
public  MiniVDD_PreVGAToHiRes
BeginProc MiniVDD_PreVGAToHiRes, DOSVM
;
;We are notified that the VDD is about to call the display driver to
;switch into HiRes mode from a full screen VGA DOS box.  We can do
;anything necessary to prepare for this.  In the case of the NVIDIA VDD,
;we simply set a flag telling us that we're about to change modes.
;
;Entry:
;       EBX contains the Windows VM handle.
;Exit:
;       Nothing assumed.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PreVGAToHiRes", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        or      ModeChangeFlags,GOING_TO_WINDOWS_MODE
        mov     DosBoxActive,0  ; back to Windows, trap int 10 in dual head mode

;
; CANOPUS TV PROGRAMMING -- only use if customer is CANOPUS
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      PHRTV_NoCanopus23
        mov     al, bCanopusTVReg               ;-- first check, if the BIOS supports Canopus TV 
        or          al, al                      
        jz          PHRTV_NoCanopus24   ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read TV Flag register
        mov         edi,ebx                     ;get pointer to our CB data area
        add         edi,OurCBDataPointer        ;EDI --> our CB data area for this VM
        mov         ah,[edi].PerVMData.EXT_CanopusTVReg
        test    ah, 040h                ; already initialized ???
        jnz     @F                      ; yes, go on

        mov     al, bCanopusTVReg       ; else get the current register contents
        out     dx, al
        inc     dx              
        in          al, dx
        dec     dx
        mov     ah, al                  ; and modify this one...
@@:
        and     ah, 07fh                ; clear the INACTIVE flag (TV_FLAG_REGISTER)
        mov     al, bCanopusTVReg                       
        out     dx, ax                  ; and write the new value back...
PHRTV_NoCanopus23:
;
;   tell the BIOS NOT to program the TV encoder
        call    TellBIOSNotProgramTV
PHRTV_NoCanopus24:

        mov     InFullScreen, 0h            ; mark that we're leaving full screen mode  CANOPUS

;IFDEF SUPER_VGA_FIX
;When Super VGA modes get windowed, the VDD can't handle it. When the user returns to full screen,
;the fb content is lost. We can fix this by copying the frame buffer and restoring it when we
;return to full screen. The only problem is that the cursor position will be wrong.
                
;Find out what mode we are in
                mov             dx,3d4h
                xor             al,al                   ; read CR00
                out             dx,al
                inc             dx
                in              al,dx
                cmp             al,5fh                  ; greater than 640?
                jbe             save_not_needed ; no, VDD can handle

;In some modes, the Grabber won't correctly save and restore memory.
; We'll do it ourselves here.
                VMMCall _HeapAllocate, <8000h, 0>
                cmp             eax,0
                jz              @f

;Copy 32k
                mov             esi, fbAddr
                mov             fbBuffer,eax
                mov             edi, eax
                mov             ecx, (08000h/4 - 1)
                rep movsd
@@:
                mov             fbBuffer,eax

save_not_needed:
;ENDIF SUPER_VGA_FIX

;For NVidia, tell the resource manager we are returing to HiRes mode so it
;can restore all the contexts.

;       call RM to enable VGA (use API)
                push    ebx
                mov     ebx, DEFAULT_PRIMARY_HDEV
                mov     eax, NVRM_API_ENABLEHIRES
                call    CallRM
                pop     ebx 

;
MSVHExit:
        ret                             ;
EndProc MiniVDD_PreVGAToHiRes
;
;
public  MiniVDD_PostVGAToHiRes
BeginProc MiniVDD_PostVGAToHiRes, DOSVM
;
;We are notified that the VDD is done setting the hardware state back
;to HiRes mode.  We simply unset our ModeChangeFlags in this case.
;
;Entry:
;       EBX contains the Windows VM handle.
;Exit:
;       Nothing assumed.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PostVGAToHiRes", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

        mov    ModeChangeFlags,0      ;

        ; Top bit of 0 indicates that we are in a fullscreen
        ; DOS box. Top bit of 1 indicates that we are in
        ; the Windows VM. The low 31bits are individual 'enable'
        ; bits that D3D will clear as each sub-system reinits
        ; itself on returning to the Windows VM from fullscreen DOS.
        mov     eax,pDDrawFullScreenDOSActive
        or      eax,eax
        je      @F
        or      dword ptr [eax],80000000H
@@:


;
; CANOPUS TV Programming -- only use if customer is CANOPUS
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
;
    test    nvCustomer, NVCUSTOMER_CANOPUS
    jz      skip_MPVTHR_Canopus01
    
        pusha

        mov     al, bCanopusTVReg       ;-- first check, if the BIOS supports Canopus TV 
        or      al, al                  
        jz      @F                      ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read Canopus TV register
        mov     al, bCanopusTVReg
        out     dx, al
        inc     dx              
        in      al, dx
        dec     dx
        or      al, TVF_INACTIVE        ; set the INACTIVE flag (TV_FLAG_REGISTER)
        mov     ah, al
        mov     al, bCanopusTVReg                       
        out     dx, ax                  ; and write the new value back...
@@:
        popa
skip_MPVTHR_Canopus01:
;
MPVHExit:
        ret                             ;
EndProc MiniVDD_PostVGAToHiRes
;
;
subttl          Save and Restore Routines for Extension Registers
page +
public  MiniVDD_SaveRegisters
BeginProc MiniVDD_SaveRegisters, DOSVM
;
;This routine is called whenever the "main" VDD is called upon to save
;the register state.  The "main" VDD will save all of the states of the
;"normal" VGA registers (CRTC, Sequencer, GCR, Attribute etc.) and will
;then call this routine to allow the mini-VDD to save register states
;that are hardware dependent.  These registers will be restored during the
;routine MiniVDD_RestoreRegisterState.  Typically, only a few registers
;relating to the memory access mode of the board are necessary to save
;and restore.  Specific registers that control the hardware BLTer probably
;need not be saved.  The register state is saved in the mini-VDD's
;"CB data area" which is a per-VM state saving area.  The mini-VDD's
;CB data area was allocated at Device_Init time.
;
;Entry:
;       EBX contains the VM handle for which these registers are being saved.
;Exit:
;       You must preserve EBX, EDX, EDI, and ESI.
;
; MSK - TODO - Why do other VDD's only do a few registers and why does comment
; above say only registers relating to memory access mode are needed to be saved
; and restored.
; One possible explination is that set modes are always done for switching to full
; screen dos boxes, and thus this is only needed for the MemC support for windowed
; DOS boxes.  What about message mode?  Does it do a setmode?
; idea, use protected mode interface to call the BIOS to save the state into a buffer
; Remember case of CRTC being the foreground full screen DOS box, and
; MemC being a different background DOS box.
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SaveRegisters", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

        cmp     nvAddr,0      ;running NVidia drivers?
        je      MSRSExit                ;nope, don't do this

        push    edx                     ;save required registers
        push    edi                     ;
        mov     edi,ebx                 ;get pointer to our CB data area
        add     edi,OurCBDataPointer    ;EDI --> our CB data area for this VM

        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get and save current CRTC index ...
        ror     eax,8                   ;in high byte of EAX

        call    ReadCr44                ;Read Cr44        
        mov     [edi].PerVMData.EXT_HeadOwner,al

        .if (al == 04)
                xor     ax,ax        ;Clear ax
                call    WriteCr44    ;Set CR44 to Head A
        .endif

;
;        unlock_extension_regs
        call    unlock_ext
;
        mov     al, 19h                 ;set to CRTC index 019h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 019h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_Repaint0NV,al
;
        mov     al, 1Ah                 ;set to CRTC index 01Ah
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Ah
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_Repaint1NV,al
                                        ;signal that this register is valid
        mov     [edi].PerVMData.EXT_Repaint1NVSet,0FFh
;
        mov     al, 1Bh                 ;set to CRTC index 01Bh
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Bh
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_FifoBurst,al
;
        mov     al, 1Ch                 ;set to CRTC index 01Ch
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Ch
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_Repaint3NV,al
;
        mov     al, 1Dh                 ;set to CRTC index 01Dh
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Dh
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_WriteBank,al
;
        mov     al, 1Eh                 ;set to CRTC index 01Eh
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Eh
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_ReadBank,al
;
        mov     al, 20h                 ;set to CRTC index 020h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 020h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_FifoLowWaterMark,al
;
        mov     al, 25h                 ;set to CRTC index 025h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 025h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_ExtraBits,al
;
        mov     al, 28h                 ;set to CRTC index 028h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 028h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_PixelFormat,al
;
        mov     al, 29h                 ;set to CRTC index 029h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 029h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_TVDecimation,al
;
; CANOPUS TV Programming
;
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      @f
CANOPUS_SaveRegisters:
        mov         al, bCanopusTVReg   ;set to CRTC index CanopusTVReg
        or          al, al                      ; Canopus TV supported ?
        jz          @F                  ; No, go on

        out         dx,al                       ;
        inc         edx                 ;EDX --> CRTC data register
        in          al,dx                       ;get data from Canopus TV register 
        dec         edx                 ;EDX --> CRTC index register
;; For Canopus TV we use this register as Flag register and won't like 
;; the VDD to touch bit 7
        and         al, NOT TVF_INACTIVE        ; don't touch bit 7 !!!
                                        ;save the data in our CB data structure
        mov         [edi].PerVMData.EXT_CanopusTVReg,al
@@:


        mov     al, 2Ah                 ;set to CRTC index 02Ah
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 02Ah
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_OverscanHigh,al
;
        mov     al, 2Dh                 ;set to CRTC index 02Dh
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 02Dh
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_HorizontalExtra,al
;
        mov     al, 30h                 ;set to CRTC index 030h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 030h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_HWCursorAddress0,al
;
        mov     al, 31h                 ;set to CRTC index 031h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 031h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_HWCursorAddress1,al
;
        mov     al, 32h                 ;set to CRTC index 032h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 032h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_VideoWindow0,al
;
        mov     al, 33h                 ;set to CRTC index 033h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 033h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_VideoWindow1,al
;
        mov     al, 39h                 ;set to CRTC index 039h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 039h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_Interlace,al
;
; save real mode window state
        push    eax
        push    esi
        push    edx
        call    SaveNVAccessState
        mov     [edi].PerVMData.EXT_RealModeAccess,al
        mov     [edi].PerVMData.EXT_RealModeAddress,esi
        mov     [edi].PerVMData.EXT_RealModeData32,dx
IF 1
; save dac
        REG_RD32(NV_PRAMDAC_VPLL_COEFF)
        mov     [edi].PerVMData.EXT_NV_VPLL_COEFF,eax
; save VCLK/2
        REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT)
        mov     [edi].PerVMData.EXT_NV_PRAMDAC,eax
; Save DAC General Control
        REG_RD32(NV_PRAMDAC_GENERAL_CONTROL)
        mov     [edi].PerVMData.EXT_NV_PDAC_GEN_CTRL,eax
ENDIF
        ;
        pop     edx
        pop     esi
        pop     eax

                call    restore_lock

        .if ([edi].PerVMData.EXT_HeadOwner == 04)
                mov     al,04h        ;Set CR44 back to broadcast mode
                call    WriteCr44     ;Do the write thing
        .endif

;Restore the CRTC index register saved in the high byte of EAX:
;
        rol     eax,8                   ;
        out     dx,al                   ;
;
        pop     edi                     ;restore saved registers
        pop     edx                     ;
;
MSRSExit:
        ret
EndProc MiniVDD_SaveRegisters
;
;
subttl          Save and Restore Routines for Extension Registers
page +
public  MiniVDD_RestoreRegisters
BeginProc MiniVDD_RestoreRegisters, DOSVM
;
;This routine is called whenever the "main" VDD is called upon to restore
;the register state.  The "main" VDD will restore all of the states of the
;"normal" VGA registers (CRTC, Sequencer, GCR, Attribute etc.) and will
;then call this routine to allow the mini-VDD to restore register states
;that are hardware dependent.  These registers were saved during the
;routine MiniVDD_SaveRegisterState.  Typically, only a few registers
;relating to the memory access mode of the board are necessary to save
;and restore.  Specific registers that control the hardware BLTer probably
;need not be saved.  The register state is saved in the mini-VDD's
;"CB data area" which is a per-VM state saving area.  The mini-VDD's
;CB data area was allocated at Device_Init time.
;
;Entry:
;       ESI contains the VM handle for the MemC owner VM.
;       ECX contains the VM handle for the CRTC owner VM.
;Exit:
;       You must preserve EBX and EDX.  The caller preserves everything else.
;
;A short explanation of the terms "CRTC owner" and "MemC owner" is in order.
;The CRTC owner VM is the VM that owns the screen mode.  If you're running
;on the Windows desktop, then the Windows VM is the CRTC owner.  If you're
;running a full-screen DOS box, then that DOS box's VM is the CRTC owner.
;If you're running a DOS box in a window, then the CRTC owner is Windows
;but the MemC owner is the DOS VM.  What significance does this have?
;Well, when you restore the register state of a DOS VM running in a
;Window, it means that you're getting ready to VIRTUALIZE the VGA by
;using the off-screen memory.  Your VGA hardware must be setup to write
;to this memory in EXACTLY THE SAME WAY AS IF THE VGA WAS RUNNING IN
;NATIVE VGA MODE.  But...  you also must preserve the appearance of the
;Windows screen which is being displayed on the VISIBLE screen.  Thus,
;we have the screen looking like it's running in Windows HiRes packed
;pixel mode from the user's perspective, but the CPU sees the video
;memory as a 4 plane VGA.  Thus, we present this routine with both
;the CRTC owner and the MemC owner's VM handles.  Therefore, you can
;restore those states from the CRTC owner that preserve the appearance
;of the screen while restoring those states from the MemC owner that
;control how the CPU sees the video memory.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_RestoreRegisters", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":CRTC:%08lX", ecx, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                Debug_Printf    "\n\r", DEBLEVELMAX
                call    DumpRegisters
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

        push    ebx
        push    ecx
        push    edx                     ;save caller's EDX
        push    esi


        cmp     DisplayEnabledFlag,0    ;is display in HiRes mode yet?
        je      MRRSExit                ;nope, don't do anything yet
        cmp     nvAddr,0                            ;running NVidia drivers?
        je      MRRSExit                ;nope, don't do this
;
        test    ModeChangeFlags,GOING_TO_WINDOWS_MODE OR GOING_TO_VGA_MODE
        jnz     MRRSExit                ;in a mode change, don't restore now
;
        cmp     ecx,WindowsVMHandle     ;is it the system VM?
        jz      MRRSExit                ;there are no registers which need to be restored
        
        .if (esi == MessageModeID)                      ;Does message mode own the MemC
                mov     esi,OFFSET32 MessageModeCBData  ;ESI --> Forced Message Mode CB Data
        .elseif (esi == PlanarStateID)                  ;Does planar state own the MemC
                mov     esi,OFFSET32 ForcedPlanarCBData ;ESI --> Forced Planar CB data
        .else
                add     esi,OurCBDataPointer            ;ESI --> MemC's CB data
        .endif
;
        .if (ecx == MessageModeID)                      ;Does message mode own the CRTC
                mov     ecx,OFFSET32 MessageModeCBData  ;ECX --> Forced Message Mode CB Data
        .else
                add     ecx,OurCBDataPointer            ;ECX --> CRTC's CB data

if 0   ;ifdef DISPLAY_SWITCH
; If the display device changes while a window'd DOS VM was active, we need to let the BIOS
; program the standard and extended CRTC regs, since the main VDD may have saved timings 
; for the previous device, and our saved copy of the extended CRTCs is probably stale, too.

                ;is this the VM that's about to go fullscreen?
                cmp     [ecx].PerVMData.GoingFullscreen, 1
                jne     noBiosRestore
                mov     [ecx].PerVMData.GoingFullscreen, 0

                ;is this an alphanumeric mode?
                mov             dx,     3CEh
                mov             al,     6h
                out             dx,     al
                in              ax,     dx
                and             ah,     1
                jnz             noBiosRestore

                ;did a head change occur prior to this?
                cmp             DisplayChanged,0
                jz              noBiosRestore
                mov             DisplayChanged,0

                ;let the BIOS reconfigure the CRTCs for the new active head

                ;save text cursor position
                mov             dx,     3D4h
                mov             al,     0Eh
                out             dx,     al
                in              ax,     dx
                push            eax
                inc             al
                out             dx,     al
                in              ax,     dx
                push            eax

                ;get MSL
                mov             al,     9h
                out             dx,     al
                in              ax,     dx
                movzx           bx,     ah
                and             bx,     1Fh
                inc             bx

                ;get VDE
                mov             ax,     7h
                out             dx,     al
                in              ax,     dx
                and             ax,     200h
                shl             eax,    7
                mov             al,     12h
                out             dx,     al
                in              ax,     dx
                shr             eax,    8
                inc             ax

                ;compute VDE/MSL
                xor             dx,     dx
                idiv            bx
                mov             cx,     ax      ;number of text rows on the screen

                ;set the mode 
                mov             ax,     0083h   ;nondestructive mode 3
                push            10h
                VMMCall         Exec_VxD_Int
                mov             ax,     1201h   ;350 scanlines
                cmp             cx,     43
                je              @F
                mov             ax,     1202h   ;400 scanlines
@@:             mov             bl,     30h
                push            10h
                VMMCall         Exec_VxD_Int
                mov             ax,     0083h   ;nondestructive mode 3
                push            10h
                VMMCall         Exec_VxD_Int
                mov             ax,     1112h   ;load 8x8 font (43/50 lines)
                cmp             cx,     25
                jne             @F
                mov             ax,     1114h   ;load 8x16 font (25 lines)
@@:             mov             bl,     0
                push            10h             ;the BIOS infers dot clock and sync
                VMMCall         Exec_VxD_Int    ;polarities from this and the above

                ;restore cursor position
                mov             dx,     3D4h
                pop             eax
                out             dx,     ax
                pop             eax
                out             dx,     ax

                jmp             MRRSExit

noBiosRestore:
endif ;endif ; DISPLAY_SWITCH

        .endif
;
MRRSGotAddr:

        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get and save current CRTC index ...
        ror     eax,8                   ;in high byte of EAX

; Broadcast mode support
; If we intend to support broadcast mode, we need to save either
; both heads or one head data here.  Either way, we need to turn off
; broadcast mode if it's set so we don't override
; Here's the current decision tree
; save current_mode on stack
; if (current_mode == broadcast)
;     restore previous head only and return to broadcast mode
; else
;     restore without changing head at all
;
; Old code was not broadcast mode aware.  It just assumed that CR44
; pointed to the active head.  So we don't want to change that.
;
        call    ReadCr44        ; GetCr44 in al
        
        .if (al == 04)
                ; currently we're in broadcast
                or      al,80h                           ;flag that we need to restore CR44
                ror     eax,8                            ;store al in highest byte
                                                         ;original index now in next highest byte
                mov     al,[ecx].PerVMData.EXT_HeadOwner ;retrieve stored CR44
                call    WriteCr44
        .else
                ror     eax,8                            ;not needed, but for consistency
                                                         ;original index now in next highest byte
        .endif

;        unlock_extension_regs
        call    unlock_ext    
;
;We need to restore the state of the saved CRTC and Sequencer registers:
;
; MSK - NOTE: SetVDDBank does not change banking control in 01Ah
; it depends on things being write after RESTORE_REGISTERS because
; that is what the Windows 95 DDK documentation under GET_VDD_BANK
; says to do.
        mov     al,19h                  ;set to CRTC index 19h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_Repaint0NV
        out     dx,ax                   ;
;
        mov     al,1Ah                  ;set to CRTC index 1Ah
        mov     ah,[ecx].PerVMData.EXT_Repaint1NV ;get CRTC owner's value for this reg
        .if (ecx == OFFSET32 MessageModeCBData)   ;Does message mode own the CRTC?
                and     ah,3fh                    ;we can enable syncs; we may have saved wrong setting if we loaded on another device
        .else
                in al,dx                ; get current value
                and al,0c0h
                and ah,3fh
                or  ah,al               ; use current sync settings
                mov al,1Ah
        .endif
        out     dx,ax                   ;
;
        mov     al,1Bh                  ;set to CRTC index 1Bh
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_FifoBurst
        out     dx,ax                   ;
;
        ; We have to be a little careful with index 1C, since it holds the
        ; FIFO Burst Mode (bit 5), which indicates how the value in the FIFO
        ; Burst register (1B) should be interpreted (NV11 arbitration sets it
        ; to 0x1). Take everything, but bit 5, from MemC owner's (esi) ptr.

        push    ebx
        mov     al,1Ch                  ;set to CRTC index 1Ch
                                        ;get MemC owner's value for this reg
        mov     ah,[esi].PerVMData.EXT_Repaint3NV
        and     ah,NOT 20h              ;clear Fifo Burst Mode Bit
        mov     bh,[ecx].PerVMData.EXT_Repaint3NV
        and     bh,20h                  ;get CRTC owner's value for Fifo Burst Mode
        or      ah,bh                   ;combine the values
        out     dx,ax                   ;
        pop     ebx        
;
        cmp     esi,ecx                 ;Only restore banking if MemC owns the CRTC
                                        ;(also try using CRTC, but only if not the Windows VM)
        jne     @f
        mov     al,1Dh                  ;set to CRTC index 1Dh
                                        ;get MemC owner's value for this reg
        mov     ah,[esi].PerVMData.EXT_WriteBank
        out     dx,ax                   ;
;
        mov     al,1Eh                  ;set to CRTC index 1Eh
                                        ;get MemC owner's value for this reg
        mov     ah,[esi].PerVMData.EXT_ReadBank
        out     dx,ax                   ;
@@:
;
        mov     al,20h                  ;set to CRTC index 20h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_FifoLowWaterMark
        out     dx,ax                   ;
;
        mov     al,25h                  ;set to CRTC index 25h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_ExtraBits
        out     dx,ax                   ;
;
        mov     al,28h                  ;set to CRTC index 28h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_PixelFormat
        out     dx,ax                   ;
;
        mov     al,29h                  ;set to CRTC index 29h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_TVDecimation
        out     dx,ax                   ;

        ; CANOPUS TV Programming
        ;
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      @f
                ;; for Canopus TV we use this register as Flag register and won't like 
                ;;       the VDD to touch bit 7 !!!
CANOPUS_RestoreRegisters:
        mov         al, bCanopusTVReg   ;set to CRTC index Canopus TV register
        or          al, al                          ; Canopus TV supported ?
        jz          @F                          ; No, go on

        out         dx, al
        inc         dx
        in          al, dx                          ; get the current value of the register
        dec         dx
        and         al, TVF_INACTIVE    ; mask out the bit we won't touch..
        mov         ah, al                          ; move value to high byte
                                                    ;get CRTC owner's value for this reg
        or          ah,[ecx].PerVMData.EXT_CanopusTVReg
        mov         al, bCanopusTVReg   ;set to canopus Tv register
        out         dx,ax                           ;
@@:
        
;
        mov     al,2Ah                  ;set to CRTC index 2Ah
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_OverscanHigh
        out     dx,ax                   ;
;
        mov     al,2Dh                  ;set to CRTC index 2Dh
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_HorizontalExtra
        out     dx,ax                   ;
;
; JJV - Don't bother restoring the HW cursor address.
;;;;;        mov     al,30h                  ;set to CRTC index 30h
;;;;;                                        ;get CRTC owner's value for this reg
;;;;;        mov     ah,[ecx].PerVMData.EXT_HWCursorAddress0
;;;;;        out     dx,ax                   ;
;;;;;;
;;;;;        mov     al,31h                  ;set to CRTC index 31h
;;;;;                                        ;get CRTC owner's value for this reg
;;;;;        mov     ah,[ecx].PerVMData.EXT_HWCursorAddress1
;;;;;        out     dx,ax                   ;
        mov     al,32h                  ;set to CRTC index 32h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_VideoWindow0
        out     dx,ax

; read current CRTC to get device bits
        mov     al,33h                  ;set to CRTC index 33h
        out     dx,al                   ;get current value for this reg
        inc     dx
        in      al,dx
        and     al,11h                  ;get slave bit
        dec     dx
        mov     ah,[ecx].PerVMData.EXT_VideoWindow1 ;get CRTC owner's value for this reg
        and     ah,0eeh                 ;mask slave bit and FP data bit
        or      ah,al                   ;add slave bit
        mov     al,33h
        out     dx,ax                   ;
;
        mov     al,39h                  ;set to CRTC index 39h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_Interlace
        out     dx,ax                   ;
;
        ; Restore DAC clock
        push    eax
        push    esi
        push    edx
        ;
        mov     eax,[ecx].PerVMData.EXT_NV_VPLL_COEFF
        REG_WR32(NV_PRAMDAC_VPLL_COEFF)

;
        ; Restore VCLK/2
        mov     eax,[ecx].PerVMData.EXT_NV_PRAMDAC
        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT)

; Restore DAC General Control
        mov     eax,[ecx].PerVMData.EXT_NV_PDAC_GEN_CTRL
;comment
        REG_WR32(NV_PRAMDAC_GENERAL_CONTROL)
        ;
        ; restore real mode window state
        mov     al,[ecx].PerVMData.EXT_RealModeAccess
        mov     esi,[ecx].PerVMData.EXT_RealModeAddress
        mov     dx,[ecx].PerVMData.EXT_RealModeData32
        call    RestoreNVAccessState

;ifdef DISPLAY_SWITCH
; If we allow the display device to change while a DOS session is active, we also need to
; restore the standard CRTC regs, since the main VDD may have saved timings for the previous
; device. We save std crtc's in postHiResToVga in this case.
                cmp             RestoreStdCrtc,0
                jz              noStdRestore

                mov             RestoreStdCrtc,0
                push    ebx
                mov             dx,3d4h
                xor             ebx,ebx

                mov             al,21h          ;unshadow
                out             dx,al
                inc             dx
                in              al,dx
                dec             dx
                shl             eax,16          ;save shadow bits in eax upper word
                mov             ax,0ff21h       ;enable all
                out             dx,ax
                
                mov             al,11h          ;write enable 0-7
                out             dx,al
                inc             dx
                in              al,dx
                and             al,07fh
                out             dx,al
                dec             dx                              
stdlp:
                mov             al,bl
                mov             ah,[ecx+ebx].PerVMData.StdCRTC
                out             dx,ax           
                inc             bx
                cmp             bx,0eh          ;skip e and f
                jnz             @f
                add             bx,2
@@:             cmp             bx,19h
                jne             stdlp           
                
                pop             ebx
                shr             eax,8           ;restore shadow bits
                mov             al,21h
                out             dx,ax           

                mov             al,11h          ;restore 0-7 write protect
                out             dx,al
                inc             dx
                in              al,dx
                or              al,80h
                out             dx,al

;;;             mov             ah,[ecx].PerVMData.SR1  ; restore SR1
;;;             mov             dx,3c4h
;;;             mov             al,1
;;;             out             dx,ax
noStdRestore:
;endif ; DISPLAY_SWITCH

        ;
        pop     edx
        pop     esi
        pop     eax

                call    restore_lock
                
        rol     eax,8   ;restore eax to determine if CR44 needs resetting
        
        ; Restore Head owner if needed
        .if (al & 80h)            ;if saved_mode needs to be restored
                and     al,7fh    ;remove flag
                call    WriteCr44 ;Write it back
        .endif

;
;Restore the CRTC index register saved in the high byte of EAX:
;
        rol     eax,8                   ;
        out     dx,al                   ;
;
MRRSExit:
        pop     esi
        pop     edx
        pop     ecx                     ;
        pop     ebx
        ret                             ;
EndProc MiniVDD_RestoreRegisters
;
;
subttl          Save and Restore Latches
page +
public  MiniVDD_SaveLatches
BeginProc MiniVDD_SaveLatches, DOSVM
;
;When virtualizing the VGA 4 plane mode, we have to save and restore the
;latches occasionally.  This routine is called for saving
;the latches by simply using the standard VGA CRTC
;register 22H which all super-VGA's possess (we hope).
;
;Entry:
;       EBX contains a Windows VM handle (which must be preserved).
;       EBP --> VM's Client Registers.
;Exit:
;       Save anything that you use.
;
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SaveLatches", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX\n\r", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax
        push    ebx
        push    ecx
        push    edx
        add     ebx,OurCBDataPointer    ;EBX --> VM's CB data area


        mov     edx,GDC_INDEX           ;EDX --> GC index register
        in      al,dx
        ror     eax,8                   ;save index

        mov     al,004h
        out     dx,al
        inc     edx                     ;EDX --> GC data register
        in      al,dx
        mov     cl,al                   ;save original
        ror     ecx,8                   ;save it in high word

        mov     al,0                    ;set plane 0
        out     dx,al                   ;

        mov     cx,dx                   ;save GC address

        call    GetCRTCPort             ;EDX --> CRTC index register

        in      al,dx
        ror     eax,8                   ;save index

        ; MSK - NOTE: Cirrus docs say that a read from 022h will force read mode 0
        mov     al,022h
        out     dx,al
        inc     edx                     ;EDX --> CRTC data register

        in      al,dx                   ;get latch 0
        mov     [ebx].Latch0,al         ;save in CB structure

        xchg    dx,cx                   ;EDX --> GC data register

        mov     al,1                    ;set plane 1
        out     dx,al

        xchg    dx,cx                   ;EDX --> CRTC data register
        in      al,dx                   ;get latch 1
        mov     [ebx].Latch1,al         ;save in CB structure

        xchg    dx,cx                   ;EDX --> GC data register

        mov     al,2                    ;set plane 2
        out     dx,al

        xchg    dx,cx                   ;EDX --> CRTC data register
        in      al,dx                   ;get latch 2
        mov     [ebx].Latch2,al         ;save in CB structure

        xchg    dx,cx                   ;EDX --> GC data register

        mov     al,3                    ;set plane 3
        out     dx,al

        xchg    dx,cx                   ;EDX --> CRTC data register
        in      al,dx                   ;get latch 3
        mov     [ebx].Latch3,al         ;save in CB structure

        dec     edx                     ;EDX --> CRTC index register
        rol     eax,8                   ; 
        out     dx,al                   ;restore index

        xchg    dx,cx                   ;EDX --> GC data register

        rol     ecx,8                   ;get saved GC[4] value
        mov     al,cl
        out     dx,al                   ;restore GR[4]

        dec     edx                     ;EDX --> GC index register
        rol     eax,8                   ; 
        out     dx,al                   ;restore index

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_SaveLatches
;
;
public  MiniVDD_RestoreLatches
BeginProc MiniVDD_RestoreLatches, DOSVM
;
;This routine reverses the latch save that we did prior to restoring the
;latches.  Just restore the states that you saved.
;
;Entry:
;       EBX contains a Windows VM handle (which must be preserved).
;       EBP --> VM's Client Registers.
;Exit:
;       Save anything that you use.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_RestoreLatches", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax
        push    ebx
        push    ecx
        push    edx
        add     ebx,OurCBDataPointer    ;EBX --> VM's CB data area

        call    MiniVDD_SetLatchBank

        mov     edx,GDC_INDEX           ;EDX --> GC index register
        in      al,dx
        ror     eax,8                   ;save index

        mov     al,004h
        out     dx,al
        inc     edx                     ;EDX --> GC data register
        in      al,dx
        ror     eax,8                   ;save it in high word

        mov     ecx,Vid_PhysA0000

        mov     al,0                    ;set plane 0
    