ong?  (If the caller specified GUID_NULL,
    // then any guidVersion is OK.)

    if( VT_VERSIONED_STREAM != propvar.vt
        ||
        GUID_NULL != guidPropertyType
        &&
        guidPropertyType != propvar.pVersionedStream->guidVersion )
    {
        if( OPENPROPERTY_OVERWRITE & dwFlags )
        {
            // Delete the existing property
            hr = DeleteMultiple( 1, &pwszPropName, 0 );
            if( FAILED(hr) ) goto Exit;

            // Recursive call
            // PERF: Optimize this so that we don't have to re-do the parameter checking.
            hr = Open( pUnkOuter, pwszPropName, guidPropertyType, dwFlags & ~OPENPROPERTY_OVERWRITE, riid, ppUnk );
        
        }   // if( OPENPROPERTY_OVERWRITE & dwFlags )
        else
        {
            propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x)::Open couldn't overwrite existing property - %ws, %d\n",
                                 this, pwszPropName, propvar.vt ));
            hr = STG_E_FILEALREADYEXISTS;
        }   // if( OPENPROPERTY_OVERWRITE & dwFlags ) ... else

        // Unconditional goto Exit; we either just called Open recursively to do the work,
        // or set an error.
        goto Exit;
    }

    // We have a good property, QI for the riid and we're done

    DfpAssert( IID_IStream == riid );

    hr = propvar.pVersionedStream->pStream->QueryInterface( IID_IUnknown, reinterpret_cast<void**>(&pUnk) );
    if( FAILED(hr) )
    {
        pUnk = NULL;
        goto Exit;
    }

    //  ----
    //  Exit
    //  ----

    *ppUnk = pUnk;
    pUnk = NULL;
    hr = S_OK;


Exit:

    if( NULL != pUnk )
        pUnk->Release();

    PropVariantClear( &propvar );

    _pBlockingLock->Unlock();
    return( hr );
}


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::Enum (IPropertyBagEx)
//
//  This method returns an enumerator of properties in a bag.  If
//  ENUMPROPERTY_MASK is set in dwFlags, poszPropNameMask is treated as a 
//  prefix, and the enumerator returns all those properties which match
//  that prefix.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::Enum( 
        /* [in] */ LPCOLESTR poszPropNameMask,
        /* [in] */ DWORD dwFlags,
        /* [out] */ IEnumSTATPROPBAG __RPC_FAR *__RPC_FAR *ppenum)
{
    HRESULT hr = S_OK;
    CEnumSTATPROPBAG *penum = NULL;

    propXTrace( "CPropertyBagEx::Enum" );

    _pBlockingLock->Lock( INFINITE );

    // Validate inputs

    if (NULL != poszPropNameMask && S_OK != (hr = ValidateInRGLPOLESTR( 1, &poszPropNameMask )))
        goto Exit;
    GEN_VDATEPTROUT_LABEL( ppenum, IEnumSTATPROPBAG*, E_INVALIDARG, Exit, hr );

    if( 0 != dwFlags )
    {
        propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x)::Enum - invalid dwFlags (%08x)\n", this, dwFlags ));
        hr = E_INVALIDARG;
        goto Exit;
    }

    propTraceParameters(( "%ws, 0x%08x, 0x%x", poszPropNameMask, dwFlags, ppenum ));

    // Initialize output

    *ppenum = NULL;

    // Open the property storage, if it exists

    hr = OpenPropStg( FILE_OPEN_IF );
    if( STG_E_FILENOTFOUND == hr )
        hr = S_OK;
    else if( FAILED(hr) )
        goto Exit;

    // Create an enumerator

    penum = new CEnumSTATPROPBAG( _pBlockingLock );
    if( NULL == penum )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // And initialize it

    hr = penum->Init( _ppropstg, poszPropNameMask, dwFlags );    // _ppropstg could be NULL
    if( FAILED(hr) ) goto Exit;

    //  ----
    //  Exit
    //  ----

    hr = S_OK;
    *ppenum = static_cast<IEnumSTATPROPBAG*>( penum );
    penum = NULL;

Exit:

    if( NULL != penum )
        penum->Release();

    _pBlockingLock->Unlock();

    return( hr );

}   // CPropertyBagEx::Enum


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::Commit
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::Commit( DWORD grfCommitFlags )
{
    HRESULT hr = S_OK;

    propITrace( "CPropertyBagEx::Commit" );
    propTraceParameters(( "%08x", grfCommitFlags ));

    // As an optimization, we only take the lock if we're really going to
    // do the commit.

    if( NULL != _ppropstg )
    {
        _pBlockingLock->Lock( INFINITE );

        if( NULL != _ppropstg && IsWriteable() )
        {
            hr = _ppropstg->Commit( grfCommitFlags );
        }

        _pBlockingLock->Unlock();
    }

    return( hr );

}   // CPropertyBagEx::Commit


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::ShutDown
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::ShutDown()
{
    HRESULT hr = S_OK;
    propITrace( "CPropertyBagEx::ShutDown" );

    if( NULL != _pBlockingLock )
        _pBlockingLock->Lock( INFINITE );

    // Release the property storage that holds the bag.  It is because
    // of this call that we need this separate ShutDown method; we can't
    // release this interface in the destructor, since it may be reverted
    // by that point.

    DfpVerify( 0 == RELEASE_INTERFACE(_ppropstg) );

    // We didn't AddRef these, so we don't need to release them.

    if( NULL != _ppropsetstgContainer )
        _ppropsetstgContainer = NULL;

    if( NULL != _pBlockingLock )
    {
        _pBlockingLock->Unlock();
        _pBlockingLock = NULL;
    }

    return( hr );

}   // CPropertyBagEx::ShutDown



//+----------------------------------------------------------------------------
//
//  Method: CSTATPROPBAGArray::Init
//
//+----------------------------------------------------------------------------

HRESULT
CSTATPROPBAGArray::Init( IPropertyStorage *ppropstg, const OLECHAR *poszPrefix, DWORD dwFlags )
{
    HRESULT hr = S_OK;

    propITrace( "CSTATPROPBAGArray::Init" );
    propTraceParameters(( "0x%x, %ws", ppropstg, poszPrefix ));

    _pBlockingLock->Lock( INFINITE );

    // Keep the IPropertyBagEx::Enum flags
    _dwFlags = dwFlags;

    // Copy the prefix string
    if( NULL == poszPrefix )
        _poszPrefix = NULL;
    else
    {
        _poszPrefix = reinterpret_cast<OLECHAR*>
                      ( CoTaskMemAlloc( ( (ocslen(poszPrefix)+1) * sizeof(OLECHAR) )));
        if( NULL == _poszPrefix )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        ocscpy( _poszPrefix, poszPrefix );
    }

    // If we were given an IPropertyStorage, enum it.  Otherwise, we'll leave
    // _penum NULL and always return 0 for *pcFetched.

    if( NULL != ppropstg )
    {
        hr = ppropstg->Enum( &_penum );
        if( FAILED(hr) ) goto Exit;
    }

    hr = S_OK;

Exit:

    _pBlockingLock->Unlock();
    return( hr );

}   // CSTATPROPBAGArray::Init



//+----------------------------------------------------------------------------
//
//  Method: CSTATPROPBAGArray::AddRef/Release
//
//+----------------------------------------------------------------------------

ULONG
CSTATPROPBAGArray::AddRef()
{
    return( InterlockedIncrement( &_cReferences ));
}

ULONG
CSTATPROPBAGArray::Release()
{
    LONG lRet = InterlockedDecrement( &_cReferences );

    if( 0 == lRet )
        delete this;

    return( 0 > lRet ? 0 : lRet );
}



//+----------------------------------------------------------------------------
//
//  Method: CSTATPROPBAGArray::NextAt
//
//  This method gets the *pcFetched STATPROPBAG structures in the
//  enumeration starting from index iNext.  This is implemented using
//  the IEnumSTATPROPSTG enumerator in _penum.
//
//+----------------------------------------------------------------------------  


HRESULT
CSTATPROPBAGArray::NextAt( ULONG iNext, STATPROPBAG *prgstatpropbag, ULONG *pcFetched )
{
    HRESULT hr = S_OK;
    STATPROPSTG statpropstg = { NULL };
    ULONG iMatch = 0;
    ULONG iFetched = 0;

    propITrace( "CSTATPROPBAGArray::NextAt" );
    propTraceParameters(( "%d, 0x%x, 0x%x", iNext, prgstatpropbag, pcFetched ));

    _pBlockingLock->Lock( INFINITE );

    // If there's nothing to enumerate, then we're done

    if( NULL == _penum )
    {
        hr = S_FALSE;
        *pcFetched = 0;
        goto Exit;
    }

    // Reset the IEnumSTATPROPBAGTG index (doesn't reload, just resets the index).
    hr = _penum->Reset();
    if( FAILED(hr) ) goto Exit;

    // Walk the IEnumSTATPROPBAGTG enumerator, looking for matches.

    hr = _penum->Next( 1, &statpropstg, NULL );
    while( S_OK == hr && iFetched < *pcFetched )
    {
        // Does this property have a name (all properties in a bag must have
        // a name)?

        if( NULL != statpropstg.lpwstrName )
        {
            // Yes, we have a name.  Are we enumerating all properties (in which case
            // _poszPrefix is NULL), or does this property name match the prefix?

            if( NULL == _poszPrefix
                ||
                statpropstg.lpwstrName == ocsstr( statpropstg.lpwstrName, _poszPrefix )
                ||
                !ocscmp( statpropstg.lpwstrName, _poszPrefix ) )
            {
                // Yes, this property matches the prefix and is therefore part
                // of this enumeration.  But is this the index into the enumeration
                // that we're looking for?

                if( iNext == iMatch )
                {
                    // Yes, everything matches, and we have a property that should
                    // be returned.

                    prgstatpropbag[ iFetched ].lpwstrName = statpropstg.lpwstrName;
                    statpropstg.lpwstrName = NULL;

                    prgstatpropbag[ iFetched ].vt = statpropstg.vt;

                    // GUID is not current supported by the enumeration
                    prgstatpropbag[ iFetched ].guidPropertyType = GUID_NULL;

                    // Show that we're now looking for the i+1 index
                    iNext++;

                    iFetched++;
                }

                // Increment the number of property matches we've had.
                // (iMatch will increment until it equals iNext, after
                // which the two will always both increment and remain equal).

                iMatch++;

            }   // if( NULL == _poszPrefix ...
        }   // if( NULL != statpropstg.lpwstrName )

        CoTaskMemFree( statpropstg.lpwstrName );
        statpropstg.lpwstrName = NULL;
        hr = _penum->Next( 1, &statpropstg, NULL );

    }   // while( S_OK == hr && iFetched < *pcFetched )

    // Did we get an error on a _penum->Next call?
    if( FAILED(hr) ) goto Exit;


    // If we reached this point, there was no error.  Determine if
    // OK or FALSE should be returned.

    if( iFetched == *pcFetched )
        hr = S_OK;
    else
        hr = S_FALSE;

    *pcFetched = iFetched;

    //  ----
    //  Exit
    //  ----

Exit:

    CoTaskMemFree( statpropstg.lpwstrName );

    _pBlockingLock->Unlock();
    return( hr );

}   // CSTATPROPBAGArray::NextAt




//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::CEnumSTATPROPBAG (copy constructor)
//
//+----------------------------------------------------------------------------

CEnumSTATPROPBAG::CEnumSTATPROPBAG( const CEnumSTATPROPBAG &Other )
{
    propDbg(( DEB_ITRACE, "CEnumSTATPROPBAG::CEnumSTATPROPBAG (copy constructor)" ));

    Other._pBlockingLock->Lock( INFINITE );

    new(this) CEnumSTATPROPBAG( Other._pBlockingLock );

    _iarray = Other._iarray;

    Other._parray->AddRef();
    _parray = Other._parray;

    Other._pBlockingLock->Unlock();
}

//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::~CEnumSTATPROPBAG
//
//+----------------------------------------------------------------------------

CEnumSTATPROPBAG::~CEnumSTATPROPBAG()
{
    propDbg(( DEB_ITRACE, "CEnumSTATPROPBAG::~CEnumSTATPROPBAG\n" ));

    _pBlockingLock->Release();
    if( NULL != _parray )
        _parray->Release();
}

//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Init
//
//+----------------------------------------------------------------------------

HRESULT
CEnumSTATPROPBAG::Init( IPropertyStorage *ppropstg, LPCOLESTR poszPrefix, DWORD dwFlags )
{
    HRESULT hr = S_OK;

    propITrace( "CEnumSTATPROPBAG::Init" );
    propTraceParameters(( "0x%x, %ws", ppropstg, poszPrefix ));

    // Create a STATPROPBAG Array
    _parray = new CSTATPROPBAGArray( _pBlockingLock );
    if( NULL == _parray )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Load the array from the IPropertyStorage
    hr = _parray->Init( ppropstg, poszPrefix, dwFlags );
    if( FAILED(hr) ) goto Exit;

    hr = S_OK;

Exit:

    return( hr );
}	// CEnumSTATPROPBAG::Init


//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::QueryInterface/AddRef/Release
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::QueryInterface( REFIID riid, void **ppvObject )
{
    HRESULT hr = S_OK;

    // Validate the inputs
    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    *ppvObject = NULL;

    if( IID_IEnumSTATPROPBAG == riid || IID_IUnknown == riid )
    {
        *ppvObject = static_cast<IEnumSTATPROPBAG*>(this);
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    return(hr);

}   // CEnumSTATPROPBAG::QueryInterface

ULONG STDMETHODCALLTYPE
CEnumSTATPROPBAG::AddRef()
{
    return( InterlockedIncrement( &_cRefs ));
}

ULONG STDMETHODCALLTYPE
CEnumSTATPROPBAG::Release()
{
    LONG lRet = InterlockedDecrement( &_cRefs );
    
    if( 0 == lRet )
        delete this;

    return( 0 > lRet ? 0 : lRet );
}


//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Next
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::Next( ULONG celt, STATPROPBAG *rgelt, ULONG *pceltFetched )
{
    HRESULT hr = S_OK;
    ULONG celtFetched = celt;

    propXTrace( "CEnumSTATPROPBAG::Next" );

    _pBlockingLock->Lock( INFINITE );

    // Validate the inputs

    if (NULL == pceltFetched)
    {
        if (celt != 1)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }
    propTraceParameters(( "%d, 0x%x, 0x%x", celt, rgelt, pceltFetched ));

    // Get the next set of stat structures
    hr = _parray->NextAt( _iarray, rgelt, &celtFetched );
    if( FAILED(hr) ) goto Exit;

    // Advance the index
    _iarray += celtFetched;
    
    // Return the count to the caller
    if( NULL != pceltFetched )
        *pceltFetched = celtFetched;

    hr = celtFetched == celt ? S_OK : S_FALSE;

Exit:

    _pBlockingLock->Unlock();
    return( hr );

}   // CEnumSTATPROPBAG::Next


//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Reset
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::Reset( )
{
    HRESULT hr = S_OK;
    propXTrace( "CEnumSTATPROPBAG::Reset" );

    _pBlockingLock->Lock( INFINITE );
    _iarray = 0;
    _pBlockingLock->Unlock();

    return( hr );

}   // CEnumSTATPROPBAG::Reset



//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Skip
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::Skip( ULONG celt )
{
    HRESULT hr = S_OK;
    STATPROPBAG statpropbag = { NULL };

    propXTrace( "CEnumSTATPROPBAG::Skip" );
    propTraceParameters( ("%d", celt ));

    _pBlockingLock->Lock( INFINITE );

    while( celt )
    {
        ULONG cFetched = 1;

        hr = _parray->NextAt( _iarray, &statpropbag, &cFetched );
        CoTaskMemFree( statpropbag.lpwstrName );
        statpropbag.lpwstrName = NULL;

        if( FAILED(hr) )
            goto Exit;
        else if( S_FALSE == hr )
            break;
        else
        {
            _iarray++;
            hr = S_OK;
            --celt;
        }
    }


Exit:

    CoTaskMemFree( statpropbag.lpwstrName );

    _pBlockingLock->Unlock();
    return( hr );

}   // CEnumSTATPROPBAG::Skip



//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Clone
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::Clone( IEnumSTATPROPBAG **ppenum )
{
    HRESULT hr = S_OK;
    CEnumSTATPROPBAG *penum = NULL;

    propXTrace( "CEnumSTATPROPBAG::Clone" );

    // Validate the input

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );
    *ppenum = NULL;
    propTraceParameters(( "0x%x", ppenum ));

    penum = new CEnumSTATPROPBAG( *this );
    if( NULL == penum )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *ppenum = static_cast<IEnumSTATPROPBAG*>(penum);
    penum = NULL;

Exit:

    if( NULL != penum )
        delete penum ;

    return( hr );

}   // CEnumSTATPROPBAG::Clone


//
// Add this functionality to chgtype.cxx when chgtype.cxx is finalized.
//
    //
    //  These are the Property Variant types that need to be
    //  dumbed down to the VARIANT types.
    //
struct {
    VARTYPE vtSrc, vtDest;
} const ImplicitCoercionLookup[] = {
    // Src             Dest  
    {VT_I8,              VT_I4},
    {VT_UI8,             VT_UI4},
    {VT_LPSTR,           VT_BSTR},
    {VT_LPWSTR,          VT_BSTR},
    {VT_FILETIME,        VT_DATE},
    {VT_BLOB,            VT_ARRAY|VT_UI1},
    {VT_STREAM,          VT_UNKNOWN},
    {VT_STREAMED_OBJECT, VT_UNKNOWN},
    {VT_STORAGE,         VT_UNKNOWN},
    {VT_STORED_OBJECT,   VT_UNKNOWN},
    {VT_BLOB_OBJECT,     VT_ARRAY|VT_UI1},
    {VT_CF,              VT_ARRAY|VT_UI1},
    {VT_CLSID,           VT_BSTR},
};

HRESULT
ImplicitPropVariantToVariantChangeType(
        PROPVARIANT *pDest,     // Omit the hungarian to make
        const PROPVARIANT *pSrc,      // the code look cleaner.
        LCID lcid )
{
    HRESULT hr=S_OK;
    VARTYPE vtCoerce;
    VARTYPE vtType;
    int i;

    //
    // Safe arrays are only built from old VARIANT types.
    // They are easy so get them out of the way.
    //
    if( VT_ARRAY & pSrc->vt )
    {
        return PropVariantCopy( pDest, pSrc );
    }

    vtType = pSrc->vt & VT_TYPEMASK;
    vtCoerce = VT_EMPTY;
    for(i=0; i<ELEMENTS(ImplicitCoercionLookup); i++)
    {
        if( ImplicitCoercionLookup[i].vtSrc == vtType )
        {
            vtCoerce = ImplicitCoercionLookup[i].vtDest;
            break;
        }
    }

    if(VT_VECTOR & pSrc->vt)
    {
        if( VT_EMPTY == vtCoerce )
            vtCoerce = pSrc->vt & VT_TYPEMASK;

        return HrPropVarVECTORToSAFEARRAY( pDest, pSrc, lcid, vtCoerce);
    }
    
    if( VT_EMPTY == vtCoerce )
        hr = PropVariantCopy( pDest, pSrc );    // Optimization.
    else
        hr = PropVariantChangeType( pDest, pSrc, lcid, 0, vtCoerce );
    return hr;
}


HRESULT
HrPropVarVECTORToSAFEARRAY(
        PROPVARIANT *pDest,
        const PROPVARIANT *pSrc,
        LCID lcid,
        VARTYPE vtCoerce )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAY	*psaT=NULL;
    SAFEARRAYBOUND sabound;
    PROPVARIANT propvarT1, propvarT2;

    PropVariantInit( &propvarT1 );
    PropVariantInit( &propvarT2 );
    
    PROPASSERT (VT_VECTOR & pSrc->vt);
	
    VARTYPE vt;

    vt = pSrc->vt & VT_TYPEMASK;

    // Create the SafeArray
    sabound.lLbound = 0;
    sabound.cElements = pSrc->cac.cElems;
    psaT = PrivSafeArrayCreate(vtCoerce, 1, &sabound );
    if(psaT == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // Convert single typed Vectors
    //  Pull each element from the Vector,
    //  Change it's type, per requested.
    //  Put it into the Array.
    if(VT_VARIANT != vt)
    {
        for(i=0; i<pSrc->cac.cElems; i++)
        {
            hr = LoadPropVariantFromVectorElem( &propvarT1, pSrc, i );
            if( FAILED(hr) )
                goto Error;

            //
            // PERF: Performance
            //  If the pSrc->vt == vtCoerce, then we can skip the ChangeType
            //  and the following clean.  And go directly to "Put" of T1.
            //
            hr = PropVariantChangeType( &propvarT2, &propvarT1, lcid, 0, vtCoerce );
            PropVariantClear( &propvarT1 );

            if( FAILED(hr) )
                goto Error;

            hr = PutPropVariantDataIntoSafeArray( psaT, &propvarT2, i);
            PropVariantClear( &propvarT2 );
            if( FAILED(hr) )
                goto Error;
        }
    }
    // Convert Vectors of Variants
    //  Do Implisit Coercion of each Variant into an new Variant
    //  Put the new Variant into the Array.
    else        
    {
        for(i=0; i<pSrc->cac.cElems; i++)
        {
            hr = ImplicitPropVariantToVariantChangeType(
                            &propvarT2, &pSrc->capropvar.pElems[i], lcid );
            if( FAILED(hr) )
                goto Error;

            hr = PrivSafeArrayPutElement( psaT, (long*)&i, (void*)&propvarT2 );
            PropVariantClear( &propvarT2 );
            if( FAILED(hr) )
                goto Error;
        }
    }

    pDest->vt = VT_ARRAY | vtCoerce;
    pDest->parray = psaT;
    psaT = NULL;

Error:
    if(NULL != psaT)
        PrivSafeArrayDestroy( psaT );

    return hr;
}

//-----------------------------------------------------------------
// Dup routines
//-----------------------------------------------------------------

LPSTR
PropDupStr( const LPSTR lpstr )
{
    int cch;

    if( NULL == lpstr )
        return NULL;
    else
    {
        cch = lstrlenA( lpstr ) + 1;
        return (LPSTR)AllocAndCopy( cch*sizeof(CHAR), lpstr );
    }
}
    
LPWSTR
PropDupWStr( const LPWSTR lpwstr )
{
    int cch;

    if( NULL == lpwstr )
        return NULL;
    else
    {
        cch = lstrlenW( lpwstr ) + 1;
        return (LPWSTR)AllocAndCopy( cch*sizeof(WCHAR), lpwstr );
    }
}

LPCLSID
PropDupCLSID( const LPCLSID pclsid )
{
    return (LPCLSID)AllocAndCopy( sizeof(CLSID), pclsid);
}

CLIPDATA*
PropDupClipData( const CLIPDATA* pclipdata )
{
    CLIPDATA* pcdNew=NULL;
    CLIPDATA* pclipdataNew=NULL;
    PVOID pvMem=NULL;

    pcdNew = new CLIPDATA;
    pvMem = AllocAndCopy( CBPCLIPDATA( *pclipdata ), pclipdata->pClipData);

    if( NULL == pvMem || NULL == pcdNew )
        goto Error;

    pcdNew->cbSize    = pclipdata->cbSize;
    pcdNew->ulClipFmt = pclipdata->ulClipFmt;
    pcdNew->pClipData = (BYTE*)pvMem;
    pclipdataNew = pcdNew;
    pcdNew = NULL;
    pvMem = NULL;

Error:
    if( NULL != pcdNew )
        delete pcdNew;
    if( NULL != pvMem )
        delete pvMem;

    return pclipdataNew;
}

//------------------------------------------------------------------------
//
//  LoadPropVariantFromVectorElem()
// This routine will load a provided PropVariant from an element of a
// provided SafeArray at the provided index.
// All the PropVariant Vector types are supported.
//  
//------------------------------------------------------------------------

HRESULT
LoadPropVariantFromVectorElem(
        PROPVARIANT *pDest,
        const PROPVARIANT *pSrc,
        int idx)
{
    VARTYPE vt;
    HRESULT hr=S_OK;

    vt = pSrc->vt & VT_TYPEMASK;

    switch( vt )
    {
    case VT_I1:
        pDest->cVal = pSrc->cac.pElems[idx];
        break;

    case VT_UI1:
        pDest->bVal = pSrc->caub.pElems[idx];
        break;

    case VT_I2:
        pDest->iVal = pSrc->cai.pElems[idx];
        break;

    case VT_UI2:
        pDest->uiVal = pSrc->caui.pElems[idx];
        break;

    case VT_I4:
        pDest->lVal = pSrc->cal.pElems[idx];
        break;

    case VT_UI4:
        pDest->ulVal = pSrc->caul.pElems[idx];
        break;

    case VT_R4:
        pDest->fltVal = pSrc->caflt.pElems[idx];
        break;

    case VT_R8:
        pDest->dblVal = pSrc->cadbl.pElems[idx];
        break;

    case VT_CY:
        pDest->cyVal = pSrc->cacy.pElems[idx];
        break;

    case VT_DATE:
        pDest->date = pSrc->cadate.pElems[idx];
        break;

    case VT_BSTR:
        if( NULL == pSrc->cabstr.pElems[idx] )
            pDest->bstrVal = NULL;
        else
        {
            pDest->bstrVal = PrivSysAllocString( pSrc->cabstr.pElems[idx] );
            if( NULL == pDest->bstrVal)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
        }
        break;

    case VT_BOOL:
        pDest->boolVal = pSrc->cabool.pElems[idx];
        break;

    case VT_ERROR:
        pDest->scode = pSrc->cascode.pElems[idx];
        break;

    case VT_I8:
        pDest->hVal = pSrc->cah.pElems[idx];
        break;

    case VT_UI8:
        pDest->uhVal = pSrc->cauh.pElems[idx];
        break;
    
        // String Copy
    case VT_LPSTR:
        if( NULL == pSrc->calpstr.pElems[idx] )
            pDest->pszVal = NULL;
        else
        {
            pDest->pszVal = PropDupStr( pSrc->calpstr.pElems[idx] );
            if( NULL == pDest->pszVal)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
        }
        break;

        // Wide String Copy
    case VT_LPWSTR:
        if( NULL == pSrc->calpwstr.pElems[idx] )
            pDest->pwszVal = NULL;
        else
        {
            pDest->pwszVal = PropDupWStr( pSrc->calpwstr.pElems[idx] );
            if( NULL == pDest->pwszVal)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
        }
        break;
    
    case VT_FILETIME:
        pDest->filetime = pSrc->cafiletime.pElems[idx];
        break;

        //
        // The Variant takes a pointer to a CLIPDATA but the
        // vector is an array of CLIPDATA structs.
        //
    case VT_CF:
        pDest->pclipdata = PropDupClipData(&pSrc->caclipdata.pElems[idx]);
        if( NULL == pDest->pclipdata)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        break;

        //
        // The Variant takes a pointer to a CLSID but the
        // vector is an array of CLSID structs.
        //
    case VT_CLSID:
        pDest->puuid = PropDupCLSID(&pSrc->cauuid.pElems[idx]);
        if( NULL == pDest->puuid)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        break;

    default:
        return DISP_E_TYPEMISMATCH;
    }
    pDest->vt = vt;

Error:
    return hr;
}       


//------------------------------------------------------------------------
//
//  PutPropVariantDataIntoSafeArray
// This will take the data part of a propvariant and "Put" it into the
// a SafeArray at the provided index.
// Only the insection of PROPVARIANT vector types with old VARIANT types
// are supported.
//
//------------------------------------------------------------------------

// PERF:  Reimplement this without using the PropVariantCopy

HRESULT
PutPropVariantDataIntoSafeArray(
        SAFEARRAY *psa,
        const PROPVARIANT *pSrc,
        int idx)
{
    VARTYPE vt;
    HRESULT hr=S_OK;
    PROPVARIANT propvarT;
    const void *pv=NULL;

    vt = pSrc->vt & VT_TYPEMASK;

    PROPASSERT(vt == pSrc->vt);

    PropVariantInit( &propvarT );
    hr = PropVariantCopy( &propvarT, pSrc );
    if( FAILED( hr ) ) goto Exit;

    switch( vt )
    {
    case VT_I1:
        pv = &propvarT.cVal;
        break;

    case VT_UI1:
        pv = &propvarT.bVal;
        break;

    case VT_I2:
        pv = &propvarT.iVal;
        break;

    case VT_UI2:
        pv = &propvarT.uiVal;
        break;

    case VT_I4:
        pv = &propvarT.lVal;
        break;

    case VT_UI4:
        pv = &propvarT.ulVal;
        break;

    case VT_R4:
        pv = &propvarT.fltVal;
        break;

    case VT_R8:
        pv = &propvarT.dblVal;
        break;

    case VT_CY:
        pv = &propvarT.cyVal;
        break;

    case VT_DATE:
        pv = &propvarT.date;
        break;

    case VT_BSTR:
        pv = propvarT.bstrVal;  // Pointer Copy
        break;

    case VT_BOOL:
        pv = &propvarT.boolVal;
        break;

    case VT_ERROR:
        pv = &propvarT.scode;
        break;

    case VT_I8:
        pv = &propvarT.hVal;
        break;

    case VT_UI8:
        pv = &propvarT.uhVal;
        break;
    
    case VT_CF:
        pv = &propvarT.pclipdata;
        break;

    default:
        hr = DISP_E_TYPEMISMATCH;
        goto Exit;
    }

    // *Copy* the data into the SafeArray
    hr = PrivSafeArrayPutElement( psa, (long*)&idx, const_cast<void*>(pv) );
    if( FAILED(hr) ) goto Exit;

Exit:

    PropVariantClear( &propvarT );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2h\scode.h ===
//+---------------------------------------------------------------------------
//
// File:        SCode.h
//
// Contents:    Defines standard status code services.
//
//
//----------------------------------------------------------------------------

#ifndef __SCODE_H__
#define __SCODE_H__

//
// SCODE
//

typedef long SCODE;
typedef SCODE *PSCODE;
typedef void FAR * HRESULT;
#define NOERROR 0

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+---------------------+-------+-------------------------------+
//  |S|       Context       | Facil |               Code            |
//  +-+---------------------+-------+-------------------------------+
//
//  where
//
//      S - is the severity code
//
//          0 - Success
//          1 - Error
//
//      Context - context info
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1



#define SUCCEEDED(Status) ((SCODE)(Status) >= 0)

#define FAILED(Status) ((SCODE)(Status)<0)


//
// Return the code
//

#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define SCODE_FACILITY(sc)  (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define SCODE_SEVERITY(sc)  (((sc) >> 31) & 0x1)

//
// Create an SCODE value from component pieces
//

#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )



// --------------------- Functions ---------------------------------------

#define GetScode(hr) 		((SCODE)(hr) & 0x800FFFFF)
#define ResultFromScode(sc) ((HRESULT)((SCODE)(sc) & 0x800FFFFF))

STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew);


// -------------------------- Facility definitions -------------------------

#define FACILITY_NULL       0x0000 // generally useful errors ([SE]_*)
#define FACILITY_RPC            0x0001 // remote procedure call errors (RPC_E_*)
#define FACILITY_DISPATCH   0x0002 // late binding dispatch errors
#define FACILITY_STORAGE   0x0003 // storage errors (STG_E_*)
#define FACILITY_ITF            0x0004 // interface-specific errors



#define S_OK                0L
#define S_FALSE             MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)



// --------------------- FACILITY_NULL errors ------------------------------

#define E_UNEXPECTED        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 0xffff)
                            // relatively catastrophic failure

#define E_NOTIMPL           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 1)
                            // not implemented

#define E_OUTOFMEMORY       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 2)
                            // ran out of memory

#define E_INVALIDARG        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 3)
                            // one or more arguments are invalid

#define E_NOINTERFACE       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 4)
                            // no such interface supported


#define E_POINTER           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 5)
                            // invalid pointer

#define E_HANDLE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 6)
                            // invalid handle

#define E_ABORT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 7)
                            // operation aborted

#define E_FAIL              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
                            // unspecified error


#define E_ACCESSDENIED		MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 9)
							// general access denied error


// ----------------- FACILITY_ITF errors used by OLE ---------------------
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an OLE interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//
// The ranges, their associated interfaces, and the header file that defines
// the actual scodes are given below.
// 

// Generic OLE errors that may be returned by many interfaces
#define OLE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0000)
#define OLE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x00FF)
#define OLE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0000)
#define OLE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x00FF)
// interfaces: all
// file: ole2.h


#define DRAGDROP_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0100)
#define DRAGDROP_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x010F)
#define DRAGDROP_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0100)
#define DRAGDROP_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x010F)
// interfaces: IDropSource, IDropTarget
// file: ole2.h

#define CLASSFACTORY_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0110)
#define CLASSFACTORY_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x011F)
#define CLASSFACTORY_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0110)
#define CLASSFACTORY_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x011F)
// interfaces: IClassFactory
// file:

#define MARSHAL_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0120)
#define MARSHAL_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x012F)
#define MARSHAL_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0120)
#define MARSHAL_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x012F)
// interfaces: IMarshal, IStdMarshalInfo, marshal APIs
// file:

#define DATA_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0130)
#define DATA_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x013F)
#define DATA_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0130)
#define DATA_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x013F)
// interfaces: IDataObject
// file: dvobj.h

#define VIEW_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0140)
#define VIEW_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x014F)
#define VIEW_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0140)
#define VIEW_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x014F)
// interfaces: IViewObject
// file: dvobj.h

#define REGDB_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0150)
#define REGDB_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x015F)
#define REGDB_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0150)
#define REGDB_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x015F)
// API: reg.dat manipulation
// file: 


// range 160 - 16F reserved

#define CACHE_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0170) 
#define CACHE_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x017F)
#define CACHE_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0170)
#define CACHE_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x017F)
// interfaces: IOleCache
// file:

#define OLEOBJ_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0180)
#define OLEOBJ_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x018F)
#define OLEOBJ_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0180)
#define OLEOBJ_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x018F)
// interfaces: IOleObject
// file:

#define CLIENTSITE_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0190) 
#define CLIENTSITE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x019F)
#define CLIENTSITE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0190)
#define CLIENTSITE_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x019F)
// interfaces: IOleClientSite
// file:

#define INPLACE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01A0)
#define INPLACE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01AF)
#define INPLACE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01A0)
#define INPLACE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01AF)
// interfaces: IOleWindow, IOleInPlaceObject, IOleInPlaceActiveObject,
//                 IOleInPlaceUIWindow, IOleInPlaceFrame, IOleInPlaceSite
// file:

#define ENUM_E_FIRST        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01B0)
#define ENUM_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01BF)
#define ENUM_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01B0)
#define ENUM_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01BF)
// interfaces: IEnum*
// file:

#define CONVERT10_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01C0)
#define CONVERT10_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01CF)
#define CONVERT10_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01C0)
#define CONVERT10_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01CF)
// API: OleConvertOLESTREAMToIStorage, OleConvertIStorageToOLESTREAM
// file:


#define CLIPBRD_E_FIRST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01D0)
#define CLIPBRD_E_LAST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01DF)
#define CLIPBRD_S_FIRST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01D0)
#define CLIPBRD_S_LAST      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01DF)
// interfaces: OleSetClipboard, OleGetClipboard, OleFlushClipboard
// file: ole2.h

#define MK_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01E0)
#define MK_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01EF)
#define MK_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01E0)
#define MK_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01EF)
// interfaces: IMoniker, IBindCtx, IRunningObjectTable, IParseDisplayName,
//             IOleContainer, IOleItemContainer, IOleLink
// file: moniker.h


#define CO_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01F0)
#define CO_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01FF)
#define CO_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01F0)
#define CO_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01FF)
// all Co* API
// file: compobj.h


// range 200 - ffff for new error codes



#endif      // ifndef __SCODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2h\storage.h ===
/*****************************************************************************\
*                                                                             *
* storage.h -   Definitions for the strutured storage system
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _STORAGE_H_ )
#define _STORAGE_H_


#include <compobj.h>


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_SHAREVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x20)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
	
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

#define STG_E_NOTFILEBASEDSTORAGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x107)

#define STG_E_EXTANTMARSHALLINGS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x108)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

/****** Storage types *******************************************************/

#if defined(_M_I286)
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP _huge
#endif
#else
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP
#endif
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT		0x00000000L
#define STGM_TRANSACTED		0x00010000L

#define STGM_READ		0x00000000L
#define STGM_WRITE		0x00000001L
#define STGM_READWRITE		0x00000002L

#define STGM_SHARE_DENY_NONE	0x00000040L
#define STGM_SHARE_DENY_READ	0x00000030L
#define STGM_SHARE_DENY_WRITE	0x00000020L
#define STGM_SHARE_EXCLUSIVE	0x00000010L

#define STGM_PRIORITY		0x00040000L
#define STGM_DELETEONRELEASE	0x04000000L

#define STGM_CREATE		0x00001000L
#define STGM_CONVERT		0x00020000L
#define STGM_FAILIFTHERE	0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef char FAR * FAR *SNB;


#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif


/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    char FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;


/****** Storage Enumerators *************************************************/

#define LPENUMSTATSTG        IEnumSTATSTG FAR*

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IENUMSTATSTG methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};


/****** ILockBytes Interface ************************************************/

#define LPLOCKBYTES     ILockBytes FAR*

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ILockBytes methods ***
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};


/****** IStream Interface ***************************************************/


#define LPSTREAM        IStream FAR*

#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
		     ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};


/****** IStorage Interface **************************************************/

#define LPSTORAGE       IStorage FAR*

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStorage methods ***
    STDMETHOD(CreateStream) (THIS_ const char FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const char FAR* pwcsName,
		 void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const char FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const char FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
 		       IID const FAR *rgiidExclude,
 		       SNB snbExclude,
 		       IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ char const FAR* lpszName,
    			      IStorage FAR *pstgDest,
                              char const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const char FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const char FAR* pwcsOldName,
                const char FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const char FAR *lpszName,
    			        FILETIME const FAR *pctime,
                                FILETIME const FAR *patime,
                                FILETIME const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};


/****** IRootStorage Interface **********************************************/

#define LPROOTSTORAGE       IRootStorage FAR*

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRootStorage methods ***
    STDMETHOD(SwitchToFile) (THIS_ LPSTR lpstrFile) PURE;
};


/****** Storage API Prototypes ********************************************/

STDAPI StgCreateDocfile(const char FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const char FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const char FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

STDAPI StgSetTimes(char const FAR* lpszName,
		  FILETIME const FAR* pctime,
                  FILETIME const FAR* patime,
                  FILETIME const FAR* pmtime);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\hntfsstg.cxx ===
//+============================================================================
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:   hntfsstg.cxx
//
//  This file provides the NFF (NTFS Flat File) IStorage implementation.
//
//  History:
//      5/6/98  MikeHill
//              -   Use CoTaskMem rather than new/delete.
//              -   Split the Init method into two methods, one which is
//                  file name based and the other which is handle based.
//      5/18/98 MikeHill
//              -   Use the cleaned up CPropertySetStorage & CPropertyBagEx
//                  constructors.
//
//+============================================================================


#include <pch.cxx>
#include "expparam.hxx"


EXTERN_C const IID IID_IFlatStorage = { /* b29d6138-b92f-11d1-83ee-00c04fc2c6d4 */
    0xb29d6138,
    0xb92f,
    0x11d1,
    {0x83, 0xee, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0xd4}
  };

#define UNSUPPORTED_STGM_BITS  ( STGM_CONVERT    |      \
                                 STGM_TRANSACTED |      \
                                 STGM_PRIORITY   |      \
                                 STGM_SIMPLE     |      \
                                 STGM_DELETEONRELEASE )


WCHAR GetDriveLetter (WCHAR const *pwcsName);
BOOL IsDataStream( const PFILE_STREAM_INFORMATION pFileStreamInformation );


//-----------------------------------------------------------
//
// NFFOpen();
//
// Routine for the rest of Storage to use to open NFF files
// without knowing a lot of details.
//
//-----------------------------------------------------------

HRESULT
NFFOpen(const WCHAR *pwcsName,
        DWORD grfMode,
        DWORD dwFlags,
        BOOL fCreateAPI,
        REFIID riid,
        void **ppv)
{
    CNtfsStorage* pnffstg=NULL;
    IUnknown *punk=NULL;
    HRESULT sc=S_OK;

    nffDebug(( DEB_TRACE | DEB_INFO | DEB_OPENS,
               "NFFOpen(\"%ws\", %x, %x, &iid=%x, %x)\n",
              pwcsName, grfMode, fCreateAPI, &riid, ppv));

    if( 0 != ( grfMode & UNSUPPORTED_STGM_BITS ) )
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    //
    // We don't support Write only storage (yet)
    //
    if( STGM_WRITE == (grfMode & STGM_RDWR_MASK) )
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    nffMem( pnffstg = new CNtfsStorage( grfMode ));

    nffChk( pnffstg->InitFromName( pwcsName, fCreateAPI, dwFlags ) );

    nffChk( pnffstg->QueryInterface( riid, (void**)&punk ) );

    *ppv = punk;
    punk = NULL;

EH_Err:
    RELEASE_INTERFACE( pnffstg );
    RELEASE_INTERFACE( punk );

    // Compatibilty with Docfile:  Multiple opens with incompatible
    //  STGM_ modes returns LOCK vio not SHARE vio.   We use file SHARE'ing
    // Docfile used file LOCK'ing.
    //
    if(STG_E_SHAREVIOLATION == sc)
        sc = STG_E_LOCKVIOLATION;

    nffDebug(( DEB_TRACE, "NFFOpen() sc=%x\n", sc ));
    return(sc);
}

//+----------------------------------------------------------------------------
//
//  Function:   NFFOpenOnHandle
//
//  Create or open an NFF IStorage (or QI-able interface) on a given
//  handle.
//
//+----------------------------------------------------------------------------

HRESULT
NFFOpenOnHandle( BOOL fCreateAPI,
                 DWORD grfMode,
                 DWORD stgfmt,
                 HANDLE* phStream,
                 REFIID riid,
                 void ** ppv)
{
    HRESULT sc=S_OK;
    CNtfsStorage *pnffstg=NULL;
    IUnknown *punk=NULL;


    nffDebug(( DEB_TRACE | DEB_INFO | DEB_OPENS,
               "NFFOpenOnHandle(%x, %x, %x, %x, &iid=%x, %x)\n",
               fCreateAPI, grfMode, stgfmt, *phStream, &riid, ppv));

    if( 0 != ( grfMode & UNSUPPORTED_STGM_BITS ) )
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    if( fCreateAPI )
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    nffMem( pnffstg = new CNtfsStorage( grfMode ));

    nffChk( pnffstg->InitFromMainStreamHandle( phStream,
                                               NULL,
                                               fCreateAPI,
                                               NFFOPEN_NORMAL,
                                               stgfmt ) );

    nffAssert( INVALID_HANDLE_VALUE == *phStream );

    nffChk( pnffstg->QueryInterface( riid, (void**)&punk ) );

    *ppv = punk;
    punk = NULL;

EH_Err:
    RELEASE_INTERFACE(pnffstg);
    RELEASE_INTERFACE(punk);

    return( sc );

}   // OpenNFFOnHandle

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IUnknown::QueryInterface
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::QueryInterface(
    REFIID  riid,
    void ** ppvObject
    )
{
    nffXTrace( "CNtfsStorage::QueryInterface" );

    HRESULT sc = S_OK;

    NFF_VALIDATE( QueryInterface( riid, ppvObject ) );

    if( IID_IStorage == riid )
    {
        nffDebug(( DEB_ERROR, "STGFMT_FILE IID_IStorage is not supported\n" ));
        return E_NOINTERFACE;
        //*ppvObject = static_cast<IStorage*>(this);
        //AddRef();
    }
    else if(    IID_IUnknown == riid
        || IID_IFlatStorage == riid )
    {
        *ppvObject = static_cast<IStorage*>(this);
        AddRef();
    }
    else if( IID_IPropertySetStorage == riid )
    {
        *ppvObject = static_cast<IPropertySetStorage*>(this);
        AddRef();
    }
    else if( IID_IBlockingLock == riid )
    {
        *ppvObject = static_cast<IBlockingLock*>(this);
        AddRef();
    }
    else if( IID_ITimeAndNoticeControl == riid )
    {
        *ppvObject = static_cast<ITimeAndNoticeControl*>(this);
        AddRef();
    }
    else if( IID_IPropertyBagEx == riid )
    {
        *ppvObject = static_cast<IPropertyBagEx*>(&_PropertyBagEx);
        AddRef();
    }
    else if( IID_IPropertyBag == riid )
    {
        *ppvObject = static_cast<IPropertyBag*>(&_PropertyBagEx);
        AddRef();
    }
#if DBG
    else if( IID_IStorageTest == riid )
    {
        *ppvObject = static_cast<IStorageTest*>(this);
        AddRef();
    }
#endif // #if DBG
    else
        return E_NOINTERFACE ;

    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IUnknown::AddRef
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNtfsStorage::AddRef(void)
{
    LONG lRet;

    lRet = InterlockedIncrement( &_cReferences );

    nffDebug(( DEB_REFCOUNT, "CNtfsStorage::AddRef(this==%x) == %d\n",
                                this, lRet));

    return( lRet );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IUnknown::Release
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNtfsStorage::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement( &_cReferences );

    if( 0 == lRet )
    {
        delete this;
    }

    nffDebug((DEB_REFCOUNT, "CNtfsStorage::Release(this=%x) == %d\n",
                            this, lRet));

    return( lRet );

}


#ifdef OLE2ANSI
#error CNtfsStorage requires OLECHAR to be UNICODE
#endif

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::CreateStream
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::CreateStream(
        const OLECHAR* pwcsName,
        DWORD grfMode,
        DWORD res1,
        DWORD res2,
        IStream** ppstm)
{
    HRESULT sc=S_OK;
    CNtfsStream *pstm = NULL;
    CNtfsStream *pstmPrevious = NULL;

    //
    // Prop code passed streams names with DOCF_  UPDR_ prefix and are too long.
    //  MikeHill and BChapman agree that the docfile in a stream code should
    //  be moved into this object's (currenly unimplemented) CreateStorage.
    // So for the moment since this IStorage is not exposed, we will remove
    // the parameter validation.
    //
    // NFF_VALIDATE( CreateStream( pwcsName, grfMode, res1, res2, ppstm ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    nffDebug(( DEB_INFO | DEB_OPENS | DEB_TRACE,
               "CreateStream(\"%ws\", %x)\n", pwcsName, grfMode));

    if( STGM_CONVERT & grfMode )
        nffErr( EH_Err, STG_E_INVALIDFLAG );


    if( FindAlreadyOpenStream( pwcsName, &pstmPrevious ) )
    {
        // If the stream is already open then return Access Denied because
        // streams are always opened Exclusive.  But if we are CREATE'ing
        // then revert the old one and make a new one.

        if( 0 == (STGM_CREATE & grfMode) )
        {
            nffErr( EH_Err, STG_E_ACCESSDENIED );
        }
        else
        {
            pstmPrevious->ShutDown();
            pstmPrevious->Release();    // FindAOS() Addref'ed, so release here
            pstmPrevious = NULL;
        }
    }
    nffChk( NewCNtfsStream( pwcsName, grfMode, TRUE, &pstm ));

    // ------------------
    // Set Out Parameters
    // ------------------

    *ppstm = static_cast<IStream*>(pstm);
    pstm = NULL;

EH_Err:

    if( NULL != pstm )
        pstm->Release();

    if( NULL != pstmPrevious )
        pstmPrevious->Release();

    Unlock();

    nffDebug(( DEB_TRACE, "CreateStream() sc=%x\n", sc ));

    return( sc );

}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::OpenStream
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::OpenStream(
        const OLECHAR* pwcsName,
        void* res1,
        DWORD grfMode,
        DWORD res2,
        IStream** ppstm)
{
    HRESULT sc=S_OK;
    CNtfsStream *pstm = NULL;

    //
    // Prop code passed streams names with DOCF_  UPDR_ prefix and are too long.
    //  MikeHill and BChapman agree that the docfile in a stream code should
    //  be moved into this object's (currenly unimplemented) OpenStorage.
    // So for the moment since this IStorage is not exposed, we will remove
    // the parameter validation.
    //
    // NFF_VALIDATE( OpenStream( pwcsName, res1, grfMode, res2, ppstm ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    nffDebug(( DEB_INFO | DEB_OPENS | DEB_TRACE,
               "OpenStream(\"%ws\", grf=0x%x);\n", pwcsName, grfMode ));

    if( FindAlreadyOpenStream( pwcsName, &pstm ) )
        nffErr( EH_Err, STG_E_ACCESSDENIED );

    nffChk( NewCNtfsStream( pwcsName, grfMode, FALSE, &pstm ));

    *ppstm = static_cast<IStream*>(pstm);
    pstm = NULL;

EH_Err:

    if( NULL != pstm )
        pstm->Release();

    Unlock();

    nffDebug(( DEB_TRACE, "OpenStream() sc=%x\n", sc ));

    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::CreateStorage
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::CreateStorage(
        const OLECHAR* pwcsName,
        DWORD grfMode,
        DWORD reserved1,
        DWORD reserved2,
        IStorage** ppstg)
{
    nffXTrace( "CNtfsStorage::CreateStorage" );
    // Not supported
    return( E_NOTIMPL );
}   // CNtfsStorage::CreateStorage



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::OpenStorage
//
//+----------------------------------------------------------------------------

HRESULT CNtfsStorage::OpenStorage(
        const OLECHAR* pwcsName,
        IStorage* pstgPriority,
        DWORD grfMode,
        SNB snbExclude,
        DWORD reserved,
        IStorage** ppstg)
{
    nffXTrace( "CNtfsStorage::OpenStorage" );
    // Not supported
    return( E_NOTIMPL );
}   // CNtfsStorage::OpenStorage



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::CopyTo
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::CopyTo(
        DWORD ciidExclude,
        const IID* rgiidExclude,
        SNB snbExclude,
        IStorage* pstgDest)
{
    nffXTrace( "CNtfsStorage::CopyTo" );

    HRESULT sc=S_OK;
    IEnumSTATSTG *penum=NULL;
    STATSTG statstg = { NULL };
    IStream *pstmSource=NULL;
    IStream *pstmDest  =NULL;
    CULargeInteger cbRead   =0;
    CULargeInteger cbWritten=0;

    NFF_VALIDATE( CopyTo( ciidExclude, rgiidExclude, snbExclude, pstgDest ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if( 0 != ciidExclude || NULL != rgiidExclude || NULL != snbExclude )
        nffErr( EH_Err, E_NOTIMPL );

    if( NULL == pstgDest)
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Get the state bits & clsid from the source
    nffChk( this->Stat( &statstg, STATFLAG_NONAME ));

    // Set the state bits & clsid on the destination
    nffChk( pstgDest->SetStateBits( statstg.grfStateBits, static_cast<ULONG>(-1) ));
    nffChk( pstgDest->SetClass( statstg.clsid ));

    // Start an enumeration of the source streams
    nffChk( EnumElements( 0, NULL, 0, &penum ) );
    sc = penum->Next( 1, &statstg, NULL );

    // Loop through the source streams and copy
    while( S_OK == sc )
    {
        // Create the destination
        nffChk( pstgDest->CreateStream( statstg.pwcsName,
                                        STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                        0, 0, &pstmDest ));

        // Open the source
        nffChk( this->OpenStream( statstg.pwcsName, NULL,
                                  STGM_SHARE_EXCLUSIVE|STGM_READ,
                                  0, &pstmSource ));

        // Copy
        nffChk( pstmSource->CopyTo( pstmDest,
                                    CLargeInteger(static_cast<LONGLONG>(MAXLONGLONG)),
                                    &cbRead, &cbWritten ));
        DfpAssert( cbRead == cbWritten );

        pstmDest->Release(); pstmDest = NULL;
        pstmSource->Release(); pstmSource = NULL;

        // Move on to the next source stream
        CoTaskMemFree( statstg.pwcsName ); statstg.pwcsName = NULL;
        sc = penum->Next( 1, &statstg, NULL );

    }
    nffChk(sc);

    // Normalize all success codes to S_OK
    sc = S_OK;

EH_Err:

    if( NULL != penum )
        penum->Release();

    if( NULL != pstmDest )
        pstmDest->Release();

    if( NULL != pstmSource )
        pstmSource->Release();

    if( NULL != statstg.pwcsName )
        CoTaskMemFree( statstg.pwcsName );

    Unlock();

    return( sc );

}
//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::MoveElementTo
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::MoveElementTo(
        const OLECHAR* pwcsName,
        IStorage* pstgDest,
        const OLECHAR* pwcsNewName,
        DWORD grfFlags)
{
    nffXTrace( "CNtfsStorage::MoveElementTo" );
    HRESULT sc=S_OK;

    NFF_VALIDATE( MoveElementTo( pwcsName, pstgDest, pwcsNewName, grfFlags ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // MoveElementTo not supported.  Use CopyTo and DestroyElement

EH_Err:
    Unlock();

    return( E_NOTIMPL );
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::Commit
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::Commit( DWORD grfCommitFlags )
{
    nffXTrace( "CNtfsStorage::Commit" );
    CNtfsStream *pstm = NULL;
    HRESULT sc=S_OK;

    NFF_VALIDATE( Commit( grfCommitFlags ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    nffChk( _PropertyBagEx.Commit( grfCommitFlags ));

    if( NULL != _pstmOpenList )     // Skip the head sentinal;
        pstm = _pstmOpenList->_pnffstmNext;

    while(NULL != pstm)
    {
        sc = pstm->Commit ( grfCommitFlags );
        if( S_OK != sc )
            break;

        pstm = pstm->_pnffstmNext;
    }

EH_Err:
    Unlock();

    return( sc );
}



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::Revert
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::Revert( void )
{
    nffXTrace( "CNtfsStorage::Revert" );
    // We don't support transactioning, so we must be in direct mode.
    // In direct mode, return S_OK on Revert.
    return( S_OK );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::EnumElements
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::EnumElements(
        DWORD res1,
        void* res2,
        DWORD res3,
        IEnumSTATSTG** ppenum )
{
    nffXTrace( "CNtfsStorage::EnumElements" );
    CNtfsEnumSTATSTG *pNtfsEnumSTATSTG = NULL;
    HRESULT sc=S_OK;

    NFF_VALIDATE( EnumElements( res1, res2, res3, ppenum ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // Create the enumerator
    pNtfsEnumSTATSTG = new CNtfsEnumSTATSTG(
                                  static_cast<IBlockingLock*>(_pTreeMutex) );

    if( NULL == pNtfsEnumSTATSTG )
    {
        sc = E_OUTOFMEMORY;
        goto EH_Err;
    }

    // Initialize the enumerator

    nffChk( pNtfsEnumSTATSTG->Init( _hFileMainStream ));

    //  ----
    //  Exit
    //  ----

    *ppenum = static_cast<IEnumSTATSTG*>(pNtfsEnumSTATSTG);
    pNtfsEnumSTATSTG = NULL;
    sc = S_OK;

EH_Err:

    if( NULL != pNtfsEnumSTATSTG )
        delete pNtfsEnumSTATSTG;

    Unlock();
    return( sc );

}   // CNtfsStorage::EnumElements

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::DestroyElement
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::DestroyElement( const OLECHAR* pwcsName )
{
    nffXTrace( "CNtfsStorage::DestroyElement" );
    HRESULT sc=S_OK;

    NFF_VALIDATE( DestroyElement( pwcsName ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    //
    // We don't allow Destroying the CONTENT Stream.
    //
    if( IsContentStream( pwcsName ) )
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    nffDebug((DEB_INFO, "CNtfsStorage::DestroyElement(\"%ws\", %x)\n",
                        pwcsName));

    sc = DestroyStreamElement( pwcsName );
    if( STG_E_PATHNOTFOUND == sc || STG_E_FILENOTFOUND == sc )
        sc = DestroyStreamElement( CDocfileStreamName(pwcsName) );
    nffChk(sc);

    CNtfsStream *pstm;
    if( FindAlreadyOpenStream( pwcsName, &pstm ) )  // revert open stream
        pstm->ShutDown();


EH_Err:
    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::RenameElement
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::RenameElement(
    const OLECHAR* pwcsOldName,
    const OLECHAR* pwcsNewName)
{
    HRESULT sc=S_OK;
    CNtfsStream *pstm = NULL;
    nffXTrace( "CNtfsStorage::RenameElement" );

    //NFF_VALIDATE( RenameElement( pwcsOldName, pwcsNewName ) );

    Lock( INFINITE );
    nffChk( CheckReverted() );

    //
    // We don't allow Renaming the CONTENT Stream.
    //
    if( IsContentStream( pwcsOldName ) )
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    nffChk( NewCNtfsStream( pwcsOldName,
                            STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                            FALSE,
                            &pstm ) );

    nffChk( pstm->Rename( pwcsNewName, FALSE ));

    nffVerify( 0 == pstm->Release() );
    pstm = NULL;

EH_Err:

    if( NULL != pstm )
        nffVerify( 0 == pstm->Release() );

    Unlock();
    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::SetElementTimes
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SetElementTimes(
        const OLECHAR* pwcsName,
        const FILETIME* pctime,
        const FILETIME* patime,
        const FILETIME* pmtime)
{
    nffXTrace( "CNtfsStorage::SetElementTimes" );
    HRESULT sc=S_OK;

    NFF_VALIDATE( SetElementTimes( pwcsName, pctime, patime, pmtime ) );

    if(NULL != pwcsName)
        return S_OK;

    Lock ( INFINITE );
    nffChk( CheckReverted() );

    nffDebug((DEB_INFO, "CNtfsStorage::SetElementTimes(\"%ws\")\n",
                        pwcsName));

    // If user mode code sets the last modified times on a handle,
    // then WriteFile()s no longer changes the last modified time

    sc = SetAllStreamsTimes(pctime, patime, pmtime);

EH_Err:
    Unlock();
    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::SetClass
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SetClass(
        REFCLSID clsid)
{
    nffXTrace( "CNtfsStorage::SetClass" );
    CLSID clsidOld = _clsidStgClass;
    HRESULT sc = S_OK;

    NFF_VALIDATE( SetClass( clsid ) );

    Lock( INFINITE );
    nffChk( CheckReverted() );

    _clsidStgClass = clsid;
    nffChk( WriteControlStream() );

EH_Err:

    if (FAILED(sc))
        _clsidStgClass = clsidOld;

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::SetStateBits
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SetStateBits(
        DWORD grfStateBits,
        DWORD grfMask)
{
    nffXTrace( "CNtfsStorage::SetStateBits" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( SetStateBits( grfStateBits, grfMask ) );

    Lock( INFINITE );
    nffChk( CheckReverted() );

    _dwStgStateBits = (grfStateBits & grfMask);
    nffChk( WriteControlStream() );

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::Stat
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::Stat(
        STATSTG *pstatstg,
        DWORD grfStatFlag)
{
    nffXTrace( "CNtfsStorage::Stat" );
    HRESULT sc = S_OK;
    BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;
    WCHAR* pwszPath=NULL;

    STATSTG statstg;

    NFF_VALIDATE( Stat( pstatstg, grfStatFlag ) );

    statstg.pwcsName = NULL;

    Lock( INFINITE );
    nffChk( CheckReverted() );

    nffDebug((DEB_INFO, "CNtfsStorage::Stat()\n"));

    // Does the caller want a name?
    if( (STATFLAG_NONAME & grfStatFlag) )
         pwszPath = NULL;
    else
        nffChk( GetFilePath( &pwszPath ) );

    // Get the type
    statstg.type = STGTY_STORAGE;

    // Get the size & times.

    if( !GetFileInformationByHandle( _hFileMainStream,
                                     &ByHandleFileInformation ))
    {
        nffErr( EH_Err, LAST_SCODE );
    }

    statstg.cbSize.LowPart = ByHandleFileInformation.nFileSizeLow;
    statstg.cbSize.HighPart = ByHandleFileInformation.nFileSizeHigh;

    statstg.mtime = ByHandleFileInformation.ftLastWriteTime;
    statstg.atime = ByHandleFileInformation.ftLastAccessTime;
    statstg.ctime = ByHandleFileInformation.ftCreationTime;

    statstg.grfLocksSupported = 0;    // no locks supported

    // Get the STGM modes
    statstg.grfMode = _grfMode & ~STGM_CREATE;


    // Get the clsid & state bits

    statstg.grfStateBits = _dwStgStateBits;
    statstg.clsid        = _clsidStgClass;


    sc = S_OK;

    statstg.pwcsName = pwszPath;
    pwszPath = NULL;

    *pstatstg = statstg;

EH_Err:

    if(NULL != pwszPath)
        CoTaskMemFree( pwszPath);

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IBlockingLock::Lock
//
//+----------------------------------------------------------------------------

inline HRESULT
CNtfsStorage::Lock( DWORD dwTimeout )
{
    // Don't trace at this level.  The noice is too great!
    // nffCDbgTrace dbg(DEB_ITRACE, "CNtfsStorage::Lock");
    nffAssert( INFINITE == dwTimeout );
    if( INFINITE != dwTimeout )
        return( E_NOTIMPL );

    // If there was an error during Initialize(), we may not have created the tree
    // mutex.

    if( NULL == _pTreeMutex )
        return( E_NOTIMPL );
    else
        return _pTreeMutex->Lock( dwTimeout );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IBlockingLock::Unlock
//
//+----------------------------------------------------------------------------

inline HRESULT
CNtfsStorage::Unlock()
{
    // Don't trace at this level.  The noice is too great!
    // nffCDbgTrace dbg(DEB_ITRACE, "CNtfsStorage::Unlock");

    // If there was an error during Initialize(), we may not have created the tree
    // mutex.

    if( NULL == _pTreeMutex )
        return( E_NOTIMPL );
    else
        return _pTreeMutex->Unlock();
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    ITimeAndNoticeControl::SuppressChanges
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SuppressChanges(
        DWORD res1,
        DWORD res2)
{
    HRESULT sc=S_OK;
    FILETIME mtime;


    nffDebug(( DEB_TRACE | DEB_STATCTRL,
               "CNtfsStorage::SuppressChanges(%d,%d)\n",
               res1, res2 ));

    if( 0 != res2 )
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    if( 0 != res1 && NFF_SUPPRESS_NOTIFY != res1)
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if( 0 == res1 )
    {
        nffBool(::GetFileTime( _hFileMainStream, NULL, NULL, &mtime));
        _filetime = mtime;

        nffChk( SetAllStreamsTimes( NULL, NULL, &_filetime ) );
        _dwState |= NFF_NO_TIME_CHANGE;
    }
    else if( NFF_SUPPRESS_NOTIFY == res1 )
    {
        nffChk( MarkAllStreamsAux() );
        _dwState |= NFF_MARK_AUX;

        _filetime.dwLowDateTime = -1;
        _filetime.dwHighDateTime = -1;
        nffChk( SetAllStreamsTimes( NULL, NULL, &_filetime ) );
        _dwState |= NFF_NO_TIME_CHANGE;

    }

EH_Err:
    Unlock();
    return sc;
}


//+----------------------------------------------------------------------------
//  End of Interface Methods
//     -------------
//  Start of C++ Methods.
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Constructor
//
//+----------------------------------------------------------------------------

inline
CNtfsStorage::CNtfsStorage( DWORD grfMode )
        : _sig(NTFSSTORAGE_SIG),
          CPropertySetStorage( MAPPED_STREAM_QI ),
          _PropertyBagEx( grfMode )
{
    nffITrace("CNtfsStorage::CNtfsStorage");

    _grfMode = grfMode;

    _pstmOpenList = NULL;
    _hFileMainStream    = INVALID_HANDLE_VALUE;
    _hFileControlStream = INVALID_HANDLE_VALUE;
    _hFileOplock        = INVALID_HANDLE_VALUE;

    _wcDriveLetter = 0;
    _dwState = 0;

    _hsmStatus = 0;
    _dwStgStateBits = 0;
    _clsidStgClass = CLSID_NULL;

    _pTreeMutex = NULL;
    _filetime.dwHighDateTime = 0;
    _filetime.dwLowDateTime  = 0;

    _ovlpOplock.Internal = _ovlpOplock.InternalHigh = 0;
    _ovlpOplock.Offset = _ovlpOplock.OffsetHigh = 0;
    _ovlpOplock.hEvent = NULL;

    _mhi.UsnSourceInfo = -1;
    _mhi.VolumeHandle = INVALID_HANDLE_VALUE;

    _hOplockThread = NULL;

    // Finish initialization the property set objects.

    _NtfsStorageForPropSetStg.Init( this ); // Not add-refed

    CPropertySetStorage::Init( static_cast<IStorage*>(&_NtfsStorageForPropSetStg),
                               static_cast<IBlockingLock*>(this),
                               FALSE ); // fControlLifetimes (=> don't addref)

    // These are also not add-refed
    _PropertyBagEx.Init( static_cast<IPropertySetStorage*>(this),
                         static_cast<IBlockingLock*>(this) );
};


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::IsNffAppropriate
//
//  Synopsis:   Looks for Control stream and Docfile Header given a filename
//
//  Arguments:  [pwszName] - Filename.
//
//  History:    22-July-98   BChapman   Created
//              10-Nov-98    BChapman   Added global routine so it can be
//                                  called by code that doesn't include
//                                  CNtfsStorage/CNtfsStream definitions.
//+----------------------------------------------------------------------------

HRESULT IsNffAppropriate( const LPCWSTR pwcsName )
{
    return CNtfsStorage::IsNffAppropriate( pwcsName );
}

HRESULT
CNtfsStorage::IsNffAppropriate( const LPCWSTR pwcsName )
{
    UNICODE_STRING usNtfsName;
    LPWSTR pFreeBuffer=NULL;
    HANDLE hFile=INVALID_HANDLE_VALUE;
    HRESULT sc=S_OK;

    if (NULL == pwcsName)
        nffErr  (EH_Err, STG_E_INVALIDNAME);

    if (!RtlDosPathNameToNtPathName_U(pwcsName, &usNtfsName, NULL, NULL))
        nffErr(EH_Err, STG_E_INVALIDNAME);

    // This buffer will need free'ing later
    pFreeBuffer = usNtfsName.Buffer;

    // When Checking file state always open the main stream ReadOnly share
    // everything.  We allow opening Directories.
    //
    nffChk( OpenNtFileHandle( usNtfsName,
                              NULL,     // No Parent File Handle
                              STGM_READ | STGM_SHARE_DENY_NONE,
                              NFFOPEN_NORMAL,
                              FALSE,            // Not a Create API
                              &hFile ) );

    nffChk( IsNffAppropriate( hFile, pwcsName ) );

EH_Err:
    if (NULL != pFreeBuffer)
        RtlFreeHeap(RtlProcessHeap(), 0, pFreeBuffer);

    if( INVALID_HANDLE_VALUE != hFile )
        NtClose( hFile );

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::IsNffAppropriate
//
//  Synopsis:   Looks for Control stream and Docfile Header given a HFILE
//
//  Arguments:  [hFile] - readable File Handle to the main stream.
//
//  History:    22-July-98   BChapman   Created
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::IsNffAppropriate( HANDLE hFile,
                                const WCHAR* wcszPath )
{
    PFILE_STREAM_INFORMATION pfsiBuf = NULL;
    ULONG cbBuf;
    OVERLAPPED olpTemp;
    HANDLE ev=NULL;
    HRESULT sc=S_OK;

    olpTemp.hEvent = NULL;


    // Check that we are on NTFS by doing a stream enum.
    // This is also useful later when looking for a control stream.
    //   PERF we should cache the fsi (reload every create or delete)
    //
    sc = EnumNtStreams( hFile, &pfsiBuf, &cbBuf, TRUE );
    if( FAILED(sc) )
    {
        nffDebug((DEB_IWARN, "EnumNtStreams Failed. Not NTFS.\n" ));
        nffErr( EH_Err,  STG_E_INVALIDFUNCTION );
    }

    // If the control stream exists then the file is NFF.
    //
    if( IsControlStreamExtant( pfsiBuf ) )
    {
        // This is a kludge test for nt4-pre-sp4 system over the RDR.
        nffChk( TestNt4StreamNameBug( pfsiBuf, wcszPath ) );

        goto EH_Err;    // return S_OK;
    }


    // Don't read HSM migrated Files.
    //  If the test fails in any way, assume it is not an HSM file.
    //
    if( S_OK == IsOfflineFile( hFile ) )
        nffErr( EH_Err, STG_E_INCOMPLETE );

    // Check that the file is not a Storage File.  Docfile and NSS don't
    // want this implementation making NTFS streams on their files.
    //
    // To do this we need to read the main stream.

    ZeroMemory( &olpTemp, sizeof(OVERLAPPED) );

    // Create the Event for the Overlapped structure.
    //
    ev = CreateEvent( NULL,     // Security Attributes.
                      TRUE,     // Manual Reset Flag.
                      FALSE,    // Inital State = Signaled, Flag.
                      NULL );   // Name

    if( NULL == ev)
        nffErr( EH_Err, LAST_SCODE );

    olpTemp.hEvent = ev;

    nffChk( StgIsStorageFileHandle( hFile, &olpTemp ) );
    if( S_OK == sc )
        nffErr (EH_Err, STG_E_INVALIDFUNCTION);

    nffAssert(S_FALSE == sc);

    nffChk( TestNt4StreamNameBug( pfsiBuf, wcszPath ) );

    sc = S_OK;

EH_Err:
    if( NULL != pfsiBuf )
        delete [] (BYTE *)pfsiBuf;

    if( NULL != olpTemp.hEvent )
        CloseHandle( olpTemp.hEvent );

    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::TestNt4StreamNameBug
//
//  Synopsis:   Check if a stream with a \005 in the name can be opened.
//              This routine added an extra NTCreateFile to the NFF Open
//              path.  And limits the length of the filename component to
//              MAX_PATH - StrLen(PropSetName().  This routine should be
//              eliminated as soon as NT4 Sp3 is history.
//                The bug this looking for was fixed in nt4 sp4 and Nt5.
//
//  Returns:    S_OK if the system is working correctly
//              STG_E_INVALIDFUNCTION if a \005 stream cannot be opened
//
//  Arguments:  [pfsiBuf]  - Buffer of Enumerated Stream Names.
//              [wcszPath] - Full Pathname of file.
//
//  History:    12-Oct-98   BChapman   Created
//+----------------------------------------------------------------------------

FMTID FMTID_NT4Check = { /* ffc11011-5e3b-11d2-8a3e-00c04f8eedad */
    0xffc11011,
    0x5e3b,
    0x11d2,
    {0x8a, 0x3e, 0x00, 0xc0, 0x4f, 0x8e, 0xed, 0xad}
};

HRESULT
CNtfsStorage::TestNt4StreamNameBug(
        PFILE_STREAM_INFORMATION pfsiBuf,
        const WCHAR* pwcszPath )
{
    const WCHAR* pwcszNtStreamName=NULL;
    WCHAR* pwszPathBuf=NULL;
    int ccBufSize=0;
    HANDLE hFile;
    UNICODE_STRING usNtfsName;
    OBJECT_ATTRIBUTES object_attributes;
    IO_STATUS_BLOCK iostatusblock;
    ACCESS_MASK accessmask=0;
    ULONG ulAttrs=0;
    ULONG ulSharing=0;
    ULONG ulCreateDisp=0;
    ULONG ulCreateOpt = 0;
    NTSTATUS status;
    HRESULT sc=S_OK;

    //  If there is no pathname (and in some calling paths there isn't)
    // then we can't do the test.
    //
    if( NULL == pwcszPath )
        goto EH_Err;    // S_OK

    // last ditch optimization to prevent having to do
    // the NT4 pre-sp4 stream name bug tests.
    //
    if( AreAnyNtPropertyStreamsExtant( pfsiBuf ) )
        goto EH_Err;    // S_OK
    //
    // OK here is the deal....
    // Try to open READONLY a stream that doesn't exist with a \005 in
    // the name.  If the system supports such stream names then it will
    // return filenotfound, on NT4 before sp4 it will return INVALIDNAME.
    //
    {
        CPropSetName psn( FMTID_NT4Check );
        CNtfsStreamName nsn( psn.GetPropSetName() );
        pwcszNtStreamName = nsn;

        //
        // Use the NT API so we don't have to worry about the length
        // of the name.  We have to convert the name while it is less
        // than MAX_PATH.
        //
        if (!RtlDosPathNameToNtPathName_U(pwcszPath, &usNtfsName, NULL, NULL))
            nffErr(EH_Err, STG_E_INVALIDNAME);

        //
        // Build a buffer with the Path + Stream name.  Free the
        // allocated UNICODE_STRING name and point at the buffer.
        //
        ccBufSize = usNtfsName.Length/sizeof(WCHAR)+ wcslen(pwcszNtStreamName) + 1;
        pwszPathBuf = (WCHAR*) alloca( ccBufSize*sizeof(WCHAR) );
        wcsncpy( pwszPathBuf, usNtfsName.Buffer, ccBufSize );
        wcscat( pwszPathBuf, pwcszNtStreamName );

        RtlFreeHeap(RtlProcessHeap(), 0, usNtfsName.Buffer);
        usNtfsName.Buffer = pwszPathBuf;
        usNtfsName.Length = wcslen(pwszPathBuf)*sizeof(WCHAR);
        usNtfsName.MaximumLength = (USHORT)(ccBufSize*sizeof(WCHAR));

        InitializeObjectAttributes(&object_attributes,
                                   &usNtfsName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        nffChk( ModeToNtFlags( STGM_READ|STGM_SHARE_DENY_NONE, 0, FALSE,
                               &accessmask, &ulAttrs, &ulSharing,
                               &ulCreateDisp, &ulCreateOpt ) );

        status = NtCreateFile( &hFile, accessmask,
                               &object_attributes, &iostatusblock,
                               NULL,
                               ulAttrs,      ulSharing,
                               ulCreateDisp, ulCreateOpt,
                               NULL, 0);


        nffAssert( NULL == hFile && "NFF Property TestNt4StreamNameBug" );
        if( NULL != hFile )
            CloseHandle( hFile );

        // The system doesn't support \005.
        //
        if( STATUS_OBJECT_NAME_INVALID == status )
        {
            nffDebug(( DEB_OPENS, "Nt4File: file=(%x) \"%ws\"\n",
                                pwszPathBuf, pwszPathBuf ));
            nffErr( EH_Err, STG_E_INVALIDFUNCTION );
        }

        // NOT_FOUND is the expected status for good systems.
        //
        if( STATUS_OBJECT_NAME_NOT_FOUND != status )
        {
            nffDebug(( DEB_IWARN, "NT4Chk Create Stream status 0x%x\n", status ));
            nffErr(EH_Err, STG_E_INVALIDFUNCTION);
        }
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::IsOfflineFile
//
//  Synopsis:   Check for FILE_ATTRIBUTE_OFFLINE in the file attributes.
//
//  Returns:    S_OK    if the file attributes have the bit set.
//              S_FALSE if the file attributes do not have the bit set.
//              E_*     if an error occured while accessing the attributes.
//
//  Arguments:  [hFile] - Attribute Readable file handle
//
//  History:    27-July-98   BChapman   Created
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::IsOfflineFile( HANDLE hFile )
{
    HRESULT         sc=S_OK;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatblk;
    FILE_BASIC_INFORMATION fbi;

    status = NtQueryInformationFile( hFile,
                                     &iostatblk,
                                     (PVOID) &fbi,
                                     sizeof(FILE_BASIC_INFORMATION),
                                     FileBasicInformation );

    if( !NT_SUCCESS(status) )
    {
        nffDebug(( DEB_IERROR,
                   "Query FileAttributeTagInformation file=%x, failed stat=%x\n",
                   hFile, status ));
        nffErr( EH_Err, NtStatusToScode( status ) );
    }

    // If it does not have a reparse tag, it is not HighLatency
    //
    if( 0==( FILE_ATTRIBUTE_OFFLINE & fbi.FileAttributes) )
    {
        sc = S_FALSE;
        goto EH_Err;
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::InitFromName
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::InitFromName(
        const WCHAR *pwcsName,
        BOOL fCreateAPI,
        DWORD dwOpenFlags )
{
    nffITrace( "CNtfsStorage::Init (name)" );

    HANDLE hFile = INVALID_HANDLE_VALUE;
    UNICODE_STRING usNtfsName;
    WCHAR* pFreeBuffer=NULL;
    DWORD dwTid;
    HRESULT sc=S_OK;
    DWORD fCreateOrNot=0;

    if (!RtlDosPathNameToNtPathName_U(pwcsName, &usNtfsName, NULL, NULL))
        nffErr(EH_Err, STG_E_INVALIDNAME);

    // This buffer will need free'ing later
    pFreeBuffer = usNtfsName.Buffer;


    if( NFFOPEN_OPLOCK & dwOpenFlags )
        nffChk( TakeOplock( usNtfsName ) );


    // Regardless of _grfMode, always open the unnamed stream read-only share
    // everything.  We allow opening Directories.  We use this handle to
    // dup-open all the other streams.
    //
    if( fCreateAPI && (STGM_CREATE & _grfMode) )
        fCreateOrNot = STGM_CREATE;

    nffChk( OpenNtFileHandle( usNtfsName,
                              NULL,     // No Parent File Handle
                              STGM_READ | STGM_SHARE_DENY_NONE | fCreateOrNot,
                              dwOpenFlags & ~NFFOPEN_OPLOCK,
                              fCreateAPI,
                              &hFile ) );

    // Cache the drive letter so that in Stat we can compose a
    // complete path name
    _wcDriveLetter = GetDriveLetter( pwcsName );

    nffChk( InitFromMainStreamHandle( &hFile,
                                      pwcsName,
                                      fCreateAPI,
                                      dwOpenFlags,
                                      STGFMT_ANY ) );

    // hFile now belongs to the object.
    nffAssert( INVALID_HANDLE_VALUE == hFile );

    //
    // If the file was sucessfull Oplocked then
    // start the thread that waits for the OPLOCK to break;
    //
    if( _dwState & NFF_OPLOCKED )
    {
        _hOplockThread = CreateThread(NULL, 0,
                                      CNtfsStorage::OplockWait,
                                      this, 0, &dwTid);

        if( NULL == _hOplockThread )
            nffErr( EH_Err, LAST_SCODE );
    }

EH_Err:
    if (NULL != pFreeBuffer)
        RtlFreeHeap(RtlProcessHeap(), 0, pFreeBuffer);


    if( INVALID_HANDLE_VALUE != hFile )
        NtClose( hFile );

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::InitFromMainStreamHandle
//
//  Synopsis:   Opens NFF file from a handle.
//
//  Arguments:  [hFileMainStream] - ReadOnly DenyNone file handle.
//              [fCreateAPI]      - Called from a Create API (vs. Open)
//              [fmtKnown]        - STGFMT_FILE if IsNffAppropriate has
//                                  already been called.  STGFMT_ANY otherwise
//
//  History:    05-Jun-98   BChapman   Created
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::InitFromMainStreamHandle(
        HANDLE* phFileMainStream,
        const WCHAR* wcszPath,
        BOOL fCreateAPI,
        DWORD dwOpenFlags,
        DWORD fmtKnown )
{
    nffITrace( "CNtfsStorage::InitFromMainStreamHandle(HANDLE)" );

    HRESULT sc = S_OK;

    CNtfsStream*   pstmHeadSentinal= NULL;
    CNFFTreeMutex* pTreeMutex      = NULL;


    // Check that this file should be opened by NFF.
    // Skip the check if the caller has already figured it out.
    //
    if( STGFMT_FILE != fmtKnown )
    {
        nffChk( IsNffAppropriate( *phFileMainStream, wcszPath ) );
        fmtKnown = STGFMT_FILE;
    }

    //
    // Load the Main Stream Handle here so member functions (below)
    // can use it.
    //
    _hFileMainStream = *phFileMainStream;
    *phFileMainStream = INVALID_HANDLE_VALUE;

    // If requested, suppress changes, starting with the main stream handle
    // we just accepted.  All subsequent stream opens/creates (including the
    // Control stream) will be marked similarly.
    //
    if( NFFOPEN_SUPPRESS_CHANGES & dwOpenFlags )
        nffChk( SuppressChanges(1, 0) );

    // Open the ControlPropertySet and place the SHARE MODE locks there
    //
    nffChk( OpenControlStream( fCreateAPI ) );

    // Create a Mutex to Serialize access to the NFF File
    //
    nffMem( pTreeMutex = new CNFFTreeMutex() );
    nffChk( pTreeMutex->Init() );


    // Create an Head Sentinal for the Open Stream List
    //
    nffMem( pstmHeadSentinal = new CNtfsStream( this, pTreeMutex ) );


    // Success!
    _dwState |= NFF_INIT_COMPLETED;

    _pTreeMutex = pTreeMutex;
    pTreeMutex = NULL;

    _pstmOpenList = pstmHeadSentinal;
    pstmHeadSentinal = NULL;


EH_Err:
    if( NULL != pTreeMutex )
        pTreeMutex->Release();

    if( NULL != pstmHeadSentinal )
        pstmHeadSentinal->Release();

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Destructor
//
//+----------------------------------------------------------------------------

inline
CNtfsStorage::~CNtfsStorage()
{
    nffITrace("CNtfsStorage::~CNtfsStorage");

    DWORD rc, hrThread=S_OK;
    HANDLE thread;

    nffDebug(( DEB_REFCOUNT, "~CNtfsStorage\n" ));

    ShutDownStorage();

    //
    // If there is an Oplock Thread it is either still wating and will wake
    // up during the above call to Shutdown, when the Content Stream's file
    // handle is closed.  Or it woke up previously on when the Oplock Broke
    // and has long since terminated.
    //  In either case it has awoken and we can safely wait on its
    // completion status here.
    //
    // The Oplock thread will call Shutdown (and take the tree lock) when it
    // wakes so we must NOT be holding the lock while we wait for him!
    //
    if( NULL != _hOplockThread )
    {
        rc = WaitForSingleObject( _hOplockThread, INFINITE );
        if( !GetExitCodeThread( _hOplockThread, &hrThread ) )
        {
            nffDebug(( DEB_ERROR, "GetExitCode for OplockThread failed %x\n",
                                    GetLastError() ));
        }
        if( FAILED( hrThread ) )
        {
            nffDebug(( DEB_ERROR, "OplockThread exitcode %x\n", hrThread ));
        }
        CloseHandle( _hOplockThread );
        _hOplockThread = NULL;
    }

    if( NULL != _pTreeMutex )
        _pTreeMutex->Release();

    if(NULL != _ovlpOplock.hEvent)
        CloseHandle( _ovlpOplock.hEvent );

    if( INVALID_HANDLE_VALUE != _mhi.VolumeHandle )
        CloseHandle( _mhi.VolumeHandle );

    nffAssert( NULL == _pstmOpenList );

    _sig = NTFSSTORAGE_SIGDEL;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::ShutDownStorage
//
//  Flush data, Close File handle and mark the objects as reverted.
//  This is called when the Oplock Breaks and when the Storage is released.
//  In neither case does the caller hold the tree mutex.  So we take it here.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::ShutDownStorage()
{
    nffITrace( "CNtfsStorage::ShutDownStorage" );
    HRESULT sc, scAccum=S_OK;
    CNtfsStream *pstm = NULL;
    CNtfsStream *pstmNext = NULL;
    PFILE_STREAM_INFORMATION pfsiBuf = NULL;
    ULONG cbBuf;

    Lock( INFINITE );

    if(NFF_FILE_CLOSED & _dwState)
        goto EH_Err;

    _dwState |= NFF_FILE_CLOSED;

    nffDebug(( DEB_INFO, "CNtfsStorage::Shutdown called\n" ));

    if(NFF_INIT_COMPLETED & _dwState)
    {
        if( FAILED(sc = _PropertyBagEx.ShutDown() ))
            scAccum = sc;

        nffAssert( NULL != _pstmOpenList );
        // Skip the head sentinal;
        pstm = _pstmOpenList->_pnffstmNext;

        //
        // Shutdown all the streams.  If there is a problem, make note of it
        // but continue until all the streams are shutdown.
        //
        while(NULL != pstm)
        {
            // ShutDown will cut itself from the list, so pick up the
            // Next pointer before calling it.
            // Let the streams go loose (don't delete or Release them)
            // the app still holds the reference (the list never had a reference)
            //
            pstmNext = pstm->_pnffstmNext;

            if( FAILED( sc = pstm->ShutDown() ) )
                scAccum = sc;

            pstm = pstmNext;
        }

        // Delete the head sentinal because it is not a stream and the
        // app doesn't have a pointer to it.
        //
        nffAssert( NULL == _pstmOpenList->_pnffstmNext );
        _pstmOpenList->Release();
        _pstmOpenList = NULL;

    }

    nffDebug(( DEB_OPENS, "Closing Storage w/ _hFileMainStream=%x\n",
                        _hFileMainStream ));

    if( INVALID_HANDLE_VALUE != _hFileControlStream )
    {
        CloseHandle( _hFileControlStream );
        _hFileControlStream = INVALID_HANDLE_VALUE;
    }

    if( INVALID_HANDLE_VALUE != _hFileMainStream )
    {
        CloseHandle( _hFileMainStream );
        _hFileMainStream = INVALID_HANDLE_VALUE;
    }

    if( INVALID_HANDLE_VALUE != _hFileOplock )
    {
        CloseHandle( _hFileOplock );
        _hFileOplock = INVALID_HANDLE_VALUE;
    }

    _dwState |= NFF_REVERTED;


EH_Err:

    if( NULL != pfsiBuf )
        delete[] pfsiBuf;

    Unlock();
    return scAccum;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::GetStreamHandle
//
//  This method gets the HANDLE for the named stream.
//  It understands grfModes and RelativeOpens of a main stream handle.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::GetStreamHandle(
        HANDLE *phStream,
        const WCHAR * pwcsName,
        DWORD grfMode,
        BOOL fCreateAPI)
{
    HANDLE hFileStream = INVALID_HANDLE_VALUE;
    HRESULT sc=S_OK;
    DWORD dwNffOpenFlags=0;
    CNtfsStreamName nsn( pwcsName );

    nffDebug(( DEB_ITRACE | DEB_INFO,
             "GetStreamHandle(\"%ws\", grf=0x%x, %s)\n",
             pwcsName, grfMode, fCreateAPI?"Create":"Open" ));

    Lock( INFINITE );

    if( IsContentStream( pwcsName ) )
    {
        // The content (main) stream always exists
        //
        if( fCreateAPI && !( STGM_CREATE & grfMode ) )
            nffErr( EH_Err, STG_E_FILEALREADYEXISTS );

        if(NFF_OPLOCKED & _dwState)
        {
            // We don't allow creates of the Content Stream.
            //
            if( fCreateAPI )
                nffErr( EH_Err, STG_E_ACCESSDENIED );

            // We only allow Read Access to the Content Stream
            // in oplocked mode.
            DWORD grfRW = grfMode & STGM_RDWR_MASK;

            if( ( STGM_WRITE == grfRW ) || ( STGM_READWRITE == grfRW ) )
            {
                nffDebug(( DEB_WARN,
                           "Opening Oplocked Main Stream for Writing"
                           " is not allowed\n" ));
                nffErr( EH_Err, STG_E_ACCESSDENIED );

                // only allow read mode.
                //
                //grfMode &= ~STGM_RDWR_MASK;
                //grfMode |= STGM_READ;       // zero flag.
            }
        }

        // only allow DenyNone mode.
        //
        grfMode &= ~STGM_SHARE_MASK;
        grfMode |= STGM_SHARE_DENY_NONE;    // Its is already open for read.

        dwNffOpenFlags |= NFFOPEN_CONTENTSTREAM;
    }
    else    // not the content stream
    {
        // Use the given access mode but
        // Use the container's Share mode.
        //
        grfMode &= ~STGM_SHARE_MASK;
        grfMode |= _grfMode & STGM_SHARE_MASK;
    }

    dwNffOpenFlags |= NFFOPEN_ASYNC;

    sc = OpenNtStream( nsn,            // ":name:$DATA"
                       grfMode,
                       dwNffOpenFlags,
                       fCreateAPI,
                       &hFileStream );
#if DBG==1
    if( STG_E_FILENOTFOUND == sc )
    {
        nffDebug(( DEB_IWARN, "GetStreamHandle: stream '%ws' not found\n",
                              (const WCHAR*)nsn ));
        goto EH_Err;
    }
#endif DBG
    nffChk( sc );

    *phStream = hFileStream;
    hFileStream = INVALID_HANDLE_VALUE;

EH_Err:

#if DBG==1
    if( S_OK != sc )
    {
        nffDebug(( DEB_OPENS|DEB_INFO,
                   "Open on stream '%ws' Failed\n",
                   pwcsName ));
    }
#endif
    if( INVALID_HANDLE_VALUE != hFileStream )
        NtClose( hFileStream );

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::FileAlreadyOpenStream
//
// This routine finds the previously open stream by the given name.
//
//+----------------------------------------------------------------------------

BOOL
CNtfsStorage::FindAlreadyOpenStream(
        const WCHAR* pwcsName,
        CNtfsStream** ppstm)
{
    // Skip the head sentinal.
    CNtfsStream *pstm = _pstmOpenList->_pnffstmNext;

    while(NULL != pstm)
    {
        //if( 0 == _wcsicmp(pwcsName, pstm->GetName() ) )
        if( 0 == dfwcsnicmp( pwcsName, pstm->GetName(), -1 ))
        {
            *ppstm = pstm;
            pstm->AddRef();
            return TRUE;
        }
        pstm = pstm->_pnffstmNext;
    }
    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::NewCNtfsStream
//
// This method lumps together the three phases of creating a new stream
// object (Constructor, Filesystem Open, and Object Initialization).  And
// it handles the special case of opening the "already open" CONTENTS stream.
// This begs the question, why is there three phases.
// 1) We can't put to much in the constructor because of the inability to
//    return errors.
// 2) GetStreamHandle and InitCNtfsStream are broken apart because of the
//    the special needs in the Storage::Init routine.  It opens the
//    CONTENT stream directly and calls InitCNtfsStream to finish.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::NewCNtfsStream( const WCHAR *pwcsName,
                              DWORD grfMode,
                              BOOL fCreateAPI,
                              CNtfsStream **ppstm )
{
    HRESULT sc=S_OK;
    HANDLE hStream = INVALID_HANDLE_VALUE;
    CNtfsStream *pstm = NULL;

    Lock( INFINITE );

    nffMem( pstm = new CNtfsStream( this, (IBlockingLock*) _pTreeMutex ) );
    nffChk( GetStreamHandle( &hStream, pwcsName, grfMode, fCreateAPI ) );
    sc = InitCNtfsStream( pstm, hStream, grfMode, pwcsName );

    hStream = INVALID_HANDLE_VALUE; // hStream now belongs the the object.
    nffChk(sc);

    if( fCreateAPI )
        nffChk( pstm->SetSize( CULargeInteger(0) ));

// Load Out parameters and clear working state
    *ppstm = pstm;
    pstm = NULL;

EH_Err:

    nffDebug(( DEB_ITRACE | DEB_INFO,
             "NewCNtfsStream() sc=%x. hFile=0x%x\n",
             sc,
             FAILED(sc)?INVALID_HANDLE_VALUE:(*ppstm)->GetFileHandle() ));

    if( INVALID_HANDLE_VALUE != hStream )
        NtClose( hStream );

    if( NULL != pstm )
        pstm->Release();

    Unlock();
    return( sc );
}



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface ::DestroyStreamElement
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::DestroyStreamElement( const OLECHAR *pwcsName )
{
    nffXTrace( "CNtfsStorage::DestroyStreamElement" );

    HANDLE hFileStream = INVALID_HANDLE_VALUE;
    HRESULT sc=S_OK;


    Lock( INFINITE );
    nffChk( CheckReverted() );
    nffDebug(( DEB_INFO | DEB_WRITE,
               "CNtfsStorage::DestroyStreamElement('%ws')\n",
               pwcsName));

    // Open the handle with DELETE permissions.  Write includes Delete.
    //
    nffChk( OpenNtStream( CNtfsStreamName(pwcsName),         // ":name:$Data"
                          STGM_WRITE | STGM_SHARE_DENY_NONE, // grfMode
                          NFFOPEN_SYNC,
                          FALSE,                             // not CreateAPI
                          &hFileStream ) );

    nffChk( CNtfsStream::DeleteStream( &hFileStream ));

EH_Err:

    if( INVALID_HANDLE_VALUE != hFileStream )
    {
        NtClose( hFileStream );
    }

    Unlock();
    return( sc );

}   // CNtfsStorage::DestroyStreamElement


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface ::GetFilePath
//      Helper routine for Stat.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::GetFilePath( WCHAR** ppwszPath )
{
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG cbFileNameInfo = 2*(MAX_PATH+1)+sizeof(FILE_NAME_INFORMATION);
    PFILE_NAME_INFORMATION pFileNameInfo=NULL;
    WCHAR* pwsz=NULL;

    HRESULT sc;
    NTSTATUS status;

    // Query the handle for the "volume-relative" path.  This isn't
    // actually volume-relative (e.g. on a UNC path), it's actually
    // the complete path without the leading "D:" or leading "\".

    pFileNameInfo = (PFILE_NAME_INFORMATION)CoTaskMemAlloc( cbFileNameInfo );
    nffMem( pFileNameInfo );

    // Get the file name
    status = NtQueryInformationFile( _hFileMainStream,
                                    &IoStatusBlock,
                                    pFileNameInfo,
                                    cbFileNameInfo,
                                    FileNameInformation );

    if( !NT_SUCCESS(status) )
    {
        if( STATUS_BUFFER_OVERFLOW == status )
            nffErr( EH_Err, CO_E_PATHTOOLONG);
        nffErr( EH_Err, NtStatusToScode( status ) );
    }

    if( 0 == pFileNameInfo->FileNameLength )
        nffErr( EH_Err, STG_E_INVALIDHEADER );


    // Allocate and copy this filename for the return.
    //

    int cbFileName;
    int cchPrefix;

    cbFileName = pFileNameInfo->FileNameLength + (sizeof(WCHAR) * 3);

    nffMem( pwsz = (WCHAR*) CoTaskMemAlloc( cbFileName ) );

    // Start with the Drive Letter or "\" for UNC paths
    if (IsCharAlphaW(_wcDriveLetter))
    {
        pwsz[0] = _wcDriveLetter;
        pwsz[1] = L':';
        pwsz[2] = L'\0';
        cchPrefix = 2;
    }
    else
    {
        nffAssert( L'\\' == _wcDriveLetter );
        pwsz[0] = L'\\';
        pwsz[1] = L'\0';
        cchPrefix = 1;
    }

    // Copy in the File Path we got from NT.  We have a length and it is
    // not necessarily NULL terminated.
    //
    CopyMemory(&pwsz[cchPrefix],
               &pFileNameInfo->FileName,
               pFileNameInfo->FileNameLength );

    // NULL terminiate the string.  Assuming we got the length allocation
    // right, then the NULL just goes at the end.
    //
    pwsz[ cchPrefix + pFileNameInfo->FileNameLength/sizeof(WCHAR) ] = L'\0';

    // Copy the Out Params And Clear the Temporaries.
    *ppwszPath = pwsz;
    pwsz = NULL;

EH_Err:
    if( NULL != pFileNameInfo )
        CoTaskMemFree( pFileNameInfo );

    if( NULL != pwsz )
        CoTaskMemFree( pwsz );

    return sc;
}



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    non-interface TakeOplock
//
// There is no documentation for how this works.  I exchanged
// Email with the Filesystem SDEs and the FileSys Test SDEs and
// I wrote some test programs to explore the functionality.
// I also looked at Content Indexing's code (query\fsci\indexing\cioplock.cxx)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::TakeOplock( const UNICODE_STRING& usName )
{
    HANDLE ev=NULL;
    HANDLE hFile=INVALID_HANDLE_VALUE;
    HRESULT sc=S_OK;

    nffChk( CheckReverted() );

    //
    // If the event exists then the Oplock is already Set.
    //
    if( NULL != _ovlpOplock.hEvent )
        return S_OK;

    // If we have no event, we should have no waiting thread.
    //
    nffAssert( NULL == _hOplockThread );

    // Create the Event for the Oplock Wait Call.
    //
    ev = CreateEvent( NULL,     // Security Attributes.
                      TRUE,     // Manual Reset Flag.
                      FALSE,    // Inital State = Signaled, Flag.
                      NULL );   // Name

    if( NULL == ev)
        nffErr( EH_Err, LAST_SCODE );

    _ovlpOplock.hEvent = ev;
    ev = NULL;

    nffChk( OpenNtFileHandle( usName,
                              NULL,                 // No Parent File Handle
                              STGM_READ_ATTRIBUTE,  // Not a Real Flag.
                              NFFOPEN_OPLOCK,
                              FALSE,
                              &hFile ) );

    nffDebug(( DEB_ITRACE | DEB_OPLOCK, "Taking Oplock hFile=%x\n", hFile ));

    //
    // We should get FALSE / ERROR_IO_PENDING if the Oplock is taken
    // on the file.
    //
    if( DeviceIoControl( hFile,
                         FSCTL_REQUEST_FILTER_OPLOCK,
                         0, 0, 0, 0, 0, &_ovlpOplock) )
    {
        nffErr( EH_Err, E_UNEXPECTED);
    }
    else
    {
        if( ERROR_IO_PENDING != GetLastError() )
            nffErr( EH_Err, LAST_SCODE );
    }

    _hFileOplock = hFile;
    hFile = INVALID_HANDLE_VALUE;

    _dwState |= NFF_OPLOCKED;

EH_Err:
    if( NULL != ev )
        CloseHandle( ev );

    if( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );

    // If we couldn't get the oplock, treat it as a sharing violation
    if( NtStatusToScode(STATUS_OPLOCK_NOT_GRANTED) == sc )
        sc = STG_E_SHAREVIOLATION;

    return sc;
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::OplockWait
//
//  The CNtfsStorage destructor will wait for this thread to finish, so we
//  know pThis-> still exists when we return from WaitForSingleObject().
//
//  We take the tree lock before calling ShutDownStorage.
//
//+----------------------------------------------------------------------------

DWORD WINAPI
CNtfsStorage::OplockWait(PVOID pvThis)
{
    nffXTrace( "CNtfsStorage::OplockWait" );
    CNtfsStorage *pThis = static_cast<CNtfsStorage*>(pvThis);
    DWORD dwReason;
    DWORD dwStatus;
    HRESULT sc=S_OK;
    BOOL rc;


    nffDebug(( DEB_OPLOCK, "Waiting on Oplock\n" ));

    rc = GetOverlappedResult( pThis->_hFileOplock,
                              &(pThis->_ovlpOplock),
                              &dwStatus,
                              TRUE);

#if DBG==1
    WCHAR* pwcsPath=NULL;

    pThis->GetFilePath( &pwcsPath );
    nffDebug(( DEB_OPLOCK, "Oplock Broke(%x,%x) '%ws'\n",
                           rc, dwStatus, pwcsPath ));
    if(NULL != pwcsPath)
        CoTaskMemFree(pwcsPath);
#endif

    pThis->Lock( INFINITE );

    if( FALSE == rc )
    {
        nffDebug(( DEB_ERROR, "Oplock thread broke for unknown status\n" ));
        sc = GetLastError();    // For Debugging;
        nffErr( EH_Err, E_UNEXPECTED );
    }
    switch(dwStatus)
    {
        // Someone opened for read.
    case FILE_OPLOCK_BROKEN_TO_LEVEL_2:
        // File Opened for write or handle was closed.
    case FILE_OPLOCK_BROKEN_TO_NONE:
        break;

    default:
        nffDebug(( DEB_ERROR,
                   "OplockWait, GetOLResult returned strange status %x\n",
                   dwStatus ));
        break;
    }

EH_Err:
    sc = pThis->ShutDownStorage();
    pThis->Unlock();
    return sc;
}


BOOL
CNtfsStorage::IsControlStreamExtant( PFILE_STREAM_INFORMATION pfsiBuf )
{
    return IsNtStreamExtant( pfsiBuf, CNtfsStreamName( GetControlStreamName() ));
}


BOOL
CNtfsStorage::AreAnyNtPropertyStreamsExtant( PFILE_STREAM_INFORMATION pfsiBuf )
{
    return FindStreamPrefixInFSI( pfsiBuf, L":\005" );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::OpenControlStream
//
// This stream is not a property set at the moment.  Because we put one of
// these on every file and it normally doesn't actually contain _any_ data we
// feel that the overhead of 88 bytes for an empty PPSet was too great.
//
// An important role of the control property set is to the be first stream
// (after the main stream) to be opened.  The share mode of the container is
// is expressed by the share mode of the control property set stream.
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::OpenControlStream( BOOL fCreateAPI )
{
    nffITrace( "CNtfsStorage::OpenControlPropertySet" );

    HRESULT sc = S_OK;
    HANDLE hFile=INVALID_HANDLE_VALUE;
    NFFCONTROLBITS nffControlBits;
    DWORD cbDidRead=0;
    DWORD grfModeOpen=0;
    CNtfsStreamName ntfsnameControlStream( GetControlStreamName() );
    CNtfsStreamName ntfsnameContentStream( GetContentStreamName() );

    //  We shouldn't be called more than once.
    // But we can handle it correctly here.
    //
    if( INVALID_HANDLE_VALUE != _hFileControlStream )
        goto EH_Err;

    //  Add STGM_CREATE flag in the open path (this is an internal only mode
    // that uses NT's OPEN_IF).
    // Don't add it in the Create path because that would mean OverWrite.
    // Don't add it in the ReadOnly case because it would create a stream.
    //
    grfModeOpen = _grfMode;
    if( !fCreateAPI && GrfModeIsWriteable( _grfMode ) )
        grfModeOpen |= STGM_CREATE;

    sc = OpenNtStream( ntfsnameControlStream,
                       grfModeOpen,
                       NFFOPEN_SYNC,
                       fCreateAPI,
                       &hFile );

    //
    // If we are a ReadOnly Open, then it is OK to not have a
    // control stream.
    //
    if( STG_E_FILENOTFOUND == sc )
    {
        if( !fCreateAPI && !GrfModeIsWriteable( _grfMode ) )
        {
            sc = S_OK;
            goto EH_Err;
        }
    }

    //
    // If we are not holding an Oplock then if we got a share vio then
    // try to break any other oplock that might be present.
    // Then try to open the control stream again.
    //
    if( 0 == (_dwState & NFF_OPLOCKED) )
    {
        if( STG_E_SHAREVIOLATION == sc )
        {
            // Open to break the lock.
            sc = OpenNtStream( ntfsnameContentStream,
                               STGM_READWRITE | STGM_SHARE_DENY_NONE,
                               NFFOPEN_CONTENTSTREAM,
                               FALSE,          // Not Create, just "Open" API
                               &hFile );

            // We don't really care if it succeeded or not.
            // But sure to close the file.
            if( SUCCEEDED(sc) )
            {
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
            }

            // Now try to really open again.  Don't use OPEN_IF cause if we are
            // fighting over the stream then it must already exist.
            sc = OpenNtStream( ntfsnameControlStream,
                               _grfMode,
                               NFFOPEN_SYNC,
                               fCreateAPI,
                               &hFile );
        }
    }

    // Catch any non-shareVio errors from the first OpenNtStream.
    //
    nffChk(sc);

    // If we're suppressing time and/or USN updates,
    // handle that suppression now.

    if( GrfModeIsWriteable( _grfMode ) )
    {
        if(_dwState & NFF_NO_TIME_CHANGE)
        {
            nffAssert(_filetime.dwHighDateTime != 0);
            nffChk( CNtfsStream::SetFileHandleTime( hFile, NULL, NULL, &_filetime ));
        }

        if(_dwState & NFF_MARK_AUX)
        {
            // Assert that the AUX_DATA request data is init'ed correctly.
            //
            nffAssert( USN_SOURCE_AUXILIARY_DATA == _mhi.UsnSourceInfo );
            nffChk( CNtfsStream::MarkFileHandleAux( hFile, _mhi ));
        }
    }

    // Set buffer to Zero so short reads are OK.
    ZeroMemory(&nffControlBits, sizeof(NFFCONTROLBITS) );

    if( !ReadFile( hFile, &nffControlBits,
                    sizeof(nffControlBits), &cbDidRead, NULL) )
    {
        nffErr(EH_Err, LAST_SCODE);
    }

    // Currently we only support version 0 control streams.
    // Note: a zero length stream is a version zero stream.
    //
    if( 0 != nffControlBits.sig)
        nffErr(EH_Err, STG_E_INVALIDHEADER);

    _dwStgStateBits = nffControlBits.bits;
    _clsidStgClass  = nffControlBits.clsid;
    _hsmStatus      = nffControlBits.hsmStatus;

    _hFileControlStream = hFile;
    hFile = INVALID_HANDLE_VALUE;

EH_Err:
    if(INVALID_HANDLE_VALUE != hFile)
        NtClose(hFile);

    return( sc );

}   // CNtfsStorage::OpenControlPropertySet



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::DeleteControlStream
//
//  Delete the control stream.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::DeleteControlStream()
{
    HRESULT sc = S_OK;
    HANDLE hStream = INVALID_HANDLE_VALUE;

    if( INVALID_HANDLE_VALUE != _hFileControlStream )
    {
        if( !(_dwState & NFF_MARK_AUX) )
        {
            nffChk( InitUsnInfo() );
            nffChk( CNtfsStream::MarkFileHandleAux( _hFileControlStream, _mhi ));
        }
        nffChk( CNtfsStream::DeleteStream( &_hFileControlStream ));
    }
    else
    {
        nffChk( OpenNtStream( CNtfsStreamName( GetControlStreamName() ),
                              STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                              NFFOPEN_SYNC,
                              FALSE,       // Open API
                              &hStream ));

        nffChk( InitUsnInfo() );
        nffChk( CNtfsStream::MarkFileHandleAux( hStream, _mhi ));

        sc = CNtfsStream::DeleteStream( &hStream );
        nffChk( sc );
    }

EH_Err:

    if( INVALID_HANDLE_VALUE != hStream )
        NtClose( hStream );

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::WriteControlStream
//
//+----------------------------------------------------------------------------
HRESULT
CNtfsStorage::WriteControlStream()
{
    NFFCONTROLBITS nffcb;
    LONG cbToWrite=0;
    ULONG cbDidWrite=0;
    HRESULT sc=S_OK;

    nffAssert( INVALID_HANDLE_VALUE != _hFileControlStream );

    nffcb.sig = 0;
    nffcb.hsmStatus = _hsmStatus;
    nffcb.bits = _dwStgStateBits;
    nffcb.clsid = _clsidStgClass;

    // Try to save some space in the file by not writing the CLSID
    // if it is all zeros.
    //
    if( IsEqualGUID(_clsidStgClass, CLSID_NULL) )
    {
        cbToWrite = FIELD_OFFSET(NFFCONTROLBITS, clsid);
        // Assert that clsid is the last thing in the struct.
        nffAssert( sizeof(NFFCONTROLBITS) == cbToWrite+sizeof(CLSID) );
    }
    else
        cbToWrite = sizeof(NFFCONTROLBITS);

    if( -1 == SetFilePointer( _hFileControlStream, 0, NULL, FILE_BEGIN ) )
        nffErr( EH_Err, LAST_SCODE );

    if( !WriteFile( _hFileControlStream,
                    &nffcb,
                    cbToWrite,
                    &cbDidWrite,
                    NULL) )
    {
        nffErr(EH_Err, LAST_SCODE);
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::StreamExists
//      The right way to do this is with enumeration.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::StreamExists( const WCHAR *pwcsName )
{
    nffITrace( "CNtfsStorage::StreamExists" );

    HANDLE hFileStream = NULL;
    HRESULT sc = S_OK;

    if( IsContentStream( pwcsName ) )
    {
        // The Contents stream always exists
        sc = S_OK;
    }
    else
    {
        sc = OpenNtStream( CNtfsStreamName(pwcsName),
                           STGM_READ_ATTRIBUTE | STGM_SHARE_DENY_NONE,
                           NFFOPEN_NORMAL,
                           FALSE,        // Not a create API.
                           &hFileStream);
        if( S_OK == sc )
        {
            NtClose( hFileStream );
        }
        else
            sc = S_FALSE;
    }
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::SetAllStreamsTimes
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SetAllStreamsTimes(
        const FILETIME *pctime,
        const FILETIME *patime,
        const FILETIME *pmtime)
{
    HRESULT sc=S_OK;
    HRESULT scAccum=S_OK;
    CNtfsStream *pstm = NULL;

    nffDebug(( DEB_INFO | DEB_STATCTRL | DEB_ITRACE,
             "CNtfsStorage::SetAllStreamsTimes()\n" ));

    // Set the time on the main control stream.

    if( INVALID_HANDLE_VALUE != _hFileControlStream )
    {
        sc = CNtfsStream::SetFileHandleTime( _hFileControlStream,
                                             pctime, patime, pmtime );
        if( S_OK != sc )
            scAccum = sc;
    }

    // We don't set time stamps on _hFileMainStream and _hFileOplock
    // Because they are readonly.  (and _hFileOplock is not always open)


    // Now set the time on any CNtfsStream objects we have open.

    if( NULL != _pstmOpenList )     // Skip the head sentinal;
        pstm = _pstmOpenList->_pnffstmNext;

    while(NULL != pstm)
    {
        sc = pstm->SetStreamTime( pctime, patime, pmtime );
        if( S_OK != sc )
            scAccum = sc;

        pstm = pstm->_pnffstmNext;
    }

    return scAccum;
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::MarkAllStreamsAux
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::MarkAllStreamsAux()
{
    HRESULT sc=S_OK;
    HRESULT scAccum=S_OK;
    CNtfsStream *pstm = NULL;
    DWORD cbReturned=0;

    nffDebug(( DEB_INFO | DEB_STATCTRL | DEB_ITRACE,
             "CNtfsStorage::MarkAllStreamsAux()\n" ));

    // Initialize _mhi and _filetime
    sc = InitUsnInfo();
    if( FAILED(sc) )
    {
        scAccum = sc;
        goto EH_Err;
    }

    // Mark each of the handles we have open (not including
    // handles that are held by CNtfsStream objects).

    if( INVALID_HANDLE_VALUE != _hFileMainStream )
    {
        sc = CNtfsStream::MarkFileHandleAux( _hFileMainStream, _mhi );
        if( S_OK != sc )
            scAccum = sc;
    }

    if( INVALID_HANDLE_VALUE != _hFileControlStream )
    {
        sc = CNtfsStream::MarkFileHandleAux( _hFileControlStream, _mhi );
        if( S_OK != sc )
            scAccum = sc;
    }

    if( INVALID_HANDLE_VALUE != _hFileOplock )
    {
        sc = CNtfsStream::MarkFileHandleAux( _hFileOplock, _mhi );
        if( S_OK != sc )
            scAccum = sc;
    }


    // Now give the open CNtfsStream objects an opportunity
    // to mark the aux bit.

    if( NULL != _pstmOpenList ) // Skip the head sentinal;
        pstm = _pstmOpenList->_pnffstmNext;

    while( NULL != pstm )
    {
        sc = pstm->MarkStreamAux( _mhi );
        if( S_OK != sc )
            scAccum = sc;

        pstm = pstm->_pnffstmNext;
    }

EH_Err:
    return scAccum;
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::InitUsnInfo
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::InitUsnInfo()
{
    HANDLE hVolume;
    WCHAR wszVolume[]=L"\\\\.\\Z:";
    HRESULT sc=S_OK;

    if( USN_SOURCE_AUXILIARY_DATA == _mhi.UsnSourceInfo)
        return S_OK;

    if(L'\\' == _wcDriveLetter)
        nffErr( EH_Err, HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) );

    wszVolume[4] = _wcDriveLetter;

    hVolume = CreateFile( wszVolume,
                    FILE_WRITE_ATTRIBUTES,              // Desired Access
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,           // Security
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if(INVALID_HANDLE_VALUE == hVolume)
    {
        nffDebug(( DEB_ERROR,
                  "Failed to Open Volume Handle. Aux Marking will Fail.\n" ));
        nffErr( EH_Err, LAST_SCODE );
    }

    _mhi.UsnSourceInfo = USN_SOURCE_AUXILIARY_DATA;
    _mhi.VolumeHandle = hVolume;
    _mhi.HandleInfo = 0;

EH_Err:
    return sc;
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::InitCNtfsStream
//
//  Create and Init an CNtfsStream Object.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::InitCNtfsStream(
        CNtfsStream *pstm,
        HANDLE hStream,
        DWORD grfMode,
        const WCHAR * pwcsName )
{
    nffITrace("CNtfsStorage::InitCNtfsStream");
    HRESULT sc=S_OK;

    // Attach the File Stream to the Stream Object
    nffChk( pstm->Init( hStream, grfMode, pwcsName, _pstmOpenList ) );

    if( ( ( STGM_RDWR & grfMode ) == STGM_WRITE )
      ||( ( STGM_RDWR & grfMode ) == STGM_READWRITE ) )
    {
        // Note: modification time suppression is done per handle
        //  so if that is turned on do that now.
        if(_dwState & NFF_NO_TIME_CHANGE)
        {
            nffAssert(_filetime.dwHighDateTime != 0);
            sc = pstm->SetStreamTime( NULL, NULL, &_filetime );
            if(FAILED(sc))
            {
                nffDebug(( 0 == dfwcsnicmp( pwcsName, GetContentStreamName(), -1 )
                               ? DEB_IERROR : DEB_ERROR,
                           "Trouble %x Setting FileTime '%ws'\n",
                           sc, pwcsName));
            }
        }

        // Note: AUX_DATA marking is done per handle
        //  so if that feature is turned on then do that now.
        if(_dwState & NFF_MARK_AUX)
        {
            // Assert that the AUX_DATA request data is init'ed correctly.
            //
            nffAssert( USN_SOURCE_AUXILIARY_DATA == _mhi.UsnSourceInfo );
            sc = pstm->MarkStreamAux( _mhi );
            if(FAILED(sc))
            {
                nffDebug(( DEB_ERROR,
                           "Trouble %x Setting AUX_DATA for '%ws'\n",
                           sc, pwcsName));
            }
        }
    }
    sc = S_OK;

EH_Err:

    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::ModeToNtFlags
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::ModeToNtFlags(DWORD grfMode,
                            DWORD dwFlags,
                            BOOL fCreateAPI,
                            ACCESS_MASK *pam,
                            ULONG *pulAttributes,
                            ULONG *pulSharing,
                            ULONG *pulCreateDisposition,
                            ULONG *pulCreateOptions)
{
    SCODE sc=S_OK;

    nffDebug((DEB_ITRACE, "In  ModeToNtFlags("
             "%lX, %d %d, %p, %p, %p, %p, %p)\n",
             grfMode, dwFlags, fCreateAPI, pam,
             pulAttributes,        pulSharing,
             pulCreateDisposition, pulCreateOptions));

    *pam = 0;
    *pulAttributes = 0;
    *pulSharing = 0;
    *pulCreateDisposition = 0;
    *pulCreateOptions = 0;

    switch(grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE | STGM_READ_ATTRIBUTE))
    {
    case STGM_READ:
        *pam = FILE_GENERIC_READ;
        break;

    case STGM_WRITE:
        *pam = FILE_GENERIC_WRITE;
        if( 0 == (NFFOPEN_CONTENTSTREAM & dwFlags) )
            *pam |= DELETE;
        break;

    case STGM_READWRITE:
        *pam = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
        if( 0 == (NFFOPEN_CONTENTSTREAM & dwFlags) )
            *pam |= DELETE;

        break;

    case STGM_READ_ATTRIBUTE:
        *pam = FILE_READ_ATTRIBUTES;
        break;

    default:
        nffErr(EH_Err, STG_E_INVALIDFLAG);
        break;
    }


    switch(grfMode & (STGM_SHARE_DENY_NONE | STGM_SHARE_DENY_READ |
                      STGM_SHARE_DENY_WRITE | STGM_SHARE_EXCLUSIVE))
    {
    case STGM_SHARE_DENY_READ:
        *pulSharing = FILE_SHARE_WRITE | FILE_SHARE_DELETE;
        break;
    case STGM_SHARE_DENY_WRITE:
        *pulSharing = FILE_SHARE_READ;
        break;
    case STGM_SHARE_EXCLUSIVE:
        *pulSharing = 0;
        break;
    case STGM_SHARE_DENY_NONE:
    case 0:
        *pulSharing = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
        break;

    default:
        nffErr(EH_Err, STG_E_INVALIDFLAG);
        break;
    }

    switch(grfMode & (STGM_CREATE | STGM_FAILIFTHERE | STGM_CONVERT))
    {
    case STGM_CREATE:
        if (fCreateAPI)
            *pulCreateDisposition = FILE_OVERWRITE_IF;
        else
            *pulCreateDisposition = FILE_OPEN_IF;   // Illegal but used internaly
        break;
    case STGM_FAILIFTHERE:  // this is a 0 flag
        if (fCreateAPI)
            *pulCreateDisposition = FILE_CREATE;
        else
            *pulCreateDisposition = FILE_OPEN;
        break;

    case STGM_CONVERT:
        nffDebug(( DEB_ERROR, "STGM_CONVERT illegal flag to NFF" ));
        nffErr(EH_Err, STG_E_INVALIDFLAG);
        break;

    default:
        nffErr(EH_Err, STG_E_INVALIDFLAG);
        break;
    }

    if( NFFOPEN_SYNC & dwFlags )
        *pulCreateOptions |= FILE_SYNCHRONOUS_IO_NONALERT;

    if( NFFOPEN_OPLOCK & dwFlags )
        *pulCreateOptions |= FILE_RESERVE_OPFILTER;

    *pulAttributes = FILE_ATTRIBUTE_NORMAL;

    sc = S_OK;

    nffDebug((DEB_ITRACE, "Out ModeToNtFlags\n"));
 EH_Err:
    return sc;
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::OpenNtStream
//      Used by NFF to open a named stream, relative to an exiting main
//      stream handle.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::OpenNtStream( const CNtfsStreamName& nsnName,
                            DWORD grfMode,
                            DWORD dwFlags,
                            BOOL fCreateAPI,
                            HANDLE* phFile )
{
    UNICODE_STRING usNtfsStreamName;

    RtlInitUnicodeString(&usNtfsStreamName, (const WCHAR*)nsnName);

    return OpenNtFileHandle( usNtfsStreamName,
                             _hFileMainStream,
                             grfMode,
                             dwFlags,
                             fCreateAPI,
                             phFile);
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::OpenNtFileHandle
//      Common sub-code for OpenNtFile and OpenNtStream
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::OpenNtFileHandle( const UNICODE_STRING& usNtfsStreamName,
                                HANDLE hParent,
                                DWORD grfMode,
                                DWORD dwFlags,
                                BOOL fCreateAPI,
                                HANDLE *phFile)
{
    OBJECT_ATTRIBUTES object_attributes;
    IO_STATUS_BLOCK iostatusblock;
    HANDLE hStream;
    ACCESS_MASK accessmask=0;
    ULONG ulAttrs=0;
    ULONG ulSharing=0;
    ULONG ulCreateDisp=0;
    ULONG ulCreateOpt = 0;


    SCODE sc;
    NTSTATUS status;

    nffDebug(( DEB_ITRACE | DEB_OPENS,
               "OpenNtStream(%ws, %p, %lX, %d, %p)\n",
               usNtfsStreamName.Buffer,
               hParent, grfMode,
               fCreateAPI, phFile ));

    InitializeObjectAttributes(&object_attributes,
                               (PUNICODE_STRING) &usNtfsStreamName, // cast away const
                               OBJ_CASE_INSENSITIVE,
                               hParent,
                               NULL);

    nffChk( ModeToNtFlags( grfMode, dwFlags, fCreateAPI,
                           &accessmask, &ulAttrs, &ulSharing,
                           &ulCreateDisp, &ulCreateOpt ) );

    status = NtCreateFile( &hStream, accessmask,
                           &object_attributes, &iostatusblock,
                           NULL,
                           ulAttrs,      ulSharing,
                           ulCreateDisp, ulCreateOpt,
                           NULL, 0);

    if (NT_SUCCESS(status))
    {
        *phFile = hStream;
        sc = S_OK;
    }
    else
        sc = NtStatusToScode(status);

 EH_Err:
    nffDebug(( DEB_ITRACE | DEB_OPENS,
                  "OpenNtFileHandle returns hFile=%x sc=%x status=%x\n",
                  *phFile, sc, status));

    return sc;
}



//////////////////////////////////////////////////////////////////////////
//
//  CNFFTreeMutex
//
//////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IUnknown::QueryInterface
//
//+----------------------------------------------------------------------------

HRESULT
CNFFTreeMutex::QueryInterface(
    REFIID  riid,
    void ** ppvObject
    )
{
    //nffITrace( "CNFFTreeMutex::QueryInterface");
    HRESULT sc = S_OK;

    //  ----------
    //  Validation
    //  ----------

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    *ppvObject = NULL;

    //  -----
    //  Query
    //  -----

    if( IID_IUnknown == riid || IID_IBlockingLock == riid )
    {
        *ppvObject = static_cast<IBlockingLock*>(this);
        AddRef();
    }
    else
        sc = E_NOINTERFACE;


    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IUnknown::AddRef
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNFFTreeMutex::AddRef(void)
{
    LONG lRet;

    lRet = InterlockedIncrement( &_cRefs );

    nffDebug(( DEB_REFCOUNT, "CNFFTreeMutex::AddRef(this==%x) == %d\n",
                            this, lRet));

    return( lRet );

}


//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IUnknown::Release
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNFFTreeMutex::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement( &_cRefs );

    if( 0 == lRet )
        delete this;

    nffDebug((DEB_REFCOUNT, "CNFFTreeMutex::Release(this=%x) == %d\n",
                            this, lRet));

    return( lRet );

}


//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IBlockingLock::Lock
//
//+----------------------------------------------------------------------------

inline HRESULT
CNFFTreeMutex::Lock( DWORD dwTimeout )
{

    // Don't trace at this level.  The noice is too great!
    // nffCDbgTrace dbg(DEB_ITRACE, "CNFFTreeMutex::Lock");

    nffAssert (_fInitialized == TRUE);
    nffAssert( INFINITE == dwTimeout );
    if( INFINITE != dwTimeout )
        return( E_NOTIMPL );

    EnterCriticalSection( &_cs );
    nffDebug(( DEB_ITRACE, "Tree Locked. cnt=%d\n", _cs.RecursionCount ));
    return( S_OK );
}


//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IBlockingLock::Unlock
//
//+----------------------------------------------------------------------------

inline HRESULT
CNFFTreeMutex::Unlock()
{
    // Don't trace at this level.  The noice is too great!
    //nffCDbgTrace dbg(DEB_ITRACE, "CNFFTreeMutex::Unlock");
    nffAssert (_fInitialized == TRUE);
    LeaveCriticalSection( &_cs );
    nffDebug(( DEB_ITRACE, "Tree Unlocked. cnt=%d\n", _cs.RecursionCount ));
    return( S_OK );
}


#if DBG
LONG
CNFFTreeMutex::GetLockCount()
{
    return( _cs.LockCount + 1 );
}
#endif // #if DBG


//////////////////////////////////////////////////////////////////////////
//
//  CNtfsEnumSTATSTG
//
//////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::QueryInterface (IUnknown)
//
//+----------------------------------------------------------------------------


HRESULT
CNtfsEnumSTATSTG::QueryInterface(
    REFIID  riid,
    void ** ppvObject
    )
{
    nffXTrace( "CNtfsEnumSTATSTG::QueryInterface" );
    HRESULT sc = S_OK;

    //  ----------
    //  Validation
    //  ----------

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----
    //  Query
    //  -----

    if( IID_IUnknown == riid || IID_IEnumSTATSTG == riid )
    {
        *ppvObject = static_cast<IEnumSTATSTG*>(this);
        AddRef();
    }
    else
    {
        *ppvObject = NULL;
        sc = E_NOINTERFACE;
    }

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
CNtfsEnumSTATSTG::AddRef(void)
{
    LONG lRet;

    lRet = InterlockedIncrement( &_cRefs );

    nffDebug(( DEB_REFCOUNT, "CNtfsEnumSTATSTG::AddRef(this==%x) == %d\n",
                                this, lRet));

    return( lRet );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Release (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
CNtfsEnumSTATSTG::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement( &_cRefs );

    nffAssert( 0 <= lRet );

    if( 0 == lRet )
        delete this;

    nffDebug((DEB_REFCOUNT, "CNtfsEnumSTATSTG::Release(this=%x) == %d\n",
                            this, lRet));


    return( lRet );

}



//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Next (IEnumSTATSTG)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsEnumSTATSTG::Next(ULONG celt, STATSTG *prgstatstg, ULONG *pcFetched)
{
    nffXTrace( "CNtfsEnumSTATSTG::Next" );
    HRESULT sc = S_OK;


    NFF_VALIDATE( Next(celt, prgstatstg, pcFetched ) );

    if( NULL != pcFetched )
        *pcFetched = 0;

    // Compatibility requires we return S_OK when 0 elements are requested.
    if( 0 == celt )
        return S_OK;

    _pBlockingLock->Lock( INFINITE );

    sc = _pstatstgarray->NextAt( _istatNextToRead, prgstatstg, &celt );
    if( FAILED(sc) ) goto Exit;

    _istatNextToRead += celt;

    if( NULL != pcFetched )
        *pcFetched = celt;

Exit:

    _pBlockingLock->Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Skip (IEnumSTATSTG)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsEnumSTATSTG::Skip(ULONG celt)
{
    nffXTrace( "CNtfsEnumSTATSTG::Skip" );
    HRESULT sc = S_OK;


    NFF_VALIDATE( Skip( celt ) );

    _pBlockingLock->Lock( INFINITE );

    // Advance the index, but not past the end of the array
    if( _istatNextToRead + celt > _pstatstgarray->GetCount() )
    {
        _istatNextToRead = _pstatstgarray->GetCount();
        sc = S_FALSE;
    }
    else
        _istatNextToRead += celt;

    _pBlockingLock->Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Reset (IEnumSTATSTG)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsEnumSTATSTG::Reset()
{
    nffXTrace( "CNtfsEnumSTATSTG::Reset" );
    _pBlockingLock->Lock( INFINITE );
    _istatNextToRead = 0;
    _pBlockingLock->Unlock();
    return( S_OK );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Clone (IEnumSTATSTG)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsEnumSTATSTG::Clone(IEnumSTATSTG **ppenum)
{
    nffXTrace( "CNtfsEnumSTATSTG::Clone" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( Clone( ppenum ) );

    _pBlockingLock->Lock( INFINITE );

    CNtfsEnumSTATSTG *pNtfsEnumSTATSTG = new CNtfsEnumSTATSTG(*this);
    if( NULL == pNtfsEnumSTATSTG )
    {
        sc = E_OUTOFMEMORY;
        goto Exit;
    }

    *ppenum = static_cast<IEnumSTATSTG*>(pNtfsEnumSTATSTG);
    pNtfsEnumSTATSTG = NULL;

Exit:

    _pBlockingLock->Unlock();

    if( NULL != pNtfsEnumSTATSTG )
        delete pNtfsEnumSTATSTG;

    return( sc );

}

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::ReadFileStreamInfo (private)
//
//  This method reads the FileStreamInformation from the ContentStream.  It
//  puts this buffer into a member pointer, for use in Next, etc.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsSTATSTGArray::ReadFileStreamInfo( HANDLE hFile )
{
    nffITrace( "CNtfsStorage::ReadFileStreamInfo" );

    PFILE_STREAM_INFORMATION    pStreamInfo=NULL;
    PFILE_STREAM_INFORMATION    pFSI=NULL;
    ULONG    cbBuffer=0;
    ULONG    cStreams=0;
    HRESULT  sc=S_OK;

    sc = EnumNtStreams( hFile, &pStreamInfo, &cbBuffer, TRUE );
    if( FAILED(sc) )
        return sc;

    for(pFSI=pStreamInfo ; NULL != pFSI; pFSI=NextFSI( pFSI ) )
        cStreams++;

    _pFileStreamInformation = pStreamInfo;
    _cFileStreamInformation = cStreams;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsSTATSTGArray::Init (Internal method)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsSTATSTGArray::Init( HANDLE hFile )
{
    nffITrace( "CNtfsSTATSTGArray::Init" );
    HRESULT hr = S_OK;

    DfpAssert( NULL != _pBlockingLock );
    _pBlockingLock->Lock( INFINITE );

    if( NULL != _pFileStreamInformation )
    {
        CoTaskMemFree( _pFileStreamInformation );
        _pFileStreamInformation = NULL;
        _cFileStreamInformation = 0;
    }

    // Snapshot the stream information in _pFileStreamInformation
    hr = ReadFileStreamInfo( hFile );
    if( FAILED(hr) ) goto Exit;

Exit:

    _pBlockingLock->Unlock();
    return( hr );

}

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsSTATSTGArray::NextAt
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsSTATSTGArray::NextAt( ULONG iNext, STATSTG *prgstatstg, ULONG *pcFetched )
{
    nffITrace( "CNtfsSTATSTGArray::NextAt" );
    HRESULT sc=S_OK;
    ULONG cFetched=0;
    ULONG cVisibleDataStreams=0;
    PFILE_STREAM_INFORMATION pFSI=NULL;
    const WCHAR* pwName=NULL;
    ULONG cbAlloc=0, cchLength=0;

    _pBlockingLock->Lock( INFINITE );

    // If there is nothing to do skip out early.
    if( iNext >= _cFileStreamInformation )
    {
        sc = S_FALSE;
        *pcFetched = 0;
        goto EH_Err;
    }

    // Loop through the cached stream info in _pFileStreamInformation

    for( pFSI=_pFileStreamInformation; NULL != pFSI; pFSI = NextFSI(pFSI) )
    {
        if( cFetched >= *pcFetched )
            break;                  // We are done.

        // We only handle data streams
        //
        if( !IsDataStream( pFSI ) )
            continue;

        // We hide some of the streams (like the Control Stream)
        //
        if( IsHiddenStream( pFSI ) )
        {
            continue;
        }

        // We are counting up to the requested streams.
        //
        if( iNext > cVisibleDataStreams++)
            continue;

        // Now lets unmangle the name no memory is allocated yet we just
        // move the pointer past the first ':' and return a shortened length.
        // Must be a $DATA Stream.  Also invent "CONTENTS" if necessary.
        // pwName is not null terminated.
        //
        GetNtfsUnmangledNameInfo(pFSI, &pwName, &cchLength);

        // Yes, this is a data stream that we need to return.

        // Allocate a buffer for the stream name in the statstg.  If this is
        // the unnamed stream, then we'll return it to the caller with the
        // name "Contents".

        cbAlloc = (cchLength + 1) * sizeof(WCHAR);

        //  Allocate memory, copy and null terminate the string from the FSI.
        //
        nffMem( prgstatstg[cFetched].pwcsName = (WCHAR*) CoTaskMemAlloc( cbAlloc ) );
        memcpy( prgstatstg[cFetched].pwcsName, pwName, cchLength*sizeof(WCHAR) );
        prgstatstg[cFetched].pwcsName[ cchLength ] = L'\0';


        // But Wait !!!
        // If this stream is really a non-simple property set, it's actually
        // a docfile, so let's return it as a STGTY_STORAGE, without the
        // name munging.

        if( IsDocfileStream( prgstatstg[cFetched].pwcsName ))
        {
            wcscpy( prgstatstg[cFetched].pwcsName,
                    UnmangleDocfileStreamName( prgstatstg[cFetched].pwcsName ));
            prgstatstg[cFetched].type = STGTY_STORAGE;
        }
        else
            prgstatstg[cFetched].type = STGTY_STREAM;

        // Fill in the rest of the stream information.
        prgstatstg[cFetched].cbSize.QuadPart = static_cast<ULONGLONG>(pFSI->StreamSize.QuadPart);

        // streams don't support timestamps yet
        prgstatstg[cFetched].mtime = prgstatstg[cFetched].ctime = prgstatstg[cFetched].atime = CFILETIME(0);
        prgstatstg[cFetched].grfMode = 0;
        prgstatstg[cFetched].grfLocksSupported = 0; // no locks supported 
        prgstatstg[cFetched].grfStateBits = 0;
        prgstatstg[cFetched].clsid = CLSID_NULL;
        prgstatstg[cFetched].reserved = 0;

        // Advance the index of the next index the caller wants retrieved
        iNext++;

        // Advance the count of entries read
        cFetched++;

    }

    //  ----
    //  Exit
    //  ----

    if( cFetched == *pcFetched )
        sc = S_OK;
    else
        sc = S_FALSE;

    *pcFetched = cFetched;

EH_Err:

    _pBlockingLock->Unlock();
    return( sc );

}

//+----------------------------------------------------------------------------
//
//  Routine     GetDriveLetter
//      Return the drive letter from a path, or '\' for UNC paths.
//
//+----------------------------------------------------------------------------


WCHAR GetDriveLetter (WCHAR const *pwcsName)
{
    nffITrace( "GetDriveLetter" );

    if( pwcsName == NULL )
        return( L'\0' );

    if( pwcsName[0] != L'\0' )
    {
        if( 0 == dfwcsnicmp( pwcsName, L"\\\\?\\", 4 )
            &&
            pwcsName[4] != L'\0' )
        {
            if( pwcsName[5] == L':' )
                return( pwcsName[4] );

            else if( 0 == dfwcsnicmp( pwcsName, L"\\\\?\\UNC\\", -1 ))
                return( L'\\' );

        }

        if( pwcsName[1] == L':'
            ||
            pwcsName[0] == L'\\' && pwcsName[1] == L'\\' )
        {
            return( pwcsName[0] );
        }

    }

   // No drive letter in pathname, get current drive instead

   WCHAR wcsPath[MAX_PATH];
   NTSTATUS nts = RtlGetCurrentDirectory_U (MAX_PATH*sizeof(WCHAR),wcsPath);
   if (NT_SUCCESS(nts))
       return( wcsPath[0] );


    return( L'\0' );
};




#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::UseNTFS4Streams( BOOL fUseNTFS4Streams )
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::GetFormatVersion(WORD *pw)
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::SimulateLowMemory( BOOL fSimulate )
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::GetLockCount()
{
    return( _pTreeMutex->GetLockCount() );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::IsDirty()
{
    return( E_NOTIMPL );
}
#endif // #if DBG


//+---------------------------------------------------------------------------
//
//  Function:   EnumNtStreams
//
//  Synopsis:   Enumerate NT stream information
//
//  Arguments:  [h] -- Handle to rename
//              [ppfsi] -- buffer to hold stream information
//              [pulBufferSize] -- size of output buffer
//              [fGrow] -- FALSE for fixed size buffer
//
//  Returns:    Appropriate status code
//
//  Notes   :
//
//  History:    1-Apr-98   HenryLee Created
//
//----------------------------------------------------------------------------

HRESULT EnumNtStreams (HANDLE h,
                       FILE_STREAM_INFORMATION ** ppfsi,
                       ULONG *pulBufferSize,
                       BOOL fGrow)
{
    HRESULT sc = S_OK;
    NTSTATUS nts;
    IO_STATUS_BLOCK iosb;

    nffAssert (pulBufferSize != NULL);
    ULONG ulStreamInfoSize = 2048;
    FILE_STREAM_INFORMATION *pfsi;

    *ppfsi = NULL;
    *pulBufferSize = 0;
    do
    {
        nffMem (pfsi = (FILE_STREAM_INFORMATION*) new BYTE[ulStreamInfoSize]);

        nts = NtQueryInformationFile(h,
                        &iosb,
                        (VOID*) pfsi,
                        ulStreamInfoSize - sizeof (L'\0'),
                        FileStreamInformation
                        );

        if ( !NT_SUCCESS(nts) )
        {
            //  We failed the call.  Free up the previous buffer and set up
            //  for another pass with a buffer twice as large

            delete [] (BYTE *)pfsi;
            pfsi = NULL;
            ulStreamInfoSize *= 2;
        }
        if (fGrow == FALSE)
            break;

    } while (nts == STATUS_BUFFER_OVERFLOW || nts == STATUS_BUFFER_TOO_SMALL);

    if (NT_SUCCESS(nts))
    {
        if (iosb.Information == 0)  // no data returned
        {
            delete [] (BYTE *) pfsi;
            *ppfsi = NULL;
            *pulBufferSize = 0;
        }
        else
        {
            *ppfsi = pfsi;
            *pulBufferSize = iosb.Status;
        }
    }
    else
    {
        sc = NtStatusToScode(nts);
    }
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindStreamInFSI
//
//  Synopsis:   Find a Stream name in a provided Enumeration Buffer
//
//  Arguments:  [ppfsi] -- buffer that holds the stream enumeration.
//              [pwszNtStreamName] -- Name to look for, in :*:$DATA form.
//
//  Returns:    Pointer to the found element, or NULL otherwise
//
//----------------------------------------------------------------------------

const FILE_STREAM_INFORMATION *
FindStreamInFSI( IN const FILE_STREAM_INFORMATION *pfsi,
                 IN const WCHAR *pwszNtStreamName  // In :*:$data format
                )
{
    ULONG cchLength = wcslen(pwszNtStreamName);

    for( ; NULL != pfsi; pfsi= NextFSI(pfsi) )
    {
        if( cchLength*sizeof(WCHAR) != pfsi->StreamNameLength )
            continue;

        if( 0 == dfwcsnicmp( pwszNtStreamName, pfsi->StreamName, cchLength ))
            break;
    }

    return( pfsi );

}

//+---------------------------------------------------------------------------
//
//  Function:   IsStreamPrefixInFSI
//
//  Synopsis:   Find a Stream with the given prefix in a provided
//              Enumeration Buffer
//
//  Arguments:  [ppfsi] -- buffer that holds the stream enumeration.
//              [pwszPrefix] -- Prefix to find.
//
//  Returns:    TRUE if it finds it, FALSE otherwise.
//
//----------------------------------------------------------------------------

BOOL
FindStreamPrefixInFSI( IN const FILE_STREAM_INFORMATION *pfsi,
                       IN const WCHAR *pwszPrefix
                     )
{
    ULONG cchLength = wcslen(pwszPrefix);

    for( ; NULL != pfsi; pfsi= NextFSI(pfsi) )
    {
        if( cchLength*sizeof(WCHAR) > pfsi->StreamNameLength )
            continue;

        if( 0 == dfwcsnicmp( pwszPrefix, pfsi->StreamName, cchLength ))
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\hntfsstm.cxx ===
//+============================================================================
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:   hntfsstg.cxx
//
//  This file provides the NFF (NTFS Flat File) IStream implementation.
//
//  History:
//      5/6/98  MikeHill
//              -   Use CoTaskMem rather than new/delete.
//
//+============================================================================

#include <pch.cxx>
#include <tstr.h>
#include "cli.hxx"
#include "expparam.hxx"

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

DECLARE_INFOLEVEL(nff)

#ifndef DEB_INFO
#define DEB_INFO  DEB_USER1
#endif


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
CNtfsStream::AddRef()
{
    LONG cRefs;

    cRefs = InterlockedIncrement( &_cRefs );

    nffDebug((DEB_REFCOUNT, "CNtfsStream::AddRef(this=%x) == %d\n",
                            this, cRefs));
    return cRefs;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Release (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
CNtfsStream::Release()
{
    ULONG ulRet = InterlockedDecrement( &_cRefs );

    if( 0 == ulRet )
    {
        RemoveSelfFromList();
        delete this;
    }
    nffDebug((DEB_REFCOUNT, "CNtfsStream::Release(this=%x) == %d\n",
                            this, ulRet));

    return( ulRet );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::QueryInterface(
        REFIID riid,
        void** ppv )
{
    HRESULT sc=S_OK;

#if DBG == 1
    WCHAR strIID[64];
    StringFromGUID2(riid, strIID, 64);
    nffDebug(( DEB_TRACE | DEB_REFCOUNT,
                "CNtfsStream::QueryInterface( %ws )\n", strIID ));
#endif

    NFF_VALIDATE( QueryInterface( riid, ppv ) );

    nffChk( CheckReverted() );

    if( IsEqualIID( riid, IID_IUnknown )
        ||
        IsEqualIID( riid, IID_IStream )
        ||
        IsEqualIID( riid, IID_ISequentialStream ) )
    {
        *ppv = static_cast<IStream*>(this);
        AddRef();
        return( S_OK );
    }
    else if( IsEqualIID( riid, IID_IMappedStream ))
    {
        *ppv = static_cast<IMappedStream*>(&_nffMappedStream);
        AddRef();
        return( S_OK );
    }
    else if( IsEqualIID( riid, IID_ILockBytes ))
    {
        *ppv = static_cast<ILockBytes*>(this);
        AddRef();
        return( S_OK );
    }
#if DBG == 1
    else if( IsEqualIID( riid, IID_IStorageTest ))
    {
        *ppv = static_cast<IStorageTest*>(this);
        AddRef();
        return( S_OK );
    }
#endif // #if DBG
    else
    {
        nffDebug(( DEB_TRACE | DEB_REFCOUNT,
                    "CNtfsStream::QueryInterface() Failed E_NOINTERFACE\n" ));
        return( E_NOINTERFACE );
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Seek (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *puliNewPos)
{
    HRESULT sc = S_OK;
    LARGE_INTEGER liFileSize;
    LARGE_INTEGER liNewPos;

    nffDebug(( DEB_TRACE, "CNtfsStream::Seek( %x:%08x, %d, %p );\n",
                                dlibMove.HighPart, dlibMove.LowPart,
                                dwOrigin, puliNewPos ));

    NFF_VALIDATE( Seek( dlibMove, dwOrigin, puliNewPos ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    switch( dwOrigin )
    {
    case STREAM_SEEK_SET:
        liNewPos.QuadPart = dlibMove.QuadPart;
        break;

    case STREAM_SEEK_CUR:
        liNewPos.QuadPart = _liCurrentSeekPosition.QuadPart + dlibMove.QuadPart;
        break;

    case STREAM_SEEK_END:
        liFileSize.LowPart = GetFileSize( _hFile,
                                         (ULONG*)(&liFileSize.HighPart) );

        if( 0xFFFFFFFF == liFileSize.LowPart && NO_ERROR != GetLastError() )
        {
            nffChk( HRESULT_FROM_WIN32( GetLastError() ) );
        }

        liNewPos.QuadPart = liFileSize.QuadPart + dlibMove.QuadPart;
        break;

    default:
        nffChk(STG_E_INVALIDPARAMETER);
        break;
    }

    // Compatibility with Docfile.  Seeking < 0 fails.
    if( liNewPos.QuadPart < 0 )
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    _liCurrentSeekPosition = liNewPos;


    // If desired, give the caller the now-current seek position.
    if( NULL != puliNewPos )
        *puliNewPos = _liCurrentSeekPosition;

EH_Err:
    Unlock();
    return( sc );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::SetSize (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::SetSize(
        ULARGE_INTEGER uliNewSize)
{
    HRESULT sc = S_OK;
    CLargeInteger liEOF;

    if ( uliNewSize.HighPart != 0 )
        nffErr(EH_Err, STG_E_INVALIDFUNCTION);

    nffDebug(( DEB_ITRACE | DEB_INFO | DEB_WRITE,
             "CNtfsStream::SetSize(%x:%x) hdl=%x, stream='%ws'\n",
             uliNewSize.QuadPart,
             _hFile,
             _pwcsName ));

    NFF_VALIDATE( SetSize( uliNewSize ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // If this stream is mapped, set the size accordingly

    if( _nffMappedStream.IsMapped() )
    {
        _nffMappedStream.SetSize( uliNewSize.LowPart, TRUE, NULL, &sc );
    }
    else
    {
        sc = SetFileSize( CULargeInteger(uliNewSize) );
    }

    if( !FAILED(sc) )
        sc = S_OK;

EH_Err:

    Unlock();
    return( sc);

}

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::CopyTo (IStream)
//
//  There's no way of knowing what the IStream is to which we're copying, so
//  we have to assume that we might be copying to ourself.  And given that
//  assumption, we have to deal with the case that this is an overlapping
//  copy (e.g., "copy 10 bytes from offset 0 to offset 5").
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::CopyTo(
        IStream *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten)
{
    nffXTrace( "CNtfsStream::CopyTo" );

    HRESULT sc = S_OK;
    PVOID pv = NULL;
    ULONG cbRead = 0, cbWritten = 0;
    CULargeInteger cbReadTotal = 0, cbWrittenTotal = 0;
    CLargeInteger liZero = 0;
    CULargeInteger uliOriginalSourcePosition, uliOriginalDestPosition;
    CULargeInteger cbSourceSize, cbDestSize;
    ULONG cbPerCopy = 0;
    STATSTG statstg;
    CULargeInteger cbRequested = cb;
    BOOL fCopyForward;

    NFF_VALIDATE( CopyTo( pstm, cb, pcbRead, pcbWritten ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if( NULL == pstm)
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Determine how much we'll copy at a time.
    // As of this writing, STREAMBUFFERSIZE is 8192 bytes

    if( cbRequested > STREAMBUFFERSIZE )
        cbPerCopy = STREAMBUFFERSIZE;
    else
        cbPerCopy = cbRequested.LowPart;

    //  ------------------------------------------------------------------
    //  Get the current stream sizes/positions, and adjust the destination
    //  size if necessary
    //  ------------------------------------------------------------------

    nffChk( this->Seek( liZero, STREAM_SEEK_CUR, &uliOriginalSourcePosition ) );

    nffChk( pstm->Seek( liZero, STREAM_SEEK_CUR, &uliOriginalDestPosition ) );

    nffChk( this->Stat( &statstg, STATFLAG_NONAME ) );

    cbSourceSize = statstg.cbSize;

    nffChk( pstm->Stat( &statstg, STATFLAG_NONAME ) );

    cbDestSize = statstg.cbSize;

    // Ensure the sizes are valid (we can't handle anything with the high bit
    // set, because Seek takes a signed offset).

    if( static_cast<CLargeInteger>(cbSourceSize) < 0
        ||
        static_cast<CLargeInteger>(cbDestSize) < 0 )
    {
        nffErr( EH_Err, STG_E_INVALIDHEADER );
    }

    // Don't copy more than the source stream has available
    if( cbRequested > cbSourceSize - uliOriginalSourcePosition )
        cbRequested = cbSourceSize - uliOriginalSourcePosition;

    // If necessary, grow the destination stream.

    if( cbSourceSize - uliOriginalSourcePosition > cbDestSize - uliOriginalDestPosition )
    {
        cbDestSize = cbSourceSize - uliOriginalSourcePosition + uliOriginalDestPosition;
        nffChk( pstm->SetSize( cbDestSize ) );
    }

    //  ----------------------
    //  Allocate a copy buffer
    //  ----------------------

    nffMem( pv = CoTaskMemAlloc( cbPerCopy ) );

    //  -----------------------------------------------------------------------------
    //  Determine if we're copying forwards (high seek position to low) or backwards.
    //  -----------------------------------------------------------------------------

    fCopyForward = TRUE;
    if( uliOriginalSourcePosition < uliOriginalDestPosition )
    {
        // E.g., say we're copying 15 bytes from offset 0 to offset 5,
        // and we're only able to copy 10 bytes at a time.
        // If we copy bytes 0-9 to offset 5, we'll end up overwriting
        // bytes 10-14, and be unable to complete the copy.
        // So instead, we'll copy bytes 5-14 to offset 10, and finish
        // up by copying bytes 0-4 to offset 5.

        fCopyForward = FALSE;

        // To do this kind of backwards copy, we need to start by seeking
        // towards the end of the stream.

        CULargeInteger uliNewSourcePosition, uliNewDestPosition;

        uliNewSourcePosition = cbSourceSize - cbPerCopy;
        nffChk( this->Seek( uliNewSourcePosition, STREAM_SEEK_SET, NULL ) );

        uliNewDestPosition = cbDestSize - cbPerCopy;
        nffChk( pstm->Seek( uliNewDestPosition, STREAM_SEEK_SET, NULL ) );

    }

    //  --------------
    //  Copy in chunks
    //  --------------

    cbPerCopy = cbRequested > cbPerCopy ? cbPerCopy : cbRequested.LowPart;
    while( cbRequested > 0 )
    {
        // Read from the source
        nffChk( this->Read( pv, cbPerCopy, &cbRead ) );

        if( cbRead != cbPerCopy )
            nffErr(EH_Err, STG_E_READFAULT);

        cbReadTotal += cbRead;

        // Write to the dest
        nffChk( pstm->Write( pv, cbPerCopy, &cbWritten ) );

        if( cbWritten != cbPerCopy )
            nffErr( EH_Err, STG_E_WRITEFAULT );

        cbWrittenTotal += cbWritten;

        // Adjust the amount remaining to be copied
        cbRequested -= cbPerCopy;


        // Determine how much to copy in the next iteration (this will
        // always be cbPerCopy until the last iteration).  If copying
        // backwards, we need to manually adjust the seek pointer.

        cbPerCopy = (cbRequested > cbPerCopy) ? cbPerCopy : cbRequested.LowPart;
        if( !fCopyForward )
        {
            nffChk( this->Seek( -static_cast<CLargeInteger>(cbPerCopy),
                                                STREAM_SEEK_CUR, NULL ) );

            nffChk( pstm->Seek( -static_cast<CLargeInteger>(cbPerCopy),
                                                STREAM_SEEK_CUR, NULL ) );
        }

    }

    // If we were backward-copying, adjust the seek pointers
    // as if we had forward-copied

    if( !fCopyForward )
    {
        uliOriginalSourcePosition += cbReadTotal;
        nffChk( this->Seek( uliOriginalSourcePosition, STREAM_SEEK_SET, NULL ) );

        uliOriginalDestPosition += cbWrittenTotal;
        nffChk( pstm->Seek( uliOriginalDestPosition, STREAM_SEEK_SET, NULL ) );
    }

    //  ----
    //  Exit
    //  ----

    if( NULL != pcbRead )
        *pcbRead = cbReadTotal;
    if( NULL != pcbWritten )
        *pcbWritten = cbWrittenTotal;

EH_Err:

    if( NULL != pv )
        CoTaskMemFree(pv);

    Unlock();
    return(sc);

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Commit (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Commit( DWORD grfCommitFlags )
{
    nffXTrace( "CNtfsStream::Commit" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( Commit( grfCommitFlags ) );
    if(~(STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE|STGC_DEFAULT) & grfCommitFlags)
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    Lock( INFINITE );

    nffChkTo ( EH_Unlock, CheckReverted() );

    if( !(STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE  & grfCommitFlags) )
    {
        if( !FlushFileBuffers( _hFile ))
            sc = LAST_SCODE;
    }

EH_Unlock:
    Unlock();
EH_Err:
    return sc;

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Revert (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Revert(void)
{
    nffXTrace( "CNtfsStream::Revert" );
    // We only support direct-mode.

    return CheckReverted();
}



//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::LockRegion (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    nffXTrace( "CNtfsStream::LockRegion" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( LockRegion( libOffset, cb, dwLockType ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );


    if( !LockFile( _hFile, libOffset.LowPart, libOffset.HighPart,
                   cb.LowPart, cb.HighPart))
    {
        nffErr( EH_Err, LAST_SCODE );
    }

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::UnlockRegion (ILockBytes)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    nffXTrace( "CNtfsStream::UnlockRegion" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( UnlockRegion( libOffset, cb, dwLockType ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );
    }

    if( !UnlockFile(_hFile, libOffset.LowPart, libOffset.HighPart,
                    cb.LowPart, cb.HighPart))
    {
        nffErr( EH_Err, LAST_SCODE );
    }

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Stat (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Stat(
        STATSTG *pstatstg,
        DWORD grfStatFlag)
{
    nffXTrace( "CNtfsStream::Stat" );
    STATSTG statstg;
    HRESULT sc = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    FILE_ACCESS_INFORMATION file_access_information;
    IO_STATUS_BLOCK IoStatusBlock;

    BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;

    NFF_VALIDATE( Stat( pstatstg, grfStatFlag ) );

    Lock( INFINITE );

    nffChkTo ( EH_Lock, CheckReverted() );

    ZeroMemory((void*)&statstg, sizeof(STATSTG));

    // Get the name, if desired

    if( (STATFLAG_NONAME & grfStatFlag) )
        statstg.pwcsName = NULL;
    else
    {
        nffAssert( NULL != _pwcsName );

        nffMem( statstg.pwcsName = reinterpret_cast<WCHAR*>
                                   ( CoTaskMemAlloc( sizeof(WCHAR)*(wcslen(_pwcsName) + 1) )));
        wcscpy( statstg.pwcsName, _pwcsName );
    }

    // Get the type
    statstg.type = STGTY_STREAM;

    statstg.grfLocksSupported = LOCK_EXCLUSIVE | LOCK_ONLYONCE;

    // Get the size & times.

    if( !GetFileInformationByHandle( _hFile, &ByHandleFileInformation ))
        nffErr( EH_Err, LAST_SCODE );

    statstg.cbSize.LowPart = ByHandleFileInformation.nFileSizeLow;
    statstg.cbSize.HighPart = ByHandleFileInformation.nFileSizeHigh;

    // We get a time back in ByHandleFileInformation, but it's the file's times,
    // not the streams times.  So really the stream times are not supported, and
    // we'll just set them to zero.

    statstg.mtime = statstg.atime = statstg.ctime = CFILETIME(0);

    // Get the STGM modes
    statstg.grfMode = _grfMode & ~STGM_CREATE;

    *pstatstg = statstg;

EH_Err:
    if( FAILED(sc) && NULL != statstg.pwcsName )
        CoTaskMemFree( statstg.pwcsName );

EH_Lock:
    Unlock();
    return( sc );

}



//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Clone (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Clone(
        IStream** ppstm)
{
    nffXTrace( "CNtfsStream::Clone" );
    return( E_NOTIMPL );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Read (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Read(
        void* pv,
        ULONG cb,
        ULONG* pcbRead)
{
    nffXTrace( "CNtfsStream::Read" );
    HRESULT sc = S_OK;
    ULONG cbRead = 0;

    nffDebug(( DEB_ITRACE, "Read( pv=0x%x, cb=0x%x );\n", pv, cb ));

    NFF_VALIDATE( Read( pv, cb, pcbRead ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    nffChk( ReadAt( _liCurrentSeekPosition, pv, cb, &cbRead ) );

    _liCurrentSeekPosition += cbRead;
    nffDebug(( DEB_ITRACE, "Read() read %x bytes.\n", cbRead ));
    if( NULL != pcbRead )
        *pcbRead = cbRead;

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::ReadAt (ILockBytes)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::ReadAt(
       ULARGE_INTEGER ulOffset,
       void* pv,
       ULONG cb,
       ULONG* pcbRead)
{
    nffXTrace( "CNtfsStream::ReadAt" );
    HRESULT sc = S_OK;

    nffDebug(( DEB_ITRACE, "ReadAt( off=%x:%x, pv=0x%x, cb=0x%x );\n",
                        ulOffset, pv, cb ));

    NFF_VALIDATE( ReadAt( ulOffset, pv, cb, pcbRead ) );

    if( static_cast<LONG>(ulOffset.HighPart) < 0 )
        return TYPE_E_SIZETOOBIG;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // Is this stream mapped?
    if( _nffMappedStream.IsMapped() )
    {
        // This stream is mapped.  We'll read directly from the mapping buffer.
        _nffMappedStream.Read( pv, _liCurrentSeekPosition.LowPart, &cb );

        if( NULL != pcbRead )
            *pcbRead = cb;
    }
    else
    {
        // No, just read from the file.

        nffChk( SyncReadAtFile( ulOffset, pv, cb, pcbRead ) );
    }

    nffDebug(( DEB_ITRACE, "ReadAt() read %x bytes.\n", *pcbRead ));


EH_Err:
    Unlock();
    return( sc );
}




//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Write (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Write(
        const void* pv,
        ULONG cb,
        ULONG* pcbWritten)
{
    nffXTrace( "CNtfsStream::Write" );
    HRESULT sc = S_OK;
    ULONG cbWritten = 0;

    nffDebug(( DEB_ITRACE, "Write( pv=0x%x, cb=0x%x );\n", pv, cb ));

    NFF_VALIDATE( Write( pv, cb, pcbWritten ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    nffChk(WriteAt( _liCurrentSeekPosition, pv, cb, &cbWritten ));

    _liCurrentSeekPosition += cbWritten;

    nffDebug(( DEB_ITRACE, "Write() wrote %x bytes.\n", cbWritten ));

    if( NULL != pcbWritten )
        *pcbWritten = cbWritten;

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::WriteAt (ILockBytes)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::WriteAt(
     ULARGE_INTEGER ulOffset,
     const void* pv,
     ULONG cb,
     ULONG* pcbWritten)
{
    nffXTrace( "CNtfsStream::WriteAt" );
    HRESULT sc = S_OK;

    nffDebug(( DEB_ITRACE, "WriteAt( off=%x:%x, pv=0x%x, cb=0x%x );\n",
                        ulOffset, pv, cb ));

    NFF_VALIDATE( WriteAt( ulOffset, pv, cb, pcbWritten ) );

    if( ((LONG)(ulOffset.HighPart)) < 0 )
        return( TYPE_E_SIZETOOBIG );


    Lock( INFINITE );

    nffChk( CheckReverted() );

    // Is this stream mapped?
    if( _nffMappedStream.IsMapped() )
    {
        // This stream is mapped, we'll take the Write to the mapping.

        ULONG iPosition = _nffMappedStream.SizeOfMapping() - _liCurrentSeekPosition.LowPart;

        if( cb > iPosition )
        {
            _nffMappedStream.SetSize( iPosition + cb, TRUE, NULL, &sc );
            nffChk(sc);
        }

        _nffMappedStream.Write( pv, _liCurrentSeekPosition.LowPart, &cb );

        if( NULL != pcbWritten )
            *pcbWritten = cb;
    }
    else
    {
        // No, just write to the file.

        nffChk( SyncWriteAtFile( ulOffset, pv, cb, pcbWritten ) );
    }

    nffDebug(( DEB_ITRACE, "WriteAt() wrote %x bytes.\n", *pcbWritten ));


EH_Err:

    Unlock();
    return( sc );

}



//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Flush (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Flush()
{
    HRESULT sc = S_OK;

    Lock( INFINITE );
    nffChk( CheckReverted() );

    _nffMappedStream.Flush(&sc);

EH_Err:
    Unlock();
    return(sc);

}


//+-------------------------------------------------------------------
//
//  Member:     CNtfsStream  Constructor
//
//--------------------------------------------------------------------

CNtfsStream::CNtfsStream( CNtfsStorage *pnffstg,
                          IBlockingLock *pBlockingLock )
#pragma warning(disable: 4355)
                : _nffMappedStream( this ),
#pragma warning(default: 4355)
                  _pnffstg( pnffstg )
{
    nffXTrace( "CNtfsStream::CNtfsStream" );
    nffDebug(( DEB_REFCOUNT, "new CNtfsStream Constructed with cRefs=1\n" ));

    _sig = NTFSSTREAM_SIG;
    _cRefs = 1;
    _grfMode = 0;
    _hFile = INVALID_HANDLE_VALUE;
    _liCurrentSeekPosition = 0;
    _pnffstmNext = NULL;
    _pnffstmPrev = NULL;
    _pwcsName = NULL;

    nffAssert( NULL != pBlockingLock );
    _pBlockingLock = pBlockingLock;
    _pBlockingLock->AddRef();

    _ovlp.Internal = _ovlp.InternalHigh = 0;
    _ovlp.Offset = _ovlp.OffsetHigh = 0;
    _ovlp.hEvent = NULL;

}


//+-------------------------------------------------------------------
//
//  Member:     CNtfsStream  Destructor
//
//--------------------------------------------------------------------

CNtfsStream::~CNtfsStream()
{

    nffXTrace( "CNtfsStream::~CNtfsStream" );
    nffDebug(( DEB_INFO, "CNtfsStream: Close 0x%x.\n", _hFile ));

    // Shut down the mapped stream
    _nffMappedStream.ShutDown();

    // Close the file
    if( INVALID_HANDLE_VALUE != _hFile )
        NtClose( _hFile );

    if( NULL != _ovlp.hEvent )
        CloseHandle( _ovlp.hEvent );

    if( NULL != _pwcsName )
        CoTaskMemFree( _pwcsName );

    // Release the object that provides access to the tree lock.
    nffAssert( NULL != _pBlockingLock );
    _pBlockingLock->Release();

    _sig = NTFSSTREAM_SIGDEL;
}


//+-------------------------------------------------------------------
//
//  Member:     CNtfsStream::Init
//
//--------------------------------------------------------------------

HRESULT
CNtfsStream::Init(
        HANDLE hFile,               // File handle of this NTFS Stream.
        DWORD grfMode,              // Open Modes
        const OLECHAR * pwcsName,   // Name of the Stream
        CNtfsStream *pnffstm)       // Previously Open NTFS Stream (list)
{
    HRESULT sc=S_OK;
    HANDLE ev;

    nffITrace( "CNtfsStream::Init" );

    // We now own this file handle, and are responsible for closing it.
    _hFile = hFile;

    // Save the STGM_ flags so we can return them in a Stat call.
    _grfMode = grfMode;

    // Save the stream name

    if( NULL != _pwcsName )
    {
        CoTaskMemFree( _pwcsName );
        _pwcsName = NULL;
    }

    if( NULL != pwcsName )
    {
        nffMem( _pwcsName = reinterpret_cast<WCHAR*>
                            ( CoTaskMemAlloc( sizeof(WCHAR)*(wcslen(pwcsName) + 1) )));
        wcscpy( _pwcsName, pwcsName );
    }

    // All the streams live on a list held by the root Storage.
    if(NULL != pnffstm)
        InsertSelfIntoList(pnffstm);

    if( NULL == _ovlp.hEvent )
    {
        ev = CreateEvent(NULL,      // Security Attributes.
                         TRUE,      // Manual Reset, Flag.
                         FALSE,     // Initial State = Signaled, Flag.
                         NULL);     // Object Name.

        if( NULL == ev)
            nffChk( LAST_SCODE );

        _ovlp.hEvent = ev;
    }

    nffChk( _nffMappedStream.Init( _hFile ));

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStream    Non-Interface::ShutDown
//
//  Flush data, Close File handle and mark the object as reverted.
//  This is called when the Storage is released and when the Oplock Breaks.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::ShutDown()
{
    nffITrace( "CNtfsStream::ShutDown" );
    HRESULT sc=S_OK;

    if( INVALID_HANDLE_VALUE == _hFile )
        return S_OK;

    nffDebug(( DEB_INFO, "CNtfsStream::ShutDown(%x)\n", _hFile ));

    //
    // Shut down the mapped stream
    //
    _nffMappedStream.ShutDown();

    //
    // Close the file/stream handle and mark the IStream object as
    // Reverted by giving the file handle an invalid value.
    //
    CloseHandle(_hFile);
    _hFile = INVALID_HANDLE_VALUE;

    // We don't need the parent CNtfsStorage any longer, and more importantly it could
    // be going away.
    _pnffstg = NULL;

    //
    // Remove IStream object from the Storage's list
    //
    RemoveSelfFromList();

    return S_OK;
}




//+----------------------------------------------------------------------------
//
//  CNtfsStream Non-Interface::Rename
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Rename(
        const WCHAR *pwcsName,
        BOOL fOverWrite )
{
    IO_STATUS_BLOCK io_status_block;
    PFILE_RENAME_INFORMATION pFileRenInfo=NULL;     // _alloca()'ed
    NTSTATUS status;

    CNtfsStreamName nsnName = pwcsName;     // Convert to ":name:$DATA"

    LONG cbBufSize=0;
    HRESULT sc=S_OK;


    nffDebug(( DEB_INFO | DEB_WRITE, "CNtfsStream::Rename(%ws -> %ws)\n",
               _pwcsName, pwcsName ));

    Lock( INFINITE );
    nffChk( CheckReverted() );

    // Size and allocate a FILE_RENAME_INFOMATION buffer.  The size argument
    // to NtSetInformationFile must be correct, so subtract 1 WCHAR for the
    // FileName[1] in the struct we are not using.
    //
    cbBufSize  = sizeof(FILE_RENAME_INFORMATION) - sizeof(WCHAR);
    cbBufSize += nsnName.Count() * sizeof(WCHAR);
    pFileRenInfo = (PFILE_RENAME_INFORMATION) _alloca( cbBufSize );

    // Load the FILE_RENAME_INFORMATION structure

    pFileRenInfo->ReplaceIfExists = (BOOLEAN) fOverWrite;
    pFileRenInfo->RootDirectory = NULL;
    pFileRenInfo->FileNameLength = nsnName.Count() * sizeof(WCHAR);
    wcscpy( pFileRenInfo->FileName, (const WCHAR*)nsnName );

    // Rename the stream

    status = NtSetInformationFile( _hFile,
                                   &io_status_block,
                                   pFileRenInfo,
                                   cbBufSize,
                                   FileRenameInformation );
    if( !NT_SUCCESS(status) )
    {
        nffChk( sc = NtStatusToScode(status) );
    }

    // Discard the old name and Save the new name

    CoTaskMemFree( _pwcsName );

    // reuse cbBufSize
    cbBufSize = sizeof(WCHAR)  * (wcslen(pwcsName)+1);

    nffMem( _pwcsName = (WCHAR*) CoTaskMemAlloc( cbBufSize ));
    wcscpy( _pwcsName, pwcsName );

    sc = S_OK;

EH_Err:

    Unlock();
    return( sc );

}



//+----------------------------------------------------------------------------
//
//  CNtfsStream Non-Interface::Delete
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Delete()
{
    HRESULT sc=S_OK;

    nffDebug(( DEB_INFO | DEB_WRITE, "Delete(stm=%ws)\n", _pwcsName ));

    nffChk( CheckReverted() );

    if( IsWriteable() )
        nffChk( DeleteStream( &_hFile ));

EH_Err:

    return( sc );

}



//+----------------------------------------------------------------------------
//
//  CNtfsStream Non-Interface::DeleteStream
//
//  This method is static so that it can be called globally.
//
//+----------------------------------------------------------------------------

HRESULT // static
CNtfsStream::DeleteStream( HANDLE *phStream )
{
    HRESULT sc=S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    FILE_DISPOSITION_INFORMATION Disposition;
    IO_STATUS_BLOCK IoStatusBlock;

    // Execute the following statement:
    //    Disposition.DeleteFile = TRUE;
    // We can't actually write the code that way, because "DeleteFile" is #defined to
    // "DeleteFileW".

    nffDebug(( DEB_INFO | DEB_WRITE, "DeleteStream(hdl=%x)\n", *phStream ));

    *reinterpret_cast<BOOLEAN*>(&Disposition) = TRUE;
    DfpAssert( sizeof(Disposition) == sizeof(BOOLEAN) );

    // Mark the file for delete on close
    // Note that if this is the Contents stream we can delete it successfully,
    // but NTFS actually just truncates it to zero length.

    status = NtSetInformationFile(
                  *phStream,
                  &IoStatusBlock,
                  &Disposition,
                  sizeof(Disposition),
                  FileDispositionInformation
                  );
    if( !NT_SUCCESS(status) )
    {
        nffErr( EH_Err, NtStatusToScode(status) );
    }

    NtClose( *phStream );
    *phStream = INVALID_HANDLE_VALUE;

EH_Err:

    return( sc );

}

//+----------------------------------------------------------------------------
//
//  CNtfsStream::SetFileSize (private, non-interface method)
//
//  Set the size of the _hFile.  This is used by the IStream & IMappedStream
//  SetSize methods
//
//+----------------------------------------------------------------------------

HRESULT // private
CNtfsStream::SetFileSize( const CULargeInteger &uliNewSize )
{
    nffITrace( "CNtfsStream::SetFileSize" );
    HRESULT sc = S_OK;
    CLargeInteger liEOF;

    // We have to convert uliNewSize into a LARGE_INTEGER, so ensure that it can
    // be cast without loss of data.

    liEOF = static_cast<CLargeInteger>(uliNewSize);
    if( liEOF < 0 )
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Move to what will be the new end-of-file position.

    liEOF.LowPart = SetFilePointer( _hFile, liEOF.LowPart,
                                    &liEOF.HighPart, FILE_BEGIN );
    if( 0xFFFFFFFF == liEOF.LowPart && NO_ERROR != GetLastError() )
        nffErr( EH_Err, LAST_SCODE );

    // Set this as the new eof

    if( !SetEndOfFile( _hFile ))
        nffErr( EH_Err, LAST_SCODE );

EH_Err:

    return( sc );

}


//+-------------------------------------------------------------------
//
//  Member:     CNtfsStream::InsertSelfIntoList/RemoveSelfFromList
//
//--------------------------------------------------------------------

// We are passed a "current" element of a doubly linked list.
// Insert "this" right after the given List element.
//
VOID
CNtfsStream::InsertSelfIntoList(CNtfsStream *pnffstmCurrent)
{
    nffDebug(( DEB_ITRACE, "CNtfsStream::InsertSelfIntoList this=%x\n", this ));

    // If we're already in the list, or there is no list, then we're done.
    if( NULL != _pnffstmNext || NULL == pnffstmCurrent )
        return;

    // "this" point back to the current element
    // and points forward to current's next element
    _pnffstmPrev = pnffstmCurrent;
    _pnffstmNext = pnffstmCurrent->_pnffstmNext;

    // the current element now points forward to "this"
    // and if the next is not NULL it points back at this.
    pnffstmCurrent->_pnffstmNext = this;
    if(NULL != _pnffstmNext)
        _pnffstmNext->_pnffstmPrev = this;
}

VOID
CNtfsStream::RemoveSelfFromList()
{
    nffDebug(( DEB_ITRACE, "CNtfsStream::RemoveSelfFromList this=%x\n", this ));
    // My next element's previous pointer is given my previous pointer.
    if(NULL != _pnffstmNext)
        _pnffstmNext->_pnffstmPrev = _pnffstmPrev;

    // My previous element's next pointer is given my next pointer.
    if(NULL != _pnffstmPrev)
        _pnffstmPrev->_pnffstmNext = _pnffstmNext;

    _pnffstmNext = NULL;
    _pnffstmPrev = NULL;
}


//+-------------------------------------------------------------------
//
//  CNtfsStream     Non-Interface::SyncReadAtFile
//
//  Synopsis:       Provide synchronous IO for a file handle open in
//                  asynchronous mode.
//
//--------------------------------------------------------------------

HRESULT
CNtfsStream::SyncReadAtFile(
        ULARGE_INTEGER ulOffset,
        PVOID  pv,
        ULONG  cb,
        PULONG pcbRead)
{
    HRESULT sc=S_OK;
    LONG err=ERROR_SUCCESS;
    //
    // We use the single OVERLAPPED structure in the object.
    // This saves us from creating an Event everytime.  We
    // require the TreeMutex will keep us single threaded.
    //
    _ovlp.Offset = ulOffset.LowPart;
    _ovlp.OffsetHigh = ulOffset.HighPart;

    nffDebug(( DEB_ITRACE | DEB_INFO | DEB_READ,
             "SyncReadAtFile(_hFile=0x%x off=%x:%x, pv=0x%x, cb=0x%x )"
             " stream='%ws'\n",
             _hFile, ulOffset.HighPart, ulOffset.LowPart,
             pv, cb, _pwcsName ));

    if( !ReadFile( _hFile, pv, cb, pcbRead, &_ovlp ) )
    {
        err = GetLastError();

        if( ERROR_IO_PENDING == err )
        {
            // Only wait if ReadFile errored and returned ERROR_IO_PENDING.
            // In that case clear "err" and continue.
            //
            err = ERROR_SUCCESS;
            if( !GetOverlappedResult( _hFile, &_ovlp, pcbRead, TRUE) )
            {
                err = GetLastError();
            }
        }
    }

    if(ERROR_SUCCESS != err && ERROR_HANDLE_EOF != err)
        nffChk( HRESULT_FROM_WIN32( err ) );

    nffDebug(( DEB_INFO, "SyncReadAtFile() read 0x%x bytes.\n", *pcbRead ));

EH_Err:
    return sc;
}


//+-------------------------------------------------------------------
//
//  CNtfsStream     Non-Interface::SyncWriteAtFile
//
//  Synopsis:       Provide synchronous IO for a file handle open in
//                  asynchronous mode.
//
//--------------------------------------------------------------------

HRESULT
CNtfsStream::SyncWriteAtFile(
        ULARGE_INTEGER ulOffset,
        const void *pv,
        ULONG cb,
        PULONG pcbWritten)
{
    HRESULT sc=S_OK;
    //
    // We use the single OVERLAPPED structure in the object.
    // We require the TreeMutex will keep us single threaded.
    //
    _ovlp.Offset = ulOffset.LowPart;
    _ovlp.OffsetHigh = ulOffset.HighPart;

    nffDebug(( DEB_ITRACE | DEB_INFO | DEB_WRITE,
             "SyncWriteAtFile(_hFile=0x%x, off=%x:%x, pv=0x%x, cb=0x%x );"
             " stream='%ws'\n",
             _hFile, ulOffset.HighPart, ulOffset.LowPart,
             pv, cb, _pwcsName ));

    //
    // We expect either OK or FALSE/ERROR_IO_PENDING.
    //
    if( !WriteFile( _hFile, pv, cb, pcbWritten, &_ovlp ) )
    {
        if( ERROR_IO_PENDING != GetLastError() )
            nffChk( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if( !GetOverlappedResult( _hFile, &_ovlp, pcbWritten, TRUE) )
        nffChk( HRESULT_FROM_WIN32( GetLastError() ) );

    nffDebug(( DEB_ITRACE | DEB_INFO,
             "SyncWriteAtFile() wrote 0x%x bytes.\n", *pcbWritten ));

EH_Err:
    return sc;
}

//+----------------------------------------------------------------------------
//
//  CNtfsStream    Non-Interface::MarkStreamAux
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::MarkStreamAux( const MARK_HANDLE_INFO& mhi )
{
    nffDebug(( DEB_INFO | DEB_STATCTRL | DEB_ITRACE,
               "MarkStreamAux() hdl=%x, stream='%ws'\n", _hFile, _pwcsName ));

    return MarkFileHandleAux( _hFile, mhi );
}

//+----------------------------------------------------------------------------
//
//  CNtfsStream    Static Non-Interface::MarkFileHandleAux
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::MarkFileHandleAux(
        HANDLE hFile,
        const MARK_HANDLE_INFO& mhi )
{
    nffITrace( "CNtfsStream::MarkStreamAux" );

    HRESULT sc=S_OK;
    ULONG cbReturned;

    if( INVALID_HANDLE_VALUE == hFile )
    {
        nffDebug(( DEB_IWARN, "CNtfsStream::MarkStreamAux on hFile == -1\n" ));
        return S_OK;
    }

    nffAssert( USN_SOURCE_AUXILIARY_DATA == mhi.UsnSourceInfo);

    nffDebug(( DEB_STATCTRL | DEB_ITRACE,
               "MarkFileHandleAux hdl=%x\n", hFile ));

    nffBool( DeviceIoControl( hFile,
                              FSCTL_MARK_HANDLE,
                              (void*)&mhi, sizeof(mhi),
                              NULL, 0,
                              &cbReturned,
                              NULL ) );
EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStream    Non-Interface::SetStreamTime
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::SetStreamTime( const FILETIME* pctime,
                            const FILETIME* patime,
                            const FILETIME* pmtime)
{
    nffDebug((DEB_INFO | DEB_STATCTRL | DEB_ITRACE,
              "SetStreamTime() hdl=%x, stream='%ws'\n",
              _hFile, _pwcsName ));

    return SetFileHandleTime( _hFile, pctime, patime, pmtime );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStream    Static Non-Interface::SetFileHandleTime
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::SetFileHandleTime( HANDLE hFile,
                            const FILETIME* pctime,
                            const FILETIME* patime,
                            const FILETIME* pmtime)
{
    HRESULT sc=S_OK;

    if( INVALID_HANDLE_VALUE == hFile )
    {
        nffDebug(( DEB_IWARN, "CNtfsStream::SetFileHandleTime on hFile == -1\n" ));
        return S_OK;
    }

    nffDebug(( DEB_STATCTRL | DEB_ITRACE,
               "SetFileHandleTime(%p %p %p) hdl=%x\n",
               pctime, patime, pmtime, hFile ));

    nffBool( ::SetFileTime( hFile, pctime, patime, pmtime ) );
EH_Err:
    return sc;
}


#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::UseNTFS4Streams( BOOL fUseNTFS4Streams )
{
    return( _nffMappedStream.UseNTFS4Streams( fUseNTFS4Streams ));
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::GetFormatVersion(WORD *pw)
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::SimulateLowMemory( BOOL fSimulate )
{
    return( _nffMappedStream.SimulateLowMemory( fSimulate ));
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::GetLockCount()
{
    return( NULL == _pnffstg ? 0 : _pnffstg->GetLockCount() );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::IsDirty()
{
    return( E_NOTIMPL );
}
#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\names.cxx ===
#include <pch.cxx>

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:	names.cxx
//
//+---------------------------------------------------------------------------


///////////////////////// CONTENTS STREAM ////////////////////////////////////

const WCHAR g_wszContentsStreamName[]   = L"CONTENTS";

//+----------------------------------------------------------------------------
//
//  Routine    IsContentStream
//      Calls String Compare with "CONTENTS".
//
//+----------------------------------------------------------------------------

BOOL IsContentStream( const WCHAR* pwszName )
{
    return ( 0 == dfwcsnicmp( pwszName, g_wszContentsStreamName, -1 ) );
}

//+----------------------------------------------------------------------------
//
//  Routine    GetContentStreamName
//      returns the string "CONTENTS".
//
//+----------------------------------------------------------------------------

const WCHAR* GetContentStreamName()
{
    return g_wszContentsStreamName;
}

///////////////////////// NTFS $Data Name Mangling ///////////////////////////

//+----------------------------------------------------------------------------
//
//  CNtfsStreamName    "constructor"
//      converts "name" into ":name:$DATA"
//
//+----------------------------------------------------------------------------
const WCHAR g_wszNtfsDollarDataSuffix[] = L":$DATA";

CNtfsStreamName::CNtfsStreamName( const WCHAR *pwsz)
{
    nffAssert( NULL != pwsz);

    if( IsContentStream( pwsz ) )
        pwsz = L"";

    _count = wcslen( pwsz ) + CCH_NTFS_DOLLAR_DATA + 1;
    nffAssert( NTFS_MAX_ATTR_NAME_LEN >= _count );

    wcscpy( _wsz, L":" );
    wcscat( _wsz, pwsz );
    wcscat( _wsz, g_wszNtfsDollarDataSuffix );
}

//+----------------------------------------------------------------------------
//
//  Routine     IsDataStream
//      Does the name have a ":$Data" On the end.
//
//+----------------------------------------------------------------------------

BOOL IsDataStream( const PFILE_STREAM_INFORMATION pFSInfo )
{
    BOOL ret;

    LONG ccnt = pFSInfo->StreamNameLength/sizeof(WCHAR) - CCH_NTFS_DOLLAR_DATA;

    ret = pFSInfo->StreamNameLength >= CCH_NTFS_DOLLAR_DATA*sizeof(WCHAR)
            &&  !dfwcsnicmp( &pFSInfo->StreamName[ ccnt ],
                            g_wszNtfsDollarDataSuffix,
                            CCH_NTFS_DOLLAR_DATA );
    return ret;        
}

//+----------------------------------------------------------------------------
//
//  Routine     GetNtfsUnmangledNameInfo
//      Take an FILE_STREAM_INFORMATION record and compute the unmangled name.
//      No memory allocation, just return pointers into the existing data.
//      The given FILE_STREAM_INFORMATION record must be a $DATA record.
//      Also invent "CONTENTS" if necessary.
//
//+----------------------------------------------------------------------------

void
GetNtfsUnmangledNameInfo(const FILE_STREAM_INFORMATION *pFSI,
                         const WCHAR** ppwcs,
                         ULONG* pcch)
{
    // The stream names in pFSI are "mangled"; they have the ":" prefix
    // and ":$DATA" suffix.  Get the size and address of the beginning of
    // the unmangled name, which is what we'll return to the caller.

    LONG cbName = pFSI->StreamNameLength
                  - sizeof(WCHAR)                       // leading colon
                  - sizeof(WCHAR)*CCH_NTFS_DOLLAR_DATA; // ":$DATA"

    nffAssert(cbName >=0 && cbName <= NTFS_MAX_ATTR_NAME_LEN);

    if(0 == cbName )
    {
        *ppwcs = GetContentStreamName();
        *pcch = wcslen(*ppwcs);     // *ppwcs is NULL terminated in this case
    }
    else
    {
        *ppwcs = &pFSI->StreamName[1];
        *pcch = cbName/sizeof(WCHAR);   // *ppwcs is not NULL terminated!
    }
}

///////////////////////// NFF CONTROL STREAM  ////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Routine    IsControlStream
//
//+----------------------------------------------------------------------------
const WCHAR g_wszNFFControlStreamName[] = L"{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}";

BOOL IsControlStream( const WCHAR* pwszName )
{
    return ( 0 == dfwcsnicmp( pwszName, g_wszNFFControlStreamName, -1 ) );
}

//+----------------------------------------------------------------------------
//
//  Routine    GetControlStreamName
//
//+----------------------------------------------------------------------------

const WCHAR* GetControlStreamName()
{
    return g_wszNFFControlStreamName;
}



//+----------------------------------------------------------------------------
//
//  Routine    IsSpecifiedStream
//
//+----------------------------------------------------------------------------

BOOL IsSpecifiedStream(const FILE_STREAM_INFORMATION *pFSI,
                       const WCHAR *pwszStream  // Without the :*:$data adornments
                       )
{
    DWORD cch = wcslen(pwszStream);

    // The cch plus the ::$data decorations should match the stream length

    if( cch + CCH_NTFS_DOLLAR_DATA + 1 
        !=
        pFSI->StreamNameLength / sizeof(WCHAR) )
    {
        return FALSE;
    }

    return ( 0 == dfwcsnicmp( &( pFSI->StreamName[1] ),
                             pwszStream,
                             cch ) );
}


//+----------------------------------------------------------------------------
//
//  Routine    HasVisibleNamedStreams
//
//  Returns TRUE if there is a stream other than the contents
//  and control streams.
//
//+----------------------------------------------------------------------------

BOOL HasVisibleNamedStreams( const FILE_STREAM_INFORMATION *pfsi )
{
    for( ; NULL != pfsi; pfsi = NextFSI(pfsi) )
    {
        if( !IsHiddenStream(pfsi) && !IsContentsStream(pfsi) )
            return( TRUE );
    }

    return( FALSE );
}




///////////////////////// Docfile Stream Name Mangling ///////////////////////

//+----------------------------------------------------------------------------
//
//  CDocfileStreamName    "constructor"
//      converts "name" into "Docf_name"
//
//+----------------------------------------------------------------------------

const WCHAR g_wszDocfileStreamPrefix[] = L"Docf_";

CDocfileStreamName::CDocfileStreamName( const WCHAR *pwsz)
{
    wcscpy( _wszName, g_wszDocfileStreamPrefix );
    wcscat( _wszName, pwsz );
}


//+----------------------------------------------------------------------------
//
//  Routine     IsDocfileStream
//      Does the name have a "Docf_" On the front.
//
//+----------------------------------------------------------------------------

BOOL IsDocfileStream( const WCHAR *pwsz )
{
    return( 0 == wcsncmp( pwsz, g_wszDocfileStreamPrefix,
                                CCH_DOCFILESTREAMPREFIX ) );
}


const WCHAR *
UnmangleDocfileStreamName( const WCHAR *pwszName )
{
    nffAssert( IsDocfileStream( pwszName ));
    return( &pwszName[ CCH_DOCFILESTREAMPREFIX ] );
}


///////////////////////// Update Stream Name Mangling ///////////////////////

//+----------------------------------------------------------------------------
//
//  CDocfileStreamName    "constructor"
//      converts "name" into "Updt_name"
//
//+----------------------------------------------------------------------------
const WCHAR g_wszNtfsUpdateStreamPrefix[] = L"Updt_";

CNtfsUpdateStreamName::CNtfsUpdateStreamName( const WCHAR *pwsz)
{
    wcscpy( _wszName, g_wszNtfsUpdateStreamPrefix );
    wcscat( _wszName, pwsz );
}

//+----------------------------------------------------------------------------
//
//  CNtfsUpdateStreamName statics
//
//+----------------------------------------------------------------------------

BOOL
IsUpdateStream( const WCHAR *pwsz )
{
    return( 0 == wcsncmp( pwsz, g_wszNtfsUpdateStreamPrefix,
                          sizeof(g_wszNtfsUpdateStreamPrefix)/sizeof(WCHAR) ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pch.cxx
//
//  Contents:   Precompiled header includes.
//
//--------------------------------------------------------------------------

#include <new.h>

extern "C"
{
# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windef.h>
}

#include <ddeml.h>
#include <objbase.h>
#include <malloc.h>

#ifdef _CAIRO_
#define _CAIROSTG_
#include <oleext.h>
#endif
#include <stgint.h>

#include <valid.h>

#include <debnot.h>

#ifdef IPROPERTY_DLL

    VOID PropAssertFailed(
        IN PVOID FailedAssertion,
        IN PVOID FileName,
        IN ULONG LineNumber,
        IN PCHAR Message OPTIONAL
        );

    #define Win4AssertEx( file, line, message ) PropAssertFailed( FALSE, __FILE__, __LINE__, message )

#endif // #ifdef IPROPERTY_DLL

#include <otrack.hxx>
#include <funcs.hxx>
#include <safedecl.hxx>
#include <infs.hxx>


#include <propset.h>    // for PROPID_CODEPAGE

extern "C"
{
#include <propapi.h>
}

#include <propstm.hxx>  // Declaration for IMappedStream i/f that
                        // is used to let the ntdll implementation of
                        // OLE properties access the underlying stream data.

#include <olechar.h>    // Wrappers. E.g.: ocscpy, ocscat.

#include "prophdr.hxx"
#define DFMAXPROPSETSIZE (256*1024)


#ifndef IPROPERTY_DLL
# include <msf.hxx>
# include <publicdf.hxx>
# include <pbstream.hxx>
# include <expdf.hxx>
# include <expst.hxx>
#endif

#include <privoa.h>     // Private OleAut32 wrappers
#include <psetstg.hxx>  // CPropertySetStorage which implements
                        // IPropertySetStorage for docfile and ofs

#include <utils.hxx>

#include <propstg.hxx>
#include <cli.hxx>
#include <SSMapStm.hxx>
#include <propdbg.hxx>

#include <propmac.hxx>

#include <reserved.hxx>
#include <objidl.h>
#include <stgprops.hxx>

#include <windows.h>
#include <dfmsp.hxx>    // LONGSIG,VDATEPTROUT


#include <error.hxx>
#include <names.hxx>
#include <hntfsstm.hxx>
#include <hntfsstg.hxx>
#include "bag.hxx"

#include <docfilep.hxx>

#ifndef STG_E_PROPSETMISMATCHED
#define STG_E_PROPSETMISMATCHED 0x800300F0
#endif

#include <cfiletim.hxx>
#include <ole.hxx>  // olAssert
#include <df32.hxx> // LAST_SCODE


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\ntprop.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        ntprop.cxx
//
// Contents:    OLE Appendix B property set support.
//
// History:     28-Nov-94   vich        created
//              15-Jul-96   MikeHill    - PropSetNames: WCHAR=>OLECHAR, byte-swapping.
//                                      - Added special-cases for PictureIt! propsets.
//              06-May-98   MikeHill    - In PropertySetNameToGuid, disallow
//                                        a string-ized well-known GUID.
//
//---------------------------------------------------------------------------

#include <pch.cxx>
#include <olechar.h>

// These optionally-compiled directives tell the compiler & debugger
// where the real file, rather than the copy, is located.
#ifdef _ORIG_FILE_LOCATION_
#if __LINE__ != 25
#error File heading has change size
#else
#line 29 "\\nt\\private\\dcomidl\\ntprop.cxx"
#endif
#endif

#define CCH_MAP         (1 << CBIT_CHARMASK)            // 32
#define CHARMASK        (CCH_MAP - 1)                   // 0x1f

// we use static array instead of string literals because some systems
// have 4 bytes string literals, and would not produce the correct result
// for REF's 2 byte Unicode convention
// 
OLECHAR aocMap[CCH_MAP + 1] = {'a','b','c','d','e','f','g',
                               'h','i','j','k','l','m','n',
                               'o','p','q','r','s','t','u',
                               'v','w','x','y','z',
                               '0','1','2','3','4','5','\0'};

#define CALPHACHARS  (1 + (OLECHAR)'z' - (OLECHAR)'a')

GUID guidSummary =
    { 0xf29f85e0,
      0x4ff9, 0x1068,
      { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };

OLECHAR oszSummary[] = {'S','u','m','m','a','r','y',
                        'I','n','f','o','r','m','a','t','i','o','n','\0'};

GUID guidDocumentSummary =
    { 0xd5cdd502,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

OLECHAR oszDocumentSummary[] = {'D','o','c','u','m','e','n','t',
                                'S','u','m','m','a','r','y',
                                'I','n','f','o','r','m','a','t','i','o','n',
                                '\0'};

// Note that user defined properties are placed in section 2 with the below
// GUID as the FMTID -- alas, we did not expect Office95 to actually use it.

GUID guidDocumentSummarySection2 =
    { 0xd5cdd505,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

// *Global Info*

OLECHAR oszGlobalInfo[] = {'G','l','o','b','a','l',' ','I','n','f','o','\0'};

GUID guidGlobalInfo =
    { 0x56616F00,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Contents*

OLECHAR oszImageContents[] = {'I','m','a','g','e',' ',
                              'C','o','n','t','e','n','t','s','\0'};

GUID guidImageContents =
    { 0x56616400,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Info*

OLECHAR oszImageInfo[] = {'I','m','a','g','e',' ','I','n','f','o','\0'};

GUID guidImageInfo =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };


__inline OLECHAR
MapChar(IN ULONG i)
{
    return((OLECHAR) aocMap[i & CHARMASK]);
}


//+--------------------------------------------------------------------------
// Function:    PrGuidToPropertySetName
//
// Synopsis:    Map property set GUID to null-terminated UNICODE name string.
//
//              The awcname parameter is assumed to be a buffer with room for
//              CWC_PROPSETSZ (28) UNICODE characters.  The first character
//              is always WC_PROPSET0 (0x05), as specified by the OLE Appendix
//              B documentation.  The colon character normally used as an NT
//              stream name separator is not written to the caller's buffer.
//
//              No error is possible.
//
// Arguments:   IN GUID *pguid        -- pointer to GUID to convert
//              OUT OLECHAR aocname[] -- output string buffer
//
// Returns:     count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------

WINOLEAPI_(ULONG)
PrGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[])
{
    ULONG cbitRemain = CBIT_BYTE;
    OLECHAR *poc = aocname;

    BYTE *pb;
    BYTE *pbEnd;    

    *poc++ = OC_PROPSET0;

    //  -----------------------
    //  Check for special-cases
    //  -----------------------

    // Note: CCH_PROPSET includes the OC_PROPSET0, and sizeof(osz...)
    // includes the trailing '\0', so sizeof(osz...) is ok because the
    // OC_PROPSET0 character compensates for the trailing NULL character.

    // Is this the SummaryInformation propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszSummary)/sizeof(OLECHAR));

    if (*pguid == guidSummary)
    {
        RtlCopyMemory(poc, oszSummary, sizeof(oszSummary));
        return(sizeof(oszSummary)/sizeof(OLECHAR));
    }

    // Is this The DocumentSummaryInformation or User-Defined propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszDocumentSummary)/sizeof(OLECHAR));

    if (*pguid == guidDocumentSummary || *pguid == guidDocumentSummarySection2)
    {
        RtlCopyMemory(poc, oszDocumentSummary, sizeof(oszDocumentSummary));
        return(sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    }

    // Is this the Global Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    if (*pguid == guidGlobalInfo)
    {
        RtlCopyMemory(poc, oszGlobalInfo, sizeof(oszGlobalInfo));
        return(sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    }

    // Is this the Image Contents propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageContents)/sizeof(OLECHAR));
    if (*pguid == guidImageContents)
    {
        RtlCopyMemory(poc, oszImageContents, sizeof(oszImageContents));
        return(sizeof(oszImageContents)/sizeof(OLECHAR));
    }

    // Is this the Image Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageInfo)/sizeof(OLECHAR));
    if (*pguid == guidImageInfo)
    {
        RtlCopyMemory(poc, oszImageInfo, sizeof(oszImageInfo));
        return(sizeof(oszImageInfo)/sizeof(OLECHAR));
    }


    //  ------------------------------
    //  Calculate the string-ized GUID
    //  ------------------------------

    // If this is a big-endian system, we need to convert
    // the GUID to little-endian for the conversion.

#if BIGENDIAN
    GUID guidByteSwapped = *pguid;
    PropByteSwap( &guidByteSwapped );
    pguid = &guidByteSwapped;
#endif

    // Point to the beginning and ending of the GUID
    pb = (BYTE*) pguid;
    pbEnd = pb + sizeof(*pguid);

    // Walk 'pb' through each byte of the GUID.

    while (pb < pbEnd)
    {
        ULONG i = *pb >> (CBIT_BYTE - cbitRemain);

        if (cbitRemain >= CBIT_CHARMASK)
        {
            *poc = MapChar(i);
            if (cbitRemain == CBIT_BYTE && *poc >= (OLECHAR)'a' 
                && *poc <= ((OLECHAR)'z'))
            {
                *poc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a') );
            }
            poc++;
            cbitRemain -= CBIT_CHARMASK;
            if (cbitRemain == 0)
            {
                pb++;
                cbitRemain = CBIT_BYTE;
            }
        }
        else
        {
            if (++pb < pbEnd)
            {
                i |= *pb << cbitRemain;
            }
            *poc++ = MapChar(i);
            cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
        }
    }   // while (pb < pbEnd)

    *poc = OLESTR( '\0' );
    return(CCH_PROPSET);

}


//+--------------------------------------------------------------------------
// Function:    PrPropertySetNameToGuid
//
// Synopsis:    Map non null-terminated UNICODE string to a property set GUID.
//
//              If the name is not properly formed as per
//              PrGuidToPropertySetName(), STATUS_INVALID_PARAMETER is
//              returned.  The pguid parameter is assumed to point to a buffer
//              with room for a GUID structure.
//
// Arguments:   IN ULONG cocname     -- count of OLECHARs in string to convert
//              IN OLECHAR aocname[] -- input string to convert
//              OUT GUID *pguid      -- pointer to buffer for converted GUID
//
// Returns:     NTSTATUS
//---------------------------------------------------------------------------

NTSTATUS
PrPropertySetNameToGuid(
    IN ULONG cocname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    GUID guidReturn = GUID_NULL;

    OLECHAR const *poc = aocname;

    if (poc[0] == OC_PROPSET0)
    {
        //  -----------------------
        //  Check for Special-Cases 
        //  -----------------------

        // Note: cocname includes the OC_PROPSET0, and sizeof(osz...)
        // includes the trailing OLESTR('\0'), but the comparison excludes both
        // the leading OC_PROPSET0 and the trailing '\0'.

        // Is this SummaryInformation?
        if (cocname == sizeof(oszSummary)/sizeof(OLECHAR) &&
            // MAC: Create a dfsocsnicmp or convert strings to WCHARs
            //ocsnicmp(&poc[1], oszSummary, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszSummary, cocname - 1) == 0)

        {
            *pguid = guidSummary;
            return(STATUS_SUCCESS);
        }

        // Is this DocumentSummaryInformation?
        if (cocname == sizeof(oszDocumentSummary)/sizeof(OLECHAR) &&
            //ocsnicmp(&poc[1], oszDocumentSummary, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszDocumentSummary, cocname - 1) == 0)
        {
            *pguid = guidDocumentSummary;
            return(STATUS_SUCCESS);
        }

        // Is this Global Info?
        if (cocname == sizeof(oszGlobalInfo)/sizeof(OLECHAR) &&
            //ocsnicmp(&poc[1], oszGlobalInfo, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszGlobalInfo, cocname - 1) == 0)
        {
            *pguid = guidGlobalInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Info?
        if (cocname == sizeof(oszImageInfo)/sizeof(OLECHAR) &&
            //ocsnicmp(&poc[1], oszImageInfo, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszImageInfo, cocname - 1) == 0)
        {
            *pguid = guidImageInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Contents?
        if (cocname == sizeof(oszImageContents)/sizeof(OLECHAR) &&
            //ocsnicmp(&poc[1], oszImageContents, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszImageContents, cocname - 1) == 0)
        {
            *pguid = guidImageContents;
            return(STATUS_SUCCESS);
        }

        //  ------------------
        //  Calculate the GUID
        //  ------------------

        // None of the special-cases hit, so we must calculate
        // the GUID from the name.

        if (cocname == CCH_PROPSET)
        {
            ULONG cbit;
            BYTE *pb = (BYTE *) &guidReturn - 1;

            RtlZeroMemory(&guidReturn, sizeof(guidReturn));
            for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)
            {
                ULONG cbitUsed = cbit % CBIT_BYTE;
                ULONG cbitStored;
                OLECHAR oc;

                if (cbitUsed == 0)
                {
                    pb++;
                }

                oc = *++poc - (OLECHAR)'A'; // assume upper case 
                // for wchar (unsigned) -ve values becomes a large number
                // but for char, which is signed, -ve is -ve
                if (oc > CALPHACHARS || oc < 0)
                {
                    // oops, try lower case
                    oc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a'));
                    if (oc > CALPHACHARS || oc < 0)
                    {
                        // must be a digit
                        oc += ((OLECHAR)'a') - ((OLECHAR)'0') + CALPHACHARS;
                        if (oc > CHARMASK)
                        {
                            goto Exit;                  // invalid character
                        }
                    }
                }
                *pb |= (BYTE) (oc << cbitUsed);

                cbitStored = min(CBIT_BYTE - cbitUsed, CBIT_CHARMASK);

                // If the translated bits wouldn't all fit in the current byte

                if (cbitStored < CBIT_CHARMASK)
                {
                    oc >>= CBIT_BYTE - cbitUsed;

                    if (cbit + cbitStored == CBIT_GUID)
                    {
                        if (oc != 0)
                        {
                            goto Exit;                  // extra bits
                        }
                        break;
                    }
                    pb++;

                    *pb |= (BYTE) oc;
                }
            }   // for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)

            Status = STATUS_SUCCESS;

            // If byte-swapping is necessary, do so now on the calculated
            // GUID.

            PropByteSwap( &guidReturn );

        }   // if (cocname == CCH_PROPSET)
    }   // if (poc[0] == OC_PROPSET0)

    // Ensure that the calculated GUID isn't one of the special ones.  If it is,
    // then this is an error.  We don't want to convert something to a GUID
    // that we can't convert back.

    if( guidSummary         == guidReturn
        ||
        guidDocumentSummary == guidReturn
        ||
        guidGlobalInfo      == guidReturn
        ||
        guidImageInfo       == guidReturn
        ||
        guidImageContents   == guidReturn
        )
    {
        return( STATUS_INVALID_PARAMETER );
    }


    //  ----
    //  Exit
    //  ----

    Status = STATUS_SUCCESS;    // Normalize results
    *pguid = guidReturn;

Exit:

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\ntpropb.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1994
//
// File:        ntpropb.cxx
//
// Contents:    Nt property set implementation based on OLE Appendix B.
//
// History:     
//  5-Dec-94   vich       created
//  09-May-96  MikeHill   Use the 'boolVal' member of PropVariant,
//                        rather than the member named 'bool'
//                       (which is a reserved keyword).
//  22-May-96  MikeHill   - Get the OSVersion during a CreatePropSet.
//                        - Let CPropSetStm allocate prop name buffers.
//  07-Jun-96  MikeHill   - Correct ClipData.cbSize to include
//                          sizeof(ulClipFmt).
//                        - Removed unnecessary Flushes.
//                        - Take the psstm lock on RtlClosePropSet.
//  12-Jun-96  MikeHill   - Fix locking in RtlClosePropertySet.
//                        - VT_I1 support (under ifdefs)
//  25-Jul-96  MikeHill   - Removed Win32 SEH.
//                        - BSTRs & prop names:  WCHAR => OLECHAR.
//                        - Added RtlOnMappedStreamEvent
//                        - Enabled for use in "iprop.dll".
//  03-Mar-98  MikeHill   - Chagned "Pr" routines to "Stg".
//  06-May-98  MikeHill   - Removed UnicodeCallouts.
//                        - Use CoTaskMem rather than new/delete.
//                        - Added support for VT_VECTOR|VT_I1
//  18-May-98  MikeHill   - Fixed typos.
//  11-June-98 MikeHIll   - Removed some old Cairo code.
//                        - Dbg output.
//                        - Add a pCodePage to PrSetProperties.
//
//---------------------------------------------------------------------------

#include <pch.cxx>
#include "propvar.h"
#include <olechar.h>
#include <stgprop.h>

#define Dbg     DEBTRACE_NTPROP
#define DbgS(s) (NT_SUCCESS(s)? Dbg : DEBTRACE_ERROR)


#if DBG
ULONG DebugLevel = DEBTRACE_ERROR;
//ULONG DebugLevel = DEBTRACE_ERROR | DEBTRACE_CREATESTREAM;
//ULONG DebugLevel = DEBTRACE_ERROR | MAXULONG;
ULONG DebugIndent;
ULONG cAlloc;
ULONG cFree;
#endif

#if defined(WINNT) && !defined(IPROPERTY_DLL)

GUID guidStorage = PSGUID_STORAGE;


#endif // #if defined(WINNT) && !defined(IPROPERTY_DLL)


//+---------------------------------------------------------------------------
// Function:    UnLock, private
//
// Synopsis:    Unlock a PropertySetStream, and return the
//              more severe of two NTSTATUSs; the result of
//              the Unlock, or the one passed in by the caller.
//
// Arguments:   [ppsstm]        -- The CPropertySetStream to unlock
//              [Status]        -- NTSTATUS
//
// Returns:     NTSTATUS
//---------------------------------------------------------------------------

inline NTSTATUS
Unlock( CPropertySetStream *ppsstm, NTSTATUS Status )
{
    NTSTATUS StatusT = ppsstm->Unlock();

    // Note that the statement below preserves
    // success codes in the original Status unless
    // there was an error in the Unlock.

    if( NT_SUCCESS(Status) && !NT_SUCCESS(StatusT) )
        Status = StatusT;

    return( Status );
}

//+---------------------------------------------------------------------------
// Function:    PrCreatePropertySet, public
//
// Synopsis:    Allocate and initialize a property set context
//
// Arguments:   [ms]            -- Nt Mapped Stream
//              [Flags]         -- *one* of READ/WRITE/CREATE/CREATEIF/DELETE
//              [pguid]         -- property set guid (create only)
//              [pclsid]        -- CLASSID of propset code (create only)
//              [ma]            -- caller's memory allocator
//		[LocaleId]	-- Locale Id (create only)
//              [pOSVersion]    -- pointer to the OS Version header field
//              [pCodePage]     -- pointer to new/returned CodePage of propset
//              [pgrfBehavior]  -- pointer to PROPSET_BEHAVIOR_* flags
//              [pnp]           -- pointer to returned property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrCreatePropertySet(
    IN NTMAPPEDSTREAM ms,           // Nt Mapped Stream
    IN USHORT Flags,                // *one* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid,  // property set guid (create only)
    OPTIONAL IN GUID const *pclsid, // CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	    // caller's memory allocator
    IN ULONG LocaleId,		    // Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion, // OS Version from the propset header
    IN OUT USHORT *pCodePage,       // IN: CodePage of property set (create only)
                                    // OUT: CodePage of property set (always)
    IN OUT DWORD *pgrfBehavior,     // IN: Behavior of property set (create only)
                                    // OUT:  Behavior of property set (always)
    OUT NTPROP *pnp)                // pointer to return prop set context
{
    NTSTATUS Status;
    IMappedStream *pmstm = (IMappedStream *) ms;
    CPropertySetStream *ppsstm = NULL;
    BOOLEAN fLocked = FALSE;
    BOOLEAN fOpened = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrCreatePropertySet" );
    propTraceParameters(( "ms=%p, f=0x%x, codepage=0x%x)", ms, Flags, *pCodePage ));

    *pnp = NULL;
    Status = STATUS_INVALID_PARAMETER;

    if( pOSVersion != NULL )
        *pOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

    // Validate the input flags

    if (Flags & ~(CREATEPROP_MODEMASK | CREATEPROP_NONSIMPLE))
    {
        propDbg(( DEB_ERROR, "PrCreatePropertySet(ms=%x, Flags=%x) ==> bad flags!\n",
                  ms, Flags));
        goto Exit;
    }

    PROPASSERT( (0 == *pgrfBehavior) || (CREATEPROP_CREATE & Flags) );
    PROPASSERT( !(*pgrfBehavior & ~PROPSET_BEHAVIOR_CASE_SENSITIVE) );

    switch (Flags & CREATEPROP_MODEMASK)
    {
        case CREATEPROP_DELETE:
        case CREATEPROP_CREATE:
        case CREATEPROP_CREATEIF:
        case CREATEPROP_WRITE:

            if (!pmstm->IsWriteable())
            {
                Status = STATUS_ACCESS_DENIED;
                goto Exit;
            }
            // FALLTHROUGH

        case CREATEPROP_READ:
        case CREATEPROP_UNKNOWN:
    	    if (ma == NULL)
    	    {
                goto Exit;
    	    }
            break;

        default:
            propDbg(( DEB_ERROR, "PrCreatePropertySet(ms=%x, Flags=%x) ==> invalid mode!\n",
                      ms, Flags));
            goto Exit;
    }

    Status = pmstm->Lock((Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm = new CPropertySetStream( Flags, pmstm, (PMemoryAllocator *) ma);
    if (ppsstm == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }
    else
    {
        ppsstm->Open(pguid, pclsid, LocaleId,
                     pOSVersion, *pCodePage, *pgrfBehavior, &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

    }

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
    {
        NTSTATUS StatusT = Status;
        if( ppsstm )
            ppsstm->Unlock();
        else
            pmstm->Unlock();

        if( NT_SUCCESS(Status) && !NT_SUCCESS(StatusT) )
            Status = StatusT;
    }

    // If we were successfull with everything, set the
    // out-parameters.

    if( NT_SUCCESS(Status) )
    {
        // pOSVersion has already been set.
        *pCodePage = ppsstm->GetCodePage();
        *pgrfBehavior = ppsstm->GetBehavior();
        *pnp = (NTPROP) ppsstm;
    }

    // Otherwise, if we created a CPropertySetStream object, but
    // the overall operation failed, we must close/delete
    // the object.  Note that we must do this after
    // the above unlock, since ppsstm will be gone after
    // this call.

    else if( NULL != ppsstm )
    {
        PrClosePropertySet((NTPROP) ppsstm);
    }

    if( STATUS_PROPSET_NOT_FOUND == Status )
        propSuppressExitErrors();

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrClosePropertySet, public
//
// Synopsis:    Delete a property set context
//
// Arguments:   [np]      -- property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrClosePropertySet(
    IN NTPROP np)               // property set context
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrClosePropertySet" );
    propTraceParameters(( "np=%p", np ));

    // Lock the mapped stream, because this close
    // may trigger a Write.

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    // Note that we haven't ReOpen-ed the mapped stream.  This
    // isn't required for the CPropertySetStream::Close method.
    ppsstm->Close(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( STG_E_REVERTED == Status )
        propSuppressExitErrors();

    delete ppsstm;

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrOnMappedStreamEvent, public
//
// Synopsis:    Handle a MappedStream event.  Every such
//              event requires a byte-swap of the property set
//              headers.
//
// Arguments:   [np]      -- property set context
//              [pbuf]    -- property set buffer
//              [cbstm]   -- size of mapped stream (or CBSTM_UNKNOWN)
//
// NOTE:        It is assumed that the caller has already taken
//              the CPropertySetStream::Lock.
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrOnMappedStreamEvent(
    IN VOID * np,               // property set context (an NTPROP)
    IN VOID *pbuf,              // property set buffer
    IN ULONG cbstm )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrOnMappedStreamEvent" );
    propTraceParameters(( "np=%p, pbuf=%p, cbstm=%lu", np, pbuf, cbstm ));

    // Byte-swap the property set headers.
    ppsstm->ByteSwapHeaders((PROPERTYSETHEADER*) pbuf, cbstm, &Status );
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    return(Status);

}   // PrOnMappedStreamEvent()


//+---------------------------------------------------------------------------
// Function:    PrFlushPropertySet, public
//
// Synopsis:    Flush property set changes to disk
//
// Arguments:   [np]      -- property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrFlushPropertySet(
    IN NTPROP np)               // property set context
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrFlushPropertySet" );
    propTraceParameters(( "np=%p", np ));

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    if (ppsstm->IsModified())
    {
        ppsstm->ReOpen(&Status);           // Reload header/size info
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Validate(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Flush(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Validate(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;
    }

Exit:

    if( fLocked )
        Status = Unlock( ppsstm, Status );

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    MapNameToPropId, private
//
// Synopsis:    Find an available propid and map it to the passed name
//
// Arguments:   [ppsstm]        -- property set stream
//              [CodePage]      -- property set codepage
//              [aprs]          -- array of property specifiers
//              [cprop]         -- count of property specifiers
//              [iprop]         -- index of propspec with name to map
//              [pidStart]      -- first PROPID to start mapping attempts
//              [pstatus]       -- NTSTATUS code
//
// Returns:     PROPID mapped to passed name
//
// Note:        Find the first unused propid starting at pidStart.
//---------------------------------------------------------------------------

PROPID
MapNameToPropId(
    IN CPropertySetStream *ppsstm,    // property set stream
    IN USHORT CodePage,
    IN PROPSPEC const aprs[],         // array of property specifiers
    IN ULONG cprop,
    IN ULONG iprop,
    IN PROPID pidStart,
    OUT NTSTATUS *pstatus)
{
    PROPID pid = PID_ILLEGAL;
    const OLECHAR *poszName = NULL;
    OLECHAR *poszNameFromDictionary = NULL;
    ULONG cbName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(aprs[iprop].ulKind == PRSPEC_LPWSTR);
    poszName = aprs[iprop].lpwstr;
    PROPASSERT(IsOLECHARString( poszName, MAXULONG ));

    IFDBG( HRESULT &hr = *pstatus );
    propITraceStatic( "MapNameToPropId" );
    propTraceParameters(( "ppsstm=%p, CodePage=%d, aprs=%p, cprop=%d, iprop=%d, pidStart=%d",
                           ppsstm,    CodePage,    aprs,    cprop,    iprop,    pidStart ));

    // Starting with the caller-provided PID, search sequentially
    // until we find a PID we can use.

    for (pid = pidStart; ; pid++)
    {
        ULONG i;

        // The caller must specify a starting propid of 2 or larger, and we
        // must not increment into the reserved propids.

        if (pid == PID_DICTIONARY ||
            pid == PID_CODEPAGE ||
            pid <  PID_FIRST_USABLE)
        {
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        // Do not assign any propids that explitly appear in the array of
        // propspecs involved in this PrSetProperties call, nor any propids
        // that are associated with any names in the propspec array.

        for (i = 0; i < cprop; i++)
        {
            if (i != iprop)             // skip the entry we are mapping
            {
                // Is the current PID in the PropSpec[]?

                if (aprs[i].ulKind == PRSPEC_PROPID &&
                    aprs[i].propid == pid)
                {
                    goto nextpid;       // skip colliding pid
                }

                // Is the current PID already used in the property set?

                if (aprs[i].ulKind == PRSPEC_LPWSTR &&
                    ppsstm->QueryPropid(aprs[i].lpwstr, pstatus) == pid)
                {
                    goto nextpid;       // skip colliding pid
                }
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // for (i = 0; i < cprop; i++)

        // Do not assign any propids that currently map to any name.
        // Note that the property name we are mapping does not appear in the
        // dictionary -- the caller checked for this case already.

        if( ppsstm->QueryPropertyNames( 1, &pid, &poszNameFromDictionary, pstatus ))
        {
            CoTaskMemFree( poszNameFromDictionary );
            poszNameFromDictionary = NULL;
        }
        else
        {
            // The property name could not be found in the dictionary.

            ULONG cbT;
	    SERIALIZEDPROPERTYVALUE const *pprop;

            PROPASSERT( NULL == poszNameFromDictionary );

            // Was the name not found due to an error in QueryPropertyNameBuf?
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            // Do not assign any propids that currently have a property value.

            pprop = ppsstm->GetValue(pid, &cbT, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            if (pprop == NULL)
            {
                // There was no property value corresponding to this PID.

                DebugTrace(0, Dbg, (
		    "MapNameToPropId(Set Entry: pid=%x, name=L'%ws')\n",
                    pid,
                    poszName));

                // Add the caller-provided name to the dictionary, using
                // the PID that we now know is nowhere in use.

                ppsstm->SetPropertyNames(1, &pid, &poszName, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                ppsstm->Validate(pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                break;

            }   // if (pprop == NULL)
        }   // if (!ppsstm->QueryPropertyNameBuf(pid, awcName, &cbName, pstatus))

nextpid:
        ;
    }   // for (pid = pidStart; ; pid++)

Exit:

    if( NULL != poszNameFromDictionary )
        CoTaskMemFree( poszNameFromDictionary );

    return(pid);
}


//+---------------------------------------------------------------------------
// Function:    ConvertVariantToPropInfo, private
//
// Synopsis:    Convert variant property values to PROPERTY_INFORMATION values
//
// Arguments:   [ppsstm]        -- property set stream
//              [cprop]         -- property count
//              [pidNameFirst]  -- first PROPID for new named properties
//              [aprs]          -- array of property specifiers
//              [apid]          -- buffer for array of propids
//              [avar]          -- array of PROPVARIANTs
//              [apinfo]        -- output array of property info
//              [pcIndirect]    -- output count of indirect properties
//
// Returns:     None
//
// Note:        If pcIndirect is NULL,
//---------------------------------------------------------------------------

VOID
ConvertVariantToPropInfo(
    IN CPropertySetStream *ppsstm,    // property set stream
    IN ULONG cprop,                   // property count
    IN PROPID pidNameFirst,           // first PROPID for new named properties
    IN PROPSPEC const aprs[],         // array of property specifiers
    OPTIONAL OUT PROPID apid[],       // buffer for array of propids
    OPTIONAL IN PROPVARIANT const avar[],// array of properties+values
    OUT PROPERTY_INFORMATION *apinfo, // output array of property info
    OUT ULONG *pcIndirect,            // output count of indirect properties
    OUT NTSTATUS *pstatus )
{
    *pstatus = STATUS_SUCCESS;

    USHORT CodePage = ppsstm->GetCodePage();
    PROPID pidStart = pidNameFirst;
    ULONG iprop;

    IFDBG( HRESULT &hr = *pstatus );
    propITraceStatic( "ConvertVariantToPropInfo" );
    propTraceParameters(( "ppsstm=%p, cprop=%d, pidNameFirst=%d, aprs=%p, apid=%p, avar=%p, apinfo=%p, pcIndirect=%p",
                           ppsstm,    cprop,    pidNameFirst,    aprs,    apid,    avar,    apinfo,    pcIndirect ));

    if (pcIndirect != NULL)
    {
        *pcIndirect = 0;
    }

    for (iprop = 0; iprop < cprop; iprop++)
    {
        PROPID pid;
        ULONG cbprop;

        switch(aprs[iprop].ulKind)
        {
        case PRSPEC_LPWSTR:
        {
            PROPASSERT(IsOLECHARString(aprs[iprop].lpwstr, MAXULONG));
            pid = ppsstm->QueryPropid(aprs[iprop].lpwstr, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            if (pid == PID_ILLEGAL && avar != NULL)
            {
                pid = MapNameToPropId(
                                ppsstm,
                                CodePage,
                                aprs,
                                cprop,
                                iprop,
                                pidStart,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                pidStart = pid + 1;
            }
            break;
        }

        case PRSPEC_PROPID:
            pid = aprs[iprop].propid;
            break;

        default:
            PROPASSERT(!"Bad ulKind");
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;

            break;
        }

        if (apid != NULL)
        {
            apid[iprop] = pid;
        }

        // StgConvertVariantToProperty returns NULL on overflow and
        // Raises on bad data.

        cbprop = 0;             // Assume property deletion
        if (pid != PID_ILLEGAL && avar != NULL)
        {
            StgConvertVariantToPropertyNoEH(
                            &avar[iprop],
                            CodePage,
                            NULL,   // Don't actualy convert. We just want to calc cbprop.
                            &cbprop,
                            pid,
                            FALSE, FALSE,   // Not a vector or array recursive call
                            pcIndirect,
                            NULL,   // Don't check for min format version required yet
                            pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            PROPASSERT(cbprop == DwordAlign(cbprop));
        }
        apinfo[iprop].cbprop = cbprop;
        apinfo[iprop].pid = pid;
    }   // for (iprop = 0; iprop < cprop; iprop++)

    //  ----
    //  Exit
    //  ----

Exit:

    if( STATUS_NOT_SUPPORTED == *pstatus )
        propSuppressExitErrors();

    return;
}


//+---------------------------------------------------------------------------
// Function:    BuildIndirectIndexArray, private
//
// Synopsis:    Set property values for a property set
//
// Arguments:   [cprop]         -- count of properties in avar
//              [cAlloc]        -- max count of indirect properties
//              [cIndirect]     -- count of indirect properties in avar
//              [avar]          -- array of PROPVARIANTs
//              [ppip]          -- ptr to ptr to Indirect property structures
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
BuildIndirectIndexArray(
    IN ULONG cprop,             // count of properties in avar
    IN ULONG cAlloc,            // max count of indirect properties
    IN ULONG cIndirect,         // count of indirect properties in avar
    IN PROPVARIANT const avar[],// array of properties+values
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                          // MAXULONG terminated array of Indirect
                                          // properties w/indexes into aprs & avar
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITraceStatic( "BuildIndirectIndexArray" );
    propTraceParameters(( "cprop=%d, cAlloc=%d, cIndirect=%d, avar=%p",
                           cprop,    cAlloc,    cIndirect,    avar ));

    PROPASSERT(cIndirect > 0);
    PROPASSERT(cAlloc >= cIndirect);
    PROPASSERT(cprop >= cAlloc);

    if (ppip != NULL)
    {
        INDIRECTPROPERTY *pip;
        ULONG iprop;

        if (cprop == 1)
        {
            pip = (INDIRECTPROPERTY *) ppip;
        }
        else
        {
            pip = (INDIRECTPROPERTY *) CoTaskMemAlloc( (cAlloc+1) * sizeof(INDIRECTPROPERTY) );
            if (pip == NULL)
            {
                *pstatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
            }
            *ppip = pip;
        }
        for (iprop = 0; iprop < cprop; iprop++)
        {
            if (IsIndirectVarType(avar[iprop].vt))
            {
                PROPASSERT(cprop == 1 || (ULONG) (pip - *ppip) < cIndirect);
                pip->Index = iprop;
                pip->poszName = NULL;
                pip++;
            }
        }
        if (cprop > 1)
        {
            pip->Index = MAXULONG;
            PROPASSERT((ULONG) (pip - *ppip) == cIndirect);
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    PrSetProperties, public
//
// Synopsis:    Set property values for a property set
//
// Arguments:   [np]            -- property set context
//              [cprop]         -- property count
//              [pidNameFirst]  -- first PROPID for new named properties
//              [aprs]          -- array of property specifiers
//              [apid]          -- buffer for array of propids
//                              -- values to write in place of indirect properties
//              [ppip]          -- ptr to ptr to Indirect property structures
//              [avar]          -- array of PROPVARIANTs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OUT USHORT *pCodePage,
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN PROPVARIANT const avar[]) // array of properties+values
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    PROPERTY_INFORMATION apinfoStack[6];
    PROPERTY_INFORMATION *apinfo = apinfoStack;
    ULONG cIndirect = 0;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrSetProperties" );
    propTraceParameters(( "np=%p, cprop=%d, pidNameFirst=%d, aprs=%p, CodePage=%d, apid=%p, ppip=%p, avar=%p",
                           np,    cprop,    pidNameFirst,    aprs,    *pCodePage,  apid,    ppip,    avar ));


    // Initialize the INDIRECTPROPERTY structure.

    if (ppip != NULL)
    {
        *ppip = NULL;

        // If cprop is 1, ppip is actually pip (one level
        // of indirection).

        if (cprop == 1)
        {
            // Default the index.
            ((INDIRECTPROPERTY *) ppip)->Index = MAXULONG;
        }
    }

    // Lock the property set.
    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    // Is the stack-based apinfo big enough?
    if (cprop > sizeof(apinfoStack)/sizeof(apinfoStack[0]))
    {
        // No - we need to allocate an apinfo.
        apinfo = reinterpret_cast<PROPERTY_INFORMATION*>
                 ( CoTaskMemAlloc( sizeof(PROPERTY_INFORMATION) * cprop ));

        if( NULL == apinfo )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // Describe the request into the apinfo array.  This also writes the names
    // to the dictionary.

    ConvertVariantToPropInfo(
                    ppsstm,
                    cprop,
                    pidNameFirst,
                    aprs,
                    apid,
                    avar,
                    apinfo,
                    ppip == NULL? NULL : &cIndirect,
                    &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // If the caller wants to know about indirect streams and
    // storages (and if there were any), allocate memory for a
    // MAXULONG terminated array of indexes to the indirect
    // variant structures, and fill it in.

    ppsstm->SetValue(cprop, ppip, avar, apinfo, pCodePage, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    // If we allocated a temporary apinfo buffer, free it.
    if (apinfo != apinfoStack)
    {
        CoTaskMemFree( apinfo );
    }

    if (!NT_SUCCESS(Status))
    {
        if (ppip != NULL)
        {
            if (cprop == 1)
            {
                ((INDIRECTPROPERTY *) ppip)->Index = MAXULONG;
            }
            else if (*ppip != NULL)
            {
                CoTaskMemFree( *ppip );
                *ppip = NULL;
            }
        }
    }

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( STATUS_NOT_SUPPORTED == Status )
        propSuppressExitErrors();

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrQueryProperties, public
//
// Synopsis:    Query property values from a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [aprs]           -- array of property specifiers
//              [apid]           -- buffer for array of propids
//              [ppip]           -- ptr to ptr to Indirect property structures
//              [avar]           -- array of PROPVARIANTs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound)     // count of property values retrieved
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    SERIALIZEDPROPERTYVALUE const *pprop = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cIndirect = 0;
    ULONG iprop;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrQueryProperties" );
    propTraceParameters(( "np=%p, cprop=%d, aprs=%p, apid=%p, ppip=%p)",
                           np,    cprop,    aprs,    apid,    ppip ));

    // Initialize the variant array enough to allow it to be cleaned up
    // by the caller (even on partial failure).

    *pcpropFound = 0;
    if (ppip != NULL)
    {
        *ppip = NULL;
        if (cprop == 1)
        {
            ((INDIRECTPROPERTY *) ppip)->Index = MAXULONG;
        }
    }

    // Zero-ing out the caller-provided PropVariants, essentially
    // sets them all to VT_EMPTY.  It also zeros out the data portion,
    // which prevents cleanup problems in error paths.

    RtlZeroMemory(avar, cprop * sizeof(avar[0]));


    Status = ppsstm->Lock(FALSE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    for (iprop = 0; iprop < cprop; iprop++)
    {
        PROPID pid;
        ULONG cbprop;

        switch(aprs[iprop].ulKind)
        {
        case PRSPEC_LPWSTR:
            pid = ppsstm->QueryPropid(aprs[iprop].lpwstr, &Status);
            if( !NT_SUCCESS(Status) ) goto Exit;
            break;

        case PRSPEC_PROPID:
            pid = aprs[iprop].propid;
            break;

        default:
            PROPASSERT(!"Bad ulKind");
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        pprop = ppsstm->GetValue(pid, &cbprop, &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        if (pprop != NULL)
        {
            BOOL fIndirect;

            (*pcpropFound)++;
            fIndirect = StgConvertPropertyToVariantNoEH(
                                pprop,
				ppsstm->GetCodePage(),
                                &avar[iprop],
                                ppsstm->GetAllocator(),
                                &Status);
            if( !NT_SUCCESS(Status) ) goto Exit;

            PROPASSERT( ( !(VT_ARRAY & avar[iprop].vt)
                          &&
                          !(VT_BYREF & avar[iprop].vt)
                          &&
                          VT_DECIMAL != avar[iprop].vt
                          &&
                          VT_I1 != avar[iprop].vt
                          &&
                          VT_INT != avar[iprop].vt
                          &&
                          VT_UINT != avar[iprop].vt
                        )
                        ||
                        PROPSET_WFORMAT_EXPANDED_VTS <= ppsstm->GetFormatVersion()
                      );

            if( fIndirect )
            {
                cIndirect++;
            }
        }
        if (apid != NULL)
        {
            apid[iprop] = pid;
        }
    }   // for (iprop = 0; iprop < cprop; iprop++)

    // If the caller wants to know about indirect streams and
    // storages (and if there were any), allocate memory for a
    // MAXULONG terminated array of indexes to the indirect
    // variant structures, and fill it in.

    if (cIndirect != 0)
    {
        BuildIndirectIndexArray(
                    cprop,
                    cIndirect,
                    cIndirect,
                    avar,
                    ppip,
                    &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(Status) )
    {
        if (ppip != NULL)
        {
            if (cprop == 1)
            {
                ((INDIRECTPROPERTY *) ppip)->Index = MAXULONG;
            }
            else if (*ppip != NULL)
            {
                CoTaskMemFree( *ppip );
                *ppip = NULL;
            }
        }
        CleanupVariants(avar, cprop, ppsstm->GetAllocator());
    }

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( STATUS_NOT_SUPPORTED == Status )
        propSuppressExitErrors();

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrEnumerateProperties, public
//
// Synopsis:    Enumerate properties in a property set
//
// Arguments:   [np]             -- property set context
//              [cskip]          -- count of properties to skip
//              [pcprop]         -- pointer to property count
//              [Flags]          -- flags: No Names (propids only), etc.
//              [asps]           -- array of STATPROPSTGs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN ULONG *pkey,             // count of properties to skip
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                 // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]) // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    SERIALIZEDPROPERTYVALUE const *pprop = NULL;
    PROPSPEC *pprs;
    STATPROPSTG *psps;
    PROPID *ppidBase = NULL;
    ULONG i;
    ULONG cpropin;
    BOOL fLocked = FALSE;

    PROPID apidStack[20];
    PROPID *ppid;
    ULONG cprop;
    PMemoryAllocator *pma = ppsstm->GetAllocator();

    // PERF: It'd be good to rewrite this name code so that it uses
    // a default-sized stack buffer where possible, which will be most of
    // the time.

    OLECHAR *poszName = NULL;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrEnumerateProperties" );
    propTraceParameters(( "np=%p, Flags=0x%x, key=0x%x, cprop=%d, aprs=%p, asps=%p)\n",
                           np,    Flags,      *pkey,    *pcprop,  aprs,    asps));

    cpropin = *pcprop;

    // Eliminate confusion for easy cleanup

    if (aprs != NULL)
    {
        // Set all the PropSpecs to PROPID (which require
        // no cleanup).

        for (i = 0; i < cpropin; i++)
        {
            aprs[i].ulKind = PRSPEC_PROPID;
        }
    }

    // Zero all pointers in the array for easy cleanup

    if (asps != NULL)
    {
        RtlZeroMemory(asps, cpropin * sizeof(asps[0]));
    }

    Status = ppsstm->Lock(FALSE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;


    ppidBase = NULL;

    cprop = ppsstm->ReOpen(&Status);   // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    if (cprop > cpropin)
    {
	cprop = cpropin;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppid = NULL;
    if (aprs != NULL || asps != NULL)
    {
	ppid = apidStack;
	if (cprop > sizeof(apidStack)/sizeof(apidStack[0]))
	{
            ppidBase = reinterpret_cast<PROPID*>( CoTaskMemAlloc( cprop * sizeof(PROPID) ));
	    if (ppidBase == NULL)
	    {
		Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
	    }
	    ppid = ppidBase;
	}
    }

    ppsstm->EnumeratePropids(pkey, &cprop, ppid, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    *pcprop = cprop;

    if (ppid != NULL)
    {
	psps = asps;
	pprs = aprs;
	while (cprop-- > 0)
	{
	    ULONG cbprop;
	    BOOLEAN fHasName;
	
	    PROPASSERT(*ppid != PID_DICTIONARY && *ppid != PID_CODEPAGE);
	    fHasName = FALSE;

	    if ((Flags & ENUMPROP_NONAMES) == 0)
	    {
                fHasName = ppsstm->QueryPropertyNames( 1, ppid, &poszName, &Status );
                if( !NT_SUCCESS(Status) ) goto Exit;
	    }

	    if (pprs != NULL)
	    {
		PROPASSERT(pprs->ulKind == PRSPEC_PROPID);
		if (fHasName)
		{
		    pprs->lpwstr = ppsstm->DuplicatePropertyName(
						poszName,
						(ocslen(poszName)+1)*sizeof(OLECHAR),
                                                &Status);
                    if( !NT_SUCCESS(Status) ) goto Exit;
		    PROPASSERT(pprs->lpwstr != NULL);

		    // Make this assignment *after* memory allocation
		    // succeeds so we free only valid pointers in below
		    // cleanup code.
		    pprs->ulKind = PRSPEC_LPWSTR;
		}
		else
		{
		    pprs->propid = *ppid;
		}
		pprs++;

	    }   // if (pprs != NULL)

	    if (psps != NULL)
	    {
		pprop = ppsstm->GetValue(*ppid, &cbprop, &Status);
                if( !NT_SUCCESS(Status) ) goto Exit;

		PROPASSERT(psps->lpwstrName == NULL);
		if (fHasName)
		{
		    psps->lpwstrName = ppsstm->DuplicatePropertyName(
						poszName,
						(ocslen(poszName)+1)*sizeof(OLECHAR),
                                                &Status);
                    if( !NT_SUCCESS(Status) ) goto Exit;
                    PROPASSERT(psps->lpwstrName != NULL);
		}

                psps->propid = *ppid;
		psps->vt = (VARTYPE) PropByteSwap( pprop->dwType );

		psps++;

	    }   // if (psps != NULL)
	
            ppid++;
            CoTaskMemFree( poszName ); poszName = NULL;

	}   // while (cprop-- > 0)
    }   // if (ppid != NULL)

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( NULL != poszName )
        CoTaskMemFree( poszName );

    CoTaskMemFree( ppidBase );

    if (!NT_SUCCESS(Status))
    {
        PMemoryAllocator *pma = ppsstm->GetAllocator();

        if (aprs != NULL)
        {
            for (i = 0; i < cpropin; i++)
            {
                if (aprs[i].ulKind == PRSPEC_LPWSTR)
                {
                    pma->Free(aprs[i].lpwstr);
                    aprs[i].ulKind = PRSPEC_PROPID;
                }
            }
        }

        if (asps != NULL)
        {
            for (i = 0; i < cpropin; i++)
            {
                if (asps[i].lpwstrName != NULL)
                {
                    pma->Free(asps[i].lpwstrName);
                    asps[i].lpwstrName = NULL;
                }
            }
        }
    }   // if (!NT_SUCCESS(Status))

#if DBG
    if (NT_SUCCESS(Status))
    {
	if (aprs != NULL)
	{
	    for (i = 0; i < cpropin; i++)
	    {
		if (aprs[i].ulKind == PRSPEC_LPWSTR)
		{
		    PROPASSERT(aprs[i].lpwstr != NULL);
		    PROPASSERT(ocslen(aprs[i].lpwstr) > 0);
		}
	    }
	}
	if (asps != NULL)
	{
	    for (i = 0; i < cpropin; i++)
	    {
		if (asps[i].lpwstrName != NULL)
		{
		    PROPASSERT(ocslen(asps[i].lpwstrName) > 0);
		}
	    }
	}
    }
#endif // DBG

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrQueryPropertyNames, public
//
// Synopsis:    Read property names for PROPIDs in a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [apid]           -- array of PROPIDs
//              [aposz]          -- array of pointers to WCHAR strings
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[])       // OUT pointers to allocated strings
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusQuery = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrQueryPropertyNames" );
    propTraceParameters(( "np=%p, cprop=%d, apid=%p, aposz=%p)",
                           np,    cprop,    apid,    aposz ));

    RtlZeroMemory(aposz, cprop * sizeof(aposz[0]));

    Status = ppsstm->Lock(FALSE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // We'll save the Status from the following call.  If there
    // are no other errors, we'll return it to the caller (it
    // might contain a useful success code).

    ppsstm->QueryPropertyNames(cprop, apid, aposz, &StatusQuery);
    if( !NT_SUCCESS(StatusQuery) )
    {
        Status = StatusQuery;
        goto Exit;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( NT_SUCCESS(Status) )
        Status = StatusQuery;

    return(Status);

}   // PrQueryPropertyNames()


//+---------------------------------------------------------------------------
// Function:    PrSetPropertyNames, public
//
// Synopsis:    Write property names for PROPIDs in a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [apid]           -- array of PROPIDs
//              [aposz]          -- array of pointers to OLECHAR strings
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[]) // pointers to property names
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrSetPropertyNames" );
    propTraceParameters(( "np=%p, cprop=%d, apid=%p, aposz=%p",
                           np,    cprop,    apid,    aposz ));

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->SetPropertyNames(cprop, apid, aposz, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    return(Status);

}   // PrSetPropertyNames()


//+---------------------------------------------------------------------------
// Function:    PrSetPropertySetClassId, public
//
// Synopsis:    Set the property set's ClassId
//
// Arguments:   [np]    -- property set context
//              [pspss] -- pointer to STATPROPSETSTG
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid)      // new CLASSID of propset code
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrSetPropertySetClassId" );
    propTraceParameters(( "np=%p, pclsid=%p", np, pclsid ));

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->SetClassId(pclsid, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    return(Status);

}   // PrSetPropertySetClassId()


//+---------------------------------------------------------------------------
// Function:    PrQueryPropertySet, public
//
// Synopsis:    Query the passed property set
//
// Arguments:   [np]    -- property set context
//              [pspss] -- pointer to STATPROPSETSTG
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss)  // buffer for property set stat information
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrQueryPropertySet" );
    propTraceParameters(( "np=%p, pspss=%p", np, pspss ));

    RtlZeroMemory(pspss, sizeof(*pspss));

    Status = ppsstm->Lock(FALSE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->QueryPropertySet(pspss, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    return(Status);

}   // PrQueryPropertySet()


inline BOOLEAN
_Compare_VT_BOOL(VARIANT_BOOL bool1, VARIANT_BOOL bool2)
{
    // Allow any non-zero value to match any non-zero value

    return((bool1 == FALSE) == (bool2 == FALSE));
}


BOOLEAN
_Compare_VT_CF(CLIPDATA *pclipdata1, CLIPDATA *pclipdata2)
{
    BOOLEAN fSame;

    if (pclipdata1 != NULL && pclipdata2 != NULL)
    {
        fSame = ( pclipdata1->cbSize == pclipdata2->cbSize
                  &&
                  pclipdata1->ulClipFmt == pclipdata2->ulClipFmt );

        if (fSame)
        {
            if (pclipdata1->pClipData != NULL && pclipdata2->pClipData != NULL)
            {
                fSame = memcmp(
                            pclipdata1->pClipData,
                            pclipdata2->pClipData,
                            CBPCLIPDATA(*pclipdata1)
                              ) == 0;
            }
            else
            {
                // They're the same if both are NULL, or if
                // they have a zero length (if they have a zero
                // length, either one may or may not be NULL, but they're
                // still considered the same).
                // Note that CBPCLIPDATA(*pclipdata1)==CBPCLIPDATA(*pclipdata2).

                fSame = pclipdata1->pClipData == pclipdata2->pClipData
                        ||
                        CBPCLIPDATA(*pclipdata1) == 0;
            }
        }
    }
    else
    {
        fSame = pclipdata1 == pclipdata2;
    }
    return(fSame);
}


//+---------------------------------------------------------------------------
// Function:    PrCompareVariants, public
//
// Synopsis:    Compare two passed PROPVARIANTs -- case sensitive for strings
//
// Arguments:   [CodePage]      -- CodePage
//              [pvar1]         -- pointer to PROPVARIANT
//              [pvar2]         -- pointer to PROPVARIANT
//
// Returns:     TRUE if identical, else FALSE
//---------------------------------------------------------------------------

#ifdef _MAC
EXTERN_C    // The Mac linker doesn't seem to be able to export with C++ decorations
#endif

BOOLEAN
PrCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2)
{
    if (pvar1->vt != pvar2->vt)
    {
        return(FALSE);
    }

    BOOLEAN fSame;
    ULONG i;

    switch (pvar1->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        fSame = TRUE;
        break;

    case VT_I1:
    case VT_UI1:
        fSame = pvar1->bVal == pvar2->bVal;
        break;

    case VT_I2:
    case VT_UI2:
        fSame = pvar1->iVal == pvar2->iVal;
        break;

    case VT_BOOL:
        fSame = _Compare_VT_BOOL(pvar1->boolVal, pvar2->boolVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        fSame = pvar1->lVal == pvar2->lVal;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        fSame = pvar1->hVal.HighPart == pvar2->hVal.HighPart
                &&
                pvar1->hVal.LowPart  == pvar2->hVal.LowPart;
        break;

    case VT_CLSID:
        fSame = memcmp(pvar1->puuid, pvar2->puuid, sizeof(CLSID)) == 0;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        fSame = ( pvar1->blob.cbSize == pvar2->blob.cbSize );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->blob.pBlobData,
                        pvar2->blob.pBlobData,
                        pvar1->blob.cbSize) == 0;
        }
        break;

    case VT_CF:
        fSame = _Compare_VT_CF(pvar1->pclipdata, pvar2->pclipdata);
        break;

    case VT_BSTR:
        if (pvar1->bstrVal != NULL && pvar2->bstrVal != NULL)
        {
            fSame = ( BSTRLEN(pvar1->bstrVal) == BSTRLEN(pvar2->bstrVal) );
            if (fSame)
            {
                fSame = memcmp(
                            pvar1->bstrVal,
                            pvar2->bstrVal,
                            BSTRLEN(pvar1->bstrVal)) == 0;
            }
        }
        else
        {
            fSame = pvar1->bstrVal == pvar2->bstrVal;
        }
        break;

    case VT_LPSTR:
        if (pvar1->pszVal != NULL && pvar2->pszVal != NULL)
        {
            fSame = strcmp(pvar1->pszVal, pvar2->pszVal) == 0;
        }
        else
        {
            fSame = pvar1->pszVal == pvar2->pszVal;
        }
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_LPWSTR:
        if (pvar1->pwszVal != NULL && pvar2->pwszVal != NULL)
        {
            fSame = Prop_wcscmp(pvar1->pwszVal, pvar2->pwszVal) == 0;
        }
        else
        {
            fSame = pvar1->pwszVal == pvar2->pwszVal;
        }
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        fSame = ( pvar1->caub.cElems == pvar2->caub.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->caub.pElems,
                        pvar2->caub.pElems,
                        pvar1->caub.cElems * sizeof(pvar1->caub.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
        fSame = ( pvar1->cai.cElems == pvar2->cai.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cai.pElems,
                        pvar2->cai.pElems,
                        pvar1->cai.cElems * sizeof(pvar1->cai.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_BOOL:
        fSame = ( pvar1->cabool.cElems == pvar2->cabool.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->cabool.cElems; i++)
            {
                fSame = _Compare_VT_BOOL(
                                pvar1->cabool.pElems[i],
                                pvar2->cabool.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        fSame = ( pvar1->cal.cElems == pvar2->cal.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cal.pElems,
                        pvar2->cal.pElems,
                        pvar1->cal.cElems * sizeof(pvar1->cal.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        fSame = ( pvar1->cah.cElems == pvar2->cah.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cah.pElems,
                        pvar2->cah.pElems,
                        pvar1->cah.cElems *
                            sizeof(pvar1->cah.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CLSID:
        fSame = ( pvar1->cauuid.cElems == pvar2->cauuid.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cauuid.pElems,
                        pvar2->cauuid.pElems,
                        pvar1->cauuid.cElems *
                            sizeof(pvar1->cauuid.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CF:
        fSame = ( pvar1->caclipdata.cElems == pvar2->caclipdata.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->caclipdata.cElems; i++)
            {
                fSame = _Compare_VT_CF(
                                &pvar1->caclipdata.pElems[i],
                                &pvar2->caclipdata.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_BSTR:
        fSame = ( pvar1->cabstr.cElems == pvar2->cabstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->cabstr.cElems; i++)
            {
                if (pvar1->cabstr.pElems[i] != NULL &&
                    pvar2->cabstr.pElems[i] != NULL)
                {
                    fSame = ( BSTRLEN(pvar1->cabstr.pElems[i])
                              ==
                              BSTRLEN(pvar2->cabstr.pElems[i]) );
                    if (fSame)
                    {
                        fSame = memcmp(
                                    pvar1->cabstr.pElems[i],
                                    pvar2->cabstr.pElems[i],
                                    BSTRLEN(pvar1->cabstr.pElems[i])) == 0;
                    }
                }
                else
                {
                    fSame = pvar1->cabstr.pElems[i] == pvar2->cabstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        fSame = ( pvar1->calpstr.cElems == pvar2->calpstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->calpstr.cElems; i++)
            {
                if (pvar1->calpstr.pElems[i] != NULL &&
                    pvar2->calpstr.pElems[i] != NULL)
                {
                    fSame = strcmp(
                                pvar1->calpstr.pElems[i],
                                pvar2->calpstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpstr.pElems[i] ==
                            pvar2->calpstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        fSame = ( pvar1->calpwstr.cElems == pvar2->calpwstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->calpwstr.cElems; i++)
            {
                if (pvar1->calpwstr.pElems[i] != NULL &&
                    pvar2->calpwstr.pElems[i] != NULL)
                {
                    fSame = Prop_wcscmp(
                                pvar1->calpwstr.pElems[i],
                                pvar2->calpwstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpwstr.pElems[i] ==
                            pvar2->calpwstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        fSame = ( pvar1->capropvar.cElems == pvar2->capropvar.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->capropvar.cElems; i++)
            {
                fSame = PrCompareVariants(
                                CodePage,
                                &pvar1->capropvar.pElems[i],
                                &pvar2->capropvar.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT Comparison");
        fSame = FALSE;
        break;

    }
    return(fSame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\nffmstm.cxx ===
//+============================================================================
//
//  File:   nffmstm.cxx
//
//  This file provides the NFF (NTFS Flat File) IMappedStream implementation.
//
//  History:
//      5/6/98  MikeHill
//              -   Misc dbg cleanup.
//
//+============================================================================

#include <pch.cxx>



CNFFMappedStream::~CNFFMappedStream()
{
    HRESULT hr = S_OK;

    // If the update stream has the latest data, rename it over the original
    // stream.  Ordinarily this replace call will create a new update stream.
    // But since we're going away, tell it not to bother.
    // Errors are ignored here because there's no way to return them.
    // If the caller wishes to avoid this, they should call Flush first.

    if( NULL != _pstmUpdate )
    {
        ReplaceOriginalWithUpdate( DONT_CREATE_NEW_UPDATE_STREAM );
        DfpVerify( 0 == RELEASE_INTERFACE(_pstmUpdate) );
    }


    // Just to be safe, free the mapping buffer (it should have
    // already been freed).

    DfpAssert( NULL == _pbMappedStream );
    CoTaskMemFree( _pbMappedStream );

    // If we've got the global reserved buffer locked,
    // free it now.

    if (_fLowMem)
        g_ReservedMemory.UnlockMemory();

}




HRESULT
CNFFMappedStream::QueryInterface( REFIID riid, void**ppvObject )
{
    return( _pnffstm->QueryInterface( riid, ppvObject ));
}

ULONG
CNFFMappedStream::AddRef()
{
    return( _pnffstm->AddRef() );
}

ULONG
CNFFMappedStream::Release()
{
    return( _pnffstm->Release() );
}



//+----------------------------------------------------------------------------
//
//  Method:     CNFFMappedStream::Open (IMappedStream)
//
//+----------------------------------------------------------------------------


VOID
CNFFMappedStream::Open( IN VOID  *powner, OUT LONG *phr )
{
    nffITrace( "CNFFMappedStream::Open" );
    VOID *pv = NULL;
    HRESULT sc=S_OK;

    BOOL fUsingLatestStream = FALSE;

    DfpAssert(!_fLowMem);

    _pnffstm->Lock( INFINITE );

    nffChk( _pnffstm->CheckReverted() );

    // If the previous open crashed during a flush, roll forward to the
    // updated copy.  If we're only open for read access, then this will
    // just set _fUpdateStreamHasLatest so that we'll know to process
    // reads from that stream.

    nffChk( RollForwardIfNecessary() );

    BeginUsingLatestStream();
    fUsingLatestStream = TRUE;

    // If given a pointer to the owner of this mapped stream,
    // save it.  This could be NULL (i.e., when called from
    // ReOpen).

    if( NULL != powner  )
        _pMappedStreamOwner = powner;

    // If we haven't already read the stream, read it now.

    if( NULL == _pbMappedStream )
    {
        BY_HANDLE_FILE_INFORMATION fileinfo;

        DfpAssert( INVALID_HANDLE_VALUE != _pnffstm->GetFileHandle() );
        DfpAssert( 0 == _cbMappedStream );
        DfpAssert( 0 == _cbMappedStreamActual);

        // Get and validate the size of the file

        if( !GetFileInformationByHandle( _pnffstm->GetFileHandle(), &fileinfo ))
        {
            nffErr( EH_Err, LAST_SCODE );
        }
        else if( 0 != fileinfo.nFileSizeHigh
                 || CBMAXPROPSETSTREAM < fileinfo.nFileSizeLow )
        {
            nffErr( EH_Err, STG_E_INVALIDHEADER );
        }

        _cbMappedStream = _cbMappedStreamActual = fileinfo.nFileSizeLow;

        // Allocate a buffer to hold the Stream.  If there isn't sufficient
        // memory in the system, lock and get the reserved buffer.  In the
        // end, 'pv' points to the appropriate buffer.

#if DBG
        pv = _fSimulateLowMem ? NULL : CoTaskMemAlloc( _cbMappedStreamActual );
#else
        pv = CoTaskMemAlloc( _cbMappedStreamActual );
#endif

        if( NULL == pv )
        {
            // could block until previous property call completes
            pv = g_ReservedMemory.LockMemory();

            if( NULL == pv )
                nffErr( EH_Err, E_OUTOFMEMORY );

            _fLowMem = TRUE;
        }
        _pbMappedStream = (BYTE*) pv;

        // Read in the file.

        if( 0 != _cbMappedStreamActual )
        {
            ULARGE_INTEGER ulOffset;
            ulOffset.QuadPart = 0;

            if( FAILED(_pnffstm->SyncReadAtFile( ulOffset, _pbMappedStream,
                                                 _cbMappedStreamActual, &_cbMappedStream)))
            {
                nffErr( EH_Err, LAST_SCODE );
            }


            // Ensure that we got all the bytes we requested.

            if( _cbMappedStream != _cbMappedStreamActual )
            {
                propDbg((DEBTRACE_ERROR,
                         "CMappedStreamOnHFile(%08X)::Open bytes-read (%lu) doesn't match bytes-requested (%lu)\n",
                         this, _cbMappedStream, _cbMappedStreamActual ));
                nffErr( EH_Err, STG_E_INVALIDHEADER );
            }
        }


#if BIGENDIAN==1
        // Notify our owner that we've read in new data.

        if( _pMappedStreamOwner != NULL && 0 != _cbMappedStream )
        {
            nffChk( PrOnMappedStreamEvent( _pMappedStreamOwner, _pbMappedStream, _cbMappedStream ) );
        }
#endif

    }   // if( NULL == _pbMappedStream )

    //  ----
    //  Exit
    //  ----

EH_Err:

    if( fUsingLatestStream )
        EndUsingLatestStream();

    // If there was an error, free any memory we have.

    if( FAILED(sc) )
    {
        propDbg((DEB_ERROR, "IMappedStream::CNtfsStream(%08X)::Open exception returns %08X\n", this, *phr));

        if (_fLowMem)
            g_ReservedMemory.UnlockMemory();
        else
            CoTaskMemFree(pv);

        _pbMappedStream = NULL;
        _cbMappedStream = _cbMappedStreamActual = 0;
        _fLowMem = FALSE;
    }

    _pnffstm->Unlock();
    *phr = sc;
    return;

}


//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Flush (IMappedStream)
//
//--------------------------------------------------------------------

VOID CNFFMappedStream::Flush(OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::Flush" );
    HRESULT sc=S_OK;
    BOOL fUsingLatestStream = FALSE;

    _pnffstm->Lock( INFINITE );;

    BeginUsingLatestStream();
    fUsingLatestStream = TRUE;

    nffChk( _pnffstm->CheckReverted() );

    if( !IsWriteable() )
        nffErr( EH_Err, STG_E_ACCESSDENIED );


    // If the IMappedStream is being used, write it out to the
    // underlying file.

    if( NULL != _pbMappedStream )
        nffChk( WriteMappedStream() );

    // Commit the Stream.
    if( !FlushFileBuffers( _pnffstm->GetFileHandle() ))
        nffErr( EH_Err, LAST_SCODE );

    EndUsingLatestStream();
    fUsingLatestStream = FALSE;

    nffChk( ReplaceOriginalWithUpdate( CREATE_NEW_UPDATE_STREAM ));

    sc = S_OK;

EH_Err:

    if( fUsingLatestStream )
        EndUsingLatestStream();

    _pnffstm->Unlock();
    *phr = sc;
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     IMappedStream::Close
//
//  Synopsis:   Close the mapped stream by writing out
//              the mapping buffer and then freeing it.
//              Errors are ignored, so if the caller wants an
//              opportunity to recover from an error, they should
//              call Flush before calling Close.
//
//  Arguments:  [LONG*] phr
//                  An HRESULT error code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CNFFMappedStream::Close(OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::Close" );
    HRESULT sc=S_OK;

    _pnffstm->Lock( INFINITE );

    // So watch out for multiple closes.
    sc = _pnffstm->CheckReverted();

    // If we are already closed then return immediatly (but don't error)
    if( STG_E_REVERTED == sc )
    {
        sc = S_OK;
        goto EH_Err;
    }

    // Report any real errors.
    if( FAILED( sc ) )
        nffErr( EH_Err, sc );

    // Write the changes.  We don't need to Commit them,
    // they will be implicitely committed when the
    // Stream is Released.

    sc = WriteMappedStream();

    // Even if we fail the write, we must free the memory.
    // (PrClosePropertySet deletes everything whether or not
    // there was an error here, so we must free the memory.
    // There's no danger of this happenning due to out-of-
    // disk-space conditions, because the propset code
    // pre-allocates).

    CoTaskMemFree( _pbMappedStream );
    _pbMappedStream = NULL;

    // Re-zero the member data.
    InitMappedStreamMembers();

    sc = S_OK;

EH_Err:

    _pnffstm->Unlock();
    *phr = sc;
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::ReOpen (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::ReOpen" );
    HRESULT sc=S_OK;

    *ppv = NULL;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    this->Open(NULL, &sc);
    nffChk(sc);

    *ppv = _pbMappedStream;

EH_Err:
    _pnffstm->Unlock();
    *phr = sc;
    return;

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Quiesce (IMappedStream)
//
//--------------------------------------------------------------------

VOID CNFFMappedStream::Quiesce(VOID)
{
    nffITrace( "CNFFMappedStream::Quiesce" );
    // Not necessary for this implemented
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Map (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::Map(IN BOOLEAN fCreate, OUT VOID **ppv)
{
    nffITrace( "CNFFMappedStream::Map" );
    HRESULT sc;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    DfpAssert(_pbMappedStream != NULL);
    *ppv = _pbMappedStream;

EH_Err:
    _pnffstm->Unlock();
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Unmap (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::Unmap(BOOLEAN fFlush, VOID **ppv)
{
    nffITrace( "CNFFMappedStream::Unmap" );

    *ppv = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::WriteMappedStream (internal support for IMappedStream)
//
//  Returns:    S_OK if successful, S_FALSE if there was nothing to write.
//
//--------------------------------------------------------------------
#define STACK_BYTES 16

HRESULT
CNFFMappedStream::WriteMappedStream()
{
    nffITrace( "CNFFMappedStream::WriteMappedStream" );
    HRESULT sc = S_OK;
    ULONG cbWritten;
    BOOL fOwnerSignaled = FALSE;
    BOOL fUsingUpdateStream = FALSE;

    // We can return right away if there's nothing to write.
    // (_pbMappedStream may be NULL in the error path of our
    // caller).

    if (!IsModified() || NULL == _pbMappedStream )
    {
        propDbg((DEB_TRACE, "IMappedStream::CNtfsStream(%08X)::Flush returns with not-dirty\n", this));
        return S_FALSE;
    }

    // Put the update stream's handle into _pnffstm, so that we write out to it.

    BeginUsingUpdateStream();
    fUsingUpdateStream = TRUE;

    DfpAssert( INVALID_HANDLE_VALUE != _pnffstm->GetFileHandle() );

#if BIGENDIAN==1
    // Notify our owner that we're about to perform a Write.
    nffChk( PrOnMappedStreamEvent( _powner, _pbMappedStream, _cbMappedStream ) );
    fOwnerSignaled = TRUE;
#endif

    // Write out the mapping buffer (to the update stream).

    ULARGE_INTEGER ulOffset;
    ulOffset.QuadPart = 0;

    nffChk( _pnffstm->SyncWriteAtFile( ulOffset, _pbMappedStream,
                                       _cbMappedStream, &cbWritten ));

    if( cbWritten != _cbMappedStream )
    {
        propDbg((DEB_ERROR,
                 "CMappedStreamOnHFile(%08X)::Write bytes-written (%lu) doesn't match bytes-requested (%lu)\n",
                 this, cbWritten, _cbMappedStream ));
        sc = STG_E_INVALIDHEADER;
        goto EH_Err;
    }

    // If the buffer is shrinking, this is a good time to shrink the file.
    if (_cbMappedStream < _cbMappedStreamActual)
    {
        nffChk( _pnffstm->SetSize( static_cast<CULargeInteger>(_cbMappedStream) ) );
        _cbMappedStreamActual = _cbMappedStream;
    }

    if( _fStreamRenameSupported )
    {
        // We wrote the data to the update stream.  So flag that it now
        // has the latest data.

        _fUpdateStreamHasLatest = TRUE;
        DfpAssert( NULL != _pstmUpdate && INVALID_HANDLE_VALUE != _pstmUpdate->GetFileHandle() );
    }

    //  ----
    //  Exit
    //  ----

EH_Err:

#if BIGENDIAN==1
    // Notify our owner that we're done with the Write.  We do this
    // whether or not there was an error, because _pbMappedStream is
    // not modified, and therefore intact even in the error path.

    if( fOwnerSignaled )
    {
        DfpVerify( PrOnMappedStreamEvent( _powner,
                                    _pbMappedStream, _cbMappedStream ) );
    }
#endif

    if( fUsingUpdateStream )
        EndUsingUpdateStream();

    if (sc == S_OK || sc == STG_E_REVERTED)
    {
        _fMappedStreamDirty = FALSE;
    }

    propDbg(( DbgFlag(sc,DEB_ITRACE), "CNtfsStream(%08X)::Write %s returns hr=%08X\n",
              this, sc != S_OK ? "exception" : "", sc));

    return sc;

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::GetSize (IMappedStream)
//
//--------------------------------------------------------------------

ULONG CNFFMappedStream::GetSize(OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::GetSize" );
    HRESULT sc=S_OK;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    // If necessary, open the Stream.

    if( NULL == _pbMappedStream )
    {
        this->Open(NULL, &sc);
    }

    if( SUCCEEDED(sc) )
    {
        DfpAssert( NULL != _pbMappedStream );
    }

    // Return the size of the mapped stream.  If there was an
    // Open error, it will be zero, and *phr will be set.

EH_Err:
    _pnffstm->Unlock();
    *phr = sc;

    return _cbMappedStream;
}


//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::InitMappedStreamMembers
//
//--------------------------------------------------------------------

void
CNFFMappedStream::InitMappedStreamMembers()
{
    nffITrace( "CNFFMappedStream::InitMappedStreamMembers" );

    _pbMappedStream = NULL;
    _cbMappedStream = 0;
    _cbMappedStreamActual = 0;
    _pMappedStreamOwner = NULL;
    _fLowMem = FALSE;
    _fMappedStreamDirty = FALSE;

    _fCheckedForRollForward = FALSE;
    _fStreamRenameSupported = FALSE;

    _cUpdateStreamInUse = _cLatestStreamInUse = 0;
}


//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::SetSize (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::SetSize(IN ULONG cb,
                     IN BOOLEAN fPersistent,
                     IN OUT VOID **ppv, OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::SetSize" );
    BYTE  *pv;

    HRESULT &sc = *phr;
    BOOL fUsingUpdateStream = FALSE, fUsingLatestStream = FALSE;

    DfpAssert(cb != 0);

    sc = S_OK;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    if( CBMAXPROPSETSTREAM < cb )
        nffErr( EH_Err, STG_E_MEDIUMFULL );

    if( fPersistent )
    {
        nffChk( CreateUpdateStreamIfNecessary() );
        BeginUsingUpdateStream();
        fUsingUpdateStream = TRUE;
    }
    else
    {
        BeginUsingLatestStream();
        fUsingLatestStream = TRUE;
    }

    // if we are growing the data, we should grow the file

    if( fPersistent && cb > _cbMappedStreamActual )
    {
        nffChk( _pnffstm->SetFileSize( CULargeInteger(cb) ) );
        _cbMappedStreamActual = cb;
    }

    // We only get here if we either (1) didn't want to grow the
    // underlying stream, or (2) we successfully grew the underlying stream.

    // Re-size the buffer to the size specified in cb.

    if( _fLowMem )
    {
        // If we want to grow the buffer In low-memory conditions,
        // no realloc is necessary, because
        // _pbMappedStream is already large enough for the largest
        // property set.

        if( NULL != ppv )
            *ppv = _pbMappedStream;
    }
    else if ( cb != _cbMappedStream )
    {

        // We must re-alloc the buffer.

#if DBG
        pv = _fSimulateLowMem ? NULL : (PBYTE) CoTaskMemRealloc( _pbMappedStream, cb );
#else
        pv = (PBYTE)CoTaskMemRealloc( _pbMappedStream, cb );
#endif

        if ((pv == NULL) )
        {
            // allocation failed: we need to try using a backup mechanism for
            // more memory.
            // copy the data to the global reserved chunk... we will wait until
            // someone else has released it.  it will be released on the way out
            // of the property code.

            pv = g_ReservedMemory.LockMemory();

            if( NULL == pv )
                nffErr( EH_Err, E_OUTOFMEMORY );

            _fLowMem = TRUE;

            if( NULL != _pbMappedStream )
            {
                memcpy( pv, _pbMappedStream, _cbMappedStream );
            }
            CoTaskMemFree( _pbMappedStream );
        }

        _pbMappedStream = pv;

        if( NULL != ppv )
            *ppv = pv;
    }
    _cbMappedStream = cb;

    //  ----
    //  Exit
    //  ----

EH_Err:

    if( fUsingUpdateStream )
    {
        DfpAssert( !fUsingLatestStream );
        EndUsingUpdateStream();
    }
    else if( fUsingLatestStream )
    {
        EndUsingLatestStream();
    }

    _pnffstm->Unlock();

    if( FAILED(*phr) )
    {
        propDbg((DbgFlag(*phr,DEB_ITRACE), "IMappedStream::CNtfsStream(%08X)::SetSize %s returns hr=%08X\n",
                this, *phr != S_OK ? "exception" : "", *phr));
    }

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Lock (IMappedStream)
//
//--------------------------------------------------------------------

NTSTATUS
CNFFMappedStream::Lock(IN BOOLEAN fExclusive)
{
    // Don't trace at this level.  The noice is too great!
    //nffXTrace( "CNFFMappedStream::Lock");

    UNREFERENCED_PARM(fExclusive);
    _pnffstm->Lock( INFINITE );
    return(STATUS_SUCCESS);

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Unlock (IMappedStream)
//
//--------------------------------------------------------------------

// Should we unlock even if there's an error?
NTSTATUS
CNFFMappedStream::Unlock(VOID)
{
    // Don't trace at this level.  The noice is too great!
    //nffXTrace( "CNFFMappedStream::Unlock");
    // if at the end of the properties set/get call we have the low
    // memory region locked, we flush to disk.
    HRESULT sc = S_OK;

    if (_fLowMem)
    {
        Flush(&sc);

        g_ReservedMemory.UnlockMemory();
        _pbMappedStream = NULL;
        _cbMappedStream = _cbMappedStreamActual = 0;
        _fLowMem = FALSE;
        propDbg((DEB_PROP_INFO, "CMappedStreamOnHFile(%08X):Unlock low-mem returns NTSTATUS=%08X\n",
            this, sc));
    }

    _pnffstm->Unlock();

    return(sc);

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::QueryTimeStamps (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::QueryTimeStamps(OUT STATPROPSETSTG *pspss, BOOLEAN fNonSimple) const
{
    nffITrace( "CNFFMappedStream::QueryTimeStamps" );
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::QueryModifyTime (IMappedStream)
//
//--------------------------------------------------------------------

BOOLEAN
CNFFMappedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    nffITrace( "CNFFMappedStream::QueryModifyTime" );
    return(FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     Unused methods by this IMappedStream implementation:
//              QuerySecurity, IsWritable, GetHandle
//
//--------------------------------------------------------------------

BOOLEAN
CNFFMappedStream::QuerySecurity(OUT ULONG *pul) const
{
    nffITrace( "CNFFMappedStream::QuerySecurity" );
    return(FALSE);
}

BOOLEAN
CNFFMappedStream::IsWriteable() const
{
    nffITrace( "CNFFMappedStream::IsWriteable" );
    return( (BOOLEAN) _pnffstm->IsWriteable() );
}

HANDLE
CNFFMappedStream::GetHandle(VOID) const
{
    nffITrace( "CNFFMappedStream::GetHandle" );
    return(INVALID_HANDLE_VALUE);
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::SetModified/IsModified (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::SetModified(OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::SetModified" );
    HRESULT &sc = *phr;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    nffChk( CreateUpdateStreamIfNecessary() );

    _fMappedStreamDirty = TRUE;
    sc = S_OK;

EH_Err:

    _pnffstm->Unlock();
}

BOOLEAN
CNFFMappedStream::IsModified(VOID) const
{
    nffITrace( "CNFFMappedStream::IsModified" );
    return _fMappedStreamDirty;
}

//+-------------------------------------------------------------------
//
//  Member:     ImappedStream::IsNtMappedStream/SetChangePending
//
//  Synopsis:   Debug routines.
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN
CNFFMappedStream::IsNtMappedStream(VOID) const
{
    nffITrace( "CNFFMappedStream::IsNtMappedStream" );
    return(TRUE);
}
#endif


#if DBGPROP
BOOLEAN
CNFFMappedStream::SetChangePending(BOOLEAN f)
{
    nffITrace( "CNFFMappedStream::SetChangePending" );
    return(f);
}
#endif


//
//  CNFFMappedStream::BeginUsingLatestStream/EndUsingLatestStream
//
//  These routines are similar to Begin/EndUsing*Update*Stream,
//  except that they honor the _fUpdateStreamHasLatest flag.
//  Thus, if the original stream has the latest data, then this
//  routine will do nothing.
//

void
CNFFMappedStream::BeginUsingLatestStream()
{
    if( _fUpdateStreamHasLatest )
    {
        if( 0 == _cLatestStreamInUse++ )
            BeginUsingUpdateStream();
    }
}

void
CNFFMappedStream::EndUsingLatestStream()
{
    if( 0 != _cLatestStreamInUse )
    {
        EndUsingUpdateStream();
        _cLatestStreamInUse--;
    }

    DfpAssert( static_cast<USHORT>(-1) != _cLatestStreamInUse );
}



//
//  CNFFMappedStream::BeginUsingUpdateStream
//
//  This is called when the update stream is to be used.  It
//  does nothing, though, if we don't have an update stream
//  (e.g. if the file system doesn't support stream renames).
//  We increment the _cUpdateStreamInUse count, so that we can determine in
//  EndUsingUpdateStream when to swap the handles back.

void
CNFFMappedStream::BeginUsingUpdateStream()
{
    if( NULL != _pstmUpdate
        &&
        INVALID_HANDLE_VALUE != _pstmUpdate->GetFileHandle()
        &&
        0 == _cUpdateStreamInUse++ )
    {
        HANDLE hTemp = _pnffstm->_hFile;
        _pnffstm->_hFile = _pstmUpdate->_hFile;
        _pstmUpdate->_hFile = hTemp;
    }

}

//
//  CNFFMappedStream::EndUsingUpdateStream
//
//  Decrement the _cUpdateStreamInUse count.  And, if that puts
//  the count down to zero, swap the handles back.
//

void
CNFFMappedStream::EndUsingUpdateStream()
{
    if( 0 != _cUpdateStreamInUse
        &&
        0 == --_cUpdateStreamInUse )
    {
        DfpAssert( NULL != _pstmUpdate && INVALID_HANDLE_VALUE != _pstmUpdate->GetFileHandle() );

        HANDLE hTemp = _pnffstm->_hFile;
        _pnffstm->_hFile = _pstmUpdate->_hFile;
        _pstmUpdate->_hFile = hTemp;
    }
    DfpAssert( static_cast<USHORT>(-1) != _cUpdateStreamInUse );
}


inline HRESULT
CNFFMappedStream::CreateUpdateStreamIfNecessary()
{
    if( _fStreamRenameSupported
        &&
        ( NULL == _pstmUpdate
          ||
          INVALID_HANDLE_VALUE == _pstmUpdate->GetFileHandle()
        )
      )
    {
        return( OpenUpdateStream( TRUE ));
    }
    else
        return( S_OK );
}


//+----------------------------------------------------------------------------
//
//  Method: CNFFMAppedStream::RollForwardIfNecessary (non-interface method)
//
//  In the open path, we look to see if there's a leftover update stream for
//  a previous open of the stream, which must have crashed during a write.
//  If we're opening for write, we fix the problem.  Otherwise, we
//  just remember that we'll have to read out of the update stream.
//
//  See the CNtfsStreamForPropStg class declaration for a description of
//  this transactioning.
//
//+----------------------------------------------------------------------------

HRESULT
CNFFMappedStream::RollForwardIfNecessary()
{
    HRESULT hr = S_OK;
    BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;

    // If we've already checked for this, then we needn't check again.
    if( _fCheckedForRollForward )
        goto Exit;

    // We also needn't do anything if we're creating, since that overwrites
    // any existing data anyway.

    if( !(STGM_CREATE & _pnffstm->_grfMode) )
    {
        // Get the size of the current stream.
        if( !GetFileInformationByHandle( _pnffstm->_hFile, &ByHandleFileInformation ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

        // If the size is zero, then there might be an update
        // stream with the real data.

        if( 0 == ByHandleFileInformation.nFileSizeLow
            &&
            0 == ByHandleFileInformation.nFileSizeHigh )
        {
            // See if there's an update stream
            hr = OpenUpdateStream( FALSE );
            if( SUCCEEDED(hr) )
            {
                // We have a zero-length main stream and an update stream,
                // so there must have been a crash in ReplaceOriginalWithUpdate,
                // after the truncation but before the NtSetInformationFile
                // (FileRenameInformation).

                // If this is a writable stream, rename the update stream
                // over the zero-length one.  Otherwise, we'll just read from
                // the update stream.

                _fUpdateStreamHasLatest = TRUE;

                if( IsWriteable() )
                {
                    hr = ReplaceOriginalWithUpdate( DONT_CREATE_NEW_UPDATE_STREAM );
                    if( FAILED(hr) ) goto Exit;
                }
            }
            else if( STG_E_FILENOTFOUND == hr )
                // Ignore the case where there's no update stream.  This happens
                // when the stream is created without STGM_CREATE set.
                hr = S_OK;
            else
                goto Exit;
        }
    }   // if( !(STGM_CREATE & _grfMode) )

    // We don't need to check for this again.
   _fCheckedForRollForward = TRUE;

Exit:

   return( hr );

}   // CNtfsStreamForPropStg::RollForwardIfNecessary


//+----------------------------------------------------------------------------
//
//  Method: CNtfsStreamForPropStg::ReplaceOriginalWithUpdate (internal method)
//
//  This method renames the update stream over the original stream, then
//  creates a new update stream (with no data but properly sized).  If, however,
//  the update stream doesn't have the latest data anyway, then this routine
//  noops.
//
//  See the CNtfsStreamForPropStg class declaration for a description of
//  this transactioning.
//
//+----------------------------------------------------------------------------

HRESULT
CNFFMappedStream::ReplaceOriginalWithUpdate( enumCREATE_NEW_UPDATE_STREAM CreateNewUpdateStream )
{
    HRESULT hr = S_OK;
    NTSTATUS status;

    FILE_END_OF_FILE_INFORMATION file_end_of_file_information;
    IO_STATUS_BLOCK io_status_block;

    // If the original stream already has the latest data, then
    // there's nothing to do.

    if( !_fUpdateStreamHasLatest )
        goto Exit;

    DfpAssert( NULL != _pstmUpdate );
    DfpAssert( 0 == _cUpdateStreamInUse );

    // We must write the update data all the way to disk.
    hr = _pstmUpdate->Flush();
    if( FAILED(hr) ) goto Exit;

    // Truncate the original stream so that it can be overwritten.
    // After this atomic operation, the update stream is considered
    // *the* stream (which is why we had to flush it above).

    file_end_of_file_information.EndOfFile = CLargeInteger(0);

    status = NtSetInformationFile( _pnffstm->_hFile, &io_status_block,
                                   &file_end_of_file_information,
                                   sizeof(file_end_of_file_information),
                                   FileEndOfFileInformation );
    if( !NT_SUCCESS(status) )
    {
        hr = NtStatusToScode(status);
        goto Exit;
    }

    NtClose( _pnffstm->_hFile );
    _pnffstm->_hFile = INVALID_HANDLE_VALUE;

    // Rename the updated stream over the original (now empty) stream.
    // This is atomic.

    hr = _pstmUpdate->Rename( _pnffstm->_pwcsName, TRUE );
    if( FAILED(hr) )
    {
        // Go into the reverted state
        NtClose( _pstmUpdate->_hFile );
        _pstmUpdate->_hFile = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    // Make the updated stream the master

    _pnffstm->_hFile = _pstmUpdate->_hFile;
    _pstmUpdate->_hFile = INVALID_HANDLE_VALUE;
    _fUpdateStreamHasLatest = FALSE;

    // Optionally create a new update stream.

    if( CREATE_NEW_UPDATE_STREAM == CreateNewUpdateStream )
    {
        // return an error if we cannot create the update stream
        hr = OpenUpdateStream( TRUE );
        if( FAILED(hr) ) goto Exit;
    }
    else
        DfpAssert( DONT_CREATE_NEW_UPDATE_STREAM == CreateNewUpdateStream );


Exit:

    return( hr );

}   // CNFFMappedStream::ReplaceOriginalWithUpdate()



//+----------------------------------------------------------------------------
//
//  Method: CNFFMappedStream::OpenUpdateStream
//
//  This method opens the update stream, to which stream updates are written.
//  This is necessary to provide a minimal level of transactioning.
//
//  See the CNtfsStreamForPropStg class declaration for a description of
//  this transactioning.
//
//+----------------------------------------------------------------------------

HRESULT
CNFFMappedStream::OpenUpdateStream( BOOL fCreate )
{
    HRESULT hr = S_OK;
    HANDLE hStream = INVALID_HANDLE_VALUE;
    CNtfsUpdateStreamName UpdateStreamName = _pnffstm->_pwcsName;

    // Open the NTFS stream

    hr = _pnffstm->_pnffstg->GetStreamHandle( &hStream,
                                             UpdateStreamName,
                                             _pnffstm->_grfMode | (fCreate ? STGM_CREATE : 0),
                                             fCreate );
    if( FAILED(hr) ) goto Exit;

    // If necessary, instantiate a CNtfsUpdateStreamForPropStg

    if( NULL == _pstmUpdate )
    {
        _pstmUpdate = new CNtfsUpdateStreamForPropStg( _pnffstm->_pnffstg, _pnffstm->_pBlockingLock );
        if( NULL == _pstmUpdate )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // Put the NTFS stream handle into the CNtfsUpdateStreamForPropStg

    hr = _pnffstm->_pnffstg->InitCNtfsStream( _pstmUpdate, hStream,
                                              _pnffstm->_grfMode | (fCreate ? STGM_CREATE : 0),
                                              UpdateStreamName );

    hStream = INVALID_HANDLE_VALUE; // ownership of the handle has changed

    if( FAILED(hr) ) goto Exit;

    // If we're creating the update stream, size it to match the size
    // of the original stream.

    if( fCreate )
    {
        ULONG ulSize = GetSize(&hr);
        if( FAILED(hr) ) goto Exit;

        hr = _pstmUpdate->SetSize( CULargeInteger(ulSize) );
        if( FAILED(hr) ) goto Exit;

    }


Exit:

    if( INVALID_HANDLE_VALUE != hStream )
        NtClose( hStream );

    if( FAILED(hr) )
    {
        // If we were attempting a create but failed, then ensure the
        // update stream is gone.

        if( NULL != _pstmUpdate && fCreate )
            _pstmUpdate->Delete();

        DfpVerify( 0 == RELEASE_INTERFACE(_pstmUpdate) );
    }

    return( hr );

}   // CNFFMappedStream::OpenUpdateStream()



//+----------------------------------------------------------------------------
//
//  Method: CNFFMappedStream::Init (override from CNtfsStream)
//
//  This method initializes the CNtfsStream, and checks the file system to
//  determine if we can support the update stream (for robustness).  The
//  necessary file system support is stream renaming, which we use to provide
//  a minimal level of transactioning.
//
//  See the CNtfsStreamForPropStg class declaration for a description of
//  this transactioning.
//
//+----------------------------------------------------------------------------

HRESULT
CNFFMappedStream::Init( HANDLE hFile )
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;

    FILE_FS_ATTRIBUTE_INFORMATION file_fs_attribute_information;
    IO_STATUS_BLOCK io_status_block;

    // Check to see if we'll be able to support stream renaming.

    if( NULL != _pnffstm->_pnffstg )
    {
        // We can at least see an IStorage for the file, so stream renaming
        // could potentially work, but we also need to query the file system
        // attributes to see if it actually supports it.

        status = NtQueryVolumeInformationFile( hFile, &io_status_block,
                                               &file_fs_attribute_information,
                                               sizeof(file_fs_attribute_information),
                                               FileFsAttributeInformation );

        // We should always get a buffer-overflow error here, because we don't
        // provide enough buffer for the file system name, but that's OK because
        // we don't need it (status_buffer_overflow is just a warning, so the rest
        // of the data is good).

        if( !NT_SUCCESS(status) && STATUS_BUFFER_OVERFLOW != status)
        {
            hr = NtStatusToScode(status);
            goto Exit;
        }

        // There's no attribute bit which says "supports stream rename".  The best
        // we can do is look for another NTFS5 feature and make an inferrence.

        if( FILE_SUPPORTS_OBJECT_IDS & file_fs_attribute_information.FileSystemAttributes )
            _fStreamRenameSupported = TRUE;
    }

Exit:

    return( hr );

}   // CNFFMappedStream::Init()




HRESULT
CNFFMappedStream::ShutDown()
{   // mikehill step
    HRESULT hr = S_OK;

    _pnffstm->Lock( INFINITE );

    // Close the mapped stream
    Close( &hr );
    if( FAILED(hr) && STG_E_REVERTED != hr )
        propDbg(( DEB_ERROR, "CNFFMappedStream(0x%x)::ShutDown failed call to CNtfsStream::Close (%08x)\n",
                             this, hr ));

    // Overwrite the original stream with the update (if necessary),
    // but don't bother to create a new update stream afterwards.

    if( NULL != _pstmUpdate )
    {
        hr = ReplaceOriginalWithUpdate( DONT_CREATE_NEW_UPDATE_STREAM );
        if( FAILED(hr) )
            propDbg(( DEB_ERROR, "CNFFMappedStream(0x%x)::ShutDown failed call to ReplaceOriginalWithUpdate (%08x)\n",
                             this, hr ));
    }

    // Release the update stream.
    if( NULL != _pstmUpdate )
        DfpVerify( 0 == RELEASE_INTERFACE(_pstmUpdate) );

    propDbg(( DbgFlag(hr,DEB_ITRACE), "CNFFMappedStream(0x%x)::ShutDown() returns %08x\n", this, hr ));

    _pnffstm->Unlock();
    return( hr );

}   // CNFFMappedStream::ShutDown


void
CNFFMappedStream::Read( void *pv, ULONG ulOffset, ULONG *pcbCopy )
{
    if( *pcbCopy > _cbMappedStream )
        *pcbCopy = 0;
    else if( *pcbCopy > _cbMappedStream - ulOffset )
        *pcbCopy = _cbMappedStream - ulOffset;

    memcpy( pv, &_pbMappedStream[ ulOffset ], *pcbCopy );

    return;
}


void
CNFFMappedStream::Write( const void *pv, ULONG ulOffset, ULONG *pcbCopy )
{
    if( *pcbCopy > _cbMappedStream )
        *pcbCopy = 0;
    else if( *pcbCopy + ulOffset > _cbMappedStream )
        *pcbCopy = _cbMappedStream - ulOffset;

    memcpy( &_pbMappedStream[ulOffset], pv, *pcbCopy );

    return;
}



//+----------------------------------------------------------------------------
//
//  Method:     IStorageTest::UseNTFS4Streams (DBG only)
//
//  This method can be used to disable the stream-renaming necessary for
//  robust property sets.  This emulates an NTFS4 volume.
//
//+----------------------------------------------------------------------------

#if DBG
HRESULT STDMETHODCALLTYPE
CNFFMappedStream::UseNTFS4Streams( BOOL fUseNTFS4Streams )
{
    HRESULT hr = S_OK;

    if( _fUpdateStreamHasLatest )
    {
        hr = STG_E_INVALIDPARAMETER;
        propDbg(( DEB_ERROR, "CNtfsStreamForPropStg(0x%x)::UseNTFS4Streams(%s)"
                             "was called while an update stream was already in use\n",
                             this, fUseNTFS4Streams ? "True" : "False" ));
    }
    else if( fUseNTFS4Streams )
    {
        DfpVerify( 0 == RELEASE_INTERFACE(_pstmUpdate) );
        _fStreamRenameSupported = FALSE;
    }
    else
    {
        // Shutting NTFS4streams off isn't implemented
        hr = E_NOTIMPL;
    }

    return( hr );

}   // CNFFMAppedStream::UseNTFS4Streams
#endif // #if DBG

#if DBG
HRESULT
CNFFMappedStream::GetFormatVersion( WORD *pw )
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT
CNFFMappedStream::SimulateLowMemory( BOOL fSimulate )
{
    _fSimulateLowMem = fSimulate;
    return( S_OK );
}
#endif // #if DBG

#if DBG
LONG
CNFFMappedStream::GetLockCount()
{
    return( _pnffstm->GetLockCount() );
}
#endif // #if DBG

#if DBG
HRESULT
CNFFMappedStream::IsDirty()
{
    return( _fMappedStreamDirty ? S_OK : S_FALSE );
}
#endif // #if DBG



//+----------------------------------------------------------------------------
//
//  Method: CNtfsUpdateStreamForPropStg::ShutDown (overrides CNtfsStream)
//
//  Override so that we can remove this stream from the linked-list, but
//  not do a flush.  See the CNtfsStreamForPropStg class declaration for
//  more information on this class.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsUpdateStreamForPropStg::ShutDown()
{
    RemoveSelfFromList();
    return( S_OK );
}   // CNtfsUpdateStreamForPropStg::ShutDown
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\propapi.cxx ===
//+==================================================================
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:   PropAPI.cxx
//
//          This file provides the Property Set API routines.
//
//  APIs:   StgCreatePropSetStg (creates an IPropertySetStorage)
//          StgCreatePropStg (creates an IPropertyStorage)
//          StgOpenPropStg (opens an IPropertyStorage)
//          StgCreateStorageOnHandle (private, not a public API)
//          StgOpenStorageOnHandle (private, not a public API)
//
//  History:
//
//      3/10/98  MikeHill   - Added StgCreate/OpenStorageOnHandle
//      5/6/98   MikeHill   - Rewrite StgCreate/OpenStorageOnHandle.
//      5/18/98     MikeHill
//                  -   Use new CPropertySetStorage constructor.
//
//+==================================================================

#include <pch.cxx>

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

//+------------------------------------------------------------------
//
//  Function:   QueryForIStream
//
//  Synopsis:   This routine queries an IUnknown for
//              an IStream interface.  This is isolated into
//              a separate routine because some workaround code
//              is required on the Mac.
//
//  Inputs:     [IUnknown*] pUnk
//                  The interface to be queried.
//              [IStream**] ppStm
//                  Location to return the result.
//
//  Returns:    [HRESULT]
//
//  Notes:      On older Mac implementations (<=2.08, <=~1996)
//              the memory-based IStream implementation
//              (created by CreateStreamOnHGlobal) had a bug
//              in QueryInterface:  when you QI for an
//              IStream or IUnknown, an addref is done, but an
//              HR of E_NOINTERFACE is returned.
//
//              Below, we look for this condition:  if we get an
//              E_NOINTERFACE on the Mac, we check to see if it's
//              an OLE mem-based IStream.  If it is, we simply cast
//              IUnknown as an IStream.  We validate it as an OLE
//              the mem-based IStream by creating one of our own, and
//              comparing the QueryInterface addresses.
//
//              This is some ugly code, but at least it is isolated,
//              only runs on the older Macs, and ensures that we
//              work on all platforms.
//
//+------------------------------------------------------------------


inline HRESULT QueryForIStream( IUnknown * pUnk, IStream** ppStm )
{
    HRESULT hr;

    // Attempt to get the interface
    hr = pUnk->QueryInterface( IID_IStream, (void**) ppStm );

#ifdef _MAC

    // On the Mac, if we get a no-interface error, see if it is really
    // a buggy mem-based IStream implementation.

    if( E_NOINTERFACE == hr )
    {
        IStream *pstmMem = NULL;

        // Create our own mem-based IStream.

        hr = CreateStreamOnHGlobal( NULL, TRUE, &pstmMem );
        if( FAILED(hr) ) goto Exit;

        // If the mem-based Stream's QI implementation has the same
        // address as the Unknown's QI implementation, then the Unknown
        // must be an OLE mem-based stream.

        if( pUnk->QueryInterface == pstmMem->QueryInterface )
        {
            // We can just cast the IUnknown* as an IStream* and
            // we're done (the original QI, despite returning an
            // error, has already done an AddRef).

            hr = S_OK;
            *ppStm = (IStream*) pUnk;
        }
        else
        {
            // This is a real no-interface error, so let's return it.
            hr = E_NOINTERFACE;
        }

        pstmMem->Release();
    }

    //  ----
    //  Exit
    //  ----

Exit:

#endif  // #ifdef _MAC

    return( hr );

}   // QueryForIStream()



//+------------------------------------------------------------------
//
//  Function:   StgCreatePropStg
//
//  Synopsis:   Given an IStorage or IStream, create an
//              IPropertyStorage.  This is similar to the
//              IPropertySetStorage::Create method.  Existing
//              contents of the Storage/Stream are removed.
//
//  Inputs:     [IUnknown*] pUnk
//                  An IStorage* for non-simple propsets,
//                  an IStream* for simple.  grfFlags is
//                  used to disambiguate.
//              [REFFMTID] fmtid
//                  The ID of the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_* enumeration.
//              [IPropertySetStorage**] ppPropStg
//                  The result.
//
//  Returns:    [HRESULT]
//
//  Notes:      The caller is responsible for maintaining
//              thread-safety between the original
//              IStorage/IStream and this IPropertyStorage.
//
//+------------------------------------------------------------------

STDAPI StgCreatePropStg( IUnknown *pUnk,
                         REFFMTID fmtid,
                         const CLSID *pclsid,
                         DWORD grfFlags,
                         DWORD dwReserved,
                         IPropertyStorage **ppPropStg)
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    IStream *pstm = NULL;
    IStorage *pstg = NULL;

    //  ----------
    //  Validation
    //  ----------

    propXTraceStatic( "StgCreatePropStg" );

    GEN_VDATEIFACE_LABEL( pUnk, E_INVALIDARG, Exit, hr );
    GEN_VDATEREADPTRIN_LABEL(&fmtid, FMTID, E_INVALIDARG, Exit, hr );
    GEN_VDATEPTRIN_LABEL(pclsid, CLSID, E_INVALIDARG, Exit, hr );
    // grfFlags is validated by CPropertyStorage
    GEN_VDATEPTROUT_LABEL( ppPropStg, IPropertyStorage*, E_INVALIDARG, Exit, hr );

    *ppPropStg = NULL;

    propTraceParameters(( "pUnk=%p, fmtid=%s, clsid=%s, grfFlags=%s, dwReserved=0x%x, ppPropStg=%p",
                           pUnk, static_cast<const char*>(CStringize(fmtid)),
                           static_cast<const char*>(CStringize(*pclsid)),
                           static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                           dwReserved, ppPropStg ));

    //  -----------------------
    //  Non-Simple Property Set
    //  -----------------------

    if( grfFlags & PROPSETFLAG_NONSIMPLE )
    {
        // Get the IStorage*
        hr = pUnk->QueryInterface( IID_IStorage, (void**) &pstg );
        if( FAILED(hr) ) goto Exit;

        // Create the IPropertyStorage implementation
        *ppPropStg = new CPropertyStorage( MAPPED_STREAM_CREATE );
        if( NULL== *ppPropStg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Initialize the IPropertyStorage
        hr = static_cast<CPropertyStorage*>(*ppPropStg)->Create( pstg, fmtid, pclsid, grfFlags,
                                                                 0 ); // We don't know the grfMode
        if( FAILED(hr) ) goto Exit;

    }   // if( grfFlags & PROPSETFLAG_NONSIMPLE )

    //  -------------------
    //  Simple Property Set
    //  -------------------

    else
    {
        // Get the IStream*
        hr = QueryForIStream( pUnk, &pstm );
        if( FAILED(hr) ) goto Exit;

        // Create an IPropertyStorage implementation.
        *ppPropStg = new CPropertyStorage( MAPPED_STREAM_CREATE );
        if( NULL == *ppPropStg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Initialize the IPropertyStorage (which
        // is responsible for sizing and seeking the
        // stream).

        hr = static_cast<CPropertyStorage*>(*ppPropStg)->Create( pstm, fmtid, pclsid, grfFlags,
                                                                 0 ); // We don't know the grfMode
        if( FAILED(hr) ) goto Exit;

    }   // if( grfFlags & PROPSETFLAG_NONSIMPLE ) ... else

    //  ----
    //  Exit
    //  ----

Exit:

    // If we created *ppPropStg, and there was an error, delete it.

    if( FAILED(hr) )
    {
        propDbg((DEB_ERROR, "StgCreatePropStg returns %08X\n", hr ));

        // Only delete it if the caller gave us valid parameters
        // and we created a CPropertyStorage

        if( E_INVALIDARG != hr && NULL != *ppPropStg )
        {
            delete *ppPropStg;
            *ppPropStg = NULL;
        }
    }

    if( NULL != pstm )
        pstm->Release();
    if( NULL != pstg )
        pstg->Release();

    return( hr );

}   // StgCreatePropStg()



//+------------------------------------------------------------------
//
//  Function:   StgOpenPropStg
//
//  Synopsis:   Given an IStorage or IStream which hold a
//              serialized property set, create an
//              IPropertyStorage.  This is similar to the
//              IPropertySetStorage::Open method.
//
//  Inputs:     [IUnknown*] pUnk
//                  An IStorage* for non-simple propsets,
//                  an IStream* for simple.  grfFlags is
//                  used to disambiguate.
//              [REFFMTID] fmtid
//                  The ID of the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_* enumeration.
//              [IPropertySetStorage**] ppPropStg
//                  The result.
//
//  Returns:    [HRESULT]
//
//  Notes:      The caller is responsible for maintaining
//              thread-safety between the original
//              IStorage/IStream and this IPropertyStorage.
//
//+------------------------------------------------------------------

STDAPI StgOpenPropStg( IUnknown* pUnk,
                       REFFMTID fmtid,
                       DWORD grfFlags,
                       DWORD dwReserved,
                       IPropertyStorage **ppPropStg)
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    IStream *pstm = NULL;
    IStorage *pstg = NULL;

    //  ----------
    //  Validation
    //  ----------

    propXTraceStatic( "StgOpenPropStg" );

    GEN_VDATEIFACE_LABEL( pUnk, E_INVALIDARG, Exit, hr );
    GEN_VDATEREADPTRIN_LABEL(&fmtid, FMTID, E_INVALIDARG, Exit, hr);
    // grfFlags is validated by CPropertyStorage
    GEN_VDATEPTROUT_LABEL( ppPropStg, IPropertyStorage*, E_INVALIDARG, Exit, hr );

    propTraceParameters(( "pUnk=%p, fmtid=%s, grfFlags=%s, dwReserved=0x%x, ppPropStg=%p",
                           pUnk, static_cast<const char*>(CStringize(fmtid)),
                           static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                           dwReserved, ppPropStg ));


    //  -----------------------
    //  Non-Simple Property Set
    //  -----------------------

    *ppPropStg = NULL;

    if( grfFlags & PROPSETFLAG_NONSIMPLE )
    {
        // Get the IStorage*
        hr = pUnk->QueryInterface( IID_IStorage, (void**) &pstg );
        if( FAILED(hr) ) goto Exit;

        // Create an IPropertyStorage* implementation.
        *ppPropStg = new CPropertyStorage( MAPPED_STREAM_CREATE );
        if( NULL == *ppPropStg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Initialize the IPropertyStorage by reading
        // the serialized property set.

        hr = static_cast<CPropertyStorage*>(*ppPropStg)->Open( pstg, fmtid, grfFlags,
                                                               0 ); // We don't know the grfMode
        if( FAILED(hr) ) goto Exit;

    }   // if( grfFlags & PROPSETFLAG_NONSIMPLE )

    //  -------------------
    //  Simple Property Set
    //  -------------------

    else
    {
        // Get the IStream*
        hr = QueryForIStream( pUnk, &pstm );
        if( FAILED(hr) ) goto Exit;

        // Create an IPropertyStorage* implementation.
        *ppPropStg = new CPropertyStorage(MAPPED_STREAM_CREATE );
        if( NULL == *ppPropStg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    
        // Initialize the IPropertyStorage by reading
        // the serialized property set (the CPropertyStorage
        // is responsible for seeking to the stream start).

        hr = static_cast<CPropertyStorage*>(*ppPropStg)->Open( pstm, fmtid, grfFlags,
                                                               0,          // We don't know the grfMode
                                                               FALSE );    // Not deleting
        if( FAILED(hr) ) goto Exit;

    }   // if( grfFlags & PROPSETFLAG_NONSIMPLE ) ... else

    //  ----
    //  Exit
    //  ----

Exit:

    // If we created *ppPropStg, and there was an error, delete it.

    if( FAILED(hr) )
    {
        propDbg((DEB_ERROR, "StgOpenPropStg returns %08X\n", hr ));

        // Only delete it if the caller gave us a valid ppPropStg
        // and we created a CPropertyStorage

        if( E_INVALIDARG != hr && NULL != *ppPropStg )
        {
            delete *ppPropStg;
            *ppPropStg = NULL;
        }
    }

    if( NULL != pstm )
        pstm->Release();

    if( NULL != pstg )
        pstg->Release();

    return( hr );

}   // StgOpenPropStg()



//+------------------------------------------------------------------
//
//  Function:   StgCreatePropSetStg
//
//  Synopsis:   Given an IStorage, create an IPropertySetStorage.
//              This is similar to QI-ing a DocFile IStorage for
//              the IPropertySetStorage interface.
//
//  Inputs:     [IStorage*] pStorage
//                  Will be held by the propsetstg and used
//                  for create/open.
//              [IPropertySetStorage**] ppPropSetStg
//                  Receives the result.
//
//  Returns:    [HRESULT]
//
//  Notes:      The caller is responsible for maintaining
//              thread-safety between the original
//              IStorage and this IPropertySetStorage.
//
//+------------------------------------------------------------------

STDAPI
StgCreatePropSetStg( IStorage *pStorage,
                     DWORD dwReserved,
                     IPropertySetStorage **ppPropSetStg)
{
    HRESULT hr = S_OK;
    CPropertySetStorage *pPropSetStg = NULL;

    // Validation

    propXTraceStatic( "StgCreatePropSetStg" );

    GEN_VDATEIFACE_LABEL( pStorage, E_INVALIDARG, Exit, hr );
    GEN_VDATEPTROUT_LABEL( ppPropSetStg, IPropertySetStorage*, E_INVALIDARG, Exit, hr );

    propTraceParameters(( "pStorage=%p, dwReserved=0x%x, ppPropSetStg=%p",
                           pStorage,    dwReserved,      ppPropSetStg ));

    // Create the IPropertySetStorage implementation.

    pPropSetStg = new CPropertySetStorage( MAPPED_STREAM_CREATE );
    if( NULL == pPropSetStg )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Pass the caller-provided storage into the CPropertySetStorage
    pPropSetStg->Init( pStorage, /*IBlockingLock*/ NULL,
                       TRUE ); // fControlLifetime (=> addref)

    //  ----
    //  Exit
    //  ----

    hr = S_OK;
    *ppPropSetStg = static_cast<IPropertySetStorage*>(pPropSetStg);
    pPropSetStg = NULL;

Exit:

    RELEASE_INTERFACE(pPropSetStg);

    if( FAILED(hr) )
        propDbg((DEB_ERROR, "StgCreatePropSetStg() returns %08X\n", hr ));

    return( hr );

}   // StgCreatePropSetStg()


//+----------------------------------------------------------------------------
//
//  Function:   FmtIdToPropStgName
//
//  Synopsis:   This function maps a property set's FMTID to the name of
//              the Stream or Storage which contains it.  This name
//              is 27 characters (including the terminator).
//
//  Inputs:     [const FMTID*] pfmtid (in)
//                  The FMTID of the property set.
//              [LPOLESTR] oszName (out)
//                  The name of the Property Set's Stream/Storage
//
//  Returns:    [HRESULT] S_OK or E_INVALIDARG
//
//+----------------------------------------------------------------------------

STDAPI
FmtIdToPropStgName( const FMTID *pfmtid, LPOLESTR oszName )
{

    HRESULT hr = S_OK;

    // Validate Inputs

    propXTraceStatic( "FmtIdToPropStgName" );

    GEN_VDATEREADPTRIN_LABEL(pfmtid, FMTID, E_INVALIDARG, Exit, hr);
    VDATESIZEPTROUT_LABEL(oszName,
                          sizeof(OLECHAR) * (CCH_MAX_PROPSTG_NAME+1),
                          Exit, hr);

    propTraceParameters(( "fmtid=%s, oszName=%p",
                           static_cast<const char*>(CStringize(*pfmtid)), oszName ));

    // Make the Conversion

    PrGuidToPropertySetName( pfmtid, oszName );

    // Exit

Exit:

    if( FAILED(hr) )
    {
        propDbg((DEB_ERROR, "FmtIdToPropStgName returns %08X\n", hr ));
    }

    return( hr );

}   // FmtIdToPropStgName()



//+----------------------------------------------------------------------------
//
//  Function:   PropStgNameToFmtId
//
//  Synopsis:   This function maps a property set's Stream/Storage name
//              to its FMTID.
//
//  Inputs:     [const LPOLESTR] oszName (in)
//                  The name of the Property Set's Stream/Storage
//              [FMTID*] pfmtid (out)
//                  The FMTID of the property set.
//
//
//  Returns:    [HRESULT] S_OK or E_INVALIDARG
//
//+----------------------------------------------------------------------------

STDAPI
PropStgNameToFmtId( const LPOLESTR oszName, FMTID *pfmtid )
{

    HRESULT hr = S_OK;

    // Validate Inputs

    propXTraceStatic( "PropStgNameToFmtId" );

    GEN_VDATEPTROUT_LABEL(pfmtid, FMTID, E_INVALIDARG, Exit, hr);

    propTraceParameters(( "oszName=%p, *pfmtid=%s", oszName,
                           static_cast<const char*>(CStringize(*pfmtid)) ));

#ifdef OLE2ANSI
    if( FAILED(hr = ValidateNameA(oszName, CCH_MAX_PROPSTG_NAME )))
        goto Exit;
#else
    if( FAILED(hr = ValidateNameW(oszName, CCH_MAX_PROPSTG_NAME )))
        goto Exit;
#endif


    // Make the Conversion, passing in the name and its character-length
    // (not including the null-terminator).

    PrPropertySetNameToGuid( ocslen(oszName), oszName, pfmtid );

    // Exit

Exit:

    propDbg(( DbgFlag(hr,DEB_TRACE), "PropStgNameToFmtId returns %08x", hr ));

    return( hr );

}   // PropStgNameToFmtId()



//+----------------------------------------------------------------------------
//
//  Function:   CreateOrOpenDocfileOnHandle
//
//  Create or open a Docfile IStorage (or QI-able interface) on a given
//  handle.
//
//+----------------------------------------------------------------------------

CreateOrOpenDocfileOnHandle( IN BOOL fCreate,
                             IN DWORD grfMode,
                             IN HANDLE *phStream,
                             IN  REFIID riid,
                             OUT void ** ppObjectOpen)
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    CNtfsStream *pnffstm = NULL;
    CNFFTreeMutex *pmutex = NULL;
    IStorage *pstg = NULL;

    propITraceStatic( "CreateOrOpenDocfileOnHandle" );

    //  --------------------
    //  Create an ILockBytes
    //  --------------------

    // Instantiate a mutex

    pmutex = new CNFFTreeMutex();
    if( NULL == pmutex )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pmutex->Init();
    if ( FAILED(hr) ) goto Exit;

    // Use the mutex to instantiate an NFF stream object

    pnffstm = new CNtfsStream( NULL, pmutex );
    if( NULL == pnffstm )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Put the stream handle and grfMode into the NFF stream object.
    // We now have our ILockBytes implementation for the given handle.

    hr = pnffstm->Init( *phStream, grfMode, NULL, NULL );
    if( FAILED(hr) ) goto Exit;
    *phStream = INVALID_HANDLE_VALUE;

    //  ----------------
    //  Open the Storage
    //  ----------------

    /*
    hr = CNtfsStorageForPropSetStg::CreateOrOpenStorageOnILockBytes( pnffstm, NULL,
                                                                    grfMode, NULL, fCreate,
                                                                    &pstg );
    if( FAILED(hr) ) goto Exit;
    */

    if( fCreate )
    {
        hr = StgCreateDocfileOnILockBytes( pnffstm, grfMode, 0, &pstg );
    }
    else
    {
        hr = StgOpenStorageOnILockBytes( pnffstm, NULL, grfMode, NULL, 0, &pstg );

        // STG_E_INVALIDHEADER in some paths of the above call gets converted into
        // STG_E_FILEALREADYEXISTS, which doesn't make a whole lot of sense from
        // from our point of view (we already knew it existed, we wanted to open it).  So,
        // translate it back.
        if( STG_E_FILEALREADYEXISTS == hr )
            hr = STG_E_INVALIDHEADER;
    }
    if( FAILED(hr) ) goto Exit;

    // QI for the caller-requested IID

    hr = pstg->QueryInterface( riid, ppObjectOpen );
    if( FAILED(hr) ) goto Exit;


    hr = S_OK;

Exit:

    RELEASE_INTERFACE(pnffstm);
    RELEASE_INTERFACE(pstg);
    RELEASE_INTERFACE(pmutex);

    return( hr );

}


//+----------------------------------------------------------------------------
//
//  CreateOrOpenStorageOnHandle
//  StgCreateStorageOnHandle
//  StgOpenStorageOnHandle
//
//  Given a handle, create or open a storage.
//  The caller-provided handle is duplicated.
//  
//+----------------------------------------------------------------------------

CreateOrOpenStorageOnHandle( IN BOOL fCreate,
                             IN DWORD grfMode,
                             IN DWORD stgfmt,
                             IN HANDLE hStream,
                             IN  REFIID riid,
                             OUT void ** ppObjectOpen)
{
    HRESULT hr = S_OK;
    HANDLE hStreamInternal = INVALID_HANDLE_VALUE;
    NTSTATUS status = STATUS_SUCCESS;
    BOOL fIsStorageFile = FALSE;
    OVERLAPPED olpTemp;


    propXTraceStatic( "CreateOrOpenStorageOnHandle" );

    ZeroMemory( &olpTemp, sizeof(OVERLAPPED) );

    propTraceParameters(( "fCreate=%s, grfMode=%s, stgfmt=0x%x, hStream=%p, riid=%s, ppObjectOpen=%p",
                          fCreate?"TRUE":"FALSE",
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))),
                          stgfmt, hStream,
                          static_cast<const char*>(CStringize(riid)), ppObjectOpen ));

    hr = VerifyPerms (grfMode, TRUE);
    if (FAILED(hr))
        return hr;

    // Make a copy of the handle so that the caller can still call
    // CloseHandle.

    if( !DuplicateHandle( GetCurrentProcess(), hStream,
                          GetCurrentProcess(), &hStreamInternal,
                          0,  // dwDesiredAccess, ignored because of DUPLICATE_SAME_ACCESS below
                          FALSE, // bInheritHandle
                          DUPLICATE_SAME_ACCESS ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hStreamInternal = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    // Set up an overlapped structure in preparation to call
    // StgIsStorageFileHandle

    olpTemp.hEvent = CreateEvent( NULL,     // Security Attributes.
                                  TRUE,     // Manual Reset Flag.
                                  FALSE,    // Inital State = Signaled, Flag.
                                  NULL );   // Name

    if( NULL == olpTemp.hEvent )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Does this handle represent a docfile?

    hr = StgIsStorageFileHandle( hStreamInternal, &olpTemp );
    if( HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) == hr )
    {
        // This is the error we get when the handle is to a directory.
        // See if that's really the case, and if so assume that this isn't
        // a docfile.

        // Do not move this in StgIsStorageFileHandle for compatibility

        BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;

        if( GetFileInformationByHandle( hStreamInternal, &ByHandleFileInformation ))
        {
            if( FILE_ATTRIBUTE_DIRECTORY & ByHandleFileInformation.dwFileAttributes )
                hr = S_FALSE;
        }
    }
    if( FAILED(hr) ) goto Exit;

    if( S_OK == hr )
        fIsStorageFile = TRUE;
    else
        DfpAssert( S_FALSE == hr );

    // Is this the create of a docfile/storage, or the open of an
    // existing docfile?

    if( fCreate && ( STGFMT_DOCFILE == stgfmt || STGFMT_STORAGE == stgfmt )
        ||
        !fCreate && fIsStorageFile )
    {
        // In the open path, the caller must request
        // either any, docfile, or storage.

        if( !fCreate
            &&
            STGFMT_ANY != stgfmt
            &&
            STGFMT_DOCFILE != stgfmt
            &&
            STGFMT_STORAGE != stgfmt )
        {
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        // Create/Open the docfile.  hStreamInternal may be changed
        // to INVALID_HANDLE_VALUE.

        hr = CreateOrOpenDocfileOnHandle( fCreate, grfMode, &hStreamInternal,
                                          riid, ppObjectOpen );
        if( FAILED(hr) ) goto Exit;
    }

    // Otherwise, this should be the create/open of an NFF
    else if( fCreate && STGFMT_FILE == stgfmt
             ||
             !fCreate && !fIsStorageFile )
    {
        // In the open path, the caller must request either any or file.

        if( !fCreate && STGFMT_ANY != stgfmt && STGFMT_FILE != stgfmt )
        {
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        // Instantiate the NFF IStorage.

        hr = NFFOpenOnHandle( fCreate, grfMode, STGFMT_FILE,
                              &hStreamInternal, riid, ppObjectOpen );

        if( FAILED(hr) ) goto Exit;
    }
    else
    {
        hr = STG_E_INVALIDPARAMETER;
        goto Exit;
    }

    hr = S_OK;

Exit:

    if( INVALID_HANDLE_VALUE != hStreamInternal )
        CloseHandle( hStreamInternal );

    if( NULL != olpTemp.hEvent )
        CloseHandle( olpTemp.hEvent );

    if( STG_E_INVALIDFUNCTION == hr // This happens e.g. when we try to get NFF propsets on FAT
        ||                          // This happens when we try to read a FAT directory file
        HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hr )
    {
        propSuppressExitErrors();
    }

    return( hr );

}   // CreateOrOpenStorageOnHandle


STDAPI
StgCreateStorageOnHandle( IN HANDLE hStream,
                          IN DWORD grfMode,
                          IN DWORD stgfmt,
                          IN void *reserved1,
                          IN void *reserved2,
                          IN REFIID riid,
                          OUT void **ppObjectOpen )
{
    return( CreateOrOpenStorageOnHandle( TRUE, grfMode, stgfmt, hStream, riid, ppObjectOpen ));
}

STDAPI
StgOpenStorageOnHandle( IN HANDLE hStream,
                        IN DWORD grfMode,
                        IN void *reserved1,
                        IN void *reserved2,
                        IN REFIID riid,
                        OUT void **ppObjectOpen )
{
    return( CreateOrOpenStorageOnHandle( FALSE, grfMode, STGFMT_ANY, hStream, riid, ppObjectOpen ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\propvar.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        propvar.cxx
//
// Contents:    PROPVARIANT manipulation code
//
// History:     15-Aug-95       vich  created
//              22-Feb-96   MikeHill  Moved DwordRemain to "propmac.hxx".
//              09-May-96   MikeHill  Use the 'boolVal' member of PropVariant
//                                    rather than the member named 'bool'.
//              22-May-96   MikeHill  Use the caller-provided codepage for
//                                    string conversions, not the system default.
//              06-Jun-96   MikeHill  Modify CLIPDATA.cbData to include sizeof
//                                    ulClipFmt.
//              12-Jun-96   MikeHill  - Use new BSTR alloc/free routines.
//                                    - Added VT_I1 support (under ifdefs)
//                                    - Bug for VT_CF|VT_VECTOR in RtlConvPropToVar
//              25-Jul-96   MikeHill  - Removed Win32 SEH.
//                                    - BSTRs:  WCHAR=>OLECHAR
//                                    - Added big-endian support.
//              10-Mar-98   MikeHill  - Added support for Variant types except
//                                      for VT_RECORD.
//              06-May-98   MikeHill  - Removed usage of UnicodeCallouts.
//                                    - Wrap SafeArray/BSTR calls for delayed-linking.
//                                    - Enforce VT in VT_ARRAYs.
//                                    - Added support for VT_VARIANT|VT_BYREF.
//                                    - Added support for VT_ARRAY|VT_BYREF.
//                                    - Added support for VT_VECTOR|VT_I1.
//                                    - Use CoTaskMem rather than new/delete.
//              11-June-98  MikeHill  - Validate elements of arrays & vectors.
//
//---------------------------------------------------------------------------

#include <pch.cxx>

#include <stdio.h>

#ifndef _MAC
#include <ddeml.h>      // for CP_WINUNICODE
#endif

#include "propvar.h"

#ifndef newk
#define newk(Tag, pCounter)     new
#endif





#if DBGPROP

BOOLEAN
IsUnicodeString(WCHAR const *pwszname, ULONG cb)
{
    return( TRUE );
}


BOOLEAN
IsAnsiString(CHAR const *pszname, ULONG cb)
{
    return( TRUE );
}
#endif




//+---------------------------------------------------------------------------
// Function:    PrpConvertToUnicode, private
//
// Synopsis:    Convert a MultiByte string to a Unicode string
//
// Arguments:   [pch]        -- pointer to MultiByte string
//              [cb]         -- byte length of MultiByte string
//              [CodePage]   -- property set codepage
//              [ppwc]       -- pointer to returned pointer to Unicode string
//              [pcb]        -- returned byte length of Unicode string
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
PrpConvertToUnicode(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    WCHAR *pwszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pch != NULL);
    PROPASSERT(ppwc != NULL);
    PROPASSERT(pcb != NULL);

    *ppwc = NULL;
    *pcb = 0;

    ULONG cwcName;

    pwszName = NULL;
    cwcName = 0;
    while (TRUE)
    {
	cwcName = MultiByteToWideChar(
				    CodePage,
				    0,			// dwFlags
				    pch,
				    cb,
				    pwszName,
				    cwcName);
	if (cwcName == 0)
	{
	    CoTaskMemFree( pwszName );
            // If there was an error, assume that it was a code-page
            // incompatibility problem.
            StatusError(pstatus, "PrpConvertToUnicode: MultiByteToWideChar error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}
	if (pwszName != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"PrpConvertToUnicode: pch='%s'[%x] pwc='%ws'[%x->%x]\n",
		pch,
		cb,
		pwszName,
		*pcb,
		cwcName * sizeof(WCHAR)));
	    break;
	}
	*pcb = cwcName * sizeof(WCHAR);
	*ppwc = pwszName = (WCHAR *) CoTaskMemAlloc( *pcb );
	if (pwszName == NULL)
	{
	    StatusNoMemory(pstatus, "PrpConvertToUnicode: no memory");
            goto Exit;
	}
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    PrpConvertToMultiByte, private
//
// Synopsis:    Convert a Unicode string to a MultiByte string
//
// Arguments:   [pwc]        -- pointer to Unicode string
//              [cb]         -- byte length of Unicode string
//              [CodePage]   -- property set codepage
//              [ppch]       -- pointer to returned pointer to MultiByte string
//              [pcb]        -- returned byte length of MultiByte string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
PrpConvertToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    ULONG cbName;
    CHAR *pszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pwc != NULL);
    PROPASSERT(ppch != NULL);
    PROPASSERT(pcb != NULL);

    *ppch = NULL;
    *pcb = 0;

    pszName = NULL;
    cbName = 0;
    while (TRUE)
    {
	cbName = WideCharToMultiByte(
				    CodePage,
				    0,			// dwFlags
				    pwc,
				    cb/sizeof(WCHAR),
				    pszName,
				    cbName,
				    NULL,		// lpDefaultChar
				    NULL);		// lpUsedDefaultChar
	if (cbName == 0)
	{
	    CoTaskMemFree( pszName );
            // If there was an error, assume that it was a code-page
            // incompatibility problem.
            StatusError(pstatus, "PrpConvertToMultiByte: WideCharToMultiByte error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}
	if (pszName != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"PrpConvertToMultiByte: pwc='%ws'[%x] pch='%s'[%x->%x]\n",
		pwc,
		cb,
		pszName,
		*pcb,
		cbName));
	    break;
	}
	*pcb = cbName;
	*ppch = pszName = reinterpret_cast<CHAR*>( CoTaskMemAlloc( cbName ));
	if (pszName == NULL)
	{
	    StatusNoMemory(pstatus, "PrpConvertToMultiByte: no memory");
            goto Exit;
	}
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    GetSafeArrayElementTypes, private
//
// Synopsis:    Determine the type of a SafeArray's elements
//
//---------------------------------------------------------------------------

/*
#define FADF_FOR_PROPSET_MASK   (FADF_BSTR | FADF_HAVEVARTYPE | FADF_VARIANT)

VARTYPE
GetSafeArrayElementTypes( const SAFEARRAY *psa, NTSTATUS *pstatus )
{
    VARTYPE vtRet = 0;
    *pstatus = STATUS_SUCCESS;

    // Fail if there's a new feature that we don't yet recognize.
    if( ~FADF_FOR_PROPSET_MASK & psa->fFeatures )
    {
        StatusInvalidParameter( pstatus, "Unrecognized safearray feature" );
        goto Exit;
    }

    // Does this safearray have a VT built in?

    if( FADF_HAVEVARTYPE & psa->fFeatures )
    {   // mikehill step
        vtRet = static_cast<VARTYPE>( *(reinterpret_cast<const LONG*>(psa) - 1) );
        goto Exit;
    }

    // Infer the VT based on the size of the elements
    switch( psa->cbElements)
    {
    case 1:
        vtRet = VT_I1;   // SF_I1;
        break;

    case 2:
        vtRet = VT_I2;   // SF_I2;
        break;

    case 4:

        switch( FADF_BSTR & psa->fFeatures )
        {
            case FADF_BSTR:
                vtRet = VT_BSTR; // SF_BSTR;
                break;

            default:
                vtRet = VT_I4;   // SF_I4;
                break;
        }
        break;

    case 8:
        vtRet = VT_I8;   // SF_I8;
        break;

    case sizeof(VARIANT):
        if( FADF_VARIANT & psa->fFeatures )
        {
            vtRet = VT_VARIANT;   // SF_VARIANT;
            break;
        }
        // fall through

    default:
        StatusInvalidParameter( pstatus, "Bad cbElements/fFeatures in SafeArray" );
        break;

    }

Exit:

    return( vtRet );
}
*/


//+---------------------------------------------------------------------------
//
// Function:    SerializeSafeArrayBounds, private
//
// Synopsis:    Write the rgsabounds field of a SAFEARRAY to pbdst (if non-NULL).
//              Calculate and return the size of the serialized bounds,
//              and the total number of elements in the array.
//
//---------------------------------------------------------------------------

NTSTATUS
SerializeSafeArrayBounds( const SAFEARRAY *psa, BYTE *pbdst, ULONG *pcbBounds, ULONG *pcElems )
{
    NTSTATUS status = STATUS_SUCCESS;

    ULONG ulIndex = 0;
    ULONG cDims = PrivSafeArrayGetDim( const_cast<SAFEARRAY*>(psa) );
    PROPASSERT( 0 < cDims );

    *pcbBounds = 0;
    *pcElems = 1;
    for( ulIndex = 1; ulIndex <= cDims; ulIndex++ )
    {
        LONG lLowerBound = 0, lUpperBound = 0;

        // Get the lower & upper bounds

        if( SUCCEEDED( status = PrivSafeArrayGetLBound( const_cast<SAFEARRAY*>(psa), ulIndex, &lLowerBound )))
        {
            status = PrivSafeArrayGetUBound( const_cast<SAFEARRAY*>(psa), ulIndex, &lUpperBound );
        }
        if( FAILED(status) )
        {
            goto Exit;
        }
        else if( lUpperBound < lLowerBound )
        {
            status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        // Calculate the element count
        *pcElems *= (lUpperBound - lLowerBound + 1 );

        // If we're really serializing, write the current set of bounds
        if( NULL != pbdst )
        {
            // Write the length of this dimension
            *(ULONG *) pbdst = (lUpperBound - lLowerBound + 1);
            pbdst += sizeof(ULONG);

            // Then the lower bound
            *(LONG *) pbdst = lLowerBound;
            pbdst += sizeof(LONG);
        }
    }

    // Calculate the size of the rgsabound array.
    *pcbBounds = sizeof(SAFEARRAYBOUND) * cDims;

Exit:

    return( status );
}


ULONG
CalcSafeArrayElements( ULONG cDims, const SAFEARRAYBOUND *rgsaBounds )
{
    ULONG cElems = 1; // Multiplicitive identity

    for( ULONG i = 0; i < cDims; i++ )
        cElems *= rgsaBounds[ i ].cElements;

    return( cElems );
}



//+---------------------------------------------------------------------------
// Function:    StgConvertVariantToProperty, private
//
// Synopsis:    Convert a PROPVARIANT to a SERIALIZEDPROPERTYVALUE
//
// Arguments:   [pvar]       -- pointer to PROPVARIANT
//              [CodePage]   -- property set codepage
//              [pprop]      -- pointer to SERIALIZEDPROPERTYVALUE
//              [pcb]        -- pointer to remaining stream length,
//			        updated to actual property size on return
//              [pid]	     -- propid (used if indirect)
//              [fVariantVectorOrArray] -- TRUE if recursing on VT_VECTOR | VT_VARIANT
//              [pcIndirect] -- pointer to indirect property count
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     NULL if buffer too small, else input [pprop] argument
//---------------------------------------------------------------------------


// Define a macro which sets a variable named 'cbByteSwap', but
// only on big-endian builds.  This value is not needed on little-
// endian builds (because byte-swapping is not necessary).

#ifdef BIGENDIAN
#define CBBYTESWAP(cb) cbByteSwap = cb
#elif LITTLEENDIAN
#define CBBYTESWAP(cb)
#else
#error Either BIGENDIAN or LITTLEENDIAN must be set.
#endif


// First, define a wrapper for this function which returns errors
// using NT Exception Handling, rather than returning an NTSTATUS.

#if defined(WINNT)

EXTERN_C SERIALIZEDPROPERTYVALUE * __stdcall
StgConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVector,
    OPTIONAL OUT ULONG *pcIndirect)
{
    SERIALIZEDPROPERTYVALUE *ppropRet;
    NTSTATUS status;

    ppropRet = StgConvertVariantToPropertyNoEH(
                                    pvar, CodePage, pprop,
                                    pcb, pid, fVector,
                                    FALSE,  // fArray
                                    pcIndirect, NULL, &status );

    if (!NT_SUCCESS( status ))
        RtlRaiseStatus( status );

    return (ppropRet );

}

#endif // #if defined(WINNT)


// Enough for "prop%lu" + L'\0'
#define CCH_MAX_INDIRECT_NAME (4 + 10 + 1)


// Now define the body of the function, returning errors with an
// NTSTATUS value instead of raising.

SERIALIZEDPROPERTYVALUE *
StgConvertVariantToPropertyNoEH(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVector,  // Used for recursive calls
    IN BOOLEAN fArray,    // Used for recursive calls
    OPTIONAL OUT ULONG *pcIndirect,
    IN OUT OPTIONAL WORD *pwMinFormatRequired,
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    //  ------
    //  Locals
    //  ------
    CHAR *pchConvert = NULL;

    ULONG count = 0;
    BYTE *pbdst;
    ULONG cbch = 0;
    ULONG cbchdiv = 0;
    ULONG cb = 0;
    ULONG ulIndex = 0;  // Used as a misc loop control variable

    // Size of byte-swapping units (e.g. 2 to swap a WORD).
    INT   cbByteSwap = 0;

    ULONG const *pcount = NULL;
    VOID const *pv = NULL;
    LONG *pclipfmt = NULL;
    BOOLEAN fCheckNullSource;
    BOOLEAN fIllegalType = FALSE;
    const VOID * const *ppv;
    OLECHAR aocName[ CCH_MAX_INDIRECT_NAME ];
    BOOLEAN fByRef;

    const SAFEARRAY *parray = NULL;
    const VOID *parraydata = NULL;
    ULONG fSafeArrayLocked = FALSE;
    ULONG cSafeArrayDims = 0;

    /*
    IRecordInfo *pRecInfo = NULL;       // Not addref-ed, not released.
    ITypeLibr   *pTypeLib = NULL;
    ITypeInfo   *pTypeInfo = NULL;
    */

    IFDBG( HRESULT &hr = *pstatus; )
    propITraceStatic( "StgConvertVariantToPropertyNoEH" );
    propTraceParameters(( "pprop=%p, CodePage=%d, pvar=%p, pma=%p" ));


    // Initialize a local wMinFormatRequired.
    WORD wMinFormatRequired = (NULL == pwMinFormatRequired) ? PROPSET_WFORMAT_ORIGINAL : *pwMinFormatRequired;

    // If this is a byref, then up the min format required.
    if( VT_BYREF & pvar->vt )
        wMinFormatRequired = max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

    // We dereference byrefs.  If this is a byref Variant, we can shortcut this
    // by simply changing pvar.

    while( (VT_BYREF | VT_VARIANT) == pvar->vt )
    {
        if( NULL == pvar->pvarVal )
        {
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        pvar = pvar->pvarVal;
    }

    // Now that we've settled on the pvar we're going to convert,
    // Jot down some info on it.

    fCheckNullSource = (BOOLEAN) ((pvar->vt & VT_VECTOR) != 0);
    fByRef = 0 != (pvar->vt & VT_BYREF);

    // If this is an array, then validate the VT in the SafeArray itself matches
    // pvar->vt.

    if( VT_ARRAY & pvar->vt )
    {
        VARTYPE vtSafeArray = VT_EMPTY;

        // It's invalid to have both the array and vector bits set (would it be
        // an array of vectors or a vector of arrays?).
        if( VT_VECTOR & pvar->vt )
        {
            StatusInvalidParameter( pstatus, "Both VT_VECTOR and VT_ARRAY set" );
            goto Exit;
        }

        // Arrays require an uplevel property set format
        wMinFormatRequired = max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

        // Get the Type bit from the SafeArray

        if( VT_BYREF & pvar->vt )
        {
            if( NULL != pvar->pparray && NULL != *pvar->pparray )
            {
                *pstatus = PrivSafeArrayGetVartype( *pvar->pparray, &vtSafeArray );
                if( FAILED(*pstatus) )
                    goto Exit;
            }
        }
        else if( NULL != pvar->parray )
        {
            *pstatus = PrivSafeArrayGetVartype( pvar->parray, &vtSafeArray );
            if( FAILED(*pstatus) )
                goto Exit;
        }

        if( !NT_SUCCESS(*pstatus) )
            goto Exit;

        // Ensure the VT read from the property set matches that in the PropVariant.
        // It is illegal for these to be different.

        if( ( vtSafeArray & VT_TYPEMASK )
            !=
            ( pvar->vt    & VT_TYPEMASK ) )
        {
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

    }   // if( VT_ARRAY & pvar->vt )


    //  -------------------------------------------------------
    //  Analyze the PropVariant, and store information about it
    //  in fIllegalType, cb, pv, pcount, count, pclipfmt,
    //  fCheckNullSource, cbch, chchdiv, and ppv.
    //  -------------------------------------------------------


    switch( pvar->vt )
    {
    case VT_EMPTY:
    case VT_NULL:
	fIllegalType = fVector || fArray;
	break;

    case VT_I1 | VT_BYREF:
	fIllegalType = fVector || fArray;
    case VT_I1:
        AssertByteField(cVal);        // VT_I1
        wMinFormatRequired = max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );
        
        cb = sizeof(pvar->bVal);
        pv = fByRef ? pvar->pcVal : &pvar->cVal;
        break;

    
    case VT_UI1 | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_UI1:
        AssertByteField(bVal);          // VT_UI1
        AssertStringField(pbVal);

	cb = sizeof(pvar->bVal);
        pv = fByRef ? pvar->pbVal : &pvar->bVal;
	break;


    case VT_I2 | VT_BYREF:
    case VT_UI2 | VT_BYREF:
    case VT_BOOL | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:

	AssertShortField(iVal);	        // VT_I2
        AssertStringField(piVal);
	AssertShortField(uiVal);        // VT_UI2
        AssertStringField(puiVal);
	AssertShortField(boolVal);      // VT_BOOL

	cb = sizeof(pvar->iVal);
        pv = fByRef ? pvar->piVal : &pvar->iVal;

        // If swapping, swap as a WORD
        CBBYTESWAP(cb);
        break;

    case VT_INT | VT_BYREF:
    case VT_UINT | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_INT:
    case VT_UINT:
        fIllegalType |= fVector;
        // Fall through

    case VT_I4 | VT_BYREF:
    case VT_UI4 | VT_BYREF:
    case VT_R4 | VT_BYREF:
    case VT_ERROR | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:

	AssertLongField(lVal);          // VT_I4
        AssertStringField(plVal);
        AssertLongField(intVal);      // VT_INT
        AssertStringField(pintVal);
	AssertLongField(ulVal);         // VT_UI4
        AssertLongField(uintVal);     // VT_UINT
        AssertStringField(puintVal);
        AssertStringField(pulVal);
	AssertLongField(fltVal);        // VT_R4
        AssertStringField(pfltVal);
	AssertLongField(scode);	        // VT_ERROR
        AssertStringField(pscode);

        if( VT_INT == (pvar->vt&VT_TYPEMASK) || VT_UINT == (pvar->vt&VT_TYPEMASK) )
            wMinFormatRequired = max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

	cb = sizeof(pvar->lVal);
        pv = fByRef ? pvar->plVal : &pvar->lVal;

        // If swapping, swap as a DWORD
        CBBYTESWAP(cb);
	break;

    case VT_FILETIME:
	fIllegalType = fArray;

    /*
    case VT_I8 | VT_BYREF:
    case VT_UI8 | VT_BYREF:
        fIllegalType = fVector || fArray;
    */

    case VT_I8:
    case VT_UI8:
	AssertLongLongField(hVal);      // VT_I8
	AssertLongLongField(uhVal);     // VT_UI8
	AssertLongLongField(filetime);  // VT_FILETIME

	cb = sizeof(pvar->hVal);
	pv = &pvar->hVal;

        // If swapping, swap each DWORD independently.
        CBBYTESWAP(sizeof(DWORD));
	break;

    case VT_R8 | VT_BYREF:
    case VT_CY | VT_BYREF:
    case VT_DATE | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_R8:
    case VT_CY:
    case VT_DATE:

	AssertLongLongField(dblVal);    // VT_R8
        AssertStringField(pdblVal);
	AssertLongLongField(cyVal);     // VT_CY
        AssertStringField(pcyVal);
	AssertLongLongField(date);      // VT_DATE
        AssertStringField(pdate);

	cb = sizeof(pvar->dblVal);
        pv = fByRef ? pvar->pdblVal : &pvar->dblVal;

        // If swapping, swap as a LONGLONG (64 bits).
        CBBYTESWAP(cb);
	break;

    case VT_CLSID:
	AssertStringField(puuid);       // VT_CLSID

	fIllegalType = fArray;
	cb = sizeof(GUID);
	pv = pvar->puuid;
	fCheckNullSource = TRUE;

        // If swapping, special handling is required.
        CBBYTESWAP( CBBYTESWAP_UID );
	break;

    case VT_DECIMAL | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_DECIMAL:
        fIllegalType |= fVector;
        wMinFormatRequired = max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

        cb = sizeof(DECIMAL);
        pv = fByRef ? pvar->pdecVal : &pvar->decVal;
        break;

    case VT_CF:

	fIllegalType = fArray;

        // Validate the PropVariant
	if (pvar->pclipdata == NULL
            ||
            pvar->pclipdata->cbSize < sizeof(pvar->pclipdata->ulClipFmt) )
	{
	    StatusInvalidParameter(pstatus, "StgConvertVariantToProperty: pclipdata NULL");
            goto Exit;
	}

        // How many bytes should we copy?
	cb = CBPCLIPDATA( *(pvar->pclipdata) );

        // Identify the value for this property's count field.
        // (which includes sizeof(ulClipFmt))
	count = pvar->pclipdata->cbSize;
	pcount = &count;

        // Identify the clipdata's format & data
	pclipfmt = &pvar->pclipdata->ulClipFmt;
	pv = pvar->pclipdata->pClipData;

	fCheckNullSource = TRUE;

        // Note that no byte-swapping of 'pv' is necessary.
	break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
	fIllegalType = fVector || fArray;
	pcount = &pvar->blob.cbSize;
	cb = *pcount;
	pv = pvar->blob.pBlobData;
	fCheckNullSource = TRUE;

        // Note that no byte-swapping of 'pv' is necessary.
	break;

    case VT_VERSIONED_STREAM:

        wMinFormatRequired = max( wMinFormatRequired, PROPSET_WFORMAT_VERSTREAM );
        // Fall through

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:

	fIllegalType = fVector || fArray;
        if( fIllegalType ) break;

        // Does the caller support indirect properties?
        if (pcIndirect != NULL)
        {
            // Yes.
            (*pcIndirect)++;

            // For indirect properties, we don't write the value
            // in 'pvar', we write a substitute value.  That value is by
            // convention (IPropertyStorage knows to use PROPGENPROPERTYNAME),
            // so we don't have to pass the name back to the caller.

            PROPGENPROPERTYNAME(aocName, pid);
            pv = aocName;

        }

        // Otherwise, the caller doesn't support indirect properties,
        // so we'll take the value from pwszVal
        else
        {
            PROPASSERT(
                pvar->pwszVal == NULL ||
                IsUnicodeString(pvar->pwszVal, MAXULONG));
            pv = pvar->pwszVal;
        }

        count = 1;      // default to forcing an error on NULL pointer

        // Jump to the LPSTR/BSTR handling code, but skip the ansi check
        goto noansicheck;

        break;

    case VT_BSTR | VT_BYREF:
	fIllegalType = fVector || fArray;
        count = 0;
        pv = *pvar->pbstrVal;
        goto noansicheck;

    case VT_LPSTR:
	fIllegalType = fArray;
        PROPASSERT(
            pvar->pszVal == NULL ||
            IsAnsiString(pvar->pszVal, MAXULONG));
        // FALLTHROUGH

    case VT_BSTR:
        count = 0;      // allow NULL pointer
        pv = pvar->pszVal;
noansicheck:
	AssertStringField(pwszVal);	        // VT_STREAM, VT_STREAMED_OBJECT
	AssertStringField(pwszVal);	        // VT_STORAGE, VT_STORED_OBJECT
	AssertStringField(bstrVal);	        // VT_BSTR
        AssertStringField(pbstrVal);
	AssertStringField(pszVal);	        // VT_LPSTR
        AssertStringField(pVersionedStream);    // VT_VERSIONED_STREAM

        if( fIllegalType ) break;

        // We have the string for an LPSTR, BSTR, or indirect
        // property pointed to by 'pv'.  Now we'll perform any
        // Ansi/Unicode conversions and byte-swapping that's
        // necessary (putting the result in 'pv').

	if (pv == NULL)
	{
	    fCheckNullSource = TRUE;
	}

	else if (pvar->vt == VT_LPSTR)
	{
	    count = strlen((char *) pv) + 1;

            // If the propset is Unicode, convert the LPSTR to Unicode.

	    if (CodePage == CP_WINUNICODE)
	    {
                // Convert to Unicode.

		PROPASSERT(IsAnsiString((CHAR const *) pv, count));
		PrpConvertToUnicode(
				(CHAR const *) pv,
				count,
				CP_ACP,  // Variants are in the system codepage
				(WCHAR **) &pchConvert,
				&count,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // 'pv' always has the ready-to-serialize string.
		pv = pchConvert;

                // This unicode string may require byte-swapping.
                CBBYTESWAP( sizeof(WCHAR) );
	    }
	}   // else if (pvar->vt == VT_LPSTR)

	else
	{
            // If this is a BSTR, increment the count to include
            // the string terminator.
	    if( (~VT_BYREF & pvar->vt) == VT_BSTR )
	    {
		count = BSTRLEN(pv);

                // Verify that the input BSTR is terminated.
		if( reinterpret_cast<const OLECHAR *>(pv)[count/sizeof(OLECHAR)] != OLESTR('\0') )
		{
		    PROPASSERT(reinterpret_cast<const OLECHAR *>(pv)[count/sizeof(OLECHAR)] == OLESTR('\0'));
		    StatusInvalidParameter(pstatus,
			"StgConvertVariantToProperty: bad BSTR null char");
                    goto Exit;
		}

                // Increment the count to include the terminator.
		count += sizeof(OLECHAR);
	    }
	    else
	    {
		count = (Prop_ocslen((OLECHAR *) pv) + 1) * sizeof(OLECHAR);
		PROPASSERT(IsOLECHARString((OLECHAR const *) pv, count));
	    }

            // This string is either an indirect property name,
            // or a BSTR, both of which could be Ansi or Unicode.

            if (CodePage != CP_WINUNICODE   // Ansi property set
                &&
                OLECHAR_IS_UNICODE          // The PropVariant is in Unicode
               )
	    {
                // A Unicode to Ansi conversion is required.

                PROPASSERT( IsUnicodeString( (WCHAR*)pv, count ));

		PrpConvertToMultiByte(
				(WCHAR const *) pv,
				count,
				CodePage,
				&pchConvert,
				&count,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
		pv = pchConvert;
	    }

            else
            if (CodePage == CP_WINUNICODE   // Unicode property set,
                &&
                !OLECHAR_IS_UNICODE         // The PropVariant is in Ansi
               )
            {
                // An Ansi to Unicode conversion is required.

                PROPASSERT(IsAnsiString((CHAR const *) pv, count));
                PROPASSERT(sizeof(OLECHAR) == sizeof(CHAR));

                PrpConvertToUnicode(
		                (CHAR const *) pv,
		                count,
		                CP_ACP, // In-mem BSTR is in system CP
		                (WCHAR **) &pchConvert,
		                &count,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // 'pv' always holds the ready-to-serialize value.
                pv = pchConvert;

                // This unicode string may require swapping.
                CBBYTESWAP( sizeof(WCHAR) );
            }

            else
            if (CodePage == CP_WINUNICODE)
            {
                // No conversion is required (i.e., both 'pv' and the 
                // property set are Unicode).  But we must remember
                // to perform a byte-swap (if byte-swapping is necessary).

                CBBYTESWAP( sizeof(WCHAR) );
            }
	}   // if (pv == NULL) ... else if ... else

        // Validate 'pv'.

#ifdef LITTLEENDIAN
        PROPASSERT( NULL == pv
                    ||
                    CodePage == CP_WINUNICODE && IsUnicodeString((WCHAR*)pv, count)
                    ||
                    CodePage != CP_WINUNICODE && IsAnsiString((CHAR*)pv, count) );
#endif

	cb = count;
	pcount = &count;
	break;

    case VT_LPWSTR:
	AssertStringField(pwszVal);		// VT_LPWSTR
	PROPASSERT(
	    pvar->pwszVal == NULL ||
	    IsUnicodeString(pvar->pwszVal, MAXULONG));

	fIllegalType = fArray;
        pv = pvar->pwszVal;
	if (pv == NULL)
	{
	    count = 0;
	    fCheckNullSource = TRUE;
	}
	else
	{
            // Calculate the [length] field.
	    count = Prop_wcslen(pvar->pwszVal) + 1;

            // If byte-swapping will be necessary to get to the serialized
            // format, we'll do so in units of WCHARs.

            CBBYTESWAP( sizeof(WCHAR) );
	}

	cb = count * sizeof(WCHAR);
	pcount = &count;
	break;

    /*
    case VT_RECORD:

        pv = pvar->pvRecord;
        pRecInfo = pvar->pRecInfo;

        if( NULL == pv )
        {
            count = 0;
            fCheckNullSource = TRUE;
        }
        else if( NULL == pRecInfo )
        {
            StatusInvalidParameter( pstatus, "Missing IRecordInfo*" );
            goto Exit;
        }

        cb = 0;

        break;
    */

    // Vector properties:

    case VT_VECTOR | VT_I1:
	AssertByteVector(cac);		// VT_I1
	fIllegalType = fArray;
        wMinFormatRequired = max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );
        // Fall through

    case VT_VECTOR | VT_UI1:
	AssertByteVector(caub);		// VT_UI1
	fIllegalType = fArray;
	pcount = &pvar->caub.cElems;
	cb = *pcount * sizeof(pvar->caub.pElems[0]);
	pv = pvar->caub.pElems;
	break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
	AssertShortVector(cai);		// VT_I2
	AssertShortVector(caui);        // VT_UI2
	AssertShortVector(cabool);      // VT_BOOL

	fIllegalType = fArray;
	pcount = &pvar->cai.cElems;
	cb = *pcount * sizeof(pvar->cai.pElems[0]);
	pv = pvar->cai.pElems;

        // If swapping, swap as WORDs
        CBBYTESWAP(sizeof(pvar->cai.pElems[0]));
	break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
	AssertLongVector(cal);		// VT_I4
	AssertLongVector(caul);		// VT_UI4
	AssertLongVector(caflt);        // VT_R4
	AssertLongVector(cascode);      // VT_ERROR

	fIllegalType = fArray;
	pcount = &pvar->cal.cElems;
	cb = *pcount * sizeof(pvar->cal.pElems[0]);
	pv = pvar->cal.pElems;

        // If swapping, swap as DWORDs
        CBBYTESWAP(sizeof(pvar->cal.pElems[0]));
	break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_FILETIME:
	AssertLongLongVector(cah);      // VT_I8
	AssertLongLongVector(cauh);     // VT_UI8
	AssertLongLongVector(cafiletime);// VT_FILETIME

	fIllegalType = fArray;
	pcount = &pvar->cah.cElems;
	cb = *pcount * sizeof(pvar->cah.pElems[0]);
	pv = pvar->cah.pElems;

        // If swapping, swap as DWORDs
        CBBYTESWAP(sizeof(DWORD));
	break;

    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
	AssertLongLongVector(cadbl);    // VT_R8
	AssertLongLongVector(cacy);     // VT_CY
	AssertLongLongVector(cadate);   // VT_DATE

	fIllegalType = fArray;
	pcount = &pvar->cah.cElems;
	cb = *pcount * sizeof(pvar->cadbl.pElems[0]);
	pv = pvar->cadbl.pElems;

        // If swapping, swap as LONGLONGs (8 bytes)
        CBBYTESWAP(sizeof(pvar->cadbl.pElems[0]));
	break;

    case VT_VECTOR | VT_CLSID:
	AssertVarVector(cauuid, sizeof(GUID));

	fIllegalType = fArray;
	pcount = &pvar->cauuid.cElems;
	cb = *pcount * sizeof(pvar->cauuid.pElems[0]);
	pv = pvar->cauuid.pElems;

        // If swapping, special handling is required.
        CBBYTESWAP( CBBYTESWAP_UID );
	break;

    case VT_VECTOR | VT_CF:
	fIllegalType = fArray;
	cbch = sizeof(CLIPDATA);
	cbchdiv = sizeof(BYTE);
	goto stringvector;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
	fIllegalType = fArray;
	cbchdiv = cbch = sizeof(BYTE);
	goto stringvector;

    case VT_VECTOR | VT_LPWSTR:
	fIllegalType = fArray;
	cbchdiv = cbch = sizeof(WCHAR);
	goto stringvector;

    case VT_VECTOR | VT_VARIANT:
	fIllegalType = fArray;
	cbch = MAXULONG;
stringvector:
	AssertVarVector(caclipdata, sizeof(CLIPDATA));	// VT_CF
	AssertStringVector(cabstr);                     // VT_BSTR
	AssertStringVector(calpstr);			// VT_LPSTR
	AssertStringVector(calpwstr);			// VT_LPWSTR
	AssertVarVector(capropvar, sizeof(PROPVARIANT));// VT_VARIANT

	pcount = &pvar->calpstr.cElems;
	ppv = (VOID **) pvar->calpstr.pElems;
	break;


    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_BSTR | VT_BYREF:
	fIllegalType = fVector || fArray;
	cbchdiv = cbch = sizeof(BYTE);
        cb = 1;
        // Fall through
        
    case VT_ARRAY | VT_VARIANT:
    case VT_ARRAY | VT_VARIANT | VT_BYREF:
	fIllegalType = fVector || fArray;
        if( 0 == cbch )
            cbch = MAXULONG;

        pcount = &count;

    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_I1 | VT_BYREF:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_UI1 | VT_BYREF:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_I2 | VT_BYREF:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI2 | VT_BYREF:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_BOOL | VT_BYREF:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_I4 | VT_BYREF:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_UI4 | VT_BYREF:
    /*
    case VT_ARRAY | VT_I8:
    case VT_ARRAY | VT_I8 | VT_BYREF:
    case VT_ARRAY | VT_UI8:
    case VT_ARRAY | VT_UI8 | VT_BYREF:
    */
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_INT | VT_BYREF:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_UINT | VT_BYREF:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R4 | VT_BYREF:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_ERROR | VT_BYREF:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_DECIMAL | VT_BYREF:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_R8 | VT_BYREF:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_CY | VT_BYREF:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_DATE | VT_BYREF:

	fIllegalType = fVector || fArray;
        if( fIllegalType ) break;

        wMinFormatRequired = max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

        parray = (VT_BYREF & pvar->vt) ? *pvar->pparray : pvar->parray;

        if( NULL == parray )
            cb = 0;
        else
        {
            // Get a pointer to the raw data
            *pstatus = PrivSafeArrayAccessData( const_cast<SAFEARRAY*>(parray), const_cast<void**>(&parraydata) );
            if( FAILED(*pstatus) ) goto Exit;
            fSafeArrayLocked = TRUE;

            pv = parraydata;
            ppv = static_cast<const void* const*>(pv);

            // Determine the dimension count and element size
            cSafeArrayDims = PrivSafeArrayGetDim( const_cast<SAFEARRAY*>(parray) );
            cb = PrivSafeArrayGetElemsize( const_cast<SAFEARRAY*>(parray) );
            PROPASSERT( 0 != cb );

            if( 0 == cSafeArrayDims )
            {
                StatusInvalidParameter( pstatus, "Zero-length safearray dimension" );
                goto Exit;
            }

            // Determine the number of elements, and the total size of parraydata
            count = CalcSafeArrayElements( cSafeArrayDims, parray->rgsabound );
            cb *= count;
        }

        break;

    default:
        propDbg(( DEB_IWARN, "StgConvertVariantToProperty: unsupported vt=%d\n", pvar->vt));
        *pstatus = STATUS_NOT_SUPPORTED;
        goto Exit;

    }   // switch (pvar->vt)

    //  ---------------------------------------------------------
    //  Serialize the property into the property set (pprop->rgb)
    //  ---------------------------------------------------------

    // At this point we've analyzed the PropVariant, and stored
    // information about it in various local variables.  Now we
    // can use this information to serialize the propvar.

    // Early exit if this is an illegal type.

    if (fIllegalType)
    {
        propDbg(( DEB_ERROR, "vt=%d\n", pvar->vt ));
	StatusInvalidParameter(pstatus, "StgConvertVariantToProperty: Illegal VarType");
        goto Exit;
    }

    // Set pbdst to point into the serialization buffer, or to 
    // NULL if there is no such buffer.

    if (pprop == NULL)
    {
	pbdst = NULL;
    }
    else
    {
	pbdst = pprop->rgb;
    }

    // Is this an Array/Vector of Strings/Variants/CFs?
    if (cbch != 0)
    {
        // Yes.

	PROPASSERT(pcount != NULL);
	PROPASSERT(*pcount == 0 || ppv != NULL);
        PROPASSERT(0 == cbByteSwap);

	// Start calculating the serialized size.  Include the sizes
        // of the VT.

	cb = sizeof(ULONG);
        
        // Is this an Array or Vector of Variants?
	if( cbch != MAXULONG )
	{
	    // No.  Include each element's length field.
	    cb += *pcount * sizeof(ULONG);
	}

        // For vectors, write the element count
        if( VT_VECTOR & pvar->vt )
        {
            cb += sizeof(ULONG);

            // Do we have room to write it?
            if( *pcb < cb )
            {
                // No.  Be we'll continue to calculate the cb
                pprop = NULL;
            }
	    else if( pprop != NULL )
	    {
	        *(ULONG *) pbdst = PropByteSwap(*pcount);
	        pbdst += sizeof(ULONG);
	    }
        }   // if( VT_VECTOR & pvar->vt )

        // For arrays, write the dimension count, features, and element size
        else if( NULL != parray )
        {
            PROPASSERT( VT_ARRAY & pvar->vt );
            ULONG cbBounds = 0, cElems = 0;

            // Allow for the VarType & dimension count
            cb += sizeof(DWORD);
            cb += sizeof(UINT);    
            PROPASSERT( sizeof(DWORD) >= sizeof(VARTYPE) );

            // Allow for the rgsaBounds
            *pstatus = SerializeSafeArrayBounds( parray, NULL, &cbBounds, &cElems );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            cb += cbBounds;

            // Do we have room to write this?
            if( *pcb < cb )
            {
                // No, but continue to calc cb
                pprop = NULL;
            }
            else if( NULL != pprop )
            {
                // Yes, we have room.  Write the safearray header data.
                PROPASSERT( sizeof(UINT) == sizeof(ULONG) );

                // Write the SafeArray's internal vartype.  We'll write the real pvar->vt
                // at the bottom of this routine.

                *(DWORD *)  pbdst = 0;
                *(VARTYPE *)pbdst = PropByteSwap( static_cast<VARTYPE>(pvar->vt & VT_TYPEMASK) );
                pbdst += sizeof(DWORD);

                // Write the dimension count
                *(UINT *)pbdst = PropByteSwap(cSafeArrayDims);
                pbdst += sizeof(UINT);

                // Write the bounds
                *pstatus = SerializeSafeArrayBounds( parray, pbdst, &cbBounds, &cElems );
                pbdst += cbBounds;
            }
        }   // if( VT_VECTOR & pvar->vt ) ... else if

        // Walk through the vector/array and write the elements.

	for( ulIndex = *pcount; ulIndex > 0; ulIndex-- )
	{
	    ULONG cbcopy = 0;
            const PROPVARIANT *ppropvarT;

            // Switch on the size of the element.
	    switch (cbch)
	    {
                //
                // VT_VARIANT, VT_VECTOR
                //
		case MAXULONG:
		    cbcopy = MAXULONG;

                    // Perform a recursive serialization
		    StgConvertVariantToPropertyNoEH(
				(PROPVARIANT *) ppv,
				CodePage,
				NULL,
				&cbcopy,
				PID_ILLEGAL,
                                (VT_VECTOR & pvar->vt) ? TRUE : FALSE,
                                (VT_ARRAY  & pvar->vt) ? TRUE : FALSE,
				NULL,
                                &wMinFormatRequired,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

		    break;


                //
                //  VT_CF
                //
		case sizeof(CLIPDATA):

                    // We copy cbSize-sizeof(ulClipFmt) bytes.

                    if( ((CLIPDATA *) ppv)->cbSize < sizeof(ULONG) )
                    {
                        StatusInvalidParameter(pstatus, "StgConvertVariantToProperty: short cbSize on VT_CF");
                        goto Exit;
                    }
                    else
                    {
                        cbcopy = CBPCLIPDATA( *(CLIPDATA*) ppv );
                    }

                    // But increment cb to to include sizeof(ulClipFmt)
                    cb += sizeof(ULONG);
		    break;

                //
                //  VT_LPWSTR
                //
		case sizeof(WCHAR):
		    if (*ppv != NULL)
		    {
			PROPASSERT(IsUnicodeString((WCHAR const *) *ppv, MAXULONG));
			cbcopy = (Prop_wcslen((WCHAR *) *ppv) + 1) * sizeof(WCHAR);
			pv = *ppv;

                        // If byte-swapping is necessary, swap in units of WCHARs
                        CBBYTESWAP( sizeof(WCHAR) );

		    }
		    break;

                //
                //  VT_LPSTR/VT_BSTR
                //
		default:

		    PROPASSERT(cbch == sizeof(BYTE));
		    PROPASSERT(pchConvert == NULL);

		    if (*ppv != NULL)
		    {
			pv = *ppv;

                        // Is this a BSTR?
			if( VT_BSTR == (VT_TYPEMASK & pvar->vt) )
			{
                            // Initialize the # bytes to copy.
			    cbcopy = BSTRLEN(pv);

                            // Verify that the BSTR is terminated.
			    if (((OLECHAR const *) pv)[cbcopy/sizeof(OLECHAR)] != OLESTR('\0'))
			    {
				PROPASSERT(((OLECHAR const *) pv)[cbcopy/sizeof(OLECHAR)] == OLESTR('\0'));
				StatusInvalidParameter(pstatus,
				    "StgConvertVariantToProperty: bad BSTR array null char");
                                goto Exit;
			    }

                            // Also copy the string terminator.
			    cbcopy += sizeof(OLECHAR);

                            // If the propset and the BSTR are in mismatched
                            // codepages (one's Unicode, the other's Ansi),
                            // correct the BSTR now.  In any case, the correct
                            // string is in 'pv'.

			    if (CodePage != CP_WINUNICODE   // Ansi property set
                                &&
                                OLECHAR_IS_UNICODE)         // Unicode BSTR
			    {
                                PROPASSERT(IsUnicodeString((WCHAR*)pv, cbcopy));

				PrpConvertToMultiByte(
						(WCHAR const *) pv,
						cbcopy,
						CodePage,
						&pchConvert,
						&cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

				pv = pchConvert;
			    }

                            else
                            if (CodePage == CP_WINUNICODE   // Unicode property set
                                &&
                                !OLECHAR_IS_UNICODE)        // Ansi BSTRs
                            {
                                PROPASSERT(IsAnsiString((CHAR const *) pv, cbcopy));

                                PrpConvertToUnicode(
		                                (CHAR const *) pv,
		                                cbcopy,
		                                CP_ACP, // In-mem BSTR is in system CP
		                                (WCHAR **) &pchConvert,
		                                &cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                // The Unicode string must have the proper byte order
                                CBBYTESWAP( sizeof(WCHAR) );

                                pv = pchConvert;

                            }

                            else
                            if (CodePage == CP_WINUNICODE )
                            {
                                // Both the BSTR and the property set are Unicode.
                                // No conversion is required, but byte-swapping
                                // is (if byte-swapping is enabled).

                                CBBYTESWAP( sizeof(WCHAR) );
                            }

			}   // if( VT_BSTR == (VT_TYPEMASK & pvar->vt) )

                        // Otherwise it's an LPSTR
			else
			{
			    PROPASSERT(IsAnsiString((char const *) pv, MAXULONG));
			    PROPASSERT(pvar->vt == (VT_VECTOR | VT_LPSTR));
			    cbcopy = strlen((char *) pv) + 1; // + trailing null

			    if (CodePage == CP_WINUNICODE)
			    {
				PROPASSERT(IsAnsiString(
						(CHAR const *) pv,
						cbcopy));
				PrpConvertToUnicode(
						(CHAR const *) pv,
						cbcopy,
						CP_ACP,
						(WCHAR **) &pchConvert,
						&cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                // If byte-swapping, we'll do so with the WCHARs
                                CBBYTESWAP( sizeof(WCHAR) );

				pv = pchConvert;
			    }   
			}   // if (pvar->vt == (VT_VECTOR | VT_BSTR)) ... else
		    }   // if (*ppv != NULL)

                    // In the end, pv should be in the codepage of
                    // the property set.

#ifdef LITTLEENDIAN
                    PROPASSERT( NULL == pv
                                ||
                                CodePage == CP_WINUNICODE && IsUnicodeString((WCHAR*)pv, cbcopy)
                                ||
                                CodePage != CP_WINUNICODE && IsAnsiString((CHAR*)pv, cbcopy));
#endif

		    break;

	    }   // switch (cbch)
	    
            // Add the size of this vector element to the property total
	    cb += DwordAlign(cbcopy);

            // Will there be enough room for this vector element?

	    if (*pcb < cb)
	    {
                // No - we'll continue (thus calculating the total size
                // necessary), but we won't write to the caller's buffer.
		pprop = NULL;
	    }

            // Is this a vector or array of Variants?

	    if (cbch == MAXULONG)
	    {
                // Yes.  Convert this variant.
		if (pprop != NULL)
		{
		    StgConvertVariantToPropertyNoEH(
				(PROPVARIANT *) ppv,
				CodePage,
				(SERIALIZEDPROPERTYVALUE *) pbdst,
				&cbcopy,
				PID_ILLEGAL,
                                (VT_VECTOR & pvar->vt) ? TRUE : FALSE,
                                (VT_ARRAY  & pvar->vt) ? TRUE : FALSE,
				NULL,
                                &wMinFormatRequired,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    pbdst += cbcopy;
		}
		ppv = (VOID **) Add2Ptr(ppv, sizeof(PROPVARIANT));
	    }   // if (cbch == MAXULONG)

	    else
	    {
                // This is a vector/array of strings or clipformats

		PROPASSERT(
		    cbch == sizeof(BYTE) ||
		    cbch == sizeof(WCHAR) ||
		    cbch == sizeof(CLIPDATA));

		PROPASSERT(cbchdiv == sizeof(BYTE) || cbchdiv == sizeof(WCHAR));

                // Are we writing the serialized property?
		if (pprop != NULL)
		{
                    ULONG cbVectOrArrayElement;

                    // Calculate the length of the vector/array element.
                    cbVectOrArrayElement = (ULONG) cbcopy/cbchdiv;

                    // Is this a ClipData?
		    if( cbch == sizeof(CLIPDATA) )
		    {
                        // Adjust the length to include sizeof(ulClipFmt)
                        cbVectOrArrayElement += sizeof(ULONG);

                        // Write the vector element length.
                        *(ULONG *) pbdst = PropByteSwap( cbVectOrArrayElement );

                        // Advance pbdst & write the clipboard format.
			pbdst += sizeof(ULONG);
			*(ULONG *) pbdst = PropByteSwap( ((CLIPDATA *) ppv)->ulClipFmt );
		    }
                    else
                    {
                        // Write the vector element length.
		        *(ULONG *) pbdst = PropByteSwap( cbVectOrArrayElement );
                    }

                    // Advance pbdst & write the property data.
		    pbdst += sizeof(ULONG);
		    RtlCopyMemory(
				pbdst,
				cbch == sizeof(CLIPDATA)?
				  ((CLIPDATA *) ppv)->pClipData :
				  pv,
				cbcopy);

                    // Zero out the pad bytes.
		    RtlZeroMemory(pbdst + cbcopy, DwordRemain(cbcopy));

                    // If byte-swapping is necessary, do so now.
                    PBSBuffer( pbdst, DwordAlign(cbcopy), cbByteSwap );

                    // Advance pbdst to the next property.
		    pbdst += DwordAlign(cbcopy);

		}   // if (pprop != NULL)

                // Advance ppv to point into the PropVariant at the
                // next element in the array.

		if (cbch == sizeof(CLIPDATA))
		{
		    ppv = (VOID **) Add2Ptr(ppv, sizeof(CLIPDATA));
		}
		else
		{
		    ppv++;
		    CoTaskMemFree( pchConvert );
		    pchConvert = NULL;
		}
	    }   // if (cbch == MAXULONG) ... else
	}   // for (cElems = *pcount; cElems > 0; cElems--)
    }   // if (cbch != 0)    // VECTOR/ARRAY of STRING/VARIANT/CF properties

    else
    {
        // This isn't an array or a vector, or the elements of the array/vector
        // aren't Strings, Variants, or CFs.

	ULONG cbCopy = cb;

        // Adjust cb (the total serialized buffer size) for
        // pre-data.

	if( pvar->vt != VT_EMPTY )
	{   // Allow for the VT
	    cb += sizeof(ULONG);
	}
	if( pcount != NULL )
	{   // Allow for the count field
	    cb += sizeof(ULONG);
	}
	if( pclipfmt != NULL )
	{   // Allow for the ulClipFmt field.
	    cb += sizeof(ULONG);
	}
        if( pvar->vt == VT_VERSIONED_STREAM )
        {
            // Allow for the version guid
            cb += sizeof(pvar->pVersionedStream->guidVersion);
        }
        if( VT_ARRAY & pvar->vt )
        {
            // Allow for SafeArray header info
            cb += sizeof(DWORD);   // VT
            cb += sizeof(UINT);    // Dimension count
            PROPASSERT( sizeof(DWORD) >= sizeof(VARTYPE) );

            // Allow for the SafeArray bounds vector

            ULONG cbBounds = 0, cElems = 0;
            *pstatus = SerializeSafeArrayBounds( parray, NULL, &cbBounds, &cElems );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            cb += cbBounds;
        }

        /*
        if( VT_RECORD == (VT_TYPEMASK & pvar->vt) )
        {
            // Allow for the recinfo guids.
            cb += sizeof(GUID);     // Type library ID
            cb += sizeof(WORD);    // Major version
            cb += sizeof(WORD);    // Minor version
            cb += sizeof(LCID);     // Type library Locale ID
            cb += sizeof(GUID);     // Type info ID

            PROPASSERT( sizeof(WORD) == sizeof(USHORT) );   // Size of major/minor versions
            PROPASSERT( NULL == pcount );
        }
        */

        // Is there room in the caller's buffer?
	if( *pcb < cb )
	{   // No - calculate cb but don't write anything.
	    pprop = NULL;
	}

        // 'pv' should point to the source data.  If it does, then
        // we'll copy it into the property set.  If it doesn't but
        // it should, then we'll report an error.

	if (pv != NULL || fCheckNullSource)
	{
	    ULONG cbZero = DwordRemain(cbCopy);

            // Do we have a destination (propset) buffer?

	    if (pprop != NULL)
	    {
                // Copy the GUID for a VT_VERSIONED_STREAM
                if( pvar->vt == VT_VERSIONED_STREAM )
                {
                    if( NULL != pvar->pVersionedStream )
                        *reinterpret_cast<GUID*>(pbdst) = pvar->pVersionedStream->guidVersion;
                    else
                        *reinterpret_cast<GUID*>(pbdst) = GUID_NULL;

                    PropByteSwap( reinterpret_cast<GUID*>(pbdst) );
                    pbdst += sizeof(pvar->pVersionedStream->guidVersion);
                }

                // Does this property have a count field?
		if( pcount != NULL )
		{
                    // Write the count & advance pbdst
		    *(ULONG *) pbdst = PropByteSwap( *pcount );
		    pbdst += sizeof(ULONG);
		}

                // Copy the clipfmt for a VT_CF
		if( pclipfmt != NULL )
		{
                    // Write the ClipFormat & advance pbdst
		    *(ULONG *) pbdst = PropByteSwap( (DWORD) *pclipfmt );
		    pbdst += sizeof(ULONG);
		}

                // Write the array info
                if( (VT_ARRAY & pvar->vt) && NULL != parray )
                {
                    ULONG cbBounds = 0, cElems = 0;

                    PROPASSERT( NULL == pcount && NULL == pclipfmt );
                    PROPASSERT( NULL != parray );
                    PROPASSERT( 0 != cSafeArrayDims );
                    PROPASSERT( VT_ARRAY & pvar->vt );
                    PROPASSERT( sizeof(UINT) == sizeof(ULONG) );

                    *(DWORD *)  pbdst = 0;
                    *(VARTYPE *)pbdst = PropByteSwap( static_cast<VARTYPE>(pvar->vt & VT_TYPEMASK) );
                    pbdst += sizeof(DWORD);

                    *(UINT *)pbdst = PropByteSwap(cSafeArrayDims);
                    pbdst += sizeof(UINT);

                    *pstatus = SerializeSafeArrayBounds( parray, pbdst, &cbBounds, &cElems );
                    pbdst += cbBounds;

                }

                /*
                // Write the Record Info GUIDs
                if( VT_RECORD == (VT_TYPEMASK & pvar->vt) )
                {
                    ULONG iTypeInfo = 0;
                    TYPEATTR *pTypeAttr = NULL;
                    TLIBATTR *pTypeLibAttr = NULL;

                    GUID guidTypeInfo;

                    *pstatus = pRecInfo->GetTypeInfo( &pTypeInfo );
                    if( FAILED(*pstatus) ) goto Exit;

                    *pstatus = pTypeInfo->GetTypeAttr( &pTypeAttr );
                    if( FAILED(*pstatus) ) goto Exit;

                    guidTypeInfo = pTypeAttr->guid;

                    pTypeInfo->ReleaseTypeAttr( pTypeAttr );
                    pTypeAttr = NULL;

                    *pstatus = pTypeInfo->GetContainingTypeLib( &pTypeLib, &iTypeInfo );
                    if( FAILED(*pstatus) ) goto Exit;

                    pTypeInfo->Release();
                    pTypeInfo = NULL;

                    *pstatus = pTypeLib->GetLibAttr( &pTypeLibAttr );
                    if( FAILED(*pstatus) ) goto Exit;

                    *(GUID *)pbdst = PropByteSwap( pTypeLibAttr->guid );
                    pbdst += sizeof(GUID);

                    *(WORD *)pbdst = PropByteSwap( pTypeLibAttr->wMajorVerNum );
                    pbdst += sizeof(WORD);
                    *(WORD *)pbdst = PropByteSwap( pTypeLibAttr->wMinorVerNum );
                    pbdst += sizeof(WORD);

                    *(LCID *)pbdst = PropByteSwap( pTypeLibAttr->lcid );
                    pbdst += sizeof(LCID);

                    *(GUID *)pbdst = PropByteSwap( guidTypeInfo );
                    pbdst += sizeof(GUID);
                    
                }   // if( VT_RECORD == (VT_TYPEMASK & pvar->vt) )
                */
	    }   // if (pprop != NULL)

            // Are we missing the source data?
	    if (pv == NULL)
	    {
		// The Source pointer is NULL.  If cbCopy != 0, the passed
		// VARIANT is not properly formed.

		if (cbCopy != 0)
		{
		    StatusInvalidParameter(pstatus, "StgConvertVariantToProperty: bad NULL");
                    goto Exit;
		}
	    }
	    else if (pprop != NULL)
	    {
                // We have a non-NULL source & destination.
                // First, copy the bytes from the former to the latter.

		RtlCopyMemory(pbdst, pv, cbCopy);

                // Then, if necessary, swap the bytes in the property
                // set (leaving the PropVariant bytes untouched).

                PBSBuffer( (VOID*) pbdst, cbCopy, cbByteSwap );

                // If this is a decimal, zero-out the reserved word at the front
                // (typically, this is actually the VarType, because of the
                // way in which a decimal is stored in a Variant).

                if( VT_DECIMAL == (~VT_BYREF & pvar->vt) )
                    *(WORD *) pbdst = 0;

	    }

            // Did we write the serialization?
	    if (pprop != NULL)
	    {
                // Zero the padding bytes.
		RtlZeroMemory(pbdst + cbCopy, cbZero);

		// Canonicalize VARIANT_BOOLs.  We do this here because
		// we don't want to muck with the caller's buffer directly.

		if ((pvar->vt & ~VT_VECTOR) == VT_BOOL)
		{
		    VARIANT_BOOL *pvb = (VARIANT_BOOL *) pbdst;
		    VARIANT_BOOL *pvbEnd = &pvb[cbCopy/sizeof(*pvb)];

		    while (pvb < pvbEnd)
		    {
			if (*pvb
                            &&
                            PropByteSwap(*pvb) != VARIANT_TRUE)
			{
			    DebugTrace(0, DEBTRACE_ERROR, (
				"Patching VARIANT_TRUE value: %hx --> %hx\n",
				*pvb,
				VARIANT_TRUE));

                            *pvb = PropByteSwap( (VARIANT_BOOL) VARIANT_TRUE );
			}
			pvb++;
		    }
		}
	    }   // if (pprop != NULL)
	}
    }   // if (cbch != 0) ... else    // non - STRING/VARIANT/CF VECTOR property

    // Set the VT in the serialized buffer now that all size
    // checks completed.

    if (pprop != NULL && pvar->vt != VT_EMPTY)
    {
        // When byte-swapping the VT, treat it as a DWORD
        // (it's a WORD in the PropVariant, but a DWORD when
        // serialized).

	pprop->dwType = PropByteSwap( static_cast<DWORD>(~VT_BYREF & pvar->vt) );
    }

    // Update the caller's copy of the total size.
    *pcb = DwordAlign(cb);

Exit:

    if( fSafeArrayLocked )
    {
        PROPASSERT( NULL != parraydata );
        PROPASSERT( NULL != parray );

        PrivSafeArrayUnaccessData( const_cast<SAFEARRAY*>(parray) );
        parraydata = NULL;
    }

    /*
    if( NULL != pTypeInfo )
        pTypeInfo->Release();
    if( NULL != pTypeLib )
        pTypeLib->Release();
    */

    if( NULL != pwMinFormatRequired )
        *pwMinFormatRequired = wMinFormatRequired;

    CoTaskMemFree( pchConvert );
    return(pprop);

}




//+---------------------------------------------------------------------------
// Function:    StgConvertPropertyToVariant, private
//
// Synopsis:    Convert a SERIALIZEDPROPERTYVALUE to a PROPVARIANT
//
// Arguments:   [pprop]         -- pointer to SERIALIZEDPROPERTYVALUE
//              [PointerDelta]	-- adjustment to pointers to get user addresses
//              [fConvertNullStrings] -- map NULL strings to empty strings
//              [CodePage]	-- property set codepage
//              [pvar]          -- pointer to PROPVARIANT
//              [pma]		-- caller's memory allocation routine
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     TRUE if property is an indirect property type
//---------------------------------------------------------------------------

#ifdef KERNEL
#define ADJUSTPOINTER(ptr, delta, type)	(ptr) = (type) Add2Ptr((ptr), (delta))
#else
#define ADJUSTPOINTER(ptr, delta, type)
#endif

// First, define a wrapper for this function which returns errors
// using NT Exception Handling, rather than returning an NTSTATUS.

#if defined(WINNT)

EXTERN_C BOOLEAN __stdcall
StgConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma)
{
    BOOLEAN boolRet;
    NTSTATUS status;

    boolRet = StgConvertPropertyToVariantNoEH(
                        pprop, CodePage, pvar,
                        pma, &status );

    if (!NT_SUCCESS( status ))
        RtlRaiseStatus( status );

    return (boolRet);

}

#endif // #if defined(WINNT)


// Now define the body of the function, returning errors with an
// NTSTATUS value instead of raising.

BOOLEAN
StgConvertPropertyToVariantNoEH(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    //  ------
    //  Locals
    //  ------

    BOOLEAN fIndirect = FALSE;

    // Buffers which must be freed before exiting.
    CHAR *pchConvert = NULL, *pchByteSwap = NULL;

    VOID **ppv = NULL;
    VOID *pv = NULL;
    const VOID *pvCountedString = NULL;

    VOID *pvSafeArrayData = NULL;
    SAFEARRAY *psa = NULL;
    BOOL fSafeArrayLocked = FALSE;

    ULONG cbskip = sizeof(ULONG);
    ULONG cb = 0;

    // Size of byte-swapping units (must be signed).
    INT cbByteSwap = 0;

    BOOLEAN fPostAllocInit = FALSE;
    BOOLEAN fNullLegal = (BOOLEAN) ( (PropByteSwap(pprop->dwType) & VT_VECTOR) != 0 );
    const BOOLEAN fConvertToEmpty = FALSE;

    IFDBG( HRESULT &hr = *pstatus; )
    propITraceStatic( "StgConvertPropertyToVariantNoEH" );
    propTraceParameters(( "pprop=%p, CodePage=%d, pvar=%p, pma=%p" ));

    //  ---------------------------------------------------------
    //  Based on the VT, calculate ppv, pv, cbskip,
    //  cb, fPostAllocInit, fNullLegal, & fConvertToEmpty
    //  ---------------------------------------------------------

    // Set the VT in the PropVariant.  Note that in 'pprop' it's a
    // DWORD, but it's a WORD in 'pvar'.

    pvar->vt = (VARTYPE) PropByteSwap(pprop->dwType);

    if( VT_BYREF & pvar->vt )
    {
        // ByRef's are always indirected on their way to the property set.
        StatusError( pstatus, "StgConvertPropertyToVariant found VT_BYREF", 
                     STATUS_INTERNAL_DB_CORRUPTION );
        goto Exit;
    }

    switch( pvar->vt )
    {
	case VT_EMPTY:
	case VT_NULL:
	    break;

        case VT_I1:
            //AssertByteField(cVal);          // VT_I1
            cb = sizeof(pvar->cVal);
            pv = &pvar->cVal;
            break;

	case VT_UI1:
	    AssertByteField(bVal);          // VT_UI1
	    cb = sizeof(pvar->bVal);
	    pv = &pvar->bVal;
	    break;

	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
	    AssertShortField(iVal);         // VT_I2
	    AssertShortField(uiVal);        // VT_UI2
	    AssertShortField(boolVal);      // VT_BOOL
	    cb = sizeof(pvar->iVal);
	    pv = &pvar->iVal;

            // If swapping, swap as a WORD
            CBBYTESWAP(cb);
	    break;

	case VT_I4:
        case VT_INT:
	case VT_UI4:
        case VT_UINT:
	case VT_R4:
	case VT_ERROR:
	    AssertLongField(lVal);          // VT_I4
            //AssertLongField(intVal)       // VT_INT
	    AssertLongField(ulVal);         // VT_UI4
            //AssertLongField(uintVal);     // VT_UINT
	    AssertLongField(fltVal);        // VT_R4
	    AssertLongField(scode);         // VT_ERROR

	    cb = sizeof(pvar->lVal);
	    pv = &pvar->lVal;

            // If swapping, swap as a DWORD
            CBBYTESWAP(cb);
	    break;

	case VT_I8:
	case VT_UI8:
	case VT_FILETIME:
	    AssertLongLongField(hVal);		// VT_I8
	    AssertLongLongField(uhVal);		// VT_UI8
	    AssertLongLongField(filetime);	// VT_FILETIME
	    cb = sizeof(pvar->hVal);
	    pv = &pvar->hVal;

            // If swapping, swap as a pair of DWORDs
            CBBYTESWAP(sizeof(DWORD));
	    break;

	case VT_R8:
	case VT_CY:
	case VT_DATE:
	    AssertLongLongField(dblVal);	// VT_R8
	    AssertLongLongField(cyVal);		// VT_CY
	    AssertLongLongField(date);		// VT_DATE
	    cb = sizeof(pvar->dblVal);
	    pv = &pvar->dblVal;

            // If swapping, swap as a LONGLONG
            CBBYTESWAP(cb);
	    break;

	case VT_CLSID:
	    AssertStringField(puuid);		// VT_CLSID
	    cb = sizeof(GUID);
	    ppv = (VOID **) &pvar->puuid;
	    cbskip = 0;

            // If swapping, special handling is required
            CBBYTESWAP( CBBYTESWAP_UID );
	    break;

        case VT_DECIMAL:
            //AssertVarField(decVal, sizeof(DECIMAL));  // VT_DECIMAL
            cb = sizeof(DECIMAL);
            pv = (VOID *) &pvar->decVal;

            #ifdef BIGENDIAN
            #error Big-Endian support required
            // Define CBBYTESWAP_DECIMAL, and add support for it below
            //CBBYTESWAP( CBBYTESWAP_DECIMAL );
            #endif
            break;


	case VT_CF:

            // Allocate a CLIPDATA buffer.  Init-zero it so that we can
            // do a safe cleanup should an early-exist be necessary.
	    pvar->pclipdata = (CLIPDATA *) pma->Allocate(sizeof(CLIPDATA));
	    if (pvar->pclipdata == NULL)
	    {
		StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for CF");
                goto Exit;
	    }
            RtlZeroMemory( pvar->pclipdata, sizeof(CLIPDATA) );

            // Set the size (includes sizeof(ulClipFmt))
	    pvar->pclipdata->cbSize = PropByteSwap( ((CLIPDATA *) pprop->rgb)->cbSize );
            if( pvar->pclipdata->cbSize < sizeof(pvar->pclipdata->ulClipFmt) )
            {
                StatusError(pstatus, "StgConvertPropertyToVariant:  Invalid VT_CF cbSize",
                            STATUS_INTERNAL_DB_CORRUPTION);
                goto Exit;
            }

            // Set the # bytes-to-copy.  We can't use the CBPCLIPDATA macro
            // here because it assumes that the CLIPDATA parameter is correctly
            // byte-swapped.
	    cb = PropByteSwap( *(DWORD*) pprop->rgb ) - sizeof(pvar->pclipdata->ulClipFmt);

            // Set the ClipFormat itself.
	    pvar->pclipdata->ulClipFmt = PropByteSwap( ((CLIPDATA *) pprop->rgb)->ulClipFmt );

            // Prepare for the alloc & copy.  Put the buffer pointer
            // in pClipData, & skip the ulClipFmt in the copy.
	    ppv = (VOID **) &pvar->pclipdata->pClipData;
	    cbskip += sizeof(ULONG);

            // It's legal for cb to be 0.
            fNullLegal = TRUE;

            // Adjust to the user-mode pointer (Kernel only)
	    ADJUSTPOINTER(pvar->pclipdata, PointerDelta, CLIPDATA *);

	    break;

	case VT_BLOB:
	case VT_BLOB_OBJECT:
	    cb = pvar->blob.cbSize = PropByteSwap( *(ULONG *) pprop->rgb );
	    ppv = (VOID **) &pvar->blob.pBlobData;
	    fNullLegal = TRUE;
	    break;

        case VT_VERSIONED_STREAM:

	    pvar->pVersionedStream = reinterpret_cast<LPVERSIONEDSTREAM>( pma->Allocate( sizeof(*pvar->pVersionedStream) ));
	    if (pvar->pVersionedStream == NULL)
	    {
		StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for VersionedStream");
                goto Exit;
	    }
            RtlZeroMemory( pvar->pVersionedStream, sizeof(*pvar->pVersionedStream) );

            pvar->pVersionedStream->guidVersion = *reinterpret_cast<const GUID*>( pprop->rgb );
            PropByteSwap( &pvar->pVersionedStream->guidVersion );

            // A buffer will be allocated and the stream name put into *ppv.
            ppv = reinterpret_cast<void**>( &pvar->pVersionedStream->pStream );

            // Point to the beginning of the string
            pvCountedString = Add2Ptr( pprop->rgb, sizeof(GUID) );

            // When copying the string, we will skip the guid
            cbskip += sizeof(GUID);


            // Fall through

	case VT_STREAM:
	case VT_STREAMED_OBJECT:
	case VT_STORAGE:
	case VT_STORED_OBJECT:
	    fIndirect = TRUE;
	    goto lpstr;

	case VT_BSTR:
	case VT_LPSTR:
lpstr:
	    AssertStringField(pszVal);		// VT_STREAM, VT_STREAMED_OBJECT
	    AssertStringField(pszVal);		// VT_STORAGE, VT_STORED_OBJECT
	    AssertStringField(bstrVal);		// VT_BSTR
	    AssertStringField(pszVal);		// VT_LPSTR

            // The string to be converted is loaded into pvCountedString
            if( NULL == pvCountedString )
                pvCountedString = reinterpret_cast<const void*>(pprop->rgb);

            // [length field] bytes should be allocated
	    cb = PropByteSwap( *(ULONG *) pvCountedString );

            // When a buffer is allocated, its pointer will go
            // in *ppv.
            if( NULL == ppv )
	        ppv = (VOID **) &pvar->pszVal;

            // Is this a non-empty string?
	    if (cb != 0)
	    {
                // Is the serialized value one that should be
                // an Ansi string in the PropVariant?

		if (pvar->vt == VT_LPSTR        // It's an LPSTR (always Ansi), or
                    ||
                    !OLECHAR_IS_UNICODE )       //    PropVariant strings are Ansi
		{
                    // If the propset is Unicode, we must do a
                    // conversion to Ansi.

		    if (CodePage == CP_WINUNICODE)
		    {
                        WCHAR *pwsz = (WCHAR *) Add2ConstPtr(pvCountedString, sizeof(ULONG));

                        // If necessary, swap the WCHARs.  'pwsz' will point to
                        // the correct (system-endian) string either way.  If an
                        // alloc is necessary, 'pchByteSwap' will point to the new
                        // buffer.

                        PBSInPlaceAlloc( &pwsz, (WCHAR**) &pchByteSwap, pstatus );
                        if( !NT_SUCCESS( *pstatus )) goto Exit;
			PROPASSERT(IsUnicodeString( pwsz, cb));

                        // Convert the properly-byte-ordered string in 'pwsz'
                        // into MBCS, putting the result in pchConvert.

			PrpConvertToMultiByte(
				    pwsz,
				    cb,
				    CP_ACP,  // Use the system default codepage
				    &pchConvert,
				    &cb,
                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    }
		}   // if (pvar->vt == VT_LPSTR) ...

                // Otherwise, even though this string may be
                // Ansi in the Property Set, it must be Unicode
                // in the PropVariant.

		else
		{
                    // If necessary, convert to Unicode

		    if (CodePage != CP_WINUNICODE)
		    {
			PROPASSERT(
			    IsAnsiString(
				    (CHAR const *)
					Add2ConstPtr(pvCountedString, sizeof(ULONG)),
				    cb));

			PrpConvertToUnicode(
				    (CHAR const *)
					Add2ConstPtr(pvCountedString, sizeof(ULONG)),
				    cb,
				    CodePage,
				    (WCHAR **) &pchConvert,
				    &cb,
                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

		    }   // if (CodePage != CP_WINUNICODE)
                    else
                    {
                        // The value is Unicode both the property set
                        // and the PropVariant.  If byte-swapping is
                        // necessary, we'll do so in units of WCHARs.

                        CBBYTESWAP( sizeof(WCHAR) );
                    }

		}   // if (pvar->vt == VT_LPSTR) ... else

                // If this is a BSTR property, verify that it is terminated
                // appropriately.

		if (VT_BSTR == pvar->vt)
		{
                    BSTR bstr = ( NULL == pchConvert )
                                ? (BSTR) Add2ConstPtr(pvCountedString, sizeof(ULONG))
                                : (BSTR) pchConvert;

                    // On little-endian machines, validate the string.
#ifdef LITTLEENDIAN
                    PROPASSERT( IsOLECHARString( bstr, MAXULONG ));
#endif

                    // Validate the bstr.  Note that even though this bstr may
                    // be byte-swapped, this 'if' block still works because
                    // ByteSwap('\0') == ('\0').

                    PROPASSERT( PropByteSwap( (OLECHAR) OLESTR('\0') )
                                ==
                                (OLECHAR) OLESTR('\0') );

                    if( (cb & (sizeof(OLECHAR) - 1)) != 0
                        &&
                        OLECHAR_IS_UNICODE
                        ||
                        bstr[cb/sizeof(OLECHAR) - 1] != OLESTR('\0') )
                    {
                        StatusError(pstatus, "StgConvertPropertyToVariant:  Invalid BSTR Property",
                                     STATUS_INTERNAL_DB_CORRUPTION);
                        goto Exit;
                    }
		}   // if (VT_BSTR == pvar->vt)
	    }   // if (cb != 0)

	    fNullLegal = TRUE;
	    break;

	case VT_LPWSTR:
	    fNullLegal = TRUE;
	    AssertStringField(pwszVal);		// VT_LPWSTR
	    cb = PropByteSwap( *(ULONG *) pprop->rgb ) * sizeof(WCHAR);
	    ppv = (VOID **) &pvar->pwszVal;

            // If byte-swapping will be necessary, do so for the WCHARs
            CBBYTESWAP( sizeof(WCHAR) );

	    break;

	case VT_VECTOR | VT_I1:
            //AssertByteVector(cac);              // VT_I1

	case VT_VECTOR | VT_UI1:
	    AssertByteVector(caub);		// VT_UI1
	    pvar->caub.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->caub.cElems * sizeof(pvar->caub.pElems[0]);
	    ppv = (VOID **) &pvar->caub.pElems;
	    break;

	case VT_VECTOR | VT_I2:
	case VT_VECTOR | VT_UI2:
	case VT_VECTOR | VT_BOOL:
	    AssertShortVector(cai);		// VT_I2
	    AssertShortVector(caui);		// VT_UI2
	    AssertShortVector(cabool);		// VT_BOOL
	    pvar->cai.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cai.cElems * sizeof(pvar->cai.pElems[0]);
	    ppv = (VOID **) &pvar->cai.pElems;

            // If swapping, swap as a WORD
            CBBYTESWAP(sizeof(pvar->cai.pElems[0]));
	    break;

	case VT_VECTOR | VT_I4:
	case VT_VECTOR | VT_UI4:
	case VT_VECTOR | VT_R4:
	case VT_VECTOR | VT_ERROR:
	    AssertLongVector(cal);		// VT_I4
	    AssertLongVector(caul);		// VT_UI4
	    AssertLongVector(caflt);		// VT_R4
	    AssertLongVector(cascode);		// VT_ERROR
	    pvar->cal.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cal.cElems * sizeof(pvar->cal.pElems[0]);
	    ppv = (VOID **) &pvar->cal.pElems;

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(sizeof(pvar->cal.pElems[0]));
	    break;

	case VT_VECTOR | VT_I8:
	case VT_VECTOR | VT_UI8:
	case VT_VECTOR | VT_FILETIME:
	    AssertLongLongVector(cah);		// VT_I8
	    AssertLongLongVector(cauh);		// VT_UI8
	    AssertLongLongVector(cafiletime);	// VT_FILETIME
	    pvar->cah.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cah.cElems * sizeof(pvar->cah.pElems[0]);
	    ppv = (VOID **) &pvar->cah.pElems;

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(sizeof(DWORD));
	    break;

	case VT_VECTOR | VT_R8:
	case VT_VECTOR | VT_CY:
	case VT_VECTOR | VT_DATE:
	    AssertLongLongVector(cadbl);	// VT_R8
	    AssertLongLongVector(cacy);		// VT_CY
	    AssertLongLongVector(cadate);	// VT_DATE
	    pvar->cadbl.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cadbl.cElems * sizeof(pvar->cadbl.pElems[0]);
	    ppv = (VOID **) &pvar->cadbl.pElems;

            // If byte swapping, swap as LONGLONGs
            CBBYTESWAP(sizeof(pvar->cadbl.pElems[0]));
	    break;


	case VT_VECTOR | VT_CLSID:
	    AssertVarVector(cauuid, sizeof(GUID));
	    pvar->cauuid.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cauuid.cElems * sizeof(pvar->cauuid.pElems[0]);
	    ppv = (VOID **) &pvar->cauuid.pElems;

            // If byte swapping, special handling is required.
            CBBYTESWAP( CBBYTESWAP_UID );
	    break;

	case VT_VECTOR | VT_CF:

            // Set the count of clipdatas
	    pvar->caclipdata.cElems = PropByteSwap( *(ULONG *) pprop->rgb );

            // How much should we allocate for caclipdata.pElems, & where
            // should that buffer pointer go?
	    cb = pvar->caclipdata.cElems * sizeof(pvar->caclipdata.pElems[0]);
	    ppv = (VOID **) &pvar->caclipdata.pElems;

            // We need to do work after pElems is allocated.
	    fPostAllocInit = TRUE;
	    break;

	case VT_VECTOR | VT_BSTR:
	case VT_VECTOR | VT_LPSTR:
	    AssertStringVector(cabstr);     // VT_BSTR
	    AssertStringVector(calpstr);    // VT_LPSTR

            // Put the element count in the PropVar
	    pvar->calpstr.cElems = PropByteSwap( *(ULONG *) pprop->rgb );

            // An array of cElems pointers should be alloced
	    cb = pvar->calpstr.cElems * sizeof(CHAR*);

            // Show where the array of pointers should go.
	    ppv = (VOID **) &pvar->calpstr.pElems;

            // Additional allocs will be necessary after the vector
            // is alloced.
	    fPostAllocInit = TRUE;

	    break;

	case VT_VECTOR | VT_LPWSTR:
	    AssertStringVector(calpwstr);	// VT_LPWSTR
	    pvar->calpwstr.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->calpwstr.cElems * sizeof(WCHAR *);
	    ppv = (VOID **) &pvar->calpwstr.pElems;
	    fPostAllocInit = TRUE;
	    break;

	case VT_VECTOR | VT_VARIANT:
	    AssertVariantVector(capropvar);	// VT_VARIANT
	    pvar->capropvar.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->capropvar.cElems * sizeof(PROPVARIANT);
	    ppv = (VOID **) &pvar->capropvar.pElems;
	    fPostAllocInit = TRUE;
	    break;


        case VT_ARRAY | VT_BSTR:
            cbskip = 0;
            cb = sizeof(BSTR);
            ppv = (VOID**) &pvar->parray;
            fPostAllocInit = TRUE;
            break;
        
        case VT_ARRAY | VT_VARIANT:
            cbskip = 0;
            cb = sizeof(PROPVARIANT);
            ppv = (VOID**) &pvar->parray;
            fPostAllocInit = TRUE;
            break;

        case VT_ARRAY | VT_I1:
        case VT_ARRAY | VT_UI1:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(BYTE);
            break;

        case VT_ARRAY | VT_I2:
        case VT_ARRAY | VT_UI2:
        case VT_ARRAY | VT_BOOL:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(USHORT);
            break;

        case VT_ARRAY | VT_I4:
        case VT_ARRAY | VT_UI4:
        case VT_ARRAY | VT_INT:
        case VT_ARRAY | VT_UINT:
        case VT_ARRAY | VT_R4:
        case VT_ARRAY | VT_ERROR:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(ULONG);
            break;

        case VT_ARRAY | VT_DECIMAL:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(DECIMAL);
            break;

        /*
        case VT_ARRAY | VT_I8:
        case VT_ARRAY | VT_UI8:
        */
        case VT_ARRAY | VT_DATE:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(ULONGLONG);

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(DWORD);

            break;

        case VT_ARRAY | VT_R8:
        case VT_ARRAY | VT_CY:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(CY);

            // If byte swapping, swap as LONGLONGs
            CBBYTESWAP(cb);

            break;

	default:
            propDbg(( DEB_IWARN, "StgConvertPropertyToVariant: unsupported vt=%d\n", pvar->vt ));
            *pstatus = STATUS_NOT_SUPPORTED;
            goto Exit;

    }   // switch (pvar->vt)

    //  ------------------------------------------------------
    //  We've now analyzed the serialized property and learned
    //  about it, now we can put it into the PropVariant.
    //  ------------------------------------------------------

    // Is this a simple, unaligned scalar?

    if (pv != NULL)
    {
        // Yes.  All we need to do is copy some bytes.

	PROPASSERT(pchConvert == NULL);
        PROPASSERT( cb < sizeof(PROPVARIANT)-sizeof(VARTYPE)
                    ||
                    VT_DECIMAL == pprop->dwType );

	RtlCopyMemory(pv, pprop->rgb, cb);

        // We also might need to byte-swap them (but only in the PropVar).
        PBSBuffer( pv, cb, cbByteSwap );

        // Decimal requires special handling, since it overlaps the VT field.
        if( VT_DECIMAL == PropByteSwap(pprop->dwType) )
            pvar->vt = VT_DECIMAL;

    }

    // Otherwise, we need to allocate memory, to which the
    // PropVariant will point.

    else if (ppv != NULL)
    {
	*ppv = NULL;

	if (!fConvertToEmpty && cb == 0)    // Kernel only
	{
	    if (!fNullLegal)
	    {
		StatusInvalidParameter(pstatus, "StgConvertPropertyToVariant: bad NULL");
                goto Exit;
	    }
	}

        else
	{
            SAFEARRAYBOUND *rgsaBounds = NULL;
            ULONG cElems = 0, cbBounds = 0;

	    PROPASSERT(cb != 0 || fConvertToEmpty);

            // Allocate the necessary buffer (which we figured out in the
            // switch above).  For vector properties, 
            // this will just be the pElems buffer at this point.
            // For singleton BSTR properties, we'll skip this allocate
            // altogether; they're allocated with SysStringAlloc.

            if( VT_ARRAY & pvar->vt )
            {
                VARTYPE vtInternal; // The VT as determined by the SafeArray
                UINT cDims = 0;
                // Read the SafeArray's internal VT
                vtInternal = *(VARTYPE*) &pprop->rgb[cbskip];
                cbskip += sizeof(ULONG);

                // Read the dimension count
                cDims = *(ULONG*) &pprop->rgb[cbskip];
                cbskip += sizeof(DWORD);

                // Point to the SAFEARRAYBOUND array
                rgsaBounds = (SAFEARRAYBOUND*) &pprop->rgb[cbskip];

                // We now have everything we need to create a new safe array
                psa = PrivSafeArrayCreateEx( vtInternal, cDims, rgsaBounds, NULL );
                if( NULL == psa )
                {
                    propDbg(( DEB_ERROR, "Failed SafeArrayCreateEx, vt=0x%x, cDims=%d",
                              vtInternal, cDims ));
                    *pstatus = STATUS_NO_MEMORY;
                    goto Exit;
                }
                cbskip += cDims * sizeof(SAFEARRAYBOUND);

                // Calculate the number of elements in the safearray

                PROPASSERT( cb == psa->cbElements );
                *pstatus = SerializeSafeArrayBounds( psa, NULL, &cbBounds, &cElems );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
                cb *= cElems;

                // Put this SafeArray into pvar->parray
                *ppv = psa;

                // Get the newly-created psa->pvData
                *pstatus = PrivSafeArrayAccessData( psa, &pvSafeArrayData );
                if( FAILED(*pstatus) ) goto Exit;
                fSafeArrayLocked = TRUE;

                ppv = &pvSafeArrayData;
                PROPASSERT( NULL != ppv && psa != *ppv );

            }
            else if( VT_BSTR != pvar->vt  )
            {
		*ppv = pma->Allocate(max(1, cb));
		if (*ppv == NULL)
		{
		    StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory");
                    goto Exit;
		}
            }

            // Can we load the PropVariant with a simple copy?
	    if( !fPostAllocInit )
	    {
                // Yes - all we need is a copy (and an implicit
                // alloc for BSTRs).

                if (VT_BSTR == pvar->vt)
		{
                    // We do the copy with the OleAutomation routine
                    // (which does an allocation too).
                    // If byte-swapping is necessary, the switch block
                    // already took care of it, leaving the buffer in
                    // 'pchConvert'.

                    PROPASSERT( NULL == *ppv );
                    *ppv = PrivSysAllocString( ( pchConvert != NULL )
                                                ? (OLECHAR *) pchConvert
                                                : (OLECHAR *) (pprop->rgb + cbskip) );
		    if (*ppv == NULL)
		    {
		        StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory");
                        goto Exit;
		    }
		}
                else
                {

                    // Copy the property into the PropVariant.
		    RtlCopyMemory(
			    *ppv,
			    pchConvert != NULL?
				(BYTE const *) pchConvert : pprop->rgb + cbskip,
			    cb);

                }

                // If necessary, byte-swap the property (only in the PropVar).
                PBSBuffer( *ppv, cb, cbByteSwap );

	    }   // if (!fPostAllocInit)

	    else
	    {
                // We must do more than just a copy.
                // (Thus this is a vector/array of strings, variants, or CFs).

		BYTE const *pbsrc;

                if( VT_VECTOR & pvar->vt )
                {
                    // Get the element count
                    cElems = pvar->calpstr.cElems;

                    // Initialize the source pointer to point just beyond
                    // the element count.
                    pbsrc = pprop->rgb + sizeof(ULONG);
                }
                else
                {   
                    PROPASSERT( VT_ARRAY & pvar->vt );
                    PROPASSERT( 0 != cElems );

                    // Initialize the source pointer to point just beyond the VT, cDims, and bounds
                    pbsrc = pprop->rgb + cbBounds + sizeof(DWORD) + sizeof(UINT);
                }

		// Zero all pointers in the pElems array for easy caller cleanup
		ppv = (VOID **) *ppv;
		RtlZeroMemory(ppv, cb);

                // Handle Variants, ClipFormats, & Strings separately.

		if( (VT_VECTOR | VT_VARIANT) == pvar->vt
                    ||
                    (VT_ARRAY  | VT_VARIANT) == pvar->vt )
		{
		    PROPVARIANT *pvarT = (PROPVARIANT *) ppv;

		    PROPASSERT(!fIndirect);
		    while (cElems-- > 0)
		    {
			ULONG cbelement;

			fIndirect = StgConvertPropertyToVariantNoEH(
					(SERIALIZEDPROPERTYVALUE const *) pbsrc,
					CodePage,
					pvarT,
					pma,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
			PROPASSERT(!fIndirect);

			cbelement = PropertyLengthNoEH(
					(SERIALIZEDPROPERTYVALUE const *) pbsrc,
					MAXULONG,
					CPSS_VARIANTVECTOR,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

			pbsrc += cbelement;
			pvarT++;
		    }
		}   // if (pvar->vt == (VT_VECTOR | VT_VARIANT))

		else if (pvar->vt == (VT_VECTOR | VT_CF))
		{
                    // Set pcd to &pElems[0]
		    CLIPDATA *pcd = (CLIPDATA *) ppv;

                    // Loop through pElems
		    while (cElems-- > 0)
		    {
                        // What is the size of the clipdata (including sizeof(ulClipFmt))?
                        pcd->cbSize = PropByteSwap( ((CLIPDATA *) pbsrc)->cbSize );
                        if( pcd->cbSize < sizeof(pcd->ulClipFmt) )
                        {
                            StatusError(pstatus, "StgConvertPropertyToVariant:  Invalid VT_CF cbSize",
                                        STATUS_INTERNAL_DB_CORRUPTION);
                            goto Exit;
                        }

                        // How many bytes should we copy to pClipData?
			cb = CBPCLIPDATA( *pcd );

                        // Set the ClipFormat & advance pbsrc to the clipdata.
			pcd->ulClipFmt = PropByteSwap( ((CLIPDATA *) pbsrc)->ulClipFmt );
			pbsrc += 2 * sizeof(ULONG);

                        // Copy the ClipData into the PropVariant

			pcd->pClipData = NULL;
			if (cb > 0)
			{
                            // Get a buffer for the clip data.
			    pcd->pClipData = (BYTE *) pma->Allocate(cb);
			    if (pcd->pClipData == NULL)
			    {
				StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for CF[]");
                                goto Exit;
			    }

                            // Copy the clipdata into pElems[i].pClipData
			    RtlCopyMemory(pcd->pClipData, pbsrc, cb);
			    ADJUSTPOINTER(pcd->pClipData, PointerDelta, BYTE *);

			}   // if (cb > 0)

                        // Move pcd to &pElems[i+1], and advance the buffer pointer.
			pcd++;
			pbsrc += DwordAlign(cb);

		    }   // while (cElems-- > 0)
		}   // else if (pvar->vt == (VT_VECTOR | VT_CF))

		else    // This is a vector or array of some kind of string.
		{
                    // Assume that characters are CHARs
		    ULONG cbch = sizeof(char);

		    if( pvar->vt == (VT_VECTOR | VT_LPWSTR) )
		    {
                        // Characters are WCHARs
			cbch = sizeof(WCHAR);

                        // If byte-swapping is enabled, LPWSTRs must have
                        // their WCHARs swapped.
                        CBBYTESWAP( sizeof(WCHAR) );
		    }

		    while (cElems-- > 0)
		    {
			ULONG cbcopy;

			cbcopy = cb = PropByteSwap( *((ULONG *) pbsrc) ) * cbch;
			pbsrc += sizeof(ULONG);

			pv = (VOID *) pbsrc;
			PROPASSERT(*ppv == NULL);
			PROPASSERT(pchConvert == NULL);

			if( fConvertToEmpty || cb != 0 )
			{
                            // Do we have actual data to work with?
			    if( cb != 0 )
			    {
                                // Special BSTR pre-processing ...
				if( (VT_VECTOR | VT_BSTR) == pvar->vt
                                    ||
                                    (VT_ARRAY  | VT_BSTR) == pvar->vt )
				{
                                    // If the propset & in-memory BSTRs are of
                                    // different Unicode-ness, convert now.

				    if (CodePage != CP_WINUNICODE   // Ansi PropSet
                                        &&
                                        OLECHAR_IS_UNICODE )        // Unicode BSTRs
				    {
                                        PROPASSERT(IsAnsiString((CHAR*) pv, cb));
					PrpConvertToUnicode(
						    (CHAR const *) pv,
						    cb,
						    CodePage,
						    (WCHAR **) &pchConvert,
						    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
					pv = pchConvert;
				    }

                                    else
                                    if (CodePage == CP_WINUNICODE   // Unicode PropSet
                                        &&
                                        !OLECHAR_IS_UNICODE )       // Ansi BSTRs
                                    {
                                        // If byte-swapping is necessary, the string from
                                        // the propset must be swapped before it can be
                                        // converted to MBCS.  If such a conversion
                                        // is necessary, a new buffer is alloced and 
                                        // put in pchByteSwap.  Either way, 'pv' points
                                        // to the correct string.

                                        PBSInPlaceAlloc( (WCHAR**) &pv,
                                                         (WCHAR**) &pchByteSwap,
                                                         pstatus );
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
			                PROPASSERT(IsUnicodeString((WCHAR*)pv, cb));

                                        // Convert the Unicode string from the property
                                        // set to Ansi.

			                PrpConvertToMultiByte(
				                    (WCHAR const *) pv,
				                    cb,
				                    CP_ACP,  // Use the system default codepage
				                    &pchConvert,
				                    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                        // 'pv' always has the correct string.
                                        pv = pchConvert;
                                    }
                                    else
                                    if (CodePage == CP_WINUNICODE)
                                    {
                                        // Both the BSTR is unicode in the property set,
                                        // and must remain unicode in the PropVariant.
                                        // But byte-swapping may still be necessary.

                                        CBBYTESWAP( sizeof(WCHAR) );
                                    }
                                                            

#ifdef LITTLEENDIAN
                                    PROPASSERT( IsOLECHARString((BSTR)pv, cbcopy ));
#endif

                                    // Verify that the BSTR is valid.
                                    if( (cbcopy & (sizeof(OLECHAR)-1)) != 0
                                        &&
                                        OLECHAR_IS_UNICODE
                                        ||
                                        ((OLECHAR const *) pv)[cbcopy/sizeof(OLECHAR) - 1] != OLESTR('\0') )
                                    {
                                        StatusError(pstatus, "StgConvertPropertyToVariant:  Invalid BSTR element",
                                                    STATUS_INTERNAL_DB_CORRUPTION);
                                        goto Exit;
                                    }

				}   // if( (VT_VECTOR | VT_BSTR) == pvar->vt ...

                                // Special LPSTR pre-processing
				else if (pvar->vt == (VT_VECTOR | VT_LPSTR))
				{
                                    // LPSTRs are always Ansi.  If the string
                                    // is Unicode in the propset, convert now.

				    if (CodePage == CP_WINUNICODE)
				    {
                                        // If byte-swapping is necessary, the string from
                                        // the propset must be swapped before it can be
                                        // converted to MBCS.  If such a conversion
                                        // is necessary, a new buffer is alloced and 
                                        // put in pchByteSwap.  Either way, 'pv' points
                                        // to the correct string.

                                        PBSInPlaceAlloc( (WCHAR**) &pv, (WCHAR**) &pchByteSwap,
                                                      pstatus );
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
					PROPASSERT(IsUnicodeString((WCHAR*)pv, cb));

                                        // Convert to Ansi.
					PrpConvertToMultiByte(
						    (WCHAR const *) pv,
						    cb,
						    CP_ACP,     // Use the system default codepage
						    &pchConvert,
						    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                        pv = pchConvert;
				    }

                                    PROPASSERT( IsAnsiString( (CHAR const *)pv, cbcopy ));
				}   // else if (pvar->vt == (VT_VECTOR | VT_LPSTR))
			    }   // if (cb != 0)


                            // Allocate memory in the PropVariant and copy
                            // the string.

                            if( (VT_BSTR | VT_VECTOR) == pvar->vt
                                ||
                                (VT_BSTR | VT_ARRAY)  == pvar->vt )
                            {
                                // For BSTRs, the allocate/copy is performed
                                // by SysStringAlloc.

                                *ppv = PrivSysAllocString( (BSTR) pv );
				if (*ppv == NULL)
				{
				    StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for BSTR element");
                                    goto Exit;
				}

                                // The BSTR length should be the property length
                                // minus the NULL.
                                PROPASSERT( BSTRLEN(*ppv) == cbcopy - sizeof(OLECHAR) );

                            }   // if( VT_BSTR == pvar->vt )

                            else
                            {
                                // Allocate a buffer in the PropVariant
				*ppv = pma->Allocate(max(1, cbcopy));
				if (*ppv == NULL)
				{
				    StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for string element");
                                    goto Exit;
				}

                                // Copy from the propset buffer to the PropVariant
				RtlCopyMemory(*ppv, pv, cbcopy);

                            }   // if( VT_BSTR == pvar->vt ) ... else

                            // If necessary, byte-swap in the PropVariant to get
                            // the proper byte-ordering.
                            PBSBuffer( *ppv, cbcopy, cbByteSwap );

                            // Adjust the PropVar element ptr to user-space (kernel only)
			    ADJUSTPOINTER(*ppv, PointerDelta, VOID *);

                            // Move, within the propset buffer, to the
                            // next element in the vector.
			    pbsrc += DwordAlign(cb);

                            // Delete the temporary buffers

                            CoTaskMemFree( pchByteSwap );
                            pchByteSwap = NULL;

			    CoTaskMemFree( pchConvert );
			    pchConvert = NULL;

			}   // if (fConvertToEmpty || cb != 0)

                        // Move, within the PropVariant, to the next
                        // element in the vector.
			ppv++;

		    }   // while (cElems-- > 0)
		}   // else if (pvar->vt == (VT_VECTOR | VT_CF)) ... else
	    }   // if (!fPostAllocInit) ... else

	    ADJUSTPOINTER(*ppvK, PointerDelta, VOID *);

	}   // if (!fConvertToEmpty && cb == 0) ... else
    }   // else if (ppv != NULL)

Exit:

    if( fSafeArrayLocked )
    {
        PROPASSERT( NULL != pvSafeArrayData );
        PrivSafeArrayUnaccessData( psa );
    }

    CoTaskMemFree( pchByteSwap );
    CoTaskMemFree( pchConvert );

    return(fIndirect);
}




//+---------------------------------------------------------------------------
// Function:    CleanupVariants, private
//
// Synopsis:    Free all memory used by an array of PROPVARIANT
//
// Arguments:   [pvar]          -- pointer to PROPVARIANT
//              [cprop]         -- property count
//              [pma]		-- caller's memory free routine
//
// Returns:     None
//---------------------------------------------------------------------------

#ifndef KERNEL
VOID
CleanupVariants(
    IN PROPVARIANT *pvar,
    IN ULONG cprop,
    IN PMemoryAllocator *pma)
{
    while (cprop-- > 0)
    {
	VOID *pv = NULL;
	VOID **ppv = NULL;
#ifdef KERNEL
        ULONG cbbstr = 0;
#endif
	ULONG cElems;

	switch (pvar->vt)
	{
	case VT_CF:
	    pv = pvar->pclipdata;
	    if (pv != NULL && pvar->pclipdata->pClipData)
	    {
		pma->Free(pvar->pclipdata->pClipData);
	    }
	    break;

        case VT_VERSIONED_STREAM:
            pv = pvar->pVersionedStream;
            if( NULL != pv && NULL != pvar->pVersionedStream->pStream )
            {
                pma->Free(pvar->pVersionedStream->pStream);
            }
            break;

	case VT_BLOB:
	case VT_BLOB_OBJECT:
	    pv = pvar->blob.pBlobData;
	    break;

	case VT_BSTR:
#ifdef KERNEL
            cbbstr = sizeof(ULONG);
            //FALLTHROUGH
#endif

	case VT_CLSID:
	case VT_STREAM:
	case VT_STREAMED_OBJECT:
	case VT_STORAGE:
	case VT_STORED_OBJECT:
	case VT_LPSTR:
	case VT_LPWSTR:
	    AssertStringField(puuid);		// VT_CLSID
	    AssertStringField(pszVal);		// VT_STREAM, VT_STREAMED_OBJECT
	    AssertStringField(pszVal);		// VT_STORAGE, VT_STORED_OBJECT
	    AssertStringField(bstrVal);		// VT_BSTR
	    AssertStringField(pszVal);		// VT_LPSTR
	    AssertStringField(pwszVal);		// VT_LPWSTR
	    pv = pvar->pszVal;
	    break;

	// Vector properties:

	case VT_VECTOR | VT_I1:
	case VT_VECTOR | VT_UI1:
	case VT_VECTOR | VT_I2:
	case VT_VECTOR | VT_UI2:
	case VT_VECTOR | VT_BOOL:
	case VT_VECTOR | VT_I4:
	case VT_VECTOR | VT_UI4:
	case VT_VECTOR | VT_R4:
	case VT_VECTOR | VT_ERROR:
	case VT_VECTOR | VT_I8:
	case VT_VECTOR | VT_UI8:
	case VT_VECTOR | VT_R8:
	case VT_VECTOR | VT_CY:
	case VT_VECTOR | VT_DATE:
	case VT_VECTOR | VT_FILETIME:
	case VT_VECTOR | VT_CLSID:
	    AssertByteVector(cac);			// VT_I1
	    AssertByteVector(caub);			// VT_UI1
	    AssertShortVector(cai);			// VT_I2
	    AssertShortVector(caui);			// VT_UI2
	    AssertShortVector(cabool);			// VT_BOOL
	    AssertLongVector(cal);			// VT_I4
	    AssertLongVector(caul);			// VT_UI4
	    AssertLongVector(caflt);			// VT_R4
	    AssertLongVector(cascode);			// VT_ERROR
	    AssertLongLongVector(cah);			// VT_I8
	    AssertLongLongVector(cauh);			// VT_UI8
	    AssertLongLongVector(cadbl);		// VT_R8
	    AssertLongLongVector(cacy);			// VT_CY
	    AssertLongLongVector(cadate);		// VT_DATE
	    AssertLongLongVector(cafiletime);		// VT_FILETIME
	    AssertVarVector(cauuid, sizeof(GUID));	// VT_CLSID
	    pv = pvar->cai.pElems;
	    break;

	case VT_VECTOR | VT_CF:
	    {
		CLIPDATA *pcd;

		cElems = pvar->caclipdata.cElems;
		pv = pcd = pvar->caclipdata.pElems;
		while (cElems-- > 0)
		{
		    if (pcd->pClipData != NULL)
		    {
			pma->Free(pcd->pClipData);
		    }
		    pcd++;
		}
	    }
	    break;

	case VT_VECTOR | VT_BSTR:
#ifdef KERNEL
            cbbstr = sizeof(ULONG);
            //FALLTHROUGH
#endif

	case VT_VECTOR | VT_LPSTR:
	case VT_VECTOR | VT_LPWSTR:
	    AssertStringVector(cabstr);			// VT_BSTR
	    AssertStringVector(calpstr);		// VT_LPSTR
	    AssertStringVector(calpwstr);		// VT_LPWSTR
	    cElems = pvar->calpstr.cElems;
	    ppv = (VOID **) pvar->calpstr.pElems;
	    break;

	case VT_VECTOR | VT_VARIANT:
	    CleanupVariants(
		    pvar->capropvar.pElems,
		    pvar->capropvar.cElems,
		    pma);
	    pv = pvar->capropvar.pElems;
	    break;

	}   // switch (pvar->vt)

	if (ppv != NULL)			// STRING VECTOR property
	{
            // Save the vector of pointers
	    pv = (VOID *) ppv;

            // Free the vector elements
	    while (cElems-- > 0)
	    {
		if (*ppv != NULL)
		{
#ifdef KERNEL
                    pma->Free((BYTE *) *ppv - cbbstr);
#else
                    if( (VT_BSTR | VT_VECTOR) == pvar->vt )
                    {
                        PrivSysFreeString( (BSTR) *ppv );
                    }
                    else
                    {
		        pma->Free((BYTE *) *ppv);
                    }
#endif
		}
		ppv++;
	    }

            // Free the vector of pointers.
            pma->Free(pv);
            pv = NULL;

	}   // if (ppv != NULL)

	if (pv != NULL)
	{
#ifdef KERNEL
            pma->Free((BYTE *) pv - cbbstr);
#else
            if( VT_BSTR == pvar->vt )
            {
                PrivSysFreeString( (BSTR) pv );
            }
            else
            {
                pma->Free((BYTE *) pv);
            }
#endif
        }

	pvar->vt = VT_EMPTY;

        // Move on to the next PropVar in the vector.
	pvar++;

    }   // while (cprop-- > 0)
}
#endif // !KERNEL


//+--------------------------------------------------------------------------
// Function:    PropertyLength
//
// Synopsis:    compute the length of a property including the variant type
//
// Arguments:   [pprop]         -- property value
//              [cbbuf]         -- max length of accessible memory at pprop
//              [flags]		-- CPropertySetStream flags
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     length of property
//---------------------------------------------------------------------------


// First, define a wrapper for this function which returns errors
// using NT Exception Handling, rather than returning an NTSTATUS.

#if defined(WINNT) && !defined(IPROPERTY_DLL)

ULONG
PropertyLength(
    SERIALIZEDPROPERTYVALUE const *pprop,
    ULONG cbbuf,
    BYTE flags)
{
    NTSTATUS status;
    ULONG ulRet;
    
    ulRet = PropertyLengthNoEH( pprop, cbbuf, flags, &status );
    
    if (!NT_SUCCESS( status ))
        RtlRaiseStatus( status );

    return( ulRet );
}

#endif // #if defined(WINNT) && !defined(IPROPERTY_DLL)


// Now define the body of the function, returning errors with an
// NTSTATUS value instead of raising.

ULONG
PropertyLengthNoEH(
    SERIALIZEDPROPERTYVALUE const *pprop,
    ULONG cbbuf,
    BYTE flags,
    OUT NTSTATUS *pstatus)
{
    ULONG const *pl = (ULONG const *) pprop->rgb;
    ULONG cElems = 1;
    ULONG cSafeArrayDimensions = 1;
    ULONG cbremain = cbbuf;
    ULONG cb = 0, cbch;
    BOOLEAN fIllegalType = FALSE;

    ULONG vt = PropByteSwap( pprop->dwType );

    const SAFEARRAYBOUND *rgsaBounds = NULL;

    *pstatus = STATUS_SUCCESS;

    if (cbremain < CB_SERIALIZEDPROPERTYVALUE)
    {
        StatusOverflow(pstatus, "PropertyLength: dwType");
        goto Exit;
    }
    cbremain -= CB_SERIALIZEDPROPERTYVALUE;

    if( VT_VECTOR & vt )
    {
        if (cbremain < sizeof(ULONG))
        {
            StatusOverflow(pstatus, "PropertyLength: cElems");
            goto Exit;
        }
        cbremain -= sizeof(ULONG);
        cElems = PropByteSwap( *pl++ );
    }
    else if( VT_ARRAY & vt )
    {
        ULONG cbBounds = 0;

        // Can we read the VT and dimension count?
        if( sizeof(DWORD) + sizeof(UINT) > cbremain )
        {
            StatusOverflow(pstatus, "PropertyLength:  vt/cDims" );
            goto Exit;
        }
        cbremain -= sizeof(DWORD) + sizeof(UINT);

        // Read the SafeArray's VT (so we'll now ignore pprop->dwType)
        vt = VT_ARRAY | PropByteSwap( *pl++ );
        PROPASSERT( sizeof(DWORD) == sizeof(*pl) );

        // Read the dimension count
        cSafeArrayDimensions = PropByteSwap( *pl++ );
        PROPASSERT( sizeof(DWORD) == sizeof(*pl) );

        // Can we read the bounds?
        if( sizeof(SAFEARRAYBOUND) * cSafeArrayDimensions > cbremain )
        {
            StatusOverflow(pstatus, "PropertyLength:  safearray bounds" );
            goto Exit;
        }

        // Size the bounds and point to them.

        cbBounds = sizeof(SAFEARRAYBOUND) * cSafeArrayDimensions;
        cbremain -= cbBounds;
        rgsaBounds = reinterpret_cast<const SAFEARRAYBOUND *>(pl);
        pl = static_cast<const ULONG*>(Add2ConstPtr( pl, cbBounds ));

        // Calc the element count
        cElems = CalcSafeArrayElements( cSafeArrayDimensions, rgsaBounds );
    }

    // Is this a vector or array?
    if( (VT_VECTOR | VT_VARIANT) == vt
        ||
        (VT_ARRAY  | VT_VARIANT) == vt )
    {
	while (cElems-- > 0)
	{
	    cb = PropertyLengthNoEH(
			(SERIALIZEDPROPERTYVALUE const *) pl,
			cbremain,
			flags | CPSS_VARIANTVECTOR,
                        pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    pl = (ULONG const *) Add2ConstPtr(pl, cb);
	    cbremain -= cb;
        }
    }

    else
    {
        cbch = sizeof(WCHAR);

        switch( VT_TYPEMASK & vt )
        {
        case VT_EMPTY:
        case VT_NULL:
            fIllegalType = (flags & CPSS_VARIANTVECTOR) != 0;
            break;

        case VT_I1:
        case VT_UI1:
            pl = (ULONG const *) Add2ConstPtr(pl, DwordAlign(cElems * sizeof(BYTE)));
            break;

        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
            pl = (ULONG const *) Add2ConstPtr(pl, DwordAlign(cElems * sizeof(USHORT)));
            break;

        case VT_I4:
        case VT_INT:
        case VT_UI4:
        case VT_UINT:
        case VT_R4:
        case VT_ERROR:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(ULONG));
            break;

        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(LONGLONG));
            break;

        case VT_CLSID:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(GUID));
            break;

        case VT_DECIMAL:
            pl = (ULONG const *) Add2ConstPtr( pl, cElems * sizeof(DECIMAL) );
            break;


        case VT_VERSIONED_STREAM:

            // Ensure we can read the GUID & string length
            if( cbremain <  sizeof(GUID) + sizeof(ULONG) )
            {
                StatusOverflow(pstatus, "PropertyLength: VersionedStream" );
                goto Exit;
            }

            // Point to the string's length
            pl = reinterpret_cast<const ULONG*>( Add2ConstPtr( pl, sizeof(GUID) ));

            // Point past the end of the property
            pl = reinterpret_cast<const ULONG*>( Add2ConstPtr( pl, sizeof(ULONG) + DwordAlign(PropByteSwap(*pl)) ));

            break;


        case VT_BLOB:
        case VT_BLOB_OBJECT:
            // FALLTHROUGH

        case VT_STREAM:
        case VT_STREAMED_OBJECT:
        case VT_STORAGE:
        case VT_STORED_OBJECT:
            if (flags & CPSS_VARIANTVECTOR)
            {
                fIllegalType = TRUE;
                break;
            }
            // FALLTHROUGH

        case VT_CF:
        case VT_BSTR:
        case VT_LPSTR:
            cbch = sizeof(BYTE);
            // FALLTHROUGH

        case VT_LPWSTR:
            while (cElems-- > 0)
            {
                if (cbremain < sizeof(ULONG) ||
                    cbremain < (cb = sizeof(ULONG) + DwordAlign(PropByteSwap(*pl) * cbch)))
                {
                    StatusOverflow(pstatus, "PropertyLength: String/BLOB/CF/Indirect");
                    goto Exit;
                }

#ifdef LITTLEENDIAN
		PROPASSERT(
		    (PropByteSwap(pprop->dwType) & VT_TYPEMASK) != VT_LPWSTR
                     ||
		     IsUnicodeString( (WCHAR const *) &pl[1],
				       PropByteSwap(*pl) * sizeof(WCHAR)));
#endif

                pl = (ULONG const *) Add2ConstPtr(pl, cb);
                cbremain -= cb;
            }
            break;

        default:

            fIllegalType = TRUE;
            break;
        }
    }
    if (fIllegalType)
    {
        propDbg(( DEB_IWARN, "PropertyLength: Unsupported VarType (0x%x)\n", vt ));
        *pstatus = STATUS_NOT_SUPPORTED;
        goto Exit;
    }
    cb = (ULONG) ((BYTE *) pl - (BYTE *) pprop);
    if (cbbuf < cb)
    {
        StatusOverflow(pstatus, "PropertyLength: cb");
        goto Exit;
    }

    // Make sure PropertyLength works when limited to an exact size buffer.
    PROPASSERT(cb == cbbuf || PropertyLengthNoEH(pprop, cb, flags, pstatus) == cb);

    //  ----
    //  Exit
    //  ----

Exit:

    // Normalize the error return value.
    if( !NT_SUCCESS(*pstatus) )
        cb = 0;

    return(cb);

}   // PropertyLengthNoEH()


//+--------------------------------------------------------------------------
// Function:    StgPropertyLengthAsVariant
//
// Synopsis:    compute the size of external memory required to store the
//		property as a PROPVARIANT
//
// Arguments:   [pprop]         -- property value
//              [cbprop]        -- computed length of pprop in propset stream
//              [CodePage]	-- property set codepage
//              [flags]		-- CPropertySetStream flags
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     length of property
//---------------------------------------------------------------------------

#if defined(WINNT)

// First, define a wrapper which raises NT Exceptions for compatibility
// with older callers who expect it.

EXTERN_C ULONG __stdcall
StgPropertyLengthAsVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cbprop,
    IN USHORT CodePage,
    IN BYTE flags)
{
    NTSTATUS status;
    ULONG ulRet;
    
    ulRet = StgPropertyLengthAsVariantNoEH( pprop, cbprop, CodePage, flags, &status );
    
    if (!NT_SUCCESS( status ))
        RtlRaiseStatus( status );

    return( ulRet );
}

// Now define the body of the function, returning errors with an
// NTSTATUS value instead of raising.

ULONG
StgPropertyLengthAsVariantNoEH(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cbprop,
    IN USHORT CodePage,
    IN BYTE flags,
    OUT NTSTATUS *pstatus)
{
    ULONG cElems = 0;
    ULONG cbvar = 0;
    const ULONG *pl = reinterpret_cast<const ULONG*>(pprop->rgb);

    *pstatus = STATUS_SUCCESS;


    PROPASSERT(cbprop == PropertyLengthNoEH(pprop, cbprop, flags, pstatus));
    if( VT_VECTOR & PropByteSwap(pprop->dwType) )
    {
        if( VT_ARRAY & PropByteSwap(pprop->dwType) )
        {
            StatusInvalidParameter( pstatus, "Both Array and Vector bits set" );
            goto Exit;
        }
        cElems = *(ULONG *) pprop->rgb;
        pl++;
        cbprop -= sizeof(ULONG);        // Discount the element count
    }
    else if( VT_ARRAY & PropByteSwap(pprop->dwType) )
    {
        const SAFEARRAYBOUND *rgsaBounds = NULL;
        ULONG cDims = 0;
        VARTYPE vtInternal;

        if( VT_VECTOR & PropByteSwap(pprop->dwType) )
        {
            StatusInvalidParameter( pstatus, "Both Array and Vector bits set" );
            goto Exit;
        }

        vtInternal = static_cast<VARTYPE>(*pl++);
        cDims = *pl++;  PROPASSERT( sizeof(UINT) == sizeof(LONG) );
        rgsaBounds = reinterpret_cast<const SAFEARRAYBOUND*>(pl);
        pl = static_cast<const ULONG*>( Add2ConstPtr( pl, cDims * sizeof(SAFEARRAYBOUND) ));
        
        cElems = CalcSafeArrayElements( cDims, rgsaBounds );

        // Adjust cbprop to take into account that we have to create a SafeArray
        cbprop = cbprop
                 - sizeof(DWORD)            // vtInternal
                 - sizeof(UINT)             // cDims
                 + sizeof(SAFEARRAY)        // The SafeArray that will be alloced
                 + sizeof(GUID)             // hidden extra data alloc-ed with a safearray
                 - sizeof(SAFEARRAYBOUND);  // Discount SAFEARRAY.rgsabound[1]
    }


    switch( PropByteSwap(pprop->dwType) )
    {
        // We don't need to check for VT_BYREF, becuase serialized property sets
        // never contain them.

	//default:
	//case VT_EMPTY:
	//case VT_NULL:
	//case VT_I1:
	//case VT_UI1:
	//case VT_I2:
	//case VT_UI2:
	//case VT_BOOL:
        //case VT_INT:
        //case VT_UINT:
	//case VT_I4:
	//case VT_UI4:
	//case VT_R4:
	//case VT_ERROR:
	//case VT_I8:
	//case VT_UI8:
	//case VT_R8:
	//case VT_CY:
	//case VT_DATE:
	//case VT_FILETIME:
        //case VT_DECIMAL:
	    //cbvar = 0;
	    //break;

	case VT_CLSID:
	    cbvar = cbprop - sizeof(ULONG);	// don't include VARTYPE
	    break;

	// VT_CF: Round CLIPDATA up to Quad boundary, then drop VARTYPE+size+
	// clipfmt, which get tossed or unmarshalled into CLIPDATA.  Round
	// byte-granular data size to a Quad boundary when returning result.

	case VT_CF:
	    cbvar = QuadAlign(sizeof(CLIPDATA)) + cbprop - 3 * sizeof(ULONG);
	    break;

	case VT_BLOB:
	case VT_BLOB_OBJECT:
	    cbvar = cbprop - 2 * sizeof(ULONG); // don't include VARTYPE & size
	    break;

        case VT_VERSIONED_STREAM:
	case VT_STREAM:
	case VT_STREAMED_OBJECT:
	case VT_STORAGE:
	case VT_STORED_OBJECT:

	    cbvar = cbprop - 2 * sizeof(ULONG); // don't include VARTYPE & size
	    if (CodePage != CP_WINUNICODE)
	    {
		cbvar *= sizeof(WCHAR);	// worst case Unicode conversion
	    }

            break;

	case VT_BSTR:

            // Don't include the size of the VT field, but leave
            // the size of the length field accounted for.
	    cbvar = cbprop - sizeof(ULONG);

            // Worst-case Ansi->Unicode conversion:
            cbvar *= sizeof(OLECHAR);

	    break;

	case VT_LPSTR:	// Assume Ansi conversion saves no space
	case VT_LPWSTR:
	    cbvar = cbprop - 2 * sizeof(ULONG);
	    break;

        case VT_ARRAY | VT_I1:
        case VT_ARRAY | VT_UI1:
        case VT_ARRAY | VT_I2:
        case VT_ARRAY | VT_UI2:
        case VT_ARRAY | VT_BOOL:
        case VT_ARRAY | VT_I4:
        case VT_ARRAY | VT_UI4:
        case VT_ARRAY | VT_INT:
        case VT_ARRAY | VT_UINT:
        case VT_ARRAY | VT_R4:
        case VT_ARRAY | VT_ERROR:
        case VT_ARRAY | VT_DECIMAL:
        //case VT_ARRAY | VT_I8:
        //case VT_ARRAY | VT_UI8:
        case VT_ARRAY | VT_R8:
        case VT_ARRAY | VT_CY:
        case VT_ARRAY | VT_DATE:

	    // don't include VARTYPE field
	    cbvar = cbprop - sizeof(ULONG);
	    break;

	// Vector properties:

	case VT_VECTOR | VT_I1:
	case VT_VECTOR | VT_UI1:
	case VT_VECTOR | VT_I2:
	case VT_VECTOR | VT_UI2:
	case VT_VECTOR | VT_BOOL:
	case VT_VECTOR | VT_I4:
	case VT_VECTOR | VT_UI4:
	case VT_VECTOR | VT_R4:
	case VT_VECTOR | VT_ERROR:
	case VT_VECTOR | VT_I8:
	case VT_VECTOR | VT_UI8:
	case VT_VECTOR | VT_R8:
	case VT_VECTOR | VT_CY:
	case VT_VECTOR | VT_DATE:
	case VT_VECTOR | VT_FILETIME:
	case VT_VECTOR | VT_CLSID:
	    AssertByteVector(cac);		// VT_I1
	    AssertByteVector(caub);		// VT_UI1
	    AssertShortVector(cai);		// VT_I2
	    AssertShortVector(caui);		// VT_UI2
	    AssertShortVector(cabool);		// VT_BOOL
	    AssertLongVector(cal);		// VT_I4
	    AssertLongVector(caul);		// VT_UI4
	    AssertLongVector(caflt);		// VT_R4
	    AssertLongVector(cascode);		// VT_ERROR
	    AssertLongLongVector(cah);		// VT_I8
	    AssertLongLongVector(cauh);		// VT_UI8
	    AssertLongLongVector(cadbl);	// VT_R8
	    AssertLongLongVector(cacy);		// VT_CY
	    AssertLongLongVector(cadate);	// VT_DATE
	    AssertLongLongVector(cafiletime);	// VT_FILETIME
	    AssertVarVector(cauuid, sizeof(GUID));

	    // don't include VARTYPE and count fields
	    cbvar = cbprop - 2 * sizeof(ULONG);
	    break;

	case VT_VECTOR | VT_CF:		// add room for each pointer
	    AssertVarVector(caclipdata, sizeof(CLIPDATA));	// VT_CF

	    // don't include VARTYPE and count fields
	    cbvar = cbprop - 2 * sizeof(ULONG);

	    // add room for each CLIPDATA data pointer and enough to Quad align
	    // every clipdata data element and 1 ULONG to Quad align the
	    // CLIPDATA array
	    cbvar += cElems * (sizeof(BYTE *) + sizeof(ULONG)) + sizeof(ULONG);
	    break;

	case VT_VECTOR | VT_BSTR:	// add room for each BSTRLEN
        case VT_ARRAY  | VT_BSTR:
	    AssertStringVector(cabstr);				// VT_BSTR
            //Assert

	    // don't include VARTYPE field
	    cbvar = cbprop - sizeof(ULONG);

            // For vectors, don't include the count field
            if( VT_VECTOR & PropByteSwap(pprop->dwType) )
                cbvar -= sizeof(ULONG);
	    
	    if (CodePage != CP_WINUNICODE)
	    {
		cbvar *= sizeof(OLECHAR);   // worst case Unicode conversion
	    }

	    // add room for each BSTRLEN value and enough to Quad align
	    // every BSTR and 1 ULONG to Quad align the array of BSTR pointers.

	    cbvar += cElems * (sizeof(ULONG) + sizeof(ULONG)) + sizeof(ULONG);
	    break;

	case VT_VECTOR | VT_LPSTR: // Assume Ansi conversion saves no space
	case VT_VECTOR | VT_LPWSTR:
	    AssertStringVector(calpstr);			// VT_LPSTR
	    AssertStringVector(calpwstr);			// VT_LPWSTR

	    // don't include VARTYPE and count fields
	    cbvar = cbprop - 2 * sizeof(ULONG);

	    // add enough room to Quad align every string and 1 ULONG to Quad
	    // align the array of string pointers.

	    cbvar += cElems * sizeof(ULONG) + sizeof(ULONG);
	    break;

	case VT_VECTOR | VT_VARIANT:
        case VT_ARRAY  | VT_VARIANT:
	{
	    ULONG cbremain = cbprop - sizeof(ULONG);    // Discount the VT

	    cbvar = cElems * sizeof(PROPVARIANT);

	    while (cElems-- > 0)
	    {
		ULONG cbpropElem;
		ULONG cbvarElem;
		
		cbpropElem = PropertyLengthNoEH(
				    (SERIALIZEDPROPERTYVALUE *) pl,
				    cbremain,
				    flags | CPSS_VARIANTVECTOR,
                                    pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

		cbvarElem = StgPropertyLengthAsVariantNoEH(
				    (SERIALIZEDPROPERTYVALUE *) pl,
				    cbpropElem,
				    CodePage,
				    flags | CPSS_VARIANTVECTOR,
                                    pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                pl = (ULONG const *) Add2ConstPtr(pl, cbpropElem);
		cbremain -= cbpropElem;
		cbvar += cbvarElem;
	    }
	    break;
	}
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // Normalize the error return value.
    if( !NT_SUCCESS(*pstatus) )
        cbvar = 0;

    return(QuadAlign(cbvar));
}

#endif // #if defined(WINNT)



//+--------------------------------------------------------------------------
// Function:    PBSCopy
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine copies the source to the destination, 
//              byte-swapping as it copies.
//
// Arguments:   [VOID*] pvDest
//                  Pointer to the target (swapped) buffer.
//                  This must be pre-allocated by the caller.
//              [VOID*] pvSource
//                  Pointer to the original buffer.
//              [ULONG] cbSize
//                  Size in bytes of the buffer.
//              [ULONG] cbByteSwap
//                  Size of byte-swapping units.
//
// Returns:     None.
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSCopy( OUT VOID *pvDest,
              IN VOID const *pvSource,
              IN ULONG cbCopy,
              IN LONG cbByteSwap )
{
    PROPASSERT( (cbCopy & 1) == 0 );
    PROPASSERT( pvDest != NULL && pvSource != NULL );

    memcpy( pvDest, pvSource, cbCopy );
    PBSBuffer( pvDest, cbCopy, cbByteSwap );
}

#endif  // BIGENDIAN


//+--------------------------------------------------------------------------
// Function:    PBSAllocAndCopy
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine allocs a buffer, and swaps the bytes from
//              the source buffer into the destination.
//
// Arguments:   [VOID**] ppvDest (out)
//                  On success will point to the swapped buffer.
//              [VOID*] pvSource (in)
//                  Pointer to the original buffer.
//              [ULONG] cbSize (in)
//                  Size in bytes of the buffer.
//              [LONG] cbByteSwap (in)
//                  Size of byte-swapping units.
//              [NTSTATUS*] pstatus (out)
//                  NTSTATUS code.
//
// Returns:     None.
//
// Note:        The caller is responsible for freeing *ppvDest
//              (using ::delete).
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSAllocAndCopy( OUT VOID **ppvDest,
                      IN VOID const *pvSource,
                      ULONG cbSize,
                      LONG cbByteSwap,
                      OUT NTSTATUS *pstatus)
{
    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;
    PROPASSERT( ppvDest != NULL && pvSource != NULL );

    // Allocate a buffer.
    *ppvDest = CoTaskMemAlloc( cbSize );
    if( NULL == *ppvDest )
    {
        *pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Swap/copy the bytes.
    PBSCopy( *ppvDest, pvSource, cbSize, cbByteSwap );

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // PBSAllocAndCopy

#endif // BIGENDIAN

//+--------------------------------------------------------------------------
// Function:    PBSInPlaceAlloc
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine takes a WCHAR array, allocates a new buffer,
//              and swaps the original array into the new buffer.
//              
//
// Arguments:   [WCHAR**] ppwszResult
//                  IN: *ppwszResult points to string to be swapped.
//                  OUT: *ppwszResult points to the swapped string.
//              [WCHAR**] ppwszBuffer
//                  *ppwszBuffer points to the buffer which was allocated
//                  for the swapped bytes (should be the same as *ppwszResult).
//                  *ppwszBuffer must be NULL on input, and must be freed
//                  by the caller (using ::delete).
//              [NTSTATUS*] pstatus
//                  NTSTATUS code.
//
// Returns:     None.
//
// On input, *ppwszResult contains the original string.
// An equivalently sized buffer is allocated in *ppwszBuffer,
// and *ppwszResult is byte-swapped into it.  *ppwszResult
// is then set to the new *ppwszBuffer.
//
// It doesn't appear to useful to have both buffer parameters,
// but it makes it easier on the caller in certain circumstances;
// *ppwszResult always points to the correct string, whether the
// build is BIGENDIAN (alloc & swap takes place) or the build
// is LITTLEENDIAN (nothing happes, so *ppwszResult continues
// to point to the proper string).  The LITTLEENDIAN version of
// this function is implemented as an inline routine.
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSInPlaceAlloc( IN OUT WCHAR** ppwszResult,
                      OUT WCHAR** ppwszBuffer,
                      OUT NTSTATUS *pstatus )
{
    //  ------
    //  Locals
    //  ------

    WCHAR *pwszNewBuffer;

    // Pointers which will walk through the input buffers.
    WCHAR *pwszOriginal, *pwszSwapped;

    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;

    // Allocate a new buffer.
    pwszNewBuffer = CoTaskMemAlloc( sizeof(WCHAR)*( Prop_wcslen(*ppwszResult) + 1 ));
    if( NULL == pwszNewBuffer )
    {
        *pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Swap the WCHARs into the new buffer.

    pwszOriginal = *ppwszResult;
    pwszSwapped = pwszNewBuffer;

    do
    {
        *pwszSwapped = PropByteSwap(*pwszOriginal++);
    }   while( *pwszSwapped++ != L'\0' );

    // If the caller wants a special pointer to the new buffer,
    // set it now.

    if( NULL != ppwszBuffer )
    {
        PROPASSERT( NULL== *ppwszBuffer );
        *ppwszBuffer = pwszNewBuffer;
    }

    // Also point *ppwszResult to the new buffer.
    *ppwszResult = pwszNewBuffer;


    //  ----
    //  Exit
    //  ----

Exit:
    return;
}   // PropByteSwap( WCHAR**, WCHAR**, NTSTATUS*)

#endif // BIGENDIAN


//+--------------------------------------------------------------------------
// Function:    PBSBuffer
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine takes a buffer and byte-swaps it.  The caller
//              specifies the size of the buffer, and the granularity of
//              the byte-swapping.
//
// Arguments:   [VOID*] pv
//                  Pointer to the buffer to be swapped.
//              [ULONG] cbSize
//                  Size in bytes of the buffer.
//              [ULONG] cbByteSwap
//                  Size of byte-swapping units.
//
// Returns:     None.
//
// For example, an array of 4 WORDs could be swapped with:
//
//      PBSBuffer( (VOID*) aw, 8, sizeof(WORD) );
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSBuffer( IN OUT VOID *pv,
                IN ULONG cbSize,
                IN ULONG cbByteSwap )
{
    ULONG ulIndex;

    // What kind of swapping should be do?

    switch( cbByteSwap )
    {
        // No swapping required

        case 0:
        case( sizeof(BYTE) ):

            // Nothing to do.
            break;

        // Swap WORDs

        case( sizeof(WORD) ):
            
            for( ulIndex = 0; ulIndex < cbSize/sizeof(WORD); ulIndex++ )
                ByteSwap( &((WORD*)pv)[ulIndex] );
            break;

        // Swap DWORDs

        case( sizeof(DWORD) ):

            for( ulIndex = 0; ulIndex < cbSize/sizeof(DWORD); ulIndex++ )
                ByteSwap( &((DWORD*)pv)[ulIndex] );
            break;

        // Swap LONGLONGs

        case( sizeof(LONGLONG) ):

            for( ulIndex = 0; ulIndex < cbSize/sizeof(LONGLONG); ulIndex++ )
                ByteSwap( &((LONGLONG*)pv)[ulIndex] );
            break;

        // Swap GUIDs

        case CBBYTESWAP_UID:

            for( ulIndex = 0; ulIndex < cbSize/sizeof(GUID); ulIndex++ )
                ByteSwap( &((GUID*)pv)[ulIndex] );
            break;

        // Error

        default:
            PROPASSERT( !"Invalid generic byte-swap size" );
    }
}   // PropByteSwap( VOID*, ULONG, ULONG )

#endif // BIGENDIAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\psetstg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       psetstg.cxx
//
//  Contents:   Implementation of common class for OFS and DocFile
//              IPropertySetStorage
//
//  Classes:    CPropertySetStorage
//              CEnumSTATPROPSETSTG
//
//  History:    1-Mar-95   BillMo      Created.
//             09-May-96   MikeHill    Don't delete a CPropertyStorage object,
//                                     it deletes itself in the Release.
//             22-May-96   MikeHill    Set STATPROPSETSTG.dwOSVersion.
//             06-Jun-96   MikeHill    Added input validation.
//             15-Jul-96   MikeHill    - Handle STATSTG as OLECHAR (not WCHAR).
//                                     - Added CDocFilePropertySetStorage imp.
//             07-Feb-97   Danl        - Removed CDocFilePropertySetStorage.
//                                     - Moved _Create, _Open, & _Delete
//                                       into Create, Open & Delete
//             10-Mar-98   MikeHill    Pass grfMode into CPropertyStorage
//                                     create/open methods.
//             06-May-98   MikeHill    Use CoTaskMem rather than new/delete.
//     5/18/98  MikeHill
//              -   Cleaned up constructor by moving parameters to a
//                  new Init method.
//     6/11/98  MikeHill
//              -   Dbg outs.
//              -   Don't use out-parm as temp-parm in Create, Open.
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#include <prophdr.hxx>

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

//
// debugging support
//

#if DBG
CHAR *
DbgFmtId(REFFMTID rfmtid, CHAR *pszBuf)
{
    PropSprintfA(pszBuf, "rfmtid=%08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X",
        rfmtid.Data1,
        rfmtid.Data2,
        rfmtid.Data3,
        rfmtid.Data4[0],
        rfmtid.Data4[1],
        rfmtid.Data4[2],
        rfmtid.Data4[3],
        rfmtid.Data4[4],
        rfmtid.Data4[5],
        rfmtid.Data4[6],
        rfmtid.Data4[7]);

    return(pszBuf);
}

CHAR *
DbgMode(DWORD grfMode, CHAR *psz)
{
    *psz = 0;

    if (grfMode & STGM_TRANSACTED)
        strcat(psz, "STGM_TRANSACTED | ");
    else
        strcat(psz, "STGM_DIRECT | ");

    if (grfMode & STGM_SIMPLE)
        strcat(psz, "STGM_SIMPLE | ");

    switch (grfMode & 3)
    {
    case STGM_READ:
        strcat(psz, "STGM_READ |");
        break;
    case STGM_WRITE:
        strcat(psz, "STGM_WRITE |");
        break;
    case STGM_READWRITE:
        strcat(psz, "STGM_READWRITE |");
        break;
    default:
        strcat(psz, "BAD grfMode |");
        break;
    }

    switch (grfMode & 0x70)
    {
    case STGM_SHARE_DENY_NONE:
        strcat(psz, "STGM_SHARE_DENY_NONE |");
        break;
    case STGM_SHARE_DENY_READ:
        strcat(psz, "STGM_SHARE_DENY_READ |");
        break;
    case STGM_SHARE_DENY_WRITE:
        strcat(psz, "STGM_SHARE_DENY_WRITE |");
        break;
    case STGM_SHARE_EXCLUSIVE:
        strcat(psz, "STGM_SHARE_EXCLUSIVE |");
        break;
    default:
        strcat(psz, "BAD grfMode | ");
        break;
    }


    if (grfMode & STGM_PRIORITY)
        strcat(psz, "STGM_PRIORITY | ");

    if (grfMode & STGM_DELETEONRELEASE)
        strcat(psz, "STGM_DELETEONRELEASE | ");

    if (grfMode & STGM_NOSCRATCH)
        strcat(psz, "STGM_NOSCRATCH | ");

    if (grfMode & STGM_CREATE)
        strcat(psz, "STGM_CREATE | ");

    if (grfMode & STGM_CONVERT)
        strcat(psz, "STGM_CONVERT | ");

    if (grfMode & STGM_FAILIFTHERE)
        strcat(psz, "STGM_FAILIFTHERE | ");

    return(psz);
}

CHAR *
DbgFlags(DWORD grfFlags, CHAR *psz)
{
    strcpy(psz, "grfFlags=");

    if (grfFlags & PROPSETFLAG_NONSIMPLE)
        strcat(psz, "PROPSETFLAG_NONSIMPLE |");
    else
        strcat(psz, "PROPSETFLAG_SIMPLE |");

    if (grfFlags & PROPSETFLAG_ANSI)
        strcat(psz, "PROPSETFLAG_ANSI |");
    else
        strcat(psz, "PROPSETFLAG_WIDECHAR |");

    return(psz);
}
#endif

//+----------------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Init
//
//  Synopsis:   This method is used to provide the IStorage in which 
//              property sets (IPropertyStorage's) will be created/opened.
//
//  Arguments:  [IStorage*]
//                  The containing storage.
//              [IBlockingLock*]
//                  The locking mechanism this CPropertySetStorage should
//                  use.  May be NULL.
//              [BOOL] (fControlLifetimes)
//                  If true, we must addref the IStorage.  E.g. in the docfile
//                  implementation, CPropertySetStorage is a base class
//                  for CExposedStorage, and this flag is set false.
//
//+----------------------------------------------------------------------------

void
CPropertySetStorage::Init( IStorage *pstg,
                           IBlockingLock *pBlockingLock,
                           BOOL fControlLifetimes )
{
    DfpAssert( NULL == _pstg && NULL == _pBlockingLock );

    _pstg = pstg;
    _pBlockingLock = pBlockingLock;

    if( fControlLifetimes )
    {
        _fContainingStgIsRefed = TRUE;

        pstg->AddRef();
        if( NULL != pBlockingLock )
            pBlockingLock->AddRef();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Create
//
//  Synopsis:   Create a property set for outermost client of
//              IPropertSetStorage.
//
//  Arguments:  Passed through to CPropertyStorage ctor.
//
//  Returns:    S_OK or failure code.
//
//  Notes:      Create a new CPropertyStorage object which will
//              implement IPropertyStorage.  The _pprivstg parameter
//              passed into CPropertyStorage::CPropertyStorage is
//              used to create (via QI) a matching type of mapped
//              stream (for OFS or DocFile properties.)
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Create( REFFMTID                rfmtid,
                                     const CLSID *           pclsid,
                                     DWORD                   grfFlags,
                                     DWORD                   grfMode,
                                     IPropertyStorage **     ppprstg)
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    IStream *pstmPropSet = NULL;
    IStorage *pstgPropSet = NULL;
    CPropertyStorage *pcPropStg = NULL;
    BOOL fCreated = FALSE;
    INT nPass = 0;
    BOOL fLocked = FALSE;
    CPropSetName psn;

    DBGBUF(buf1);
    DBGBUF(buf2);
    DBGBUF(buf3);

    propXTrace( "CPropertySetStorage::Create" );

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != (hr = Validate()))
        goto Exit;

    Lock();
    fLocked = TRUE;

    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, Exit, hr);
    GEN_VDATEPTRIN_LABEL(pclsid, CLSID, E_INVALIDARG, Exit, hr);
    GEN_VDATEPTROUT_LABEL( ppprstg, IPropertyStorage*, E_INVALIDARG, Exit, hr);

    propTraceParameters(( "%s, %s, %s",
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize( SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))) ));

    // We don't support PROPSETFLAG_UNBUFFERED from the IPropertySetStorage
    // interface.  This may only be used in the StgOpenPropStg
    // and StgCreatePropStg APIs.  This was done because we can't support
    // the flag on IPropertySetStorage::Open, so it would be inconsistent
    // to support it on the Create method.

    if( grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        hr = STG_E_INVALIDFLAG;
        goto Exit;
    }

    hr = CheckFlagsOnCreateOrOpen(TRUE,grfMode);
    if (hr != S_OK)
    {
        goto Exit;
    }

    psn = CPropSetName(rfmtid);
    *ppprstg = NULL;

    //  --------------------------------
    //  Create a child Stream or Storage
    //  --------------------------------

    // We'll make one or two passes (two if we the stream/storage
    // already exists and we have to delete it).

    while( nPass <= 1 )
    {
        if( PROPSETFLAG_NONSIMPLE & grfFlags )
        {
            // The Child should be a Storage

            hr = _pstg->CreateStorage( psn.GetPropSetName(),
                                       grfMode,
                                       0L, 0L,
                                       &pstgPropSet );

            if( SUCCEEDED(hr) )
            {
                fCreated = TRUE;

                if( NULL != pclsid )
                {
                    // We should also set the CLSID of the Storage.
                    hr = pstgPropSet->SetClass(*pclsid);
                    if( FAILED(hr) && E_NOTIMPL != hr ) goto Exit;
                    hr = S_OK;
                }
            }

        }   // if( PROPSETFLAG_NONSIMPLE & grfFlags )

        else
        {
            // The Child should be a Stream

            if( IsEqualGUID( rfmtid, FMTID_UserDefinedProperties ))
            {
                hr = CreateUserDefinedStream( _pstg, psn, grfMode, &fCreated, &pstmPropSet );
            }
            else
            {
                hr = _pstg->CreateStream(psn.GetPropSetName(),
                                         grfMode & ~STGM_TRANSACTED,
                                         0, 0, &pstmPropSet);
                if( hr == S_OK )
                    fCreated = TRUE;
            }

        }

        // If the create failed because the element already existed,
        // and if STGM_CREATE was set, then let's delete the existing
        // element and try again.

        if( hr == STG_E_FILEALREADYEXISTS
            &&
            grfMode & STGM_CREATE
            &&
            0 == nPass )
        {
            hr = _pstg->DestroyElement( psn.GetPropSetName() );
            if( FAILED(hr) )
                goto Exit;

            nPass++;
        }

        // If we failed for any other reason, then it's fatal.

        else if( FAILED(hr) )
            goto Exit;

        // Otherwise (we succeeded), we can move on.

        else
            break;

    }   // while( nPass <= 1 )


    //  ---------------------------
    //  Create the Property Storage
    //  ---------------------------

    // Create a CPropertyStorage
    pcPropStg = new CPropertyStorage( _MSOpts );
    if( NULL == pcPropStg )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Initialize the property set.

    if( PROPSETFLAG_NONSIMPLE & grfFlags )
        // We need a non-simple IPropertyStorage
        hr = pcPropStg->Create( pstgPropSet, rfmtid, pclsid, grfFlags, grfMode);

    else
        // We need a simple IPropertyStorage
        hr = pcPropStg->Create(  pstmPropSet, rfmtid, pclsid, grfFlags, grfMode );

    if( FAILED(hr) ) goto Exit;


    //  ----
    //  Exit
    //  ----

    *ppprstg = static_cast<IPropertyStorage*>(pcPropStg);
    pcPropStg = NULL;
    hr = S_OK;

Exit:

    // On failure ...
    if( FAILED(hr) )
    {
        // If an entry was created, attempt to delete it.
        if( fCreated )
            _pstg->DestroyElement( psn.GetPropSetName() );

    }

    if( NULL != pcPropStg )
        delete pcPropStg;

    if( NULL != pstmPropSet )
        pstmPropSet->Release();

    if( NULL != pstgPropSet )
        pstgPropSet->Release();


    if( fLocked )
        Unlock();

    if( STG_E_FILEALREADYEXISTS == hr )
        propSuppressExitErrors();

    return( hr );
}




//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Open
//
//  Synopsis:   Open a property set for outermost client.
//
//  Arguments:  passed through to CPropertyStorage ctor.
//
//  Returns:    S_OK or error.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Open(   REFFMTID                rfmtid,
                                     DWORD                   grfMode,
                                     IPropertyStorage **     ppprstg)
{
    HRESULT hr;

    IUnknown *punkPropSet = NULL;
    BOOL fSimple = TRUE;
    BOOL fLocked = FALSE;
    CPropertyStorage *pcPropStg = NULL;
    CPropSetName psn;

    DBGBUF(buf1);
    DBGBUF(buf2);

    propXTrace( "CPropertySetStorage::Open" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto Exit;

    Lock();
    fLocked = TRUE;

    // Validate inputs
    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, Exit, hr);
    GEN_VDATEPTROUT_LABEL( ppprstg, IPropertyStorage*, E_INVALIDARG, Exit, hr);


    propTraceParameters(( "%s, %s, %p",
                          DbgFmtId(rfmtid, buf1), DbgMode(grfMode, buf2), ppprstg ));

    psn = CPropSetName(rfmtid);
    *ppprstg = NULL;

    //  --------------------------------
    //  Open the child Stream or Storage
    //  --------------------------------

    hr = _pstg->OpenStream( psn.GetPropSetName(),
                            0L,
                            grfMode & ~STGM_TRANSACTED,
                            0L,
                            (IStream**) &punkPropSet );

    if( STG_E_FILENOTFOUND == hr )
    {
        fSimple = FALSE;
        hr = _pstg->OpenStorage( psn.GetPropSetName(),
                                 NULL,
                                 grfMode,
                                 NULL,
                                 0L,
                                 (IStorage**) &punkPropSet );
    }

    if( FAILED(hr) ) goto Exit;


    //  -------------------------
    //  Open the Property Storage
    //  -------------------------

    // Create an empty CPropertyStorage object.
    pcPropStg = new CPropertyStorage( _MSOpts );
    if( NULL == pcPropStg )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Open the property set and load it into the CPropertyStorage
    // object.  We pas the default grfFlags, letting the Open method
    // infer its correct value from the property set.

    if( !fSimple )
    {
        hr = pcPropStg->Open(static_cast<IStorage*>(punkPropSet),   // Addref-ed
                             rfmtid,
                             PROPSETFLAG_DEFAULT, // Flags are inferred
                             grfMode );
    }
    else
    {
        hr = pcPropStg->Open( static_cast<IStream*>(punkPropSet),   // Addref-ed
                              rfmtid,
                              PROPSETFLAG_DEFAULT, // Flags are inferred
                              grfMode,
                              FALSE );    // Don't delete this property set

    }
    if( FAILED(hr) ) goto Exit;


    //  ----
    //  Exit
    //  ----

    *ppprstg = static_cast<IPropertyStorage*>(pcPropStg);
    pcPropStg = NULL;
    hr = S_OK;

Exit:

    if( NULL != pcPropStg )
        delete pcPropStg;

    if( NULL != punkPropSet )
        punkPropSet->Release();

    if( fLocked )
        Unlock();

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return(hr);
}



//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Delete
//
//  Synopsis:   Delete the specified property set.
//
//  Arguments:  [rfmtid] -- format id of property set to delete.
//
//  Returns:    S_OK if successful, error otherwise.
//
//  Notes:      Get the matching name and try the element deletion.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Delete( REFFMTID  rfmtid)
{
    HRESULT hr = S_OK;
    IStream *pstm = NULL;
    BOOL fLocked = FALSE;
    CPropSetName psn;
    DBGBUF(buf);

    propXTrace( "CPropertySetStorage::Delete" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto Exit;

    Lock();
    fLocked = TRUE;

    // Validate the input
    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, Exit, hr);

    propTraceParameters(( "%s", DbgFmtId(rfmtid, buf) ));
    psn = CPropSetName(rfmtid);

    //  --------------------------
    //  Delete the PropertyStorage
    //  --------------------------

    // Check for the special-case

    if( IsEqualIID( rfmtid, FMTID_UserDefinedProperties ))
    {
        // This property set is actually the second section of the Document
        // Summary Information property set.  We must delete this
        // section, but we can't delete the Stream because it
        // still contains the first section.

        CPropertyStorage* pprstg;

        // Open the Stream.
        hr = _pstg->OpenStream( psn.GetPropSetName(),
                                NULL,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0L,
                                &pstm );
        if( FAILED(hr) ) goto Exit;

        // Create a CPropertyStorage
        pprstg = new CPropertyStorage( _MSOpts );
        if( NULL == pprstg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Use the CPropertyStorage to delete the section.
        hr = pprstg->Open( pstm,
                           rfmtid,
                           PROPSETFLAG_DEFAULT,
                           STGM_READWRITE | STGM_SHARE_EXCLUSIVE,      
                           TRUE ); // Delete this section

        pprstg->Release();  // Deletes *pprstg
        pprstg = NULL;

        if( FAILED(hr) ) goto Exit;

    }   // if( IsEqualIID( rfmtid, FMTID_DocSummaryInformation2 ))

    else
    {
        // This is not a special case, so we can just delete
        // the Stream.  Note that if the rfmtid represents the first
        // section of the DocumentSummaryInformation set, we might be
        // deleting the second section here as well.  That is a documented
        // side-effect.

        hr = _pstg->DestroyElement(psn.GetPropSetName());
        if( FAILED(hr) ) goto Exit;

    }   // if( IsEqualIID( rfmtid, FMTID_UserDefinedProperties )) ... else


    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    if( NULL != pstm )
        pstm->Release();

    if( fLocked )
        Unlock();

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Enum
//
//  Synopsis:   Create an enumerator over the property set
//
//  Arguments:  [ppenum] -- where to return the pointer to the
//                          enumerator.
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      [ppenum] is NULL on error.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Enum(   IEnumSTATPROPSETSTG **  ppenum)
{

    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertySetStorage::Enum" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto Exit;

    Lock();
    fLocked = TRUE;

    // Validate the input
    GEN_VDATEPTROUT_LABEL( ppenum, IEnumSTATPROPSETSTG*, E_INVALIDARG, Exit, hr);
    *ppenum = NULL;

    propTraceParameters(( "%p", ppenum ));

    //  --------------------
    //  Create the enuerator
    //  --------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSETSTG(_pstg, &hr);

    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSETSTG*) *ppenum;
        *ppenum = NULL;
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG
//
//  Synopsis:   Constructor which is used to implement
//              IPropertySetStorage::Enum
//
//  Arguments:  [pstg] -- the storage of the container to enumerate.
//              [phr] -- place to return HRESULT, S_OK or error.
//
//  Notes:      We use an STATSTG enumerator over the actual storage
//              to get the information about the property sets.
//
//--------------------------------------------------------------------


CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG(IStorage *pstg, HRESULT *phr)
{
    HRESULT & hr = *phr;

    _ulSig = ENUMSTATPROPSETSTG_SIG;
    _cRefs = 1;
    hr = pstg->EnumElements(FALSE, NULL, 0, &_penumSTATSTG);
    if (FAILED(hr))
        _penumSTATSTG = NULL;
    _cstatTotalInArray = 0;
    _istatNextToRead = 0;

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG
//
//  Synopsis:   Copy constructor which is used to implement
//              IEnumSTATPROPSETSTG::Clone.
//
//  Arguments:  [Other] -- The CEnumSTATPROPSETSTG to clone.
//              [phr] -- place to return HRESULT, S_OK or error.
//
//--------------------------------------------------------------------

CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG(   CEnumSTATPROPSETSTG &Other,
                                            HRESULT *phr)
{
    HRESULT & hr = *phr;

    _ulSig = ENUMSTATPROPSETSTG_SIG;
    _cRefs = 1;
    _cstatTotalInArray = 0;
    _istatNextToRead = Other._istatNextToRead;

    hr = Other._penumSTATSTG->Clone(&_penumSTATSTG);
    if (hr == S_OK)
    {
        // Copy the data in the buffer
        memcpy(_statarray, Other._statarray, sizeof(_statarray));
        _cstatTotalInArray = Other._cstatTotalInArray;

        // Copy the strings in the buffer
        for (ULONG i=0; i<_cstatTotalInArray; i++)
        {
            _statarray[i].pwcsName = reinterpret_cast<OLECHAR*>
                                     ( CoTaskMemAlloc( sizeof(OLECHAR)*( ocslen(Other._statarray[i].pwcsName) + 1 ) ));
            if (_statarray[i].pwcsName == NULL)
            {
                _cstatTotalInArray = i;
                hr = STG_E_INSUFFICIENTMEMORY;
                break;
            }
            else
            {
                ocscpy(_statarray[i].pwcsName, Other._statarray[i].pwcsName);
            }
        }
    }
    // note: destructor will cleanup the the strings or enumerator left behind
    //       in the error case
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::~CEnumSTATPROPSETSTG
//
//  Synopsis:   Delete the enumerator.
//
//  Notes:      Just releases the contained IEnumSTATSTG
//
//--------------------------------------------------------------------

CEnumSTATPROPSETSTG::~CEnumSTATPROPSETSTG()
{
    _ulSig = ENUMSTATPROPSETSTG_SIGDEL;

    if (_penumSTATSTG != NULL)
        _penumSTATSTG->Release();

    CleanupStatArray();

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown
//
//  Arguments:  The usual thing.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IEnumSTATPROPSETSTG))
    {
        *ppvObject = (IEnumSTATPROPSETSTG *)this;
        CEnumSTATPROPSETSTG::AddRef();
    }
    else
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *)this;
        CEnumSTATPROPSETSTG::AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return(hr);

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::AddRef
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSETSTG::AddRef(void)
{
    if (S_OK != Validate())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Release
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSETSTG::Release(void)
{
    LONG lRet;

    if (S_OK != Validate())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Next
//
//  Synopsis:   Implement IEnumSTATPROPSETSTG for ofs and docfile.
//
//  Arguments:  [celt] -- Count of elements to attempt to retrieve.
//              [rgelt] -- Where to put the results.  Must be valid for at least
//                         celt * sizeof(STATPROPSETSTG) bytes in length.
//              [pceltFetched] -- Count of elements returned is put here if
//                  the pointer is non-null.  If celt > 1, pceltFetched must
//                  be valid non-NULL.  If pcelt is non-NULL, it must be valid.
//                  if pcelt is NULL, celt must be 1.
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      We use a stack buffer to get more stuff per call to
//              underlying storage IEnumSTATSTG::Next.  We then copy
//              data from the STATSTG's to STATPROPSETSTG's.
//
//              An outer loop enumerates into statarray and then an
//              inner loop copies each batch into the [rgelt] buffer.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Next(ULONG                   celt,
                                  STATPROPSETSTG *        rgelt,
                                  ULONG *                 pceltFetched)
{
    HRESULT hr;
    ULONG celtCallerTotal;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate inputs

    if (NULL == pceltFetched)
    {
        if (1 != celt)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }

    if (0 == celt)
        return(hr);

    if( !IsValidPtrOut(rgelt, celt * sizeof(rgelt[0])) )
        return( E_INVALIDARG );


    //  -----------------------
    //  Perform the enumeration
    //  -----------------------

    celtCallerTotal = 0;

    //
    // we do this loop until we have what the caller wanted or error, or
    // no more.
    //
    do
    {
        //
        // If our internal buffer is empty, we (re)load it
        //
        if (_istatNextToRead == _cstatTotalInArray)
        {
            if (_cstatTotalInArray != 0)
                CleanupStatArray();

            hr = _penumSTATSTG->Next(sizeof(_statarray)/sizeof(_statarray[0]),
                    _statarray,
                    &_cstatTotalInArray);
        }

        // S_OK or S_FALSE indicate that we got something
        if (SUCCEEDED(hr))
        {
            //
            // we loop reading out of this buffer until either we have
            // all that the caller asked for, or we have exhausted the
            // buffer.
            //
            for (; celtCallerTotal < celt &&
                   _istatNextToRead < _cstatTotalInArray ;
                   _istatNextToRead++)
            {
                OLECHAR *pocsName = _statarray[_istatNextToRead].pwcsName;
                BOOL fDone = FALSE;

                DfpAssert(pocsName != NULL);

                if (pocsName[0] == OC_PROPSET0)
                {
                    // SPEC: if no matching fmtid then return GUID_NULL

                    // *** get fmtid *** //

                    if (!NT_SUCCESS(PrPropertySetNameToGuid(
                                    ocslen(pocsName), pocsName, &rgelt->fmtid)))
                    {
                        ZeroMemory(&rgelt->fmtid, sizeof(rgelt->fmtid));
                    }

                    // *** get clsid *** //
                    // *** get grfFlags *** //
                    // SPEC: don't support returning PROPSETFLAG_ANSI

                    if (_statarray[_istatNextToRead].type == STGTY_STORAGE)
                    {
                        rgelt->clsid = _statarray[_istatNextToRead].clsid;
                        rgelt->grfFlags = PROPSETFLAG_NONSIMPLE;
                    }
                    else
                    {
                        // SPEC: don't get the clsid for !PROPSET_NONSIMPLE
                        ZeroMemory(&rgelt->clsid, sizeof(rgelt->clsid));
                        rgelt->grfFlags = 0;
                    }

                    // *** get mtime *** //
                    rgelt->mtime = _statarray[_istatNextToRead].mtime;

                    // *** get ctime *** //
                    rgelt->ctime = _statarray[_istatNextToRead].ctime;

                    // *** get atime *** //
                    rgelt->atime = _statarray[_istatNextToRead].atime;

                    // *** default the OS Version *** //
                    rgelt->dwOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

                    rgelt ++;
                    celtCallerTotal ++;
                }
            }
        }
    }
    while (celtCallerTotal < celt && hr == S_OK);

    if (SUCCEEDED(hr))
    {
        hr = celt == celtCallerTotal ? S_OK : S_FALSE;
        DfpAssert(hr == S_OK || celtCallerTotal < celt);

        if (pceltFetched != NULL)
            *pceltFetched = celtCallerTotal;
    }
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Skip
//
//  Synopsis:   Skip the requested number of elements.
//
//  Arguments:  [celt] -- number to skip.
//
//  Returns:    S_OK if all skipped, S_FALSE if less than requested
//              number skipped, error otherwise.
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Skip(ULONG celt)
{
    HRESULT hr;
    STATPROPSETSTG stat;
    ULONG celtCallerTotal = 0;

    if (S_OK != (hr = Validate()))
        return(hr);

    do
    {
        hr = Next(1, &stat, NULL);
    } while ( hr == S_OK && ++celtCallerTotal < celt );

    if (SUCCEEDED(hr))
        hr = celt == celtCallerTotal ? S_OK : S_FALSE;

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CleanupStatArray
//
//  Synopsis:   Free any strings in the array.
//
//--------------------------------------------------------------------

VOID CEnumSTATPROPSETSTG::CleanupStatArray()
{
    for (ULONG i=0; i<_cstatTotalInArray; i++)
    {
        CoTaskMemFree( _statarray[i].pwcsName );
        _statarray[i].pwcsName = NULL;
    }
    _istatNextToRead = 0;
    _cstatTotalInArray = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Reset
//
//  Synopsis:   Reset the enumerator.
//
//  Notes:      Merely resetting the underlying enumerator should be
//              adequate,
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Reset()
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    hr = _penumSTATSTG->Reset();
    if (hr == S_OK)
    {
        CleanupStatArray();
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Clone
//
//  Synopsis:   Copy the enumeration state of this enumerator.
//
//  Arguments:  [ppenum] -- where to put the pointer to the clone
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      We end up just calling IEnumSTATSTG::Clone in the
//              CEnumSTATPROPSETSTG constructor.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Clone(IEnumSTATPROPSETSTG **     ppenum)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate inputs

    VDATEPTROUT( ppenum, IEnumSTATPROPSETSTG* );

    //  --------------------
    //  Clone the enumerator
    //  --------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSETSTG(*this, &hr);
    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSETSTG*) *ppenum;
        *ppenum = NULL;
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::
//              QueryInterface, AddRef, and Release
//
//  Synopsis:   IUnknown members.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr = S_OK;

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != (hr = Validate()))
        return(hr);

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----
    //  Query
    //  -----

    if( IID_IPropertySetStorage == riid
        ||
        IID_IUnknown == riid )
    {
        *ppvObject = this;
        this->AddRef();
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }

    return( hr );
}

ULONG   CPropertySetStorage::AddRef(void)
{
    LONG lRet;

    //  ----------
    //  Validation
    //  ----------

    if (S_OK !=  Validate())
        return(0);

    //  ------
    //  AddRef
    //  ------

    lRet = InterlockedIncrement( &_cReferences );
    return( lRet );
}

ULONG   CPropertySetStorage::Release(void)
{
    LONG lRet;

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != Validate())
        return(0);

    //  ----------------
    //  Decrement/Delete
    //  ----------------

    lRet = InterlockedDecrement( &_cReferences );

    if( 0 == lRet )
        delete this;
    else if( 0 > lRet )
        lRet = 0;

    return( lRet );
}

//+----------------------------------------------------------------------------
//
//  Function:   Lock & Unlock
//
//  Synopsis:   This methods take and release the CPropertySetStorage's
//              critical section.
//
//  Inputs:     None
//
//  Returns:    Nothing
//
//+----------------------------------------------------------------------------

VOID
CPropertySetStorage::Lock()
{
#ifndef _MAC

    if (NULL == _pBlockingLock)
    {
        DfpAssert (_fInitCriticalSection);
        EnterCriticalSection( &_CriticalSection );
    }
    else
    {
        _pBlockingLock->Lock(INFINITE);
    }

#endif
}

VOID
CPropertySetStorage::Unlock()
{
#ifndef _MAC

    if (NULL == _pBlockingLock)
    {
        DfpAssert (_fInitCriticalSection);
        LeaveCriticalSection( &_CriticalSection );
    }
    else
    {
        _pBlockingLock->Unlock();
    }


#endif
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::CreateUserDefinedStream
//
//  Synopsis:   Open the "DocumentSummaryInformation" stream in order
//              to create the UserDefined section of that property set.
//              Create the stream only if it doesn't already exist.
//
//  Arguments:  [pstg]     -- container storage
//              [psn]      -- the property set name
//              [grfMode]  -- mode of the property set
//              [fCreated] -- TRUE if Stream is created, FALSE if opened.
//              [ppStream] -- On return, the Stream for the property set
//
//  Notes:      This special case is necessary because this DocSumInfo
//              property set is the only one in which we support more
//              than one section.  For this property set, if the caller
//              Creates the second section, we must not *Create* the Stream,
//              because that would lose the first Section.  So, we must open it.
//
//              This routine is only called when creating the second
//              Section.  The first Section is created normally (note
//              that if the client creates the first section, the second
//              section is lost).
//
//              Also note that it may not be possible to open the Stream,
//              since it may already be opened.  This is significant
//              because it may not be obvious to the caller.  I.e.,
//              to a client of IPropertyStorage, the 2 sections are
//              distinct property sets, and you would think that you could
//              open them for simultaneous write.
//
//--------------------------------------------------------------------

HRESULT
CPropertySetStorage::CreateUserDefinedStream( IStorage *      pstg,
                         CPropSetName &  psn,
                         DWORD           grfMode,
                         BOOL *          pfCreated,
                         IStream **      ppStream )
{

    HRESULT hr;
    DWORD   grfOpenMode;

    // Calculate the STGM flags to use for the Open.  Create & Convert
    // don't have meaning for the Open, and Transacted isn't supported
    // by IPropertyStorage on the simple stream.

    grfOpenMode = grfMode & ~(STGM_CREATE | STGM_CONVERT | STGM_TRANSACTED);

    *pfCreated = FALSE;

    // Try an Open

    hr = pstg->OpenStream( psn.GetPropSetName(), NULL,
                           grfOpenMode,
                           0L, ppStream );

    // If the file wasn't there, try a create.

    if(( hr == STG_E_FILENOTFOUND ) || ( hr == STG_E_INVALIDFUNCTION))
    {
        hr = pstg->CreateStream(psn.GetPropSetName(), grfMode, 0, 0, ppStream);

        if( SUCCEEDED( hr ))
        {
            *pfCreated = TRUE;
        }
    }

    return( hr );

} // CPropertySetStorage::CreateUserDefinedStream
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\reserved.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       reserved.cxx
//
//  Contents:   Class that implements reserved memory for properties.
//              This implementation is in the form of two derivations
//              of the CReservedMemory class.
//
//  Classes:    CWin32ReservedMemory
//              CWin31ReservedMemory
//
//  History:    1-Mar-95   BillMo      Created.
//              29-Aug-96  MikeHill    Split CReservedMemory into CWin31 & CWin32
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#include "reserved.hxx"

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

// Instantiate the appropriate object.

#ifdef _MAC
    CWin31ReservedMemory g_ReservedMemory;
#else
    CWin32ReservedMemory g_ReservedMemory;
#endif


//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory::_Init
//
//  Synopsis:   Prepare as much as possible during initialization, in order
//              to be able to provide memory in LockMemory.
//
//  Inputs:     None.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------


#ifndef _MAC

HRESULT
CWin32ReservedMemory::_Init(VOID)
{
    HRESULT hr = E_FAIL;
    SID_IDENTIFIER_AUTHORITY Sa = SECURITY_CREATOR_SID_AUTHORITY;
    ULONG cInits;

    // Ensure this method is called once and only once.  This
    // is necessary since this class is implemented as a global
    // variable.

    cInits = InterlockedIncrement( &_cInits );
    if( 1 < cInits )
    {
        // We've already been initialized (probably simultaneously
        // in another thread).  NOTE: This leaves one small race where
        // this thread really needs to use the reserved memory before
        // the other thread has finished initializing it.  If that window
        // is hit, it won't cause a corruption, but will cause an out-of-mem
        // error to occur.

        InterlockedDecrement( &_cInits );
        hr = S_OK;
        goto Exit;
    }


    // Create a creator/owner SID.  We'll give the creator/owner
    // full access to the temp file.

    if( !AllocateAndInitializeSid( &Sa,                           // Top-level authority
                                   1,
                                   SECURITY_CREATOR_OWNER_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &_pCreatorOwner ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        _pCreatorOwner = NULL;
        goto Exit;
    }

    // Create a DACL that just gives the Creator/Owner full access.

    if (!InitializeAcl( &_DaclBuffer.acl, sizeof(_DaclBuffer), ACL_REVISION))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    if (!AddAccessAllowedAce( &_DaclBuffer.acl,
                              ACL_REVISION,
                              STANDARD_RIGHTS_ALL | GENERIC_ALL,
                              _pCreatorOwner
                              ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Set up the security descriptor with that DACL in it.

    InitializeSecurityDescriptor( &_sd, SECURITY_DESCRIPTOR_REVISION );
    if( !SetSecurityDescriptorDacl( &_sd, TRUE, &_DaclBuffer.acl, FALSE ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Put the security descriptor into the security attributes.

    memset( &_secattr, 0, sizeof(_secattr) );
    _secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
    _secattr.lpSecurityDescriptor = &_sd;
    _secattr.bInheritHandle = FALSE;

    // Initialize the critical section.

    __try
    {
        InitializeCriticalSection( &_critsec );
        _fInitialized = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
        goto Exit;
    }

    hr = S_OK;

Exit:

    return hr;

}

#endif  // #ifndef _MAC


//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory::~CWin32ReservedMemory
//
//  Inputs:     N/A
//
//  Returns:    N/A
//
//+----------------------------------------------------------------------------

#ifndef _MAC

CWin32ReservedMemory::~CWin32ReservedMemory()
{
    if( _fInitialized )
        DeleteCriticalSection( &_critsec );

    if( NULL != _pCreatorOwner )
        FreeSid( _pCreatorOwner );
    FreeResources();

}



//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory::FreeResources
//
//  Inputs:     N/A
//
//  Returns:    Void
//
//  Synopsis:   Free the view, the mapping, and the file.
//
//+----------------------------------------------------------------------------

void
CWin32ReservedMemory::FreeResources()
{
    if( NULL != _pb )
    {
        UnmapViewOfFile( _pb );
        _pb = NULL;
    }

    if( NULL != _hMapping )
    {
        CloseHandle( _hMapping );
        _hMapping = NULL;
    }

    if( INVALID_HANDLE_VALUE != _hFile )
    {
        CloseHandle( _hFile );
        _hFile = INVALID_HANDLE_VALUE;
    }

}

#endif  // #ifndef _MAC


//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory::LockMemory
//
//  Synopsis:   Use a temporary file to get enough memory to hold the
//              largest possible property set and return a pointer to
//              that mapping.
//
//  Inputs:     None.
//
//  Returns:    Lock() returns a pointer to the locked memory.
//
//+----------------------------------------------------------------------------

#ifndef _MAC


BYTE * CWin32ReservedMemory::LockMemory(VOID)
{

    WCHAR wszTempFileName[ MAX_PATH + 64 ];
    ULONG cchPath = 0;

    // If for some reason initialization failed, there's nothing we can do,
    // we'll return NULL.

    if( !_fInitialized )
        goto Exit;
    
    // Lock down this class until the caller has completed.
    // This isn't really necessary, since this class could be
    // a member variable instead of a global, but that is too
    // much of a change for NT5.

    EnterCriticalSection( &_critsec );


    // Get the temp directory.

    cchPath = GetTempPath( MAX_PATH + 1, wszTempFileName );
    if( 0 == cchPath || cchPath > MAX_PATH + 1 )
        goto Exit;

    // Create a temporary file.  We can't use GetTempFileName, because it creates
    // the file, and consequently the DACL we pass in on CreateFile gets ignored.

    SYSTEMTIME st;
    FILETIME ft;
    GetSystemTime( &st );
    SystemTimeToFileTime( &st, &ft );

    wsprintf( &wszTempFileName[cchPath], L"OLEPROPSTG_%08x%08x.tmp",
              ft.dwHighDateTime, ft.dwLowDateTime );

    _hFile = CreateFile( wszTempFileName,
                         GENERIC_WRITE|GENERIC_READ|DELETE,
                         0,
                         &_secattr,
                         CREATE_NEW,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                         INVALID_HANDLE_VALUE );
    if( INVALID_HANDLE_VALUE == _hFile )
        goto Exit;
    

    // Map the temporary file.

    _hMapping = CreateFileMappingA(_hFile,               // handle of file to map
                                   NULL,                 // optional security attributes
                                   PAGE_READWRITE,       // protection for mapping object
                                   0,                    // high-order 32 bits of object size
                                   CBMAXPROPSETSTREAM,   // low-order 32 bits of object size
                                   NULL);                // name of file-mapping object
    if( NULL == _hMapping )
        goto Exit;

    // Map a view.

    _pb = (BYTE*)MapViewOfFile(_hMapping,   // file-mapping object to map into address space
                       FILE_MAP_WRITE,      // access mode
                       0,   // high-order 32 bits of file offset
                       0,   // low-order 32 bits of file offset
                       0);  // number of bytes to map
    if( NULL == _pb )
        goto Exit;

Exit:

    // If there was an error, free everything.

    if( NULL == _pb )
    {
        FreeResources();
        LeaveCriticalSection( &_critsec );
    }

    return _pb;

}


//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory
//
//  Synopsis:   Free the temp file and its mapping, and leave the critical
//              section.
//
//+----------------------------------------------------------------------------

VOID CWin32ReservedMemory::UnlockMemory(VOID)
{

    FreeResources();
    LeaveCriticalSection( &_critsec );

}

#endif  // #ifndef _MAC


//+----------------------------------------------------------------------------
//
//  Method:     CWin31ReservedMemory::LockMemory/UnlockMemory
//
//  Synopsis:   This derivation of the CReservedMemory does not provide
//              a locking mechanism, so no locking is performed.  The Lock
//              method simply returns the shared memory buffer.
//
//  Inputs:     None.
//
//  Returns:    Nothing
//
//+----------------------------------------------------------------------------


#ifdef _MAC

BYTE * CWin31ReservedMemory::LockMemory(VOID)
{

    DfpAssert( !_fLocked );
    #if DBG==1
        _fLocked = TRUE;
    #endif

    return (BYTE*) g_pbPropSetReserved;

}


VOID CWin31ReservedMemory::UnlockMemory(VOID)
{

    // No locking required on the Mac.

    DfpAssert( _fLocked );
    #if DBG==1
        _fLocked = FALSE;
    #endif

}

#endif // #ifdef _MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\propstg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       propstg.cxx
//
//  Contents:   Class that directly implements IPropertyStorage
//
//  Classes:    CCoTaskAllocator
//              CPropertyStorage
//
//  Notes:      For methods that state 'if successful returns S_OK,
//              otherwise error code', the possible error codes include:
//
//                  STG_E_INVALIDHANDLE
//                  STG_E_INSUFFICIENTMEMORY
//                  STG_E_MEDIUMFULL
//                  STG_E_REVERTED
//                  STG_E_INVALIDPARAMETER
//                  STG_E_INVALIDFLAG
//
//  History:    1-Mar-95   BillMo      Created.
//             22-Feb-96   MikeHill    Use VT_EMPTY instead of VT_ILLEGAL.
//             14-Mar-96   MikeHill    Set _fUserDefinedProperties in open constructor.
//             09-May-96   MikeHill    Don't return an error when someone calls
//                                     IPropertyStorage::Revert on a direct-mode propset.
//             22-May-96   MikeHill    Use the new _dwOSVersion.
//             06-Jun-96   MikeHill    Validate inputs.
//             31-Jul-96   MikeHill    - Treat prop names as OLECHARs, not WCHARs
//                                     - Added CDocFilePropertyStorage
//                                     - Modified for Mac support.
//             07-Feb-97   Danl        - Removed CDocFilePropertyStorage.
//             10-Mar-98   MikeHill    - Only stat for the grfMode on create/open
//                                       if it wasn't provided by the caller.
//                                     - Dbg outputs.
//      5/6/98  MikeHill
//              -   Use CoTaskMem rather than new/delete.
//              -   Removed calls for defunct UnicodeCallouts.
//              -   Added dbgouts.
//              -   Changed GetCPropertySetStream to GetFormatVersion (DBG only).
//     5/18/98  MikeHill
//              -   Fixed typos.
//     6/11/98  MikeHill
//              -   Allow the codepage to change during WriteMultiple.
//     8/18/98  MikeHill
//              -   If the given _grfMode is zero, then probe the stream
//                  to see if it's actually writeable.
//              -   InitializePropertyStream now determines the CREATEPROP_
//                  flags internally.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#include <tstr.h>

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

#ifndef _MAC    // No InfoLevel debug functionality on Mac.
DECLARE_INFOLEVEL(prop)
#endif


extern "C" const IID
IID_IStorageTest = { /* 40621cf8-a17f-11d1-b28d-00c04fb9386d */
    0x40621cf8,
    0xa17f,
    0x11d1,
    {0xb2, 0x8d, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };

// The IMappedStream is implemented by all the IStream implementations,
// and provides a mapping for CPropertySetStream.

extern "C" const IID
IID_IMappedStream = { /* 7d747d7f-a49e-11d1-b28e-00c04fb9386d */
    0x7d747d7f,
    0xa49e,
    0x11d1,
    {0xb2, 0x8e, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };

//+-------------------------------------------------------------------
//
//  Member:     CCoTaskAllocator::Allocate, Free.
//
//  Synopsis:   A PMemoryAllocator used by the Pr*
//              property set routines.  This is required
//              so that those routines can work in any
//              heap.
//
//--------------------------------------------------------------------


void *
CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return( CoTaskMemAlloc(cbSize) );
}

void
CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree( pv );
}


const OLECHAR g_oszPropertyContentsStreamName[] = OLESTR( "CONTENTS" );

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Initialize
//
//  Synopsis:   Initialize members to known values.
//
//--------------------------------------------------------------------

void CPropertyStorage::Initialize()
{
    _fExplicitelyProbedForWriteAccess = FALSE;
    _fUserDefinedProperties = FALSE;
    _ulSig = PROPERTYSTORAGE_SIG;
    _cRefs = 1;
    _pstgPropSet = NULL;
    _pstmPropSet = NULL;
    _dwOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;
    _np = NULL;
    _ms = NULL;
    _usCodePage = CP_WINUNICODE;
    _grfFlags = 0;
    _grfMode = 0;

#if DBG
    _cLocks = 0;
#endif

}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::InitializePropertyStream.
//
//  Synopsis:   Initialize the storage-type specific members.
//
//  Arguments:  [pguid] -- FMTID, in for create only.
//              [pclsid] -- Class id, in for create only.
//              [CreateOpenDelete] -- has one of the following
//                  values: CREATE_PROPSTREAM, OPEN_PROPSTREAM, or
//                  DELETE_PROPSTREAM.
//
//  Returns:    HRESULT
//
//  Requires:
//              _pstmPropSet -- The IStream of the main property set stream.
//
//  Modifies:
//              _ms         (IMappedStream *)
//
//                          (assumed NULL on entry) will be NULL or valid on exit
//
//              _np         (NTPROP)         aka CPropertySetStream
//
//                          (assumed NULL on entry) will be NULL or valid on exit
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::InitializePropertyStream(
    const GUID *pguid,
    GUID const *pclsid,
    EInitializePropertyStream CreateOpenDelete )
{
    HRESULT hr = S_OK;
    DWORD grfBehavior = 0;
    USHORT createprop = 0;  // Flags parameter to PrCreatePropertySet

    propITrace( "CPropertyStorage::InitializePropertyStream" );
    AssertLocked();


    // Set the CREATEPROP_ flags in createprop

    if( CREATE_PROPSTREAM == CreateOpenDelete )
        createprop = CREATEPROP_CREATE;
    else if( DELETE_PROPSTREAM == CreateOpenDelete )
        createprop = CREATEPROP_DELETE;
    else
    {
        DfpAssert( OPEN_PROPSTREAM == CreateOpenDelete );

        // If _grfMode is zero, it's either uninitialized or STGM_READ|STGM_SHARE_DENYNONE.
        // We'll consider it unknown for now, and probe the stream later to see if it's
        // writeable.

        if( 0 == _grfMode )
            createprop = CREATEPROP_UNKNOWN;
        else
            createprop = IsWriteable() ? CREATEPROP_WRITE : CREATEPROP_READ;
    }

    if( IsNonSimple() )
        createprop |= CREATEPROP_NONSIMPLE;


    // In the create path, set the behavior flag that will be passed to
    // PrCreatePropertySet.  In the open path, this will be returned
    // from that function instead.

    if( PROPSETFLAG_CASE_SENSITIVE & _grfFlags
        &&
        CREATEPROP_CREATE & createprop )
    {
        grfBehavior = PROPSET_BEHAVIOR_CASE_SENSITIVE;
    }


    // Get an appropriate IMappedStream
    hr = CreateMappedStream();
    if( FAILED(hr) ) goto Exit;

    // Create the CPropertySetStream

    NTSTATUS Status;

    DfpAssert( NULL == _np );

    Status = PrCreatePropertySet(
                        (NTMAPPEDSTREAM)_ms,
                        createprop,
                        pguid,
                        pclsid,
                        (NTMEMORYALLOCATOR) &_cCoTaskAllocator,
                        GetUserDefaultLCID(),
                        &_dwOSVersion,
                        &_usCodePage,
                        &grfBehavior,
                        &_np);

    if (!NT_SUCCESS(Status))
    {
        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::InitializePropertyStream"
            " - PrCreatePropertySet Status=%08X\n", this, Status));
        hr = DfpNtStatusToHResult(Status);
        goto Exit;
    }

    // If this was a create, the input _grfFlags should match the Behavior
    DfpAssert( (PROPSETFLAG_CASE_SENSITIVE & _grfFlags) && (PROPSET_BEHAVIOR_CASE_SENSITIVE & grfBehavior)
               ||
               !(PROPSETFLAG_CASE_SENSITIVE & _grfFlags) && !(PROPSET_BEHAVIOR_CASE_SENSITIVE & grfBehavior)
               ||
               !(CREATEPROP_CREATE & createprop) );

    // Also if this was a create, the input _grfFlags should match the codepage
    DfpAssert( (PROPSETFLAG_ANSI & _grfFlags) && CP_WINUNICODE != _usCodePage
               ||
               !(PROPSETFLAG_ANSI & _grfFlags) && CP_WINUNICODE == _usCodePage
               ||
               !(CREATEPROP_CREATE & createprop) );

    // If this is an open, we need to update _grfFlags with the actual values,
    // so that we can return them in a Stat.

    if( CP_WINUNICODE != _usCodePage )
        _grfFlags |= PROPSETFLAG_ANSI;

    if( PROPSET_BEHAVIOR_CASE_SENSITIVE & grfBehavior )
        _grfFlags |= PROPSETFLAG_CASE_SENSITIVE;

Exit:

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::~CPropertyStorage
//
//  Synopsis:   Free up object resources.
//
//  Notes:      Cleans up even from partial construction.
//
//--------------------------------------------------------------------

CPropertyStorage::~CPropertyStorage()
{
    HRESULT hr = S_OK;

    propITrace( "CPropertyStorage::~CPropertyStorage" );

    Lock();

    _ulSig = PROPERTYSTORAGE_SIGDEL; // prevent someone else deleting it

    // Close the property set.  This causes the latest mapped stream data to be
    // written to the underlying stream.  Errors are ignored, though, so 
    // clients should call Commit before calling the final release, in order
    // to get an opportunity to recover from flush errors.

    if (_np != NULL)
    {
        PrClosePropertySet(_np);
    }

    // Free the mapped stream.

    DeleteMappedStream();

    // Free the Stream and/or Storage with the serialized data.
    // If it was opened in direct mode, then the data written
    // during PrClosePropertySet will be implicitely commited.
    // If it was opened in transacted mode, then data written
    // in PrClosePropertySet will be reverted and lost (of course,
    // to avoid this, the client would have called IPropertyStorage::Commit).

    RELEASE_INTERFACE( _pstmPropSet );

    if( _pstgPropSet != NULL )
    {
        // If we're not opened in transacted mode, call Commit.
        // This was added to handle NFF (NTFS property sets), in which case
        // we open a direct IStorage, but it actually gives us a transacted
        // storage, for the purpose of robustness.
        // We tell IsWriteable not to probe the stream if it's unsure
        // about the _grfMode; return FALSE in that case.

        if( IsWriteable(DO_NOT_PROBE) && !(STGM_TRANSACTED & _grfMode) )
            _pstgPropSet->Commit( STGC_DEFAULT );

        RELEASE_INTERFACE( _pstgPropSet );
    }

    if (_fInitCriticalSection)
        DeleteCriticalSection( &_CriticalSection );
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown members
//
//  Notes:      IPropertyStorage supports IPropertyStorage and IUnknown
//
//--------------------------------------------------------------------


HRESULT CPropertyStorage::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = ValidateRef()))
        return(hr);

    // Validate the inputs

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----------------
    //  Perform the Query
    //  -----------------

    *ppvObject = NULL;

    if( IID_IPropertyStorage == riid || IID_IUnknown == riid )
    {
        *ppvObject = static_cast<IPropertyStorage*>(this);
        CPropertyStorage::AddRef();
    }

#if DBG
    else if( IID_IStorageTest == riid )
    {
        *ppvObject = static_cast<IStorageTest*>(this);
        CPropertyStorage::AddRef();
    }
#endif // #if DBG

    else
    {
        hr = E_NOINTERFACE;
    }

    return(hr);
}

ULONG   CPropertyStorage::AddRef(void)
{
    if (S_OK != ValidateRef())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

ULONG   CPropertyStorage::Release(void)
{
    LONG lRet;

    if (S_OK != ValidateRef())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;    // this will do a flush if dirty
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::CleanupOpenedObjects
//
//  Synopsis:   Cleans up the objects that have been opened
//              during the ReadMultiple.  Sets all entries to
//              VT_ILLEGAL so that the later free doesn't try to
//              treat the pointers as interface pointers.
//
//  Arguments:  [avar] -- The user's array of PROPVARIANTs
//
//              [pip] -- The array of INDIRECTPROPERTY structures
//                            for non-simple properties.
//
//              [cpspec] -- if 1 then no MAX_ULONG end of list marker.
//
//              [iFailIndex] -- An index into [pip] which
//                               indicates the non-simple property
//                               which failed to open, and represents
//                               the index at which the avar's begin
//                               to be strings rather than IStream's et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CPropertyStorage::CleanupOpenedObjects(
    PROPVARIANT avar[],
    INDIRECTPROPERTY *pip,
    ULONG cpspec,
    ULONG iFailIndex)
{
    HRESULT hr = S_OK;
    ULONG iStgProp;
    ULONG iiScan;

    propITrace( "CPropertyStorage::CleanupOpenedObjects" );
    AssertLocked();

    // the one that fails is passed in as ppPropVarFail.

    for (iiScan = 0;
        (iStgProp = pip[iiScan].Index) != MAX_ULONG;
        iiScan++)
    {
        // since we've just opened a bunch of storages we should
        // release them in this error case.  We don't release the
        // one at ppPropVarFail because that one is still a string.

        PROPVARIANT *pPropVar = avar + iStgProp;

        if (iiScan < iFailIndex)
        {
            switch (pPropVar->vt)
            {
            case VT_STREAM:
            case VT_STREAMED_OBJECT:
                pPropVar->pStream->Release();
                break;
            case VT_STORAGE:
            case VT_STORED_OBJECT:
                pPropVar->pStorage->Release();
                break;
            }
        }
        else
        {
            CoTaskMemFree( pPropVar->pStream );
        }

        pPropVar->vt = VT_ILLEGAL;
        pPropVar->pStream = NULL; // mark pStorage and pStream as nul

        if (cpspec == 1)
        {
            break;
        }
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::ReadMultiple
//
//  Synopsis:   Read properties from the property set.
//
//  Arguments:  [cpspec] -- Count of PROPSPECs in [rgpspec]
//              [rgpspec] -- Array of PROPSPECs
//              [rgpropvar] -- Array of PROPVARIANTs to be filled in
//                             with callee allocated data.
//
//  Returns:    S_FALSE if none found
//              S_OK if >=1 found
//              FAILED(hr) otherwise.
//
//  Notes:      SPEC: Returning the same IStream* for the same
//              VT queried multiple times.
//
//              PrQueryProperties has been specified to return
//              useful data: the count of properties found (controls
//              return code) and an array of indexes of non-simple
//              PROPSPECs (useful for simply opening the storages and
//              streams.)  This extra returned data means we don't
//              have to walk the [rgpropvar] in the success cases.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::ReadMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                PROPVARIANT             rgpropvar[])
{
    NTSTATUS Status;
    HRESULT hr;
    INDIRECTPROPERTY * pip; //array for non-simple
    INDIRECTPROPERTY ip;
    ULONG   cpropFound;
    BOOL    fLocked = FALSE;

    propXTrace( "CPropertyStorage::ReadMultiple" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate inputs

    if (0 == cpspec)
    {
        hr = S_FALSE;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    if (S_OK != (hr = ValidateOutRGPROPVARIANT( cpspec, rgpropvar )))
        goto errRet;

    propTraceParameters(( "cpspec=%d, rgpspec=%08X, rgpropvar=%08X",
                           cpspec, rgpspec, rgpropvar ));

    //  -------------------
    //  Read the Properties
    //  -------------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsReadable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    Status = PrQueryProperties(
                    _np,
                    cpspec,
                    rgpspec,
                    NULL,   // don't want PROPID's
                    cpspec == 1 ? (INDIRECTPROPERTY**)&ip : &pip,
                    rgpropvar,
                    &cpropFound);

    if (NT_SUCCESS(Status))
    {
        if (cpropFound != 0)
        {
            if (cpspec == 1)
            {
                if (ip.Index != MAX_ULONG)
                {
                    pip = &ip;
                }
                else
                {
                    pip = NULL;
                }
            }

            if (pip != NULL)
            {

                // we have one or more of VT_STREAM, VT_STREAMED_OBJECT,
                // VT_STORAGE, VT_STORED_OBJECT, VT_VERSIONED_STREAM

                ULONG iiScan;
                ULONG iStgProp;

                for (iiScan = 0;
                     hr == S_OK && (iStgProp = pip[iiScan].Index) != MAX_ULONG;
                     iiScan++ )
                {
                    PROPVARIANT *pPropVar = rgpropvar + iStgProp;
                    OLECHAR **pposzStreamOrStorageName = NULL;

                    if (IsNonSimple() && pPropVar->pwszVal[0] != L'\0')
                    {
                        VOID *pStreamOrStorage = NULL;

                        switch (pPropVar->vt)
                        {
                            case VT_VERSIONED_STREAM:

                                pposzStreamOrStorageName
                                    = reinterpret_cast<OLECHAR**>( &(pPropVar->pVersionedStream->pStream) );
                                // Fall through

                            case VT_STREAM:
                            case VT_STREAMED_OBJECT:

                                if( NULL == pposzStreamOrStorageName )
                                {
                                    pposzStreamOrStorageName
                                        = reinterpret_cast<OLECHAR**>( &(pPropVar->pStream) );
                                }

                                // Mask out the STGM_TRANSACTED bit because we don't
                                // support it.

                                hr = _pstgPropSet->OpenStream(*pposzStreamOrStorageName,
                                        NULL,
                                        GetChildOpenMode() & ~STGM_TRANSACTED,
                                        0,
                                        (IStream**)&pStreamOrStorage);
                                break;

                            case VT_STORAGE:
                            case VT_STORED_OBJECT:

                                if( NULL == pposzStreamOrStorageName )
                                {
                                    pposzStreamOrStorageName
                                        = reinterpret_cast<OLECHAR**>( &(pPropVar->pStorage) );
                                }

                                hr = _pstgPropSet->OpenStorage(*pposzStreamOrStorageName,
                                        NULL,
                                        GetChildOpenMode(),
                                        NULL,
                                        0,
                                        (IStorage**)&pStreamOrStorage);
                                break;

                            default:

                                DfpAssert( !OLESTR("Invalid non-simple property type") );
                                hr = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );

                        }   // switch (pPropVar->vt)

                        if (hr == S_OK)
                        {
                            // The pStream/pStorage entry currently points to a string
                            // (the name of the stream/storage).  Delete that string buffer
                            // and put in the real stream/storage interface pointer.

                            CoTaskMemFree( *pposzStreamOrStorageName );
                            *pposzStreamOrStorageName = reinterpret_cast<OLECHAR*>( pStreamOrStorage );

                        }
                        else if (hr != STG_E_FILENOTFOUND)
                        {
                            // the one that fails is passed in as
                            // iiScan and is still a string.
                            CleanupOpenedObjects(rgpropvar, pip, cpspec, iiScan);
                        }
                    }   // if (IsNonSimple() && pPropVar->pwszVal[0] != L'\0')
                    else
                    {
                        hr = STG_E_FILENOTFOUND;
                    }

                    if (hr == STG_E_FILENOTFOUND)
                    {
                        // if the stream/storage is not found, or this is
                        // a simple stream with VT_STORAGE etc, then treat
                        // like the property is not found.

                        if( VT_VERSIONED_STREAM == pPropVar->vt )
                        {
                            pPropVar->pVersionedStream->pStream->Release();
                            CoTaskMemFree( pPropVar->pVersionedStream );
                        }
                        else
                        {
                            CoTaskMemFree( pPropVar->pszVal );
                        }

                        PropVariantInit( pPropVar );
                        --cpropFound;
                        hr = S_OK;
                    }

                    if (cpspec == 1)
                        break;
                }

                if (cpspec != 1 && pip != NULL)
                    CoTaskMemFree( pip );

            }   // if (pip != NULL)

            if (hr != S_OK)
            {
                // we succeeded in getting the basic property types but
                // the non-simple stuff failed, so we zap out the whole lot
                // and return a complete failure
                FreePropVariantArray(cpspec, rgpropvar);
            }
        }

        if (hr == S_OK && cpropFound == 0)
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    if( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr )
        propSuppressExitErrors();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_WriteMultiple, private
//
//  Synopsis:   Write the properties to the property set.  Allows
//              a NULL rgpropvar pointer for deletion case.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//
//              [rgpspec] -- pointer to array of PROPSPECs
//
//              [rgpropvar] -- pointer to array of PROPVARIANTs with
//                           the values to write.
//
//              [propidNameFirst] -- id below which not to assign
//                           ids for named properties.
//
//
//  Returns:    S_OK,   -- all requested data was written.
//              S_FALSE -- all simple properties written, but non-simple
//                         types (VT_STREAM etc) were ignored.
//              Errors  --
//
//  Modifies:
//
//  Derivation:
//
//  Notes:      PrSetProperties has been carefully specified to return
//              useful information so that we can deal with the case
//              where a non-simple type (VT_STREAM etc) is overwritten
//              by a simple type.
//
//              This routine assumes the object has been validated
//              and is writeable.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::_WriteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                const PROPVARIANT       rgpropvar[],
                PROPID                  propidNameFirst)
{
    HRESULT             hr;
    NTSTATUS            Status;
    ULONG               i;
    CStackPropIdArray   rgPROPID;

    INDIRECTPROPERTY *  pip;
    INDIRECTPROPERTY    ip;

    if (S_OK != (hr = rgPROPID.Init(cpspec)))
        return(hr);

    propITrace( "CPropertyStorage::_WriteMultiple" );
    AssertLocked();

    Status = PrSetProperties(_np,   // property set context
                cpspec,             // property count
                propidNameFirst,    // first propid for new named props
                rgpspec,            // array of property specifiers
                &_usCodePage,       // updated CodePage
                rgPROPID,           // buffer for array of propids
                                    // the stream/storage names for indirect properties
                1 == cpspec ? (INDIRECTPROPERTY**)&ip : &pip,
                rgpropvar);

    if (NT_SUCCESS(Status))
    {
        // The code page may have been modified. Update grfFlags to
        // reflect the current value.

        if( CP_WINUNICODE == _usCodePage )
            _grfFlags &= ~PROPSETFLAG_ANSI;
        else
            _grfFlags |= PROPSETFLAG_ANSI;

        // Point 'pip' to the INDIRECTPROPERTY array

        if (cpspec == 1)
        {
            if (ip.Index != MAX_ULONG)
                pip = &ip;
            else
                pip = NULL;
        }

        // If we have indirect properties, write them out now.

        if ( pip != NULL)
        {
            ULONG iiScan;   // in this scope because we always use
            ULONG iStgProp; // these variables in the free memory loop below.

            if (IsSimple())
            {
                //
                // VT_STREAM was requested to be written and this
                // is a "SIMPLE" property set.
                //
                hr = STG_E_PROPSETMISMATCHED;
            }
            else
            {
                //
                // Two cases now:
                // 1.  Wrote a simple over a non-simple -- must delete the
                //     old non-simple.
                // 2.  Wrote a non-simple -- must actually copy data into it.
                //


                for (iiScan = 0;
                     hr == S_OK &&
                     (iStgProp = pip[iiScan].Index) != MAX_ULONG;
                     iiScan++ )
                {

                    OLECHAR oszStdPropName[sizeof("prop")+10+1];
                    const OLECHAR *poszPropName;
                    const PROPVARIANT *pPropVar = rgpropvar + iStgProp;
                    IStream *pstmFrom = NULL;

                    poszPropName = static_cast<LPOLESTR>(pip[iiScan].poszName);

                    if( NULL == poszPropName )
                    {
                        DfpAssert((LONG) iStgProp >= 0 && iStgProp < cpspec);
                        PROPGENPROPERTYNAME( oszStdPropName, rgPROPID[iStgProp] );
                        poszPropName = oszStdPropName;
                    }

                    DfpAssert( NULL != poszPropName );

                    switch (rgpropvar == NULL ? VT_ILLEGAL : pPropVar->vt)
                    {

                    case VT_VERSIONED_STREAM:
                    case VT_STREAM:
                    case VT_STREAMED_OBJECT:
                        {
                            IStream *pstm;
                            int i=0;

                            if( VT_VERSIONED_STREAM == pPropVar->vt )
                                pstmFrom = pPropVar->pVersionedStream->pStream;
                            else
                                pstmFrom = pPropVar->pStream;

                            while (i<=1)
                            {
                                hr = _pstgPropSet->CreateStream(poszPropName,
                                                                GetChildCreateMode() & ~STGM_TRANSACTED,
                                                                0, 0, &pstm);
                                if (hr == S_OK)
                                {
                                    if( NULL != pstmFrom )
                                    {
                                        ULARGE_INTEGER uli;
                                        memset(&uli, -1, sizeof(uli));
                                        hr = pstmFrom->CopyTo(pstm, uli, NULL, NULL);
                                    }
                                    pstm->Release();
                                    break;
                                }
                                else
                                if (hr != STG_E_FILEALREADYEXISTS)
                                {
                                    break;
                                }
                                else
                                if (i == 0)
                                {
                                    _pstgPropSet->DestroyElement(poszPropName);
                                }
                                i++;
                            }
                        }
                        break;
                    case VT_STORAGE:
                    case VT_STORED_OBJECT:
                        {
                            IStorage *pstg;
                            int i=0;
                            while (i<=1)
                            {
                                hr = _pstgPropSet->CreateStorage(poszPropName,
                                        GetChildCreateMode(),
                                        0,
                                        0,
                                        &pstg);
                                if (hr == S_OK)
                                {
                                    if (pPropVar->pStorage != NULL)
                                    {
                                        hr = pPropVar->pStorage->CopyTo(0, NULL,
                                                NULL, pstg);
                                    }
                                    pstg->Release();
                                    break;
                                }
                                else
                                if (hr != STG_E_FILEALREADYEXISTS)
                                {
                                    break;
                                }
                                else
                                if (i == 0)
                                {
                                    _pstgPropSet->DestroyElement(poszPropName);
                                }
                                i++;
                            }
                        }
                        break;
                    default:
                        //
                        // Any other VT_ type is simple and therefore
                        // was a non-simple overwritten by a simple.
                        //
                        hr = _pstgPropSet->DestroyElement( poszPropName );
                        break;
                    }

                    if (cpspec == 1)
                        break;

                }   // for (iiScan = 0; ...
            }   // if (IsSimple())

            // In both the success and failure cases we do this cleanup.

            for (iiScan = 0; pip[iiScan].Index != MAX_ULONG; iiScan++ )
            {
                if (pip[iiScan].poszName != NULL)
                    CoTaskMemFree( pip[iiScan].poszName );

                if (cpspec == 1)
                    break;
            }

            if (cpspec != 1 && pip != NULL)
                CoTaskMemFree( pip );

        }   // if ( pip != NULL)
        else
        {
            //
            // No VT_STREAM etc was requested to be written.
            // and no simple property overwrote a non-simple one.
        }
    }   // if (NT_SUCCESS(Status))
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    if( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr )
        propSuppressExitErrors();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::WriteMultiple
//
//  Synopsis:   Write properties.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//              [rgpspec] -- pointer to array of PROPSPECs
//              [rgpropvar] -- pointer to array of PROPVARIANTs with
//                           the values to write.
//              [propidNameFirst] -- id below which not to assign
//                           ids for named properties.
//
//  Returns:    S_OK,   -- all requested data was written.
//              S_FALSE -- all simple properties written, but non-simple
//                         types (VT_STREAM etc) were ignored.
//              Errors  --
//
//  Notes:      Checks that rgpropvar is not NULL, then calls
//              _WriteMultiple.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::WriteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                const PROPVARIANT       rgpropvar[],
                PROPID                  propidNameFirst)
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::WriteMultiple" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if (0 == cpspec)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    if (S_OK != (hr = ValidateInRGPROPVARIANT( cpspec, rgpropvar )))
        goto errRet;

    propTraceParameters(( "cpspec=%d, rgpspec=%08X, rgpropvar=%08X, propidNameFirst=%d",
                          cpspec, rgpspec, rgpropvar, propidNameFirst ));

    // Ensure we understand all the VarTypes in the input array.
    hr = ValidateVTs( cpspec, rgpropvar );
    if( FAILED(hr) ) goto errRet;

    //  --------------------
    //  Write the Properties
    //  --------------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    hr = _WriteMultiple(cpspec, rgpspec, rgpropvar, propidNameFirst);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;

        for (ULONG i=0; hr == S_OK && i < cpspec; i++)
        {
            hr = _WriteMultiple(1, rgpspec+i, rgpropvar+i, propidNameFirst);
            if( FAILED(hr) ) goto errRet;
        }
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }



    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    if( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr )
        propSuppressExitErrors();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::DeleteMultiple
//
//  Synopsis:   Delete properties.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//              [rgpspec] -- pointer to array of PROPSPECs
//
//  Returns:    S_OK,   -- all requested data was deleted.
//              S_FALSE -- all simple properties written, but non-simple
//                         types (VT_STREAM etc) were ignored.
//              Errors  --
//
//  Notes:      Checks that rgpropvar is not NULL, then calls
//              _WriteMultiple.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::DeleteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[])
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::DeleteMultiple" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if (0 == cpspec)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    propTraceParameters(( "cpspec=%d, rgpspec=%08X", cpspec, rgpspec ));

    //  ---------------------
    //  Delete the Properties
    //  ---------------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    hr = _WriteMultiple(cpspec, rgpspec, NULL, 2);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;

        for (ULONG i=0; hr == S_OK && i < cpspec; i++)
        {
            hr = _WriteMultiple(1, rgpspec+i, NULL, 2);
            if( FAILED(hr) ) goto errRet;
        }
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::ReadPropertyNames
//
//  Synopsis:   Attempt to read names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK -- success, one or more names returned
//              S_FALSE -- success, no names returned
//              STG_E_INVALIDHEADER -- no propid->name mapping property
//              other errors -- STG_E_INSUFFICIENTMEMORY etc
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::ReadPropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                LPOLESTR                rglpwstrName[])
{
    HRESULT hr;
    NTSTATUS Status;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::ReadPropertyNames" );

    //  --------
    //  Validate
    //  --------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if (0 == cpropid)
    {
        hr = S_FALSE;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    if (S_OK != (hr = ValidateOutRGLPOLESTR( cpropid, rglpwstrName )))
        goto errRet;

    propTraceParameters(( "cpropid=%d, rgpropid=%08X, rglpwstrName=%08X",
                           cpropid, rgpropid, rglpwstrName ));

    //  --------------
    //  Read the Names
    //  --------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsReadable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    Status = PrQueryPropertyNames(_np, cpropid, rgpropid, rglpwstrName);
    if (Status == STATUS_NOT_FOUND)
        hr = STG_E_INVALIDHEADER;
    else
    if (Status == STATUS_BUFFER_ALL_ZEROS)
        hr = S_FALSE;
    else
    if (!NT_SUCCESS(Status))
        hr = DfpNtStatusToHResult(Status);


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_WritePropertyNames
//
//  Synopsis:   Internal function used by WritePropertyNames and
//              DeletePropertyNames.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK if successful, otherwise error code.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::_WritePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                const LPOLESTR          rglpwstrName[])
{
    NTSTATUS Status;
    AssertLocked();

    Status = PrSetPropertyNames(_np, cpropid, rgpropid, (OLECHAR const * const *) rglpwstrName);
    return NT_SUCCESS(Status) ? S_OK : DfpNtStatusToHResult(Status);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::WritePropertyNames
//
//  Synopsis:   Attempt to write names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK -- success, otherwise error code.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::WritePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                const LPOLESTR          rglpwstrName[])
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::WritePropertyNames" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate inputs

    if (0 == cpropid)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    if (S_OK != (hr = ValidateInRGLPOLESTR( cpropid, rglpwstrName )))
        goto errRet;

    propTraceParameters(( "cpropid=%d, rgpropid=%08X, rglpwstrName=%08X",
                          cpropid, rgpropid, rglpwstrName ));

    //  ---------------
    //  Write the Names
    //  ---------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    hr = _WritePropertyNames(cpropid, rgpropid, rglpwstrName);

    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;

        for (ULONG i=0; hr == S_OK && i < cpropid; i++)
        {
            hr = _WritePropertyNames(1, rgpropid+i, rglpwstrName+i);
            if( FAILED(hr) ) goto errRet;
        }
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::DeletePropertyNames
//
//  Synopsis:   Attempt to delete names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//
//  Returns:    S_OK -- success, otherwise error.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::DeletePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[])
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::DeletePropertyNames" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if( 0 == cpropid )
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    propTraceParameters(( "cpropid=%d, rgpropid=%08X)", cpropid, rgpropid ));

    //  ----------------
    //  Delete the Names
    //  ----------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    hr = _WritePropertyNames(cpropid, rgpropid, NULL);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;

        for (ULONG i=0; hr == S_OK && i < cpropid; i++)
        {
            hr = _WritePropertyNames(1, rgpropid+i, NULL);
            if( FAILED(hr) ) goto errRet;
        }
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Commit
//
//  Synopsis:   Flush and/or commit the property set
//
//  Arguments:  [grfCommittFlags] -- Commit flags.
//
//  Returns:    S_OK -- success, otherwise error.
//
//  Notes:      For both simple and non-simple, this flushes the
//              memory image to disk subsystem.  In addition,
//              for non-simple transacted-mode property sets, this
//              performs a commit on the property set.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Commit(DWORD grfCommitFlags)
{
    HRESULT  hr;
    NTSTATUS Status;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::Commit" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if (S_OK != (hr = VerifyCommitFlags(grfCommitFlags)))
        goto errRet;

    propTraceParameters(( "grfCommitFlags=%08X", grfCommitFlags ));

    //  --------------------------
    //  Commit the PropertyStorage
    //  --------------------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    Status = PrFlushPropertySet(_np);
    if (!NT_SUCCESS(Status))
    {
        hr = DfpNtStatusToHResult(Status);
    }

    if (IsNonSimple())
    {
        if (hr == S_OK)
            hr = _pstgPropSet->Commit(grfCommitFlags);
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Revert
//
//  Synopsis:   For non-simple property sets, revert it.
//
//  Returns:    S_OK if successful.  STG_E_UNIMPLEMENTEDFUNCTION for
//              simple property sets.
//
//  Notes:      For non-simple property sets, call the underlying
//              storage's Revert and re-open the 'contents' stream.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Revert()
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::Revert" );

    if (S_OK != (hr = Validate()))
        goto errRet;

    Lock(); fLocked = TRUE;

    if (IsNonSimple())
    {
        hr = _pstgPropSet->Revert();
        if (hr == S_OK)
        {
            PrClosePropertySet(_np);
            _np = NULL;

            _pstmPropSet->Release();
            _pstmPropSet = NULL;

            DeleteMappedStream();

            // if one of these fails then this object becomes invalid (zombie)
            // Mask out the STGM_TRANSACTED bit because we don't support it.

            hr = _pstgPropSet->OpenStream(g_oszPropertyContentsStreamName, NULL,
                                          GetChildOpenMode() & ~STGM_TRANSACTED,
                                          0, &_pstmPropSet);
            if (hr == S_OK)
            {
                // Initialize the property set.  If this property set is the 2nd section
                // of the DocumentSummaryInformation property set (used by Office),
                // then we must specify the FMTID.

                hr = InitializePropertyStream(
                        _fUserDefinedProperties ? &FMTID_UserDefinedProperties : NULL,
                        NULL,       // pguid
                        OPEN_PROPSTREAM );
            }

            if (hr != S_OK)
            {
                _ulSig = PROPERTYSTORAGE_SIGZOMBIE;
            }
        }

    }
    else
        hr = S_OK;


errRet:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Enum
//
//  Synopsis:   Create an enumerator over the property set.
//
//  Arguments:  [ppenum] -- where to return the IEnumSTATPROPSTG *
//
//  Returns:    S_OK or error.
//
//  Notes:      The constructor of CEnumSTATPROPSTG creates a
//              CStatArray which reads the entire property set and
//              which can be shared when IEnumSTATPROPSTG::Clone is
//              used.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Enum(IEnumSTATPROPSTG **    ppenum)
{
    HRESULT hr;
    BOOL fLocked = FALSE;
    IStatArray *psa = NULL;
    IEnumSTATPROPSTG *penum = NULL;

    propXTrace( "CPropertyStorage::Enum" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the inputs

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );
    *ppenum = NULL;

    propTraceParameters(( "ppenum=%p", ppenum ));

    Lock(); fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto Exit;
    }

    if( !IsReadable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto Exit;
    }

    //  ----------------------
    //  Create the Enumeration
    //  ----------------------

    psa = (IStatArray*) new CStatArray( _np, &hr );
    if( NULL == psa )
        hr = STG_E_INSUFFICIENTMEMORY;
    if( FAILED(hr) ) goto Exit;

    penum = new CEnumSTATPROPSTG( psa );
    if( NULL == penum )
    {
        hr = STG_E_INSUFFICIENTMEMORY;
        goto Exit;
    }

    *ppenum = penum;
    penum = NULL;

    //  ----
    //  Exit
    //  ----

Exit:

    RELEASE_INTERFACE( penum );
    RELEASE_INTERFACE( psa );

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::SetTimes
//
//  Synopsis:   Set the given times on the underlying storage
//
//  Arguments:  [pctime] -- creation time
//              [patime[ -- access time
//              [pmtime] -- modify time
//
//  Returns:    S_OK or error.
//
//  Notes:
//              (non-simple only)  Only the times supported by the
//              underlying docfile implementation are
//              supported.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::SetTimes(
                FILETIME const *        pctime,
                FILETIME const *        patime,
                FILETIME const *        pmtime)
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::SetTimes" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    VDATEPTRIN_LABEL( pctime, FILETIME, errRet, hr );
    VDATEPTRIN_LABEL( patime, FILETIME, errRet, hr );
    VDATEPTRIN_LABEL( pmtime, FILETIME, errRet, hr );

    propTraceParameters(( "pctime=%08x:%08x, patime=%08x:%08x, pmtime=%08x:%08x",
                          pctime->dwHighDateTime, pctime->dwLowDateTime,
                          patime->dwHighDateTime, patime->dwLowDateTime,
                          pmtime->dwHighDateTime, pmtime->dwLowDateTime ));

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    //  -------------
    //  Set the Times
    //  -------------

    if (IsNonSimple())
    {
        hr = _pstgPropSet->SetElementTimes(
                NULL,
                pctime,
                patime,
                pmtime);
    }
    if( FAILED(hr) ) goto errRet;


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::SetClass
//
//  Synopsis:   Sets the class of the property set.
//
//  Arguments:  [clsid] -- class id to set.
//
//  Returns:    S_OK or error.
//
//  Notes:      If non-simple, the underlying storage has SetClass
//              called.  Both simple and non-simple will have
//              clsid set into the property set stream.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::SetClass(REFCLSID clsid)
{
    HRESULT hr;
    NTSTATUS Status;
    BOOL fLocked = FALSE;
    DBGBUF(buf);

    propXTrace( "CPropertyStorage::SetClass" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    GEN_VDATEREADPTRIN_LABEL(&clsid, CLSID, E_INVALIDARG, errRet, hr);

    propTraceParameters(( "clsid=%s", DbgFmtId(clsid, buf) ));

    //  -------------
    //  Set the CLSID
    //  -------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    // Set it in the property set header

    Status = PrSetPropertySetClassId(_np, &clsid);
    if (NT_SUCCESS(Status))
    {
        // And if this is an IStorage, set it there as well.
        if (IsNonSimple())
        {
            hr = _pstgPropSet->SetClass(clsid);
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Stat
//
//  Synopsis:   Get STATPROPSETSTG about the property set.
//
//  Arguments:  [p] -- STATPROPSETSTG *
//
//  Returns:    S_OK if successful, error otherwise.  On failure,
//              *p is all zeros.
//
//  Notes:      See spec.  Gets times from underlying storage or stream
//              using IStorage or IStream ::Stat.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Stat(STATPROPSETSTG * pstatpropsetstg)
{
    HRESULT hr;
    NTSTATUS Status;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::Stat" )

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate inputs

    VDATEPTROUT_LABEL(pstatpropsetstg, STATPROPSETSTG, errRet, hr);

    propTraceParameters(( "STATPROPSETSTG *p = %08X", pstatpropsetstg ));

    //  ------------
    //  Get the Stat
    //  ------------

    Lock();
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsReadable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    ZeroMemory(pstatpropsetstg, sizeof(*pstatpropsetstg));

    // returns mtime, ansi flag, clsid, fmtid
    Status = PrQueryPropertySet(_np, pstatpropsetstg);
    if (NT_SUCCESS(Status))
    {
        STATSTG statstg;

        hr = S_OK;

        if( NULL != _pstgPropSet || NULL != _pstmPropSet )
        {
            if (IsNonSimple())
            {
                hr = _pstgPropSet->Stat(&statstg, STATFLAG_NONAME);
            }
            else
            {
                hr = _pstmPropSet->Stat(&statstg, STATFLAG_NONAME);
            }

            if (hr == S_OK)
            {
                pstatpropsetstg->mtime = statstg.mtime;
                pstatpropsetstg->ctime = statstg.ctime;
                pstatpropsetstg->atime = statstg.atime;
                pstatpropsetstg->grfFlags = _grfFlags;
                pstatpropsetstg->dwOSVersion = _dwOSVersion;
            }
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    if (FAILED(hr))
    {
        ZeroMemory(pstatpropsetstg, sizeof(*pstatpropsetstg));
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return(hr);
}



//+-------------------------------------------------------------------
//
//  Member:     CStatArray::CStatArray
//
//--------------------------------------------------------------------

CStatArray::CStatArray(NTPROP np, HRESULT *phr)
{
    NTSTATUS Status;
    ULONG ulKeyZero;
    ULONG cpropAllocated;

    _cpropActual = 0;
    _cRefs = 1;
    _psps = NULL;

    do
    {
        //  when *pkey == 0, *pcprop == MAXULONG, aprs == NULL and asps == NULL on input,
        // *pcprop will be the total count of properties in the enumeration set.  OLE needs to
        // allocate memory and enumerate out of the cached PROPID+propname list.

        ulKeyZero = 0;
        _cpropActual = MAX_ULONG;

        CoTaskMemFree( _psps );
        _psps = NULL;

        Status = PrEnumerateProperties(
                np,
                ENUMPROP_NONAMES,
                &ulKeyZero,
                &_cpropActual,
                NULL,   // aprs
                NULL);

        if (!NT_SUCCESS(Status))
            break;

        cpropAllocated = _cpropActual + 1;

        _psps = reinterpret_cast<STATPROPSTG*>
                ( CoTaskMemAlloc( sizeof(STATPROPSTG) * cpropAllocated ) );
        if (_psps == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ulKeyZero = 0;
        Status = PrEnumerateProperties(
                np,
                0,
                &ulKeyZero,
                &cpropAllocated,
                NULL,   // aprs
                _psps);
    } while (NT_SUCCESS(Status) && cpropAllocated != _cpropActual);

    *phr = NT_SUCCESS(Status) ? S_OK : DfpNtStatusToHResult(Status);
}

//+-------------------------------------------------------------------
//
//  Member:     CStatArray::~CStatArray
//
//  Synopsis:   Deallocated the object's data.
//
//--------------------------------------------------------------------

CStatArray::~CStatArray()
{
    if( NULL != _psps )
    {
        STATPROPSTG *psps = _psps;

        while( _cpropActual )
        {
            CoTaskMemFree( psps->lpwstrName );
            _cpropActual--;
            psps++;
        }

        CoTaskMemFree( _psps );
    }
}


//+----------------------------------------------------------------------------
//
//	Member:		CStatArray::  QueryInterface/AddRef/Release
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CStatArray::QueryInterface( REFIID riid, void **ppvObject)
{
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CStatArray::AddRef(void)
{
    LONG lRet;

    lRet = InterlockedIncrement(&_cRefs);
    return(lRet);
}

STDMETHODIMP_(ULONG) CStatArray::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}


//+-------------------------------------------------------------------
//
//  Member:     CStatArray::NextAt
//
//  Synopsis:   Read from the internal STATPROPSTG array.
//
//  Effects:    The cursor is passed in, and this function acts
//              as a IEnumXX::Next would behave if the current cursor
//              was [ipropNext].
//
//  Arguments:  [ipropNext] -- index of cursor to use
//              [pspsDest] -- if NULL, emulate read's effect on cursor.
//                            if non-NULL, return data with cursor effect.
//              [pceltFetched] -- buffer for count fetched
//
//  Returns:    STATUS_SUCCESS if successful, otherwise
//              STATUS_INSUFFICIENT_RESOURCES.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS
CStatArray::NextAt(ULONG ipropNext, STATPROPSTG *pspsDest, ULONG *pceltFetched)
{
    ULONG   ipropLastPlus1;

    //
    // Copy the requested number of elements from the cache
    // (including strings, the allocation of which may fail.)
    //

    ipropLastPlus1 = ipropNext + *pceltFetched;
    if (ipropLastPlus1 > _cpropActual)
    {
        ipropLastPlus1 = _cpropActual;
    }

    *pceltFetched = ipropLastPlus1 - ipropNext;

    if (pspsDest != NULL)
        return CopySTATPROPSTG(*pceltFetched, pspsDest, _psps + ipropNext);
    else
        return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::CEnumSTATPROPSTG
//
//  Synopsis:   Constructor which is used by IEnumSTATPROPSTG::Clone.
//
//  Arguments:  [other] -- the CEnumSTATPROPSTG to copy
//              [phr] -- the error code.
//
//  Notes:      Since the CStatArray actually contains the object this
//              just adds to the ref count.
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::CEnumSTATPROPSTG(const CEnumSTATPROPSTG & other )
{
    _ulSig = ENUMSTATPROPSTG_SIG;
    _cRefs = 1;

    _psa = other._psa;
    _psa->AddRef();

    _ipropNext = other._ipropNext;

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::~CEnumSTATPROPSTG
//
//  Synopsis:   Deallocated storage.
//
//  Arguments:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::~CEnumSTATPROPSTG()
{
    _ulSig = ENUMSTATPROPSTG_SIGDEL;    // prevent another thread doing it - kinda

    RELEASE_INTERFACE( _psa );
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::QueryInterface
//
//  Synopsis:   Respond to IEnumSTATPROPSTG and IUnknown.
//
//  Returns:    S_OK  or E_NOINTERFACE
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    *ppvObject = NULL;

    if (S_OK != (hr = Validate()))
        return(hr);

    if (IsEqualIID(riid, IID_IEnumSTATPROPSTG))
    {
        *ppvObject = (IEnumSTATPROPSTG *)this;
        AddRef();
    }
    else
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *)this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::AddRef
//
//  Synopsis:   Add 1 to ref count.
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSTG::AddRef(void)
{
	long cRefs;

    if (S_OK != Validate())
        return(0);

    cRefs = InterlockedIncrement(&_cRefs);
    return(cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Release
//
//  Synopsis:   Subtract 1 from ref count and delete if 0.
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSTG::Release(void)
{
    LONG lRet;

    if (S_OK != Validate())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Function:   CopySTATPROPSTG
//
//  Synopsis:   Copy out the range of elements from [pspsSrc] to
//              [pspsDest].
//
//  Arguments:  [celt] -- count of elements to copy
//              [pspsDest] -- where to copy to, always filled with
//                          zeros before anything else (helps cleanup
//                          case.)
//
//              [pspsSrc] -- where to copy from
//
//  Returns:    STATUS_SUCCESS if ok, otherwise
//              STATUS_INSUFFICIENT_RESOURCES in which case there
//              may be pointers that need deallocating.  Use
//              CleanupSTATPROPSTG to do that.
//
//--------------------------------------------------------------------

NTSTATUS
CopySTATPROPSTG(ULONG celt,
            STATPROPSTG * pspsDest,
            const STATPROPSTG * pspsSrc)
{
    memset(pspsDest, 0, sizeof(*pspsDest) * celt);

    while (celt)
    {
        *pspsDest = *pspsSrc;

        if (pspsSrc->lpwstrName != NULL)
        {
            pspsDest->lpwstrName = reinterpret_cast<OLECHAR*>
                                   ( CoTaskMemAlloc( sizeof(OLECHAR)*( 1 + ocslen(pspsSrc->lpwstrName) ) ));
            if (pspsDest->lpwstrName != NULL)
            {
                ocscpy(pspsDest->lpwstrName,
                       pspsSrc->lpwstrName);
            }
            else
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        celt--;
        pspsDest++;
        pspsSrc++;
    }

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Next
//
//  Synopsis:   Get the next [celt] STATPROPSTGs from the enumerator.
//
//  Arguments:  [celt] -- count requested.
//              [rgelt] -- where to return them
//              [pceltFetched] -- buffer for returned-count.
//                  if pceltFetched==NULL && celt != 1 -> STG_E_INVALIDPARAMETER
//                  if pceltFetched!=NULL && celt == 0 -> S_OK
//
//  Returns:    S_OK if successful, otherwise error.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Next(
             ULONG                   celt,
             STATPROPSTG *           rgelt,
             ULONG *                 pceltFetched)
{
    HRESULT hr;
    NTSTATUS Status;
    ULONG   celtFetched = celt;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the inputs

    if (NULL == pceltFetched)
    {
        if (celt != 1)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }

    if( 0 == celt )
        return( S_OK );

    if( !IsValidPtrOut(rgelt, celt * sizeof(rgelt[0])) )
        return( E_INVALIDARG );


    //  -----------------------
    //  Perform the enumeration
    //  -----------------------

    if (celt == 0)
        return(hr);

    Status = _psa->NextAt(_ipropNext, rgelt, &celtFetched);

    if (NT_SUCCESS(Status))
    {
        _ipropNext += celtFetched;

        if (pceltFetched != NULL)
            *pceltFetched = celtFetched;

        hr = celtFetched == celt ? S_OK : S_FALSE;
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    return(hr);

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Skip
//
//  Synopsis:   Skip the next [celt] elements in the enumeration.
//
//  Arguments:  [celt] -- number of elts to skip
//
//  Returns:    S_OK if skipped [celt] elements
//              S_FALSE if skipped < [celt] elements
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Skip(ULONG celt)
{
    HRESULT hr;
    ULONG celtFetched = celt;

    if (S_OK != (hr = Validate()))
        return(hr);

    _psa->NextAt(_ipropNext, NULL, &celtFetched);

    _ipropNext += celtFetched;

    return celtFetched == celt ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Reset
//
//  Synopsis:   Set cursor to beginnging of enumeration.
//
//  Returns:    S_OK otherwise STG_E_INVALIDHANDLE.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Reset()
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    _ipropNext = 0;

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Clone
//
//  Synopsis:   Creates an IEnumSTATPROPSTG with same cursor
//              as this.
//
//  Arguments:  S_OK or error.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Clone(IEnumSTATPROPSTG ** ppenum)
{
    HRESULT hr = S_OK;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the input

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );
    *ppenum = NULL;

    //  --------------------
    //  Clone the enumerator
    //  --------------------

    *ppenum = new CEnumSTATPROPSTG( *this );

    if( NULL == *ppenum )
		hr = STG_E_INSUFFICIENTMEMORY;

    return(hr);
}




//+----------------------------------------------------------------------------
//
//  Function:   Lock & Unlock
//
//  Synopsis:   This methods take and release the CPropertyStorage's
//              critical section.
//
//  Inputs:     none
//
//  Returns:    Nothing
//
//+----------------------------------------------------------------------------

VOID
CPropertyStorage::Lock(void)
{
#ifndef _MAC
    DfpAssert (_fInitCriticalSection);
    EnterCriticalSection( &_CriticalSection );
#endif

#if DBG
    _cLocks++;
#endif

}

VOID
CPropertyStorage::Unlock()
{
#if DBG
    --_cLocks;
    DfpAssert( 0 <= _cLocks );
#endif

#ifndef _MAC
    DfpAssert (_fInitCriticalSection);
    LeaveCriticalSection( &_CriticalSection );
#endif
}



//+----------------------------------------------------------------------------
//
//  Function:   CPropertyStorage::ProbeStreamToDetermineIfWriteable
//
//  Synopsis:   Probes the IStream which holds the property set to see if it
//              can be written.  Ordinarily we know whether or not a stream
//              is writeable either because we were given the grfMode or
//              because we Stat-ed it out of the stream.  But this code
//              was added for the case where IStream::Stat returns zero
//              for the grfMode but it's actually writeable (this happens
//              with CreateStreamOnHGlobal).  So a grfMode of zero is a hint
//              that the IStream may not support that value in the Stat.
//
//              This method should be called lazily the first time a modify
//              operation is called on the property set, because it will
//              cause an update to the last-modify time of the stream.
//
//  Inputs:     none
//
//  Returns:    TRUE if the stream is writeable.  Also sets
//              _fExplicitelyProbedForWriteAccess so that we don't call this
//              twice.
//
//+----------------------------------------------------------------------------

BOOL
CPropertyStorage::ProbeStreamToDetermineIfWriteable()
{
    HRESULT hr = S_OK;
    BOOL fWriteable = FALSE;
    BYTE FirstByte;
    LARGE_INTEGER liZero = {0};

    propITrace( "CPropertyStorage::ProbeStreamToDetermineIfWriteable" );
    AssertLocked();
    DfpAssert( !_fExplicitelyProbedForWriteAccess );

    // This routine is only called once

    _fExplicitelyProbedForWriteAccess = TRUE;

    // Read then write a byte

    hr = _pstmPropSet->Read( &FirstByte, 1, NULL );
    if( FAILED(hr) ) goto Exit;

    hr = _pstmPropSet->Seek( liZero, STREAM_SEEK_SET, NULL );
    if( FAILED(hr) ) goto Exit;

    hr = _pstmPropSet->Write( &FirstByte, 1, NULL );
    if( FAILED(hr) ) goto Exit;

    // If the write worked, then this stream is really STGM_READWRITE

    fWriteable = TRUE;
    _grfMode |= STGM_READWRITE;

Exit:

    propDbg((DEB_ITRACE, "Property Set %p %s writeable (hr=%08x)\n",
            this, fWriteable?"is":"isn't", hr ));

    return( fWriteable );

}


//+-----------------------------------------------------------------------
//
//  Member:     InitializeOnCreateOrOpen
//
//  Synopsis:   This routine is called during the creation or opening
//              of a Property Storage, and initializes everything
//              it can without being concerned about whether this
//              is a simple or non-simple property set.
//
//  Inputs:     [DWORD] grfFlags (in)
//                  From the PROPSETFLAG_* enumeration.
//              [DWORD] grfMode (in)
//                  From the STGM_* enumeration.
//              [REFFMTID] rfmtid (in)
//                  The ID of the property set.
//              [BOOL] fCreate (in)
//                  Distinguishes Create from Open.
//
//  Returns:    [HRESULT]
//
//  Effects:    _grfFlags, _grfMode, _fUserDefinedProperties,
//              and g_ReservedMemory.
//
//+-----------------------------------------------------------------------


HRESULT
CPropertyStorage::InitializeOnCreateOrOpen(
                                      DWORD grfFlags,
                                      DWORD grfMode,
                                      REFFMTID rfmtid,
                                      BOOL fCreate )
{
    HRESULT hr = S_OK;

    propITrace( "CPropertyStorage::InitializeOnCreateOrOpen" );
    AssertLocked();

    // If the caller didn't give us a grfMode, stat for it.

    if( 0 == grfMode )
    {
        STATSTG statstg;    
        DfpAssert( NULL != _pstgPropSet || NULL != _pstmPropSet );

        if( NULL != _pstgPropSet )
            hr = _pstgPropSet->Stat( &statstg, STATFLAG_NONAME );
        else
            hr = _pstmPropSet->Stat( &statstg, STATFLAG_NONAME );

        if( FAILED(hr) ) goto Exit;
        grfMode = statstg.grfMode;
    }

    // Validate that grfFlags is within the enumeration.
    if (grfFlags & ~(PROPSETFLAG_ANSI | PROPSETFLAG_NONSIMPLE | PROPSETFLAG_UNBUFFERED | PROPSETFLAG_CASE_SENSITIVE))
    {
        hr = STG_E_INVALIDFLAG;
        goto Exit;
    }

    hr = CheckFlagsOnCreateOrOpen( fCreate, grfMode );
    if (hr != S_OK)
    {
        goto Exit;
    }

    // Store the grfFlags & grfMode.
    _grfFlags = grfFlags;

    _grfMode = grfMode;

    // Is this the special-case second-section property set?
    _fUserDefinedProperties = ( rfmtid == FMTID_UserDefinedProperties ) ? TRUE : FALSE;

    if (fCreate
        &&
        (_grfFlags & PROPSETFLAG_ANSI) )
    {
        _usCodePage = static_cast<USHORT>(GetACP());
    }

    // Initialize the global reserved memory (to prevent problems
    // in low-memory conditions).

    if (S_OK != (hr = g_ReservedMemory.Init()))
        goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    return( hr );


}   // CPropertyStorage::InitializeOnCreate()



//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Create( IStream * ...
//
//  Synopsis:   This method creates an IPropertyStorage on a
//              given *Stream*.  It is therefore a simple property
//              set.  The given Stream is addref-ed.
//
//  Arguments:  [IStream*] pstm
//                  The Stream which will hold the serialized property set.
//              [REFFMTID] rfmtid
//                  The ID of the property set.
//              [const CLSID*]
//                  The COM object which can interpret the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_* enumeration.
//              [DWORD] grfMode
//                  From the STGM_* enumeration.  If 0, we use Stat.
//              [HRESULT*]
//                  The return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::Create(
                IStream       *pstm,
                REFFMTID      rfmtid,
                const CLSID   *pclsid,
                DWORD         grfFlags,
                DWORD         grfMode
                )
{
    HRESULT hr = S_OK;
    BOOL fCreated = FALSE;
    BOOL    fLocked = FALSE;

    propITrace( "CPropertyStorage::Create(IStream*)" );
    propTraceParameters(( "pstm=%p, rfmtid=%s, grfFlags=%s, grfMode=%s, fDelete=%s",
                          pstm,
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize(*pclsid)),
                          static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))) ));

    // Save and addref the Stream.

    _pstmPropSet = pstm;
    _pstmPropSet->AddRef();

    Lock();
    fLocked = TRUE;

    // Initialize this object

    DfpAssert( !(PROPSETFLAG_NONSIMPLE & grfFlags ));
    hr = InitializeOnCreateOrOpen( grfFlags, grfMode, rfmtid,
                                   TRUE ); // => Create
    if( FAILED(hr) ) goto Exit;

    DfpAssert( !IsNonSimple() );

    // Initialize the Stream.

    hr = InitializePropertyStream( &rfmtid, pclsid, CREATE_PROPSTREAM );
    if( FAILED(hr) ) goto Exit;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // On error, remove our reference to the Stream.
    if( FAILED(hr) )
    {
        _pstmPropSet->Release();
        _pstmPropSet = NULL;

        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::Create(IStream*)"
            " hr=%08X\n", this, hr));
    }

    if( fLocked )
        Unlock();

    return( hr );

}   // CPropertyStorage::Create( IStream *, ...


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Create( IStorage *, ...
//
//  Synopsis:   This method creates an IPropertyStorage on a
//              given *Storage*.  It is therefore a non-simple property
//              set.  The Storage is addref-ed.
//
//  Arguments:  [IStorage*] pstm
//                  The Storage which will hold the serialized property set.
//              [REFFMTID] rfmtid
//                  The ID of the property set.
//              [const CLSID*]
//                  The COM object which can interpret the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_* enumeration.
//              [HRESULT*]
//                  The return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::Create(
                IStorage      *pstg,
                REFFMTID      rfmtid,
                const CLSID   *pclsid,
                DWORD         grfFlags,
                DWORD         grfMode
                )
{
    HRESULT hr = S_OK;
    BOOL fCreated = FALSE;
    BOOL    fLocked = FALSE;
    STATSTG statstg = { NULL };

    propITrace( "CPropertyStorage::Create(IStorage*)" );
    propTraceParameters(( "pstg=%p, rfmtid=%s, grfFlags=%s, grfMode=%s, fDelete=%s",
                          pstg,
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize(*pclsid)),
                          static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))) ));

    // Save the given Storage.

    _pstgPropSet = pstg;
    _pstgPropSet->AddRef();

    Lock();
    fLocked = TRUE;

    // Initialize this object.

    DfpAssert( grfFlags & PROPSETFLAG_NONSIMPLE );
    hr = InitializeOnCreateOrOpen( grfFlags, grfMode, rfmtid,
                                   TRUE ); // => Create
    if( FAILED(hr) ) goto Exit;

    DfpAssert( IsNonSimple() );

    // Create the "CONTENTS" stream.  Mask out the STGM_TRANSACTED
    // bit because we don't support it.

    hr = _pstgPropSet->CreateStream(g_oszPropertyContentsStreamName,
                                    GetChildCreateMode() & ~STGM_TRANSACTED,
                                    0, 0, &_pstmPropSet);
    if (FAILED(hr)) goto Exit;
    fCreated = TRUE;

    // Initialize the CONTENTS Stream.

    hr = InitializePropertyStream( &rfmtid, pclsid, CREATE_PROPSTREAM );
    if( FAILED(hr) ) goto Exit;

    // In the transacted case, ensure that the contents
    // stream is actually published right away.
    // The logic is this ... if you have a storage and create a transacted
    // child storage, that child storage is complete and intact to the parent.
    // If you then revert the child, or make no changes to it, the parent still
    // has a valid (albeit empty) storage.  Now, say you do the same thing, but
    // the transacted child is a property set.  As it stands at this point in this
    // method, the parent can only see an empty storage.  For it to see a valid
    // (empty) property set child, it must see the Contents stream, along with its default
    // data (header, codepage, etc.).  In order to make this happen, we must
    // commit (not just flush) this storage that holds a property set.
    //
    // There's one more complication.  Even if this is a direct mode property 
    // set, the _pstgPropSet may be transacted nonetheless, for the purpose of
    // robustness (this happens in NFF).  So, we need to commit not if
    // _grfMode is transacted, but if _pstgPropSet says that it's transacted.

    hr = _pstgPropSet->Stat( &statstg, STATFLAG_NONAME );
    if( FAILED(hr) ) goto Exit;

    if( STGM_TRANSACTED & statstg.grfMode )
    {
        hr = Commit(STGC_DEFAULT);
        if( FAILED(hr) ) goto Exit;

    }

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    else if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // On error, remove our reference to the Storage.

    if( FAILED(hr) )
    {
        _pstgPropSet->Release();
        _pstgPropSet = NULL;

        // Also, delete the "CONTENTS" stream.
        if( fCreated )
            pstg->DestroyElement( g_oszPropertyContentsStreamName );

        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::Create(IStorage*)"
            " hr=%08X\n", this, hr));
    }

    if( fLocked )
        Unlock();

    return( hr );

}   // CPropertyStorage::Create( IStorage *, ...


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Open( IStream * ...
//
//  Synopsis:   This method opens an IPropertyStorage on a
//              given *Stream*.  It is therefore a simple property
//              set.  The Stream is addref-ed.
//
//  Arguments:  [IStream*] pstm
//                  The Stream which will hold the serialized property set.
//              [REFFMTID] rfmtid
//                  The ID of the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_ enumeration.  Only the
//                  _UNBUFFERED flag is relevant _ANSI and
//                  _NONSIMPLE are inferred from the property set.
//              [BOOL] fDelete
//                  If TRUE, the property set is actually to be deleted,
//                  rather than opened (this is used for the special-case
//                  "UserDefined" property set).
//              [HRESULT*]
//                  The return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::Open(
                IStream *pstm,
                REFFMTID  rfmtid,
                DWORD     grfFlags,
                DWORD     grfMode,
                BOOL      fDelete
                )
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    propITrace( "CPropertyStorage::Open(IStream*)" );
    propTraceParameters(( "pstm=%p, rfmtid=%s, grfFlags=%s, grfMode=%s, fDelete=%s",
                          pstm,
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))),
                          fDelete ? "True":"False" ));

    // Keep a copy of the Stream.

    _pstmPropSet = pstm;
    _pstmPropSet->AddRef();

    Lock();
    fLocked = TRUE;

    // Initialize this object.

    hr = InitializeOnCreateOrOpen( grfFlags,
                                   grfMode,
                                   rfmtid,
                                   FALSE ); // => Open
    if( FAILED(hr) ) goto Exit;

    // Only simple sections may be deleted (really, only the
    // second section of the DocumentSummaryInformation property
    // set may be deleted in this way).

    DfpAssert( !fDelete || !IsNonSimple() );

    // Initialize the property set Stream.

    if (hr == S_OK)
    {
        // sets up _usCodePage
        hr = InitializePropertyStream(
                &rfmtid,
                NULL,
                fDelete ? DELETE_PROPSTREAM : OPEN_PROPSTREAM );

    }
    if( FAILED(hr) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    // On error, remove our reference to the Stream.
    if( FAILED(hr) )
    {
        _pstmPropSet->Release();
        _pstmPropSet = NULL;

        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::Open(IStream*)"
            " hr=%08X\n", this, hr));
    }

    if( fLocked )
        Unlock();

    return( hr );

}   // CPropertyStorage::Open( IStream *, ...


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Open( IStorage * ...
//
//  Synopsis:   This method opens an IPropertyStorage on a
//              given *Storage*.  It is therefore a non-simple property
//              set.  The Storage is addref-ed.
//
//  Arguments:  [IStorage*] pstg
//                  The Storage which will hold the serialized property set.
//              [REFFMTID] rfmtid
//                  The ID of the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_ enumeration.  Only the
//                  _UNBUFFERED flag is relevant _ANSI and
//                  _NONSIMPLE are inferred from the property set.
//              [HRESULT*]
//                  The return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::Open(
                IStorage *pstg,
                REFFMTID  rfmtid,
                DWORD     grfFlags,
                DWORD     grfMode
                )
{
    HRESULT hr = S_OK;
    CPropSetName psn(rfmtid);
    USHORT createprop = 0L;
    BOOL    fLocked = FALSE;

    propITrace( "CPropertyStorage::Open(IStorage*)" );
    propTraceParameters(( "pstg=%p, rfmtid=%s, grfFlags=%s, grfMode=%s",
                          pstg,
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))) ));


    // Keep a copy of the Storage

    _pstgPropSet = pstg;
    _pstgPropSet->AddRef();

    Lock();
    fLocked = TRUE;

    // Initialize this object.

    hr = InitializeOnCreateOrOpen( grfFlags,
                                   grfMode,
                                   rfmtid,
                                   FALSE ); // => Open
    if( FAILED(hr) ) goto Exit;

    _grfFlags |= PROPSETFLAG_NONSIMPLE;

    // Open the CONTENTS stream.  Mask out the STGM_TRANSACTED bit
    // because it causes an error on Mac OLE2.

    hr = _pstgPropSet->OpenStream( g_oszPropertyContentsStreamName,
                                   0,
                                   GetChildOpenMode() & ~STGM_TRANSACTED,
                                   0,
                                   &_pstmPropSet );
    if( FAILED(hr) ) goto Exit;


    // Load the property set Stream.

    if (hr == S_OK)
    {
        // sets up _usCodePage
        hr = InitializePropertyStream(
                &rfmtid,
                NULL,
                OPEN_PROPSTREAM );

    }
    if( FAILED(hr) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    // On error, remove our reference to the Storage.

    if( FAILED(hr) )
    {
        _pstgPropSet->Release();
        _pstgPropSet = NULL;

        if( NULL != _pstmPropSet )
        {
            _pstmPropSet->Release();
            _pstmPropSet = NULL;
        }

        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::Open(IStorage*)"
            " hr=%08X\n", this, hr));
    }

    if( fLocked )
        Unlock();

    return( hr );

}   // CPropertyStorage::Open( IStorage *, ...


//+----------------------------------------------------------------
//
//  Member:     CPropertyStorage::CreateMappedStream
//
//  Synopsis:   Create a IMappedStream object on an IStream.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      This method calls QI through the PropSet Stream to see if
//              a mapped stream exists.  If it doesn't then this
//              method creates a IMappedStream which maps
//              an IStream.
//
//+----------------------------------------------------------------

HRESULT
CPropertyStorage::CreateMappedStream()
{
    HRESULT hr;

    DfpAssert( NULL != _pstmPropSet );
    DfpAssert( NULL == _ms );
    AssertLocked();
    propITrace( "CPropertyStorage::CreateMappedStream" );

    // QI the property set's IStream, if asked to do so, for an IMappedstream.
    if( MAPPED_STREAM_QI == _fMSOpts )
    {
        // We got a mapped stream, so we're done.
        hr = _pstmPropSet->QueryInterface(IID_IMappedStream,(void**)&_ms);
        if (SUCCEEDED(hr))
        {
            propDbg(( DEB_INFO, "Using QI-ed IMappedStream\n" ));
            goto Exit;
        }
    }

    // Either we couldn't get a mapped stream from the IStream, or
    // we were told not to ask for one.  In either case, we'll
    // create our own.

    hr = S_OK;

    _ms = (IMappedStream *) new CSSMappedStream( _pstmPropSet );
    if( NULL == _ms )
        hr = E_OUTOFMEMORY;
    else
        propDbg(( DEB_INFO, "Using CSSMappedStream\n" ));

Exit:
    return( hr );
}

VOID
CPropertyStorage::DeleteMappedStream()
{
    AssertLocked();

    if (NULL != _ms) {
        _ms->Release();
    }
    _ms = NULL;
}



#if DBG

HRESULT
CPropertyStorage::UseNTFS4Streams( BOOL fUseNTFS4Streams )
{
    IStorageTest *pPropStgTest = NULL;
    HRESULT hr = S_OK;

    if( NULL != _pstmPropSet )
        hr = _pstmPropSet->QueryInterface( IID_IStorageTest,
                                           reinterpret_cast<void**>(&pPropStgTest) );
    else if( NULL != _pstgPropSet )
        hr = _pstgPropSet->QueryInterface( IID_IStorageTest,
                                           reinterpret_cast<void**>(&pPropStgTest) );
    else
        hr = STG_E_NOMOREFILES;
    if( FAILED(hr) ) goto Exit;

    hr = pPropStgTest->UseNTFS4Streams( fUseNTFS4Streams );
    if( FAILED(hr) ) goto Exit;

Exit:

    if( NULL != pPropStgTest )
        pPropStgTest->Release();

    return( hr );

}   // CPropertyStorage::UseNTFS4Streams()
#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CPropertyStorage::GetFormatVersion (IStorageTest) **DBG**
//
//  Get the property set's wFormatVersion field.
//
//+----------------------------------------------------------------------------

#if DBG
HRESULT
CPropertyStorage::GetFormatVersion(WORD *pw)
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    CPropertySetStream *pPropertySetStream = (CPropertySetStream*) _np;

    status = pPropertySetStream->Lock( TRUE );
    if( !NT_SUCCESS(status) ) goto Exit;

    pPropertySetStream->ReOpen( &status );
    if( !NT_SUCCESS(status) ) goto Exit;

    *pw = pPropertySetStream->GetFormatVersion();
    status = STATUS_SUCCESS;

Exit:

    if( !NT_SUCCESS(status) )
        hr = DfpNtStatusToHResult(status);

    pPropertySetStream->Unlock();
    return( hr );
}
#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CPropertyStorage::SimulateLowMemory (IStorageTest) **DBG**
//
//  Forcable turn on the low-memory support in the IMappedStream implementation.
//
//+----------------------------------------------------------------------------

#if DBG
HRESULT
CPropertyStorage::SimulateLowMemory( BOOL fSimulate )
{
    IStorageTest *pPropStgTest = NULL;
    HRESULT hr = S_OK;

    if( NULL != _pstmPropSet )
        hr = _pstmPropSet->QueryInterface( IID_IStorageTest,
                                           reinterpret_cast<void**>(&pPropStgTest) );
    else if( NULL != _pstgPropSet )
        hr = _pstgPropSet->QueryInterface( IID_IStorageTest,
                                           reinterpret_cast<void**>(&pPropStgTest) );
    else
        hr = STG_E_NOMOREFILES;
    if( FAILED(hr) ) goto Exit;

    hr = pPropStgTest->SimulateLowMemory( fSimulate );
    if( FAILED(hr) ) goto Exit;

Exit:

    if( NULL != pPropStgTest )
        pPropStgTest->Release();

    return( hr );
}
#endif  // #if DBG


#if DBG
HRESULT
CPropertyStorage::GetLockCount()
{
    return( E_NOTIMPL );
}
#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CPropertyStorage::IsDirty (IStorageTest) **DBG**
//
//  Determine if the IMappedStream is dirty.
//
//+----------------------------------------------------------------------------

#if DBG
HRESULT
CPropertyStorage::IsDirty()
{
    HRESULT hr = S_OK;
    IStorageTest *ptest = NULL;

    if( NULL == _ms )
    {
        hr = S_FALSE;
        goto Exit;
    }

    hr = _ms->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
    if( FAILED(hr) ) goto Exit;

    hr = ptest->IsDirty();

Exit:

    RELEASE_INTERFACE(ptest);
    return( hr );

}
#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CPropertyStorage::ValidateVTs
//
//  Validate the VTs in an array of PropVariants.  If we see a type we don't
//  understand, return error_not_supported.
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyStorage::ValidateVTs( ULONG cprops, const PROPVARIANT rgpropvar[] )
{
    HRESULT hr = S_OK;
    propITrace( "CPropertyStorage::ValidateVTs" );
    propTraceParameters(( "cprops=%d, rgpropvar=%p", cprops, rgpropvar ));

    for( ULONG i = 0; i < cprops; i++ )
    {
        if( !IsSupportedVarType( rgpropvar[i].vt ) )
        {
            propDbg(( DEB_IWARN, "Unsupported VarType in ValidateVTs: 0x%x\n", rgpropvar[i].vt ));
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            propSuppressExitErrors();
            goto Exit;
        }
    }

Exit:

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\ssmapstm.cxx ===
//+============================================================================
//
//  File:       SSMapStm.cxx
//
//  Purpose:    This file defines the CSSMappedStream class.
//              This class provdes a IMappedStream implementation
//              which maps an IStream from a Compound File.
//
//  History:
//
//      5/6/98  MikeHill
//              -   Use CoTaskMem rather than new/delete.
//
//+============================================================================

//  --------
//  Includes
//  --------

#include <pch.cxx>
#include "SSMapStm.hxx"

#include <privguid.h>       // IID_IMappedStream

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif


//+----------------------------------------------------------------------------
//
//  Method:     CSSMappedStream::Initialize
//
//  Synopsis:   Zero-out all of the member data.
//
//  Arguments:  None
//
//  Returns:    None
//
//
//+----------------------------------------------------------------------------

VOID
CSSMappedStream::Initialize()
{
    propDbg(( DEB_ITRACE, "CSSMappedStream::Initialize\n" ));

    _pstm = NULL;
    _pbMappedStream = NULL;
    _cbMappedStream = 0;
    _cbActualStreamSize = 0;
    _powner = NULL;
    _fLowMem = FALSE;
    _fDirty = FALSE;

#if DBGPROP
    _fChangePending = FALSE;
#endif

}   // CSSMappedStream::Initialize()


//+----------------------------------------------------------------------------
//
//  Member:     Constructor/Destructor
//
//  Synopsis:   Initialize/cleanup this object.
//
//+----------------------------------------------------------------------------

CSSMappedStream::CSSMappedStream( IStream *pstm )
{
    DfpAssert( NULL != pstm );

    // Initialize the member data.
    Initialize();

    // Keep a copy of the Stream that we're mapping.
    _pstm = pstm;
    _pstm->AddRef();
    _cRefs = 1;
}


CSSMappedStream::~CSSMappedStream( )
{
    // Just to be safe, free the mapping buffer (it should have
    // already been freed).

    DfpAssert( NULL == _pbMappedStream );
    CoTaskMemFree( _pbMappedStream );

    // If we've got the global reserved buffer locked,
    // free it now.

    if (_fLowMem)
    {
        g_ReservedMemory.UnlockMemory();
    }

    // Free the stream which we were mapping.

    if( NULL != _pstm )
        _pstm->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown members
//
//--------------------------------------------------------------------

HRESULT CSSMappedStream::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr = S_OK;

    // Validate the inputs

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----------------
    //  Perform the Query
    //  -----------------

    *ppvObject = NULL;

    if (IsEqualIID(riid,IID_IMappedStream) || IsEqualIID(riid,IID_IUnknown))
    {
        *ppvObject = (IMappedStream *)this;
        CSSMappedStream::AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return(hr);
}

ULONG   CSSMappedStream::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

ULONG   CSSMappedStream::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSSMappedStream::Open
//
//  Synopsis:   Open up the Stream which we're mapping, and
//              read it's data into a buffer.
//
//  Arguments:  [VOID*] powner
//                  The owner of this Stream.  We use this for the
//                  PrOnMappedStreamEvent call.
//              [HRESULT*] phr
//                  The return code.
//
//  Returns:    Nothing.
//
//+----------------------------------------------------------------------------


VOID
CSSMappedStream::Open( IN VOID     *powner,
                       OUT HRESULT *phr )
{
    HRESULT &hr = *phr;
    VOID *pv = NULL;
    DfpAssert(!_fLowMem);

    hr = S_OK;
    propITrace( "CSSMappedStream::Open" );

    // If given a pointer to the owner of this mapped stream,
    // save it.  This could be NULL (i.e., when called from
    // ReOpen).

    if( NULL != powner  )
        _powner = powner;

    // If we haven't already read the stream, read it now.

    if( NULL == _pbMappedStream )
    {
        STATSTG statstg;
        LARGE_INTEGER liSeek;

        DfpAssert( NULL != _pstm );
        DfpAssert( 0 == _cbMappedStream );
        DfpAssert( 0 == _cbActualStreamSize );

        // Get and validate the size of the Stream.

        *phr = _pstm->Stat( &statstg, STATFLAG_NONAME );
        if( FAILED(*phr) ) goto Exit;

        if( statstg.cbSize.HighPart != 0
            ||
            statstg.cbSize.LowPart > CBMAXPROPSETSTREAM )
        {
            *phr = STG_E_INVALIDHEADER;
            goto Exit;
        }
        _cbMappedStream = _cbActualStreamSize = statstg.cbSize.LowPart;

        // Allocate a buffer to hold the Stream.  If there isn't sufficient
        // memory in the system, lock and get the reserved buffer.  In the
        // end, 'pv' points to the appropriate buffer.

        pv = CoTaskMemAlloc( _cbActualStreamSize );

        if (pv == NULL)
        {
            pv = g_ReservedMemory.LockMemory();   // could wait until previous
                                                  // property call completes
            _fLowMem = TRUE;
        }
        _pbMappedStream = (BYTE*) pv;

        // Seek to the start of the Stream.

        liSeek.HighPart = 0;
        liSeek.LowPart = 0;
        *phr = _pstm->Seek( liSeek, STREAM_SEEK_SET, NULL );
        if( FAILED(*phr) ) goto Exit;

        // Read in the Stream.  But only if it is non-zero; some
        // stream implementations (namely the Mac StreamOnHGlobal imp)
        // don't allow 0-length reads.

        if( 0 != _cbActualStreamSize )
        {
            *phr = _pstm->Read(
                          _pbMappedStream,
                          _cbActualStreamSize,
                          &_cbMappedStream);
            if( FAILED(*phr) ) goto Exit;

            // Ensure that we got all the bytes we requested.

            if( _cbMappedStream != _cbActualStreamSize )
            {
                propDbg((DEBTRACE_ERROR,
                         "CSSMappedStream(%08X)::Open bytes-read (%lu) doesn't match bytes-requested (%lu)\n",
                         this, _cbMappedStream, _cbActualStreamSize ));
                *phr = STG_E_INVALIDHEADER;
                goto Exit;
            }
        }


#if BIGENDIAN==1
        // Notify our owner that we've read in new data.

        if( _powner != NULL && 0 != _cbMappedStream )
        {
            *phr = PrOnMappedStreamEvent( _powner, _pbMappedStream, _cbMappedStream );
            if( FAILED(*phr) ) goto Exit;
        }
#endif

    }   // if( NULL == _pbMappedStream )

    //  ----
    //  Exit
    //  ----

Exit:

    // If there was an error, free any memory we have.

    if( FAILED(*phr) )
    {
        propDbg((DEB_ERROR, "CSSMappedStream(%08X):Open exception returns %08X\n", this, *phr));

        if (_fLowMem)
            g_ReservedMemory.UnlockMemory();
        else
            CoTaskMemFree( pv );

        _pbMappedStream = NULL;
        _cbMappedStream = 0;
        _cbActualStreamSize = 0;
        _fLowMem = FALSE;
    }

    return;

}   // CSSMappedStream::Open


//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Flush
//
//  Synopsis:   Write out the mapping buffer to the Stream,
//              and Commit it.
//
//  Arguments:  [LONG*] phr
//                  An HRESULT return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Flush(OUT LONG *phr)
{

    HRESULT &hr = *phr;
    propITrace( "CSSMappedStream::Flush" );

    // Write out any data we have cached to the Stream.
    hr = Write();

    // Commit the Stream.
    if( SUCCEEDED(hr) )
    {
        hr = _pstm->Commit(STGC_DEFAULT);
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Close
//
//  Synopsis:   Close the mapped stream by writing out
//              the mapping buffer and then freeing it.
//
//  Arguments:  [LONG*] phr
//                  An HRESULT error code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Close(OUT LONG *phr)
{
    // Write the changes.  We don't need to Commit them,
    // they will be implicitely committed when the
    // Stream is Released.

    HRESULT &hr = *phr;
    propITrace( "CSSMappedStream::Close" );

    hr = Write();

    // Even if we fail the write, we must free the memory.
    // (PrClosePropertySet deletes everything whether or not
    // there was an error here, so we must free the memory.
    // There's no danger of this happenning due to out-of-
    // disk-space conditions, because the propset code
    // pre-allocates).

    CoTaskMemFree( _pbMappedStream );
    _pstm->Release();

    // Re-zero the member data.
    Initialize();

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::ReOpen
//
//  Synopsis:   Gets the caller a pointer to the already-opened
//              mapping buffer.  If it isn't already opened, then
//              it is opened here.
//
//  Arguments:  [VOID**] ppv
//                  Used to return the mapping buffer.
//              [LONG*] phr
//                  Used to return an HRESULT.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
    *ppv = NULL;

    Open(NULL,  // Unspecified owner.
         phr);

    if( SUCCEEDED(*phr) )
        *ppv = _pbMappedStream;

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Quiesce
//
//  Synopsis:   Unnecessary for this IMappedStream implementation.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Quiesce(VOID)
{
    DfpAssert(_pbMappedStream != NULL);
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Map
//
//  Synopsis:   Used to get a pointer to the current mapping.
//
//  Arguments:  [BOOLEAN] fCreate
//                  Not used by this IMappedStream implementation.
//              [VOID**] ppv
//                  Used to return the mapping buffer.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Map(BOOLEAN fCreate, VOID **ppv)
{
    DfpAssert(_pbMappedStream != NULL);
    *ppv = _pbMappedStream;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Unmap
//
//  Synopsis:   Unnecessary for this IMappedStream implementation.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Unmap(BOOLEAN fFlush, VOID **ppv)
{
    *ppv = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Write
//
//  Synopsis:   Writes the mapping buffer out to the original
//              Stream.
//
//  Arguments:  None.
//
//  Returns:    [HRESULT]
//                  S_FALSE => Nothing needed to be written
//
//--------------------------------------------------------------------
#define STACK_BYTES 16

HRESULT CSSMappedStream::Write ()
{
    HRESULT hr;
    ULONG cbWritten;
    LARGE_INTEGER liSeek;
    BOOL fOwnerSignaled = FALSE;

    propITrace( "CSSMappedStream::Write" );

    // We can return right away if there's nothing to write.
    // (_pbMappedStream may be NULL in the error path of our
    // caller).

    if (!_fDirty || NULL == _pbMappedStream )
    {
        propDbg((DEB_PROP_INFO, "CPubStream(%08X):Flush returns with not-dirty\n", this));

        return S_FALSE;
    }

    DfpAssert( _pstm != NULL );

#if BIGENDIAN==1
    // Notify our owner that we're about to perform a Write.
    // Note that there are no goto Exit calls prior to this point, because
    // we making a corresponding call to PrOnMappedStreamEvent (for byte-swapping)
    // in the Exit.
    hr = PrOnMappedStreamEvent( _powner, _pbMappedStream, _cbMappedStream );
    if( S_OK != hr ) goto Exit;
    fOwnerSignaled = TRUE;
#endif

    // Seek to the start of the Stream.
    liSeek.HighPart = 0;
    liSeek.LowPart = 0;
    hr = _pstm->Seek( liSeek, STREAM_SEEK_SET, NULL );
    if( FAILED(hr) ) goto Exit;

    // Write out the mapping buffer.
    hr = _pstm->Write(_pbMappedStream, _cbMappedStream, &cbWritten);
    if( S_OK != hr ) goto Exit;
    if( cbWritten != _cbMappedStream )
    {
        propDbg((DEB_ERROR,
                 "CSSMappedStream(%08X)::Write bytes-written (%lu) doesn't match bytes-requested (%lu)\n",
                 this, cbWritten, _cbMappedStream ));
        hr = STG_E_INVALIDHEADER;
        goto Exit;
    }

    // If the buffer is shrinking, this is a good time to shrink the Stream.
    if (_cbMappedStream < _cbActualStreamSize)
    {
        ULARGE_INTEGER uli;
        uli.HighPart = 0;
        uli.LowPart = _cbMappedStream;

        hr = _pstm->SetSize(uli);
        if( S_OK == hr )
        {
            _cbActualStreamSize = _cbMappedStream;
        }
    }

    //
    // If we changed the buffer size and it is less than the
    // actual underlying stream, then we need to zero out the memory
    // above the currrent size.
    //
    if (_cbMappedStream < _cbActualStreamSize)
    {
        PBYTE           pTemp;
        HRESULT         hr;
        LARGE_INTEGER   li;
        DWORD           cbWrite = _cbActualStreamSize - _cbMappedStream;

        li.HighPart = 0;
        li.LowPart = _cbMappedStream;
        hr = _pstm->Seek(li,STREAM_SEEK_SET,NULL);
        if (SUCCEEDED(hr))
        {
            pTemp = reinterpret_cast<PBYTE>( CoTaskMemAlloc( cbWrite ));
            if (pTemp != NULL)
            {
                memset(pTemp,0,cbWrite);
                //
                // Successfully allocated memory for the write.  Write the
                // zeros out all at once.
                //
                hr = _pstm->Write(pTemp, cbWrite, NULL);
                if (FAILED(hr))
                {
                    propDbg((DEB_ERROR, "CSSMappedStream::Write "
                        "write failure\n",hr));
                    goto Exit;
                }
                CoTaskMemFree( pTemp );
            }
            else
            {
                //
                // We couldn't allocate memory.  So we will use a small
                // stack buffer instead.
                //
                BYTE   stackBuf[STACK_BYTES];
                memset(stackBuf, 0, STACK_BYTES);

                while (cbWrite >= STACK_BYTES)
                {
                    hr = _pstm->Write(stackBuf, STACK_BYTES, NULL);
                    if (FAILED(hr))
                    {
                        propDbg((DEB_ERROR, "CSSMappedStream::Write write failure\n",hr));
                        goto Exit;
                    }
                    cbWrite -= STACK_BYTES;
                }

                if (cbWrite < STACK_BYTES)
                {
                    hr = _pstm->Write(stackBuf, cbWrite, NULL);
                    if (FAILED(hr))
                    {
                        propDbg((DEB_ERROR, "CSSMappedStream::Write write failure\n",hr));
                        goto Exit;
                    }
                }
            }
        }
        else
        {
            propDbg((DEB_ERROR, "CSSMappedStream::Write seek failure\n",hr));
            goto Exit;
        }
    }
    //  ----
    //  Exit
    //  ----

Exit:

    // Notify our owner that we're done with the Write.  We do this
    // whether or not there was an error, because _pbMappedStream is
    // not modified, and therefore intact even in the error path.
    // This call allows the owner to correct the byte-order of the header.

#if BIGENDIAN==1
    if( fOwnerSignaled )
        DfpVerify( PrOnMappedStreamEvent( _powner, _pbMappedStream, _cbMappedStream ));
#endif

    if (hr == S_OK || hr == STG_E_REVERTED)
    {
        _fDirty = FALSE;
    }

    return hr;

}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::GetSize
//
//  Synopsis:   Returns the current size of the mapped stream.
//
//  Arguments:  [LONG*] phr
//                  Used to return an HRESULT.
//
//  Returns:    [ULONG]
//                  The current size.
//
//--------------------------------------------------------------------

ULONG CSSMappedStream::GetSize(OUT LONG *phr)
{
    HRESULT &hr = *phr;
    hr = S_OK;

    propITrace( "CSSMappedStream::GetSize" );

    // If necessary, open the Stream.

    if( NULL == _pbMappedStream )
    {
        Open(NULL,  // Unspecified owner
             phr);
    }

    if( SUCCEEDED(*phr) )
    {
        DfpAssert( NULL != _pbMappedStream );
    }

    // Return the size of the mapped stream.  If there was an
    // Open error, it will be zero, and *phr will be set.

    propDbg(( DEB_ITRACE, "CSSMappedStream::GetSize, size is %d\n", _cbMappedStream ));
    return _cbMappedStream;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::SetSize
//
//  Synopsis:   Set the size of the mapped stream.
//
//  Arguments:  [ULONG] cb
//                  The new size.
//              [BOOLEAN] fPersistent
//                  If not set, then this change will not be stored -
//                  thus the mapping buffer must be set, but the
//                  Stream itself must not.  This was added so that
//                  CPropertySetStream could grow the buffer for internal
//                  processing, when the Stream itself is read-only.
//              [VOID**] ppv
//                  Used to return the new mapping buffer location.
//
//  Returns:    None.
//
//  Pre-Conditions:
//              cb is below the maximum property set size.
//
//--------------------------------------------------------------------

VOID
CSSMappedStream::SetSize(ULONG cb,
                         IN BOOLEAN fPersistent,
                         VOID **ppv, OUT LONG *phr)
{
    BYTE            *pv;

    HRESULT &hr = *phr;

    hr = S_OK;
    DfpAssert(cb != 0);
    DfpAssert(cb <= CBMAXPROPSETSTREAM);

    propITrace( "CSSMappedStream::SetSize" );
    propTraceParameters(( "cb=%lu, fPersistent=%s, ppv=%p", cb, fPersistent?"True":"False" ));

    //
    // if we are growing the data, we should grow the stream
    //
    if (fPersistent && cb > _cbActualStreamSize)
    {
        ULARGE_INTEGER  uli;
        uli.HighPart = 0;
        uli.LowPart = cb;

        //----------------
        // Need to Grow!
        //----------------

        propDbg(( DEB_ITRACE, "Growing from %d to %d\n", _cbActualStreamSize, cb ));
        *phr = _pstm->SetSize( uli );

        if (FAILED(*phr) )
            goto Exit;
        else
            _cbActualStreamSize = cb;
    }

    //
    // We only get here if we either (1) didn't want to grow the
    // underlying stream, or (2) we successfully grew the underlying stream.
    //

    //
    // Re-size the buffer to the size specified in cb.
    //
    if ( _fLowMem )
    {
        // If we want to grow the buffer In low-memory conditions,
        // no realloc is necessary, because
        // _pbMappedStream is already large enough for the largest
        // property set.

        *ppv = _pbMappedStream;
    }
    else if ( cb != _cbMappedStream )
    {

            // We must re-alloc the buffer.

            pv = reinterpret_cast<BYTE*>( CoTaskMemAlloc( cb ));

            if ((pv == NULL) )
            {
                // allocation failed: we need to try using a backup mechanism for
                // more memory.
                // copy the data to the global reserved chunk... we will wait until
                // someone else has released it.  it will be released on the way out
                // of the property code.

                _fLowMem = TRUE;
                pv = g_ReservedMemory.LockMemory();
                if ( NULL == pv)
                {
                    *phr = E_OUTOFMEMORY;
                    goto Exit;
                }
                else if( NULL != _pbMappedStream)
                {
                    memcpy( pv, _pbMappedStream, min(cb,_cbMappedStream) );
                }
                CoTaskMemFree( _pbMappedStream );
            }
            else
            {
                memcpy( pv, _pbMappedStream, min(cb,_cbMappedStream) );
                CoTaskMemFree( _pbMappedStream );
            }

            _pbMappedStream = pv;
            *ppv = pv;
    }
    _cbMappedStream = cb;

    //  ----
    //  Exit
    //  ----

Exit:

    propDbg((DbgFlag(*phr,DEB_TRACE), "CSSMappedStream(%08X):SetSize %s returns hr=%08X\n",
                                    this, *phr != S_OK ? "exception" : "", *phr));

}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Lock
//
//  Synopsis:   Locking is not supported by this class.
//
//--------------------------------------------------------------------

NTSTATUS CSSMappedStream::Lock(BOOLEAN fExclusive)
{
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Unlock
//
//  Synopsis:   Locking is not supported by this class.
//              However, this method still must check to
//              see if the reserved memory pool should be
//              freed for use by another property set.
//
//--------------------------------------------------------------------

NTSTATUS CSSMappedStream::Unlock(VOID)
{
    // if at the end of the properties set/get call we have the low
    // memory region locked, we flush to disk.
    HRESULT hr = S_OK;

    if (_fLowMem)
    {
        Flush(&hr);

        g_ReservedMemory.UnlockMemory();
        _pbMappedStream = NULL;
        _cbMappedStream = 0;
        _fLowMem = FALSE;
        propDbg((DEB_ERROR, "CPubStream(%08X):Unlock low-mem returns NTSTATUS=%08X\n",
            this, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::QueryTimeStamps
//
//  Synopsis:   Not used by this IMappedStream derivation.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::QueryTimeStamps(STATPROPSETSTG *pspss, BOOLEAN fNonSimple) const
{
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::QueryModifyTime
//
//  Synopsis:   Not used by this IMappedStream derivation.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CSSMappedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    return(FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     Unused methods by this IMappedStream implementation:
//              QuerySecurity, IsWritable, GetHandle
//
//--------------------------------------------------------------------

BOOLEAN CSSMappedStream::QuerySecurity(OUT ULONG *pul) const
{
    return(FALSE);
}

BOOLEAN CSSMappedStream::IsWriteable() const
{
    return TRUE;
}

HANDLE CSSMappedStream::GetHandle(VOID) const
{
    return(INVALID_HANDLE_VALUE);
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::SetModified/IsModified
//
//--------------------------------------------------------------------

VOID CSSMappedStream::SetModified(OUT LONG *phr)
{
    _fDirty = TRUE;
    *phr = S_OK;
}

BOOLEAN CSSMappedStream::IsModified(VOID) const
{
    propDbg(( DEB_ITRACE, "CSSMappedStream::IsModified (%s)\n", _fDirty?"TRUE":"FALSE" ));
    return (BOOLEAN) _fDirty;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::IsNtMappedStream/SetChangePending
//
//  Synopsis:   Debug routines.
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CSSMappedStream::IsNtMappedStream(VOID) const
{
    return(FALSE);
}
#endif


#if DBGPROP
BOOLEAN CSSMappedStream::SetChangePending(BOOLEAN f)
{
    BOOL fOld = _fChangePending;
    _fChangePending = f;
    return((BOOLEAN)_fChangePending);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\stgvarb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       StgVarB.cxx
//
//  Contents:   C++ Base wrapper for PROPVARIANT.
//
//  History:    01-Aug-94 KyleP     Created
//              31-Jul-96 MikeHill  - Relaxed assert in IsUnicodeString.
//                                  - Allow NULL strings.
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "debtrace.hxx"
#include <propset.h>
#include <propvar.h>

// These optionally-compiled directives tell the compiler & debugger
// where the real file, rather than the copy, is located.
#ifdef _ORIG_FILE_LOCATION_
#if __LINE__ != 25
#error File heading has change size
#else
#line 29 "\\nt\\private\\dcomidl\\stgvarb.cxx"
#endif
#endif

#if DBGPROP

BOOLEAN
IsUnicodeString(WCHAR const *pwszname, ULONG cb)
{
    if (cb != 0)
    {
	for (ULONG i = 0; pwszname[i] != L'\0'; i++)
	{
	}
        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.

        PROPASSERT(cb == MAXULONG || (i + 1) * sizeof(WCHAR) <= cb);
    }
    return(TRUE);
}


BOOLEAN
IsAnsiString(CHAR const *pszname, ULONG cb)
{
    if (cb != 0)
    {
        // If the string is NULL, then it's not not an Ansi string,
        // so we'll call it an Ansi string.

        if( NULL == pszname )
            return( TRUE );

	for (ULONG i = 0; pszname[i] != '\0'; i++)
	{
	}
        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.

	PROPASSERT(cb == MAXULONG || i + 1 <= cb);
    }
    return(TRUE);
}
#endif


//+-------------------------------------------------------------------
//  Member:    CBaseStorageVariant::UnmarshalledSize, public
//
//  Synopsis:  Unmarshalls a PROPVARIANT value serialized in a PDeSerStream.
//
//  Arguments: [stm] -- serialized stream
//             [cb]  -- size of *additional* data goes here.  Size of
//                      base PROPVARIANT not included.
//
//  Returns:   one of the following NTSTATUS values
//             STATUS_SUCCESS -- the call was successful.
//             STATUS_INVALID_PARAMETER -- unsupported type for unmarshalling.
//
//  Notes:     The size is computed assuming 4-byte granular allocations.
//
//--------------------------------------------------------------------

#if defined(WINNT) && !defined(IPROPERTY_DLL)

#ifdef KERNEL
NTSTATUS
CBaseStorageVariant::UnmarshalledSize(
    PDeSerStream& stm,
    ULONG &cb)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cElems = 0;
    ULONG i;

    cb = 0;

    VARTYPE vt = (VARTYPE) stm.GetULong();

    switch (vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        break;

    case VT_CLSID:
        cb = sizeof(GUID);
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        cb = stm.GetULong();
        break;

    case VT_CF:
        cb = stm.GetULong() + sizeof(CLIPDATA);
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
        PROPASSERT("Serialization of stream not yet supported!");
        Status = STATUS_INVALID_PARAMETER;
        break;

    case VT_STORAGE:
    case VT_STORED_OBJECT:
        PROPASSERT("Serialization of storage not yet supported!");
        Status = STATUS_INVALID_PARAMETER;
        break;

    case VT_BSTR:
        cb = sizeof(ULONG) + stm.GetULong();
        break;

    case VT_LPSTR:
        cb = stm.GetULong();
        break;

    case VT_LPWSTR:
        cb = stm.GetULong() * sizeof(WCHAR);
        break;

    case VT_VECTOR | VT_UI1:
        cb = stm.GetULong();
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cb = stm.GetULong() * sizeof(SHORT);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cb = stm.GetULong() * sizeof(LONG);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cb = stm.GetULong() * sizeof(LARGE_INTEGER);
        break;

    case VT_VECTOR | VT_CLSID:
        cb = stm.GetULong() * sizeof(GUID);
        break;

    case VT_VECTOR | VT_CF:
        cElems = stm.GetULong();
        cb = cElems * sizeof(CLIPDATA);
        break;

    case VT_VECTOR | VT_BSTR:
        cElems = stm.GetULong();
        cb = cElems * (sizeof(ULONG) + sizeof(LPSTR));
        break;

    case VT_VECTOR | VT_LPSTR:
        cElems = stm.GetULong();
        cb = cElems * sizeof(LPSTR);
        break;

    case VT_VECTOR | VT_LPWSTR:
        cElems = stm.GetULong();
        cb = cElems * sizeof(LPWSTR);
        break;

    case VT_VECTOR | VT_VARIANT:
        cElems = stm.GetULong();
        cb = cElems * sizeof(PROPVARIANT);
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT marshalling");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    cb = (cb + 3) & ~3;

    if (cElems == 0 || Status != STATUS_SUCCESS)
    {
        return(Status);
    }

    // We have a variant with variable sized data which requires
    // further unmarshalling.
    switch(vt)
    {
    case VT_VECTOR | VT_CF:
        for (i = 0; i < cElems; i++)
        {
            ULONG len = (stm.GetULong() + 3) & ~3;

            cb += len;
            stm.SkipChar(sizeof(ULONG) + len);
        }
        break;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
        for (i = 0; i < cElems; i++)
        {
            ULONG len = (stm.GetULong() + 3) & ~3;

            cb += len;
            stm.SkipChar(len);
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        for (i = 0; i < cElems; i++)
        {
            ULONG len = (stm.GetULong() * sizeof(WCHAR) + 3) & ~3;

            cb += len;
            stm.SkipWChar(len / sizeof(WCHAR));
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        for (i = 0; i < cElems; i++)
        {
            ULONG cbElem = 0;

            Status = CBaseStorageVariant::UnmarshalledSize(stm, cbElem);
            if (Status != STATUS_SUCCESS)
            {
               break;
            }
            cb += cbElem;
        }
        break;
    }
    return(Status);
}
#endif //ifdef KERNEL


//+-------------------------------------------------------------------
//  Member:    CBaseStorageVariant::Unmarshall, public
//
//  Synopsis:  Unmarshalls a PROPVARIANT value serialized in a PDeSerStream.
//
//  Arguments: [stm] -- serialized stream
//             [var] -- unmarshalled PROPVARIANT instance
//             [MemAlloc] -- memory allocator for unmarshalling
//
//  Returns:   one of the following NTSTATUS values
//             STATUS_SUCCESS -- the call was successful.
//             STATUS_INSUFFICIENT_RESOURCES -- out of memory.
//             STATUS_INVALID_PARAMETER -- unsupported type for unmarshalling.
//--------------------------------------------------------------------

NTSTATUS
CBaseStorageVariant::Unmarshall(
    PDeSerStream& stm,
    PROPVARIANT& var,
    PMemoryAllocator &MemAlloc)
{
#if DBG
    switch (stm.PeekULong())
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_CLSID:
    case VT_BLOB:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_VECTOR | VT_UI1:
    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
    case VT_VECTOR | VT_CLSID:
    case VT_VECTOR | VT_CF:
    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
    case VT_VECTOR | VT_VARIANT:
        break;

    default:
        PROPASSERT(!"Invalid type (peek) for PROPVARIANT unmarshalling");
        break;
    }
#endif

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbAlloc = 0;
    VOID **ppv = NULL;
    BOOLEAN fZero = FALSE;

    // Zero the entire variant data structure before assembling it together.
    memset(&var, 0, sizeof(PROPVARIANT));

    var.vt = (VARTYPE) stm.GetULong();

    switch (var.vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_UI1:
        var.bVal = stm.GetByte();
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        var.iVal = stm.GetUShort();
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        var.lVal = stm.GetULong();
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        stm.GetBlob((BYTE *)&var.hVal, sizeof(LARGE_INTEGER));
        break;

    case VT_CLSID:
        cbAlloc = sizeof(GUID);
        ppv = (void **)&var.puuid;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        var.blob.cbSize = stm.GetULong();
        cbAlloc = var.blob.cbSize;
        ppv = (void **)&var.blob.pBlobData;
        break;

    case VT_CF:
        var.pclipdata = (CLIPDATA *) MemAlloc.Allocate(sizeof(*var.pclipdata));
        if (var.pclipdata == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        var.pclipdata->cbSize = stm.GetULong();
        cbAlloc = CBPCLIPDATA(*var.pclipdata);
        var.pclipdata->ulClipFmt = stm.GetULong();
        ppv = (void **) &var.pclipdata->pClipData;
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
        PROPASSERT("Serialization of stream not yet supported!");
        Status = STATUS_INVALID_PARAMETER;
        break;

    case VT_STORAGE:
    case VT_STORED_OBJECT:
        PROPASSERT("Serialization of storage not yet supported!");
        Status = STATUS_INVALID_PARAMETER;
        break;

    case VT_BSTR:
        cbAlloc = sizeof(ULONG) + stm.GetULong();
        ppv = (void **)&var.bstrVal;
        break;

    case VT_LPSTR:
        cbAlloc = stm.GetULong();
        ppv = (void **)&var.pszVal;
        break;

    case VT_LPWSTR:
        cbAlloc = stm.GetULong() * sizeof(WCHAR);
        ppv = (void **)&var.pwszVal;
        break;

    case VT_VECTOR | VT_UI1:
        var.caub.cElems = stm.GetULong();
        cbAlloc = var.caub.cElems * sizeof(BYTE);
        ppv = (void **)&var.caub.pElems;
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        var.cai.cElems = stm.GetULong();
        cbAlloc = var.cai.cElems * sizeof(SHORT);
        ppv = (void **)&var.cai.pElems;
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        var.cal.cElems = stm.GetULong();
        cbAlloc = var.cal.cElems * sizeof(LONG);
        ppv = (void **)&var.cal.pElems;
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        var.cah.cElems = stm.GetULong();
        cbAlloc = var.cah.cElems * sizeof(LARGE_INTEGER);
        ppv = (void **)&var.cah.pElems;
        break;

    case VT_VECTOR | VT_CLSID:
        var.cauuid.cElems = stm.GetULong();
        cbAlloc = var.cauuid.cElems * sizeof(GUID);
        ppv = (void **)&var.cauuid.pElems;
        break;

    case VT_VECTOR | VT_CF:
        var.caclipdata.cElems = stm.GetULong();
        cbAlloc = var.caclipdata.cElems * sizeof(CLIPDATA);
        ppv = (void **)&var.caclipdata.pElems;
        fZero = TRUE;   // set all pClipData pointers to NULL
        break;

    case VT_VECTOR | VT_BSTR:
        var.cabstr.cElems = stm.GetULong();
        cbAlloc = var.cabstr.cElems * sizeof(BSTR);
        ppv = (void **)&var.cabstr.pElems;
        fZero = TRUE;   // set all BSTR pointers to NULL
        break;

    case VT_VECTOR | VT_LPSTR:
        var.calpstr.cElems = stm.GetULong();
        cbAlloc = var.calpstr.cElems * sizeof(LPSTR);
        ppv = (void **)&var.calpstr.pElems;
        fZero = TRUE;   // set all LPSTR pointers to NULL
        break;

    case VT_VECTOR | VT_LPWSTR:
        var.calpwstr.cElems = stm.GetULong();
        cbAlloc = var.calpwstr.cElems * sizeof(LPWSTR);
        ppv = (void **)&var.calpwstr.pElems;
        fZero = TRUE;   // set all LPWSTR pointers to NULL
        break;

    case VT_VECTOR | VT_VARIANT:
        var.capropvar.cElems = stm.GetULong();
        cbAlloc = var.capropvar.cElems * sizeof(PROPVARIANT);
        ppv = (void **)&var.capropvar.pElems;
        fZero = TRUE;   // set all vt pointers to VT_EMPTY
        PROPASSERT(VT_EMPTY == 0);
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT unmarshalling");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (cbAlloc == 0 || Status != STATUS_SUCCESS)
    {
        // No further work need be done. The Ummarshalling is complete,
        // i.e., fixed size variant or no variable length data.

        if (ppv != NULL)
        {
            *ppv = NULL;
        }
        return(Status);
    }

    // Allocate the desired amount of memory and continue unmarshalling
    // if allocation was successfull.

    ULONG i;

    PROPASSERT(ppv != NULL);
    *ppv = MemAlloc.Allocate(cbAlloc);

    if (*ppv == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    if (fZero)
    {
        memset(*ppv, 0, cbAlloc);
    }

    // We have a variant with variable sized data which requires
    // further unmarshalling.
    switch(var.vt)
    {
    case VT_CLSID:
        stm.GetBlob((BYTE *)var.puuid, sizeof(CLSID));
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        stm.GetBlob(var.blob.pBlobData, var.blob.cbSize);
        break;

    case VT_CF:
        stm.GetBlob(var.pclipdata->pClipData, CBPCLIPDATA(*var.pclipdata));
        break;

    case VT_BSTR:
        cbAlloc -= sizeof(ULONG);
        *(ULONG *) var.bstrVal = cbAlloc - sizeof (OLECHAR);
        var.bstrVal = (BSTR) ((ULONG *) var.bstrVal + 1);
        stm.GetChar((char *) var.bstrVal, cbAlloc);
        break;

    case VT_LPSTR:
        stm.GetChar(var.pszVal, cbAlloc);
        break;

    case VT_LPWSTR:
        stm.GetWChar(var.pwszVal, cbAlloc / sizeof(WCHAR));
        break;

    case VT_VECTOR | VT_UI1:
        for (i = 0; i < var.caub.cElems; i++)
        {
            var.caub.pElems[i] = stm.GetByte();
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        for (i = 0; i < var.cai.cElems; i++)
        {
            var.cai.pElems[i] = stm.GetUShort();
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        for (i = 0; i < var.cal.cElems; i++)
        {
            var.cal.pElems[i] = stm.GetULong();
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        for (i = 0; i < var.cah.cElems; i++)
        {
            stm.GetBlob((BYTE *)&var.cah.pElems[i], sizeof(LARGE_INTEGER));
        }
        break;

    case VT_VECTOR | VT_CLSID:
        for (i = 0; i < var.cauuid.cElems; i++)
        {
            stm.GetBlob((BYTE *)&var.cauuid.pElems[i], sizeof(CLSID));
        }
        break;

    case VT_VECTOR | VT_CF:
        for (i = 0; i < var.caclipdata.cElems; i++)
        {
            PROPASSERT(var.caclipdata.pElems[i].pClipData == NULL);
            var.caclipdata.pElems[i].cbSize = stm.GetULong();
            cbAlloc = CBPCLIPDATA(var.caclipdata.pElems[i]);
            var.caclipdata.pElems[i].ulClipFmt = stm.GetULong();
            if (cbAlloc == 0)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.caclipdata.pElems[i].pClipData =
                (BYTE *) MemAlloc.Allocate(cbAlloc);
            if (var.caclipdata.pElems[i].pClipData == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetBlob(var.caclipdata.pElems[i].pClipData, cbAlloc);
        }
        break;

    case VT_VECTOR | VT_BSTR:
        for (i = 0; i < var.cabstr.cElems; i++)
        {
            PROPASSERT(var.cabstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();
            if (cbAlloc == 0)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.cabstr.pElems[i] =
                (BSTR) MemAlloc.Allocate(sizeof(ULONG) + cbAlloc);
            if (var.cabstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            *(ULONG *) var.cabstr.pElems[i] = cbAlloc - sizeof (OLECHAR);
            var.cabstr.pElems[i] = (BSTR) ((ULONG *) var.cabstr.pElems[i] + 1);
            stm.GetChar((char *) var.cabstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        for (i = 0; i < var.calpstr.cElems; i++)
        {
            PROPASSERT(var.calpstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();
            if (cbAlloc == 0)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.calpstr.pElems[i] = (LPSTR) MemAlloc.Allocate(cbAlloc);
            if (var.calpstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetChar(var.calpstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        for (i = 0; i < var.calpwstr.cElems; i++)
        {
            PROPASSERT(var.calpwstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();   // actually, a count of WCHARs
            if (cbAlloc == 0)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.calpwstr.pElems[i] = (WCHAR *) MemAlloc.Allocate(cbAlloc * sizeof(WCHAR));
            if (var.calpwstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetWChar(var.calpwstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        for (i = 0; i < var.capropvar.cElems; i++)
        {
            PROPASSERT(var.capropvar.pElems[i].vt == VT_EMPTY);
            Status = CBaseStorageVariant::Unmarshall(
                                            stm,
                                            var.capropvar.pElems[i],
                                            MemAlloc);
            if (Status != STATUS_SUCCESS)
            {
               break;
            }
        }
        break;
    }
    return(Status);
}


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_CF(CLIPDATA *pclipdata, PSerStream &stm)
{
    CLIPDATA clipdata;

    clipdata.cbSize = 0;
    clipdata.ulClipFmt = 0;

    if (pclipdata != NULL)
    {
        clipdata.cbSize = pclipdata->cbSize;
        clipdata.ulClipFmt = pclipdata->ulClipFmt;
        if (pclipdata->pClipData == NULL)
        {
            clipdata.cbSize = 0;
        }
    }
    stm.PutULong(clipdata.cbSize);
    stm.PutULong(clipdata.ulClipFmt);
    if (clipdata.cbSize)
    {
        stm.PutBlob((BYTE *) pclipdata->pClipData, CBPCLIPDATA(clipdata));
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_BSTR(BSTR bstrVal, PSerStream &stm)
{
    if (bstrVal != NULL)
    {
        ULONG cc = BSTRLEN(bstrVal) + sizeof (OLECHAR);

        stm.PutULong(cc);
        stm.PutChar((char *) bstrVal, cc);
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_LPSTR(CHAR *pszVal, PSerStream &stm)
{
    if (pszVal != NULL)
    {
        // Include NULL because OLE 2.0 spec says so.
        ULONG cc = strlen(pszVal) + 1;

        stm.PutULong(cc);
        stm.PutChar(pszVal, cc);
        PROPASSERT(IsAnsiString(pszVal, cc));
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_LPWSTR(LPWSTR pwszVal, PSerStream &stm)
{
    if (pwszVal != NULL)
    {
        // Include NULL because OLE 2.0 spec says so.

        ULONG cc = Prop_wcslen(pwszVal) + 1;

        PROPASSERT(IsUnicodeString(pwszVal, cc * sizeof(WCHAR)));
        stm.PutULong(cc);
        stm.PutWChar(pwszVal, cc);
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
void
CBaseStorageVariant::Marshall(PSerStream & stm) const
{
    ULONG i;

    stm.PutULong(vt);

    switch (vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_UI1:
        stm.PutByte(bVal);
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        stm.PutUShort(iVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        stm.PutULong(lVal);
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        stm.PutBlob((BYTE *) &hVal, sizeof(hVal));
        break;

    case VT_CLSID:
        stm.PutBlob((BYTE *)puuid, sizeof(CLSID));
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        stm.PutULong(blob.cbSize);
        stm.PutBlob(blob.pBlobData, blob.cbSize);
        break;

    case VT_CF:
        _Marshall_VT_CF(pclipdata, stm);
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
        PROPASSERT("Serialization of stream not yet supported!");
        break;

    case VT_STORAGE:
    case VT_STORED_OBJECT:
        PROPASSERT("Serialization of storage not yet supported!");
        break;

    case VT_BSTR:
        _Marshall_VT_BSTR(bstrVal, stm);
        break;

    case VT_LPSTR:
        _Marshall_VT_LPSTR(pszVal, stm);
        break;

    case VT_LPWSTR:
        _Marshall_VT_LPWSTR(pwszVal, stm);
        break;

    case VT_VECTOR | VT_UI1:
        stm.PutULong(caub.cElems);
        for (i = 0; i < caub.cElems; i++)
        {
            stm.PutByte(caub.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        stm.PutULong(cai.cElems);
        for (i = 0; i < cai.cElems; i++)
        {
            stm.PutUShort(cai.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        stm.PutULong(cal.cElems);
        for (i = 0; i < cal.cElems; i++)
        {
            stm.PutULong(cal.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        stm.PutULong(cah.cElems);
        for (i = 0; i < cah.cElems; i++)
        {
            stm.PutBlob((BYTE *) &cah.pElems[i], sizeof(LARGE_INTEGER));
        }
        break;

    case VT_VECTOR | VT_CLSID:
        stm.PutULong(cauuid.cElems);
        for (i = 0; i < cauuid.cElems; i++)
        {
            stm.PutBlob((BYTE *)&cauuid.pElems[i], sizeof(CLSID));
        }
        break;

    case VT_VECTOR | VT_CF:
        stm.PutULong(caclipdata.cElems);
        for (i = 0; i < caclipdata.cElems; i++)
        {
            _Marshall_VT_CF(&caclipdata.pElems[i], stm);
        }
        break;
        break;

    case VT_VECTOR | VT_BSTR:
        stm.PutULong(cabstr.cElems);
        for (i = 0; i < cabstr.cElems; i++)
        {
            _Marshall_VT_BSTR(cabstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        stm.PutULong(calpstr.cElems);
        for (i = 0; i < calpstr.cElems; i++)
        {
            _Marshall_VT_LPSTR(calpstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        stm.PutULong(calpwstr.cElems);
        for (i = 0; i < calpwstr.cElems; i++)
        {
            _Marshall_VT_LPWSTR(calpwstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        stm.PutULong(capropvar.cElems);
        for (i = 0; i < capropvar.cElems; i++)
        {
            ((CBaseStorageVariant *) &capropvar.pElems[i])->Marshall(stm);
        }
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT marshalling");
        break;

    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef OLDSUMCATAPI
void
MarshallVariant(PSerStream &stm, PROPVARIANT &stgvar)
{
    CBaseStorageVariant *pstgvar = (CBaseStorageVariant *)&stgvar;
    pstgvar->Marshall(stm);
}
#endif //ifdef OLDSUMCATAPI


#ifdef ENABLE_DISPLAY_VARIANT
VOID
CBaseStorageVariant::DisplayVariant(
    ULONG ulLevel,
    USHORT CodePage) const
{
    char *psz;

    switch (vt)
    {
    case VT_ILLEGAL: psz = "ILLEGAL"; goto EmptyType;
    case VT_EMPTY:   psz = "EMPTY";   goto EmptyType;
    case VT_NULL:    psz = "NULL";    goto EmptyType;

BlobType:
EmptyType:
        DEBTRACE((DBGFLAG "%s", psz));
        break;

    case VT_UI1:
        AssertByteField(bVal);          // VT_UI1
        DEBTRACE((DBGFLAG "UI1=%hx", bVal));
        break;

    case VT_I2:  psz = "I2";  goto ShortType;
    case VT_UI2: psz = "UI2"; goto ShortType;

ShortType:
        AssertShortField(iVal);                 // VT_I2
        AssertShortField(uiVal);                // VT_UI2
        DEBTRACE((DBGFLAG "%s=%hx", psz, iVal));
        break;

    case VT_BOOL:
        switch (boolVal)
        {
            case VARIANT_TRUE:
                DEBTRACE((DBGFLAG "BOOL=TRUE"));
                break;

            case FALSE:
                DEBTRACE((DBGFLAG "BOOL=FALSE"));
                break;

            default:
                DEBTRACE((DBGFLAG "BOOL=%hx???", boolVal));
                break;
        }
        break;

    case VT_I4:    psz = "I4";    goto LongType;
    case VT_UI4:   psz = "UI4";   goto LongType;
    case VT_R4:    psz = "R4";    goto LongType;
    case VT_ERROR: psz = "ERROR"; goto LongType;

LongType:
        AssertLongField(lVal);                  // VT_I4
        AssertLongField(ulVal);                 // VT_UI4
        AssertLongField(fltVal);                // VT_R4
        AssertLongField(scode);                 // VT_ERROR
        DEBTRACE((DBGFLAG "%s=%x", psz, lVal));
        break;

    case VT_I8:       psz = "I8";       goto LongLongType;
    case VT_UI8:      psz = "UI8";      goto LongLongType;
    case VT_R8:       psz = "R8";       goto LongLongType;
    case VT_CY:       psz = "CY";       goto LongLongType;
    case VT_DATE:     psz = "DATE";     goto LongLongType;
    case VT_FILETIME: psz = "FILETIME"; goto LongLongType;

LongLongType:
        AssertLongLongField(hVal);              // VT_I8
        AssertLongLongField(uhVal);             // VT_UI8
        AssertLongLongField(dblVal);            // VT_R8
        AssertLongLongField(cyVal);             // VT_CY
        AssertLongLongField(date);              // VT_DATE
        AssertLongLongField(filetime);          // VT_FILETIME
        DEBTRACE((DBGFLAG "%s=%x:%x", psz, hVal.HighPart, hVal.LowPart));
        break;

    case VT_CLSID: psz = "CLSID"; goto EmptyType;

    case VT_BLOB:        psz = "BLOB";        goto BlobType;
    case VT_BLOB_OBJECT: psz = "BLOB_OBJECT"; goto BlobType;
    case VT_CF:          psz = "CF";          goto BlobType;

    case VT_STREAM:          psz = "STREAM";          goto TestUnicode;
    case VT_STREAMED_OBJECT: psz = "STREAMED_OBJECT"; goto TestUnicode;
    case VT_STORAGE:         psz = "STORAGE";         goto TestUnicode;
    case VT_STORED_OBJECT:   psz = "STORED_OBJECT";   goto TestUnicode;
    case VT_LPSTR:           psz = "LPSTR";           goto TestUnicode;

TestUnicode:
        AssertStringField(pszVal);              // VT_STREAM, VT_STREAMED_OBJECT
        AssertStringField(pszVal);              // VT_STORAGE, VT_STORED_OBJECT
        AssertStringField(pszVal);              // VT_LPSTR
        DEBTRACE((
            DBGFLAG
            CodePage == CP_WINUNICODE? "%s=L'%ws'" : "%s='%s'",
            psz,
            pszVal));
        break;

    case VT_BSTR:            psz = "BSTR";            goto PrintUnicode;
    case VT_LPWSTR:          psz = "LPWSTR";          goto PrintUnicode;

PrintUnicode:
        AssertStringField(pwszVal);             // VT_LPWSTR
        AssertStringField(bstrVal);             // VT_BSTR
        DEBTRACE((DBGFLAG "%s=L'%ws'", psz, pwszVal));
        break;

    default:
        if (vt & VT_VECTOR)
        {
            DEBTRACE((DBGFLAG "UNPRINTABLE VECTOR TYPE=%x(%u)", vt, vt));
        }
        else
        {
            DEBTRACE((DBGFLAG "UNKNOWN TYPE=%x(%u)", vt, vt));
        }
        break;

    }
}
#endif //ifdef ENABLE_DISPLAY_VARIANT

#endif //ifdef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\propstm.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        propstm.cxx
//
// Contents:    property set value extraction code
//
// History:     15-Jul-94       brianb  created
//              12-Aug-94       SethuR  Included Assertions for # of sections
//                                      split PropertySet class into
//                                      CPropertySetStream & CPropertySetStorage
//                                      Included Update methods on the property
//                                      stream.
//              22-Feb-96      MikeHill DWORD-align the dictionary entries,
//                                      & use char-counts for dict entries.
//              29-Feb-96      MikeHill Moved _DictionaryEntryLength and _NextDictionaryEntry
//                                      inlines here from propstm.hxx.
//              09-May-96      MikeHill - Keep the dictionary in the UserDef propset
//                                        immediately after the last entry in the PID/Offset
//                                        array (for Office95 compatibility).
//                                      - Create an empty dictionary in the UD propset
//                                        when it is created.  If we wait till later,
//                                        we can't make the dictionary the first property,
//                                        which is required by Office95.
//                                      - Provide compatibility with Publisher95 (which doesn't
//                                        DWORD-align the section/stream size).
//                                      - Provide compatibility with PowerPoint 4.0 (which
//                                        over-pads some properties, and under-pads others).
//                                      - Don't try to unpack the DocParts and HeadingPair
//                                        DocSumInfo properties in Ansi property sets.
//              22-May-96      MikeHill - Return the OSVersion on an Open.
//                                      - Use the PropSet's code page, not the system's.
//              11-Jun-96      MikeHill - Initialize all members in the constructor.
//              25-Jul-96      MikeHill - Removed usage of Win32 SEH.
//                                      - BSTRs & prop names: WCHAR => OLECHAR.
//                                      - Added big-endian support.
//                                      - Determine the OSVer at run-time.
//                                      - Fix for Excel 5.0a compatibility.
//              26-Nov-96      MikeHill Handle invalid oSection values.
//              10-Mar-98      MikeHill - Change "Pr" functions to "Stg".
//                                      - Added asserts for new VTs.
//              06-May-98      MikeHill - Use CoTaskMem rather than new(k)/delete
//                                      - Removed usage of UnicodeCallouts.
//              18-May-98      MikeHIll - Fixed typos.
//              11-June-98     MikeHill - Dbg output.
//                                      - Allow codepage & lcid to be changed
//                                        if property set is empty.
//                                      - Validate pid_behavior in property set.
//                                      - Silently ignore PID_ILLEGAL in SetPropertyNames.
//              18-Aug-98      MikeHill - Make reserved range 0x80000000 to 0x8c000000
//                                        read-only unless the property is understood.
//
// Notes:
//
// The OLE 2.0 Appendix B property set specifies multiple sections in the
// property stream specification.  Multiple sections were intended to allow
// the schema associated with the property set to evolve over a period of time,
// but there is no reason that new PROPIDs cannot serve the same purpose.  The
// current implementation of the property stream is limited to one section,
// except for the Office DocumentSummaryInformation property set's specific use
// of a second section.  Other property sets with multiple sections can only be
// accessed in read-only mode, and then only for the first property section.
//
// The current implementation of property set stream is built around a class
// called CPropertySetStream.  The various details of the OLE property spec is
// confined to this class.  Since the property set streams need to be parsed
// in the kernel mode (OFS driver) as well as the user mode, this class
// encapsulates a stream implementation (IMappedStream).  This is different
// from other stream implementations in that the fundamental mechanism provided
// for acessing the contents is Map/Unmap rather than Read/Write.  There are
// two user mode implementations of this IMappedStream interface, one for
// docfile streams, and another for native streams.  There is one
// implementation in kernel mode for the OFS driver.  For more details,
// refer to propstm.hxx.
//---------------------------------------------------------------------------

#include <pch.cxx>

#include <olechar.h>

#if DBGPROP
#include <stdio.h>      // for sprintf/strcpy
#endif
#include "propvar.h"


#define Dbg     DEBTRACE_PROPERTY

#define szX     "x"     // allows radix change for offsets & sizes
//#define szX   "d"     // allows radix change for offsets & sizes

#ifndef newk
#define newk(Tag, pCounter)     new
#endif

#ifndef IsDwordAligned
#define IsDwordAligned(p)       (( (p) & (sizeof(ULONG) - 1)) == 0)
#endif

#ifndef DwordRemain
#define DwordRemain(cb) \
        ((sizeof(ULONG) - ((cb) % sizeof(ULONG))) % sizeof(ULONG))
#endif


// Information for the the OS Version field of the
// property set header.

#if defined(WINNT) && !defined(IPROPERTY_DLL)
#   define PROPSETVER_CURRENT MAKEPSVER(OSKIND_WIN32, WINVER >> 8, WINVER & 0xff)
#endif

#define PROPSETVER_WIN310  MAKEPSVER(OSKIND_WINDOWS, 3, 10)
#define PROPSETVER_WIN333  MAKEPSVER(OSKIND_WIN32, 3, 0x33)



extern GUID guidSummary;
extern GUID guidDocumentSummary;
extern GUID guidDocumentSummarySection2;

#define CP_DEFAULT_NONUNICODE   1252 // ANSI Latin1 (US, Western Europe)
#define CP_CREATEDEFAULT(state)	GetACP()
#define LCID_CREATEDEFAULT GetUserDefaultLCID()

#if DBGPROP
#define StatusCorruption(pstatus, szReason)             \
            _StatusCorruption(szReason " ", pstatus)
#else
#define StatusCorruption(pstatus, szReason)             \
            _StatusCorruption(pstatus)
#endif


VOID PrpConvertToUnicode(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus);
VOID PrpConvertToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus);



//
// Re-direct PrEqual[Unicode]String routines
//
// These macros redirect two NTDLL routines which don't exist in
// the IProperty DLL.  They are redirected to CRT calls.
//
// Note:  These redirections assume that the Length and
// MaximumLength fields, on both String structures, are the
// same (e.g. s1.len == s1.maxlen == s2.len == s2.maxlen).
//

#ifdef IPROPERTY_DLL

#error Need to replace the icmp routines with CharUpper-based code for correct locale ID

    #define RtlEqualString(String1,String2,fCaseInSensitive)    \
        fCaseInSensitive                                        \
            ? ( !_strnicmp( (String1)->Buffer,                  \
                            (String2)->Buffer,                  \
                            (String1)->MaximumLength) )         \
            : ( !strncmp(   (String1)->Buffer,                  \
                            (String2)->Buffer,                  \
                            (String1)->MaximumLength) )

    #define RtlEqualUnicodeString(String1,String2,fCaseInSensitive)         \
        fCaseInSensitive                                                    \
            ? ( !_wcsnicmp( (String1)->Buffer,                              \
                            (String2)->Buffer,                              \
                            (String1)->MaximumLength / sizeof(WCHAR) ))     \
            : ( !wcsncmp(   (String1)->Buffer,                              \
                            (String2)->Buffer,                              \
                            (String1)->MaximumLength / sizeof(WCHAR) ))

#endif  // #ifdef IPROPERTY_DLL


#if DBGPROP

#define CB_VALUEDISPLAY 8       // Number of bytes to display
#define CB_VALUESTRING  (CB_VALUEDISPLAY * 3 + 3)       // "xx xx xx xx...\0"

char *
ValueToString(SERIALIZEDPROPERTYVALUE const *pprop, ULONG cbprop, char buf[])
{
    char *p = buf;
    BYTE const *pb = pprop->rgb;
    BOOLEAN fOverflow = FALSE;
    static char szDots[] = "...";

    if (cbprop >= FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb))
    {
        cbprop -= FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb);
        if (cbprop > CB_VALUEDISPLAY)
        {
            cbprop = CB_VALUEDISPLAY;
            fOverflow = TRUE;
        }
        while (cbprop-- > 0)
        {
            if (p != buf)
            {
                *p++ = ' ';
            }
            p += PropSprintfA( p, "%02.2x", *pb++ );
        }
    }
    *p =  '\0';
    PROPASSERT(p - buf + sizeof(szDots) <= CB_VALUESTRING);
    if (fOverflow)
    {
        strcpy(p, szDots);
    }
    return(buf);
}


#define CB_VARIANT_TO_STRING 35

char *
VariantToString(PROPVARIANT const &var, char buf[], ULONG cbprop)
{
    char *p = buf;

    PROPASSERT( cbprop >= CB_VARIANT_TO_STRING );


    // Add the VT to the output buffer.

    p += PropSprintfA( p, "vt=%04.4x", var.vt );
    p += PropSprintfA( p, ", val=(%08.8x, %08.8x)", var.uhVal.LowPart, var.uhVal.HighPart );

    *p =  '\0';
    PROPASSERT( (p - buf) == CB_VARIANT_TO_STRING);
    return(buf);
}

#endif


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DictionaryEntryLength
//
// Synopsis:    Calculate the length of an entry in the
//              dictionary.  This is non-trivial because
//              it is codepage-dependent.
//
// Arguments:   [pent] -- pointer to a dictionary entry.
//
// Returns:     The entry's length.
//+--------------------------------------------------------------------------


inline ULONG
CPropertySetStream::_DictionaryEntryLength(
    IN ENTRY UNALIGNED const * pent
    ) const
{
    ULONG ulSize ;

    // If this is a Unicode property set, it should be DWORD-aligned.
    PROPASSERT( _CodePage != CP_WINUNICODE
                ||
                IsDwordAligned( (ULONG_PTR)pent ));

    // The size consists of the length of the
    // PROPID and character count ...

    ulSize = CB_DICTIONARY_ENTRY;

    // Plus the length of the string ...

    ulSize += PropByteSwap( pent->cch )
              *
              (_CodePage == CP_WINUNICODE ? sizeof( WCHAR ) : sizeof( CHAR ));

    // Plus, possibly, padding to make the entry DWORD-aligned
    // (for Unicode property sets).

    if( _CodePage == CP_WINUNICODE )
    {
        ulSize = DwordAlign( ulSize );
    }

    return( ulSize );

}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_NextDictionaryEntry
//
// Synopsis:    Given a pointer to an entry in the dictionary,
//              create a pointer to the next entry.
//
// Arguments:   [pent] -- pointer to a dictionary entry.
//
// Returns:     Pointer to the next entry.  If the input
//              points to the last entry in the dictionary,
//              then return a pointer to just beyond the
//              end of the dictionary.
//+--------------------------------------------------------------------------


inline ENTRY UNALIGNED *
CPropertySetStream::_NextDictionaryEntry(
    IN ENTRY UNALIGNED const * pent
    ) const
{

    return (ENTRY UNALIGNED *)
           Add2Ptr( pent, _DictionaryEntryLength( pent ));

}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_SignalCorruption
//
// Synopsis:    possibly PROPASSERT and return data corrupt error
//
// Arguments:   [szReason]              -- string explanation (DBGPROP only)
//              [pstatus]               -- NTSTATUS code.
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_StatusCorruption(
#if DBGPROP
    char *szReason,
#endif
    OUT NTSTATUS *pstatus
    ) const
{
#if DBGPROP

    propDbg(( DEB_ERROR,
                "_StatusCorruption(%s, psstm=%lx, mapstm=%lx, flags=%x)\n",
                szReason, this, _pmstm, _Flags));
#endif

    *pstatus = STATUS_INTERNAL_DB_CORRUPTION;
    return;
}


//+--------------------------------------------------------------------------
// Function:    _PropMoveMemory
//
// Synopsis:    call DebugTrace and RtlMoveMemory
//
// Arguments:   [pszReason]             -- string explanation (Debug only)
//              [pvSection]             -- base of section (Debug only)
//              [pvDst]                 -- destination
//              [pvSrc]                 -- source
//              [cbMove]                -- byte count to move
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
#define PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove) \
        _PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove)
#else
#define PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove) \
        _PropMoveMemory(pvDst, pvSrc, cbMove)
#endif

inline VOID
_PropMoveMemory(
#if DBGPROP
    char *pszReason,
    VOID *pvSection,
#endif
    VOID *pvDst,
    VOID const UNALIGNED *pvSrc,
    ULONG cbMove)
{
    propDbg(( DEB_ITRACE,
              "%s: Moving Dst=%lx(%l" szX ") Src=%lx(%l" szX ") Size=%l" szX "\n",
              pszReason, pvDst,
              (BYTE *) pvDst - (BYTE *) pvSection,
              pvSrc,
              (BYTE *) pvSrc - (BYTE *) pvSection,
              cbMove));

    RtlMoveMemory(pvDst, pvSrc, cbMove);
}


inline BOOLEAN
IsReadOnlyPropertySet(BYTE flags, BYTE state)
{
    return(
	(flags & CREATEPROP_MODEMASK) == CREATEPROP_READ ||
	(state & CPSS_USERDEFINEDDELETED) ||
	(state & (CPSS_MULTIPLESECTIONS | CPSS_DOCUMENTSUMMARYINFO)) ==
	    CPSS_MULTIPLESECTIONS);
}


inline BOOLEAN
IsLocalizationPropid(PROPID pid)
{
    return(
        PID_CODEPAGE == pid
        ||
        PID_LOCALE == pid
     );
}


inline BOOLEAN
IsReadOnlyPropid(PROPID pid)
{
    return(
        pid == PID_DICTIONARY ||
        pid == PID_MODIFY_TIME ||
        pid == PID_SECURITY ||
        pid == PID_BEHAVIOR ||
        IsLocalizationPropid(pid) ||
        ( PID_MIN_READONLY <= pid
          &&
          PID_MAX_READONLY >= pid
        )
      );
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::CStreamChunkList
//
// Synopsis:    constructor
//
// Arguments:   [cChunks]               -- count of chunks that will be needed
//
// Returns:     None
//+--------------------------------------------------------------------------

CStreamChunkList::CStreamChunkList(
    ULONG cChunks,
    CStreamChunk *ascnk) :
    _cMaxChunks(cChunks),
    _cChunks(0),
    _ascnk(ascnk),
    _fDelete(FALSE)
{
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::Delete
//
// Synopsis:    destructor
//
// Arguments:   None
//
// Returns:     None
//+--------------------------------------------------------------------------

inline
VOID
CStreamChunkList::Delete(VOID)
{
    if (_fDelete)
    {
        CoTaskMemFree( _ascnk );
    }
#if DBGPROP
    _cMaxChunks = _cChunks = 0;
    _ascnk = NULL;
    _fDelete = FALSE;
#endif
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::GetChunk
//
// Synopsis:    retrieves a chunk given the index
//
// Arguments:   [i]          -- index of the chunk to retrieve
//
// Returns:     specified chunk pointer
//+--------------------------------------------------------------------------

inline
CStreamChunk const *
CStreamChunkList::GetChunk(ULONG i) const
{
    PROPASSERT(i < _cChunks);
    PROPASSERT(i < _cMaxChunks);
    PROPASSERT(_ascnk != NULL);
    return(&_ascnk[i]);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::Count
//
// Synopsis:    returns the count of chunks
//
// Arguments:   None
//
// Returns:    the number of chunks.
//+--------------------------------------------------------------------------

inline ULONG
CStreamChunkList::Count(VOID) const
{
    return(_cChunks);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::GetFreeChunk
//
// Synopsis:    gets a unused chunk descriptor
//
// Arguments:   [pstatus]   -- NTSTATUS code
//
// Returns:     a ptr to a stream chunk descriptor.
//              This will be NULL if there was an
//              error.
//+--------------------------------------------------------------------------

CStreamChunk *
CStreamChunkList::GetFreeChunk(OUT NTSTATUS *pstatus)
{
    CStreamChunk *pscnk = NULL;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_cChunks < _cMaxChunks);
    if (_ascnk == NULL)
    {
        PROPASSERT(_cChunks == 0);
        _ascnk = new CStreamChunk[_cMaxChunks];
        if (_ascnk == NULL)
        {
            StatusNoMemory(pstatus, "GetFreeChunk");
            goto Exit;
        }
        _fDelete = TRUE;
    }

    pscnk = &_ascnk[_cChunks++];

    //  ----
    //  Exit
    //  ----

Exit:

    return( pscnk );
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::AssertCbChangeTotal
//
// Synopsis:    make sure the computed cbChangeTotal is correct for the chunk
//
// Arguments:   None
//
// Returns:     Nothing
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CStreamChunkList::AssertCbChangeTotal(
    CStreamChunk const *pscnk,
    ULONG cbChangeTotal) const
{
    ULONG cb = 0;
    ULONG i;

    for (i = 0; i < Count(); i++)
    {
        CStreamChunk const *pscnkT = GetChunk(i);

        cb += pscnkT->cbChange;
        if (pscnk == pscnkT)
        {
            PROPASSERT(cb == cbChangeTotal);
            return;
        }
    }
    PROPASSERT(i < Count());
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnChunkCompare
//
// Synopsis:    qsort helper to compare chunks in the chunk list.
//
// Arguments:   [pscnk1]        -- pointer to chunk1
//              [pscnk2]        -- pointer to chunk2
//
// Returns:     difference
//+--------------------------------------------------------------------------

int __cdecl
fnChunkCompare(VOID const *pscnk1, VOID const *pscnk2)
{
    return(((CStreamChunk const *) pscnk1)->oOld -
           ((CStreamChunk const *) pscnk2)->oOld);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::SortByStartAddress
//
// Synopsis:    sort all the chunks that are being modified in a stream in the
//              ascending order.
//
// Arguments:   None
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CStreamChunkList::SortByStartAddress(VOID)
{
    DebugTrace(0, Dbg, ("Sorting %l" szX " Chunks @%lx\n", _cChunks, _ascnk));

    qsort(_ascnk, _cChunks, sizeof(_ascnk[0]), &fnChunkCompare);

#if DBGPROP
    LONG cbChangeTotal;
    ULONG i;

    cbChangeTotal = 0;
    for (i = 0; i < _cChunks; i++)
    {
        cbChangeTotal += _ascnk[i].cbChange;

        DebugTrace(0, Dbg, (
            "Chunk[%l" szX "] oOld=%l" szX " cbChange=%s%l" szX
                " cbChangeTotal=%s%l" szX "\n",
            i,
            _ascnk[i].oOld,
            _ascnk[i].cbChange < 0? "-" : "",
            _ascnk[i].cbChange < 0? -_ascnk[i].cbChange : _ascnk[i].cbChange,
            cbChangeTotal < 0? "-" : "",
            cbChangeTotal < 0? -cbChangeTotal : cbChangeTotal));
    }
#endif
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetFormatidOffset
//
// Synopsis:    Get a pointer to the (first) section header
//
// Arguments:   None
//
// Returns:     pointer to section header
//+--------------------------------------------------------------------------

inline FORMATIDOFFSET *
CPropertySetStream::_GetFormatidOffset(ULONG iSection) const
{
    return(&((FORMATIDOFFSET *) Add2Ptr(_pph, sizeof(*_pph)))[iSection]);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetSectionHeader
//
// Synopsis:    Get a pointer to the (first) section header
//
// Arguments:   None
//
// Returns:     pointer to section header
//+--------------------------------------------------------------------------

inline PROPERTYSECTIONHEADER *
CPropertySetStream::_GetSectionHeader(VOID) const
{
    return((PROPERTYSECTIONHEADER *) Add2Ptr(_pph, _oSection));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetSectionHeader
//
// Synopsis:    Get a pointer to the specified section header
//
// Arguments:   [iSection]      -- section number (zero-relative)
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     pointer to specified section header
//+--------------------------------------------------------------------------

PROPERTYSECTIONHEADER *
CPropertySetStream::_GetSectionHeader(ULONG iSection, OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;
    PROPERTYSECTIONHEADER *psh = NULL;

    ULONG oSection = 0;                 // Assume no header
    ULONG cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Don't assume *any* class variables (except _pph) are loaded yet!

    PROPASSERT(iSection < _pph->reserved );

    // Get the section offset, after verifying that we can read all
    // of the FmtID/Offset table.

    if (cbstm >= CB_PROPERTYSETHEADER + (iSection + 1) * CB_FORMATIDOFFSET)
        oSection = _GetFormatidOffset(iSection)->dwOffset;
    else
        StatusCorruption (pstatus, "GetSectionHeader(i):  stream size too short to read section offset");

    // Create a pointer to the section header, after verifying that we can
    // read all of the section header.  We don't verify that we can actually
    // read the whole section (using cbSection), the caller must be responsible
    // for this.

    // We have to check oSection first, then oSection+cb_psh, because oSection
    // could be a negative number (such as 0xffffffff), so adding it to cb_psh
    // could make it look valid.

    if (cbstm >= oSection
        &&
        cbstm >= oSection + CB_PROPERTYSECTIONHEADER)
    {
        psh = (PROPERTYSECTIONHEADER *) Add2Ptr(_pph, oSection);
    }
    else
        StatusCorruption (pstatus, "GetSectionHeader(i):  stream size too short to read section header");

    // Finally, ensure that the section is 32 bit aligned.  We handle several
    // compatibility problems in the _Fix* routines, but not a misaligned
    // section header.

    if( !IsDwordAligned( (ULONG_PTR) psh ))
        StatusCorruption( pstatus, "GetSectionHeader(i):  section header is misaligned" );


    //  ----
    //  Exit
    //  ----

Exit:

    return(psh);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_SearchForCodePage, private
//
// Synopsis:    Searches a section of a property set for the code page,
//              LCID, and Behavior properties.
//
//              This routine searches for these special properties by iterating
//              through the PID/Offset array in search of
//              PID_CODEPAGE, PID_BEHAVIOR, and PID_LOCALE.  The difference between calling
//              this routine, and calling GetValue(PID_CODEPAGE),
//              is that this routine does not assume that the
//              property set is formatted correctly; it only assumes
//              that the PID/Offset array is correct.
//
//              Note that this routine is like a specialized _LoadProperty(),
//              the important difference is that this routine must use
//              unaligned pointers, since it cannot assume that the
//              property set is aligned properly.
//
// Pre-Conditions:
//              The PID/Offset array is correct.
//              &&
//              _oSection & _cSection are set correctly.
//
// Post-Conditions:
//              If PID_CODEPAGE/PID_BEHAVIOR exist, they are put
//                  into _CodePage/_grfBehavior.
//              If either doesn't exist, the corresponding member
//                  variable is left unchanged.
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Notes:       We do *not* assume that the property set's
//              cbSection field is valid (this was added to handle a
//              special-case compatibility problem).
//
// Returns:     None.
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_SearchForCodePage( OUT NTSTATUS *pstatus )
{

    PROPERTYSECTIONHEADER UNALIGNED *psh;
    PROPERTYIDOFFSET UNALIGNED      *ppo;
    PROPERTYIDOFFSET UNALIGNED      *ppoMax;

    BOOL fCodePageFound = FALSE;
    BOOL fBehaviorFound = FALSE;
    BOOL fLocaleFound = FALSE;
    ULONG cbstm;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_SearchForCodePage" );

    *pstatus = STATUS_SUCCESS;

    // Verify the pre-conditions.

    PROPASSERT( _oSection != 0 );
    PROPASSERT( _cSection != 0 );

    // It's invalid to call any function on a deleted
    // DocSumInfo user-defined (section section) section.

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "GetValue: deleted");
        goto Exit;
    }

    // Get the section's header.

    psh = _GetSectionHeader();

    // Ensure that we can at least read the section header and
    // PID/Offset table.

    cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER
        ||
        cbstm < _oSection + CB_PROPERTYSECTIONHEADER
                + psh->cProperties * CB_PROPERTYIDOFFSET
       )
    {
        StatusCorruption(pstatus, "_SearchForCodePage: stream too short to read section header");
        goto Exit;
    }

    // Calculate the first & last PID/Offset pointers.
    // We can't use _LoadPropertyOffsetPointers, because it assumes
    // alignment.

    ppo = psh->rgprop;
    ppoMax = psh->rgprop + psh->cProperties;

    // Search the PID/Offset array for PID_CODEPAGE & PID_BEHAVIOR

    for ( ; ppo < ppoMax; ppo++)
    {
        if( PID_CODEPAGE == ppo->propid
            || PID_BEHAVIOR == ppo->propid
            || PID_LOCALE == ppo->propid )
        {
            SERIALIZEDPROPERTYVALUE UNALIGNED *pprop;

            // Get the real address of serialized property.

            pprop = (SERIALIZEDPROPERTYVALUE *)
                    _MapOffsetToAddress( ppo->dwOffset );

            // Check for corruption.  Both properties are <= DWORD in size

            if ( cbstm < (_oSection + ppo->dwOffset + CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD)) )
            {
                StatusCorruption(pstatus, "_SearchForCodePage");
                goto Exit;
            }

            if( PID_CODEPAGE == ppo->propid )
            {
                if( VT_I2 != PropByteSwap(pprop->dwType) )
                {
                    StatusCorruption(pstatus, "_SearchForCodePage");
                    goto Exit;
                }

                fCodePageFound = TRUE;
                _CodePage = PropByteSwap( *reinterpret_cast<UNALIGNED SHORT *>(&pprop->rgb) );
            }
            else if( PID_BEHAVIOR == ppo->propid )
            {
                if( VT_UI4 != PropByteSwap(pprop->dwType) )
                {
                    StatusCorruption(pstatus, "_SearchForCodePage");
                    goto Exit;
                }

                fBehaviorFound = TRUE;
                _grfBehavior = PropByteSwap( *reinterpret_cast<UNALIGNED DWORD *>(&pprop->rgb) );
            }
            else if( PID_LOCALE == ppo->propid )
            {
                if( VT_UI4 != PropByteSwap(pprop->dwType) )
                {
                    StatusCorruption( pstatus, "_SearchForCodePage");
                    goto Exit;
                }

                fLocaleFound = TRUE;
                _Locale = PropByteSwap( *reinterpret_cast<UNALIGNED DWORD *>(&pprop->rgb) );
            }

            if( fCodePageFound && fBehaviorFound && fLocaleFound )
                break;

        }   // if( PID_CODEPAGE == ppo->propid || PID_BEHAVIOR == ppo->propid )
    }   // for ( ; ppo < ppoMax; ppo++)

    //  ----
    //  Exit
    //  ----

Exit:

    propDbg(( DEB_ITRACE, "CodePage=0x%x, Behavior=0x%x",
              _CodePage, _grfBehavior ));

    return;

}   // CPropertySetStream::_SearchForCodePage()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapOffsetToAddress, private
//
// Synopsis:    maps an offset to an address
//
// Arguments:   [Offset]        -- the offset in the section
//
// Returns:     ptr to the offset mapped
//+--------------------------------------------------------------------------

inline VOID *
CPropertySetStream::_MapOffsetToAddress(ULONG Offset) const
{
    PROPASSERT(_cSection != 0);

    return(Add2Ptr(_GetSectionHeader(), Offset));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAddressToOffset, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [pvAddr]        -- the address in the section
//
// Returns:     section-relative offset for passed pointer
//+--------------------------------------------------------------------------

inline ULONG
CPropertySetStream::_MapAddressToOffset(VOID const *pvAddr) const
{
    PROPASSERT(_cSection != 0);

    // Get a ptr to the section header.
    VOID const *pvSectionHeader = _GetSectionHeader();

    PROPASSERT((BYTE const *) pvAddr >= (BYTE const *) pvSectionHeader);
    return (ULONG)((BYTE const *) pvAddr - (BYTE const *) pvSectionHeader);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAbsOffsetToAddress, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [oAbsolute]      -- the absolute offset
//
// Returns:     a ptr to the offset mapped
//+--------------------------------------------------------------------------

inline VOID *
CPropertySetStream::_MapAbsOffsetToAddress(ULONG oAbsolute) const
{
    return(Add2Ptr(_pph, oAbsolute));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAddressToAbsOffset, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [pvAddr]        -- the address
//
// Returns:     the absolute offset
//+--------------------------------------------------------------------------

inline ULONG
CPropertySetStream::_MapAddressToAbsOffset(VOID const *pvAddr) const
{
    PROPASSERT((BYTE const *) pvAddr >= (BYTE *) _pph);
    return (ULONG) ((BYTE const *) pvAddr - (BYTE *) _pph);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::CPropertySetStream
//
// Synopsis:    constructor for property set class
//
// Arguments:UK [Flags] -- NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
//            K [pscb]          -- SCB for property stream
//            K [pirpc]         -- pointer to Irp Context
//            K [State]         -- CPSS_PROPHEADER
//           U  [pmstm]         -- mapped stream implementation
//           U  [pma]           -- caller's memory allocator
//
// Returns:     None
//---------------------------------------------------------------------------

CPropertySetStream::CPropertySetStream(
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    IN IMappedStream *pmstm,    // mapped stream impelementation
    IN PMemoryAllocator *pma    // caller's memory allocator
    ) :
        _Flags((BYTE) Flags),
        _State(0),
        _pmstm(pmstm),
        _pma(pma),
        _pph(NULL)
{
    // GetACP returns a UINT, but the property set only holds a USHORT.
    PROPASSERT( USHRT_MAX >= CP_CREATEDEFAULT(_State) );

    _CodePage = (USHORT)CP_CREATEDEFAULT(_State); // Default if not present
    _Locale =  LCID_CREATEDEFAULT;                // Default if not present

    PROPASSERT(_Flags == Flags);                // Should fit in a byte

    _oSection = 0;
    _cSection = 0;
    _cbTail   = 0;
    _grfBehavior = 0;

}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Close
//
// Synopsis:    shutdown property set prior to calling destructor
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None
//
// Notes:       This method does *not* require that _pph be valid,
//              since it makes no use of it.  If it were required, then
//              we would have to call ReOpen, which would be a waste
//              since we're closing down anyway.
//
//---------------------------------------------------------------------------

VOID
CPropertySetStream::Close(OUT NTSTATUS *pstatus)
{
    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::Close" );

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(
        (_Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ ||
        !IsModified());

    _MSTM(Close)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Open
//
// Synopsis:    Open property set image
//
// Arguments:   None
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::Open(
    IN GUID const *pfmtid,	    // property set fmtid
    OPTIONAL IN GUID const *pclsid, // CLASSID of propset code (create only)
    IN ULONG LocaleId,		    // Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion, // OS Version from header
    IN USHORT CodePage,             // CodePage of property set (create only)
    IN DWORD grfBehavior,   // PROPSET_BEHAVIOR_*
    OUT NTSTATUS *pstatus
    )
{
    *pstatus = STATUS_SUCCESS;
    LOADSTATE LoadState;
    PROPASSERT(!_IsMapped());

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::Open" );
    propTraceParameters(( "pfmtid=%p, pclsid=%p, LocaleId=%d, pOSVersion=%p, CodePage=%d, grfBehavior=0x%x",
                           pfmtid,    pclsid,    LocaleId,    pOSVersion,    CodePage,    grfBehavior ));

    if( pOSVersion != NULL )
        *pOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

    // Open the underlying stream which holds the property set.
    // We give it a callback pointer so that it can call
    // PrOnMappedStreamEvent.

    _MSTM(Open)(this, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Load the header, including fixing the in-memory image of
    // poorly-formatted property sets.

    LoadState = _LoadHeader(pfmtid, _Flags & CREATEPROP_MODEMASK, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (LoadState != LOADSTATE_DONE)
    {
	switch (_Flags & CREATEPROP_MODEMASK)
	{
	    case CREATEPROP_READ:
	    case CREATEPROP_WRITE:
    		if (LoadState == LOADSTATE_FAIL)
		{
		    StatusCorruption(pstatus, "Open: _LoadHeader");
                    goto Exit;
		}
		PROPASSERT(
		    LoadState == LOADSTATE_BADFMTID ||
		    LoadState == LOADSTATE_USERDEFINEDNOTFOUND);
#if DBG
                if( LOADSTATE_BADFMTID == LoadState )
                   DebugTrace(0, DEBTRACE_WARN,
		              ("_LoadHeader: LoadState=%x\n", LoadState));
#endif

                *pstatus = STATUS_PROPSET_NOT_FOUND;
		goto Exit;
	}

        _Create(
            pfmtid,
            pclsid,
	    LocaleId,
            CodePage,
	    LoadState,
            grfBehavior,
            pstatus
            );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

    }   // if (LoadState != LOADSTATE_DONE)

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (_HasPropHeader() &&
        (_pph->dwOSVer == PROPSETVER_WIN310 ||
         _pph->dwOSVer == PROPSETVER_WIN333))
    {
        propDbg(( DEB_ERROR, "Open(%s) downlevel: %x",
                  (_Flags & CREATEPROP_MODEMASK) == CREATEPROP_READ? "Read" : "Write",
                  _Flags ));
        _State |= CPSS_DOWNLEVEL;
    }

    if ((_Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ)
    {
        if (_State & CPSS_PACKEDPROPERTIES)
        {
            StatusAccessDenied(pstatus, "Open: writing Unaligned propset");
            goto Exit;
        }
        if ((_State & (CPSS_MULTIPLESECTIONS | CPSS_DOCUMENTSUMMARYINFO)) ==
	    CPSS_MULTIPLESECTIONS)
        {
            StatusAccessDenied(pstatus, "Open: writing unknown multiple section propset");
            goto Exit;
        }
    }

    // Return the OS Version to the caller.

    if( pOSVersion != NULL )
        *pOSVersion = _pph->dwOSVer;

    //  ----
    //  Exit
    //  ----

Exit:

    if( STATUS_PROPSET_NOT_FOUND == *pstatus )
        propSuppressExitErrors();

    return;
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::ReOpen
//
// Synopsis:    ReOpen property set image
//
// Arguments:   [pstatus]       -- Pointer to NSTATUS code.
//
// Returns:     Number of properties.
//---------------------------------------------------------------------------

ULONG
CPropertySetStream::ReOpen(OUT NTSTATUS *pstatus)
{
    LOADSTATE LoadState;
    PROPERTYSECTIONHEADER const *psh;
    ULONG cProperties = 0;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::ReOpen" );

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());

    _MSTM(ReOpen)((VOID **) &_pph, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	goto Exit;
    }

    LoadState = _LoadHeader(NULL,
                            CREATEPROP_READ,  // all we need is !create
                            pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (LoadState != LOADSTATE_DONE)
    {
	propDbg(( DEB_ERROR, "ReOpen: LoadState=%lx\n",
                  LoadState));
        StatusCorruption(pstatus, "ReOpen: _LoadHeader");
        goto Exit;
    }

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    psh = _GetSectionHeader();
    PROPASSERT(psh != NULL);

    cProperties = psh->cProperties;

    //  ----
    //  Exit
    //  ----

Exit:

    return( cProperties );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_InitSection
//
// Synopsis:    Initialize a section header and the default properties.
//
// Arguments:   [pfo]		-- pointer to section info
//		[LocaleId]	-- Locale Id
//              [fCreateDictionary]
//                              -- TRUE => create empty dictionary
//
// Returns:     None
//---------------------------------------------------------------------------

        // Serialized Code-Page size
#define CB_CODEPAGE         (CB_SERIALIZEDPROPERTYVALUE + DwordAlign(sizeof(USHORT)))

        // Serialized Locale ID (LCID) size.
#define CB_LOCALE	    (CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG))

        // PID_BEHAVIOR property (VT_UI4)
#define CB_BEHAVIOR        (CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG))

        // Minimum section size (minimum has Code Page & LCID)
#define CB_MINSECTIONSIZE   (CB_PROPERTYSECTIONHEADER   \
                             + 2 * CB_PROPERTYIDOFFSET  \
                             + CB_CODEPAGE              \
                             + CB_LOCALE)

        // Minimum serialized dictionary size (a dict with no entries).
#define CB_EMPTYDICTSIZE    (sizeof(DWORD)) // Entry count

        // Minimum User-Defined section size (in DocumentSummaryInformation proset).
        // (Must include an empty dictionary & a PID/Offset for it.)
#define CB_MINUSERDEFSECTIONSIZE                    \
                            (CB_MINSECTIONSIZE      \
                             +                      \
                             CB_PROPERTYIDOFFSET    \
                             +                      \
                             CB_EMPTYDICTSIZE)

VOID
CPropertySetStream::_InitSection(
    IN FORMATIDOFFSET *pfo,
    IN ULONG LocaleId,
    IN BOOL  fCreateDictionary  // Create an empty dictionary?
    )
{
    PROPERTYSECTIONHEADER *psh;

    ULONG ulPropIndex;     // Index into the PID/Offset array.
    DWORD dwPropValOffset; // The offset to where the next prop val will be written.
                           // Pointer to a serialized property value.
    SERIALIZEDPROPERTYVALUE *pprop;

    IFDBG( HRESULT hr = S_OK );
    propITrace( "CPropertySetStream::_InitSection" );

    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

    // Set the property count and section size in the section header.
    // This must account for the Code Page and Locale ID properties, and
    // might need to account for an empty dictionary property and/or
    // a behavior property.  dwPropValOffset identifies the location of the
    // next property value to be written.

    psh->cProperties = 2;   // Always write codepage & local
//    dwPropValOffset  = CB_PROPERTYSECTIONHEADER + 2 * CB_PROPERTYIDOFFSET;

    // Don't add in CB_PROPERTYIDOFFSET yet
    psh->cbSection   = CB_PROPERTYSECTIONHEADER + CB_CODEPAGE + CB_LOCALE;

    // Finish calculating cProperties
    if( fCreateDictionary )
    {
        psh->cProperties++; // Write an empty dictionary too
        psh->cbSection += CB_EMPTYDICTSIZE;
    }

    if( 0 != _grfBehavior )
    {
        psh->cProperties++; // Write a behavior property too
        psh->cbSection += CB_BEHAVIOR;
    }

    // Based on cProperties, finish calculating cbSection
    psh->cbSection += psh->cProperties * CB_PROPERTYIDOFFSET;

    ulPropIndex = 0;

    // If requested by the caller, create a dictionary property, but
    // leave the dictionary empty.  We always create this first.  It shouldn't
    // matter where it's located, but Office95 requires it to be first
    // and it doesn't do any harm to put it there.

    dwPropValOffset = CB_PROPERTYSECTIONHEADER + psh->cProperties * CB_PROPERTYIDOFFSET;

    if( fCreateDictionary )
    {
        // Fill in the PID/Offset table.

        psh->rgprop[ ulPropIndex ].propid = PID_DICTIONARY;
        psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

        // Fill in the property value.

        pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
        pprop->dwType = 0L; // For the dictonary, this is actually the entry count.

        // Advance the table & value indices.

        ulPropIndex++;
        dwPropValOffset += CB_EMPTYDICTSIZE;

    }   // if( fCreateDictionary )

    // Also if requested by the caller, create a behavior property.

    if( 0 != _grfBehavior )
    {
        // Fill in the PID/Offset table

        psh->rgprop[ ulPropIndex ].propid = PID_BEHAVIOR;
        psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

        // Fill in the property value

        pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
        pprop->dwType = PropByteSwap( (DWORD) VT_UI4 );
        *reinterpret_cast<ULONG*>(pprop->rgb) = PropByteSwap( _grfBehavior );

        // Advance the table & value indices

        ulPropIndex++;
        dwPropValOffset += CB_BEHAVIOR;

    }   // if( 0 != _grfBehavior )


    // Write the code page.  We write a zero first to initialize
    // the padding bytes.

    psh->rgprop[ ulPropIndex ].propid = PID_CODEPAGE;
    psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

    pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
    pprop->dwType = PropByteSwap((DWORD) VT_I2);
    *(DWORD *) pprop->rgb = 0;   // Zero out extra two bytes.
    *(WORD  *) pprop->rgb = PropByteSwap( _CodePage );

    ulPropIndex++;
    dwPropValOffset += CB_CODEPAGE;


    // Write the Locale ID.

    psh->rgprop[ ulPropIndex ].propid = PID_LOCALE;
    psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

    pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr(psh, dwPropValOffset );
    pprop->dwType = PropByteSwap( (DWORD) VT_UI4 );
    *(DWORD *) pprop->rgb = PropByteSwap( (DWORD) LocaleId );

    // ulPropIndex++;
    // dwPropValOffset += CB_LOCALE;

}   // CPropertySetStream::_InitSection




//+---------------------------------------------------------------------------
// Member:      _MultiByteToWideChar, private
//
// Synopsis:    Convert a MultiByte string to a Unicode string,
//              using the _pma memory allocator if necessary.
//
// Arguments:   [pch]        -- pointer to MultiByte string
//              [cb]         -- byte length of MultiByte string
//                              (-1 if null terminated)
//              [CodePage]   -- Codepage of input string.
//              [ppwc]       -- pointer to pointer to converted string
//                              (if *ppwc is NULL, it will be alloced,
//                              if non-NULL, *ppwc must be *pcb bytes long).
//              [pcb]        -- IN:  byte length of *ppwc
//                              OUT: byte length of Unicode string.
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_MultiByteToWideChar(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    // Did we allocate *ppwc?
    BOOL fAlloc = FALSE;

    //  --------------
    //  Initialization
    //  --------------

//    IFDBG( HRESULT &hr = *pstatus );
//    propITrace( "CPropertySetStream::_MultiByteToWideChar" );

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pch != NULL);
    PROPASSERT(ppwc != NULL);
    PROPASSERT(pcb != NULL);
    PROPASSERT(IsAnsiString(pch, ((ULONG)-1 == cb ) ? MAXULONG : cb));
    PROPASSERT(NULL != *ppwc || 0 == *pcb);

//    propTraceParameters(( "pch=%s, cb=%d, CodePage=%d, ppwc=%p, pcb=%p",
//                          pch,     cb,    CodePage,    ppwc,    pcb ));

    //  ------------------
    //  Convert the String
    //  ------------------

    // We will pass through this loop once (if the caller provided a buffer
    // or twice (otherwise).

    while (TRUE)
    {
        // Attempt to convert the string.

	*pcb = MultiByteToWideChar(
				    CodePage,   // Source codepage
				    0,          // Flags
				    pch,        // Source string
				    cb,         // Source string length
				    *ppwc,      // Target string
				    *pcb);      // Size of target string buffer

        // The converted length should never be zero.
	if (0 == *pcb)
	{
            // If we alloced a buffer, free it now.
            if( fAlloc )
            {
	        _pma->Free( *ppwc );
                *ppwc = NULL;
            }

            // If there was an error, assume that it was a code-page
            // incompatibility problem.

            StatusError(pstatus, "_MultiByteToWideChar error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}

        // There was no error.  If we provided a non-NULL buffer,
        // then the conversion was performed and we're done.

	*pcb *= sizeof(WCHAR);  // cch => cb
	if (*ppwc != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"_MultiByteToWideChar: pch='%s'[%x] pwc='%ws'[%x->%x]\n",
		pch,
		cb,
		*ppwc,
		*pcb,
		*pcb * sizeof(WCHAR)));
	    break;
	}

        // We haven't actually the string yet.  Now that
        // we know the length, we can allocate a buffer and try the
        // conversion for real.

	*ppwc = (WCHAR *) _pma->Allocate( *pcb );
	if (NULL == *ppwc)
	{
	    StatusNoMemory(pstatus, "_MultiByteToWideChar: no memory");
            goto Exit;
	}
        fAlloc = TRUE;

    }   // while(TRUE)

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_MultiByteToWideChar



//+---------------------------------------------------------------------------
// Member:      _WideCharToMultiByte, private
//
// Synopsis:    Convert a Unicode string to a MultiByte string,
//              using the _pma memory allocator if necessary.
//
// Arguments:   [pwc]        -- pointer to Unicode string
//              [cch]        -- character length of Unicode string
//                              (-1 if null terminated)
//              [CodePage]   -- codepage of target string
//              [ppch]       -- pointer to pointer to converted string
//                              (if *ppch is NULL, it will be alloced,
//                              if non-NULL, *ppch must be *pcb bytes long).
//              [pcb]        -- IN:  byte length of *ppch
//                              OUT: byte length of MultiByte string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_WideCharToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cch,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    // Did we allocate *ppch?
    BOOL fAlloc = FALSE;

    //  --------------
    //  Initialization
    //  --------------

    IFDBG( HRESULT &hr = *pstatus );
//    propITrace( "CPropertySetStream::_WiteCharToMultiByte" );

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pwc != NULL);
    PROPASSERT(ppch != NULL);
    PROPASSERT(pcb != NULL);
    PROPASSERT(IsUnicodeString(pwc, ((ULONG)-1 == cch ) ? MAXULONG : cch*sizeof(WCHAR)));
    PROPASSERT(NULL != *ppch || 0 == *pcb);

//    propTraceParameters(( "pwc=%ws, cch=%d, CodePage=%d, ppch=%p, pcb=%p",
//                           pwc,      cch,    CodePage,    ppch,    pcb ));

    //  ------------------
    //  Convert the String
    //  ------------------

    // We will pass through this loop once (if the caller provided a buffer
    // or twice (otherwise).

    while (TRUE)
    {
        // Attempt the conversion.
	*pcb = WideCharToMultiByte(
				    CodePage,       // Codepage to convert to
				    0,              // Flags
				    pwc,            // Source string
				    cch,            // Size of source string
				    *ppch,          // Target string
				    *pcb,           // Size of target string buffer
				    NULL,           // lpDefaultChar
				    NULL);          // lpUsedDefaultChar

        // A converted length of zero indicates an error.
	if (0 == *pcb)
	{
            // If we allocated a buffer in this routine, free it.
            if( fAlloc )
            {
	        _pma->Free( *ppch );
                *ppch = NULL;
            }

            // If there was an error, assume that it was a code-page
            // incompatibility problem.

            StatusError(pstatus, "_WideCharToMultiByte: WideCharToMultiByte error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}

        // If we have a non-zero length, and we provided a buffer,
        // then we're done (successfully).

	if (*ppch != NULL)
	{
            propDbg(( DEB_ITRACE, "_WideCharToMultiByte: pwc='%ws'[%x] pch='%s'[%x->%x]\n",
		                   pwc, cch, *ppch, *pcb, *pcb));
	    break;
	}

        // There were no errors, but we need to allocate a buffer
        // to do the actual conversion.

	*ppch = (CHAR*) _pma->Allocate( *pcb );
	if (*ppch == NULL)
	{
	    StatusNoMemory(pstatus, "_WideCharToMultiByte: no memory");
            goto Exit;
	}
        fAlloc = TRUE;

    }   // while (TRUE)


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_WideCharToMultiByte


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::ByteSwapHeaders
//
// Synopsis:    Byte-swap the headers of a property set header
//              (both the propset header and any section headers).
//
// Arguments:   [PROPERTYSETHEADER*] pph
//                  Pointer to the beginning of the property set.
//              [ULONG] cbstm
//                  Total size of the property stream.
//              [NTSTATUS*] pstatus
//                  Pointer to NTSTATUS code.
//
// Pre-Conditions:
//              There are no more than two sections.
//
//              Note that this routine does not assume anything
//              about the current state of the CPropertySetStream
//              (it accesses no member variables).
//
// Post-Conditions:
//              If the property set headers are valid, the
//              propset and section headers are byte-swapped.
//              Note that if the property set is invalid, this
//              routine may only partially swap it.  Therefore,
//              the caller must ensure in this case that no
//              attempt is made to use the property set.
//
// Returns:     None.  *pstatus will only be non-successful
//              if the Stream was too small for the property set
//              (i.e, the property set is corrupt).  If the caller
//              knows this not to be the case, then it can assume
//              that this routine will return STATUS_SUCCESS.
//
//---------------------------------------------------------------------------

VOID
CPropertySetStream::ByteSwapHeaders( IN PROPERTYSETHEADER *pph,
                                     IN DWORD cbstm,
                                     OUT NTSTATUS *pstatus )
{
#if LITTLEENDIAN

    *pstatus = STATUS_SUCCESS;
    return;

#else

    //  ------
    //  Locals
    //  ------

    ULONG cSections;
    ULONG ulIndex, ulSectionIndex;

    // pfoPropSet points into pph, pfoReal is a local copy
    // in the system's endian-ness.
    FORMATIDOFFSET *pfoPropSet, pfoReal[2];

    // Pointers into pph.
    PROPERTYSECTIONHEADER *psh = NULL;
    PROPERTYIDOFFSET *po = NULL;

    // Are we converting *to* the system's endian-ness?
    BOOL fToSystemEndian;

    //  ----------
    //  Initialize
    //  ----------

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::ByteSwapHeaders" );
    propTraceParameters( "pph=%p, cbstm=%d", pph, cbstm );

    *pstatus = STATUS_SUCCESS;
    PROPASSERT( NULL != pph );
    PROPASSERT(PROPSET_BYTEORDER == pph->wByteOrder
               ||
               PROPSET_BYTEORDER == ByteSwap( pph->wByteOrder )
              );


    //  ----------------------------
    //  Swap the Property Set header
    //  ----------------------------

    // Validate the stream length.
    if( sizeof(*pph) > cbstm )
    {
        StatusCorruption(pstatus, "CPropertySetStream::ByteSwapHeaders: PropertySet header size");
        goto Exit;
    }

    // Swap the fields in place.
    PropByteSwap( &pph->wByteOrder );
    PropByteSwap( &pph->wFormat );
    PropByteSwap( &pph->dwOSVer );
    PropByteSwap( &pph->clsid );
    PropByteSwap( &pph->reserved );

    // Are we converting to little-endian?
    if( PROPSET_BYTEORDER == pph->wByteOrder)
        fToSystemEndian = TRUE;
    else
    {
        fToSystemEndian = FALSE;
        PROPASSERT( PROPSET_BYTEORDER == PropByteSwap(pph->wByteOrder) );
    }

    // Get the correctly-endianed section count and validate.

    cSections = fToSystemEndian ? pph->reserved
                                : PropByteSwap( pph->reserved );

    if( cSections > 2 )
    {
        StatusCorruption(pstatus, "CPropertySetStream::ByteSwapHeaders: PropertySet header size");
        goto Exit;
    }

    //  -------------------------
    //  Swap the per-section data
    //  -------------------------

    pfoPropSet = (FORMATIDOFFSET*) ((BYTE*) pph + sizeof(*pph));

    for( ulSectionIndex = 0; ulSectionIndex < cSections; ulSectionIndex++ )
    {
        ULONG cbSection, cProperties;

        //  ------------------------------
        //  Swap the FormatID/Offset entry
        //  ------------------------------

        // Is the Stream long enough for the array?
        if( cbstm < (ULONG) &pfoPropSet[ulSectionIndex]
                    + sizeof(*pfoPropSet)
                    - (ULONG) pph )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::_ByteSwapHeaders: FormatID/Offset size");
            goto Exit;
        }

        // Get a local copy of this FMTID/Offset array entry
        // If it is propset-endian format, swap to make usable.

        pfoReal[ ulSectionIndex ].fmtid    = pfoPropSet[ulSectionIndex].fmtid;
        pfoReal[ ulSectionIndex ].dwOffset = pfoPropSet[ulSectionIndex].dwOffset;

        if( fToSystemEndian )
        {
            PropByteSwap( &pfoReal[ulSectionIndex].fmtid );
            PropByteSwap( &pfoReal[ulSectionIndex].dwOffset );
        }

        // Swap this FMTID/Offset entry in place.
        PropByteSwap( &pfoPropSet[ulSectionIndex].fmtid );
        PropByteSwap( &pfoPropSet[ulSectionIndex].dwOffset );


        //  -----------------------
        //  Swap the section header
        //  -----------------------

        // Locate the section header and the first entry in the
        // PID/Offset table.

        psh = (PROPERTYSECTIONHEADER*)
              ( (BYTE*) pph + pfoReal[ ulSectionIndex ].dwOffset );

        po = (PROPERTYIDOFFSET*)
             ( (BYTE*) psh + sizeof(psh->cbSection) + sizeof(psh->cProperties) );

        // Validate that we can see up to the PID/Offset table.
        if( cbstm < (ULONG) ((BYTE*) po - (BYTE*) pph) )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::ByteSwapHeaders: Section header size");
            goto Exit;
        }

        // Get local copies of the section & property counts.
        // Again we may need to swap them from propset-endian format
        // in order to make them usable.

        cbSection = psh->cbSection;
        cProperties = psh->cProperties;

        if( fToSystemEndian)
        {
            PropByteSwap( &cbSection );
            PropByteSwap( &cProperties );
        }

        // Swap the two fields at the top of the section header.

        PropByteSwap( &psh->cbSection );
        PropByteSwap( &psh->cProperties );

        //  -------------------------
        //  Swap the PID/Offset table
        //  -------------------------

        // Validate that we can see the whole table.
        if( cbstm < (BYTE*) po - (BYTE*) pph + cProperties * sizeof(*po) )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::ByteSwapHeaders: Section header size");
            goto Exit;
        }

        // Swap each of the array entries.
        for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
        {
            PropByteSwap( &po[ulIndex].propid );
            PropByteSwap( &po[ulIndex].dwOffset );
        }

    }   // for( ulSectionIndex = 0; ulSectionIndex < cSections, ulIndex++ )

    //  ----
    //  Exit
    //  ----

Exit:

    return;

#endif // #if LITTLEENDIAN ... #else

}   // CPropertySetStream::ByteSwapHeaders


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CreateUserDefinedSection
//
// Synopsis:    Create second property section
//
// Arguments:   [LoadState]	-- _LoadHeader returned state
//		[LocaleId]	-- Locale Id
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     TRUE if LoadState handled successfully.  If TRUE,
//              *pstatus will be STATUS_SUCCESS.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_CreateUserDefinedSection(
    IN LOADSTATE LoadState,
    IN ULONG LocaleId,
    OUT NTSTATUS *pstatus)
{
    BOOLEAN fSuccess = FALSE;
    FORMATIDOFFSET *pfo;
    ULONG cbstmNew;
    PROPERTYSECTIONHEADER *psh;

    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_CreateUserDefinedSection" );
    propTraceParameters(( "LoadState=%d, LocaleId=0x%x", LoadState, LocaleId ));

    PROPASSERT(_State & CPSS_USERDEFINEDPROPERTIES);
    switch (_Flags & CREATEPROP_MODEMASK)
    {
    case CREATEPROP_CREATEIF:
    case CREATEPROP_CREATE:
	if (LoadState == LOADSTATE_USERDEFINEDNOTFOUND)
	{
	    ULONG cbmove;

	    PROPASSERT(_cSection == 1);
	    pfo = _GetFormatidOffset(0);
	    PROPASSERT(pfo->fmtid == guidDocumentSummary);
	    PROPASSERT(IsDwordAligned(pfo->dwOffset));

            // Get a pointer to the first section header, using the
            // FmtID/Offset array.

	    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

            // Determine if we need to move the first section back in order
            // to make room for this new entry in the FmtID/Offset array.

	    cbmove = 0;
	    if (pfo->dwOffset < CB_PROPERTYSETHEADER + 2 * CB_FORMATIDOFFSET)
	    {
		cbmove = CB_PROPERTYSETHEADER + 2*CB_FORMATIDOFFSET - pfo->dwOffset;
	    }

            // How big should the Stream be?

	    cbstmNew = pfo->dwOffset            // The offset of the first section
                            +
			    cbmove              // Room for new FormatID/Offset array entry
                            +                   // Size of first section
			    DwordAlign(psh->cbSection)
                            +                   // Size of User-Defined section.
			    CB_MINUSERDEFSECTIONSIZE;

            // Set the stream size.

	    _MSTM(SetSize)(cbstmNew, TRUE, (VOID **) &_pph, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // reload all pointers into mapped image:

	    pfo = _GetFormatidOffset(0);
	    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

	    if (cbmove != 0)
	    {
		// Move section back to make room for new FORMATIDOFFSET entry

		PropMoveMemory(
			"_AddSection",
			psh,
			Add2Ptr(psh, cbmove),
			psh,
			psh->cbSection);

		pfo->dwOffset += cbmove;
		PROPASSERT(IsDwordAligned(pfo->dwOffset));
	    }

	    psh->cbSection = DwordAlign(psh->cbSection);

            PROPASSERT(_oSection == 0);
	    PROPASSERT(_cSection == 1);
	    PROPASSERT(_pph->reserved == 1);

	    _cSection++;
	    _pph->reserved++;

	    _oSection = pfo->dwOffset + psh->cbSection;
	    pfo = _GetFormatidOffset(1);
	    pfo->fmtid = guidDocumentSummarySection2;
	    pfo->dwOffset = _oSection;
	    _InitSection(pfo,
                         LocaleId,
                         TRUE ); // Create an empty dictionary.

	    fSuccess = TRUE;
	}
	break;

    case CREATEPROP_DELETE:
	PROPASSERT(
	    LoadState == LOADSTATE_USERDEFINEDDELETE ||
	    LoadState == LOADSTATE_USERDEFINEDNOTFOUND);
	if (LoadState == LOADSTATE_USERDEFINEDDELETE)
	{
	    PROPASSERT(_cSection == 2);
	    PROPASSERT(_pph->reserved == 2);
	    pfo = _GetFormatidOffset(1);
	    RtlZeroMemory(pfo, sizeof(*pfo));

	    _cSection--;
	    _pph->reserved--;
	    pfo = _GetFormatidOffset(0);
	    PROPASSERT(pfo->fmtid == guidDocumentSummary);
	    PROPASSERT(IsDwordAligned(pfo->dwOffset));
	    psh = (PROPERTYSECTIONHEADER *)
			_MapAbsOffsetToAddress(pfo->dwOffset);
	    psh->cbSection = DwordAlign(psh->cbSection);
	    cbstmNew = pfo->dwOffset + psh->cbSection;

	    _MSTM(SetSize)(cbstmNew, TRUE, (VOID **) &_pph, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	}
	_State |= CPSS_USERDEFINEDDELETED;

	fSuccess = TRUE;
        break;

    default:
	PROPASSERT(!"_Flags: bad open mode");
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return( fSuccess );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_Create
//
// Synopsis:    Create property set image
//
// Arguments:   [pfmtid]        -- format id
//              [pclsid]        -- class id
//		[LocaleId]	-- Locale Id
//              [CodePage]      -- CodePage
//		[LoadState]	-- _LoadHeader returned state
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_Create(
    IN GUID const *pfmtid,
    OPTIONAL IN GUID const *pclsid,
    IN ULONG LocaleId,		    // Locale Id (create only)
    IN USHORT CodePage,
    IN LOADSTATE LoadState,
    IN DWORD grfBehavior,
    OUT NTSTATUS *pstatus
    )
{
    ULONG cb;
    FORMATIDOFFSET *pfo;
    ULONG cSectionT;

    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_Create" );
    propTraceParameters(( "pfmtid=%p, pclsid=%p, LocaleId=%d, CodePage=%d, LoadState=%d, grfBehavior=0x%x",
                           pfmtid,    pclsid,    LocaleId,    CodePage,    LoadState,    grfBehavior ));

    _SetModified(pstatus);
    if( !NT_SUCCESS(*pstatus) )
    {
        TraceStatus( "_Create: Couldn't SetModified" );
        goto Exit;
    }

    // Set the size of the stream to correspond to the header for the
    // property set as well as the section.

    _CodePage = CodePage;
    _grfBehavior = grfBehavior;

    cSectionT = 1;

    // Are we creating the UserDefined property set
    // (the second section of the DocumentSummaryInformation
    // property set)?

    if (_State & CPSS_USERDEFINEDPROPERTIES)
    {
        // Create the UD propset, and set the cSection.
        // If this routine returns TRUE, it means that
        // the first section already existed, and we're done.
        // Otherwise, we must continue and create the first section.

	if (_CreateUserDefinedSection(LoadState, LocaleId, pstatus))
	{
            // If we get here, we know that *pstatus is Success.

	    if (pclsid != NULL)
	    {
		_pph->clsid = *pclsid;
	    }
	    goto Exit;
	}
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

	cSectionT = 2;
    }

    // Calculate the exact size of the Stream (we know exactly
    // what it will be because we only initialize the set(s) with
    // fixed size data).

    PROPASSERT( 1 <= cSectionT && cSectionT <= 2 );
    cb = CB_PROPERTYSETHEADER       // The size of the propset header.
         +                          // The size of the FmtID/Offset array
         cSectionT * CB_FORMATIDOFFSET
         +
         CB_MINSECTIONSIZE          // The size of the first section
         +                          // Maybe the size of the User-Defined section
         ( cSectionT <= 1 ? 0 : CB_MINUSERDEFSECTIONSIZE );

    if( 0 != _grfBehavior )
        cb += CB_PROPERTYIDOFFSET + CB_BEHAVIOR;


    propDbg(( DEB_ITRACE, "SetSize(%x) init\n", cb ));

    // Set the size of the stream
    _MSTM(SetSize)(cb, TRUE, (VOID **) &_pph, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // And get a mapping of the Stream.
    _MSTM(Map)(TRUE, (VOID **) &_pph);
    RtlZeroMemory(_pph, cb);            // Zeros classid, fmtid(s), etc

    // Initialize the OS Version in the header.
    // Getting the current OS version depends on the OS.

#if defined(_MAC)

    {
        // Get the Mac System Version (e.g., 7.53).  If we get an API error,
        // we won't treat it as fatal, we'll just set the version to 0.

        OSErr oserr;
        SysEnvRec theWorld;
        oserr = SysEnvirons( curSysEnvVers, &theWorld );
        PROPASSERT( noErr == oserr );

        if( noErr == oserr )
        {
            _pph->dwOSVer = MAKEPSVER( OSKIND_MACINTOSH,
                                       HIBYTE(theWorld.systemVersion),  // Major
                                       LOBYTE(theWorld.systemVersion) );// Minor
        }
        else
        {
            _pph->dwOSVer = MAKEPSVER( OSKIND_MACINTOSH, 0, 0 );
        }

    }

#elif defined(IPROPERTY_DLL) || !defined(WINNT)

    {
        // Get the Windows version.
        DWORD dwWinVersion = GetVersion();

        // Use it to set the OSVersion
        _pph->dwOSVer = MAKEPSVER( OSKIND_WIN32,
                                   LOBYTE(LOWORD( dwWinVersion )),      // Major
                                   HIBYTE(LOWORD( dwWinVersion )) );    // Minor
    }

#else   // #if defined(_MAC) ... #elif defined(IPROPERTY_DLL)

    // Since we're part of the system, we can hard-code the OSVersion,
    // and save the expense of an API call.

    _pph->dwOSVer = PROPSETVER_CURRENT;

#endif  // #if defined(_MAC) ... #elif ... #else

    // Initialize the rest of the header.

    _pph->wByteOrder = 0xfffe;
    //_pph->wFormat = 0;                // RtlZeroMemory does this
    PROPASSERT(_pph->wFormat == 0);

    // The behavior property is only supported in version-1 property sets.
    if( 0 != _grfBehavior )
        _pph->wFormat = PROPSET_WFORMAT_BEHAVIOR;

    if (pclsid != NULL)
    {
	_pph->clsid = *pclsid;
    }
    _pph->reserved = cSectionT;

    // Initialize the format id offset for the section(s).

    pfo = _GetFormatidOffset(0);
    pfo->dwOffset = CB_PROPERTYSETHEADER + cSectionT * CB_FORMATIDOFFSET;

    // Are we creating the second section of the DocSumInfo property set?

    if (cSectionT == 2)
    {
        // We need to initialize any empty first section.

	pfo->fmtid = guidDocumentSummary;

	_InitSection(pfo,
                     LocaleId,
                     FALSE); // Don't create an empty dictionary.

        // Advance the FmtID/Offset table pointer to the second entry,
        // and set it's offset to just beyond the first section.

	pfo = _GetFormatidOffset(1);
	pfo->dwOffset = CB_PROPERTYSETHEADER +
			cSectionT * CB_FORMATIDOFFSET +
			CB_MINSECTIONSIZE;
    }

    // Initialize the requested property set.

    PROPASSERT(pfmtid != NULL);
    pfo->fmtid = *pfmtid;
    _InitSection(pfo,
                 LocaleId,
                           // TRUE => Create an empty dictionary
                 pfo->fmtid == guidDocumentSummarySection2 );

    _cSection = cSectionT;
    _oSection = pfo->dwOffset;


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_Create


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadHeader
//
// Synopsis:    verify header of a property set and read the code page
//
// Arguments:   [pfmtid]        -- format id
//		[Mode]		-- open mode
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     LOADSTATE
//---------------------------------------------------------------------------

LOADSTATE
CPropertySetStream::_LoadHeader(
    OPTIONAL IN GUID const *pfmtid,
    IN BYTE Mode,
    OUT NTSTATUS *pstatus)
{
    LOADSTATE loadstate = LOADSTATE_FAIL;
    ULONG cbstm, cbMin;
    PROPERTYSECTIONHEADER *psh;
    FORMATIDOFFSET const *pfo;
    BOOLEAN fSummaryInformation = FALSE;
#if DBGPROP
    BOOLEAN fFirst = _pph == NULL;
#endif

    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_LoadHeader" );
    propTraceParameters(( "pfmtid=%s, Mode=%d",
                          (NULL == pfmtid)?"<null>":static_cast<const char*>(CStringize(*pfmtid)),
                          Mode ));

    PROPASSERT((_State & CPSS_USERDEFINEDDELETED) == 0);

    // If this is one of the DocSumInfo property sets,
    // we need to set some _State bits.  If this is an
    // Open, rather than a Create, pfmtid may be NULL.
    // In that case, we'll set these bits after the open
    // (since we can then get the fmtid from the header).

    if( pfmtid != NULL && *pfmtid == guidDocumentSummary )
    {
        _State |= CPSS_DOCUMENTSUMMARYINFO;
    }

    if (pfmtid != NULL && *pfmtid == guidDocumentSummarySection2)
    {
	_State |= CPSS_USERDEFINEDPROPERTIES;
    }
    else
    {
        // If this isn't the UD property set, the Mode
        // better not be "Delete" (all other property sets
        // are deleted simply be deleting the underlying
        // stream).

	if (Mode == CREATEPROP_DELETE)
	{
	    propDbg(( DEB_ITRACE, "_LoadHeader: CREATEPROP_DELETE\n" ));
	    StatusInvalidParameter(pstatus, "_LoadHeader: CREATEPROP_DELETE");
            goto Exit;
	}
	if (Mode == CREATEPROP_CREATE)
	{
	    goto Exit;  // We're going to overwrite it anyway
	}
    }

    // Get the size of the underlying stream.

    cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Map the serialized property set to a pointer.

    _MSTM(Map)(FALSE, (VOID **) &_pph);

    // Fix a Visio problem where the User-Defined property set isn't
    // aligned properly.

    _FixUnalignedUDPropSet( &cbstm, pstatus );
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Compute the minimum size of this property set, as specified
    // by the property set header and the section headers.  This call
    // will fail if any part of these headers is beyond the end of the
    // the stream (as determined from cbstm).
    // It will *not* fail if a section's cbSection indicates that the
    // section goes beyond the end of the stream (in order to maintain
    // compatibility with other propset imps, such as Publisher).  We'll
    // handle that later in the _Fix* routines called below.

    cbMin = _ComputeMinimumSize(cbstm, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // The following assert should technically ASSERT equality.  However,
    // to avoid unmapping and closing sections for every property operation,
    // we allow shrinks to fail when other instances of the same property
    // set are active.  So we on occasion will legitimately see streams larger
    // than necessary.  The wasted space will be cleaned up when the property
    // set is next modified.
    //PROPASSERT(cbMin == cbstm);

    // The following assert should be valid, but it isn't for some
    // older property sets which we fix in the _Fix* routines, which
    // are called below.
    //PROPASSERT(cbMin <= cbstm);

    propDbg(( DEB_ITRACE, "ComputeMinimumSize: cbMin=%l" szX " cbstm=%l" szX " cbUnused=%l" szX "\n",
                          cbMin, cbstm, cbstm - cbMin ));

    _oSection = 0;
    _cSection = 1;
    _cbTail = 0;
#ifdef KERNEL
    _CodePage = CP_WINUNICODE;
#endif

    if (_HasPropHeader())   // I.e. if not in kernel mode
    {
	// The first expression must be TRUE before we can dereference _pph
	// for the second expression.

        if (cbstm < CB_PROPERTYSETHEADER + CB_FORMATIDOFFSET ||
	    cbstm < CB_PROPERTYSETHEADER + _pph->reserved * CB_FORMATIDOFFSET ||
            _pph->wByteOrder != 0xfffe ||
            _pph->wFormat > 1 ||
            _pph->reserved < 1)
        {
            _cSection = 0;		// Mark property set invalid
            propDbg(( DEB_ERROR, "_LoadHeader: %s\n",
                cbstm == 0? "Empty Stream" :
		    cbstm < CB_PROPERTYSETHEADER + CB_FORMATIDOFFSET?
			"Stream too small for header" :
		    _pph->wByteOrder != 0xfffe? "Bad wByteOrder field" :
		    _pph->wFormat > 1 ? "Bad wFormat field" :
		    _pph->reserved < 1? "Bad reserved field" :
                    "Bad dwOSVer field" ));
            goto Exit;
        }

        // Now that we've loaded the property set, check again
        // to see if this is a SumInfo or DocSumInfo set.

        pfo = _GetFormatidOffset(0);
	if (pfo->fmtid == guidDocumentSummary)
	{
	    _State |= CPSS_DOCUMENTSUMMARYINFO;
	}
        else if (pfo->fmtid == guidSummary)
        {
            fSummaryInformation = TRUE;
        }

        // If what we're after is the property set in the
        // second section, verify that it's there.

        if (_State & CPSS_USERDEFINEDPROPERTIES)
	{
            // Ensure that this is the second section of
            // the DocSumInfo property set; that's the only
            // two-section property set we support.

	    if ((_State & CPSS_DOCUMENTSUMMARYINFO) == 0)
	    {
		propDbg(( DEB_ERROR, "Not DocumentSummaryInfo 1st FMTID\n" ));
		goto Exit;
	    }

            // Verify that this property set has two sections, and that
            // the second section is the UD propset.
            // Note that this gets pfo pointing to the correct entry in the
            // FMTID/Offset array.

	    if (_pph->reserved < 2 ||
		(pfo = _GetFormatidOffset(1))->fmtid != guidDocumentSummarySection2)
	    {
		DebugTrace(
			0,
			_pph->reserved < 2? Dbg : DEBTRACE_ERROR,
			("Bad/missing 2nd section FMTID\n"));
		loadstate = LOADSTATE_USERDEFINEDNOTFOUND;
                goto Exit;
	    }
	}
	else if (pfmtid != NULL)
        {
            // This isn't the UserDefined property set, so it
            // should be the first section, so it should match
            // the caller-requested format ID.

            if (*pfmtid != pfo->fmtid)
            {
                // The propset's FmtID doesn't match, but maybe that's
                // because it's a MacWord6 SumInfo property set, in which
                // the FmtID isn't byte-swapped.  Otherwise, it's a problem.

                if( OSKIND_MACINTOSH == PROPSETHDR_OSVER_KIND(_pph->dwOSVer)
                    &&
                    guidSummary == *pfmtid
                    &&
                    IsEqualFMTIDByteSwap( *pfmtid, pfo->fmtid )
                  )
                {
                    fSummaryInformation = TRUE;
                }
                else
	        {
                    _cSection = 0;
	            DebugTrace(0, DEBTRACE_ERROR, ("Bad FMTID\n"));
                    loadstate = LOADSTATE_BADFMTID;
                    goto Exit;
	        }
            }   // if (*pfmtid != pfo->fmtid)
        }   // else if (pfmtid != NULL)

        _oSection = pfo->dwOffset;
        _cSection = _pph->reserved; // Could be first or second section, depending on pfo

    }   // if (_HasPropHeader())

    psh = _GetSectionHeader();

    // Scan the property set for code page and behavior properties.
    // Sets _CodePage and _grfBehavior.

    _SearchForCodePage( pstatus );
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Validate that the Behavior property only has bits we understand.

    if( 0 != _grfBehavior && _pph->wFormat < PROPSET_WFORMAT_BEHAVIOR )
    {
        propDbg(( DEB_ITRACE, "_LoadHeader: invalid format for behavior (%d,%x)\n",
                               _pph->wFormat, _grfBehavior ));
        goto Exit;
    }
    else if( ~PROPSET_BEHAVIOR_CASE_SENSITIVE & _grfBehavior )
    {
        propDbg(( DEB_ITRACE, "_LoadHeader: unsupported behavior (%x)\n", _grfBehavior ));
        goto Exit;
    }

    PROPASSERT( 0 == _grfBehavior || _pph->wFormat > 0 );

    // If we have multiple sections, record the tail length
    // (the size of the property set beyond this section).

    if (_cSection > 1)
    {
	_State |= CPSS_MULTIPLESECTIONS;
	_cbTail = cbMin - (_oSection + psh->cbSection);
	propDbg(( DEB_ITRACE, "_LoadHeader: cbTail=%x\n", _cbTail));
    }


    // Fix all header-related problems in the in-memory representation.
    // The only header-related problems we fix are with SummaryInformation
    // property sets.

    if (fSummaryInformation)
    {
	_FixSummaryInformation(&cbstm, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // The stream may have been re-mapped, invalidating our section header pointer
        psh = _GetSectionHeader();
    }


    // Now that, to the best of our ability, the headers are good,
    // let's validate them against the actual stream size.

    if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER ||
        psh->cbSection < CB_PROPERTYSECTIONHEADER +
            psh->cProperties * CB_PROPERTYIDOFFSET ||
        cbstm < _oSection + CB_PROPERTYSECTIONHEADER +
            psh->cProperties * CB_PROPERTYIDOFFSET ||
        cbstm < _oSection + psh->cbSection)
    {
        _cSection = 0;
        propDbg(( DEB_ITRACE, "_LoadHeader: too small for section\n"));
        goto Exit;
    }

    if( 1 < _cSection )
    {
        PROPERTYSECTIONHEADER *psh1;
        ULONG oSection1 = 0;

        oSection1 = _GetFormatidOffset(1)->dwOffset;

        psh1 = _GetSectionHeader( 1, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (cbstm < oSection1 + CB_PROPERTYSECTIONHEADER ||
            psh1->cbSection < CB_PROPERTYSECTIONHEADER +
                psh1->cProperties * CB_PROPERTYIDOFFSET ||
            cbstm < oSection1 + CB_PROPERTYSECTIONHEADER +
                psh1->cProperties * CB_PROPERTYIDOFFSET ||
            cbstm < oSection1 + psh1->cbSection)
        {
            _cSection = 0;
            propDbg(( DEB_ITRACE, "_LoadHeader: too small for section\n"));
            goto Exit;
        }
    }

    // Now we know the headers are OK, so let's see if there are any
    // problems in the properties themselves that we know how
    // to fix.

    if (fSummaryInformation || (_State & CPSS_DOCUMENTSUMMARYINFO))
    {
        psh = NULL; // May get re-mapped by _FixPackedPropertySet
	_FixPackedPropertySet( pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    if (Mode == CREATEPROP_DELETE)
    {
	loadstate = LOADSTATE_USERDEFINEDDELETE;
        goto Exit;
    }


    //  ----
    //  Exit
    //  ----

    loadstate = LOADSTATE_DONE;

Exit:

    return( loadstate );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixSummaryInformation
//
// Synopsis:    Fix up the memory image of a SummaryInformation propset,
//              except for packing or padding problems (which are fixed
//              in _FixPackedPropertySet).
//
// Arguments:   [pcbstm]    - The size of the mapped stream.  This may
//                            be updated by this routine.
//              [pstatus]   - Pointer to NTSTATUS code.
//
// Returns:     None
//
//---------------------------------------------------------------------------

#define PID_THUMBNAIL	0x00000011  // SummaryInformation thumbnail property

VOID
CPropertySetStream::_FixSummaryInformation(IN OUT ULONG *pcbstm,
                                           OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER *psh;
    PROPERTYIDOFFSET *ppo, *ppoMax;

    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_FixSummaryInformation" );
    propTraceParameters(( "pcbstm=%p(%d)", pcbstm, *pcbstm ));

    // If this property set has multiple sections, then it's not one
    // of the ones we know how to fix in this routine.

    if (1 != _cSection) goto Exit;

    // Load pointers to the section header and the PID/Offset array.
    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) || NULL == psh ) goto Exit;

    //  Look for the MS Publisher problem.  Pub only writes
    //  a Thumbnail, but it sets the section size too short (by 4 bytes).
    //  Pub95 has the additional problem that it doesn't DWORD-align the
    //  section and stream size.  We fix both of these problems below.

    if (*pcbstm == _oSection + psh->cbSection + sizeof(ULONG))
    {
        // Look for the thumbnail property.

	for ( ; ppo < ppoMax; ppo++)
	{
	    if (ppo->propid == PID_THUMBNAIL)
	    {
		SERIALIZEDPROPERTYVALUE const *pprop;

                // If this property isn't properly aligned, then ignore it.

		if (ppo->dwOffset & (sizeof(DWORD) - 1))
		{
		    break;
		}

                // Get a pointer to the property.

		pprop = (SERIALIZEDPROPERTYVALUE *)
			    _MapOffsetToAddress(ppo->dwOffset);

                // Look specifically for the Publisher's Thumbnail property.
                // If this is a Publisher set, the lengths won't add
                // up correctly.  For the lengths to add up correctly,
                // the offset of the property, plus
                // the length of the thumbnail, plus the size of the VT
                // DWORD and the size of the length DWORD should be the
                // size of the Section.  But In the case of Publisher,
                // the section length is 4 bytes short.

		if (PropByteSwap(pprop->dwType) == VT_CF                // It's in a clipboard format
                    &&                                                  // For Windows
		    *(ULONG *) &pprop->rgb[sizeof(ULONG)] == PropByteSwap((ULONG)MAXULONG)
                    &&
		    ppo->dwOffset +                                     // And the lengths don't add up
			PropByteSwap( *(ULONG *) pprop->rgb ) +
			(3 - 2) * sizeof(ULONG) == psh->cbSection)
		{
                    // We've found the Publisher problem.

                    // For Pub95 files, we must dword-align the section
                    // and stream size.  We don't change the size of the underlying
                    // stream, however, just the mapping.  This is because if the caller
                    // doesn't make any explicit changes, we don't want the mapped Stream
                    // to be modified.  We do this step before fixing the section-size
                    // problem, so if it should fail we haven't touched anything.

                    if( !IsDwordAligned( *pcbstm ))
                    {
                        // Increase the size of the buffer, and reload the
                        // psh pointer.

                        *pcbstm += DwordRemain(*pcbstm);
    	                _MSTM(SetSize)(*pcbstm,             // The new size
                                       FALSE,               // Don't update the underlying stream
                                       (VOID **) &_pph,     // The new mapping
                                       pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // Align the section size.

                        psh->cbSection += DwordRemain(psh->cbSection);
                    }
                    else
                    {
                        // We don't need to adjust the size of the stream, but we
                        // do need to write to it (below to correct the section size).
                        // Until we call SetSize once, we don't know if the mapped stream
                        // is writable, so we'll call SetSize here to ensure that it is
                        // writable.

    	                _MSTM(SetSize)(*pcbstm,             // Reset the same size
                                       FALSE,               // Don't update the underlying stream
                                       (VOID **) &_pph,     // The new mapping
                                       pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    }

                    // Now correct the section size.

		    propDbg(( DEB_ITRACE,
			      "_FixSummaryInformation: Patch section size: %x->%x\n",
			      psh->cbSection, psh->cbSection + sizeof(ULONG)  ));

                    psh->cbSection += sizeof(ULONG);

		}   // if (pprop->dwType == VT_CF ...

		break;

	    }   // if (ppo->propid == PID_THUMBNAIL)
	}   // for ( ; ppo < ppoMax; ppo++)
    }   // if (cbstm == _oSection + psh->cbSection + sizeof(ULONG))

    // Look for the Excel 5.0a problem.
    // Excel 5.0a set the cbSection field to be 4 bytes too
    // high.  This code handles the more general case where the
    // cbSection is too long for the stream.  In such cases, if
    // all the properties actually fit within the stream, the
    // cbSection field is corrected.

    if (*pcbstm < _oSection + psh->cbSection)
    {
        // We'll fix this problem by adjusting the cbSection
        // value.  We have to be careful, though,
        // that the entire section fits within this new cbSection
        // value.  For efficiency, we'll just find the property
        // which is at the highest offset, and verify that it's
        // within the new section size.

        // Get what we think is the actual section length.
        ULONG cbSectionActual = *pcbstm - _oSection;

        ULONG dwHighestOffset = 0;
        ULONG cbProperty;

        // Find the property with the highest offset.

	for ( ; ppo < ppoMax; ppo++)
        {
            if( ppo->dwOffset > dwHighestOffset )
                dwHighestOffset = ppo->dwOffset;
        }

        // How long is this property?

        cbProperty = PropertyLengthNoEH(
                                     // Pointer to property
                        (SERIALIZEDPROPERTYVALUE *)
		            _MapOffsetToAddress(dwHighestOffset),
                                     // Bytes between above ptr & end of stream
                        *pcbstm - _oSection - dwHighestOffset,
                        0,           // Flags
                        pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Does this property fit within the section?  If so, then fix this
        // property set.

        if( dwHighestOffset + DwordAlign(cbProperty) <= cbSectionActual )
        {
            // Until we call SetSize once, we don't know if the mapped stream
            // is writable, so we'll call SetSize here to ensure that it is.

    	    _MSTM(SetSize)(*pcbstm,             // Reset the same size
                           FALSE,               // Don't update the underlying stream
                           (VOID **) &_pph,     // The new mapping
                           pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            // Fix the section size
            psh->cbSection = dwHighestOffset + DwordAlign(cbProperty);
        }
        else
        {
            StatusCorruption(pstatus, "SumInfo cbSection is too long for the Stream.");
        }

    }   // if (*pcbstm < _oSection + psh->cbSection)


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_FixSummaryInformation()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixPackedPropertySet
//
// Synopsis:    Align the memory image of a propset.
//
// Algorithm:   We need to move the properties within the
//              property set so that they are properly aligned,
//              and we need to adjust the PID/Offset array accordingly.
//              This is complicated by the fact that we may have to
//              grow some propertes (which are not properly padded
//              for alignement) and at the same time we may have to
//              shrink some properties (which are over-padded).
//
//              To handle these two constraints, and to
//              avoid growing the underlying stream any more
//              than necessary, we process the property set in
//              two phases.  In the Compaction phase, we shrink
//              properties which are over-padded.  In the Expansion
//              phase, we grow properties which are under-padded.
//              For example, say we have a property set with 3
//              properties, all of which should be 4 bytes.  But
//              say they are currently 2, 4, and 6 bytes.  Thus
//              we must grow the first property, hold the second
//              constant, and shrink the third property.  In this
//              example, after the Compaction phase, the 3 properties
//              will be 2, 4, and 4 bytes.  After the Expansion phase,
//              the properties will be 4, 4, and 4 bytes.
//
//              To do all of this, we make a copy of the PID/Offset
//              array (apoT) and sort it.  We then proceed to make
//              two arrays of just offsets (no PIDs) - aopropShrink
//              and aopropFinal.  aopropShrink holds the offset for
//              each property after the Compaction phase.  aopropFinal
//              holds the offset for each property after the
//              Expansion phase.  (Note that each of these phases
//              could be skipped if they aren't necessary.)
//
//              Finally, we perform the Compaction and Expansion,
//              using aopropShrink and aopropFinal, respectively,
//              as our guide.
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None
//---------------------------------------------------------------------------

int __cdecl fnOffsetCompare(VOID const *ppo1, VOID const *ppo2);

// DocumentSummaryInformation special case properties (w/packed vector elements)
#define PID_HEADINGPAIR 0x0000000c // heading pair (VT_VECTOR | VT_VARIANT):
					// {VT_LPSTR, VT_I4} pairs
#define PID_DOCPARTS	0x0000000d // docparts (VT_VECTOR | VT_LPSTR)
//#define PID_HLINKS	0x00000015 // hlinks vector

VOID
CPropertySetStream::_FixPackedPropertySet(OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    BOOLEAN fPacked = FALSE;
    BOOLEAN fDocSummaryInfo = FALSE;

    IFDBG( BOOLEAN fExpandDocSummaryInfo = FALSE );
    IFDBG( HRESULT &hr = *pstatus );

    PROPERTYSECTIONHEADER *psh = NULL;
    PROPERTYIDOFFSET *ppoT, *ppoTMax;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;

    PROPERTYIDOFFSET *apoT = NULL;

    ULONG *aopropShrink = NULL;
    ULONG *aopropFinal = NULL;
    ULONG cbprop;
    ULONG cCompact, cExpand;
    ULONG *poprop = NULL;

#if i386 == 0
    SERIALIZEDPROPERTYVALUE *ppropbuf = NULL;
    ULONG cbpropbuf = 0;
#endif

    ULONG cbtotal = 0;

    //  -----
    //  Begin
    //  -----

    propITrace( "CPropertySetStream::_FixPackedPropertySet" );
    *pstatus = STATUS_SUCCESS;

    // Determine if this is the first section of the DocSumInfo
    // property set.
    if ((_State & (CPSS_USERDEFINEDPROPERTIES | CPSS_DOCUMENTSUMMARYINFO)) ==
	 CPSS_DOCUMENTSUMMARYINFO)
    {
	fDocSummaryInfo = TRUE;
    }

    // Get pointers into this section's header.
    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // We know it's packed if the section-length isn't aligned.
    fPacked = !IsDwordAligned(psh->cbSection);

    // If we don't already know it's packed, check each of the properties in
    // the PID/Offset array to see if one is not properly aligned, if so we'll
    // assume that it's packed.  Also, if this is an Ansi DocSumInfo property set,
    // (first section), we'll assume that the HeadingPair and DocParts properties
    // are packed (vectors).

    if (!fPacked && psh != NULL)
    {
	for (ppo = ppoBase; ppo < ppoMax; ppo++)
	{
	    if ( !IsDwordAligned(ppo->dwOffset)
                 ||
		 ( fDocSummaryInfo
                   &&
                   _CodePage != CP_WINUNICODE
                   &&
		   ( ppo->propid == PID_HEADINGPAIR
                     ||
		     ppo->propid == PID_DOCPARTS
                   )
                 )
               )
	    {
		fPacked = TRUE;
		break;
	    }
	}
    }

    //  ----------------------------------------------------
    //  Fix the properties if they are packed or if there is
    //  unnecessary padding.
    //  ----------------------------------------------------

    // If we know there's a problem, set a _State flag
    // now.  If we can fix the problem below, we'll clear it.
    // Otherwise, the rest of the Class will know that there's
    // an unresolved problem.

    if (fPacked)
    {
	propDbg(( DEB_ITRACE, "_FixPackedPropertySet: packed properties\n" ));
        _State |= CPSS_PACKEDPROPERTIES;
    }


    //  ---------------------------------------------------------
    //  Create apoT (a sorted array of PID/Offsets), aopropShrink
    //  (the offsets for the Compaction phase) and aopropFinal
    //  (the offsets for the Expansion phase).
    //  ---------------------------------------------------------

    // Create a buffer for a temporary PID/Offset array.

    apoT = reinterpret_cast<PROPERTYIDOFFSET*>
           ( CoTaskMemAlloc( sizeof(PROPERTYIDOFFSET) * (psh->cProperties + 1) ));
    if (apoT == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Copy the PID/offset pairs from the property set to the
    // temporary PID/Offset array.

    RtlCopyMemory(
	    apoT,
	    psh->rgprop,
	    psh->cProperties * CB_PROPERTYIDOFFSET);

    // Mark the end of the temporary array.

    ppoTMax = apoT + psh->cProperties;
    ppoTMax->propid = PID_ILLEGAL;
    ppoTMax->dwOffset = psh->cbSection;

    // Sort the PID/Offset array by offset and check for overlapping values:

    qsort(apoT, psh->cProperties, sizeof(apoT[0]), &fnOffsetCompare);

    // Create two arrays which will hold property offsets.
    // aopropShrink holds the offsets for the Compaction phase where
    // we shrink the property set.  aopropFinal holds the offsets
    // of the final property set, which will be achieved in the
    // Expansion phase.

    aopropShrink = reinterpret_cast<ULONG*>
                   ( CoTaskMemAlloc( sizeof(ULONG) *(psh->cProperties + 1) ));
    if (aopropShrink == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    aopropFinal = reinterpret_cast<ULONG*>
                  ( CoTaskMemAlloc( sizeof(ULONG)*(psh->cProperties + 1) ));
    if (aopropFinal == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

#if i386 == 0
    // On non-x86 machines, we can't directly access unaligned
    // properties.  So, allocate enough (aligned) memory to hold
    // the largest unaligned property.  We'll copy properties here
    // when we need to access them.

    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
    {
	if (!IsDwordAligned(ppoT->dwOffset))
	{
	    cbprop = DwordAlign(ppoT[1].dwOffset - ppoT->dwOffset);
	    if (cbpropbuf < cbprop)
	    {
		cbpropbuf = cbprop;
	    }
	}
    }

    if (cbpropbuf != 0)
    {
	ppropbuf = (SERIALIZEDPROPERTYVALUE *) CoTaskMemAlloc( cbpropbuf );
	if (ppropbuf == NULL)
	{
	    *pstatus = STATUS_NO_MEMORY;
            goto Exit;
	}
    }
#endif  // i386==0


    //  ----------------------------------------------
    //  Iterate through the properties, filling in the
    //  entries of aopropShrink and aopropFinal.
    //  ----------------------------------------------

    // We'll also count the number of compacts and expands
    // necessary.

    aopropShrink[0] = aopropFinal[0] = apoT[0].dwOffset;
    PROPASSERT(IsDwordAligned(aopropShrink[0]));
    cExpand = 0;
    cCompact = 0;

    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
    {
	SERIALIZEDPROPERTYVALUE *pprop;
	BOOLEAN fDocSumLengthComputed = FALSE;
        ULONG cbpropOriginal;

        // Validate the property's offset

        if( ppoT->dwOffset >= psh->cbSection )
        {
            StatusCorruption(pstatus, "Property's offset is too long for the section.");
            goto Exit;
        }

        // How much space does the property take up in the current
        // property set?

	cbpropOriginal = cbprop = ppoT[1].dwOffset - ppoT->dwOffset;
	pprop = (SERIALIZEDPROPERTYVALUE *)
		    _MapOffsetToAddress(ppoT->dwOffset);

#if i386 == 0
        // If necessary, put this property into an aligned buffer.

	if (!IsDwordAligned(ppoT->dwOffset))
	{
	    propDbg(( DEB_ITRACE, "_FixPackedPropertySet: unaligned pid=%x off=%x\n",
		                   ppoT->propid, ppoT->dwOffset ));
	    PROPASSERT(DwordAlign(cbprop) <= cbpropbuf);

	    RtlCopyMemory((VOID *) ppropbuf, pprop, cbprop);
	    pprop = ppropbuf;
	}
#endif
        // Calculate the actual length of this property, including
        // the necessary padding.  This might be bigger than the
        // property's current length (if the propset wasn't properly
        // padded), and it might be smaller than the property's current
        // length (if the propset was over-padded).

	if (ppoT->propid == PID_DICTIONARY)
	{
            // Get the size of the dictionary.

	    cbprop = DwordAlign(_DictionaryLength(
				    (DICTIONARY const *) pprop,
				    cbprop,
                                    pstatus));
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	}
	else
	{
	    ULONG cbpropT;

            // Ansi DocSumInfo property sets have two vector properties
            // which are packed.  If this is one of those properties,
            // we won't fix it yet, but we'll compute the size required
            // when the elements are un-packed.

	    if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
	    {
		if (ppoT->propid == PID_HEADINGPAIR)
		{
		    fDocSumLengthComputed = _FixHeadingPairVector(
					    PATCHOP_COMPUTESIZE,
					    pprop,
					    &cbpropT);
		}
		else
		if (ppoT->propid == PID_DOCPARTS)
		{
		    fDocSumLengthComputed = _FixDocPartsVector(
					    PATCHOP_COMPUTESIZE,
					    pprop,
					    &cbpropT);
		}
	    }

            // If we computed a length above, use it, otherwise calculate
            // the length using the standard rules (we've already checked
            // for the special cases).

	    if (fDocSumLengthComputed)
	    {
		cbprop = cbpropT;
#if DBGPROP
		fExpandDocSummaryInfo = TRUE;
#endif
	    }
	    else
	    {
		cbprop = PropertyLengthNoEH(pprop, DwordAlign(cbprop), 0, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    }

	}   // if (ppoT->propid == PID_DICTIONARY) ... else

	PROPASSERT(IsDwordAligned(cbprop));

        // Now that we know the actual cbprop, use it to update the
        // *next* entry in the two arrays of correct offsets.
        //
        // We want aopropFinal to hold the final, correct offsets,
        // so we'll use cbprop to calculate this array.
        // But for aopropShrink, we only want it to differ from
        // the original array (apoT) when a property is shrinking,
        // so we'll use min(cbNew,cbOld) for this array.

        poprop = &aopropShrink[ ppoT - apoT ]; // 1st do aopropShrink
        poprop[1] = poprop[0] + min(cbprop, cbpropOriginal);

        poprop = &aopropFinal[ ppoT - apoT ];  // 2nd do aopropFinal
        poprop[1] = poprop[0] + cbprop;

	propDbg(( DEB_ITRACE, "_FixPackedPropertySet: pid=%x off=%x->%x\n",
	          ppoT->propid, ppoT->dwOffset, poprop[0],
	          poprop[0] < ppoT->dwOffset? " (compact)" : poprop[0] > ppoT->dwOffset? " (expand)" : "" ));


        // Is this compaction or an expansion?
        // If we computed the doc-sum length, we count it as
        // an expansion, even if the total property size didn't change,
        // because we need the expand the elements within the vector.

	if (cbprop < cbpropOriginal)
	{
	    cCompact++;
	}
	else
	if (cbprop > cbpropOriginal || fDocSumLengthComputed)
	{
	    cExpand++;
	}
    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++)


    //  -------------------------------
    //  Compact/Expand the Property Set
    //  -------------------------------

    // We've now generated the complete aopropShrink and aopropFinal
    // offset arrays.  Now, if necessary, let's expand and/or compact
    // the property set to match these offsets.

    if (cExpand || cCompact)
    {
	ULONG cbstm;
	LONG cbdelta;

	cbstm = _oSection + psh->cbSection + _cbTail;
	cbdelta = aopropFinal[psh->cProperties] - psh->cbSection;

        // We may not have a writable mapped stream.  Do a SetSize on it
        // to ensure that we do.

	_MSTM(SetSize)(
		cbstm,
                FALSE,   // Not persistent
		(VOID **) &_pph,
                pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Always reload after obtaining a new _pph.
	psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;


        propDbg(( DEB_ITRACE, "_FixPackedPropertySet: cbstm=%x cbdelta=%x cexpand=%x ccompact=%x\n",
	                                              cbstm,   cbdelta,   cExpand,   cCompact ));

        //  -----------------------------
        //  Grow the Stream if necessary.
        //  -----------------------------

        if (cbdelta > 0)
	{
            propDbg(( DEB_ITRACE, "SetSize(%x) _FixPackedPropertySet grow %x bytes\n",
		                   cbstm + cbdelta, cbdelta ));

            // On the set-size, say that this is a non-persistent
            // change, so that the underlying Stream isn't modified.
            // At this point, we don't know if this change should remain
            // permanent (if the caller closes without making any changes
            // the file should remain un-changed).

	    _MSTM(SetSize)(
		    cbstm + cbdelta,
                    FALSE,   // Not persistent
		    (VOID **) &_pph,
                    pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // reload all pointers into mapped image:

	    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // If there's another section after this one, move it back
	    // to the end of the stream now, which will create room for
            // our expansion.

	    if (_cbTail != 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"_FixPackedPropertySet(_cbTail:grow)",
			psh,
			Add2Ptr(pvSrc, cbdelta),
			pvSrc,
			_cbTail);
	    }
	}   // if (cbdelta > 0)

        // This previous step (growing the Stream), was the last one which can
        // fail.  We're about to modify the actual property set (we've been
        // working only with temporary buffers so far).  So we're always guaranteed
        // a good property set, or the original set, we'll never end up with a
        // half-updated set.


        //  ----------------
        //  Compaction Phase
        //  ----------------

        // Compact the property set if necessary.  I.e., adjust
        // the property set buffer so that it matches aopropShrink.

        if (cCompact > 0)
	{
	    // Start at the beginning and move each property up.

	    poprop = aopropShrink;
	    for (ppoT = apoT; ppoT < ppoTMax; ppoT++, poprop++)
	    {
		if (*poprop != ppoT->dwOffset)
		{
		    PROPASSERT(*poprop < ppoT->dwOffset);
		    PROPASSERT(poprop[1] > *poprop);

		    // We're compacting; the property should not grow!

		    PROPASSERT(
			poprop[1] - *poprop <=
			ppoT[1].dwOffset - ppoT->dwOffset);

		    PropMoveMemory(
			    "_FixPackedPropertySet(compact)",
			    psh,
			    Add2Ptr(psh, *poprop),
			    Add2Ptr(psh, ppoT->dwOffset),
			    poprop[1] - *poprop);
		}
	    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++, poprop++)
	}   // if (cCompact > 0)


        //  ---------------
        //  Expansion phase
        //  ---------------

        // Recall that, whether or not we just did a compaction, aopropShrink
        // holds the property set offsets as they currently exist in the
        // property set.

        if (cExpand > 0)
        {
	    // Start at the end and move each property back.
            // The 'poprop' gives us the final correct offset
            // of the current property.

            LONG lOffsetIndex;
	    poprop = &aopropFinal[psh->cProperties - 1];

            // Start at the second-to-last entry in the arrays of offsets
            // (the last entry is an artificially added one to mark the end of the
            // property set).

	    for (lOffsetIndex = (LONG)(ppoTMax - apoT - 1), ppoT = ppoTMax - 1;
                 lOffsetIndex >=0;
                 lOffsetIndex--, poprop--, ppoT--)
	    {
                // Get a pointer to the final location of this
                // property.

		SERIALIZEDPROPERTYVALUE *pprop;
		pprop = (SERIALIZEDPROPERTYVALUE *)
			    Add2Ptr(psh, *poprop);

		if (*poprop != aopropShrink[ lOffsetIndex ])
		{
		    ULONG cbCopy, cbOld;
			
		    PROPASSERT(*poprop > aopropShrink[ lOffsetIndex ]);
		    PROPASSERT(poprop[1] > *poprop);
                    PROPASSERT(aopropShrink[ lOffsetIndex+1 ] > aopropShrink[ lOffsetIndex ]);

                    // How many bytes should we copy?  The minimum size of the property
                    // calculated using the old and new offsets.

		    cbCopy = poprop[1] - poprop[0];
		    cbOld = aopropShrink[ lOffsetIndex+1 ]
                            - aopropShrink[ lOffsetIndex+0 ];

		    if (cbCopy > cbOld)
		    {
			cbCopy = cbOld;
		    }

                    // Copy the property from its old location
                    // (psh+aopropShrink[lOffsetIndex]) to its new location
                    // (pprop == psh+*poprop).

                    propDbg(( DEB_ITRACE,
                              "_FixPackedPropertySet:move pid=%x off=%x->%x "
                              "cb=%x->%x cbCopy=%x z=%x @%x\n",
                              ppoT->propid, ppoT->dwOffset, *poprop,
                              cbOld, poprop[1] - *poprop, cbCopy, DwordRemain(cbCopy), _MapAddressToOffset(Add2Ptr(pprop, cbCopy))));

		    PropMoveMemory(
			    "_FixPackedPropertySet(expand)",
			    psh,
			    pprop,
			    Add2Ptr(psh, aopropShrink[ lOffsetIndex ]),
			    cbCopy);
		    RtlZeroMemory(
			    Add2Ptr(pprop, cbCopy),
			    DwordRemain(cbCopy));

		}   // if (*poprop != ppoT->dwOffset)

                // If this is an older DocSumInfo property set,
                // and this property is one of the vector values,
                // we must expand the vector elements now that we've
                // room for it.

		if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
		{
		    ULONG cbpropT;

		    if (ppoT->propid == PID_HEADINGPAIR)
		    {
			_FixHeadingPairVector(
					PATCHOP_EXPAND,
					pprop,
					&cbpropT);
		    }
		    else
		    if (ppoT->propid == PID_DOCPARTS)
		    {
			_FixDocPartsVector(
					PATCHOP_EXPAND,
					pprop,
					&cbpropT);
		    }
		}   // if (fDocSummaryInfo)
	    }   // for (ppoT = ppoTMax; --ppoT >= apoT; popropNew--)
	}   // if (cExpand != 0)



        //  ---------------------------------------------------------
	//  Patch the section size and the moved properties' offsets.
        //  ---------------------------------------------------------

	DebugTrace(0, DEBTRACE_PROPPATCH, (
	    "_FixPackedPropertySet: Patch section size %x->%x\n",
	    psh->cbSection,
	    psh->cbSection + cbdelta));

	psh->cbSection += cbdelta;

        // Iterate through the original PID/Offset array to update the
        // offsets.

	for (ppo = ppoBase; ppo < ppoMax; ppo++)
	{
            // Search the temporary PID/Offset array (which has the updated
            // offsets) for ppo->propid.

	    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
	    {
		if (ppo->propid == ppoT->propid)
		{
                    // We've found ppo->propid in the temporary PID/Offset
                    // array.  Copy the offset value from the temporary array
                    // to the actual array in the property set.

		    PROPASSERT(ppo->dwOffset == ppoT->dwOffset);
		    ppo->dwOffset = aopropFinal[ppoT - apoT];
#if DBGPROP
		    if (ppo->dwOffset != ppoT->dwOffset)
		    {
                        propDbg(( DEB_ITRACE,
                                  "_FixPackedPropertySet: Patch propid %x offset=%x->%x\n",
			          ppo->propid, ppoT->dwOffset, ppo->dwOffset ));
		    }
#endif
		    break;

		}   // if (ppo->propid == ppoT->propid)
	    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
	}   // for (ppo = ppoBase; ppo < ppoMax; ppo++)

        //  ------------
        //  Fix the tail
        //  ------------


        // If we have a tail, fix it's offset in the FmtID/Offset
        // array.  Also, if we've overall shrunk this section, bring
        // the tail in accordingly.

        if (_cbTail != 0)
	{
	    if (cbdelta < 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"_FixPackedPropertySet(_cbTail:shrink)",
			psh,
			Add2Ptr(pvSrc, cbdelta),
			pvSrc,
			_cbTail);
	    }

	    _PatchSectionOffsets(cbdelta);

	}   // if (_cbTail != 0)


        // If we get to this point we've successfully un-packed (or
        // un-over-padded) the property set, so we can clear the
        // state flag.

	_State &= ~CPSS_PACKEDPROPERTIES;

    }   // if (cExpand || cCompact)


    //  ----
    //  Exit
    //  ----

Exit:

    CoTaskMemFree( apoT );
    CoTaskMemFree( aopropShrink );
    CoTaskMemFree( aopropFinal );

#if i386 == 0
    CoTaskMemFree( (BYTE *) ppropbuf );
#endif // i386

}   // CPropertySetStream::_FixPackedPropertySet()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixDocPartsVector
//
// Synopsis:    Align the memory image of a DocParts vector
//              The DocParts property is part of the DocSumInfo
//              property set (first section).  It is a vector
//              of strings, and in Ansi property sets it's packed
//              and must be un-packed.
//
// Arguments:	[PatchOp]	-- patch request
//		[pprop]         -- property value to be patched or sized
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if property type and all elements meet expectations;
//		FALSE on error
//
// Note:	Operate on a DocumentSummaryInformation first section property,
//		PID_DOCPARTS.  This property is assumed to be an array of
//		VT_LPSTRs.
//
//		PATCHOP_COMPUTESIZE merely computes the size required to unpack
//		the property, and must assume it is currently unaligned.
//
//		PATCHOP_ALIGNLENGTHS patches all VT_LPSTR lengths to DWORD
//		multiples, and may rely on the property already being aligned.
//
//		PATCHOP_EXPAND expands the property from the Src to Dst buffer,
//		moving elements to DWORD boundaries, and patching VT_LPSTR
//		lengths to DWORD multiples.  The Src buffer is assumed to be
//		unaligned, and the Dst buffer is assumed to be properly sized.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixDocPartsVector(
    IN PATCHOP PatchOp,
    IN OUT SERIALIZEDPROPERTYVALUE *pprop,
    OUT ULONG *pcbprop)
{
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pprop != NULL);
    PROPASSERT(pcbprop != NULL);

    // If the property is a variant vector,
    // it's in an ANSI property set, and
    // there are an even number of elements, ...

    if ( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_LPSTR)
         &&
         _CodePage != CP_WINUNICODE)
    {
	ULONG cString;
	VOID *pv;

	cString = PropByteSwap( *(DWORD *) pprop->rgb );
	pv = Add2Ptr(pprop->rgb, sizeof(DWORD));

	if (_FixDocPartsElements(PatchOp, cString, pv, pv, pcbprop))
	{
	    *pcbprop += CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);
	    return(TRUE);
	}
    }
    return(FALSE);	// Not a recognizable DocParts vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixDocPartsElements
//
// Synopsis:    Recursively align the memory image of DocParts elements
//
// Arguments:	[PatchOp]	-- patch request
//		[cString]	-- count of strings remaining in the vector
//		[pvDst]		-- aligned overlapping destination buffer
//		[pvSrc]		-- unaligned overlapping source buffer
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if all remaining elements meet expectations;
//		FALSE on error
//
// Note:        The pvDst & pvSrc buffers must be in property-set
//              byte order (little endian).
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixDocPartsElements(
    IN PATCHOP PatchOp,
    IN ULONG cString,
    OUT VOID *pvDst,
    IN VOID UNALIGNED const *pvSrc,
    OUT ULONG *pcbprop)
{
    ULONG cb;
    PROPERTYSECTIONHEADER UNALIGNED *psh = _GetSectionHeader();

    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pvDst >= pvSrc);
    PROPASSERT(PatchOp != PATCHOP_ALIGNLENGTHS || pvDst == pvSrc);

    if (cString == 0)
    {
	*pcbprop = 0;
	return(TRUE);
    }
    cb = sizeof(DWORD) + PropByteSwap( *(DWORD UNALIGNED *) pvSrc );

    // Validate the source

    if( Add2ConstPtr( psh, psh->cbSection )
        <
        Add2ConstPtr( pvSrc, cb ))
    {
            return FALSE;
    }


    // If the caller serialized the vector properly, all we need to do is
    // to round up the string lengths to DWORD multiples, so readers that
    // treat these vectors as byte-aligned get faked out.  We expect
    // readers will not have problems with a DWORD aligned length, and a
    // '\0' character a few bytes earlier than the length indicates.

    if (PatchOp == PATCHOP_ALIGNLENGTHS)
    {
	cb = DwordAlign(cb);	// Caller says it's already aligned
    }
    if (_FixDocPartsElements(
		PatchOp,
		cString - 1,
		Add2Ptr(pvDst, DwordAlign(cb)),
		(VOID UNALIGNED const *)Add2ConstPtr(pvSrc, cb),
		pcbprop))
    {
	*pcbprop += DwordAlign(cb);

	if (PatchOp == PATCHOP_EXPAND)
	{
	    PropMoveMemory(
		    "_FixDocPartsElements",
		    _GetSectionHeader(),
		    pvDst,
		    pvSrc,
		    cb);
	    RtlZeroMemory(Add2Ptr(pvDst, cb), DwordRemain(cb));

	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"_FixDocPartsElements: Move(%x:%s) "
		    "cb=%x->%x off=%x->%x z=%x @%x\n",
		cString,
		Add2Ptr(pvDst, sizeof(ULONG)),
		cb - sizeof(ULONG),
		DwordAlign(cb) - sizeof(ULONG),
		_MapAddressToOffset((void const *)pvSrc),
		_MapAddressToOffset(pvDst),
		DwordRemain(cb),
		_MapAddressToOffset(Add2Ptr(pvDst, cb))));
	}
	if (PatchOp != PATCHOP_COMPUTESIZE)
	{
	    PROPASSERT(
		PatchOp == PATCHOP_ALIGNLENGTHS ||
		PatchOp == PATCHOP_EXPAND);

	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"_FixDocPartsElements: Patch(%x:%s) cb=%x->%x\n",
		cString,
		Add2Ptr(pvDst, sizeof(ULONG)),
		*(ULONG *) pvDst,
		DwordAlign(*(ULONG *) pvDst)));

	    *(ULONG *) pvDst = PropByteSwap( (ULONG) DwordAlign( PropByteSwap( *(ULONG *) pvDst )));
	}
	return(TRUE);
    }
    return(FALSE);	// Not a recognizable DocParts vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixHeadingPairVector
//
// Synopsis:    Align the memory image of a HeadingPair vector.
//              The HeadingPair property is part of the DocSumInfo
//              property set (first section).  It's a vector of
//              Variants, where the elements are alternating
//              strings and I4s (the string is a heading name,
//              and the I4 is the count of DocumentParts in that
//              heading).  In Ansi property sets, these elements
//              are packed, and must be un-packed.
//
// Arguments:	[PatchOp]	-- patch request
//		[pprop]         -- property value to be patched or sized
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if property and all elements meet expectations;
//		FALSE on error
//
// Note:	Operate on a DocumentSummaryInformation first section property,
//		PID_HEADINGPAIR.  This property is assumed to be an array of
//		VT_VARIANTs with an even number of elements.  Each pair must
//		consist of a VT_LPSTR followed by a VT_I4.
//
//		PATCHOP_COMPUTESIZE merely computes the size required to unpack
//		the property, and must assume it is currently unaligned.
//
//		PATCHOP_ALIGNLENGTHS patches all VT_LPSTR lengths to DWORD
//		multiples, and may rely on the property already being aligned.
//
//		PATCHOP_EXPAND expands the property from the Src to Dst buffer,
//		moving elements to DWORD boundaries, and patching VT_LPSTR
//		lengths to DWORD multiples.  The Src buffer is assumed to be
//		unaligned, and the Dst buffer is assumed to be properly sized.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixHeadingPairVector(
    IN PATCHOP PatchOp,
    IN OUT SERIALIZEDPROPERTYVALUE *pprop,
    OUT ULONG *pcbprop)
{
    ULONG celem;
    ULONG cbprop = 0;

    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pprop != NULL);
    PROPASSERT(pcbprop != NULL);

    // If the property is a variant vector, and
    // there are an even number of elements, ...

    if( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_VARIANT)
        &&
	( (celem = PropByteSwap(*(ULONG *) pprop->rgb) ) & 1) == 0
        &&
        _CodePage != CP_WINUNICODE)
    {
	pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr(pprop->rgb, sizeof(ULONG));

	if (_FixHeadingPairElements(PatchOp, celem/2, pprop, pprop, pcbprop))
	{
	    *pcbprop += CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);
	    return(TRUE);
	}
    }
    return(FALSE);	// Not a recognizable HeadingPair vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixHeadingPairElements
//
// Synopsis:    Recursively align the memory image of HeadingPair elements
//
// Arguments:	[PatchOp]	-- patch request
//		[cPairs]	-- count of heading pairs remaining
//		[ppropDst]	-- aligned overlapping destination buffer
//		[ppropSrc]	-- unaligned overlapping source buffer
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if all remaining elements meet expectations;
//		FALSE on error
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixHeadingPairElements(
    IN PATCHOP PatchOp,
    IN ULONG cPairs,
    OUT SERIALIZEDPROPERTYVALUE *ppropDst,
    IN SERIALIZEDPROPERTYVALUE UNALIGNED const *ppropSrc,
    OUT ULONG *pcbprop)
{
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(ppropDst >= ppropSrc);
    PROPASSERT(PatchOp != PATCHOP_ALIGNLENGTHS || ppropDst == ppropSrc);

    if (cPairs == 0)
    {
	*pcbprop = 0;
	return(TRUE);
    }

    // If the first element of the pair is a VT_LPSTR, ...

    if( PropByteSwap(ppropSrc->dwType) == VT_LPSTR )
    {
	ULONG cb;

	// Compute size of the string element.

	cb = CB_SERIALIZEDPROPERTYVALUE
             +
             sizeof(ULONG)
             +
             PropByteSwap( *(DWORD UNALIGNED *) ppropSrc->rgb );

	// If the caller serialized the vector properly, all we need to do is
	// to round up the string lengths to DWORD multiples, so readers that
	// treat these vectors as byte-aligned get faked out.  We expect
	// readers will not have problems with a DWORD aligned length, and a
	// '\0' character a few bytes earlier than the length indicates.

	if (PatchOp == PATCHOP_ALIGNLENGTHS)
	{
	    cb = DwordAlign(cb);	// Caller says it's already aligned
	}

	// and if the second element of the pair is a VT_I4, ...

	if ( PropByteSwap( (DWORD) VT_I4 )
             ==
             ( (SERIALIZEDPROPERTYVALUE UNALIGNED const *)
               Add2ConstPtr(ppropSrc, cb)
             )->dwType )
	{
	    cb += CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD);

	    if (_FixHeadingPairElements(
			    PatchOp,
			    cPairs - 1,
			    (SERIALIZEDPROPERTYVALUE *)
				    Add2Ptr(ppropDst, DwordAlign(cb)),
			    (SERIALIZEDPROPERTYVALUE UNALIGNED const *)
				    Add2ConstPtr(ppropSrc, cb),
			    pcbprop))
	    {
		*pcbprop += DwordAlign(cb);

		if (PatchOp == PATCHOP_EXPAND)
		{
		    // Move the unaligned VT_I4 property back in memory to an
		    // aligned boundary, move the string back to a (possibly
		    // different) aligned boundary, zero the space in between
		    // the two and patch the string length to be a DWORD
		    // multiple to fake out code that expects vector elements
		    // to be byte aligned.

		    // Adjust byte count to include just the string element.

		    cb -= CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);

		    // Move the VT_I4 element.

		    PropMoveMemory(
			    "_FixHeadingPairElements:I4",
			    _GetSectionHeader(),
			    Add2Ptr(ppropDst, DwordAlign(cb)),
			    Add2ConstPtr(ppropSrc, cb),
			    CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG));

		    // Move the VT_LPSTR element.

		    PropMoveMemory(
			    "_FixHeadingPairElements:LPSTR",
			    _GetSectionHeader(),
			    ppropDst,
			    ppropSrc,
			    cb);

		    // Zero the space in between.

		    RtlZeroMemory(Add2Ptr(ppropDst, cb), DwordRemain(cb));

		    DebugTrace(0, DEBTRACE_PROPPATCH, (
		        "_FixHeadingPairElements: Move(%x:%s) "
			    "cb=%x->%x off=%x->%x z=%x @%x\n",
		        cPairs,
		        &ppropDst->rgb[sizeof(ULONG)],
		        PropByteSwap( *(ULONG *) ppropDst->rgb ),
		        DwordAlign(PropByteSwap( *(ULONG *) ppropDst->rgb )),
		        _MapAddressToOffset(ppropSrc),
		        _MapAddressToOffset(ppropDst),
		        DwordRemain(cb),
		        _MapAddressToOffset(Add2Ptr(ppropDst, cb))));
		}

		if (PatchOp != PATCHOP_COMPUTESIZE)
		{
		    PROPASSERT(
			PatchOp == PATCHOP_ALIGNLENGTHS ||
			PatchOp == PATCHOP_EXPAND);
#ifdef DBGPROP
		    SERIALIZEDPROPERTYVALUE const *ppropT =
			(SERIALIZEDPROPERTYVALUE const *)
			    Add2Ptr(ppropDst, DwordAlign(cb));
#endif
		    DebugTrace(0, DEBTRACE_PROPPATCH, (
			"_FixHeadingPairElements: Patch(%x:%s) "
			    "cb=%x->%x, vt=%x, %x\n",
			cPairs,
			&ppropDst->rgb[sizeof(ULONG)],
			PropByteSwap( *(ULONG *) ppropDst->rgb ),
			DwordAlign( PropByteSwap( *(ULONG *) ppropDst->rgb )),
			PropByteSwap( ppropT->dwType ),
			PropByteSwap( *(ULONG *) ppropT->rgb )));

		    // Patch the string length to be a DWORD multiple.

		    *(ULONG *) ppropDst->rgb
                        = PropByteSwap( (ULONG) DwordAlign( PropByteSwap( *(ULONG *) ppropDst->rgb )));
		}
		return(TRUE);
	    }
	}
    }
    return(FALSE);	// Not a recognizable HeadingPair vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertySet
//
// Synopsis:    Return the classid for the property set code
//
// Arguments:   [pspss]         -- pointer to buffer for output
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::QueryPropertySet(OUT STATPROPSETSTG *pspss,
                                     OUT NTSTATUS       *pstatus) const
{
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::QueryPropertySet" );
    propTraceParameters(( "pspss=%p", pspss ));

    if ((_State & CPSS_USERDEFINEDDELETED) || _cSection < 1)
    {
	StatusAccessDenied(pstatus, "QueryPropertySet: deleted or no section");
        goto Exit;
    }
    _MSTM(QueryTimeStamps)(
                pspss,
                (BOOLEAN) ((_Flags & CREATEPROP_NONSIMPLE) != 0));
    pspss->clsid = _pph->clsid;
    pspss->fmtid = _GetFormatidOffset(
			    (_State & CPSS_USERDEFINEDPROPERTIES)? 1 : 0)->fmtid;
    pspss->grfFlags = _CodePage == CP_WINUNICODE?
    PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetClassId
//
// Synopsis:    Set the classid for the property set code
//
// Arguments:   [pclsid]        -- pointer to new ClassId
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::SetClassId(IN GUID const *pclsid,
                               OUT NTSTATUS  *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::SetClassId" );
    propTraceParameters(( "clsid=%s", static_cast<const char*>(CStringize(*pclsid)) ));

    if (IsReadOnlyPropertySet(_Flags, _State))
    {
	StatusAccessDenied(pstatus, "SetClassId: deleted or read-only");
        goto Exit;
    }

    _SetModified(pstatus);
    if( !NT_SUCCESS(*pstatus) )
    {
        TraceStatus("SetClassId: couldn't SetModified");
        goto Exit;
    }

    _pph->clsid = *pclsid;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::EnumeratePropids
//
// Synopsis:    enumerates the property ids in a prop set
//
// Arguments:   [pkey]     -- pointer to bookmark (0 implies beginning)
//              [pcprop]   -- on input: size; on output: # of props returned.
//              [apropids] -- output buffer
//              [pstatus]  -- pointer to NTSTATUS code
//
// Returns:     TRUE if more properties are available
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::EnumeratePropids(
    IN OUT ULONG *pkey,
    IN OUT ULONG  *pcprop,
    OPTIONAL OUT PROPID *apropids,
    OUT NTSTATUS *pstatus)
{
    PROPERTYIDOFFSET *ppo, *ppoStart, *ppoMax;
    ULONG cprop = 0;
    BOOLEAN fMorePropids = FALSE;
    PROPID propidPrev = *pkey;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::EnumeratePropids" );
    propTraceParameters(( "pkey=%p(%d), pcprop=%p(%d), apropids=%p",
                           pkey,*pkey,  pcprop,&pcprop, apropids ));

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "EnumeratePropids: deleted");
        goto Exit;
    }

    if (_LoadPropertyOffsetPointers(&ppoStart, &ppoMax, pstatus) == NULL)
    {
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }
    else
    {
        if (propidPrev != 0)    // if not first call, start w/last propid
        {
            for (ppo = ppoStart; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == propidPrev)
                {
                    ppoStart = ++ppo;
                    break;
                }
            }
        }
        for (ppo = ppoStart; ppo < ppoMax; ppo++)
        {
            if (ppo->propid != PID_DICTIONARY &&
                ppo->propid != PID_CODEPAGE &&
                ppo->propid != PID_LOCALE &&
                ppo->propid != PID_BEHAVIOR)
            {
                if (cprop >= *pcprop)
                {
                    fMorePropids = TRUE;
                    break;
                }
                if (apropids != NULL)
                {
                    apropids[cprop] = ppo->propid;
                }
                cprop++;
                propidPrev = ppo->propid;
            }
        }
    }
    *pkey = propidPrev;
    *pcprop = cprop;

    //  ----
    //  Exit
    //  ----

Exit:

    return(fMorePropids);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadPropertyOffsetPointers
//
// Synopsis:    Load start and (past) end pointers to PROPERTYIDOFFSET array
//
// Arguments:   [pppo]          -- pointer to base of PROPERTYIDOFFSET array
//              [pppoMax]       -- pointer past end of PROPERTYIDOFFSET array
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     Pointer to Section Header, NULL if section not present
//              or if there was an error.
//---------------------------------------------------------------------------

PROPERTYSECTIONHEADER *
CPropertySetStream::_LoadPropertyOffsetPointers(
    OUT PROPERTYIDOFFSET **pppo,
    OUT PROPERTYIDOFFSET **pppoMax,
    OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER *psh = NULL;
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());

    if (_cSection != 0)
    {
        psh = _GetSectionHeader();
        ULONG cbstm = _MSTM(GetSize)(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Ensure that we can read all of the PID/Offset
        // table.

        if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER ||
            cbstm < _oSection + CB_PROPERTYSECTIONHEADER +
                psh->cProperties * CB_PROPERTYIDOFFSET)
        {
            StatusCorruption(pstatus, "LoadPropertyOffsetPointers: stream size");
            goto Exit;
        }

        *pppo = psh->rgprop;
        *pppoMax = psh->rgprop + psh->cProperties;
    }

    //  ----
    //  Exit
    //  ----

Exit:
    if( !NT_SUCCESS(*pstatus) )
        psh = NULL;
    else if( NULL == psh )
        // This should never happen.
        *pstatus = STATUS_INTERNAL_DB_CORRUPTION;

    return(psh);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadProperty
//
// Synopsis:    return a pointer to the specified property value
//
// Arguments:   [propid]        -- property id for property
//              [pcbprop]       -- pointer to return property size, 0 on error
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     SERIALIZEDPROPERTYVALUE * -- NULL if not present
//---------------------------------------------------------------------------

SERIALIZEDPROPERTYVALUE *
CPropertySetStream::_LoadProperty(
    IN PROPID propid,
    OUT OPTIONAL ULONG *pcbprop,
    OUT NTSTATUS *pstatus )
{
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;
    SERIALIZEDPROPERTYVALUE *pprop = NULL;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (psh != NULL)
    {
        for (ppo = ppoBase; ppo < ppoMax; ppo++)
        {
            if (IsDwordAligned(ppo->dwOffset)
                &&
                ppo->dwOffset >= CB_PROPERTYSECTIONHEADER
                                 +
                                 psh->cProperties * CB_PROPERTYIDOFFSET
                &&
                psh->cbSection >= ppo->dwOffset + CB_SERIALIZEDPROPERTYVALUE)
            {

                if (ppo->propid != propid)
                {
                    continue;
                }
                pprop = (SERIALIZEDPROPERTYVALUE *)
                    _MapOffsetToAddress(ppo->dwOffset);

                if (pcbprop != NULL)
                {
                    ULONG cb;

                    cb = psh->cbSection - ppo->dwOffset;
                    if (propid == PID_DICTIONARY)
                    {
                        *pcbprop = _DictionaryLength(
                                        (DICTIONARY const *) pprop,
                                        cb,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }
                    else
                    {
			*pcbprop = PropertyLengthNoEH(pprop, cb, 0, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    }
                }
                if (pcbprop == NULL ||
                    psh->cbSection >= ppo->dwOffset + *pcbprop)
                {
                    // Success
                    goto Exit;
                }
            }

            pprop = NULL;
            StatusCorruption(pstatus, "LoadProperty: property offset");
            goto Exit;
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(pprop);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::GetValue
//
// Synopsis:    return a pointer to the specified property value
//
// Arguments:   [propid]        -- property id of property
//              [pcbprop]       -- pointer to returned property length
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     pointer to property value
//---------------------------------------------------------------------------

SERIALIZEDPROPERTYVALUE const *
CPropertySetStream::GetValue(
    IN PROPID propid,
    OUT ULONG *pcbprop,
    OUT NTSTATUS *pstatus)
{
    SERIALIZEDPROPERTYVALUE *pprop = NULL;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::GetValue" );
    propTraceParameters(( "propid=0x%x, pcbprop=%p", propid, pcbprop ));

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "GetValue: deleted");
        goto Exit;
    }
    if (propid == PID_DICTIONARY)
    {
	DebugTrace(0, DEBTRACE_ERROR, ("GetValue: PID_DICTIONARY\n"));
	StatusInvalidParameter(pstatus, "GetValue: PID_DICTIONARY");
        goto Exit;
    }

    pprop = NULL;
    if (propid == PID_SECURITY || propid == PID_MODIFY_TIME)
    {
        StatusError( pstatus, "PID_SECURITY, PID_MODIFY_TIME not supported", STATUS_NOT_SUPPORTED );

        /*
        SERIALIZEDPROPERTYVALUE aprop[2];

        PROPASSERT(sizeof(aprop) >= sizeof(ULONG) + sizeof(LONGLONG));

        aprop[0].dwType = PropByteSwap( (DWORD) VT_EMPTY );
        if (propid == PID_SECURITY)
        {
            if (_MSTM(QuerySecurity)((ULONG *) aprop[0].rgb))
            {
                aprop[0].dwType = PropByteSwap( (DWORD) VT_UI4 );
                *pcbprop = 2 * sizeof(ULONG);
            }
        }
        else // (propid == PID_MODIFY_TIME)
        {
            LONGLONG ll;

            if (_MSTM(QueryModifyTime)(&ll))
            {
                *(LONGLONG UNALIGNED *) aprop[0].rgb = PropByteSwap( ll );
                aprop[0].dwType = PropByteSwap( (DWORD) VT_FILETIME );
                *pcbprop = sizeof(ULONG) + sizeof(LONGLONG);
            }
        }

        if( VT_EMPTY != PropByteSwap(aprop[0].dwType)  )
        {
            pprop = (SERIALIZEDPROPERTYVALUE *) CoTaskMemAlloc(*pcbprop);

            if (pprop == NULL)
            {
                StatusNoMemory(pstatus, "GetValue: no memory");
                goto Exit;
            }
            propDbg(( DEB_ITRACE,  "GetValue: pprop=%lx, vt=%lx, cb=%lx\n",
                                    pprop, PropByteSwap( aprop[0].dwType ), *pcbprop ));
            RtlCopyMemory(pprop, aprop, *pcbprop);
        }
        */
    }   // if (propid == PID_SECURITY || propid == PID_MODIFY_TIME)

    else
    {
	pprop = _LoadProperty(propid, pcbprop, pstatus);
        if( !NT_SUCCESS(*pstatus) )
        {
            pprop = NULL;
            goto Exit;
        }
    }   // if (propid == PID_SECURITY || propid == PID_MODIFY_TIME) ... else

#if DBGPROP
    if (pprop == NULL)
    {
        propDbg(( DEB_ITRACE, "GetValue: propid=%lx pprop=NULL\n", propid ));
    }
    else
    {
        char valbuf[CB_VALUESTRING];

        propDbg(( DEB_ITRACE,  "GetValue: propid=%lx pprop=%l" szX " vt=%hx val=%s cb=%l" szX "\n",
                                propid, _MapAddressToOffset(pprop), PropByteSwap( pprop->dwType ),
                                ValueToString(pprop, *pcbprop, valbuf), *pcbprop ));
    }
#endif

    //  ----
    //  Exit
    //  ----

Exit:

    if( STATUS_NOT_SUPPORTED == *pstatus )
        propSuppressExitErrors();

    return(pprop);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetValue
//
// Synopsis:    update/add/delete property values
//
// Arguments:   [cprop]         -- count of properties
//              [pip]           -- pointer to indirect indexes
//              [avar]          -- PROPVARIANT array
//              [apinfo]        -- PROPERTY_INFORMATION array
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//
// Note:        All the properties in the apinfo array can be classified into
//              one of the following categories:
//
//              PROPOP_IGNORE:
//                No change.  Deleting a non-existent property or the same
//                propid appears later in the apinfo array.
//
//              PROPOP_DELETE:
//                Deletion of an existing property.  Remove the
//                PROPERTYIDOFFSET structure from the property offset array and
//                and pack the remaining entries.  Delete the property value
//                and pack remaining property values
//
//              PROPOP_INSERT:
//                Addition of a new property.  Insert the new PROPERTYIDOFFSET
//                structure at the end of the property offset array.  Insert
//                the new property value at the end of the section/stream.
//
//              PROPOP_MOVE:
//                A property whose value needs to be updated out of place
//                because of a change in the property value's size.  A property
//                value is moved to the end of the section if it grows or
//                shrinks across a DWORD boundary.  The existing value is
//                removed from the section and the remaining values are packed.
//                Then, the new value is inserted at the end of the section.
//                The idea here is to move variable length properties that are
//                being changed frequently as near as possible to the end of
//                the stream to minimize the cost of maintaining a packed set
//                of property values.  Note that the property offset structure
//                is not moved around in the array.
//
//              PROPOP_UPDATE:
//                A property whose value can be updated in-place.  The property
//                value's new size is equal to the old size.  There are a
//                number of variant types that take up a fixed amount of space,
//                e.g., VT_I4, VT_R8 etc.  This would also apply to any
//                variable length property that is updated without changing
//                the property value's size across a DWORD boundary.
//
//              Note that while the property offset array is itself packed out
//              of necessity (to conform to the spec), there may be unused
//              entries at the end of the array that are not compressed out of
//              the stream when properties are deleted.  The unused space is
//              detected and reused when new properties are added later.
//---------------------------------------------------------------------------

#define CCHUNKSTACK     (sizeof(ascnkStack)/sizeof(ascnkStack[0]))

VOID
CPropertySetStream::SetValue(
    IN ULONG cprop,
    OPTIONAL IN OUT INDIRECTPROPERTY **ppip,
    IN PROPVARIANT const avar[],
    IN PROPERTY_INFORMATION *apinfo,
    OUT OPTIONAL USHORT *pCodePage,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    CStreamChunk ascnkStack[6];

    ULONG cpoReserve;
    ULONG cDelete, cInsert, cMove, cUpdate;

#if DBGPROP
    ULONG cIgnore;
    char valbuf[CB_VALUESTRING];
    KERNELSELECT(
    char valbuf2[CB_VALUESTRING],
    char varbuf[CB_VARIANT_TO_STRING]);
#endif

    ULONG iprop;
    ULONG cbstm;
    LONG cbChange, cbInsertMove;
    PROPERTYSECTIONHEADER *psh;
    int cIndirect = 0;
    CStreamChunk *pscnk0 = NULL;
    ULONG cbNewSize;

    USHORT NewCodePage = _CodePage;


    //  ----------
    //  Initialize
    //  ----------

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);
    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::SetValue" );
    propTraceParameters(( "cprop=%d, ppip=%p, avar=%p, apinfo=%p, pCodePage=%p",
                           cprop,    ppip,    avar,    apinfo,    pCodePage ));


    // Worst case, we will need chunks for:
    //  - the possible growth of the PROPERTYIDOFFSET array,
    //  - one for EACH property that is being modified,
    //  - and one chunk to mark the end of the property data.

    CStreamChunkList scl(
                        1 + cprop + 1,
                        1 + cprop + 1 <= CCHUNKSTACK? ascnkStack : NULL);

    PROPASSERT(_IsMapped());


    // Validate that this property set can be written to.
    if (IsReadOnlyPropertySet(_Flags, _State))
    {
        StatusAccessDenied(pstatus, "SetValue: deleted or read-only");
        goto Exit;
    }

    // Mark the propset dirty.
    _SetModified(pstatus);
    if( !NT_SUCCESS(*pstatus) )
    {
        TraceStatus( "SetValue: couldn't SetModified" );
        goto Exit;
    }

    psh = _GetSectionHeader();

    cpoReserve = 0;
    cDelete = cInsert = cMove = cUpdate = 0;
#if DBGPROP
    cIgnore = 0;
#endif
    cbInsertMove = cbChange = 0;

    pscnk0 = scl.GetFreeChunk(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    pscnk0->oOld = 0;
    pscnk0->cbChange = 0;
    PROPASSERT(pscnk0 == scl.GetChunk(0));

    cbstm = _oSection + psh->cbSection + _cbTail;
    PROPASSERT( cbstm <= _MSTM(GetSize)(pstatus) && NT_SUCCESS(*pstatus) );
    PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    //  ------------------------
    //  Classify all the updates
    //  ------------------------

    // Each update gets classified as ignore, delete, insert, move,
    // or update.
    // Lookup the old value for each of the properties specified and
    // compute the current size.

    for (iprop = 0; iprop < cprop; iprop++)
    {
        ULONG i;
        ULONG cbPropOld;
        SERIALIZEDPROPERTYVALUE const *pprop = NULL;

        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

        // Is this PROPID read-only?  E.g. the code page is a read-only property,
        // even if the property set is opened read/write.

        if (IsReadOnlyPropid(apinfo[iprop].pid))
        {
            BOOL fWritable = FALSE;

            // Read-only properties aren't settable except for two special
            // cases:  (1) we get called by the SetPropertyNames method
            // to create an empty dictionary; and (2) it's OK to set the
            // codepage/LCID on an empty property set.


            // Is this the SetPropertyNames case?

	    if (cprop == 1 &&
		apinfo[0].pid == PID_DICTIONARY &&
		apinfo[0].cbprop != 0 &&
                ( avar != NULL && avar[0].vt == VT_DICTIONARY )
               )
            {
                fWritable = TRUE;
            }

            // Or, is this a codepage/lcid going into an empty property set?

            else if( IsLocalizationPropid(apinfo[iprop].pid) )
            {
                // These properties may only be written as singletons, or
                // together, to an empty property set.  So we should be at
                // an iprop of 0 or 1.  We'll do all the checking at 0.

                if( 0 == iprop )
                {
                    // First, is this property set empty?
                    BOOLEAN fSettable = _IsLocalizationSettable(pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    if( fSettable )
                    {
                        // It's OK to set these props, so as long as either this
                        // is the only property being written, or there's one
                        // more and it's a localization property too, we're OK.

                        if( 1 == cprop )
                            fWritable = TRUE;
                        else if( 2 == cprop && IsLocalizationPropid(apinfo[1].pid) )
                            fWritable = TRUE;
                    }
                }
                else if( 1 == iprop )
                {
                    // This is valid iff iprop==0 was a localization property, and therefore
                    // we did the checking already.
                    if( IsLocalizationPropid(apinfo[0].pid) )
                        fWritable = TRUE;
                }

            }   // else if( IsLocalizationPropid(apinfo[iprop].pid) )


            if( !fWritable )
	    {
                propDbg(( DEB_ITRACE,  "SetValue: read-only propid=%lx\n",
		                        apinfo[iprop].pid ));
                StatusInvalidParameter(pstatus, "SetValue: read-only PROPID");
                goto Exit;
	    }

            if( PID_CODEPAGE == apinfo[iprop].pid && NULL != avar )
            {
                if( VT_I2 != avar[iprop].vt )
                {
                    propDbg(( DEB_ERROR, "SetValue:  invalid type for codepage (%d)\n",
                                          avar[iprop].vt ));
                    StatusInvalidParameter(pstatus, "SetValue: invalid type for CodePage");
                }
                NewCodePage = avar[iprop].iVal;
            }
            else if( PID_LOCALE == apinfo[iprop].pid && NULL != avar )
            {
                if( VT_I4 != avar[iprop].vt )
                {
                    propDbg(( DEB_ERROR,  "SetValue:  invalid type for locale ID (%d)\n",
                                           avar[iprop].vt ));
                    StatusInvalidParameter(pstatus, "SetValue: invalid type for LCID");
                }
            }

        }   // if (IsReadOnlyPropid(apinfo[iprop].pid))

        if (apinfo[iprop].pid != PID_ILLEGAL)
        {
            pprop = _LoadProperty(apinfo[iprop].pid, &cbPropOld, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
        }

        // If this propid appears later in the input array, ignore it.

        for (i = iprop + 1; i < cprop; i++)
        {
            if (apinfo[i].pid == apinfo[iprop].pid)
            {
                #if DBGPROP
                    cIgnore++;
                #endif
                apinfo[iprop].operation = PROPOP_IGNORE;
                break;
            }
        }

        // If this propid appears only once or if it's the last instance,
        // load the property and compute its size.

        if (i == cprop)
        {
            VOID *pvStart = NULL;

            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

            // Are we overwriting a property that already exists?

            if (pprop != NULL)
            {
                // Yes, we're either deleting or overwriting an existing property.

                ULONG cbPropNew;

                PROPASSERT(apinfo[iprop].pid != PID_DICTIONARY);

                // A cbprop of 0 indicates that we should delete this property

                if (apinfo[iprop].cbprop == 0)
                {
                    propDbg(( DEB_ITRACE,
                              "SetValue: Deleting propid=%lx oOld=%l" szX
                              " vt=%hx val=%s cb=%l" szX "\n",
                              apinfo[iprop].pid, _MapAddressToOffset(pprop), PropByteSwap( pprop->dwType ),
                              ValueToString(pprop, cbPropOld, valbuf), cbPropOld));

                    cbPropNew = 0;
                    cDelete++;
                    apinfo[iprop].operation = PROPOP_DELETE;

                }   // if (apinfo[iprop].cbprop == 0)

                // Otherwise, we're writing this property to the property set
                else
                {
                    /*
                    propDbg(( DEB_ITRACE, "SetValue: Modifying propid=%lx oOld=%l" szX
                                          " vt=%hx-->%hx cb=%l" szX "-->%l" szX " val=%s-->%s\n",
                                apinfo[iprop].pid,
                                _MapAddressToOffset(pprop),
                                PropByteSwap( pprop->dwType ),
			        avar[iprop].vt,
                                cbPropOld,
                                apinfo[iprop].cbprop,
                                ValueToString(pprop, cbPropOld, valbuf),
			        VariantToString(
				        avar[iprop],
				        varbuf,
				        sizeof( varbuf )) ));
                    */

                    cbPropNew = apinfo[iprop].cbprop;

                    // If this property is a different size than the existing value,
                    // then we'll write it to the end.

                    if (cbPropOld != cbPropNew)
                    {
                        cbInsertMove += apinfo[iprop].cbprop;
                        cMove++;
                        apinfo[iprop].operation = PROPOP_MOVE;
                    }

                    // Otherwise, we'll update the property value in place.
                    else
                    {
                        cUpdate++;
                        apinfo[iprop].operation = PROPOP_UPDATE;
                    }
                }   //    // if (apinfo[iprop].cbprop == 0) ... else

                if (apinfo[iprop].operation != PROPOP_UPDATE)
                {
                    // Update the list of chunks that need to be adjusted
                    CStreamChunk *pscnk = scl.GetFreeChunk(pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    pscnk->oOld = _MapAddressToOffset(pprop);
                    pscnk->cbChange = - (LONG) cbPropOld;
                }

                // Stream size change
                cbChange += cbPropNew - cbPropOld;

            }   // if (pprop != NULL)

            // Or, are we deleting a non-extant property?

            else if (apinfo[iprop].cbprop == 0)
            {
                // The request is to delete the property, but a NULL pprop indicates
                // that the property doesn't exist.  We'll ignore this part of the request.

                #if DBGPROP
                    cIgnore++;
                #endif
                PROPASSERT(apinfo[iprop].pid != PID_DICTIONARY);
                apinfo[iprop].operation = PROPOP_IGNORE;
            }

            // Otherwise, we're inserting a new property

            else
            {
                /*
                propDbg(( DEB_ITRACE,
                    "SetValue: Inserting new propid=%lx vt=%hx "
                        "cbNew=%l" szX " val=%s\n",
                    apinfo[iprop].pid,
		    avar[iprop].vt,
                    apinfo[iprop].cbprop,
		    VariantToString(
			avar[iprop],
			varbuf,
			sizeof( varbuf )) ));
                */

                PROPASSERT(apinfo[iprop].pid != PID_ILLEGAL);

                cbInsertMove += apinfo[iprop].cbprop;
                cbChange += apinfo[iprop].cbprop;

                cInsert++;
                apinfo[iprop].operation = PROPOP_INSERT;

            } // if (pprop != NULL) ... else if ... else

            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

            // In order to delete any old stream or storage type properties
            // we count the properties which used to be VT_STREAM etc.
            // Also, we count the properties which are to be created as
            // streams or storages.

            if (ppip != NULL && apinfo[iprop].operation != PROPOP_IGNORE)
            {
                if ((pprop != NULL && IsIndirectVarType(PropByteSwap(pprop->dwType)))
                    ||
                    (avar != NULL && IsIndirectVarType(avar[iprop].vt)))
                {
                    cIndirect++;
                }
            }
        }   // if (i == cprop)
    }   // for (iprop = 0; iprop < cprop; iprop++)
    // We're now done classifying each of the properties to be added.


    //  ------------------------------------------------------------
    //  Put existing, to-be-overwritten, indirect properties in ppip
    //  ------------------------------------------------------------

    // Did the caller give us an INDIRECTPROPERTY buffer, and are
    // there indirect properties being added and/or overwritten?

    if (ppip != NULL && cIndirect != 0)
    {
        // allocate needed space for indirect information
        INDIRECTPROPERTY *pipUse;

        if (cprop != 1)
        {
            pipUse = *ppip = reinterpret_cast<INDIRECTPROPERTY*>
                             ( CoTaskMemAlloc( sizeof(INDIRECTPROPERTY) * (cIndirect + 1) ));
            if (*ppip == NULL)
            {
                StatusNoMemory(pstatus, "SetValue: Indirect Name");
                goto Exit;
            }
            RtlZeroMemory( pipUse, sizeof(INDIRECTPROPERTY) * (cIndirect + 1) );
            pipUse[cIndirect].Index = MAXULONG;
        }
        else
        {
            pipUse = (INDIRECTPROPERTY *) ppip;
            RtlZeroMemory( pipUse, sizeof(*pipUse) );
        }


        int iIndirect = 0;
        for (iprop = 0; iprop < cprop; iprop++)
        {
            ULONG cbPropOld;
            SERIALIZEDPROPERTYVALUE const *pprop = NULL;

            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
            if (apinfo[iprop].operation == PROPOP_IGNORE ||
                apinfo[iprop].pid == PID_ILLEGAL)
            {
                continue;
            }

            pprop = _LoadProperty(apinfo[iprop].pid, &cbPropOld, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

            if (pprop != NULL && IsIndirectVarType(PropByteSwap(pprop->dwType)))
            {
                CHAR *pszName;
                BOOL fAlloc = FALSE;  // Did we alloc pszName?

                // we are overwriting an indirect property value

                PROPASSERT(cbPropOld >= 2 * sizeof(ULONG));

                // Point to the indirect property inline value (i.e. the name of the
                // stream/storage which holds it).

                cbPropOld -= 2 * sizeof(ULONG);                             // Subtract size of VT & length
                pszName = (CHAR *) Add2ConstPtr(pprop->rgb, sizeof(ULONG)); // Move past length

                // If this is a versioned stream, the inline value comes after
                // the guidVersion.

                if( VT_VERSIONED_STREAM == PropByteSwap(pprop->dwType) )
                {
                    cbPropOld -= sizeof(GUID);
                    pszName = (CHAR *) Add2ConstPtr(pszName, sizeof(GUID) );

                    PROPASSERT( cbPropOld
                                >=
                                *reinterpret_cast<const ULONG*>(Add2ConstPtr(pprop->rgb, sizeof(GUID)) ));
                }

                // Do we need to convert the name between Ansi & Unicode?

                if (_CodePage != CP_WINUNICODE      // Ansi propset
                    &&
                    OLECHAR_IS_UNICODE)             // Unicode OLE APIs
                {
                    // Convert the indirect reference to Unicode

                    PrpConvertToUnicode(
                                pszName,
                                cbPropOld,
                                _CodePage,
                                (WCHAR **) &pszName,
                                &cbPropOld,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    fAlloc = TRUE; // We need to free pszName
                }
                else
                if (_CodePage == CP_WINUNICODE      // Unicode propset
                    &&
                    !OLECHAR_IS_UNICODE )           // Ansi OLE APIs
                {
                    // Byte-Swap the Unicode indirect reference value

                    WCHAR *pwszBuffer = NULL;

                    // After this call, the appropriately swapped name will be
                    // in pszName.  If an alloc was required, pszBuffer will point
                    // to the new buffer (we must free this).

                    PBSInPlaceAlloc( (WCHAR**) &pszName, &pwszBuffer, pstatus );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    // Convert the reference value to Ansi.

                    PrpConvertToMultiByte(
                                (WCHAR*) pszName,
                                cbPropOld,
                                CP_ACP,
                                (CHAR **) &pszName,
                                &cbPropOld,
                                pstatus);
                    CoTaskMemFree( pwszBuffer );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    fAlloc = TRUE; // We need to free pszName
                }

                pipUse[iIndirect].poszName = reinterpret_cast<OLECHAR*>( CoTaskMemAlloc( cbPropOld ));

                if (pipUse[iIndirect].poszName == NULL)
                {
                    StatusNoMemory(pstatus, "SetValue: Indirect Name2");
                    goto Exit;
                }

                RtlCopyMemory(
                        pipUse[iIndirect].poszName,
                        pszName,
                        cbPropOld);


                // Is byte-swapping necessary?  It is if the property set
                // codepage is Unicode, and if OLECHARs are also Unicode.
                // If both are Ansi, then no byte-swapping is ever necessary,
                // and if one is Ansi and the other is Unicode, then we
                // already byte-swapped above during the conversion.

                if (_CodePage == CP_WINUNICODE
                    &&
                    OLECHAR_IS_UNICODE )
                {
                    // Convert from propset-endian to system-endian.
                    PBSBuffer( pipUse[iIndirect].poszName, cbPropOld, sizeof(OLECHAR) );
                }

                // Clean up pszName

                if( fAlloc )
                {
                    // In the Unicode/MBCS conversions, we did an alloc which
                    // we must free now.

                    PROPASSERT(pszName != NULL);
                    PROPASSERT(
                        pszName !=
                        (CHAR *) Add2ConstPtr(pprop->rgb, sizeof(ULONG)));
                    CoTaskMemFree( pszName );
                }

            }   // if (pprop != NULL && IsIndirectVarType(PropByteSwap(pprop->dwType)))

            else
            if (avar == NULL || !IsIndirectVarType(avar[iprop].vt))
            {
                // Neither the property being overwritten, nor the property
                // being written is indirect, so we can continue on to
                // check the next property (skipping the pipUse updating
                // below).

                continue;
            }

            // If we get here, we know that either this property is
            // an indirect type, or it's overwriting an indirect property.
            // We established pipUse[].pszName above, so we just need to
            // insert the index and move on.

            pipUse[iIndirect].Index = iprop;
            iIndirect++;

        }   // for (iprop = 0; iprop < cprop; iprop++)

        PROPASSERT(iIndirect == cIndirect);

    }   // if (ppip != NULL && cIndirect != 0)


    propDbg(( DEB_ITRACE, "SetValue: Total Props %l" szX "\n", cprop ));
    propDbg(( DEB_ITRACE,
        "SetValue: Delete=%l" szX " Insert=%l" szX " Move=%l" szX
            " Update=%l" szX " Ignore=%l" szX "\n",
        cDelete, cInsert, cMove, cUpdate, cIgnore ));

    PROPASSERT(cDelete + cInsert + cMove + cUpdate + cIgnore == cprop);
    PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);


    //  --------------------------------------------------------
    //  Calculate the total size adjustments to the property set
    //  --------------------------------------------------------

    // If we need to grow the property offset array, detect any unused
    // entries at the end of the array that are available for reuse.
    // and adjust the size difference to reflect the reuse.

    if (cInsert > cDelete)
    {
        ULONG cpoReuse, cpoExpand;

        cpoExpand = cInsert - cDelete;
        cpoReuse = _CountFreePropertyOffsets(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (cpoReuse > cpoExpand)
        {
            cpoReuse = cpoExpand;
        }
        cpoExpand -= cpoReuse;

        // If adding a small number of new entries, but not reusing any old
        // ones, add 10% more reserved entries (but only up to 10 more) to
        // avoid having to continually grow the property offset array for
        // clients that insist on adding a few properties at a time.

        // We don't do this for the User-Defined property set, however,
        // because older apps assume that the dictionary immediately follows
        // the last entry in the PID/Offset array.

        if (cpoExpand >= 1 && cpoExpand <= 2 && cpoReuse == 0
            &&
            !(_State & CPSS_USERDEFINEDPROPERTIES)
           )
        {
           cpoReserve = 1 + min(psh->cProperties, 90)/10;
           cpoExpand += cpoReserve;
        }
        DebugTrace(0, Dbg, (
            "SetValue: Reusing %l" szX " offsets, Expanding %l" szX
                " offsets\n",
            cpoReuse,
            cpoExpand));

        pscnk0->oOld = CB_PROPERTYSECTIONHEADER +
               (psh->cProperties + cpoReuse) * CB_PROPERTYIDOFFSET;
        pscnk0->cbChange = cpoExpand * CB_PROPERTYIDOFFSET;
        cbChange += cpoExpand * CB_PROPERTYIDOFFSET;
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    }   // if (cInsert > cDelete)

    // Do we instead need to *shrink* the PID/Offset array?
    // If so, don't shrink any more than necessary.  We'll
    // leave up to min(10%,10) blank entries.
    // However, if this is the User-Defined property set,
    // there can never be any unused entries (for compatibility
    // with older apps), so we do a complete shrink.

    else if (cInsert < cDelete)
    {
        ULONG cpoRemove = 0;
        ULONG cpoDelta = cDelete - cInsert;

        // How many blank entries do we already have?
        ULONG cpoCurBlankEntries = _CountFreePropertyOffsets( pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if( _State & CPSS_USERDEFINEDPROPERTIES )
        {
            cpoRemove = cpoDelta;
        }
        else
        {
            // How many blank entries can we have?
            ULONG cpoMaxBlankEntries;
            cpoMaxBlankEntries = 1 + min(psh->cProperties - cpoDelta, 90)/10;

            // If, after deleting the properties, we'd have too many,
            // remove only enough to get us down to the max allowable.

            if( cpoCurBlankEntries + cpoDelta
                >
                cpoMaxBlankEntries
              )
            {
                cpoRemove = cpoCurBlankEntries + cpoDelta - cpoMaxBlankEntries;
            }
        }   // if( _State & CPSS_USERDEFINEDPROPERTIES )

        // Should we remove any PID/Offset entries?

        if( cpoRemove > 0 )
        {
            // Start removing at cpoRemove entries from the end of the PID/Offset array
            pscnk0->oOld = CB_PROPERTYSECTIONHEADER
                           +
                           (psh->cProperties + cpoCurBlankEntries - cpoRemove)
                           *
                           CB_PROPERTYIDOFFSET;

            // Remove the bytes of the cpoRemove entries.
            pscnk0->cbChange = - (LONG) (cpoRemove * CB_PROPERTYIDOFFSET );

            // Adjust the size of the section equivalently.
            cbChange += pscnk0->cbChange;
        }

    }   // else if (cInsert < cDelete)

    PROPASSERT(
        cbstm + cbChange >=
        _oSection + CB_PROPERTYSECTIONHEADER +
        (psh->cProperties + cInsert - cDelete) * CB_PROPERTYIDOFFSET +
	_cbTail);

    // If we need to grow the stream, do it now.

    if (cbChange > 0)
    {
        if (cbstm + cbChange > CBMAXPROPSETSTREAM)
        {
            StatusDiskFull(pstatus, "SetValue: 256k limit");
            goto Exit;
        }

        propDbg(( DEB_ITRACE,  "SetSize(%x) SetValue grow\n", cbstm + cbChange));

        _MSTM(SetSize)(cbstm + cbChange, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // reload all pointers into mapped image:

        psh = _GetSectionHeader();
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

	// If there's another section after this one, move it back to the
	// end of the stream now.

	if (_cbTail != 0)
	{
	    VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

	    PropMoveMemory(
		    "SetValue(_cbTail:grow)",
		    psh,
		    Add2Ptr(pvSrc, cbChange),
		    pvSrc,
		    _cbTail);
	}
    }   // if (cbChange > 0)

    // From this point on, the operation should succeed.
    // If necessary, the stream has already been grown.

    //  ----------------------------------------
    //  Write the new properties into the stream
    //  ----------------------------------------

    // Update the PID/Offset table, and compact the stream, creating a whole at the
    // end of the stream for the new property values.

    if (cDelete + cInsert + cMove != 0)
    {
        // Delete and compact property offsets in the section header.

        if (cDelete + cMove != 0)
        {
            _DeleteMovePropertyOffsets(apinfo, cprop, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            psh->cProperties -= cDelete;
        }
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

        // Use the last chunk to mark the section end, and sort the chunks
        // in ascending order by start offset.

        CStreamChunk *pscnk = scl.GetFreeChunk(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        pscnk->oOld = psh->cbSection;
        pscnk->cbChange = 0;

        scl.SortByStartAddress();

        // If we're reducing the number of properties, we may be shrinking
        // the PID/Offset array.  So, update that array now, since
        // we may remove some bytes at the end of it when we compact
        // the stream.

        if( cDelete > cInsert )
        {
            _UpdatePropertyOffsets( &scl, pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

        // Compact the Stream following the directions in the
        // chunk list.

        _CompactStream(&scl);

        // If the number of properties is holding constant or increasing,
        // we can update the PID/Offset array now (because _CompactStream
        // allocated any necessary space for us).

        if( cDelete <= cInsert )
        {
            _UpdatePropertyOffsets( &scl, pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

        // Set the new section size to include the deleted and inserted
        // property offsets, and the deleted property values.

        psh->cbSection += cbChange;

        // Insert new property offsets at the end of the array.

        if (cInsert + cMove != 0)
        {
            _InsertMovePropertyOffsets(
                                apinfo,
                                cprop,
                                psh->cbSection - cbInsertMove,
                                cpoReserve,
                                pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            psh->cProperties += cInsert;
        }

        PROPASSERT(cbstm + cbChange == _oSection + psh->cbSection + _cbTail);
	if (_cbTail != 0)
	{
	    // There's another section after this one; if we're shrinking
	    // the stream, move it up to the new end of the stream now.

	    if (cbChange < 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"SetValue(_cbTail:shrink)",
			psh,
			Add2Ptr(pvSrc, cbChange),
			pvSrc,
			_cbTail);
	    }
	    _PatchSectionOffsets(cbChange);
	}
    }   // if (cDelete + cInsert + cMove != 0)

    // Copy the new values.

    // NOTE: It might seem unnecessary to delay the in-place updates until
    // this for loop.  We do not perform the in-place updates while
    // classifying the changes because unmapping, remapping and changing
    // the size required for handling other updates can fail.  In the event
    // of such a failure, the update would not be atomic.  By delaying the
    // in-place updates, we provide some degree of atomicity.

    if (cInsert + cUpdate + cMove != 0)
    {
	BOOLEAN fDocSummaryInfo = FALSE;

	if ((_State &
             (CPSS_USERDEFINEDPROPERTIES | CPSS_DOCUMENTSUMMARYINFO)) ==
	     CPSS_DOCUMENTSUMMARYINFO)
	{
	    fDocSummaryInfo = TRUE;
	}

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // Find property in the offset array and copy in the new value.
            if (apinfo[iprop].operation == PROPOP_INSERT ||
                apinfo[iprop].operation == PROPOP_UPDATE ||
                apinfo[iprop].operation == PROPOP_MOVE)
            {
                SERIALIZEDPROPERTYVALUE *pprop;
                ULONG cbprop;
                ULONG cIndirectProps;
                PROPID propid = apinfo[iprop].pid;

                pprop = _LoadProperty(propid, NULL, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
                PROPASSERT(pprop != NULL);

                // Special case for SetPropertyNames dictionary creation:

                if (propid == PID_DICTIONARY)
                {
                    PROPASSERT(CB_SERIALIZEDPROPERTYVALUE == CB_DICTIONARY);
                    PROPASSERT(apinfo[iprop].cbprop == CB_SERIALIZEDPROPERTYVALUE);
                    PROPASSERT(avar[iprop].vt == VT_DICTIONARY);
                    ((DICTIONARY *) pprop)->cEntries = 0;
                }   // if (propid == PID_DICTIONARY)
                else
                {
                    // In User, serialize the PROPVARIANT in avar
                    // directly into the mapped stream.  We ask for the
                    // count of indirect properties, even though we don't
                    // use it, in order to tell the routine that we
                    // can handle them.  Any handling that is actually
                    // required must be handled by our caller.

                    WORD wMinFormatRequired = 0;

                    cbprop = apinfo[iprop].cbprop;
                    pprop = StgConvertVariantToPropertyNoEH(
                                    &avar[iprop],
                                    _CodePage,
                                    pprop,
                                    &cbprop,
                                    apinfo[iprop].pid,
                                    FALSE, FALSE,
                                    &cIndirectProps,
                                    &wMinFormatRequired,
                                    pstatus
                                    );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    // This property type might not have been supported in the original
                    // property set format.  If so, it may be necessary to increment
                    // the format in the header.

                    _pph->wFormat = max( _pph->wFormat, wMinFormatRequired );

                    PROPASSERT(pprop != NULL);
                    PROPASSERT(cbprop == DwordAlign(cbprop));
                    PROPASSERT(cbprop == apinfo[iprop].cbprop);

		    // If writing a DocumentSummaryInformation property
		    // for which an alignment hack is provided, hack it now.

		    if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
		    {
                        // The two vectors in the DocSumInfo property set
                        // (if Ansi) are un-packed, but we'll adjust the lengths
                        // so that if a propset reader expects them to be packed,
                        // it will still work.  E.g., a one character string will
                        // have a length of 4, with padding of NULL characters.

			ULONG cbpropT;

			if (propid == PID_HEADINGPAIR)
			{
			    _FixHeadingPairVector(
					    PATCHOP_ALIGNLENGTHS,
					    pprop,
					    &cbpropT);
			}
			else
			if (propid == PID_DOCPARTS)
			{
			    _FixDocPartsVector(
					    PATCHOP_ALIGNLENGTHS,
					    pprop,
					    &cbpropT);
			}
		    }
                    propDbg(( DEB_ITRACE,  "SetValue:Insert: pph=%x pprop=%x cb=%3l" szX
                                           " vt=%4x val=%s o=%x oEnd=%x\n",
                        _pph,
                        pprop,
                        apinfo[iprop].cbprop,
                        PropByteSwap(pprop->dwType),
                        ValueToString(pprop, apinfo[iprop].cbprop, valbuf),
                        _MapAddressToOffset(pprop),
                        _MapAddressToOffset(pprop) + apinfo[iprop].cbprop));

                }   // if (propid == PID_DICTIONARY) ... else
            }   // if (apinfo[iprop].operation == PROPOP_INSERT || ...
        }   // for (iprop = 0; iprop < cprop; iprop++)
    }   // if (cInsert + cUpdate + cMove != 0)

    // If we need to shrink the stream or if we are cleaning up after a
    // previous shrink that failed, do it last.

    if ( cbChange < 0 )
    {
        propDbg(( DEB_ITRACE, "SetSize(%x) SetValue shrink\n", cbstm + cbChange ));
        _MSTM(SetSize)(cbstm + cbChange, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

    if( NULL != pCodePage )
        *pCodePage = _CodePage = NewCodePage;

Exit:

    scl.Delete();

    if( !NT_SUCCESS(*pstatus) )
    {
        if( ppip != NULL && 0 != cIndirect )
        {
            INDIRECTPROPERTY *pipUse;

            pipUse = (1 == cprop) ? (INDIRECTPROPERTY*) ppip
                                  : *ppip;

            for (int iFree = 0; iFree < cIndirect; iFree++)
            {
                CoTaskMemFree( pipUse[iFree].poszName );
            }
            if (cprop != 1)
            {
                CoTaskMemFree( pipUse );
                *ppip = NULL;
            }
        }
    }   // if( !NT_SUCCESS(*pstatus) )


}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CountFreePropertyOffsets, private
//
// Synopsis:    counts available (free) property offsets at and of array
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     count of available property offsets at and of array
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_CountFreePropertyOffsets(OUT NTSTATUS *pstatus)
{
    PROPERTYIDOFFSET *ppo, *ppoMax;
    PROPERTYSECTIONHEADER const *psh;
    ULONG oMin = MAXULONG;
    ULONG oEnd;
    ULONG cFree = 0;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (psh != NULL)
    {
        for ( ; ppo < ppoMax; ppo++)
        {
            if (oMin > ppo->dwOffset)
            {
                oMin = ppo->dwOffset;
            }
        }
    }
    if (oMin == MAXULONG)
    {
        goto Exit;
    }
    PROPASSERT(psh != NULL);
    oEnd = CB_PROPERTYSECTIONHEADER + psh->cProperties * CB_PROPERTYIDOFFSET;
    PROPASSERT(oEnd <= oMin);

    cFree = (oMin - oEnd)/CB_PROPERTYIDOFFSET;

Exit:

    return( cFree );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DeleteMovePropertyOffsets, private
//
// Synopsis:    updates the offsets following the changes to the stream
//
// Arguments:   [apinfo]        -- array of property information
//              [cprop]         -- number of properties
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_DeleteMovePropertyOffsets(
    IN PROPERTY_INFORMATION const *apinfo,
    IN ULONG cprop,
    OUT NTSTATUS *pstatus)
{
    ULONG i;
    ULONG cDelete;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase = NULL, *ppoMax = NULL;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Remove the deleted properties

    DebugTrace(0, Dbg, ("Marking deleted/moved property offsets\n"));
    cDelete = 0;
    for (i = 0; i < cprop; i++)
    {
        if (apinfo[i].operation == PROPOP_DELETE ||
            apinfo[i].operation == PROPOP_MOVE)
        {
            for (ppo = ppoBase; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == apinfo[i].pid)
                {
                    DebugTrace(0, Dbg, (
                        "%sing propid=%lx oOld=%l" szX "\n",
                        apinfo[i].operation == PROPOP_DELETE? "Delet" : "Mov",
                        ppo->propid,
                        ppo->dwOffset));
                    if (apinfo[i].operation == PROPOP_DELETE)
                    {
                        cDelete++;
                        ppo->dwOffset = MAXULONG;
                    }
                    else
                    {
                        ppo->dwOffset = 0;
                    }
                    break;
                }
            }
        }
    }

    // scan once and compact the property offset array.

    if (cDelete > 0)
    {
        PROPERTYIDOFFSET *ppoDst = ppoBase;

        DebugTrace(0, Dbg, ("Compacting %l" szX " deleted props\n", cDelete));
        for (ppo = ppoBase; ppo < ppoMax; ppo++)
        {
            if (ppo->dwOffset != MAXULONG)
            {
                if (ppo > ppoDst)
                {
                    *ppoDst = *ppo;
                }
                DebugTrace(0, Dbg, (
                    "%sing propid=%lx oOld=%l" szX "\n",
                    ppo > ppoDst? "Compact" : "Preserv",
                    ppo->propid,
                    ppo->dwOffset));
                ppoDst++;
            }
        }
        PROPASSERT(cDelete == (ULONG) (ppoMax - ppoDst));
        DebugTrace(0, Dbg, ("Zeroing %l" szX " entries\n", cDelete));
        RtlZeroMemory(ppoDst, (BYTE *) ppoMax - (BYTE *) ppoDst);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_UpdatePropertyOffsets, private
//
// Synopsis:    update property offsets in section header
//
// Arguments:   [pscl]          -- list of chunks in stream that were changed
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_UpdatePropertyOffsets(
    IN CStreamChunkList const *pscl,
    OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo = NULL, *ppoMax = NULL;

    // Update the offsets for the existing properties.
    DebugTrace(0, Dbg, ("Updating existing property offsets\n"));

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    for ( ; ppo < ppoMax; ppo++)
    {
        if (ppo->dwOffset != 0)
        {
#if DBGPROP
            ULONG oOld = ppo->dwOffset;
#endif
            ppo->dwOffset = _GetNewOffset(pscl, ppo->dwOffset);

            DebugTrace(0, Dbg, (
                "UpdatePropertyOffsets: propid=%lx offset=%l" szX "-->%l" szX"\n",
                ppo->propid,
                oOld,
                ppo->dwOffset));
        }
    }

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_InsertMovePropertyOffsets, private
//
// Synopsis:    updates the offsets following the changes to the stream
//
// Arguments:   [apinfo]        -- array of property information
//              [cprop]         -- number of properties
//              [oInsert]       -- offset in section for new properties
//              [cpoReserve]    -- newly reserved property offsets to zero
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_InsertMovePropertyOffsets(
    IN PROPERTY_INFORMATION const *apinfo,
    IN ULONG cprop,
    IN ULONG oInsert,
    IN ULONG cpoReserve,
    OUT NTSTATUS *pstatus)
{
    ULONG i;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase = NULL, *ppoMax = NULL;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Insert the new property offsets at the end.
    DebugTrace(0, Dbg, ("Inserting/Moving/Zeroing property offsets\n"));

    for (i = 0; i < cprop; i++)
    {
        if (apinfo[i].operation == PROPOP_INSERT)
        {
            ppo = ppoMax++;
            ppo->propid = apinfo[i].pid;
        }
        else if (apinfo[i].operation == PROPOP_MOVE)
        {
            for (ppo = ppoBase; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == apinfo[i].pid)
                {
                    PROPASSERT(ppo->dwOffset == 0);
                    break;
                }
            }
        }
        else
        {
            continue;
        }

        PROPASSERT(ppo->propid == apinfo[i].pid);
        ppo->dwOffset = oInsert;
        oInsert += apinfo[i].cbprop;

        DebugTrace(0, Dbg, (
            "%sing propid=%lx offset=%l" szX " size=%l" szX "\n",
            apinfo[i].operation == PROPOP_INSERT? "Insert" : "Mov",
            ppo->propid,
            ppo->dwOffset,
            apinfo[i].cbprop));
    }
    DebugTrace(0, Dbg, (
        "Zeroing %x property offsets o=%l" szX " size=%l" szX "\n",
        cpoReserve,
        _MapAddressToOffset(ppoMax),
        cpoReserve * CB_PROPERTYIDOFFSET));
    RtlZeroMemory(ppoMax, cpoReserve * CB_PROPERTYIDOFFSET);

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CompactStream, private
//
// Synopsis:    compact all of the property stream chunks
//
// Arguments:   [pscl]          -- list of chunks in stream that were changed
//
// Returns:     None
//
// Note:
//      Each chunk structure represents a contiguous range of the stream to be
//      completely removed or added.  A terminating chunk is appended to
//      transparently mark the end of the data stream.  The unmodified data
//      after each chunk (except the last one) must be preserved and compacted
//      as necessary.  Chunk structures contain section-relative offsets.
//
//      Invariants:
//      - Only the first chunk can represent an insertion; subsequent chunks
//        always represent deletions.
//      - The first chunk can never cause a deletion, but it might not cause
//        any change at all.
//      - The last chunk is a dummy used to mark the end of the stream.
//
//      Algorithm:
//      In the optimal case without insertions, each chunk's trailing data can
//      be moved ahead (compacted) individually in ascending chunk index order.
//      If the first chunk represents an insertion, then some consecutive
//      number of data blocks must be moved back (in *descending* chunk index
//      order) to make room for the insertion.
//
//      Walk the chunk array to find the first point where the accumulated size
//      change is less than or equal to zero.
//
//      After (possibly) compacting a single range in descending chunk index
//      order, compact all remaining chunks in ascending chunk index order.
//
//      Example: the first chunk inserts 18 bytes for new property offsets
//      (apo'[]), and the second two delete 10 bytes each (chnk1 & chnk2).
//      There are four chunks in the array, and three blocks of data to move.
//
//                   oOld   cbChange | AccumulatedChange  oNew
//      chunk[0]:     38      +18    |      +18            38  (apo'[])
//      chunk[1]:     48      -10    |       +8            50  (chnk1)
//      chunk[2]:     6c      -10    |       -8            74  (chnk2)
//      chunk[3]:     8c        0    |       -8            84  (end)
//
//      Data blocks are moved in the following sequence to avoid overlap:
//      DstOff  SrcOff  cbMove | Chunk#
//        60      58      14   |    1  chnk1/data2: descending pass (Dst > Src)
//        50      38      10   |    0  apo'[]/data1: descending pass (Dst > Src)
//        74      7c      10   |    2  chnk2/data3: ascending pass  (Dst < Src)
//
//      SrcOff = oOld - min(cbChange, 0)
//      DstOff = SrcOff + AccumulatedChange
//      cbMove = chnk[i+1].oOld - SrcOff
//
//      Before compacting:
//                   0           38      48      58         6c      7c      8c
//                   |            |       |       |          |       |       |
//                   V            V   10  V  -10  V    14    V  -10  V   10  V
//      +----+-------+----+-------+-------+-------+----------+-------+-------+
//      | ph | afo[] | sh | apo[] | data1 | chnk1 |  data2   | chnk2 | data3 |
//      +----+-------+----+-------+-------+-------+----------+-------+-------+
//
//      After compacting:
//                   0           38          50      60         74      84
//                   |            |           |       |          |       |
//                   V            V    +18    V   10  V    14    V   10  V
//      +----+-------+----+-------+-----------+-------+----------+-------+
//      | ph | afo[] | sh | apo[] |   apo'[]  | data1 |  data2   | data3 |
//      +----+-------+----+-------+-----------+-------+----------+-------+
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_CompactStream(
    IN CStreamChunkList const *pscl)
{
    ULONG i, iMax, iAscend;
    LONG cbChangeTotal, cbChangeTotalAscend;
    CStreamChunk const *pscnk;

    // Subtract one to avoid operating on the terminating chunk directly.

    iMax = pscl->Count() - 1;

    // If the first chunk does not indicate an insertion, the first for loop is
    // exited with i == 0.
    //
    // If the first chunk represents an insertion, either i == iMax or i itself
    // indexes the first chunk that can be compacted normally (in ascending
    // chunk index order).  In either case, we compact in descending chunk
    // index order starting just below i.

    DebugTrace(0, Dbg, (
        "CompactStream: %l" szX " chunks @%lx\n",
        pscl->Count(),
        pscl->GetChunk(0)));

    cbChangeTotal = 0;
    for (i = 0; i < iMax; i++)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);
        if (cbChangeTotal + pscnk->cbChange <= 0)
        {
            break;
        }
        cbChangeTotal += pscnk->cbChange;
    }
    iAscend = i;                                // save ascending order start
    cbChangeTotalAscend = cbChangeTotal;

    DebugTrace(0, Dbg, ("CompactStream: iAscend=%l" szX "\n", iAscend));

    // First compact range in descending chunk index order if necessary:

    while (i-- > 0)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);

        DebugTrace(0, Dbg, ("CompactStream: descend: i=%l" szX "\n", i));
#if DBGPROP
        pscl->AssertCbChangeTotal(pscnk, cbChangeTotal);
#endif
        _CompactChunk(pscnk, cbChangeTotal, pscl->GetChunk(i + 1)->oOld);
        cbChangeTotal -= pscnk->cbChange;
    }

    // Compact any remaining chunks in ascending chunk index order.

    cbChangeTotal = cbChangeTotalAscend;
    for (i = iAscend; i < iMax; i++)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);

        DebugTrace(0, Dbg, ("CompactStream: ascend: i=%l" szX "\n", i));
        cbChangeTotal += pscnk->cbChange;
#if DBGPROP
        pscl->AssertCbChangeTotal(pscnk, cbChangeTotal);
#endif
        _CompactChunk(pscnk, cbChangeTotal, pscl->GetChunk(i + 1)->oOld);
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CompactChunk, private
//
// Synopsis:    Compact the data block following one chunk
//
// Arguments:   [pscnk]         -- pointer to stream chunk
//              [cbChangeTotal] -- Bias for this chunk
//              [oOldNext]      -- offset of next chunk
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_CompactChunk(
    IN CStreamChunk const *pscnk,
    IN LONG cbChangeTotal,
    IN ULONG oOldNext)
{
#if DBG==1
    LONG cbDelta = cbChangeTotal + min(pscnk->cbChange, 0);

    DebugTrace(0, Dbg, (
        "CompactChunk(pscnk->oOld=%l" szX ", pscnk->cbChange=%s%l" szX "\n"
            "       cbChangeTotal=%s%l" szX
            ", cbDelta=%s%l" szX
            ", oOldNext=%l" szX ")\n",
        pscnk->oOld,
        pscnk->cbChange < 0? "-" : "",
        pscnk->cbChange < 0? -pscnk->cbChange : pscnk->cbChange,
        cbChangeTotal < 0? "-" : "",
        cbChangeTotal < 0? -cbChangeTotal : cbChangeTotal,
        cbDelta < 0? "-" : "",
        cbDelta < 0? -cbDelta : cbDelta,
        oOldNext));
#endif // DBG==1

    if (cbChangeTotal != 0)
    {
        ULONG oSrc;
        VOID const *pvSrc;

        oSrc = pscnk->oOld - min(pscnk->cbChange, 0);
        pvSrc = _MapOffsetToAddress(oSrc);
        PropMoveMemory(
                "CompactChunk",
                _GetSectionHeader(),
                (VOID *) Add2ConstPtr(pvSrc, cbChangeTotal),
                pvSrc,
                oOldNext - oSrc);
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_PatchSectionOffsets, private
//
// Synopsis:    patch section offsets after moving data around
//
// Arguments:   [cbChange]      -- size delta
//
// Returns:     none
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_PatchSectionOffsets(
    LONG cbChange)
{
    ULONG i;

    for (i = 0; i < _cSection; i++)
    {
	FORMATIDOFFSET *pfo;

	pfo = _GetFormatidOffset(i);
	if (pfo->dwOffset > _oSection)
	{
	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"PatchSectionOffsets(%x): %l" szX " + %l" szX " --> %l" szX "\n",
		i,
		pfo->dwOffset,
		cbChange,
		pfo->dwOffset + cbChange));
	    pfo->dwOffset += cbChange;
	}
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetNewOffset, private
//
// Synopsis:    gets the new address
//
// Arguments:   [pscl]          -- list of stream chunks that were changed
//              [oOld]          -- old offset
//
// Returns:     new offset
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_GetNewOffset(
    IN CStreamChunkList const *pscl,
    IN ULONG oOld) const
{
    // The Chunk list is sorted by start offsets.  Locate the chunk to which
    // the old offset belongs, then use the total change undergone by the chunk
    // to compute the new offset.

    ULONG i;
    ULONG iMax = pscl->Count();
    LONG cbChangeTotal = 0;

    for (i = 0; i < iMax; i++)
    {
        CStreamChunk const *pscnk = pscl->GetChunk(i);
        if (pscnk->oOld > oOld)
        {
            break;
        }
        cbChangeTotal += pscnk->cbChange;
        if (pscnk->oOld == oOld)
        {
            PROPASSERT(pscnk->cbChange >= 0);
            break;
        }
    }
    PROPASSERT(i < iMax);
    DebugTrace(0, Dbg, (
        "GetNewOffset: %l" szX " + %l" szX " --> %l" szX "\n",
        oOld,
        cbChangeTotal,
        oOld + cbChangeTotal));
    return(oOld + cbChangeTotal);
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixUnalignedUDPropSet, private
//
// Synopsis:    Fixes a case seen with Visio where the user-defined
//              property set is not dword aligned.  The fix is to align
//              it (shifting everything else back) in memory.
//
// Arguments:   [*pcbstm]  -- in:  current stream size
//                            out: updated stream size.
//              [pstatus]  -- pointer to NTSTATUS code
//
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_FixUnalignedUDPropSet( ULONG *pcbstm,
                                            NTSTATUS *pstatus )
{
    *pstatus = STATUS_SUCCESS;

    //
    // Don't assume *any* class variables except _pph & _State are loaded yet!
    //

    ULONG cSection;
    UNALIGNED PROPERTYSECTIONHEADER* pshOld = NULL;
    PROPERTYSECTIONHEADER* pshNew = NULL;
    ULONG cbDelta = 0;
    ULONG cbTail = 0;
    ULONG oSection = 0;

    // We only do this fixup for the docsuminfo/userdefined property sets.

    if( !(_State & (CPSS_USERDEFINEDPROPERTIES|CPSS_DOCUMENTSUMMARYINFO)) )
        return;

    // Make sure we have a header.

    if( NULL == _pph )
        return;

    // Make sure the stream is at least big enough to have
    // a second section.

    if( *pcbstm < CB_PROPERTYSETHEADER + 2*CB_FORMATIDOFFSET )
        return;

    // We're only looking for a 2-section problem, so we're done if
    // there's only one section.

    cSection = _pph->reserved;
    if( 1 >= cSection )
        return;

    // Get the stream-relative offset of the second section.

    //oSection = _GetFormatidOffset(1)->dwOffset;
    oSection = ((FORMATIDOFFSET *) Add2Ptr(_pph, sizeof(*_pph)))[1].dwOffset;

    // If it's already aligned, then we're done.

    if( IsDwordAligned(oSection) )
        return;

    // Determine how much we need to add to make it aligned, and determine
    // the size of the stream after the misalignment point.

    cbDelta = DwordRemain(oSection);
    pshOld = (PROPERTYSECTIONHEADER *) Add2Ptr(_pph, oSection);
    pshNew = (PROPERTYSECTIONHEADER *) ( (ULONG_PTR) pshOld + cbDelta );
    
    cbTail = (ULONG)( (ULONG_PTR) pshOld - (ULONG_PTR) _pph );
    cbTail = *pcbstm - cbTail;

    // Make sure there's enough stream left to see everything.

    if( *pcbstm < oSection + sizeof(PROPERTYSECTIONHEADER) )
    {
        StatusCorruption (pstatus, "_FixUnalignedUDPropSet:  stream size too short to read section header");
        goto Exit;
    }

    // Reset the stream size, only in memory for now, to accomodate
    // cbDelta more bytes.

    _MSTM(SetSize)(
	    *pcbstm + cbDelta,
            FALSE,   // Not persistent
	    (VOID **) &_pph,
            pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    *pcbstm += cbDelta;

    // Recalc the location of the section header (in memory) now
    // that we have a new _pph from the _MSTM call.

    pshOld = (PROPERTYSECTIONHEADER *) Add2Ptr(_pph, oSection);
    pshNew = (PROPERTYSECTIONHEADER *) ( (ULONG_PTR) pshOld + cbDelta );

    // Shift everything out by cbDelta bytes.

    RtlCopyMemory( pshNew,
                   pshOld,
                   cbTail );
    ((FORMATIDOFFSET *) Add2Ptr(_pph, sizeof(*_pph)))[1].dwOffset += cbDelta;

    *pstatus = STATUS_SUCCESS;

Exit:

    return;

}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ComputeMinimumSize, private
//
// Synopsis:    computes the minimum possible size of a property set stream
//
// Arguments:   [cbstm]         -- actual stream size
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     computed highest offset in use
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_ComputeMinimumSize(
    IN ULONG cbstm,
    OUT NTSTATUS *pstatus)
{
    ULONG oMax = 0;
    *pstatus = STATUS_SUCCESS;

    // Don't assume *any* class variables except _pph are loaded yet!

    if (_pph != NULL && cbstm != 0)
    {
        ULONG cbMin;
        ULONG i;
        ULONG cSection;

        cSection = 1;
        cbMin = 0;

        if (_HasPropHeader())
        {
            cSection = _pph->reserved;
            cbMin = CB_PROPERTYSETHEADER + cSection * CB_FORMATIDOFFSET;
        }
        oMax = cbMin;

        // Add the size of each section

        for (i = 0; i < cSection; i++)
        {
            ULONG oSectionEnd;

            PROPERTYSECTIONHEADER const *psh = _GetSectionHeader(i, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            cbMin += psh->cbSection;
            oSectionEnd = _MapAddressToAbsOffset(psh) + psh->cbSection;
            if (oMax < oSectionEnd)
            {
                oMax = oSectionEnd;
            }
        }

        // The following can't be asserted, because there may be
        // a correctable reason why cbstm < oMax at in the Open path
        // (see the Excel 5.0a problem in _FixSummaryInformation)
        //PROPASSERT(oMax <= cbstm);

        PROPASSERT(cbMin <= oMax);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // oMax may have been set before an error occurred.
    // In this case, set it to zero.

    if( !NT_SUCCESS(*pstatus) )
        oMax = 0;

    return(oMax);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DictionaryLength
//
// Synopsis:    compute length of property set dictionary
//
// Arguments:   [pdy]           -- pointer to dictionary
//              [cbbuf]         -- maximum length of accessible memory at pdy
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     Byte-granular count of bytes in dictionary
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_DictionaryLength(
    IN DICTIONARY const *pdy,
    IN ULONG cbbuf,
    OUT NTSTATUS *pstatus ) const
{
    ENTRY UNALIGNED const *pent;
    ULONG cbDict = CB_DICTIONARY;
    ULONG i;

    *pstatus = STATUS_SUCCESS;

    for (i = 0, pent = &pdy->rgEntry[0];
         i < PropByteSwap( pdy->cEntries );
         i++, pent = _NextDictionaryEntry( pent ))
    {
        if (cbbuf < cbDict + CB_DICTIONARY_ENTRY ||
            cbbuf < _DictionaryEntryLength( pent ))
        {
            StatusCorruption(pstatus, "_DictionaryLength: section size");
            goto Exit;
        }

        cbDict += _DictionaryEntryLength( pent );
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(cbDict);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_IsLocalizationSettable
//
// Synopsis:    Determine if this property set may be localized
//              (i.e., that the codepage & locale ID may be set).
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     TRUE if settable.
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_IsLocalizationSettable(
    OUT NTSTATUS *pstatus )
{
    BOOLEAN fSettable = FALSE;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase = NULL, *ppoMax = NULL;

    *pstatus = STATUS_SUCCESS;

    // Get the section header

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // If the section is empty, then we're done.

    if( NULL == psh || 0 == psh->cProperties )
    {
        fSettable = TRUE;
        goto Exit;
    }

    // Walk through the properties in the set

    for (ppo = ppoBase; ppo < ppoMax; ppo++)
    {
        // Is this the dictionary?

        if( PID_DICTIONARY == ppo->propid )
        {
            // The dictionary is OK if it's empty.

            DICTIONARY const *pdy;

            pdy = reinterpret_cast<DICTIONARY const *>
                  ( _MapOffsetToAddress(ppo->dwOffset) );

            if( 0 != pdy->cEntries )
                goto Exit;  // fSettable == FALSE
        }

        // Or, is this an existing codepage or LCID property
        // (which are fine to overwrite)?

        else if( PID_CODEPAGE != ppo->propid
                 &&
                 PID_LOCALE   != ppo->propid )
        {
            // No, so we're done.
            goto Exit;  // fSettable == FALSE
        }
    }

    fSettable = TRUE;

Exit:

    return( fSettable );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_PropertyNameLength
//
// Synopsis:    compute length (*byte* count) of a property name
//
// Arguments:   [pvName]        -- property name, in the codepage of
//                                 the property set
//              [pcbName]       -- pointer to returned byte length of name
//
// Returns:     Minimum format version (wFormat) required for this name.
//
// Note:        The OLE 2.0 format mandates that the null be included as part
//              of the length of the name that is stored in the dictionary.
//              If the propset uses the Unicode code page, names contain
//              WCHARs, otherwise they contain CHARs.  In either case, the
//              length is a byte count that includes the L'\0' or '\0'.
//
//              Also note that this routine does not concern itself with
//              the byte-order of the name:  for Ansi names, it's irrelevant;
//              and for Unicode names, L'\0' == PropByteSwap(L'\0').
//
//+--------------------------------------------------------------------------

WORD
CPropertySetStream::_PropertyNameLength(
    IN VOID const *pvName,
    OUT ULONG *pcbName) const
{
    ULONG cchsz;

    if (_CodePage == CP_WINUNICODE)
    {
        cchsz = Prop_wcslen((WCHAR const *) pvName) + 1;
        *pcbName = cchsz * sizeof(WCHAR);
    }
    else
    {
        *pcbName = cchsz = strlen((char const *) pvName) + 1;
    }

    return( cchsz > CCH_MAXPROPNAMESZ ? PROPSET_WFORMAT_LONG_NAMES : PROPSET_WFORMAT_ORIGINAL );

}   // CPropertySetStream::_PropertyNameLength


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ComparePropertyNames
//
// Synopsis:    Compare two property names.
//
// Pre-Conditions:
//              The property names are in the codepage of the
//              property set.
//
// Arguments:   [pvName1]       -- property name 1
//              [pvName2]       -- property name 2
//              [fSameByteOrder]-- TRUE:  names are both big- or little-endian
//                                 FALSE: 2nd name is wrong endian in a big endian compile
//              [cbName]        -- byte count of name length
//                                 (includes terminator)
//
// Returns:     TRUE if names are equal
//+--------------------------------------------------------------------------



BOOLEAN
CPropertySetStream::_ComparePropertyNames(
    IN VOID const *pvName1,
    IN VOID const *pvName2,
    IN BOOL fSameByteOrder,
    IN ULONG cbName,
    OUT NTSTATUS *pstatus ) const
{

#ifdef BIGENDIAN
// If fSameByteOrder, we need to swap pvName2.
#error BigEndian support in this routine needs to be implemented
#endif

    int nCompare = 0;
    *pstatus = STATUS_SUCCESS;

    PROPASSERT( NULL != pvName1 && NULL != pvName2 );
    PROPASSERT( _SupportsLongNames() || CCH_MAXPROPNAMESZ >= CB2CCh(cbName) );


    if (_CodePage == CP_WINUNICODE)
    {
        PROPASSERT( IsUnicodeString(reinterpret_cast<const WCHAR*>(pvName1),cbName)
                    &&
                    IsUnicodeString(reinterpret_cast<const WCHAR*>(pvName2),cbName) );

        if( _IsCaseSensitive() )
        {
            nCompare = CompareStringW( _Locale,
                                       0,
                                       reinterpret_cast<WCHAR const *>(pvName1),
                                       -1,
                                       reinterpret_cast<WCHAR const *>(pvName2),
                                         -1 );
        }
        else
        {
            nCompare = CompareStringW( _Locale,
                                       NORM_IGNORECASE,
                                       reinterpret_cast<WCHAR const *>(pvName1),
                                       -1,
                                       reinterpret_cast<WCHAR const *>(pvName2),
                                       -1  );
        }

    }
    else
    {
        PROPASSERT( IsAnsiString(reinterpret_cast<const CHAR*>(pvName1), cbName)
                    &&
                    IsAnsiString(reinterpret_cast<const CHAR*>(pvName2), cbName) );

        if( _IsCaseSensitive() )
        {
            nCompare = CompareStringA( _Locale,
                                       0,
                                       reinterpret_cast<char const *>(pvName1),
                                       -1,
                                       reinterpret_cast<char const *>(pvName2),
                                       -1 );
        }
        else
        {
            nCompare = CompareStringA( _Locale,
                                       NORM_IGNORECASE,
                                       reinterpret_cast<char const *>(pvName1),
                                       -1,
                                       reinterpret_cast<char const *>(pvName2),
                                       -1 );
        }
    }


    if( CSTR_EQUAL == nCompare )
        return TRUE;
    else if( 0 == nCompare )
    {
        StatusError( pstatus, "Failed CompareString", HRESULT_FROM_WIN32(GetLastError()) );
    }

    return FALSE;

}   // CPropertySetStream::_ComparePropertyNames()



//+---------------------------------------------------------------------------
// Function:    CPropertySetStream::DuplicatePropertyName
//
// Synopsis:    Duplicate an OLECHAR property name string
//
// Arguments:   [poszName]  -- input string
//              [cbName]    -- count of bytes in string (includes null)
//              [pstatus]   -- pointer to NTSTATUS code
//
// Returns:     pointer to new string
//---------------------------------------------------------------------------

OLECHAR *
CPropertySetStream::DuplicatePropertyName(
    IN OLECHAR const *poszName,
    IN ULONG cbName,
    OUT NTSTATUS *pstatus) const
{
    OLECHAR *poc = NULL;
    *pstatus = STATUS_SUCCESS;

    // Why do we need cbName? It seems to be redundant

    PROPASSERT(cbName != 0);
    PROPASSERT(IsOLECHARString(poszName, cbName));

    if (cbName != 0)
    {
        PROPASSERT((ocslen(poszName) + 1) * sizeof(OLECHAR) == cbName);

        poc = (OLECHAR *) _pma->Allocate(cbName);

        if (NULL == poc)
        {
            StatusNoMemory(pstatus, "DuplicatePropertyName: no memory");
            goto Exit;
        }
        RtlCopyMemory(poc, poszName, cbName);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(poc);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropid
//
// Synopsis:    translate a property name to a property id using the
//              dictionary on the property stream
//
// Arguments:   [poszName]      -- name of property
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     propid for property if found; PID_ILLEGAL if not found
//---------------------------------------------------------------------------

PROPID
CPropertySetStream::QueryPropid(
    IN OLECHAR const *poszName,
    OUT NTSTATUS *pstatus )
{
    //  ------
    //  Locals
    //  ------

    ULONG cbname;
    DICTIONARY const *pdy;
    ENTRY UNALIGNED const *pent;
    ULONG cdye;
    ULONG cbDict;               // BYTE granular size!
    VOID const *pvName = NULL;
    PROPID propid = PID_ILLEGAL;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::QueryPropid" );
    propTraceParameters(( "poszName=%s",
                          poszName ));

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT( IsOLECHARString( poszName, MAXULONG ));
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);


    // Make sure this isn't a UD propset which has been deleted.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropid: deleted");
        goto Exit;
    }

    // Put the name into pvName, converting it if
    // necessary to the code-page of the property set.

    pvName = poszName;
    if (_CodePage == CP_WINUNICODE  // Property set is Unicode
        &&
        !OLECHAR_IS_UNICODE )       // Name is in Ansi
    {
        // Convert the caller-provided name from the system
        // Ansi codepage to Unicode.

        ULONG cb = 0;
        pvName = NULL;
        _OLECHARToWideChar( poszName, (ULONG)-1, CP_ACP,
                            (WCHAR**)&pvName, &cb, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    else
    if (_CodePage != CP_WINUNICODE  // Property set is Ansi
        &&
        OLECHAR_IS_UNICODE )        // Name is in Unicode
    {
        // Convert the caller-provided name from Unicode
        // to the propset's Ansi codepage.

        ULONG cb = 0;
        pvName = NULL;
        _OLECHARToMultiByte( poszName, (ULONG)-1, _CodePage,
                             (CHAR**)&pvName, &cb, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    // How long is this property name (in bytes)?

    _PropertyNameLength(pvName, &cbname);
    if( CP_WINUNICODE == _CodePage && sizeof(WCHAR) == cbname
        ||
        CP_WINUNICODE != _CodePage && sizeof(CHAR)  == cbname)
    {
        // Empty names are invalid
        StatusInvalidParameter(pstatus, "QueryPropid: name length");
        goto Exit;
    }

    // Get a pointer to the raw dictionary.

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Is there a dictionary?

    if (pdy != NULL)
    {
        // Yes - there is a dictionary.

        PROPERTYSECTIONHEADER const *psh = _GetSectionHeader();

        // Search the dictionary for an entry name matching
        // pvName.

        for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0];
             cdye > 0;
             cdye--, pent = _NextDictionaryEntry( pent ))
        {
            // Is the length of this dictionary entry valid?
            if ( _MapAddressToOffset(pent) + _DictionaryEntryLength( pent )
                 > psh->cbSection
               )
            {
                StatusCorruption(pstatus, "QueryPropid: section size");
                goto Exit;
            }

            // If the byte-length matches what we're looking for,
            // and the names compare successfully, then we're done.

            if ( CCh2CB(PropByteSwap( pent->cch )) == cbname
                 &&
                 _ComparePropertyNames(pvName, pent->sz,
                                       FALSE, // pvName, pent->sz could be dif Endians
                                       cbname,
                                       pstatus)
               )
            {
                propid = PropByteSwap( pent->propid );
                break;
            }
            else if( !NT_SUCCESS(*pstatus) )
            {
                // There was an error during the property name comparison
                goto Exit;
            }

        }   // for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0]; ...

        PROPASSERT(cdye > 0 || pent == Add2ConstPtr(pdy, cbDict));

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    // If we did an alloc on the name to munge it,
    // delete that buffer now.  We must cast pvName
    // as a non-const in order for the compiler to accept
    // the free call.

    if( pvName != poszName )
        _pma->Free( (VOID*) pvName );

    return(propid);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertyNameBuf
//
// Synopsis:    convert from a property id to a property name using the
//              dictionary in the property set, and putting the result
//              in a caller-provided buffer.
//
// Arguments:   [propid]        -- property id to look up
//              [aocName]       -- output buffer
//              [pcbName]       -- IN:  length of aocName;
//                                 OUT: actual length of name
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     TRUE if name is found in dictionary
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::QueryPropertyNameBuf(
    IN PROPID propid,
    OUT OLECHAR *aocName,
    IN OUT ULONG *pcbName,
    OUT NTSTATUS *pstatus)
{
    BOOLEAN fFound = FALSE;
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(propid != PID_DICTIONARY);
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);
    PROPASSERT(NULL != aocName);

    // Ensure that this isn't an already-deleted UD propset.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropertyNameBuf: deleted");
        goto Exit;
    }

    // Get a pointer to the raw dictionary.

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Is there a dictionary?
    if (pdy != NULL)
    {
        // Yes - the dictionary was found.

        ULONG cdye;
        ENTRY UNALIGNED const *pent;
        VOID const *pvDictEnd;

        // Get pointers to the first and last+1 entries.

        pent = pdy->rgEntry;
        pvDictEnd = Add2ConstPtr(pdy, cbDict);

        // Scan through the dictionary, searching for 'propid'.

        for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0];
             cdye > 0;
             cdye--, pent = _NextDictionaryEntry( pent ))
        {
            // Make sure this entry doesn't go off the end of the
            // dictionary.

            if (Add2ConstPtr(pent, _DictionaryEntryLength( pent )) > pvDictEnd)
            {
                StatusCorruption(pstatus, "QueryPropertyNameBuf: dictionary entry size");
                goto Exit;
            }

            // Is this the PID we're looking for?
            if (PropByteSwap(pent->propid) == propid)
            {
                // Yes.  Copy or convert the name into the caller's
                // buffer.

                // Is a Unicode to Ansi conversion required?
                if (_CodePage == CP_WINUNICODE      // Property set is Unicode
                    &&
                    !OLECHAR_IS_UNICODE )           // Caller's buffer is Ansi
                {
                    WCHAR *pwszName = (WCHAR*) pent->sz;

                    // If we're byte-swapping, alloc a new buffer, swap
                    // pwszName into it (getting the string into system-endian
                    // byte-order), and point pwszName to the result.

                    PBSInPlaceAlloc( &pwszName, NULL, pstatus );
                    if( !NT_SUCCESS( *pstatus )) goto Exit;

                    // Convert the Unicode string in the property set
                    // to the system default codepage.

                    _WideCharToOLECHAR( pwszName, (ULONG)-1, CP_ACP,
                                        &aocName, pcbName, pstatus );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    // If we allocated a buffer for byte-swapping,
                    // we don't need it any longer.

                    if( pwszName != (WCHAR*) pent->sz )
                        CoTaskMemFree( pwszName );
                }

                // Or is an Ansi to Unicode conversion required?
                else
                if (_CodePage != CP_WINUNICODE      // Property set is Ansi
                    &&
                    OLECHAR_IS_UNICODE )            // Caller's buffer is Unicode
                {
                    // Convert the Ansi property set name from the
                    // propset's codepage to Unicode.

                    _MultiByteToOLECHAR( (CHAR*) pent->sz, (ULONG)-1, _CodePage,
                                         &aocName, pcbName, pstatus );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
                }

                // Otherwise, no conversion of the name is required
                else
                {
                    // Copy the name into the caller's buffer.
                    RtlCopyMemory(aocName, pent->sz,
                                  min(CCh2CB(PropByteSwap(pent->cch)), *pcbName));

                    aocName[ (*pcbName / sizeof(OLECHAR)) - 1 ] = OLESTR('\0');


                    // Swap the name to the correct endian
                    // (This will do nothing if OLECHARs are CHARs).
                    PBSBuffer( aocName,
                               min( CCh2CB(PropByteSwap( pent->cch )), *pcbName),
                               sizeof(OLECHAR) );

                    // Tell the caller the actual size of the name.
                    *pcbName = CCh2CB( PropByteSwap( pent->cch ));
                }

                PROPASSERT( NULL == aocName || IsOLECHARString( aocName, MAXULONG ));
                fFound = TRUE;
                break;

            }   // if (pent->propid == propid)
        }   // for (cdye = pdy->cEntries, pent = &pdy->rgEntry[0]; ...

        PROPASSERT(fFound || pent == pvDictEnd);

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    return( fFound );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertyNames
//
// Synopsis:    query dictionary names for the passed property ids.
//
// Arguments:   [cprop]          -- count of name to propid mappings to change
//              [apid]           -- array of property ids
//              [aposz]          -- array of pointers to the new names
//              [pstatus]        -- pointer to NTSTATUS code
//
// Returns:     TRUE if the property exists.
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::QueryPropertyNames(
    IN ULONG cprop,
    IN PROPID const *apid,
    OUT OLECHAR *aposz[],
    OUT NTSTATUS *pstatus)
{
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!
    ULONG iprop;
    BOOLEAN fFound = FALSE;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

//    IFDBG( HRESULT &hr = *pstatus );
//    propITrace( "CPropertySetStream::QueryPropertyNames" );
//    propTraceParameters(( "cprop=%d, apid=%p, aposz=%p", cprop, apid, aposz ));

    // If this is an attempt to access a deleted UD
    // propset, exit now.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropertyNames: deleted");
        goto Exit;
    }

    // Validate the input array of strings.
    for (iprop = 0; iprop < cprop; iprop++)
    {
        PROPASSERT(aposz[iprop] == NULL);
    }

    // Get a pointer to the beginning of the dictionary
    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Did we get a dictionary?
    if (pdy != NULL)
    {
        // Yes, the dictionary exists.

        ULONG i;
        ENTRY UNALIGNED const *pent;

        // Iterate through each of the entries in the dictionary.

        for (i = 0, pent = &pdy->rgEntry[0];
             i < PropByteSwap( pdy->cEntries );
             i++, pent = _NextDictionaryEntry( pent ))
        {

            // Scan the input array of PIDs to see if one matches
            // this dictionary entry.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                if( PropByteSwap(pent->propid) == apid[iprop] )
                {
                    // We've found an entry in the dictionary
                    // that's in the input PID array.  Put the property's
                    // name in the caller-provided array (aposz).

                    PROPASSERT(aposz[iprop] == NULL);

                    // Do we need to convert to Unicode?

                    if (_CodePage != CP_WINUNICODE      // Ansi property set
                        &&
                        OLECHAR_IS_UNICODE)             // Unicode property names
                    {
                        ULONG cbName = 0;
                        _MultiByteToOLECHAR( (CHAR*)pent->sz, (ULONG)-1, _CodePage,
                                             &aposz[iprop], &cbName, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }

                    // Or, do we need to convert to Ansi?
                    else
                    if (_CodePage == CP_WINUNICODE      // Unicode property set
                        &&
                        !OLECHAR_IS_UNICODE)            // Ansi property names
                    {
                        ULONG cbName = 0;
                        WCHAR *pwszName = (WCHAR*) pent->sz;

                        // If necessary, swap the Unicode name in the dictionary,
                        // pointing pwszName to the new, byte-swapped, buffer.

                        PBSInPlaceAlloc( &pwszName, NULL, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // And convert to Ansi.
                        _WideCharToOLECHAR( pwszName, (ULONG)-1, CP_ACP,
                                            &aposz[iprop], &cbName, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // If we alloced a new buffer for byte-swapping,
                        // we can free it now.

                        if( pwszName != (WCHAR*) pent->sz )
                            CoTaskMemFree( pwszName );

                    }   // else if (_CodePage == CP_WINUNICODE ...

                    // Otherwise, both the propset & in-memory property names
                    // are both Unicode or both Ansi, so we can just do
                    // an alloc & copy.

                    else
                    {
                        aposz[iprop] = DuplicatePropertyName(
                                                    (OLECHAR *) pent->sz,
                                                    CCh2CB( PropByteSwap( pent->cch )),
                                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // If necessary, swap the in-memory copy.
                        PBSBuffer( (OLECHAR*) aposz[iprop],
                                   CCh2CB( PropByteSwap( pent->cch )),
                                   sizeof(OLECHAR) );

                    }   // if (_CodePage != CP_WINUNICODE ... else if ... else

                    PROPASSERT( IsOLECHARString( aposz[iprop], MAXULONG ));

                    fFound = TRUE;

                }   // if (pent->propid == apid[iprop])
            }   // for (iprop = 0; iprop < cprop; iprop++)
        }   // for (i = 0, pent = &pdy->rgEntry[0];

        PROPASSERT(pent == Add2ConstPtr(pdy, cbDict));

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    // If the property name simply didn't exist, return
    // a special success code.

    if( !fFound && NT_SUCCESS(*pstatus) )
	    *pstatus = STATUS_BUFFER_ALL_ZEROS;

    return( fFound );

}   // CPropertySetStream::QueryPropertyNames



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetPropertyNames
//
// Synopsis:    changes dictionary entry names associated with property ids.
//
// Arguments:   [cprop]         -- count of name to propid mappings to change
//              [apid]          -- array of property ids
//              [aposz]         -- array of pointers to the new names
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//
// Note:        Attempting to set a property name for a property that does not
//              exist in the property set is not an error.
//
//              Attempting to set a property name or property id that would
//		result in a duplicate name or property id causes the existing
//		entry(ies) to be replaced.
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::SetPropertyNames(
    IN ULONG cprop,
    IN const PROPID *apid,
    IN OPTIONAL OLECHAR const * const aposz[],
    OUT NTSTATUS *pstatus )
{

    //  ------
    //  Locals
    //  ------

    DICTIONARY *pdy = NULL;
    ULONG cbDictOld = 0;            // Byte granular Old dictionary size
    ULONG cbDictOldD = 0;           // Dword granular Old dictionary size
    ULONG iprop = 0;
    ULONG i = 0;
    ULONG cDel, cAdd;
    LONG cbDel, cbAdd;          // Byte granular sizes
    LONG cbChangeD;             // Dword granular size
    ENTRY UNALIGNED *pent;
    BOOLEAN fDupPropid = FALSE;
    BOOLEAN fDupName = FALSE;
    BOOLEAN fDeleteByName = FALSE;
    BOOLEAN fDeleteAll = FALSE;
    VOID **appvNames = NULL;

    ULONG cbstm;
    ULONG oDictionary;
    ULONG cbTail;
    ULONG cbNewSize;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::SetPropertyNames" );
    propTraceParameters(( "cprop=%d, apid=%p, aposz=%p",
                          cprop, apid, aposz ));

    
    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    //  --------
    //  Validate
    //  --------

    // Verify that this propset is modifiable.
    if (IsReadOnlyPropertySet(_Flags, _State))
    {
        StatusAccessDenied(pstatus, "SetPropertyNames: deleted or read-only");
        goto Exit;
    }

    if (aposz != NULL)
    {
        for (iprop = 0; iprop < cprop; iprop++)
        {
            PROPASSERT( IsOLECHARString( aposz[iprop], MAXULONG ));
        }
    }   // if (apwsz != NULL)

    //  ----------------------------------------------------------------
    //  If necessary, convert each of the caller-provided names:
    //  to Unicode (if the property set is Unicode) or Ansi (otherwise).
    //  ----------------------------------------------------------------

    // In the end, appvNames will have the names in the same codepage
    // as the property set.

    appvNames = (VOID **) aposz;
    if (appvNames != NULL)
    {
        // Do we need to convert the caller's names to Ansi?

        if( _CodePage != CP_WINUNICODE  // Property set is Ansi
            &&
            OLECHAR_IS_UNICODE )        // Caller's names are Unicode
        {
            // Allocate an array of cprop string pointers.

            appvNames = (VOID **) CoTaskMemAlloc( sizeof(char *) * cprop );
            if (appvNames == NULL)
            {
                StatusNoMemory(pstatus, "SetpropertyNames: Ansi Name Pointers");
                goto Exit;
            }
            RtlZeroMemory(appvNames, cprop * sizeof(appvNames[0]));

            // Convert the caller-provided property names from Unicode to
            // the property set's codepage.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                ULONG cb = 0;

                // Silently ignore PID_ILLEGAL
                if( PID_ILLEGAL == apid[iprop] ) continue;

                // Convert from aposz to appvNames
                appvNames[iprop] = NULL;
                _OLECHARToMultiByte( (OLECHAR*) aposz[iprop], (ULONG)-1, _CodePage,
                                     (CHAR**) &appvNames[iprop], &cb, pstatus );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // if( _CodePage != CP_WINUNICODE ...

        // Or, do we need to convert the caller's names to Unicode?

        if( _CodePage == CP_WINUNICODE  // Property set is Unicode
            &&
            !OLECHAR_IS_UNICODE  )      // Caller's names are Ansi
        {
            // Allocate an array of cprop string pointers.

            appvNames = (VOID **) CoTaskMemAlloc( sizeof(WCHAR*)*cprop );
            if (appvNames == NULL)
            {
                StatusNoMemory(pstatus, "SetpropertyNames: Unicode Name Pointers");
                goto Exit;
            }
            RtlZeroMemory(appvNames, cprop * sizeof(appvNames[0]));

            // Convert the caller-provided property names from the system
            // default Ansi codepage to Unicode.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                ULONG cb = 0;

                // Silently ignore PID_ILLEGAL
                if( PID_ILLEGAL == apid[iprop] ) continue;

                // Convert from aposz to appvNames
                appvNames[iprop] = NULL;
                _OLECHARToWideChar( (OLECHAR*) aposz[iprop], (ULONG)-1, CP_ACP,
                                    (WCHAR**) &appvNames[iprop], &cb, pstatus );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // if( _CodePage == CP_WINUNICODE )
    }   // if (appvNames != NULL)


    //  -----------------------------------------------------
    //  Compute total size of entries to be modified or added
    //  -----------------------------------------------------

    cbAdd = 0;
    cAdd = 0;
    for (iprop = 0; iprop < cprop; iprop++)
    {
        // Did the caller give us no array of names?  If so,
        // it means that the name for this PID is to be deleted.

        if (appvNames == NULL)
	{
            // If the PID is for the dictionary, then it must be the
            // only entry in apid, and it indicates that we're going to
            // delete all the names in the dictionary.

	    if (apid[iprop] == PID_DICTIONARY)
	    {
		if (cprop != 1)
		{
		    StatusInvalidParameter(pstatus, "SetPropertyNames: DeleteAll parms");
                    goto Exit;
		}
		fDeleteAll = TRUE;
	    }
        }

        // Otherwise, we're setting a new name for this PID.

	else
        {
            ULONG cbname;
            WORD wFormatRequired;

            // Silently ignore PID_ILLEGAL
            if( PID_ILLEGAL == apid[iprop] )
                continue;   // => for (iprop = 0; iprop < cprop; iprop++)

            // Validate the caller-provided length.

            wFormatRequired = _PropertyNameLength(appvNames[iprop], &cbname);

            if( CP_WINUNICODE == _CodePage && sizeof(WCHAR) == cbname
                ||
                CP_WINUNICODE != _CodePage && sizeof(CHAR)  == cbname)
            {
                // Empty names are not supported
                StatusInvalidParameter(pstatus, "SetPropertyNames: name length");
                goto Exit;
            }
            _pph->wFormat = max( _pph->wFormat, wFormatRequired );

            // See if this propid or name appears later in the array.

            for (i = iprop + 1; i < cprop; i++)
            {
                ULONG cbname2;

                if (apid[i] == apid[iprop])
                {
                    fDupPropid = TRUE;
                    break;
                }

                _PropertyNameLength(appvNames[i], &cbname2);

                if (cbname == cbname2 &&
                    _ComparePropertyNames(
                                appvNames[iprop],
                                appvNames[i],
                                TRUE, // Both names are in the same byte-order
                                cbname,
                                pstatus))
                {
                    fDupName = TRUE;
                    break;
                }
                else if( !NT_SUCCESS(*pstatus) )
                {
                    // There was an error in _ComparePropertyNames
                    goto Exit;
                }
            }

            // If this propid appears only once or if it's the last instance,
            // count it.  If the property set is Unicode, include DWORD padding.

            if (i == cprop)
            {
                propDbg(( DEB_ITRACE,
                    _CodePage == CP_WINUNICODE?
                        "Adding New Entry: propid=%lx  L'%ws'\n" :
                        "Adding New Entry: propid=%lx  '%s'\n",
                    apid[iprop],
                    appvNames[iprop]));

                cAdd++;

                cbAdd += CB_DICTIONARY_ENTRY + cbname;
                if( _CodePage == CP_WINUNICODE )
                {
                    cbAdd = DwordAlign( cbAdd );
                }
            }
        }
    }
    PROPASSERT( _CodePage == CP_WINUNICODE ? IsDwordAligned( cbAdd ) : TRUE );


    //  ---------------------------------------------
    //  Get the dictionary, creating it if necessary.
    //  ---------------------------------------------

    _SetModified( pstatus );
    if( !NT_SUCCESS(*pstatus) )
    {
        propDbg(( DEB_ERROR, "SetPropertyNames: Couldn't SetModified (%08x)\n", *pstatus ));
        goto Exit;
    }

    for (i = 0; ; i++)
    {
        PROPERTY_INFORMATION pinfo;
        PROPVARIANT var;

        pdy = (DICTIONARY *) _LoadProperty(PID_DICTIONARY, &cbDictOld, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (pdy != NULL)
        {
            break;
        }
        PROPASSERT(i == 0);
        if (cprop == 0 || appvNames == NULL)
        {
            // no dictionary and we are deleting or doing nothing -- return
            goto Exit;
        }
        // create dictionary if it doesn't exist
        propDbg(( DEB_ITRACE, "Creating empty dictionary\n"));

        PROPASSERT(CB_SERIALIZEDPROPERTYVALUE == CB_DICTIONARY);
        pinfo.cbprop = CB_SERIALIZEDPROPERTYVALUE;
        pinfo.pid = PID_DICTIONARY;

        var.vt = VT_DICTIONARY;
        SetValue(1, NULL, &var, &pinfo, NULL, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        Validate(pstatus);     // Make sure dictionary was properly created
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
        DebugTrace(0, Dbg, ("Created empty dictionary\n"));

    }   // for (i = 0; ; i++)

    //  ----------------------------------------------------------------
    //  Compute total size of existing entries to be modified or deleted
    //  ----------------------------------------------------------------

    // Walk the dictionary looking for entries which are referenced
    // in the caller's 'apid' array or 'appvNames' array.

    cbDel = 0;
    cDel = 0;
    for (i = 0, pent = &pdy->rgEntry[0];
         i < PropByteSwap( pdy->cEntries );
         i++, pent = _NextDictionaryEntry( pent ))
    {
        propDbg(( DEB_ITRACE,
            _CodePage == CP_WINUNICODE?
                "Dictionary Entry @%lx: propid=%lx L'%ws'\n" :
                "Dictionary Entry @%lx: propid=%lx '%s'\n",
            pent,
            PropByteSwap( pent->propid ),
            pent->sz ));

        // For this dictionary entry, walk the caller's
        // 'apid' and 'appvNames' arrays, looking for a match.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // Silently ignore PID_ILLEGAL
            if( PID_ILLEGAL == apid[iprop] ) continue;

            // If we get to the bottom of this 'for' loop,
            // then we know that we've found an entry to delete.
            // If fDeleteAll, or the PID in apid matches this
            // dictionary entry, then we can fall to the bottom.
            // Otherwise, the following 'if' block checks the
            // name in 'appvNames' against this dictionary entry.

            if (!fDeleteAll
                &&
                apid[iprop] != PropByteSwap( pent->propid ))
            {
                // The caller's PID didn't match this dictionary entry,
                // does the name?

                ULONG cbname;

                // If we have no names from the caller, then we obviously
                // don't have a match, and we can continue on to check this
                // dictionary entry against the next of the caller's PIDs.

                if (appvNames == NULL)
                {
                    continue;
                }

                // Or, if this name from the caller doesn't match this
                // dictionary entry, we again can continue on to check
                // the next of the caller's properties.

                _PropertyNameLength(appvNames[iprop], &cbname);
                if (cbname != CCh2CB( PropByteSwap( pent->cch ))
                    ||
                    !_ComparePropertyNames(
                            appvNames[iprop],
                            pent->sz,
                            FALSE,  // appvNames & pent->sz may be dif endians.
                            cbname,
                            pstatus )
                   )
                {
                    // Check to see if there was an error from _ComparePropertyNames
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    continue;
                }
                fDeleteByName = TRUE;

            }   // if (!fDeleteAll ...

            // If we reach this point, we're going to delete this entry
            // in the dictionary.  So update cDel & cbDel.

            propDbg(( DEB_ITRACE,
                "Deleting Entry (%s) @%lx: propid=%lx\n",
                fDeleteAll? "DeleteAll" :
                    apid[iprop] == PropByteSwap(pent->propid)
                                ? "replace by propid"
                                : "replace by name",
                pent,
                PropByteSwap( pent->propid )));

            cDel++;
            cbDel += _DictionaryEntryLength( pent );

            // We don't need to continue through the caller's arrays,
            // we can move on to the next dictionary entry.

            break;

        }   // for (iprop = 0; iprop < cprop; iprop++)
    }   // for (i = 0, pent = &pdy->rgEntry[0]; ...

    PROPASSERT(pent == Add2Ptr(pdy, cbDictOld));
    PROPASSERT( _CodePage == CP_WINUNICODE ? IsDwordAligned( cbDel ) : TRUE );


    cbDictOldD = DwordAlign(cbDictOld);
    cbChangeD = DwordAlign(cbDictOld + cbAdd - cbDel) - cbDictOldD;

    cbstm = _oSection + _GetSectionHeader()->cbSection + _cbTail;
    oDictionary = _MapAddressToOffset(pdy);
    cbTail;

    cbTail = cbstm - (_oSection + oDictionary + cbDictOldD);

    //  --------------------------------------------------------
    //  Before we change anything, grow the stream if necessary.
    //  --------------------------------------------------------

    if (cbChangeD > 0)
    {
        propDbg(( DEB_ITRACE,
            "SetSize(%x) dictionary grow\n", cbstm + cbChangeD));
        if (cbstm + cbChangeD > CBMAXPROPSETSTREAM)
        {
            StatusDiskFull(pstatus, "SetPropertyNames: 256k limit");
            goto Exit;
        }

        _MSTM(SetSize)(cbstm + cbChangeD, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // reload all pointers into mapped image:

        pdy = (DICTIONARY *) _MapOffsetToAddress(oDictionary);

        // move everything after the dictionary back by cbChangeD bytes.

        PropMoveMemory(
            "SetPropertyNames:TailBack",
            _GetSectionHeader(),
            Add2Ptr(pdy, cbDictOldD + cbChangeD),
            Add2Ptr(pdy, cbDictOldD),
            cbTail);
    }

    //  -------------------------------------------------------------------
    //  Walk through the existing dictionary and compact unmodified entries
    //  toward the front.  New and modified entries will be appended later.
    //  -------------------------------------------------------------------

    VOID *pvSrc;
    VOID *pvDst;
    ULONG cbCopy;

    pvDst = pvSrc = pent = &pdy->rgEntry[0];
    cbCopy = 0;

    if (!fDeleteAll)
    {
        ULONG cb;

        for (i = 0; i < PropByteSwap(pdy->cEntries); i++)
        {
            for (iprop = 0; iprop < cprop; iprop++)
            {
                if( apid[iprop] == PropByteSwap(pent->propid) )
                {
                    break;
                }
                if (fDeleteByName)      // if deleting any properties by name
                {
                    ULONG cbname;

                    _PropertyNameLength(appvNames[iprop], &cbname);
                    if (cbname == CCh2CB( PropByteSwap( pent->cch ))
                        &&
                        _ComparePropertyNames(
                                appvNames[iprop],
                                pent->sz,
                                FALSE,  // appvNames & pent->sz may be dif endians
                                cbname,
                                pstatus)
                       )
                    {
                        break;          // found an entry to be removed.
                    }
                    else if( !NT_SUCCESS(*pstatus) )
                    {
                        // There was an error in _ComparePropertyNames
                        goto Exit;
                    }
                }
            }   // for (iprop = 0; iprop < cprop; iprop++)

            cb = _DictionaryEntryLength( pent );
            pent = _NextDictionaryEntry( pent );

            if (iprop == cprop)     // keep the dictionary entry
            {
                cbCopy += cb;
            }
            else                    // remove the dictionary entry
            {
                if (cbCopy != 0)
                {
                    if (pvSrc != pvDst)
                    {
                        PropMoveMemory(
                            "SetPropertyNames:Compact",
                            _GetSectionHeader(),
                            pvDst,
                            pvSrc,
                            cbCopy);
                    }
                    pvDst = Add2Ptr(pvDst, cbCopy);
                    cbCopy = 0;
                }
                pvSrc = pent;
            }
        }   // for (i = 0; i < PropByteSwap(pdy->cEntries); i++)

        // Compact last chunk and point past compacted entries.

        if (cbCopy != 0 && pvSrc != pvDst)
        {
            PropMoveMemory(
                "SetPropertyNames:CompactLast",
                _GetSectionHeader(),
                pvDst,
                pvSrc,
                cbCopy);
        }
        pent = (ENTRY UNALIGNED *) Add2Ptr(pvDst, cbCopy);

    }   // if (!fDeleteAll)

    pdy->cEntries = PropByteSwap( PropByteSwap(pdy->cEntries) - cDel );

    //  ------------------------------------
    //  Append new and modified entries now.
    //  ------------------------------------

    if (appvNames != NULL)
    {
        // Add each name to the property set.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // See if this propid appears later in the array.

            i = cprop;
            if (fDupPropid)
            {
                for (i = iprop + 1; i < cprop; i++)
                {
                    if (apid[i] == apid[iprop])
                    {
                        break;
                    }
                }
            }

            // See if this name appears later in the array.

            if (i == cprop && fDupName)
            {
                ULONG cbname;

                _PropertyNameLength(appvNames[iprop], &cbname);

                for (i = iprop + 1; i < cprop; i++)
                {
                    ULONG cbname2;

                    _PropertyNameLength(appvNames[i], &cbname2);

                    if (cbname == cbname2 &&
                        _ComparePropertyNames(
                            appvNames[iprop],
                            appvNames[i],
                            TRUE,   // Both names are the same endian
                            cbname,
                            pstatus))
                    {
                        break;
                    }
                    else if( !NT_SUCCESS(*pstatus) )
                        // There was an error in _ComparePropertyNames
                        goto Exit;
                }
            }

            // Silently ignore PID_ILLEGAL
            if( PID_ILLEGAL == apid[iprop] ) continue;

            // If this propid appears only once or if it's the last instance,
            // append the mapping entry.

            if (i == cprop)
            {
                ULONG cbname;

                // Set the PID & character-count fields for this entry.
                _PropertyNameLength(appvNames[iprop], &cbname);
                pent->propid = PropByteSwap( apid[iprop] );
                pent->cch = PropByteSwap( CB2CCh( cbname ));

                // Copy the name into the dictionary.
                RtlCopyMemory(pent->sz, appvNames[iprop], cbname);

                // If this is a Unicode property set, we need to correct
                // the byte-order.

                if( CP_WINUNICODE == _CodePage )
                {
                    PBSBuffer( pent->sz, cbname, sizeof(WCHAR) );
                }

                // Zero-out the pad bytes.

		RtlZeroMemory(
			Add2Ptr(pent->sz, cbname),
			DwordRemain((ULONG) (ULONG_PTR) pent->sz + cbname));


                pent = _NextDictionaryEntry( pent );
            }
        }   // for (iprop = 0; iprop < cprop; iprop++)

        // We've added all the names, now let's update the entry count.
        pdy->cEntries = PropByteSwap( PropByteSwap(pdy->cEntries) + cAdd );

    }   // if (appvNames != NULL)

    // Zero the possible partial DWORD at the end of the dictionary.

    {
        ULONG cb = (ULONG) ((BYTE *) pent - (BYTE *) pdy);
        PROPASSERT(DwordAlign(cb) == cbDictOldD + cbChangeD);
        RtlZeroMemory(pent, DwordRemain(cb));
    }


    //  -----------------------------------------------------
    //  Adjust the remaining property offsets in the section.
    //  -----------------------------------------------------

    PROPERTYIDOFFSET *ppo, *ppoMax;
    PROPERTYSECTIONHEADER *psh;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Don't rely on the dictionary being the first property.
    // Skip PID_DICTIONARY and adjust every other higher entry.

    for ( ; ppo < ppoMax; ppo++)
    {
        if (ppo->dwOffset > oDictionary)
        {
            ppo->dwOffset += cbChangeD;
            PROPASSERT(ppo->propid != PID_DICTIONARY);
        }
    }

    // Update the size of the section
    psh->cbSection += cbChangeD;

    if (cbChangeD < 0)
    {
        // move everything after the dictionary forward by cbChangeD bytes.

        PropMoveMemory(
            "SetPropertyNames:TailUp",
            _GetSectionHeader(),
            Add2Ptr(pdy, cbDictOldD + cbChangeD),
            Add2Ptr(pdy, cbDictOldD),
            cbTail);
    }
    if (_cbTail != 0)
    {
	_PatchSectionOffsets(cbChangeD);
    }

    // If we need to shrink the stream or if we are cleaning up after a
    // previous shrink that failed, do it last.

    if ( cbChangeD < 0 )
    {
        propDbg(( DEB_ITRACE,
            "SetSize(%x) dictionary shrink\n",
            cbstm + cbChangeD));
        _MSTM(SetSize)(cbstm + cbChangeD, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // If we had to convert the array of names into a different
    // codepage, delete those temporary buffers now.

    if (appvNames != NULL && appvNames != (VOID **) aposz)
    {
        for (iprop = 0; iprop < cprop; iprop++)
        {
            _pma->Free( appvNames[iprop] );
        }
        CoTaskMemFree( appvNames );
    }

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateStructure
//
// Synopsis:    validate property set structure
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateStructure(OUT NTSTATUS *pstatus)
{
    PROPID propid;
    ULONG cb;

    OLECHAR *poszName = NULL;

    *pstatus = STATUS_SUCCESS;

    // Walk through properties to make sure all properties are consistent
    // and are contained within the section size.  A NULL return value
    // means _LoadProperty walked the entire section, so we can quit then.

    for (propid = PID_CODEPAGE; propid != PID_ILLEGAL; propid++)
    {
        SERIALIZEDPROPERTYVALUE const *pprop;

        pprop = GetValue(propid, &cb, pstatus);
        if( STATUS_NOT_SUPPORTED == *pstatus )
            // We're working with an up-level property set
            *pstatus = STATUS_SUCCESS;
        else if( !NT_SUCCESS(*pstatus) )
        {
            goto Exit;
        }

        if (NULL == pprop)
        {
            break;
        }
    }

    // Walk through dictionary entries to make sure all entries are consistent
    // and are contained within the dictionary size.  A FALSE return value
    // means QueryPropertyNameBuf walked the entire dictionary, so quit then.

    for (propid = PID_CODEPAGE + 1; propid != PID_ILLEGAL; propid++)
    {
        BOOL fExists;

        fExists = QueryPropertyNames( 1, &propid, &poszName, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if( !fExists )
        {
            break;
        }
        else
        {
            _pma->Free( poszName );
            poszName = NULL;
        }
    }

    if (_cSection > 1)
    {
	FORMATIDOFFSET const *pfo;

	if (_cSection != 2)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: csection(%x) != 2",
		_cSection));
	    StatusCorruption(pstatus, "_ValidateStructure: csection != 2");
            goto Exit;
	}
	pfo = _GetFormatidOffset(0);
	if (pfo->fmtid != guidDocumentSummary)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: DocumentSummary[0] fmtid"));
	    StatusCorruption(pstatus, "_ValidateStructure: DocumentSummary[0] fmtid");
            goto Exit;
	}
	if (!IsDwordAligned(pfo->dwOffset))
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: dwOffset[0] = %x",
		pfo->dwOffset));
	    StatusCorruption(pstatus, "_ValidateStructure: dwOffset[0]");
            goto Exit;
	}

	pfo = _GetFormatidOffset(1);
	if (pfo->fmtid != guidDocumentSummarySection2)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: DocumentSummary[1] fmtid"));
	    StatusCorruption(pstatus, "_ValidateStructure: DocumentSummary[1] fmtid");
            goto Exit;
	}
	if (!IsDwordAligned(pfo->dwOffset))
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: dwOffset[1] = %x",
		pfo->dwOffset));
	    StatusCorruption(pstatus, "_ValidateStructure: dwOffset[1]");
            goto Exit;
	}
    }   // if (_cSection > 1)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnPropidCompare
//
// Synopsis:    qsort helper to compare propids in a PROPERTYIDOFFSET array.
//
// Arguments:   [ppo1]          -- pointer to PROPERTYIDOFFSET 1
//              [ppo2]          -- pointer to PROPERTYIDOFFSET 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
int __cdecl
fnPropidCompare(VOID const *ppo1, VOID const *ppo2)
{
    return(((PROPERTYIDOFFSET const *) ppo1)->propid -
           ((PROPERTYIDOFFSET const *) ppo2)->propid);
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnOffsetCompare
//
// Synopsis:    qsort helper to compare offsets in a PROPERTYIDOFFSET array.
//
// Arguments:   [ppo1]          -- pointer to PROPERTYIDOFFSET 1
//              [ppo2]          -- pointer to PROPERTYIDOFFSET 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

int __cdecl
fnOffsetCompare(VOID const *ppo1, VOID const *ppo2)
{
    return(((PROPERTYIDOFFSET const *) ppo1)->dwOffset -
           ((PROPERTYIDOFFSET const *) ppo2)->dwOffset);
}


//+--------------------------------------------------------------------------
// Member:      GetStringLength
//
// Synopsis:    return length of possibly unicode string.
//
// Arguments:   [CodePage]   -- TRUE if string is Unicode
//              [pwsz]       -- pointer to string
//              [cb]         -- MAXULONG or string length with L'\0' or '\0'
//
// Returns:     length of string in bytes including trailing L'\0' or '\0'
//+--------------------------------------------------------------------------

ULONG
GetStringLength(
    IN USHORT CodePage,
    IN WCHAR const *pwsz,
    IN ULONG cb)
{
    ULONG i;

    if (CodePage == CP_WINUNICODE)
    {
        for (i = 0; i < cb/sizeof(WCHAR); i++)
        {
            if (pwsz[i] == L'\0')
            {
                break;
            }
        }
        PROPASSERT(cb == MAXULONG || cb == (i + 1) * sizeof(WCHAR));
        return((i + 1) * sizeof(WCHAR));
    }
    else
    {
        char *psz = (char *) pwsz;

        for (i = 0; i < cb; i++)
        {
            if (psz[i] == '\0')
            {
                break;
            }
        }
        PROPASSERT(cb == MAXULONG || cb == (i + 1) * sizeof(char));
        return((i + 1) * sizeof(char));
    }
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateProperties
//
// Synopsis:    validate properties
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateProperties(OUT NTSTATUS *pstatus) const
{
    PROPERTYIDOFFSET *apo = NULL;
    PROPERTYSECTIONHEADER const *psh = _GetSectionHeader();
    static ULONG cValidate = 0;
    ULONG cbwasted = 0;
    ULONG cbtotal = 0;

    *pstatus = STATUS_SUCCESS;

    cValidate++;
    DebugTrace(0, DEBTRACE_PROPVALIDATE, (
	"_ValidateProperties(%x ppsstm=%x state=%x pph=%x)\n",
	cValidate,
	this,
	_State,
	_pph));

    if (psh->cProperties != 0)
    {
        PROPERTYIDOFFSET *ppo, *ppoMax;

        apo = reinterpret_cast<PROPERTYIDOFFSET*>
              ( CoTaskMemAlloc( sizeof(PROPERTYIDOFFSET) * (psh->cProperties + 1) ));
        if (apo == NULL)
        {
            *pstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        RtlCopyMemory(
                apo,
                psh->rgprop,
                psh->cProperties * CB_PROPERTYIDOFFSET);

        ppoMax = apo + psh->cProperties;
        ppoMax->propid = PID_ILLEGAL;
        ppoMax->dwOffset = psh->cbSection;

        // Sort by property id and check for duplicate propids:

        qsort(apo, psh->cProperties, sizeof(apo[0]), &fnPropidCompare);

        for (ppo = apo; ppo < ppoMax; ppo++)
        {
            if (ppo->propid == PID_ILLEGAL ||
                ppo->propid == ppo[1].propid)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateProperties(bad propid=%x @%x)\n",
                    ppo->propid,
                    ppo->dwOffset));
                StatusCorruption(pstatus, "_ValidateProperties: bad or dup propid");
                goto Exit;
            }


        }

        // Sort by offset and check for overlapping values.

        qsort(apo, psh->cProperties, sizeof(apo[0]), &fnOffsetCompare);

        cbtotal = _oSection;
        for (ppo = apo; ppo < ppoMax; ppo++)
        {
            ULONG cbdiff;   // Size of a prop according to PROPID/Offset table
            ULONG cbpropraw;// Size of prop based on knowledge of the type
            ULONG cbprop;   // cbpropraw + padding for alignment

            SERIALIZEDPROPERTYVALUE const *pprop;

            cbprop = MAXULONG;
            cbpropraw = cbprop;
            cbdiff = ppo[1].dwOffset - ppo->dwOffset;

            if (IsDwordAligned(ppo->dwOffset) &&
                IsDwordAligned(ppo[1].dwOffset))
            {
                pprop = (SERIALIZEDPROPERTYVALUE const *)
                            _MapOffsetToAddress(ppo->dwOffset);

                if (ppo->propid == PID_DICTIONARY)
                {
                    cbprop = _DictionaryLength(
                                    (DICTIONARY const *) pprop,
                                    cbdiff,
                                    pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    cbpropraw = cbprop;
                    cbprop = DwordAlign(cbprop);
                }
                else
                {
                    cbprop = PropertyLengthNoEH(pprop, cbdiff, 0, pstatus);
                    if( STATUS_NOT_SUPPORTED == *pstatus )
                    {
                        // We're working with an up-level property set.
                        // Assume it's OK.
                        cbprop = cbdiff;
                        *pstatus = STATUS_SUCCESS;
                    }
                    else if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    cbpropraw = cbprop;
                }

                DebugTrace(0, DEBTRACE_PROPVALIDATE, (
                    "_ValidateProperties(%x) i=%x cb=%x/%x/%x @%x/%x pid=%x\n",
                    cValidate,
                    ppo - apo,
                    cbprop,
                    cbdiff,
                    ppo->dwOffset,
                    pprop,
                    ppo->propid));
                cbtotal += cbdiff;

                // As long as we're looking at the properties, let's check for
                // property types that require a minimum format version (wFormat).

                if( PID_DICTIONARY == ppo->propid )
                    ;   // pprop->dwType isn't actually a type for the dictionary property
                else
                if( PROPSET_WFORMAT_EXPANDED_VTS > GetFormatVersion()
                    &&
                    (
                      !IsOriginalPropVariantType( static_cast<VARTYPE>(PropByteSwap( pprop->dwType )))
                      ||
                      (VT_BYREF & PropByteSwap(pprop->dwType))
                    )
                  )
                {
                    DebugTrace(0, DEBTRACE_ERROR, (
                        "_ValidateProperties(bad value type: propid/vt=%x/%x @%x/%x cb=%x/%x/%x ppsstm=%x)\n",
                        ppo->propid, pprop->dwType,
                        ppo->dwOffset, pprop,
                        cbpropraw, cbprop, cbdiff,
                        this));
                    StatusCorruption(pstatus, "_ValidateProperties: bad property type");
                    goto Exit;
                }

                // Technically, the OLE spec allows extra unused space
                // between properties, but this implementation never
                // writes out streams with space between properties.

                if( cbdiff == cbprop )
                {
                    continue;
                }
            }
            DebugTrace(0, DEBTRACE_ERROR, (
                "_ValidateProperties(bad value length: propid=%x @%x/%x cb=%x/%x/%x ppsstm=%x)\n",
                ppo->propid,
                ppo->dwOffset, pprop,
                cbpropraw, cbprop, cbdiff,
                this));
            StatusCorruption(pstatus, "_ValidateProperties: bad property length");
            goto Exit;

        }   // for (ppo = apo; ppo < ppoMax; ppo++)

    }   // if (psh->cProperties != 0)

    //  ----
    //  Exit
    //  ----

Exit:

    CoTaskMemFree( apo );

    DebugTrace(0, cbwasted != 0? 0 : Dbg, (
        "_ValidateProperties(wasted %x bytes, total=%x)\n",
        cbwasted,
        cbtotal));

}
#endif


#if DBGPROP
typedef struct tagENTRYVALIDATE         // ev
{
    ENTRY UNALIGNED const *pent;
    CPropertySetStream const *ppsstm;
} ENTRYVALIDATE;
#endif


//+--------------------------------------------------------------------------
// Member:      fnEntryPropidCompare
//
// Synopsis:    qsort helper to compare propids in a ENTRYVALIDATE array.
//
// Arguments:   [pev1]          -- pointer to ENTRYVALIDATE 1
//              [pev2]          -- pointer to ENTRYVALIDATE 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
int __cdecl
fnEntryPropidCompare(VOID const *pev1, VOID const *pev2)
{
    return(((ENTRYVALIDATE const *) pev1)->pent->propid -
           ((ENTRYVALIDATE const *) pev2)->pent->propid);
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnEntryNameCompare
//
// Synopsis:    qsort helper to compare names in a ENTRYVALIDATE array.
//
// Arguments:   [pev1]          -- pointer to ENTRYVALIDATE 1
//              [pev2]          -- pointer to ENTRYVALIDATE 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
int __cdecl
fnEntryNameCompare(VOID const *pev1, VOID const *pev2)
{
    ENTRY UNALIGNED const *pent1;
    ENTRY UNALIGNED const *pent2;
    INT rc;
    NTSTATUS Status = STATUS_SUCCESS;

    pent1 = ((ENTRYVALIDATE const *) pev1)->pent;
    pent2 = ((ENTRYVALIDATE const *) pev2)->pent;

    rc = PropByteSwap(pent1->cch) - PropByteSwap(pent2->cch);
    if (rc == 0)
    {
        rc = !((ENTRYVALIDATE const *) pev1)->ppsstm->_ComparePropertyNames(
                    pent1->sz,
                    pent2->sz,
                    TRUE,       // Both names have the same byte-order
                    ( (ENTRYVALIDATE const *)
                      pev1
                    )->ppsstm->CCh2CB(PropByteSwap( pent1->cch )),
                    &Status );
    }
    return(rc);
}
#endif


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateDictionary
//
// Synopsis:    validate property set dictionary
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateDictionary(OUT NTSTATUS *pstatus)
{
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!

    ENTRYVALIDATE *aev = NULL;
    ENTRYVALIDATE *pev, *pevMax;
    PROPERTYSECTIONHEADER const *psh;
    ENTRY UNALIGNED const *pent;
    ENTRY entMax;
    VOID const *pvDictEnd;

    *pstatus = STATUS_SUCCESS;

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (pdy != NULL && PropByteSwap(pdy->cEntries) != 0)
    {
        aev = reinterpret_cast<ENTRYVALIDATE*>
              ( CoTaskMemAlloc( sizeof(ENTRYVALIDATE) * (PropByteSwap(pdy->cEntries) + 1) ));
        if (aev == NULL)
        {
            *pstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        psh = _GetSectionHeader();
        pent = pdy->rgEntry;
        pvDictEnd = Add2ConstPtr(pdy, cbDict);
        pevMax = aev + PropByteSwap( pdy->cEntries );

        for (pev = aev; pev < pevMax; pev++)
        {
            ULONG cb = _DictionaryEntryLength( pent );

            // If the cb is greater than the max allowed in original
            // property sets (after allowing for padding and per-entry
            // overhead), then check the wFormat field in the header.

            if( CB2CCh(cb) > CCH_MAXPROPNAME + CB_DICTIONARY_ENTRY + sizeof(DWORD) )
            {
                if( PROPSET_WFORMAT_LONG_NAMES > GetFormatVersion() )
                {
                    StatusCorruption(pstatus, "ValidateDictionary:  entry size too big for wFormat");
                    goto Exit;
                }
            }

            if (Add2ConstPtr(pent, cb) > pvDictEnd)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad entry size for propid=%x)\n",
                    PropByteSwap( pev->pent->propid )));
                StatusCorruption(pstatus, "ValidateDictionary: entry size");
                goto Exit;
            }
            pev->pent = pent;
            pev->ppsstm = this;

#ifdef LITTLEENDIAN
            if (_CodePage == CP_WINUNICODE)
            {
                PROPASSERT(IsUnicodeString((WCHAR const *) pent->sz,
                                            CCh2CB(PropByteSwap( pent->cch ))));
            }
            else
            {
                PROPASSERT(IsAnsiString((char const *) pent->sz,
                                        CCh2CB( PropByteSwap( pent->cch ))));
            }
#endif

            pent = _NextDictionaryEntry( pent );
        }
        if ((VOID const *) pent != pvDictEnd)
        {
            StatusCorruption(pstatus, "ValidateDictionary: end offset");
            goto Exit;
        }
        entMax.cch = 0;
        entMax.propid = PID_ILLEGAL;
        pevMax->pent = &entMax;
        pevMax->ppsstm = this;

        // Sort by property id and check for duplicate propids:

        qsort(aev, PropByteSwap(pdy->cEntries), sizeof(aev[0]), &fnEntryPropidCompare);

        for (pev = aev; pev < pevMax; pev++)
        {
            if (PID_ILLEGAL == PropByteSwap(pev->pent->propid)
                ||
                pev[1].pent->propid == pev->pent->propid)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad propid=%x)\n",
                    PropByteSwap( pev->pent->propid )));
                StatusCorruption(pstatus, "_ValidateDictionary: bad or dup propid");
                goto Exit;
            }
        }

        // Sort by property name and check for duplicate names:

        qsort(aev, PropByteSwap(pdy->cEntries), sizeof(aev[0]), &fnEntryNameCompare);

        for (pev = aev; pev < pevMax; pev++)
        {
            if (pev->pent->cch == 0
                ||
                ( pev->pent->cch == pev[1].pent->cch
                  &&
                  _ComparePropertyNames(
                         pev->pent->sz,
                         pev[1].pent->sz,
                         TRUE,              // Names are the same byte-order
                         CCh2CB(PropByteSwap(pev->pent->cch)),
                         pstatus)
                )
               )
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad name for propid=%x)\n",
                    PropByteSwap( pev->pent->propid )));
                StatusCorruption(pstatus, "_ValidateDictionary: bad or dup name");
                goto Exit;
            }
            else if( !NT_SUCCESS(*pstatus) )
                // There was an error in _ComparePropertyNames
                goto Exit;

        }   // for (pev = aev; pev < pevMax; pev++)
    }   // if (pdy != NULL && pdy->cEntries != 0)

    //  ----
    //  Exit
    //  ----

Exit:

    CoTaskMemFree( aev );

}
#endif  // DBGPROP


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Validate
//
// Synopsis:    validate entire property stream
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP

extern "C" BOOLEAN fValidatePropSets = KERNELSELECT(DBG, TRUE);

VOID
CPropertySetStream::Validate(OUT NTSTATUS *pstatus)
{
    if (fValidatePropSets && (_State & CPSS_USERDEFINEDDELETED) == 0)
    {
        ULONG cbstm = _MSTM(GetSize)(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Walk through section headers to make sure all sections are contained
        // within the stream size.

        if (_ComputeMinimumSize(cbstm, pstatus) != 0)
        {
            // If an error had occurred in the above call,
            // it would have returned zero.

            _ValidateStructure( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ValidateProperties( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ValidateDictionary( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ComputeMinimumSize(cbstm, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }
    }   // if (fValidatePropSets && (_State & CPSS_USERDEFINEDDELETED) == 0)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}
#endif


//+--------------------------------------------------------------------------
// Function:    CopyPropertyValue
//
// Synopsis:    copy a property value into a supplied buffer
//
// Arguments:   [pprop]         -- property value (possibly NULL)
//              [cb]            -- property length
//              [ppropDst]      -- output buffer for property value
//              [pcb]           -- length of buffer (in); actual length (out)
//
// Returns:     None
//---------------------------------------------------------------------------

#ifdef WINNT
VOID
CopyPropertyValue(
    IN OPTIONAL SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cb,
    OUT SERIALIZEDPROPERTYVALUE *ppropDst,
    OUT ULONG *pcb)
{
#if DBG==1
    NTSTATUS Status;
#endif

    if (pprop == NULL)
    {
        static SERIALIZEDPROPERTYVALUE prop = { VT_EMPTY, };

        pprop = &prop;
        cb = CB_SERIALIZEDPROPERTYVALUE;
    }
    PROPASSERT(cb == PropertyLengthNoEH(pprop, cb, 0, &Status)
               &&
               NT_SUCCESS(Status) );

    RtlCopyMemory(ppropDst, pprop, min(cb, *pcb));
    *pcb = cb;
}
#endif  // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\iprop\privoa.cxx ===
#include <pch.cxx>

// Bring in the real code, but avoid compiler errors by
// preventing an unnecessary include of ole2int.h

#define _OLE2INT_H_
#include "..\\..\\..\\com\\class\\privoa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\iprop\dllmain.cxx ===
//+============================================================================
//
//  File:       dllmain.cxx
//
//  Purpose:    This file provides the registration and deregistration 
//              functions for the IProp DLL:  DllRegisterServer and
//              DllUnregisterServer.  These two functions register/
//              deregister the property set marshaling code:
//              IPropertySetStorage, IPropertyStorage, IEnumSTATPROPSETSTG,
//              and IEnumSTATPROPSTG.  Note that this registration is
//              different from the typical server registration in that
//              it only registers the marshaling code, it does not 
//              register an instantiable COM server.  Also, no registration
//              takes place if OLE32 is already registered to perform
//              this marshaling.
//
//              The actual DllRegisterServer and DllUnregisterServer
//              implementations are at the end of this file.  First,
//              several helper functions are defined.
//
//+============================================================================

//  --------
//  Includes
//  --------

#include <pch.cxx>
#include <tchar.h>

// The following is from "olectl.h".  That file couldn't simply
// be included, however, because it isn't compatible with the
// special objidl.h and wtypes.h used by IProp DLL.

#define SELFREG_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0200)
#define SELFREG_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x020F)
#define SELFREG_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0200)
#define SELFREG_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x020F)

#define SELFREG_E_TYPELIB           (SELFREG_E_FIRST+0)
#define SELFREG_E_CLASS             (SELFREG_E_FIRST+1)

//  -------
//  Globals
//  -------

// Important DLL names.
const LPTSTR tszNameDll  = TEXT( "IProp.dll" );

// Registry entry descriptions
const LPTSTR tszOle32PSFactoryClsid     = TEXT( "{00000320-0000-0000-C000-000000000046}" );
const LPTSTR tszNamePropertySetStorage  = TEXT( "IPropertySetStorage" );
const LPTSTR tszNamePropertyStorage     = TEXT( "IPropertyStorage" );
const LPTSTR tszNameIEnumSTATPROPSETSTG = TEXT( "IEnumSTATPROPSETSTG" );
const LPTSTR tszNameIEnumSTATPROPSTG    = TEXT( "IEnumSTATPROPSTG" );

// GUIDs in Registry format
const LPTSTR tszGuidPropertySetStorage  = TEXT( "{0000013A-0000-0000-C000-000000000046}" );
const LPTSTR tszGuidPropertyStorage     = TEXT( "{00000138-0000-0000-C000-000000000046}" );
const LPTSTR tszGuidIEnumSTATPROPSETSTG = TEXT( "{0000013B-0000-0000-C000-000000000046}" );
const LPTSTR tszGuidIEnumSTATPROPSTG    = TEXT( "{00000139-0000-0000-C000-000000000046}" );

//+----------------------------------------------------------------------------
//
//  Function:   UpdateKeyAndSubKey
//  
//  Synopsis:   This function either creates or deletes first
//              a key and un-named value under HKEY_CLASSES_ROOT,
//              then a sub-key and associated un-named value.  The
//              caller indicates whether a create or delete should occur.
//
//              However, the caller may specify that nothing be done
//              if the sub-key exists and already has a specific
//              un-named REG_SZ value.
//
//  Inputs:     [const LPTSTR] tszMainKey (in)
//                  The name of the key under HKEY_CLASSES_ROOT.
//              [const LPTSTR] tszMainKeyDescription (in)
//                  The un-named REG_SZ value under this key (not necessary
//                  if fDelete is true).
//              [const LPTSTR] tszSubKey (in)
//                  The name of the key under the first key.
//              [const LPTSTR] tszSubKeyDescription (in)
//                  The un-named REG_SZ value to write under this sub-key
//                  (not necessary if fDelete is true).
//              [const LPTSTR] tszSubKeyCheck (in)
//                  If non-NULL, and the subkey already exists, see if
//                  this string matches an un-named REG_SZ value in 
//                  the sub-key.  If so, abort the operation and return
//                  ERROR_ALREADY_EXISTS.
//              [BOOL] fDelete
//                  If TRUE, delete the keys, if FALSE, create them.
//                  But this is ignored if tszSubKeyCheck matches
//                  (in which case nothing happens).
//
//  Returns:    [long] A GetLastError value.
//
//+----------------------------------------------------------------------------

long
UpdateKeyAndSubKey( const LPTSTR tszMainKey,
                    const LPTSTR tszMainKeyDescription,
                    const LPTSTR tszSubKey,
                    const LPTSTR tszSubKeyDescription,
                    const LPTSTR tszSubKeyCheck,
                    BOOL  fDelete )
{
    //  ------
    //  Locals
    //  ------

    long lResult = ERROR_SUCCESS;
    DWORD dwDisposition;

    HKEY hkeyMain = NULL;   // E.g. "HKEY_CLASSES_ROOT\\CLSID\\{.....}"
    HKEY hkeySub = NULL;    // E.g. ..."InProcServer32"

    //  -------------
    //  Open the keys
    //  -------------

    // Are we opening for delete?

    if( fDelete )
    {
        // Yes - we're deleting.  We'll just attempt to do an Open.
        dwDisposition = REG_OPENED_EXISTING_KEY;

        lResult = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                tszMainKey,
                                0L,
                                KEY_ALL_ACCESS,
                                &hkeyMain );
        
        if( ERROR_SUCCESS == lResult )
        {
            lResult = RegOpenKeyEx( hkeyMain,
                                    tszSubKey,
                                    0L,
                                    KEY_ALL_ACCESS,
                                    &hkeySub );
        }

        if( ERROR_FILE_NOT_FOUND == lResult )
            lResult = ERROR_SUCCESS;
        else if( ERROR_SUCCESS != lResult )
            goto Exit;

    }   // if( fDelete )

    else
    {
        // We're not opening for delete.  So we'll use RegCreateKey,
        // which does an Open if the key exists, and a Create otherwise.

        lResult = RegCreateKeyEx( HKEY_CLASSES_ROOT,
                                  tszMainKey,
                                  0L,
                                  NULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hkeyMain,
                                  &dwDisposition );
        if( lResult != ERROR_SUCCESS ) goto Exit;

        // Open the sub-key.

        lResult = RegCreateKeyEx( hkeyMain,
                                  tszSubKey,
                                  0L,
                                  NULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hkeySub,
                                  &dwDisposition );
        if( ERROR_SUCCESS != lResult ) goto Exit;

    }   // if( fDelete ) ... else

    //  --------------------------
    //  Do we need to do anything?
    //  --------------------------

    // Does it look like we might not need to do anything?

    if( NULL != tszSubKeyCheck      // The caller said to check first
        &&
        NULL != hkeySub             // We Created or Opened a sub-key
        &&                          // Specifically, it was an Open.
        REG_OPENED_EXISTING_KEY	== dwDisposition )
    {
        // Yes - we need to see if the key already contains
        // tszSubKeyCheck.  If so, then we're done.

        DWORD dwType = 0;
        TCHAR tszData[ MAX_PATH ];
        DWORD dwDataSize = sizeof( tszData );

        // Is there an un-named value in this key?

        lResult = RegQueryValueEx( hkeySub,
                                   NULL,            // Name
                                   NULL,            // Reserved
                                   &dwType,         // E.g. REG_SZ
                                   (LPBYTE) tszData,// Return value
                                   &dwDataSize );   // In: size of buf. Out: size of value

        // We should have gotten a success-code or a not-extant code
        if( ERROR_SUCCESS != lResult
            &&
            ERROR_FILE_NOT_FOUND != lResult )
        {
            goto Exit;
        }

        // If we got an extant SZ value that matches tszSubKeyCheck,
        // then there's nothing we need do.

        if( ERROR_SUCCESS == lResult
            &&
            REG_SZ == dwType
            &&
            !_tcsicmp( tszData, tszSubKeyCheck )
          )
        {
            lResult = ERROR_ALREADY_EXISTS;
            goto Exit;
        }

    }   // if( REG_OPENED_EXISTING_KEY	== dwDisposition ...

    //  --------------------------
    //  Delete keys, or set values
    //  --------------------------

    if( fDelete )
    {
        // Reset the result code, since the code below may not set it.
        lResult = ERROR_SUCCESS;

        // We're doing a delete.  First, delete the sub-key, which
        // will delete any values.  If there was no subkey, hkeySub will
        // be NULL.

        if( NULL != hkeySub )
        {
            CloseHandle( hkeySub );
            hkeySub = NULL;

            lResult = RegDeleteKey( hkeyMain,
                                    tszSubKey );
            if( ERROR_SUCCESS != lResult ) goto Exit;
        }

        // Second, delete the main key

        if( NULL != hkeyMain )
        {
            CloseHandle( hkeyMain );
            hkeyMain = NULL;

            lResult = RegDeleteKey( HKEY_CLASSES_ROOT,
                                    tszMainKey );
            if( ERROR_SUCCESS != lResult ) goto Exit;
        }

    }	// if( fDelete )

    else
    {
        // We're adding to the Registry.  The two keys are now
        // created & opened, so we can add the REG_SZ values.

        // The REG_SZ value for the main key.
        lResult = RegSetValueEx(hkeyMain,
                                NULL,
                                0L,
                                REG_SZ,
                                (const BYTE *) tszMainKeyDescription,
                                sizeof(TCHAR) * (1 + _tcslen(tszMainKeyDescription) ));
        if( ERROR_SUCCESS != lResult ) goto Exit;

        // The REG_SZ value for the sub-key.
        lResult = RegSetValueEx(hkeySub,
                                NULL, 0L,
                                REG_SZ,
                                (const BYTE *) tszSubKeyDescription,
                                sizeof(TCHAR) * (1 + _tcslen(tszSubKeyDescription) ));
        if( ERROR_SUCCESS != lResult ) goto Exit;

    }	// if( fDelete ) ... else

    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hkeySub )
        CloseHandle( hkeySub );

    if( NULL != hkeyMain )
        CloseHandle( hkeyMain );

    return( lResult );

}   // WriteKeyAndSubKey()


//+----------------------------------------------------------------------------
//
//  Function:   RegisterForMarshaling
//
//  Synopsis:   This function takes the GUID ane name of an interface
//              for which MIDL-generated marshaling code exists in the
//              caller-specified DLL.  First we try to update the
//              CLSID entries, but we'll fail this if the entries already
//              exist and reference OLE32 (OLE32 has better marshaling
//              code).  If this doesn't fail, then we'll update the
//              Interface entries.
//
//              The caller specifies if this "update" of the registry
//              is a write or a delete.  This this routine can be used
//              in either a registration or a de-registration.
//
//  Inputs:     [const LPTSTR] tszGuid (in)
//                  The GUID in registery format ("{...-...-...}")
//              [const LPTSTR] tszName (in)
//                  The name of the interface
//              [const LPTSTR] tszDllPath (in)
//                  The complete path and filename of the DLL which contains
//                  the marshaling code.
//              [BOOL] fDelete (in)
//                  Determines if we add to the Registry or delete from it.
//
//  Returns:    [long] a GetLastError() value
//
//+----------------------------------------------------------------------------


long
RegisterForMarshaling( const LPTSTR tszGuid,
                       const LPTSTR tszName,
                       const LPTSTR tszDllPath,
                       BOOL fDelete )
{
    //  ------
    //  Locals
    //  ------

    long lResult;
    TCHAR tszMainKey[ MAX_PATH ];

    //  -----------------------------------
    //  Update HKEY_CLASSES_ROOT\Interfaces
    //  -----------------------------------

    // Calculate the key name name
    _tcscpy( tszMainKey, TEXT( "Interface\\" ));
    _tcscat( tszMainKey, tszGuid );

    // Update the registry, but only if there isn't a current
    // entry pointing to OLE32's proxy/stub factory.

    lResult = UpdateKeyAndSubKey( tszMainKey,
                                  tszName,
                                  TEXT( "ProxyStubClsid32" ),
                                  tszGuid,
                                  tszOle32PSFactoryClsid,
                                  fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;


    //  ------------------------------
    //  Update HKEY_CLASSES_ROOT\CLSID
    //  ------------------------------

    // Calculate the name.
    _tcscpy( tszMainKey, TEXT( "CLSID\\" ));
    _tcscat( tszMainKey, tszGuid );

    // Update the entries.  This will add the path (if !fDelete) or remove
    // the registry entry (if fDelete) regardless of the current state
    // of the key; if we weren't supposed to remove it, the previous
    // call to UpdateKeyAndSubKey would have returned an error.

    lResult = UpdateKeyAndSubKey( tszMainKey,
                                  tszName,
                                  TEXT( "InprocServer32" ),
                                  tszDllPath, 
                                  NULL, // Add/delete, regardless of what exists
                                  fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( ERROR_ALREADY_EXISTS == lResult )
    {
        propDbg(( DEB_WARN, "IProp DLL UpdateKeyAndSubKey:  Entry already exists\n" ));
        lResult = ERROR_SUCCESS;
    }

    return( lResult );

}   // RegisterForMarshaling()


//+----------------------------------------------------------------------------
//
//  Function:   RegisterServer
//  
//  Synopsis:   This routine can be used with both DllRegisterServer and
//              DllUnregisterServer.  It adds/deletes IPropertySetStorage
//              IPropertyStorage, IEnumSTATPROPSETSTG, and IEnumSTATPROPSTG.
//
//  Inputs:     [BOOL] fDelete (in)
//                  Indicates whether the registry entries should be added
//                  or removed.
//
//  Returns:    [HRESULT]
//
//+----------------------------------------------------------------------------


STDAPI RegisterServer( BOOL fDelete )
{
    //  ------
    //  Locals
    //  ------

    LONG  lResult;

    //  -----
    //  Begin
    //  -----

    // Register IPropertySetStorage
    lResult = RegisterForMarshaling( tszGuidPropertySetStorage,
                                     tszNamePropertySetStorage,
                                     tszNameDll,
                                     fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;

    // Register IPropertyStorage
    lResult = RegisterForMarshaling( tszGuidPropertyStorage,
                                     tszNamePropertyStorage,
                                     tszNameDll,
                                     fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;

    // Register IEnumSTATPROPSETSTG
    lResult = RegisterForMarshaling( tszGuidIEnumSTATPROPSETSTG,
                                     tszNameIEnumSTATPROPSETSTG,
                                     tszNameDll,
                                     fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;

    // Register IEnumSTATPROPSTG
    lResult = RegisterForMarshaling( tszGuidIEnumSTATPROPSTG,
                                     tszNameIEnumSTATPROPSTG,
                                     tszNameDll,
                                     fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;


    //  ----
    //  Exit
    //  ----

Exit:

    if( ERROR_SUCCESS != lResult )
    {
        propDbg(( DEB_ERROR, "IProp DLL RegisterServer failed (%lu)\n", lResult ));
        return( SELFREG_E_CLASS );
    }
    else
    {
        return( S_OK );
    }

}   // RegisterServer()



//+----------------------------------------------------------------------------
//
//  Function:   DllRegisterServer & DllUnregisterServer
//
//  Synopsis:   These routines are the standard DLL registration entry
//              points for a self-registering in-proc COM server.  They
//              are used to register the property set marshaling code.
//              These routines are called, for example,
//              by a setup program during installation and de-installation,
//              respectively.
//
//+----------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
    return( RegisterServer( FALSE ));
}

STDAPI DllUnregisterServer()
{
    return( RegisterServer( TRUE ));
}


void InitializeDebugging();
void UnInitializeDebugging();

BOOL WINAPI
DllMain( HANDLE hinst, DWORD dwReason, LPVOID lpv )
{
    #if DBG == 1
    {
        if( DLL_PROCESS_ATTACH == dwReason )
            InitializeDebugging();
        else if( DLL_PROCESS_DETACH == dwReason )
            UnInitializeDebugging();
    }
    #endif // #if DBG == 1

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\iprop\stubapi.cxx ===
#include <pch.cxx>

#include <funcs.hxx>
#include <dfentry.hxx>



DECLARE_INFOLEVEL(ol)
#define ntfsChk(a)      olChk(a)
#define ntfsErr(a,b)    olErr(a,b)
#define ntfsDebugOut(a) olDebugOut(a)
#define ntfsAssert(a)   olAssert(a)


//+---------------------------------------------------------------------------
//
//  Function:   DfOpenStorageEx
//
//  Synopsis:   Open storage and stream objects
//
//  Arguments:  [pwcsUsersName] - pathanme of the file
//              [fCreateAPI] - create or open
//              [grfMode] - open mode flags
//              [grfAttrs] -  reserved
//              [stgfmt] -  storage format
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//  Returns:    Appropriate status code
//
//  History:    12-Jul-95   HenryLee    Created
//
//----------------------------------------------------------------------------

STDAPI DfOpenStorageEx (
            const WCHAR* pwcsUsersName,
            BOOL     fCreateAPI,         // create vs open
            DWORD    grfMode,
            DWORD    stgfmt,             // enum
            DWORD    grfAttrs,           // reserved
            STGOPTIONS *pStgOptions,  
            void *   reserved,
            WCHAR *  pwcsNameSnapshot,
            REFIID   riid,
            void **  ppObjectOpen)
{
    HRESULT sc = S_OK;

    DWORD dwFullPathLen;
    WCHAR awcsFullName[_MAX_PATH], *pwcsFile;

    //
    // The ANY and STORAGE formats recursivly call back through here
    // for the correct real format (DOCFILE, NATIVE or FILE).  We only call
    // GetFullPathName on real formats, to avoid redundant calls as we
    // recurse.
    //  This then *requires* that the ANY and STORAGE must recurse (i.e. can't
    // call NFFOpen or NSS directly) because the filename has not been
    // properly prepared.
    //
    // For STGFMT_DOCFILE, let the docfile layer handle name checking
    //
    if(STGFMT_ANY != stgfmt &&
       STGFMT_STORAGE != stgfmt &&
       STGFMT_DOCFILE != stgfmt)
    {
        dwFullPathLen = GetFullPathNameW(pwcsUsersName, _MAX_PATH,
                                         awcsFullName,&pwcsFile);

        if (dwFullPathLen == 0)
        {
            DWORD dwErr = GetLastError();

            // In some circumstances (name == " ", for instance),
            // GetFullPathNameW can return 0 and GetLastError returns 0.
            // We want to return STG_E_INVALIDNAME for these.
            if (dwErr != NOERROR)
            {
                ntfsErr(EH_Err, Win32ErrorToScode(dwErr));
            }
            else
            {
                ntfsErr(EH_Err, STG_E_INVALIDNAME);
            }
        }
        else if (dwFullPathLen > _MAX_PATH)
            ntfsErr(EH_Err, STG_E_PATHNOTFOUND);
    }

    //-----------------------------------------
    //  Switch on STGFMT_
    //      STORAGE, NATIVE, DOCFILE, FILE, ANY
    //
    switch(stgfmt)
    {

    case STGFMT_FILE:
      {
        ntfsChk( NFFOpen( awcsFullName, grfMode, NFFOPEN_NORMAL,
                          fCreateAPI, riid, ppObjectOpen) );

      }	// case STGFMT_FILE
    break;

    case STGFMT_ANY:
      {
        DWORD stgfmt=STGFMT_STORAGE;
        //
        // Attempting to CREATE a Storage with STGFMT_ANY is ambiguous,
        // On NTFS either STGFMT_NATIVE or STGFMT_FILE could be appropriate,
        // and is therefore invalid.
        //
        if (fCreateAPI)
            ntfsChk (STG_E_INVALIDPARAMETER);

        //
        //   If the file is a storage then try STGFMT_STORAGE.
        // Otherwise try STGFMT_FILE.  
        //   If StgIsStorageFile() error'ed go ahead into the STGFMT_STORAGE
        // for consistant error return values.
        //
        if( S_OK == CNtfsStorage::IsNffAppropriate( pwcsUsersName ) )
            stgfmt = STGFMT_FILE;

        sc = DfOpenStorageEx (pwcsUsersName, fCreateAPI, grfMode, stgfmt,
                                grfAttrs, pStgOptions, reserved,
                                pwcsNameSnapshot, riid, ppObjectOpen);

        ntfsChk(sc);

      }	// case STGFMT_ANY;
    break;


    default:
        ntfsErr (EH_Err, STG_E_INVALIDPARAMETER);
        break;
    }

EH_Err:
    return sc;

};

//+---------------------------------------------------------------------------
//
//  Function:	StgCreateStorageEx, public
//
//  Synopsis:	Creates a storage or stream object
//
//  Arguments:	[pwcsName] - pathname of file
//              [grfMode] - open mode flags
//              [stgfmt] -  storage format
//              [grfAttrs] -  reserved
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//
//  Returns:	Appropriate status code
//
//  History:	12-Jul-95	HenryLee   Created
//
//----------------------------------------------------------------------------

typedef HRESULT (*PFNStgCreateStorageEx)( const WCHAR* pwcsName, DWORD grfMode, DWORD stgfmt,
                                          DWORD grfAttrs, void *pSecurity, void *pTransaction,
                                          REFIID riid, void **ppObjectOpen );

typedef HRESULT (*PFNStgOpenStorageEx)( const WCHAR *pwcsName, DWORD grfMode, DWORD stgfmt,
                                        DWORD grfAttrs, void *pSecurity, void *pTransaction,
                                        REFIID riid, void **ppObjectOpen );

HINSTANCE HInstOle32()
{
    static HINSTANCE hinstOLE32 = NULL;

    if( NULL == hinstOLE32 )
        hinstOLE32 = LoadLibrary( TEXT("ole32.dll") );

    return( hinstOLE32 );
}


WINOLEAPI StgCreateStorageEx (IN const WCHAR* pwcsName,
            IN  DWORD grfMode,
            IN  DWORD stgfmt,              // enum
            IN  DWORD grfAttrs,             // reserved
            IN  STGOPTIONS * pStgOptions,
            IN  void * reserved,
            IN  REFIID riid,
            OUT void ** ppObjectOpen)
{
    HRESULT sc = S_OK;
    WCHAR awcsTmpPath[_MAX_PATH];

    ntfsChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (grfAttrs != 0)
        ntfsErr(EH_Err, STG_E_INVALIDFLAG);

    if ((grfMode & STGM_RDWR) == STGM_READ ||
        (grfMode & (STGM_DELETEONRELEASE | STGM_CONVERT)) ==
        (STGM_DELETEONRELEASE | STGM_CONVERT))
        ntfsErr(EH_Err, STG_E_INVALIDFLAG);

    if( STGFMT_FILE == stgfmt
        &&
        (IID_IPropertySetStorage == riid || IID_IStorage == riid || IID_IPropertyBagEx == riid)
      )
    {
        ntfsChk (DfOpenStorageEx (pwcsName, TRUE, grfMode, stgfmt, grfAttrs,
                     pStgOptions, reserved, NULL, riid, ppObjectOpen));
    }
    else
    {
        static PFNStgCreateStorageEx pfnStgCreateStorageEx = NULL;

        if( NULL == pfnStgCreateStorageEx )
            pfnStgCreateStorageEx = (PFNStgCreateStorageEx) GetProcAddress( HInstOle32(), "StgCreateStorageEx" );

        if( NULL == pfnStgCreateStorageEx )
            ntfsChk( E_FAIL );

        ntfsChk( pfnStgCreateStorageEx( pwcsName, grfMode, stgfmt, grfAttrs, pStgOptions, reserved, riid, ppObjectOpen ));
    }

    ntfsDebugOut((DEB_TRACE, "Out StgCreateStorageEx => %p\n", *ppObjectOpen));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:	StgOpenStorageEx
//
//  Synopsis:	Open storage and stream objects
//
//  Arguments:	[pwcsName] - pathanme of the file
//              [grfMode] - open mode flags
//              [grfAttrs] -  reserved
//              [stgfmt] -  storage format
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//  Returns:	Appropriate status code
//
//  History:	12-Jul-95	HenryLee    Created
//
//----------------------------------------------------------------------------

WINOLEAPI StgOpenStorageEx (IN const WCHAR* pwcsName,
            IN  DWORD grfMode,
            IN  DWORD stgfmt,              // enum
            IN  DWORD grfAttrs,             // reserved
            IN  STGOPTIONS * pStgOptions,
            IN  void * reserved,
            IN  REFIID riid,
            OUT void ** ppObjectOpen)
{
    HRESULT sc = S_OK;
    WCHAR awcsTmpPath[_MAX_PATH];
    WCHAR * pwcsNameSnapshot = NULL;

    ntfsDebugOut((DEB_TRACE, "In  StgOpenStorageEx(%ws, %p, %p, %p, %p)\n",
                pwcsName, grfMode, stgfmt, riid, ppObjectOpen));

    ntfsChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (pStgOptions!= NULL || reserved != NULL)
        ntfsErr (EH_Err, STG_E_INVALIDPARAMETER);

    if (grfAttrs != 0)
        ntfsErr(EH_Err, STG_E_INVALIDFLAG);
    
    ntfsChk (ValidateNameW (pwcsName, _MAX_PATH));


    if( (IID_IPropertySetStorage == riid || IID_IStorage == riid || IID_IPropertyBagEx == riid)
        &&
        ( STGFMT_FILE == stgfmt
          ||
          STGFMT_ANY == stgfmt && S_OK != StgIsStorageFile(pwcsName)
        )
      )
    {
        ntfsChk (DfOpenStorageEx (pwcsName, FALSE, grfMode, stgfmt, grfAttrs,
                 pStgOptions, reserved, pwcsNameSnapshot, riid, ppObjectOpen));
    }
    else
    {
        static PFNStgOpenStorageEx pfnStgOpenStorageEx = NULL;

        if( NULL == pfnStgOpenStorageEx )
            pfnStgOpenStorageEx = (PFNStgOpenStorageEx) GetProcAddress( HInstOle32(), "StgOpenStorageEx" );
        if( NULL == pfnStgOpenStorageEx )
            ntfsChk( E_FAIL );

        ntfsChk( pfnStgOpenStorageEx( pwcsName, grfMode, stgfmt, grfAttrs, pStgOptions, reserved,
                                      riid, ppObjectOpen ));
    }

    ntfsDebugOut((DEB_TRACE, "Out StgOpenStorageEx => %p\n", *ppObjectOpen));
EH_Err:

    return sc;
}


// Copied from stg\docfile\funcs.cxx
#ifdef WIN32
SCODE Win32ErrorToScode(DWORD dwErr)
{
    olAssert((dwErr != NO_ERROR) &&
	     aMsg("Win32ErrorToScode called on NO_ERROR"));

    SCODE sc = STG_E_UNKNOWN;

    switch (dwErr)
    {
    case ERROR_INVALID_FUNCTION:
	sc = STG_E_INVALIDFUNCTION;
	break;
    case ERROR_FILE_NOT_FOUND:
	sc = STG_E_FILENOTFOUND;
	break;
    case ERROR_PATH_NOT_FOUND:
	sc = STG_E_PATHNOTFOUND;
	break;
    case ERROR_TOO_MANY_OPEN_FILES:
	sc = STG_E_TOOMANYOPENFILES;
	break;
    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
	sc = STG_E_ACCESSDENIED;
	break;
    case ERROR_INVALID_HANDLE:
	sc = STG_E_INVALIDHANDLE;
	break;
    case ERROR_NOT_ENOUGH_MEMORY:
	sc = STG_E_INSUFFICIENTMEMORY;
	break;
    case ERROR_NO_MORE_FILES:
	sc = STG_E_NOMOREFILES;
	break;
    case ERROR_WRITE_PROTECT:
	sc = STG_E_DISKISWRITEPROTECTED;
	break;
    case ERROR_SEEK:
	sc = STG_E_SEEKERROR;
	break;
    case ERROR_WRITE_FAULT:
	sc = STG_E_WRITEFAULT;
	break;
    case ERROR_READ_FAULT:
	sc = STG_E_READFAULT;
	break;
    case ERROR_SHARING_VIOLATION:
	sc = STG_E_SHAREVIOLATION;
	break;
    case ERROR_LOCK_VIOLATION:
	sc = STG_E_LOCKVIOLATION;
	break;
    case ERROR_HANDLE_DISK_FULL:
    case ERROR_DISK_FULL:
	sc = STG_E_MEDIUMFULL;
	break;
    case ERROR_FILE_EXISTS:
    case ERROR_ALREADY_EXISTS:
	sc = STG_E_FILEALREADYEXISTS;
	break;
    case ERROR_INVALID_PARAMETER:
	sc = STG_E_INVALIDPARAMETER;
	break;
    case ERROR_INVALID_NAME:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILENAME_EXCED_RANGE:
	sc = STG_E_INVALIDNAME;
	break;
    case ERROR_INVALID_FLAGS:
	sc = STG_E_INVALIDFLAG;
	break;
    default:
	sc = WIN32_SCODE(dwErr);
	break;
    }

    return sc;
}
#endif


//+--------------------------------------------------------------
//
//  Function:   ValidateSNB, private
//
//  Synopsis:   Validates SNB memory
//
//  Arguments:  [snb] - SNB
//
//  Returns:    Appropriate status code
//
//  History:    10-Jun-92       DrewB   Created
//
//---------------------------------------------------------------

#include <docfilep.hxx>

// ***** From stg\docfile\funcs.cxx
SCODE ValidateSNB(SNBW snb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  ValidateSNB(%p)\n", snb));
    for (;;)
    {
	olChk(ValidatePtrBuffer(snb));
	if (*snb == NULL)
	    break;
	olChk(ValidateNameW(*snb, CWCMAXPATHCOMPLEN));
	snb++;
    }
    olDebugOut((DEB_ITRACE, "Out ValidateSNB\n"));
    return S_OK;
EH_Err:
    return sc;
}



//+--------------------------------------------------------------
//
//  Function:   CheckName, public
//
//  Synopsis:   Checks name for illegal characters and length
//
//  Arguments:  [pwcsName] - Name
//
//  Returns:    Appropriate status code
//
//  History:    11-Feb-92       DrewB   Created
//                              04-Dec-95               SusiA   Optimized
//
//---------------------------------------------------------------

// ***** From stg\docfile\funcs.cxx
#ifdef OLEWIDECHAR
SCODE CheckName(WCHAR const *pwcsName)
{
    LPCWSTR pChar;
    
    //Each character's position in the array is detrmined by its ascii numeric
    //value.  ":" is 58, so bit 58 of the array will be 1 if ":" is illegal.
    //32bits per position in the array, so 58/32 is in Invalid[1].
    //58%32 = 28th bit ( 0x04000000 ) in Invalid[1].

    /* Invalid characters:                               :  /  !   \ */
    static ULONG const Invalid[128/32] =
    {0x00000000,0x04008002,0x10000000,0x00000000};

    SCODE sc = STG_E_INVALIDNAME;
    olDebugOut((DEB_ITRACE, "In  CheckName(%ws)\n", pwcsName));

    __try
    {
        for (pChar = (LPCWSTR)pwcsName;
             pChar <= (LPCWSTR) &pwcsName[CWCMAXPATHCOMPLEN];
             pChar++)
        {
            if (*pChar == L'\0')
            {
                sc = S_OK;
                break;                  // Success
            }

            // Test to see if this is an invalid character
            if (*pChar < 128 &&
                // All values above 128 are valid
                (Invalid[*pChar / 32] & (1 << (*pChar % 32))) != 0)
                // check to see if this character's bit is set
            {
                break;                  // Failure: invalid Char
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

    olDebugOut((DEB_ITRACE, "Out CheckName\n"));
    return sc;
    
}
#endif



/*
// Forwarders to the nt5props.dll version of the property APIs.

EXTERN_C HRESULT
PrivPropVariantCopy ( PROPVARIANT * pvarDest, const PROPVARIANT * pvarSrc )
{
    return( PropVariantCopy( pvarDest, pvarSrc ));
}

EXTERN_C HRESULT
PrivPropVariantClear ( PROPVARIANT * pvar )
{
    return( PropVariantClear( pvar ));
}

EXTERN_C HRESULT
PrivFreePropVariantArray ( ULONG cVariants, PROPVARIANT * rgvars )
{
    return( FreePropVariantArray( cVariants, rgvars ));
}


EXTERN_C ULONG
PrivStgPropertyLengthAsVariant( IN SERIALIZEDPROPERTYVALUE const *pprop,
                               IN ULONG cbprop, IN USHORT CodePage,
                               IN BYTE flags )
{
    return( StgPropertyLengthAsVariant( pprop, cbprop, CodePage, flags ));
}


EXTERN_C SERIALIZEDPROPERTYVALUE *
PrivStgConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVectorOrArray,  // Used for recursive calls
    OPTIONAL OUT ULONG *pcIndirect)
{
    return( StgConvertVariantToProperty( pvar, CodePage, pprop, pcb, pid, fVariantVectorOrArray, pcIndirect ));
}

*/
//+--------------------------------------------------------------
//
//  Function:   VerifyPerms, private
//
//  Synopsis:   Checks flags to see if they are valid
//
//  Arguments:  [grfMode] - Permissions
//              [fRoot] - TRUE if checking root storage
//
//  Returns:    Appropriate status code
//
//  Notes:      This routine is called when opening a root storage
//              or a subelement.  When changing root permissions,
//              use the fRoot flag to preserve compatibily for
//              return codes when opening subelements
//
//  History:    19-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE VerifyPerms(DWORD grfMode, BOOL fRoot)
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  VerifyPerms(%lX)\n", grfMode));

    // Check for valid flags
    if ((grfMode & STGM_RDWR) > STGM_READWRITE ||
	(grfMode & STGM_DENY) > STGM_SHARE_DENY_NONE ||
	(grfMode & ~(STGM_RDWR | STGM_DENY | STGM_DIRECT | STGM_TRANSACTED |
		     STGM_PRIORITY | STGM_CREATE | STGM_CONVERT |
		     STGM_NOSCRATCH |
#ifndef DISABLE_NOSNAPSHOT
		     STGM_NOSNAPSHOT |
#endif
#if WIN32 >= 300
		     STGM_EDIT_ACCESS_RIGHTS |
#endif
		     STGM_FAILIFTHERE | STGM_DELETEONRELEASE)))
	olErr(EH_Err, STG_E_INVALIDFLAG);

    // If priority is specified...
    if (grfMode & STGM_PRIORITY)
    {
	// Make sure no priority-denied permissions are specified
	if ((grfMode & STGM_RDWR) == STGM_WRITE ||
	    (grfMode & STGM_RDWR) == STGM_READWRITE ||
	    (grfMode & STGM_TRANSACTED))
	    olErr(EH_Err, STG_E_INVALIDFLAG);
    }

    // Check to make sure only one existence flag is specified
    // FAILIFTHERE is zero so it can't be checked
    if ((grfMode & (STGM_CREATE | STGM_CONVERT)) ==
	(STGM_CREATE | STGM_CONVERT))
	olErr(EH_Err, STG_E_INVALIDFLAG);

    // If not transacted and not priority, you can either be
    // read-only deny write or read-write deny all
    if ((grfMode & (STGM_TRANSACTED | STGM_PRIORITY)) == 0)
    {
	if ((grfMode & STGM_RDWR) == STGM_READ)
	{
	    //  we're asking for read-only access

	    if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
#ifdef DIRECTWRITERLOCK
		    (!fRoot || (grfMode & STGM_DENY) != STGM_SHARE_DENY_NONE) &&
#endif
		(grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE)
	    {
		//  Can't allow others to have write access
		olErr(EH_Err, STG_E_INVALIDFLAG);
	    }
	}
	else
	{
	    //  we're asking for write access

#ifdef DIRECTWRITERLOCK
	    if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
            (!fRoot || (grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE))
#else
	    if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
#endif
	    {
		//  Can't allow others to have any access
		olErr(EH_Err, STG_E_INVALIDFLAG);
	    }
	}
    }

    //If this is not a root open, we can't pass STGM_NOSCRATCH or
    // STGM_NOSNAPSHOT
    if (!fRoot && (grfMode & (STGM_NOSCRATCH | STGM_NOSNAPSHOT)))
    {
        olErr(EH_Err, STG_E_INVALIDFLAG);
    }
    
    if (grfMode & STGM_NOSCRATCH)
    {
	if (((grfMode & STGM_RDWR) == STGM_READ) ||
	    ((grfMode & STGM_TRANSACTED) == 0))
	{
	    olErr(EH_Err, STG_E_INVALIDFLAG);
	}
    }

    if (grfMode & STGM_NOSNAPSHOT)
    {
	if (((grfMode & STGM_DENY) == STGM_SHARE_EXCLUSIVE) ||
	    ((grfMode & STGM_DENY) == STGM_SHARE_DENY_WRITE) ||
	    ((grfMode & STGM_TRANSACTED) == 0) ||
	    ((grfMode & STGM_NOSCRATCH) != 0) ||
	    ((grfMode & STGM_CREATE) != 0) ||
	    ((grfMode & STGM_CONVERT) != 0))
	{
	    olErr(EH_Err, STG_E_INVALIDFLAG);
	}
    }

    olDebugOut((DEB_ITRACE, "Out VerifyPerms\n"));
    // Fall through
EH_Err:
    return sc;
}



//+--------------------------------------------------------------
//
//  Function:   StgIsStorageFileHandle, private
//
//  Synopsis:   Determines whether a handle is open on a storage file.
//              Spun off from StgIsStorageFile.  Internaly we use this
//
//  Arguments:  [hf] - Open File Handle (caller must seek it to 0)
//
//  Returns:    S_OK, S_FALSE or error codes
//
//  History:    07-May-98   MikeHill   Created
//              05-June-98  BChapman   Return Errors not just S_FALSE.
//                                     Add optional Overlapped pointer.
//
//---------------------------------------------------------------


STDAPI StgIsStorageFileHandle( HANDLE hf, LPOVERLAPPED povlp )
{
    DWORD cbRead;
    BYTE stgHeader[sizeof(SStorageFile)];   
    SCODE sc;
    LONG status;
    OVERLAPPED ovlp;
    
    FillMemory( stgHeader, sizeof(SStorageFile), 0xDE );

    if (povlp == NULL)
    {
	ovlp.Offset = 0;
	ovlp.OffsetHigh = 0;
	ovlp.hEvent = NULL;
    }

    if( !ReadFile( hf,
		   &stgHeader,
		   sizeof( stgHeader ),
		   &cbRead,
		   (povlp == NULL) ? &ovlp : povlp ) )
    {
        if( NULL != povlp )
        {
            status = GetLastError();
            if( ERROR_IO_PENDING == status)
            {
                status = ERROR_SUCCESS;
                if( !GetOverlappedResult( hf, povlp, &cbRead, TRUE ) )
                    status = GetLastError();
            }
            if(ERROR_SUCCESS != status && ERROR_HANDLE_EOF != status)
                olChk( HRESULT_FROM_WIN32( status ) );
        }
        else
            olErr( EH_Err, LAST_STG_SCODE );
    }

    // Don't worry about short reads.  If the read is short then
    // the signature checks will fail.
    
    sc = CheckSignature( ((SStorageFile*)stgHeader)->abSig );
    if(S_OK == sc)
        goto EH_Err;    // Done, return "Yes"

    olChk(sc);

    // It didn't error.  sc != S_OK then it
    // Must be S_FALSE.
    olAssert(S_FALSE == sc);

EH_Err:
    if( (STG_E_OLDFORMAT == sc) || (STG_E_INVALIDHEADER == sc) )
        sc = S_FALSE;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckSignature, private
//
//  Synopsis:   Checks the given memory against known signatures
//
//  Arguments:  [pb] - Pointer to memory to check
//
//  Returns:    S_OK - Current signature
//              S_FALSE - Beta 2 signature, but still successful
//              Appropriate status code
//
//  History:    23-Jul-93       DrewB   Created from header.cxx code
//
//----------------------------------------------------------------------------

//Identifier for first bytes of Beta 1 Docfiles
const BYTE SIGSTG_B1[] = {0xd0, 0xcf, 0x11, 0xe0, 0x0e, 0x11, 0xfc, 0x0d};
const USHORT CBSIGSTG_B1 = sizeof(SIGSTG_B1);

//Identifier for first bytes of Beta 2 Docfiles
const BYTE SIGSTG_B2[] = {0x0e, 0x11, 0xfc, 0x0d, 0xd0, 0xcf, 0x11, 0xe0};
const BYTE CBSIGSTG_B2 = sizeof(SIGSTG_B2);

SCODE CheckSignature(BYTE *pb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CheckSignature(%p)\n", pb));

    // Check for ship Docfile signature first
    if (memcmp(pb, SIGSTG, CBSIGSTG) == 0)
        sc = S_OK;

    // Check for Beta 2 Docfile signature
    else if (memcmp(pb, SIGSTG_B2, CBSIGSTG_B2) == 0)
        sc = S_FALSE;

    // Check for Beta 1 Docfile signature
    else if (memcmp(pb, SIGSTG_B1, CBSIGSTG_B1) == 0)
        sc = STG_E_OLDFORMAT;

    else
        sc = STG_E_INVALIDHEADER;

    olDebugOut((DEB_ITRACE, "Out CheckSignature => %lX\n", sc));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   dfwcsnicmp, public
//
//  Synopsis:   wide character string compare that interoperates with what
//              we did on 16-bit windows.
//
//  Arguments:  [wcsa] -- First string
//              [wcsb] -- Second string
//              [len] -- Length to compare to
//
//  Returns:    > 0 if wcsa > wcsb
//              < 0 if wcsa < wcsb
//              0 is wcsa == wcsb
//
//  History:    11-May-95       PhilipLa        Created
//                              22-Nov-95       SusiA           Optimize comparisons
//
//  Notes:      This function is necessary because on 16-bit windows our
//              wcsnicmp function converted everything to uppercase and
//              compared the strings, whereas the 32-bit runtimes convert
//              everything to lowercase and compare.  This means that the
//              sort order is different for string containing [\]^_`
//
//----------------------------------------------------------------------------

int dfwcsnicmp(const WCHAR *wcsa, const WCHAR *wcsb, size_t len)
{
    if (!len)
        return 0;

    while (--len && *wcsa &&
                   ( *wcsa == *wcsb ||
                     CharUpperW((LPWSTR)*wcsa) == CharUpperW((LPWSTR)*wcsb)))
    {
        wcsa++;
        wcsb++;
    }
    return (int)(LONG_PTR)CharUpperW((LPWSTR)*wcsa) -
           (int)(LONG_PTR)CharUpperW((LPWSTR)*wcsb);
}

//+---------------------------------------------------------------------------
//
//  Member:     ValidateNameW, public
//
//  Synopsis:   Validate that a name is valid and no longer than the
//              size specified.
//
//  Arguments:  [pwcsName] -- Pointer to wide character string
//              [cchMax] -- Maximum length for string
//
//  Returns:    Appropriate status code
//
//  History:    23-Nov-98       PhilipLa        Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE ValidateNameW(LPCWSTR pwcsName, UINT cchMax)
{
    SCODE sc = S_OK;

#if WIN32 == 200
    if (IsBadReadPtrW(pwcsName, sizeof(WCHAR)))
        sc = STG_E_INVALIDNAME;
#else
    if (IsBadStringPtrW(pwcsName, cchMax))
        sc = STG_E_INVALIDNAME;
#endif
    else
    {
        __try
        {
                if ((UINT)lstrlenW(pwcsName) >= cchMax)
                    sc = STG_E_INVALIDNAME;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            sc = STG_E_INVALIDNAME;
        }
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\nffdrt\args.cxx ===
#include "pch.hxx"

#include "tbtest.hxx"

DWORD g_NoOpenStg  = FALSE;
DWORD g_CreateStg  = FALSE;
DWORD g_AnyStorage = FALSE;
DWORD g_ReleaseStg = FALSE;
DWORD g_AddRefStg  = FALSE;

DWORD g_NoOpenStm  = FALSE;
DWORD g_CreateStm  = FALSE;
DWORD g_ReadStm    = FALSE;
DWORD g_WriteStm   = FALSE;
DWORD g_AddRefStm  = FALSE;

DWORD g_SetClass   = FALSE;
DWORD g_Stat       = FALSE;

DWORD g_OplockFile = FALSE;
DWORD g_UseUpdater = FALSE;
DWORD g_Pause      = FALSE;
DWORD g_SuppressTime = FALSE;
DWORD g_CheckTime  = FALSE;
DWORD g_CheckIsStg = FALSE;
WCHAR g_tszFileName[ MAX_PATH ] = { L"001.bmp" };

void
StrLower( char *sz)
{
    while('\0' != *sz)
    {
        if(*sz >= 'A' && *sz <= 'Z')
            *sz += ('a' - 'A');
        sz++;
    }
}

void
Usage(WCHAR *wszApp)
{
    wprintf(L"%s options:\n", wszApp);

    printf("  -noopenstg\tDon't Open the file with IStorage.\n");
    printf("\t\tpstg->operations are not allowed.\n");

    printf("  -createstg\tOpen IStorage file for CreateStg(CREATE).\n");
    printf("\t\t\tOtherwise open with OpenStg()\n");
    printf("  -any\t\tOpen with STGFMT_ANY.  Otherwise use STGFMT_FILE\n");
    printf("  -releasestg\t\tRelease Storage before stream R/W\n");
    printf("  -addrefstg\t\tExtra Addref and release after creation\n");

    printf("\n");

    printf("  -noopenstm\tDon't open a stream.");
    printf("  pstm->operations not allowed\n");
    printf("  -createstm\tOpen w/ CreateStm(CREATE).  (otherwise OpenStm())\n");
    printf("  -readstm\tRead from the stream.  Mode is R/W\n");
    printf("  -writestm\tWrite to the stream.  Mode is R/W\n");
    printf("  -addrefstm\t\tExtra Addref and release after creation\n");

    printf("\n");

    printf("  -setclass\tCall pstg->SetClass()\n");
    printf("  -stat\t\tCall pstg->Stat()\n");
    
    printf("\n");

    printf("  -oplock\tOpen IStorage for Oplocking\n");
    printf("  -useupdater\tStart Updater and call IFilterStatus::PreFilter()\n");
    printf("  -pause\tPause before IO operations\n");
    printf("  -suppresstime\tCall ITimeAndNotifyControl->SuppressChanges\n");
    printf("  -checktime\tGet and print the FileTime before and after test\n");
    printf("  -checkisstg\tCall StgIsStorageFile before tring to Open Storage\n");
}

void
ParseArgs(
        int cArgs,
        WCHAR **pwszArgs)
{
    WCHAR *wszApp = *pwszArgs;

    ++pwszArgs;
    while( (--cArgs > 0) && ( ('-' == **pwszArgs) || ('/' == **pwszArgs) ) )
    {
        WCHAR *wszArg = *pwszArgs;
        
        ++wszArg;            // Advance over the '-'

        _wcslwr(wszArg);

        if(0 == wcscmp(L"noopenstg", wszArg))
            g_NoOpenStg = TRUE;

        else if(0 == wcscmp(L"createstg", wszArg))
            g_CreateStg = TRUE;

        else if(0 == wcscmp(L"any", wszArg))
            g_AnyStorage = TRUE;

        else if(0 == wcscmp(L"releasestg", wszArg))
            g_ReleaseStg = TRUE;

        else if(0 == wcscmp(L"addrefstg", wszArg))
            g_AddRefStg = TRUE;

        else if(0 == wcscmp(L"noopenstream", wszArg))
            g_NoOpenStm = TRUE;

        else if(0 == wcscmp(L"createstm", wszArg))
            g_CreateStm = TRUE;

        else if(0 == wcscmp(L"readstm", wszArg))
            g_ReadStm = TRUE;

        else if(0 == wcscmp(L"writestm", wszArg))
            g_WriteStm = TRUE;

        else if(0 == wcscmp(L"addrefstm", wszArg))
            g_AddRefStm = TRUE;

        else if(0 == wcscmp(L"setclass", wszArg))
            g_SetClass = TRUE;

        else if(0 == wcscmp(L"stat", wszArg))
            g_Stat = TRUE;

        else if(0 == wcscmp(L"oplock", wszArg))
            g_OplockFile = TRUE;

        else if(0 == wcscmp(L"useupdater", wszArg))
            g_UseUpdater = TRUE;

        else if(0 == wcscmp(L"pause", wszArg))
            g_Pause = TRUE;

        else if(0 == wcscmp(L"suppresstime", wszArg))
            g_SuppressTime = TRUE;

        else if(0 == wcscmp(L"checktime", wszArg))
            g_CheckTime = TRUE;

        else if(0 == wcscmp(L"checkisstg", wszArg))
            g_CheckIsStg = TRUE;

        else
        {
            printf("unknown argument '%s'\n", *pwszArgs);
            Usage(wszApp);
            exit(0);
        }
        ++pwszArgs;
    }

    if(0 < cArgs)
    {
        wcscpy( g_tszFileName, *pwszArgs );
        ++pwszArgs;
        --cArgs;
    }

    if(0 < cArgs)
    {
        printf("extra arguments ignored: ");
        while(--cArgs >= 0)
        {
            wprintf( L" %s", *pwszArgs);
            ++pwszArgs;
        }
        Usage(wszApp);
        printf("\n");
        exit(0);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utils.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       utils.cxx
//
//  Contents:   Utility classes/functions for property implementation.
//
//  Classes:    CPropSetName -- wraps buffer and conversion of fmtids
//              CStackBuffer -- utility class that allows a small number
//                              of items be on stack, but more be on heap.
//
//  Functions:  PropVariantClear
//              FreePropVariantArray
//              AllocAndCopy
//              PropVariantCopy
//
//  History:    1-Mar-95   BillMo      Created.
//             22-Feb-96   MikeHill    Removed an over-active assert.
//             22-May-96   MikeHill    Handle "unmappable character" in
//                                     NtStatusToScode.
//             12-Jun-96   MikeHill    - Added PropSysAllocString and PropSysFreeString.
//                                     - Added VT_I1 support (under ifdef)
//                                     - Fix PropVarCopy where the input VT_CF
//                                       has a zero size but a non-NULL pClipData.
//             29-Jul-96   MikeHill    - PropSet names:  WCHAR => OLECHAR
//                                     - Bug in PropVarCopy of 0-length VT_BLOB
//                                     - Support VT_BSTR_BLOB types (used in IProp.dll)
//             10-Mar-98   MikeHIll    Support Variant types in PropVariantCopy/Clear
//             06-May-98   MikeHill    - Use CoTaskMem rather than new/delete.
//                                     - Removed unused PropSysAlloc/FreeString.
//                                     - Support VT_VECTOR|VT_I1.
//                                     - Removed UnicodeCallouts support.
//                                     - Use oleaut32.dll wrappers, don't call directly.
//     5/18/98  MikeHill
//              -   Moved IsOriginalPropVariantType from utils.hxx.
//              -   Added IsVariantType.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#include <privoa.h>     // Private OleAut32 wrappers

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

//+-------------------------------------------------------------------
//
//  Member:     CPropSetName::CPropSetName
//
//  Synopsis:   Initialize internal buffer with converted FMTID
//
//  Arguments:  [rfmtid] -- FMTID to convert
//
//--------------------------------------------------------------------

CPropSetName::CPropSetName(REFFMTID rfmtid)
{
    PrGuidToPropertySetName(&rfmtid, _oszName);
}

//+-------------------------------------------------------------------
//
//  Member:     CStackBuffer::Init
//
//  Synopsis:   Determine whether the class derived from this one
//              needs to have additional buffer allocated on the
//              heap and allocate it if neccessary.  Otherwise, if
//              there is space, use the internal buffer in the
//              derived class.
//
//  Arguments:  [cElements] -- the number of elements required.
//
//  Returns:    S_OK if buffer available
//              STG_E_INSUFFICIENTMEMORY if stack buffer was not
//                  big enough AND heap allocation failed.
//
//  Notes:      To be called directly by client after the derived
//              classes constructor initialized CStackBuffer.
//
//--------------------------------------------------------------------

HRESULT CStackBuffer::Init(ULONG cElements)
{
    if (cElements > _cElements)
    {
        _pbHeapBuf = reinterpret_cast<BYTE*>( CoTaskMemAlloc( cElements * _cbElement ));
        if (_pbHeapBuf == NULL)
        {
            return(STG_E_INSUFFICIENTMEMORY);
        }
        _cElements = cElements;
    }

    memset( _pbHeapBuf, 0, _cElements * _cbElement );

    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   PropVariantClear
//
//  Synopsis:   Deallocates the members of the PROPVARIANT that require
//              deallocation.
//
//  Arguments:  [pvarg] - variant to clear
//
//  Returns:    S_OK if successful,
//              STG_E_INVALIDPARAMETER if any part of the variant has
//                  an unknown vt type.  (In this case, ALL the elements
//                  that can be freed, will be freed.)
//
//  Modifies:   [pvarg] - the variant is left with vt = VT_EMPTY
//
//--------------------------------------------------------------------------

STDAPI PropVariantClear(PROPVARIANT *pvarg)
{

    ULONG l;
    HRESULT hr = S_OK;

    // Is there really anything to clear?
    if (pvarg == NULL)
        return(hr);

    // Validate the input
    VDATEPTROUT( pvarg, PROPVARIANT );

    switch (pvarg->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:

    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
        break;

    case VT_BSTR:
        if (pvarg->bstrVal != NULL)
            PrivSysFreeString( pvarg->bstrVal );
        break;

    case VT_BSTR_BLOB:
        if (pvarg->bstrblobVal.pData != NULL)
            CoTaskMemFree( pvarg->bstrblobVal.pData );
        break;
    case VT_BOOL:
    case VT_ERROR:
    case VT_FILETIME:
        break;

    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_CLSID:
        DfpAssert((void**)&pvarg->pszVal == (void**)&pvarg->pwszVal);
        DfpAssert((void**)&pvarg->pszVal == (void**)&pvarg->puuid);
        CoTaskMemFree( pvarg->pszVal ); // ptr at 0
        break;
        
    case VT_CF:
        if (pvarg->pclipdata != NULL)
        {
            CoTaskMemFree( pvarg->pclipdata->pClipData ); // ptr at 8
            CoTaskMemFree( pvarg->pclipdata );
        }
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        CoTaskMemFree( pvarg->blob.pBlobData ); //ptr at 4
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
        if (pvarg->pStream != NULL)
            pvarg->pStream->Release();
        break;

    case VT_VERSIONED_STREAM:
        if( NULL != pvarg->pVersionedStream )
        {
            if( NULL != pvarg->pVersionedStream->pStream )
                pvarg->pVersionedStream->pStream->Release();
            CoTaskMemFree( pvarg->pVersionedStream );
        }
        break;

    case VT_STORAGE:
    case VT_STORED_OBJECT:
        if (pvarg->pStorage != NULL)
            pvarg->pStorage->Release();
        break;

    case (VT_VECTOR | VT_I1):
    case (VT_VECTOR | VT_UI1):
    case (VT_VECTOR | VT_I2):
    case (VT_VECTOR | VT_UI2):
    case (VT_VECTOR | VT_I4):
    case (VT_VECTOR | VT_UI4):
    case (VT_VECTOR | VT_I8):
    case (VT_VECTOR | VT_UI8):
    case (VT_VECTOR | VT_R4):
    case (VT_VECTOR | VT_R8):
    case (VT_VECTOR | VT_CY):
    case (VT_VECTOR | VT_DATE):

FreeArray:
        DfpAssert((void**)&pvarg->caub.pElems == (void**)&pvarg->cai.pElems);
        CoTaskMemFree( pvarg->caub.pElems );
        break;

    case (VT_VECTOR | VT_BSTR):
        if (pvarg->cabstr.pElems != NULL)
        {
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                if (pvarg->cabstr.pElems[l] != NULL)
                {
                    PrivSysFreeString( pvarg->cabstr.pElems[l] );
                }
            }
        }
        goto FreeArray;

    case (VT_VECTOR | VT_BSTR_BLOB):
        if (pvarg->cabstrblob.pElems != NULL)
        {
            for (l=0; l< pvarg->cabstrblob.cElems; l++)
            {
                if (pvarg->cabstrblob.pElems[l].pData != NULL)
                {
                    CoTaskMemFree( pvarg->cabstrblob.pElems[l].pData );
                }
            }
        }
        goto FreeArray;

    case (VT_VECTOR | VT_BOOL):
    case (VT_VECTOR | VT_ERROR):
        goto FreeArray;

    case (VT_VECTOR | VT_LPSTR):
    case (VT_VECTOR | VT_LPWSTR):
        if (pvarg->calpstr.pElems != NULL)
        for (l=0; l< pvarg->calpstr.cElems; l++)
        {
            CoTaskMemFree( pvarg->calpstr.pElems[l] );
        }
        goto FreeArray;

    case (VT_VECTOR | VT_FILETIME):
    case (VT_VECTOR | VT_CLSID):
        goto FreeArray;

    case (VT_VECTOR | VT_CF):
        if (pvarg->caclipdata.pElems != NULL)
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                CoTaskMemFree( pvarg->caclipdata.pElems[l].pClipData );
            }
        goto FreeArray;

    case (VT_VECTOR | VT_VARIANT):
        if (pvarg->capropvar.pElems != NULL)
            hr = FreePropVariantArray(pvarg->capropvar.cElems, pvarg->capropvar.pElems);
        goto FreeArray;

    default:

        hr = PrivVariantClear( reinterpret_cast<VARIANT*>(pvarg) );
        if( DISP_E_BADVARTYPE == hr )
            hr = STG_E_INVALIDPARAMETER;

        break;
    }

    //  We have all of the important information about the variant, so
    //  let's clear it out.
    //
    PropVariantInit(pvarg);

    return (hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreePropVariantArray, public
//
//  Synopsis:   Frees a value array returned from ReadMultiple
//
//  Arguments:  [cval] - Number of elements
//              [rgvar] - Array
//
//  Returns:    S_OK if all types recognised and all freeable items were freed.
//              STG_E_INVALID_PARAMETER if one or more types were not
//              recognised but all items are freed too.
//
//  Notes:      Even if a vt-type is not understood, all the ones that are
//              understood are freed.  The error code will indicate
//              if *any* of the members were illegal types.
//
//----------------------------------------------------------------------------

STDAPI FreePropVariantArray (
        ULONG cVariants,
        PROPVARIANT *rgvars)
{
    HRESULT hr = S_OK;

    VDATESIZEPTROUT_LABEL(rgvars, cVariants * sizeof(PROPVARIANT),
                          Exit, hr );

    if (rgvars != NULL)
        for ( ULONG I=0; I < cVariants; I++ )
            if (STG_E_INVALIDPARAMETER == PropVariantClear ( rgvars + I ))
                hr = STG_E_INVALIDPARAMETER;

Exit:

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   AllocAndCopy
//
//  Synopsis:   Allocates enough memory to copy the passed data into and
//              then copies the data into the new buffer.
//
//  Arguments:  [cb] -- number of bytes of data to allocate and copy
//              [pvData]  --  the source of the data to copy
//              [phr] -- optional pointer to an HRESULT set to
//                       STG_E_INSUFFICIENTMEMORY if memory could
//                       not be allocated.
//              
//
//  Returns:    NULL if no memory could be allocated,
//              Otherwise, pointer to allocated and copied data.
//
//--------------------------------------------------------------------

void * AllocAndCopy(ULONG cb, void * pvData, HRESULT *phr /* = NULL */)
{
    void * pvNew  =  CoTaskMemAlloc( cb );
    if (pvNew != NULL)
    {
        memcpy(pvNew, pvData, cb);
    }
    else
    {
        if (phr != NULL)
        {
            *phr = STG_E_INSUFFICIENTMEMORY;
        }
    }
    return(pvNew);
}



//+-------------------------------------------------------------------
//
//  Function:   PropSysAllocString
//              PropSysFreeString
//
//  Synopsis:   Wrappers for OleAut32 routines.
//
//  Notes:      These PropSys* functions simply forward the call to
//              the PrivSys* routines in OLE32.  Those functions
//              will load OleAut32 if necessary, and forward the call.
//
//              The PrivSys* wrapper functions are provided in order to
//              delay the OleAut32 load.  The PropSys* functions below
//              are provided as a mechanism to allow the NTDLL PropSet
//              functions to call the PrivSys* function pointers.
//
//              The PropSys* functions below are part of the
//              UNICODECALLOUTS structure used by NTDLL.
//              These functions should go away when the property set
//              code is moved from NTDLL to OLE32.
//
//--------------------------------------------------------------------

STDAPI_(BSTR)
PropSysAllocString(OLECHAR FAR* pwsz)
{
    return( PrivSysAllocString( pwsz ));
}

STDAPI_(VOID)
PropSysFreeString(BSTR bstr)
{
    PrivSysFreeString( bstr );
    return;
}

//+---------------------------------------------------------------------------
//
//  Class:      CRGTypeSizes (instantiated in g_TypeSizes)
//
//  Synopsis:   This class maintains a table with an entry for
//              each of the VT types.  Each entry contains
//              flags and a byte-size for the type (each entry is
//              only a byte).
//
//              This was implemented as a class so that we could use
//              it like an array (using an overloaded subscript operator),
//              indexed by the VT.  An actual array would require
//              4K entries
//
//              Internally, this class keeps two tables, each containing
//              a range of VTs (the VTs range from 0 to 31, and 64 to 72).
//              Other values are treated as a special-case.
//
//----------------------------------------------------------------------------

//  -----------------------
//  Flags for table entries
//  -----------------------

#define BIT_VECTNOALLOC 0x80    // the VT_VECTOR with this type does not
                                // use heap allocation

#define BIT_SIMPNOALLOC 0x40    // the non VT_VECTOR with this type does not
                                // use heap allocation

#define BIT_INVALID     0x20    // marks an invalid type

#define BIT_SIZEMASK    0x1F    // mask for size of underlying type

//  Dimensions of the internal tables

#define MIN_TYPE_SIZES_A    VT_EMPTY        // First contiguous range of VTs
#define MAX_TYPE_SIZES_A    VT_LPWSTR

#define MIN_TYPE_SIZES_B    VT_FILETIME     // Second continuous range of VTs
#define MAX_TYPE_SIZES_B    VT_VERSIONED_STREAM

//  ----------------
//  class CRTTypeSizes
//  ----------------

class CRGTypeSizes
{

public:

    // Subscript Operator
    //
    // This is the only method on this class.  It is used to
    // read an entry in the table.

    unsigned char operator[]( int nSubscript )
    {
        // Is this in the first table?
        if( MIN_TYPE_SIZES_A <= nSubscript && nSubscript <= MAX_TYPE_SIZES_A )
        {
	    return( m_ucTypeSizesA[ nSubscript ] );
        }

        // Or, is it in the second table?
        else if( MIN_TYPE_SIZES_B<= nSubscript && nSubscript <= MAX_TYPE_SIZES_B )
        {
            return( m_ucTypeSizesB[ nSubscript - MIN_TYPE_SIZES_B ] );
        }

        // Or, is it a special-case value (not in either table)?
        else
        if( VT_BSTR_BLOB == nSubscript )
        {
	    return( sizeof(BSTRBLOB) );
        }

        // Otherwise, the VT is invalid.
        return( BIT_INVALID );
    }


private:

    // There are two ranges of supported VTs, so we have
    // one table for each.

    static const unsigned char m_ucTypeSizesA[];
    static const unsigned char m_ucTypeSizesB[];
};

//  --------------------------
//  Instantiate the CRGTypeSizes
//  --------------------------

CRGTypeSizes g_TypeSizes;

//  ----------------------------
//  Define the CTypeSizes tables
//  ----------------------------

const unsigned char CRGTypeSizes::m_ucTypeSizesA[] =
{                 BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_EMPTY= 0,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_NULL      = 1,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  2,                    //VT_I2        = 2,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_I4        = 3,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_R4        = 4,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_R8        = 5,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(CY),           //VT_CY        = 6,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(DATE),         //VT_DATE      = 7,
                                                       sizeof(BSTR),         //VT_BSTR      = 8,
                                        BIT_INVALID |  0,                    //VT_DISPATCH  = 9,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(SCODE),        //VT_ERROR     = 10,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(VARIANT_BOOL), //VT_BOOL      = 11,
                                                       sizeof(PROPVARIANT),  //VT_VARIANT   = 12,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_UNKNOWN   = 13,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    // 14
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    // 15
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,                    //VT_I1        = 16,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,                    //VT_UI1       = 17,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  2,                    //VT_UI2       = 18,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_UI4       = 19,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_I8        = 20,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_UI8       = 21,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_INT  = 22,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_UINT = 23,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_VOID = 24,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_HRESULT      = 25,
    BIT_INVALID |                                      0,                    //VT_PTR  = 26,
    BIT_INVALID |                                      0,                    //VT_SAFEARRAY    = 27,
    BIT_INVALID |                                      0,                    //VT_CARRAY       = 28,
    BIT_INVALID |                                      0,                    //VT_USERDEFINED  = 29,
														   sizeof(LPSTR),        //VT_LPSTR        = 30,
														   sizeof(LPWSTR)        //VT_LPWSTR       = 31,
};

const unsigned char CRGTypeSizes::m_ucTypeSizesB[] =
{
    // sizes for vectors of types marked ** are determined dynamically
    BIT_SIMPNOALLOC | BIT_VECTNOALLOC |     sizeof(FILETIME),     //VT_FILETIME                 = 64,
                                            0,                    //**VT_BLOB                   = 65,
                                            0,                    //**VT_STREAM                 = 66,
                                            0,                    //**VT_STORAGE                = 67,
                                            0,                    //**VT_STREAMED_OBJECT        = 68,
                                            0,                    //**VT_STORED_OBJECT          = 69,
                                            0,                    //**VT_BLOB_OBJECT            = 70,
                                            sizeof(CLIPDATA),     //VT_CF                       = 71,
                      BIT_VECTNOALLOC |     sizeof(CLSID),        //VT_CLSID                    = 72,
                                            0                     //**VT_VERSIONED_STREAM       = 73
};


//+---------------------------------------------------------------------------
//
//  Function:   PropVariantCopy, public
//
//  Synopsis:   Copies a PROPVARIANT
//
//  Arguments:  [pDest] -- the destination PROPVARIANT
//              [pvarg] - the source PROPVARIANT
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

STDAPI PropVariantCopy ( PROPVARIANT * pvOut, const PROPVARIANT * pvarg )
{
    HRESULT     hr = S_OK;
    register unsigned char TypeInfo;
    register int iBaseType;
    BOOL fInputValidated = FALSE;
    PROPVARIANT Temp, *pDest = &Temp;

    //  ----------
    //  Initialize
    //  ----------

    // Validate the inputs

    VDATEREADPTRIN_LABEL( pvarg, PROPVARIANT, Exit, hr );
    VDATEPTROUT_LABEL( pvOut, PROPVARIANT, Exit, hr );
    fInputValidated = TRUE;

    // Duplicate the source propvar to the temp destination.  For types with
    // no external buffer (e.g. an I4), this will be sufficient.  For
    // types with an external buffer, we'll now have both propvars
    // pointing to the same buffer.  So we'll have to re-allocate 
    // for the destination propvar and copy the data into it.
    //

    *pDest = *pvarg;

    // Handle the simple types quickly.

    iBaseType = pvarg->vt & ~VT_VECTOR;
    TypeInfo = g_TypeSizes[ iBaseType ];    // Not to be confused with an ITypeInfo

    if( (TypeInfo & BIT_INVALID) != 0 )
    {
        // Try copying it as a regular Variant
        PropVariantInit( pDest );
        hr = PrivVariantCopy( reinterpret_cast<VARIANT*>(pDest),
                              reinterpret_cast<VARIANT*>(const_cast<PROPVARIANT*>( pvarg )) );
        goto Exit;
    }

    //  -----------------------
    //  Handle non-vector types
    //  -----------------------

    if ((pvarg->vt & VT_VECTOR) == 0)
    {

        // Is this a type which requires an allocation (otherwise there's
        // nothing to do)?

        if ((TypeInfo & BIT_SIMPNOALLOC) == 0)
        {
            // Yes - an allocation is required.

            // Keep a copy of the allocated buffer, so that at the end of
            // this switch, we can distiguish the out-of-memory condition from
            // the no-alloc-required condition.

            void * pvAllocated = (void*)-1;

            switch (pvarg->vt)
            {
                case VT_BSTR:
                    if( NULL != pvarg->bstrVal )
                        pvAllocated = pDest->bstrVal = PrivSysAllocString( pvarg->bstrVal );
                    break;

                case VT_BSTR_BLOB:
                    if( NULL != pvarg->bstrblobVal.pData )
                        pvAllocated = pDest->bstrblobVal.pData = (BYTE*)
                            AllocAndCopy(pDest->bstrblobVal.cbSize, pvarg->bstrblobVal.pData);
                    break;

                case VT_LPSTR:
                    if (pvarg->pszVal != NULL)
                        pvAllocated = pDest->pszVal = (CHAR *)
                            AllocAndCopy(strlen(pvarg->pszVal)+1, pvarg->pszVal);
                    break;
                case VT_LPWSTR:
                    if (pvarg->pwszVal != NULL)
                    {
                        ULONG cbString = (Prop_wcslen(pvarg->pwszVal)+1) * sizeof(WCHAR);
                        pvAllocated = pDest->pwszVal = (WCHAR *)
                            AllocAndCopy(cbString, pvarg->pwszVal);
                    }
                    break;
                case VT_CLSID:
                    if (pvarg->puuid != NULL)
                        pvAllocated = pDest->puuid = (GUID *)
                            AllocAndCopy(sizeof(*(pvarg->puuid)), pvarg->puuid);
                    break;
                
                case VT_CF:
                    // first check if CLIPDATA is present
                    if (pvarg->pclipdata != NULL)
                    {
                        // yes ... copy the clip data structure

                        pvAllocated = pDest->pclipdata = (CLIPDATA*)AllocAndCopy(
                            sizeof(*(pvarg->pclipdata)), pvarg->pclipdata);

                        // did we allocate the CLIPDATA ?
                        if (pvAllocated != NULL)
                        {
                            // yes ... initialize the destination.
                            pDest->pclipdata->pClipData = NULL;

                            // Is the input valid?
                            if (NULL == pvarg->pclipdata->pClipData
                                &&
                                0 != CBPCLIPDATA(*pvarg->pclipdata))
                            {
                                // no ... the input is not valid
                                hr = STG_E_INVALIDPARAMETER;
                                CoTaskMemFree( pDest->pclipdata );
                                pvAllocated = pDest->pclipdata = NULL;
                                break;
                            }

                            // Copy the actual clip data.  Note that if the source
                            // is non-NULL, we copy it, even if the length is 0.

                            if( NULL != pvarg->pclipdata->pClipData )
                            {
                                pvAllocated = pDest->pclipdata->pClipData =
                                    (BYTE*)AllocAndCopy(CBPCLIPDATA(*pvarg->pclipdata),
                                             pvarg->pclipdata->pClipData);
                            }

                        }   // if (pvAllocated != NULL)
                    }   // if (pvarg->pclipdata != NULL)
                    break;

                case VT_BLOB:
                case VT_BLOB_OBJECT:

                    // Is the input valid?
                    if (NULL == pvarg->blob.pBlobData
                        &&
                        0 != pvarg->blob.cbSize)
                    {
                        // no ... the input is not valid
                        hr = STG_E_INVALIDPARAMETER;
                        goto Exit;
                    }

                    // Copy the actual blob.  Note that if the source
                    // is non-NULL, we copy it, even if the length is 0.

                    if( NULL != pvarg->blob.pBlobData )
                    {
                        pvAllocated = pDest->blob.pBlobData =
                            (BYTE*)AllocAndCopy(pvarg->blob.cbSize,
                                     pvarg->blob.pBlobData);
                    }


                    break;

                case VT_STREAM:
                case VT_STREAMED_OBJECT:

                    if (pDest->pStream != NULL)
                            pDest->pStream->AddRef();
                    break;

                case VT_VERSIONED_STREAM:

                    if( NULL != pvarg->pVersionedStream )
                    {
                        LPVERSIONEDSTREAM pVersionedStream
                            = reinterpret_cast<LPVERSIONEDSTREAM>(CoTaskMemAlloc( sizeof(VERSIONEDSTREAM) ));
                        if( NULL == pVersionedStream )
                        {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                        }

                        *pVersionedStream = *pvarg->pVersionedStream;
                        if( NULL != pVersionedStream->pStream )
                            pVersionedStream->pStream->AddRef();

                        pDest->pVersionedStream = pVersionedStream;
                    }

                    break;


                case VT_STORAGE:
                case VT_STORED_OBJECT:

                    if (pDest->pStorage != NULL)
                            pDest->pStorage->AddRef();
                    break;

                case VT_VARIANT:

                    // drop through - this merely documents that VT_VARIANT has been thought of.
                    // VT_VARIANT is only supported as part of a vector.

                default:

                    hr = STG_E_INVALIDPARAMETER;
                    goto Exit;

            }   // switch (pvarg->vt)

            // If there was an error, we're done.
            if( FAILED(hr) )
                goto Exit;

            // pvAllocated was initialized to -1, so if it's NULL now,
            // there was an alloc failure.

            if (pvAllocated == NULL)
            {
                hr = STG_E_INSUFFICIENTMEMORY;
                goto Exit;
            }

        }   // if ((TypeInfo & BIT_SIMPNOALLOC) == 0)
    }   // if ((pvarg->vt & VT_VECTOR) == 0)

    //  -------------------
    //  Handle vector types
    //  -------------------

    else
    {
        // What's the byte-size of this type.

        ULONG cbType = TypeInfo & BIT_SIZEMASK;
        if (cbType == 0)
        {
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        // handle the vector types

        // this depends on the pointer and count being in the same place in
        // each of CAUI1 CAI2 etc

        // allocate the array for pElems
        if (pvarg->caub.pElems == NULL || pvarg->caub.cElems == 0)
        {
            DfpAssert( hr == S_OK );
            goto Exit; // not really an error
        }

        // Allocate the pElems array (the size of which is
        // type-dependent), and copy the source into it.

        void *pvAllocated = pDest->caub.pElems = (BYTE *)
            AllocAndCopy(cbType * pvarg->caub.cElems, pvarg->caub.pElems);

        if (pvAllocated == NULL)
        {
            hr = STG_E_INSUFFICIENTMEMORY;
            goto Exit;
        }

        // If this type doesn't require secondary allocation (e.g.
        // a VT_VECTOR | VT_I4), then we're done.

        if ((TypeInfo & BIT_VECTNOALLOC) != 0)
        {
            // the vector needs no further allocation
            DfpAssert( hr == S_OK );
            goto Exit;
        }

        ULONG l;

        // vector types that require allocation ...
        // we first zero out the pointers so that we can use PropVariantClear
        // to clean up in the error case

        switch (pvarg->vt)
        {
        case (VT_VECTOR | VT_BSTR):
            // initialize for error case
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                pDest->cabstr.pElems[l] = NULL;
            }
            break;

        case (VT_VECTOR | VT_BSTR_BLOB):
            // initialize for error case
            for (l=0; l< pvarg->cabstrblob.cElems; l++)
            {
                memset( &pDest->cabstrblob.pElems[l], 0, sizeof(BSTRBLOB) );
            }
            break;

        case (VT_VECTOR | VT_LPSTR):
        case (VT_VECTOR | VT_LPWSTR):
            // initialize for error case
            for (l=0; l< pvarg->calpstr.cElems; l++)
            {
                pDest->calpstr.pElems[l] = NULL;
            }
            break;

        case (VT_VECTOR | VT_CF):
            // initialize for error case
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                pDest->caclipdata.pElems[l].pClipData  = NULL;
            }
            break;

        case (VT_VECTOR | VT_VARIANT):
            // initialize for error case
            for (l=0; l< pvarg->capropvar.cElems; l++)
            {
                pDest->capropvar.pElems[l].vt = VT_ILLEGAL;
            }
            break;

        default:
            DfpAssert(!"Internal error: Unexpected type in PropVariantCopy");
            CoTaskMemFree( pvAllocated );
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        // This is a vector type which requires a secondary alloc.

        switch (pvarg->vt)
        {
            case (VT_VECTOR | VT_BSTR):
                for (l=0; l< pvarg->cabstr.cElems; l++)
                {
                    if (pvarg->cabstr.pElems[l] != NULL)
                    {
                        pDest->cabstr.pElems[l] = PrivSysAllocString( pvarg->cabstr.pElems[l]);
                        if (pDest->cabstr.pElems[l]  == NULL)
                        {
                            hr = STG_E_INSUFFICIENTMEMORY;
                            break;
                        }
                    }
                }
                break;

            case (VT_VECTOR | VT_BSTR_BLOB):
                for (l=0; l< pvarg->cabstrblob.cElems; l++)
                {
                    if (pvarg->cabstrblob.pElems[l].pData != NULL)
                    {
                        pDest->cabstrblob.pElems[l].cbSize
                            = pvarg->cabstrblob.pElems[l].cbSize;

                        pDest->cabstrblob.pElems[l].pData = (BYTE*)AllocAndCopy(
                            pvarg->cabstrblob.pElems[l].cbSize,
                            pvarg->cabstrblob.pElems[l].pData,
                            &hr );

                        if (hr != S_OK)
                            break;
                    }
                }
                break;
        
            case (VT_VECTOR | VT_LPWSTR):
                for (l=0; l< pvarg->calpwstr.cElems; l++)
                {
                    if (pvarg->calpwstr.pElems[l] != NULL)
                    {

                        pDest->calpwstr.pElems[l] = (LPWSTR)AllocAndCopy(
                            sizeof(WCHAR)*(Prop_wcslen(pvarg->calpwstr.pElems[l])+1),
                            pvarg->calpwstr.pElems[l],
                            &hr);

                        if (hr != S_OK)
                            break;
                    }
                }
                break;

            case (VT_VECTOR | VT_LPSTR):
                for (l=0; l< pvarg->calpstr.cElems; l++)
                {
                    if (pvarg->calpstr.pElems[l] != NULL)
                    {
                        pDest->calpstr.pElems[l] = (LPSTR)AllocAndCopy(
                            strlen(pvarg->calpstr.pElems[l])+1,
                            pvarg->calpstr.pElems[l],
                            &hr);

                        if (hr != S_OK)
                            break;
                    }
                }
                break;

            case (VT_VECTOR | VT_CF):
                for (l=0; l< pvarg->caclipdata.cElems; l++)
                {
                    // Is the input valid?
                    if (NULL == pvarg->caclipdata.pElems[l].pClipData
                        &&
                        0 != CBPCLIPDATA(pvarg->caclipdata.pElems[l] ))
                    {
                        hr = STG_E_INVALIDPARAMETER;
                        break;
                    }

                    // Is there data to copy?
                    if (NULL != pvarg->caclipdata.pElems[l].pClipData)
                    {
                        pDest->caclipdata.pElems[l].pClipData  = (BYTE*)AllocAndCopy(
                            CBPCLIPDATA(pvarg->caclipdata.pElems[l]),
                            pvarg->caclipdata.pElems[l].pClipData,
                            &hr);

                        if (hr != S_OK)
                            break;
                    }
                }
                break;

            case (VT_VECTOR | VT_VARIANT):
                for (l=0; l< pvarg->capropvar.cElems; l++)
                {
                    hr = PropVariantCopy(pDest->capropvar.pElems + l,
                                         pvarg->capropvar.pElems + l);
                    if (hr != S_OK)
                    {
                        break;
                    }
                }
                break;

            default:
                DfpAssert(!"Internal error: Unexpected type in PropVariantCopy");
                CoTaskMemFree( pvAllocated );
                hr = STG_E_INVALIDPARAMETER;
                goto Exit;

        }   // switch (pvarg->vt)
    }   // if ((pvarg->vt & VT_VECTOR) == 0) ... else

    //  ----
    //  Exit
    //  ----

Exit:

    // If there was an error, and it wasn't a caller error
    // (in which case *pDest may not be writable), clear the
    // destination propvar.

    if (fInputValidated && hr != S_OK && E_INVALIDARG != hr)
    {
        // if *pDest == *pvarg, then we didn't alloc anything, and
        // nothing need be cleared, so we'll just init *pDest.
        // We can't free it because it may point to pvarg's buffers.

        if( !memcmp( pDest, pvarg, sizeof(PROPVARIANT) ))
            PropVariantInit( pDest );

        // Otherwise, we must have done some allocations for *pDest,
        // and must free them.

        else
            PropVariantClear( pDest );

    }

    if (SUCCEEDED(hr))
        *pvOut = Temp;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   NtStatusToScode, public
//
//  Synopsis:   Attempts to map an NTSTATUS code to an SCODE
//
//  Arguments:  [nts] - NTSTATUS
//
//  Returns:    Appropriate status code
//
//  History:    29-Jun-93       DrewB   Created
//
//  Notes:      Assumes [nts] is an error code
//              This function is by no means exhaustively complete
//
//----------------------------------------------------------------------------

SCODE NtStatusToScode(NTSTATUS nts)
{
    SCODE sc;

    propDbg((DEB_ITRACE, "In  NtStatusToScode(%lX)\n", nts));

    switch(nts)
    {
    case STATUS_INVALID_PARAMETER:
    case STATUS_INVALID_PARAMETER_MIX:
    case STATUS_INVALID_PARAMETER_1:
    case STATUS_INVALID_PARAMETER_2:
    case STATUS_INVALID_PARAMETER_3:
    case STATUS_INVALID_PARAMETER_4:
    case STATUS_INVALID_PARAMETER_5:
    case STATUS_INVALID_PARAMETER_6:
    case STATUS_INVALID_PARAMETER_7:
    case STATUS_INVALID_PARAMETER_8:
    case STATUS_INVALID_PARAMETER_9:
    case STATUS_INVALID_PARAMETER_10:
    case STATUS_INVALID_PARAMETER_11:
    case STATUS_INVALID_PARAMETER_12:
        sc = STG_E_INVALIDPARAMETER;
        break;

    case STATUS_DUPLICATE_NAME:
    case STATUS_DUPLICATE_OBJECTID:
    case STATUS_OBJECTID_EXISTS:
    case STATUS_OBJECT_NAME_COLLISION:
        sc = STG_E_FILEALREADYEXISTS;
        break;

    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_NOT_A_DIRECTORY:
    case STATUS_FILE_IS_A_DIRECTORY:
    case STATUS_PROPSET_NOT_FOUND:
    case STATUS_NOT_FOUND:
    case STATUS_OBJECT_TYPE_MISMATCH:
        sc = STG_E_FILENOTFOUND;
        break;

    case STATUS_OBJECT_NAME_INVALID:
    case STATUS_OBJECT_PATH_SYNTAX_BAD:
    case STATUS_OBJECT_PATH_INVALID:
    case STATUS_NAME_TOO_LONG:
        sc = STG_E_INVALIDNAME;
        break;

    case STATUS_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;

    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;

    case STATUS_INVALID_HANDLE:
    case STATUS_FILE_INVALID:
    case STATUS_FILE_FORCED_CLOSED:
        sc = STG_E_INVALIDHANDLE;
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
    case STATUS_INVALID_SYSTEM_SERVICE:
    case STATUS_NOT_IMPLEMENTED:
        sc = STG_E_INVALIDFUNCTION;
        break;

    case STATUS_NO_MEDIA_IN_DEVICE:
    case STATUS_UNRECOGNIZED_MEDIA:
    case STATUS_DISK_CORRUPT_ERROR:
    case STATUS_DATA_ERROR:
        sc = STG_E_WRITEFAULT;
        break;

    case STATUS_OBJECT_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;

    case STATUS_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;

    case STATUS_FILE_LOCK_CONFLICT:
    case STATUS_LOCK_NOT_GRANTED:
        sc = STG_E_LOCKVIOLATION;
        break;

    case STATUS_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;

    case STATUS_ACCESS_VIOLATION:
    case STATUS_INVALID_USER_BUFFER:
        sc = STG_E_INVALIDPOINTER;
        break;

    case STATUS_TOO_MANY_OPENED_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;

    case STATUS_DIRECTORY_NOT_EMPTY:
        sc = HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
        break;

    case STATUS_DELETE_PENDING:
        sc = STG_E_REVERTED;
        break;

    case STATUS_INTERNAL_DB_CORRUPTION:
        sc = STG_E_INVALIDHEADER;
        break;

    case STATUS_UNSUCCESSFUL:
        sc = E_FAIL;
        break;
        
    case STATUS_UNMAPPABLE_CHARACTER:
        sc = HRESULT_FROM_WIN32( ERROR_NO_UNICODE_TRANSLATION );
        break;

    default:
        propDbg((DEB_TRACE, "NtStatusToScode: Unknown status %lX\n", nts));

        sc = HRESULT_FROM_WIN32(RtlNtStatusToDosError(nts));
        break;
    }

    propDbg((DEB_ITRACE, "Out NtStatusToScode => %lX\n", sc));
    return sc;
}

#if DBG!=0 && !defined(WINNT)

ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    CHAR Buffer[512];
    int cb;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    cb = PropVsprintfA(Buffer, Format, arglist);
    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 2] = '\n';
        Buffer[sizeof(Buffer) - 1] = '\0';
    }

    OutputDebugString(Buffer);

    return 0;
}
#endif


//+-------------------------------------------------------------------
//
//  Member:     ValidateInRGPROPVARIANT
//
//  Synopsis:   S_OK if PROPVARIANT[] is valid for Read.
//              E_INVALIDARG otherwise.
//
//--------------------------------------------------------------------

HRESULT
ValidateInRGPROPVARIANT( ULONG cpspec, const PROPVARIANT rgpropvar[] )
{
    // We verify that we can read the whole PropVariant[], but
    // we don't validate the content of those elements.

    HRESULT hr;
    VDATESIZEREADPTRIN_LABEL(rgpropvar, cpspec * sizeof(PROPVARIANT), Exit, hr);
    hr = S_OK;

Exit:

    return( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     ValidateOutRGPROPVARIANT
//
//  Synopsis:   S_OK if PROPVARIANT[] is valid for Write.
//              E_INVALIDARG otherwise.
//
//--------------------------------------------------------------------

HRESULT
ValidateOutRGPROPVARIANT( ULONG cpspec, PROPVARIANT rgpropvar[] )
{
    // We verify that we can write the whole PropVariant[], but
    // we don't validate the content of those elements.

    HRESULT hr;
    VDATESIZEPTROUT_LABEL(rgpropvar, cpspec * sizeof(PROPVARIANT), Exit, hr);
    hr = S_OK;

Exit:

    return( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     ValidateOutRGLPOLESTR.
//
//  Synopsis:   S_OK if LPOLESTR[] is valid for Write.
//              E_INVALIDARG otherwise.
//
//--------------------------------------------------------------------

HRESULT
ValidateOutRGLPOLESTR( ULONG cpropid, LPOLESTR rglpwstrName[] )
{
    HRESULT hr;
    VDATESIZEPTROUT_LABEL( rglpwstrName, cpropid * sizeof(LPOLESTR), Exit, hr );
    hr = S_OK;

Exit:

    return( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     ValidateInRGLPOLESTR
//
//  Synopsis:   S_OK if LPOLESTR[] is valid for Read.
//              E_INVALIDARG otherwise.
//
//--------------------------------------------------------------------

HRESULT
ValidateInRGLPOLESTR( ULONG cpropid, const OLECHAR* const rglpwstrName[] )
{
    // Validate that we can read the entire vector.

    HRESULT hr;
    VDATESIZEREADPTRIN_LABEL( rglpwstrName, cpropid * sizeof(LPOLESTR), Exit, hr );

    // Validate that we can at least read the first character of
    // each of the strings.

    for( ; cpropid > 0; cpropid-- )
    {
        VDATEREADPTRIN_LABEL( rglpwstrName[cpropid-1], WCHAR, Exit, hr );
    }

    hr = S_OK;

Exit:

    return( hr );
}





//+----------------------------------------------------------------------------
//
//  Function:   IsOriginalPropVariantType
//
//  Determines if a VARTYPE was one of the ones in the original PropVariant
//  definition (as defined in the OLE2 spec and shipped with NT4/DCOM95).
//
//+----------------------------------------------------------------------------

BOOL
IsOriginalPropVariantType( VARTYPE vt )
{
    if( vt & ~VT_TYPEMASK & ~VT_VECTOR )
        return( FALSE );

    switch( vt )
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_UI1: 
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_CLSID:
    case VT_BLOB:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_UI1|VT_VECTOR:
    case VT_I2|VT_VECTOR:
    case VT_UI2|VT_VECTOR:
    case VT_BOOL|VT_VECTOR:
    case VT_I4|VT_VECTOR:
    case VT_UI4|VT_VECTOR:
    case VT_R4|VT_VECTOR:
    case VT_ERROR|VT_VECTOR:
    case VT_I8|VT_VECTOR:
    case VT_UI8|VT_VECTOR:
    case VT_R8|VT_VECTOR:
    case VT_CY|VT_VECTOR:
    case VT_DATE|VT_VECTOR:
    case VT_FILETIME|VT_VECTOR:
    case VT_CLSID|VT_VECTOR:
    case VT_CF|VT_VECTOR:
    case VT_BSTR|VT_VECTOR:
    case VT_BSTR_BLOB|VT_VECTOR:
    case VT_LPSTR|VT_VECTOR:
    case VT_LPWSTR|VT_VECTOR:
    case VT_VARIANT|VT_VECTOR:

        return( TRUE );
    }

    return( FALSE );
}



//+----------------------------------------------------------------------------
//
//  Function:   IsVariantType
//
//  Determines if a VARTYPE is one in the set of Variant types which are 
//  supported in the property set implementation.
//
//+----------------------------------------------------------------------------

BOOL
IsVariantType( VARTYPE vt )
{
    // Vectors are unsupported
    if( (VT_VECTOR | VT_RESERVED) & vt )
        return( FALSE );

    switch( VT_TYPEMASK & vt )
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_UNKNOWN:
    case VT_DISPATCH:
    case VT_BOOL:
    case VT_ERROR:
    case VT_DECIMAL:
    case VT_VARIANT:

        return( TRUE );

    default:

        return( FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\iprop\nt5props.h ===
#ifndef _IPROP_H_
#define _IPROP_H_


#if !defined(__objidl_h__) || !defined(_OBJBASE_H_)
#error ole2.h (specifically, objidl.h & objbase.h) must be included before iprop.h
#endif

EXTERN_C HRESULT __stdcall PrivStgOpenStorageEx (
            const WCHAR *pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            void *        pSecurity,    // supports IAccessControl
            void *        pTransaction, // coordinated transactions
            REFIID riid,
            void ** ppObjectOpen);

EXTERN_C HRESULT __stdcall PrivStgCreateStorageEx (
            const WCHAR* pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            void *        pSecurity,    // supports IAccessControl
            void *        pTransaction, // coordinated transactions
            REFIID riid,
            void ** ppObjectOpen);


#ifndef STGFMT_STORAGE
#define STGFMT_STORAGE          0
#define STGFMT_NATIVE           1
#define STGFMT_FILE             3
#define STGFMT_ANY              4
#define STGFMT_DOCFILE          5
#endif // #ifndef STGFMT_STORAGE



EXTERN_C HRESULT __stdcall PrivPropVariantCopy ( PROPVARIANT * pvarDest, const PROPVARIANT * pvarSrc );
EXTERN_C HRESULT __stdcall PrivPropVariantClear ( PROPVARIANT * pvar );
EXTERN_C HRESULT __stdcall PrivFreePropVariantArray ( ULONG cVariants, PROPVARIANT * rgvars );

#ifdef NT5PROPS_CI_APIS
EXTERN_C ULONG   __stdcall PrivStgPropertyLengthAsVariant( IN SERIALIZEDPROPERTYVALUE const *pprop, IN ULONG cbprop, IN USHORT CodePage, IN BYTE flags );
EXTERN_C SERIALIZEDPROPERTYVALUE * __stdcall
                           PrivStgConvertVariantToProperty( IN PROPVARIANT const *pvar, IN USHORT CodePage, OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop, IN OUT ULONG *pcb, IN PROPID pid, IN BOOLEAN fVariantVectorOrArray, OPTIONAL OUT ULONG *pcIndirect );
#endif

#define StgOpenStorageEx                PrivStgOpenStorageEx
#define StgCreateStorageEx              PrivStgCreateStorageEx
#define PropVariantCopy                 PrivPropVariantCopy
#define PropVariantClear                PrivPropVariantClear
#define FreePropVariantArray            PrivFreePropVariantArray
#define StgPropertyLengthAsVariant      PrivStgPropertyLengthAsVariant
#define StgConvertVariantToProperty     PrivStgConvertVariantToProperty

#endif // #ifndef _IPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\tnupdr.cxx ===
//+------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File: tnupdr.cxx
//
//+------------------------------------------------------------------

#include "pch.cxx"

#include <filtntfy.h>
#include "tnupdr.hxx"


EXTERN_C const IID IID_IFlatStorage; /* b29d6138-b92f-11d1-83ee-00c04fc2c6d4 */

DECLARE_INFOLEVEL(updr)

#define DEB_INFO    DEB_USER1
#define DEB_REGINFO DEB_USER2


#define MIME_TYPES_ROOT L"software\\classes\\Mime\\Database\\Content Type"

#define IMAGE_PREFIX    L"image/"
#define IMAGE_PREFIX_LEN  6

extern "C" CLSID CLSID_ThumbnailFCNHandler;
extern "C" CLSID CLSID_ThumbnailUpdater;

class CThumbnailCF : public IClassFactory
{
public:
    // Constructor
    CThumbnailCF(): _cRefs(1)  { }

    // IUnknown methods
    STDMETHOD (QueryInterface)   (REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)     (void);
    STDMETHOD_(ULONG,Release)    (void);

    // IClassFactory methods
    STDMETHOD (CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppv);
    STDMETHOD (LockServer)    (BOOL fLock) { return S_OK; }

private:
    ULONG               _cRefs;         // CF reference count
};


//////////////////////////////////////////////////////////////
//  Funtion to create a Class Factory Object.
//      This is in form DoATClassCreate() wants.
//////////////////////////////////////////////////////////////

HRESULT GetCThumbnailCF(REFCLSID clsid, REFIID iid, void **ppv)
{
    HRESULT hr=S_OK;
    CThumbnailCF *pCF=NULL;

    *ppv = 0;

    if( ! IsEqualCLSID(clsid, CLSID_ThumbnailUpdater))
        return CLASS_E_CLASSNOTAVAILABLE;

    pCF = new CThumbnailCF();

    if( NULL == pCF )
        return E_OUTOFMEMORY;


    hr = pCF->QueryInterface(iid, ppv);
    pCF->Release();

    return hr;
}


//////////////////////////////////////////////////////////////
//  Hook from the DllgetClassObject routine.
//      This is special because it must start in an Apartment.
//////////////////////////////////////////////////////////////

HRESULT CThumbnail_ApartmentDllGetClassObject(
        REFCLSID clsid,
        REFIID iid,
        void **ppv)
{
    HRESULT hr;

    updrDebug((DEB_ITRACE,
                "ApartmentDllGetClassObject(%I,%I,%x)\n",
                &clsid, &iid, ppv));

    if(IsEqualCLSID(clsid, CLSID_ThumbnailUpdater))
    {
        COleTls tls;

        if ( (tls->dwFlags & OLETLS_INNEUTRALAPT)
             || !(tls->dwFlags & OLETLS_APARTMENTTHREADED))
        {
            //We need to switch to a single-threaded apartment.
            hr = DoATClassCreate(GetCThumbnailCF, clsid, iid, (IUnknown **)ppv);
        }
        else
        {
            //This thread is in a single-threaded apartment.
            hr = GetCThumbnailCF(clsid, iid, ppv);
        }
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CThumbnailCF::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CThumbnailCF::AddRef(void)
{
    return InterlockedIncrement((LONG *)&_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CThumbnailCF::Release, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CThumbnailCF::Release(void)
{
    ULONG cRefs = (ULONG) InterlockedDecrement((LONG *)&_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }
    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CThumbnailCF::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CThumbnailCF::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IClassFactory *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////
//  OLE32 Internal ClassFactory Entry Point
//////////////////////////////////////////////////////////////

HRESULT CThumbnailCF_CreateInstance(
        IUnknown *pUnkOuter,
        REFIID riid,
        void** ppv)
{
    HRESULT hr;
    CTNUpdater * pact;

    updrDebug(( DEB_IWARN, "Thumbnailer: CreateInstance called\n" ));

    if(NULL != pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    pact = new CTNUpdater;

    if(NULL == pact)
    {
        return E_OUTOFMEMORY;
    }

    if(!pact->ObjectInit())
    {
        pact->Release();
        return E_OUTOFMEMORY;
    }

    hr = pact->QueryInterface(riid, ppv);
    pact->Release();

    return hr;
}

//+-------------------------------------------------------------------
//  Member:     CThumbnailCF::CreateInstance, public
//--------------------------------------------------------------------
STDMETHODIMP CThumbnailCF::CreateInstance(IUnknown *pUnkOuter,
                                              REFIID riid,
                                              void **ppv)
{
    return CThumbnailCF_CreateInstance( pUnkOuter, riid, ppv );
}


//////////////////////////////////////////////////////////////
//  CTNUpdater Class
//////////////////////////////////////////////////////////////

//---------------------------------------------------------
//  C++ Methods: Constructor
//---------------------------------------------------------
CTNUpdater::CTNUpdater(void)
{
    m_cRef = 1;
    m_pITE = NULL;
    m_hEvRegNotify = NULL;
    m_hkeyMime = NULL;
    m_ppwszExtensions = NULL;
    m_pTempList = NULL;
}


//---------------------------------------------------------
//  C++ Methods: Destructor
//---------------------------------------------------------
CTNUpdater::~CTNUpdater(void)
{
    if( NULL != m_pTempList )
        FreeTempExtensionList();

    if( NULL != m_pITE )
        m_pITE->Release();

    if( NULL != m_hkeyMime )
        CloseHandle( m_hkeyMime );

    if( NULL != m_hEvRegNotify )
        CloseHandle( m_hEvRegNotify );

    if( NULL != m_ppwszExtensions )
        CoTaskMemFree( m_ppwszExtensions );
}

//---------------------------------------------------------
// non-interface Init routine
//---------------------------------------------------------
BOOL
CTNUpdater::ObjectInit()
{
    HRESULT sc;
    DWORD status;

    //
    // Create the event for waiting on registry changes.
    //
    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           MIME_TYPES_ROOT,
                           0,
                           KEY_ALL_ACCESS,
                           &m_hkeyMime );

    if( ERROR_SUCCESS != status )
        updrErr( EH_Err, LAST_SCODE );

    m_hEvRegNotify = CreateEvent( NULL,
                                  TRUE,     // Manual Reset
                                  FALSE,    // Init signaled
                                  NULL );

    if( NULL == m_hEvRegNotify )
        updrErr( EH_Err, LAST_SCODE );

    updrChk( GetImageFileExtensions() );

    return TRUE;
EH_Err:
    return FALSE;
}

//---------------------------------------------------------
//  IUnknown::AddRef
//---------------------------------------------------------
ULONG
CTNUpdater::AddRef()
{
    return InterlockedIncrement((LONG*)&m_cRef);
}

//---------------------------------------------------------
//  IUnknown::Release
//---------------------------------------------------------
ULONG
CTNUpdater::Release()
{
    LONG cRef;

    cRef = InterlockedDecrement((LONG*)&m_cRef);

    // ASSERT(cRef >= 0);

    if(cRef <= 0)
    {
        delete this;
    }
    return cRef;
}

//---------------------------------------------------------
//  IUnknown::QueryInterface
//---------------------------------------------------------
HRESULT
CTNUpdater::QueryInterface(
        REFIID iid,
        void **ppv)
{
    HRESULT hr=S_OK;
    IUnknown *pUnk=NULL;

    if(IsEqualIID(IID_IUnknown, iid))
    {
        pUnk = (IFilterStatus*)this;
    }
    else if(IsEqualIID(IID_IFilterStatus, iid))
    {
        pUnk = (IFilterStatus*)this;
    }
    else if(IsEqualIID(IID_IOplockStorage, iid))
    {
        pUnk = (IOplockStorage*)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppv = pUnk;
    return S_OK;
}

//---------------------------------------------------------
//  IFilterStatus::Initialize
//---------------------------------------------------------
HRESULT
CTNUpdater::Initialize(
        const WCHAR *pwszCatalogName,
        const WCHAR *pwszCatalogPath)
{
    return S_OK;
}

//---------------------------------------------------------
//  IFilterStatus::FilterLoad
//---------------------------------------------------------
HRESULT
CTNUpdater::FilterLoad(
        const WCHAR *pwszPath,
        SCODE scFilterStatus)
{
    return S_OK;
}

/*
//---------------------------------------------
// Test routine
//----------------------------------------

HRESULT
test_junk(IStorage *pstg)
{
    HRESULT sc=S_OK;
    IPropertySetStorage *ppss = NULL;
    IPropertyStorage *pps = NULL;
    PROPSPEC propSpec[1];
    PROPVARIANT propVar[1];


    updrChk( pstg->QueryInterface( IID_IPropertySetStorage, (void**)&ppss ) );

    updrChk( ppss->Open( FMTID_SummaryInformation,
                           STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                           &pps ) );

    propSpec[0].ulKind = PRSPEC_PROPID;
    propSpec[0].propid = PIDSI_THUMBNAIL;

    updrChk( pps->ReadMultiple(1, propSpec, propVar) );

EH_Err:
    // FreePropVariantArray(1, propVar);
    if( NULL != ppss )
        ppss->Release();
    if( NULL != pps )
        pps->Release();
    return sc;
} */

//---------------------------------------------------------
//  IFilterStatus::PreFilter
//
//  This routine ALWAYS SUCCEEDS, unless we want to defer processing
// to a later time.
//  If it returns any failure, CI will defer filtering the file
// and will submit it again later.
//---------------------------------------------------------
HRESULT
CTNUpdater::PreFilter(
        WCHAR const * pwszPath)
{
    HRESULT sc=S_OK;
    IStorage *pstg=NULL;
    IThumbnailExtractor *pITE=NULL;
    ITimeAndNoticeControl *pITNC=NULL;
    ULONG cStorageFinalReferences=0;

    updrDebug(( DEB_INFO | DEB_TRACE,
                "PreFilter(\"%ws\")\n", pwszPath ));

    // Optimize, don't spend time on files that we don't expect to be
    // Images.  If it does not have a valid extension then we are done.
    //
    if( ! HasAnImageFileExtension(pwszPath) )
        return S_FALSE;

    // Open an Oplock'ed Storage. (w/ SuppressChanges turned on)
    //
    updrChk( OpenStorageEx(pwszPath,
                           STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                           STGFMT_FILE,
                           0,
                           IID_IFlatStorage,
                           (void**)&pstg) );

    if( NULL == m_pITE )
    {
        updrChk( CoCreateInstance(CLSID_ThumbnailFCNHandler,
                                  NULL,          // pUnkOuter
                                  CLSCTX_INPROC_SERVER,
                                  IID_IThumbnailExtractor,
                                  (void**)&pITE) );
        m_pITE = pITE;
        pITE = NULL;
    }

    updrChk( m_pITE->OnFileUpdated(pstg) );


EH_Err:
    if(NULL != pITNC)
        pITNC->Release();

    if(NULL != pITE)
        pITE->Release();

    if(NULL != pstg)
        cStorageFinalReferences = pstg->Release();

    updrAssert( 0 == cStorageFinalReferences );
    updrDebug(( DEB_TRACE, "PreFilter() returned %x\n", sc ));

    switch( sc )
    {
    case STG_E_SHAREVIOLATION:  // Someone else has it open when we started.
    case STG_E_LOCKVIOLATION:

    case STG_E_REVERTED:        // Someone else opened if after we started.
        break;

        // All other problems are likely permanent so don't error.
        // all errors tell CI to  re-try the file.
    default:
        if( FAILED( sc ) )
            sc = S_FALSE;
        else
            sc = S_OK;
        break;
    }

    return sc;
}

//---------------------------------------------------------
//  IFilterStatus::PostFilter
//---------------------------------------------------------
HRESULT
CTNUpdater::PostFilter(
        WCHAR const * pwszPath,
        HRESULT hrStatus)
{
    return S_OK;
}


//---------------------------------------------------------
//  IOplockStorage::CreateStorageEx
//---------------------------------------------------------
HRESULT
CTNUpdater::CreateStorageEx(
        LPCWSTR pwcsName,
        DWORD   grfMode,
        DWORD   stgfmt,
        DWORD   grfAttrs,
        REFIID  riid,
        void ** ppstgOpen)
{
    return STG_E_INVALIDPARAMETER;
}

//---------------------------------------------------------
//  IOplockStorage::OpenStorageEx
//---------------------------------------------------------
HRESULT
CTNUpdater::OpenStorageEx(
        LPCWSTR pwcsName,
        DWORD   grfMode,
        DWORD   stgfmt,
        DWORD   grfAttrs,
        REFIID  riid,
        void ** ppstgOpen)
{
    HRESULT sc=S_OK;
    IStorage *pstg=NULL;

    if(0 != (grfMode & STGM_OPLOCKS_DONT_WORK))
        return STG_E_INVALIDFLAG;

    if(  STGFMT_NATIVE  == stgfmt
      || STGFMT_DOCFILE == stgfmt
      || STGFMT_STORAGE == stgfmt)
    {
        updrErr(EH_Err, STG_E_INVALIDPARAMETER);
    }


    if( STGFMT_ANY == stgfmt )
        updrErr(EH_Err, STG_E_INVALIDPARAMETER);

    if( STGFMT_FILE == stgfmt )
    {
        updrChk( NFFOpen( pwcsName,          // PathName
                          grfMode,           // Storage Mode
                                             // Special NFF flags
                          NFFOPEN_OPLOCK | NFFOPEN_SUPPRESS_CHANGES,
                          FALSE,             // Create API?
                          riid,              // Interface ID
                          (void**)&pstg ) ); // [out] interface pointer

    }

    *ppstgOpen = pstg;
    pstg = NULL;
    sc = S_OK;

EH_Err:

    RELEASE_INTERFACE( pstg );

    return(sc);
}


//---------------------------------------------------------
//  HasAnImageFileExtention, private method.
//---------------------------------------------------------
BOOL
CTNUpdater::HasAnImageFileExtension(
        WCHAR const * pwszPath)
{
    LPCWSTR pwszDot;
    LPWSTR* ppwszExt;
    HRESULT sc=S_OK;

    if(NULL == pwszPath)
        return FALSE;

    //
    // Scan forward through the string looking for the last dot that
    // was not followed by a WHACK or a SPACE.
    //
    for (pwszDot = NULL; *pwszPath; pwszPath++)
    {
        switch (*pwszPath) {
        case L'.':
            pwszDot = pwszPath;     // remember the last dot
            break;
        case L'\\':
        case L' ':                  // extensions can't have spaces
            pwszDot = NULL;         // forget last dot, it was in a directory
            break;
        }
    }

    // If there is no extension fail.
    //
    if(NULL == pwszDot)
        return FALSE;

    // If the registry change event is signaled then read a new list.
    //
    if( WAIT_OBJECT_0 == WaitForSingleObject( m_hEvRegNotify, 0 ) )
        updrChk( GetImageFileExtensions() );

    for( ppwszExt=m_ppwszExtensions; NULL!=*ppwszExt; ++ppwszExt)
    {
        // Do a case insensitive compare for a known extension.
        if( 0 == _wcsicmp( pwszDot, *ppwszExt ) )
            return TRUE;
    }
EH_Err:
    return FALSE;
}


HRESULT
CTNUpdater::GetImageFileExtensions()
{
    DWORD  idx, ckeys;
    LPWSTR pwszKeyName = NULL;
    LPWSTR pwszExtension;
    ULONG  ccName, ccMaxNameLength;
    DWORD  status;
    HRESULT sc;
    FILETIME ftLastTime;

    int cszTotalStrs=0;     // Count of Extension Strings
    int ccTotalChars=0;     // Count of total Extension characters w/ NULLs
    int cbTotalSize=0;      // Total memory to allocate.

    TEMPEXTLIST* pExt=NULL; // Src Pointer to the current Extension.
    LPWSTR* ppwszPtr=NULL;  // Des Pointer into string pointer table.
    WCHAR*  pwszBuf=NULL;   // Des Pointer into character buffer table.
    LPWSTR* ppwszTable=NULL;

    if( NULL != m_ppwszExtensions )
    {
        CoTaskMemFree( m_ppwszExtensions );
        m_ppwszExtensions = NULL;
    }

    //
    // Ask for notification if this part of the registry changes.
    // Set the notify before reading, that way if a change is made while
    // we are reading and we miss it, we will pick it up on the next round.
    //
    status = RegNotifyChangeKeyValue( m_hkeyMime,
                                      TRUE,     // watch subtree
                                      REG_NOTIFY_CHANGE_LAST_SET
                                      |REG_NOTIFY_CHANGE_NAME,
                                      m_hEvRegNotify,
                                      TRUE );
    if( ERROR_SUCCESS != status )
    {
        updrDebug(( DEB_ERROR,
                    "Can't set RegNotifyChangeKeyValue() %x\n",
                    GetLastError() ));
    }

    //
    // Get the size of the maximum entry.
    // Then allocate the buffer for the key name.
    //
    status = RegQueryInfoKey( m_hkeyMime,
                              NULL, NULL, NULL,
                              &ckeys,
                              &ccMaxNameLength,
                              NULL, NULL, NULL,
                              NULL, NULL, NULL );
    if(ERROR_SUCCESS != status)
        updrErr( EH_Err, LAST_SCODE );

    ccMaxNameLength += 1;  // Add one for the NULL
    updrMem( pwszKeyName = new WCHAR[ ccMaxNameLength * sizeof(WCHAR)] );

    //
    // Enumerate through all the format types, looking for
    // the image types.  (they start with "image/")
    //
    for(idx=0; idx<ckeys; idx++)
    {
        ccName = ccMaxNameLength;

        status = RegEnumKeyEx( m_hkeyMime,
                               idx,
                               pwszKeyName,
                               &ccName,
                               0,
                               NULL,
                               NULL,
                               &ftLastTime );

        if(ERROR_SUCCESS != status)
        {
            updrDebug(( DEB_REGINFO,
                        "Enum of Mime Image types failed %x)\n",
                        status));
            continue;
        }

        //
        // If it is an image format then get the value of the
        // "Extension" subkey (if any).
        //
        if( 0 == _wcsnicmp( pwszKeyName, IMAGE_PREFIX, IMAGE_PREFIX_LEN ) )
        {
            //
            // The extension string is allocated by "GetAFileNameExtension()"
            // and given away to "AddToTempExtensionList()".
            //
            sc = GetAFileNameExtension( pwszKeyName,
                                        &pwszExtension );

            if(!FAILED(sc))
            {
                AddToTempExtensionList( pwszExtension );
                pwszExtension = NULL;
            }
        }
    }

    //
    // Build a table of extensions from the temporary linked list.
    //

    // Count the size.
    //
    for(pExt=m_pTempList; pExt!=NULL; pExt=pExt->pNext)
    {
        cszTotalStrs += 1;
        ccTotalChars += wcslen(pExt->pwszExtension) + 1;
    }

    // Allocate the memory
    //
    cbTotalSize  = (cszTotalStrs+1) * sizeof (WCHAR*);
    cbTotalSize += ccTotalChars * sizeof(WCHAR*);
    ppwszTable = (LPWSTR*) CoTaskMemAlloc( cbTotalSize );

    // Set the pointers to the start of the pointer table and
    // the start of the character buffer space.
    //
    ppwszPtr = ppwszTable;
    pwszBuf = (WCHAR*) (ppwszTable + cszTotalStrs+1);

    for(pExt=m_pTempList; pExt!=NULL; pExt=pExt->pNext)
    {
        // Copy the string into the buffer space.
        //
        wcscpy(pwszBuf, pExt->pwszExtension);

        // Record the enrty to point at it.
        //
        *ppwszPtr = pwszBuf;

        // Advance the pointers.
        //
        ppwszPtr += 1;                  // Advance one string pointer.
        pwszBuf += wcslen(pwszBuf) +1;  // Advance one string.
    }

    // Place a NULL in the last entry, to terminate the list.
    //
    *ppwszPtr = NULL;

    FreeTempExtensionList();

    // Success.  Copy results out.
    //
    m_ppwszExtensions = ppwszTable;
    ppwszTable = NULL;

EH_Err:
    if( NULL != ppwszTable )
        CoTaskMemFree( ppwszTable );

    if( NULL != pwszKeyName )
        delete[] pwszKeyName;

    return S_OK;
}


//
// Search the existing list for an identical extension.  If you don't find
// one, then push a new one onto the front of the list.
// The string is given to us.  If we don't want it, then delete it.
//
HRESULT
CTNUpdater::AddToTempExtensionList(
        WCHAR* pwszExtension)
{
    TEMPEXTLIST* pExt;

    for(pExt=m_pTempList; pExt!=NULL; pExt=pExt->pNext)
    {
        if( 0 == _wcsicmp(pwszExtension, pExt->pwszExtension) )
            break;
    }

    if(NULL == pExt)
    {           // If we didn't find it, save it on the list.
        pExt = new TEMPEXTLIST;
        pExt->pwszExtension = pwszExtension;
        pExt->pNext = m_pTempList;
        m_pTempList = pExt;
    }
    else
    {           // If we already have one, then delete this string.
        CoTaskMemFree(pwszExtension);
    }
    return S_OK;
}



HRESULT
CTNUpdater::FreeTempExtensionList()
{
    TEMPEXTLIST* pExt;
    TEMPEXTLIST* pExtNext;

    pExt=m_pTempList;

    while(NULL != pExt)
    {
        pExtNext = pExt->pNext;
        CoTaskMemFree( pExt->pwszExtension );
        delete pExt;
        pExt = pExtNext;
    }
    m_pTempList = NULL;
    return S_OK;
}



HRESULT
CTNUpdater::GetAFileNameExtension(
        WCHAR*  pwszKeyName,
        WCHAR** ppwszExtension)
{
    DWORD status, dwType;
    HKEY hkeyImageFormat=NULL;
    DWORD cbExtBuf=0;
    HRESULT sc=S_OK;
    WCHAR *pwszExt=NULL;

    status = RegOpenKeyEx( m_hkeyMime,
                           pwszKeyName,
                           0,
                           KEY_ALL_ACCESS,
                           &hkeyImageFormat );

    if(ERROR_SUCCESS != status)
    {
        updrDebug(( DEB_ERROR,
                    "Error, could not open image format key '%ws' err=%d\n",
                    pwszKeyName, status ));
        updrErr( EH_Err, LAST_SCODE );
    }

    // Get the Size of the extension string.
    //
    status = RegQueryValueEx( hkeyImageFormat,
                              L"Extension",
                              0,
                              &dwType,
                              NULL,
                              &cbExtBuf );

    if(ERROR_SUCCESS != status)
    {
        if(ERROR_FILE_NOT_FOUND != status)
        {
            updrDebug(( DEB_REGINFO,
                    "Error, reading Extension for '%ws' err=%d\n",
                    pwszKeyName, status ));
        }
        sc = E_FAIL;
        goto EH_Err;
    }

    if(REG_SZ != dwType)
    {
        updrDebug(( DEB_REGINFO,
                "Error, Extension for '%ws' not REG_SZ type.\n",
                pwszKeyName ));
        sc = E_FAIL;
        goto EH_Err;
    }


    // Allocate the buffer and read the extension string.
    //
    updrMem( pwszExt = (WCHAR*)CoTaskMemAlloc(cbExtBuf) );

    status = RegQueryValueEx( hkeyImageFormat,
                              L"Extension",
                              0,
                              &dwType,
                              (BYTE*)pwszExt,
                              &cbExtBuf );

    if(ERROR_SUCCESS != status)
        updrErr( EH_Err, LAST_SCODE );

    *ppwszExtension = pwszExt;
    pwszExt = NULL;

EH_Err:
    if(NULL != pwszExt)
        CoTaskMemFree(pwszExt);

    if( NULL != hkeyImageFormat )
        RegCloseKey(hkeyImageFormat);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\iprop\assert.cxx ===
// This file provides dbgout implementations for use when the property
// set code is built into a standalone dll (so that we don't require a
// checked OLE32).

#include <pch.cxx>

#if DBG == 1

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[500];		// this is the message buffer

#include <dprintf.h>            // w4printf, w4dprintf prototypes

static int _cdecl w4dprintf(const char *format, ...)
{
	int ret;

    va_list va;
    va_start(va, format);
	ret = w4vdprintf(format, va);
    va_end(va);

	return ret;
}


static int _cdecl w4vdprintf(const char *format, va_list arglist)
{
	int ret;

	EnterCriticalSection(&s_csMessageBuf);
	ret = vsprintf(g_szMessageBuf, format, arglist);
	OutputDebugStringA(g_szMessageBuf);
	LeaveCriticalSection(&s_csMessageBuf);
	return ret;
}


void APINOT vdprintf(unsigned long ulCompMask,
              char const *pszComp,
              char const *ppszfmt,
              va_list     pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {

        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);

            // Chicago and Win32s debugging is usually through wdeb386
            // which needs carriage returns
#if WIN32 == 50 || WIN32 == 200
            w4dprintf("\r");
#endif
        }
    }
}



//  Private version of RtlAssert so debug versions really assert on free builds.

VOID PropAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    CHAR szMessage[ 512 ];
    int nResponse;

    sprintf( szMessage, "File:\t%s\nLine:\t%d\nMessage:\t%s\n"
                        "\nPress Abort to kill the process, Retry to debug",
             FileName, LineNumber, NULL == Message ? "" : Message );

    nResponse = MessageBoxA( NULL, szMessage, "Assertion failed in NT5Props.dll", MB_ABORTRETRYIGNORE );
    if( IDRETRY == nResponse )
        DebugBreak();
    else if( IDABORT == nResponse )
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );

    return;
    

    /*
    char Response[ 2 ] = { "B" };   // In MSDEV there is no input, so default to break

    for ( ; ; ) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

        DbgPrompt( "Break, Ignore, terminate Process, Sleep 30 seconds, or terminate Thread (bipst)? ",
                   Response, sizeof( Response));
        switch ( toupper(Response[0])) {
        case 'B':
            DbgBreakPoint();
            break;
        case 'I':
            return;
            break;
        case 'P':
            NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
            break;
        case 'S':
            Sleep( 30000L);
            break;
        case 'T':
            NtTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
            break;
        default:
            DbgBreakPoint();
            break;
        }
    }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
    */
}







void
InitializeDebugging()
{
    CHAR szValue[ 30 ];

    InitializeCriticalSection( &s_csMessageBuf );

    if (GetProfileStringA("CairOLE InfoLevels", // section
                          "prop",               // key
                          "3",                  // default value
                          szValue,              // return buffer
                          sizeof(szValue))) 
    {
        propInfoLevel = DEB_ERROR | DEB_WARN | strtoul (szValue, NULL, 16);
    }    

}

void
UnInitializeDebugging()
{
    DeleteCriticalSection( &s_csMessageBuf );
}





#endif // #if DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\nffdrt\main.cxx ===
#include "pch.hxx"

#include "tbtest.hxx"

#define OPEN     1
#define CREATE   2

extern "C" CLSID CLSID_ThumbnailUpdater;

EXTERN_C const IID IID_IFlatStorage = { /* b29d6138-b92f-11d1-83ee-00c04fc2c6d4 */
    0xb29d6138,
    0xb92f,
    0x11d1,
    {0x83, 0xee, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0xd4}
  };


void
Call_CreateUpdater(REFIID riid, void** ppv)
{
    HRESULT sc;

    sc = CoCreateInstance(CLSID_ThumbnailUpdater,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          riid,
                          ppv);
    if(FAILED(sc))
    {
        printf("CoCreateInstance of Thumbnaile Updater failed %x\n", sc);
        exit(0);
    }
}

HRESULT
Call_IFilterStatus(IFilterStatus *pIFS,
                 WCHAR * pwszFileName)
{
    HRESULT sc;

    sc = pIFS->PreFilter(pwszFileName);
    if(FAILED(sc))
    {
        printf("PreFilter returned %x\n", sc);
        exit(0);
    }
    return S_OK;
}

  
HRESULT
Call_CheckTime()
{
    FILETIME mtime, ctime, atime;
    DWORD rc;
    HANDLE hFile;

    hFile = CreateFile( g_tszFileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        printf("CheckTime File Open error %x\n", GetLastError());
        return S_OK;
    }

    if(!GetFileTime(hFile, &ctime, &atime, &mtime))
    {
        printf("GetFileTime Failed %x\n", GetLastError());
        exit(0);
    }
    CloseHandle(hFile);

    printf("file ctime=%x:%x, atime=%x:%x, mtime=%x:%x\n", ctime, atime, mtime);
    return S_OK;

}


IStorage *
Call_CreateOplockStorageFile(DWORD mode)
{
    IOplockStorage *pIOpStg;
    IStorage *pstg;

    HRESULT sc;

    Call_CreateUpdater(IID_IOplockStorage, (void**)&pIOpStg);

    switch(mode)
    {
    case CREATE:
        sc = pIOpStg->CreateStorageEx(
                        g_tszFileName,
                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        STGFMT_FILE,
                        0,
                        IID_IFlatStorage,
                        (void**)&pstg);
        break;

    case OPEN:
        sc = pIOpStg->OpenStorageEx(
                        g_tszFileName,
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        STGFMT_FILE,
                        0,
                        IID_IFlatStorage,
                        (void**)&pstg);
        break;

    default:
        printf("Bad file open mode\n");
        exit(0);
        break;
    }

    if(FAILED(sc))
    {
        printf("IOplockStorage::{Create/Open}StorageEx failed %x\n", sc);
        exit(0);
    }

    if(NULL != pIOpStg)
        pIOpStg->Release();

    return pstg;
}


IStorage *
Call_CreateStorageFile(DWORD mode)
{
    HRESULT hr;
    IStorage *pstg;
    DWORD stgfmt = STGFMT_FILE;

    if(g_AnyStorage)
        stgfmt = STGFMT_ANY;

    switch(mode)
    {
    case CREATE:
        hr = StgCreateStorageEx(
                g_tszFileName,
                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                stgfmt,
                0,0,0,
                IID_IFlatStorage,
                (void**)&pstg);
        break;

    case OPEN:
        hr = StgOpenStorageEx(
                g_tszFileName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                stgfmt,
                0,0,0,
                IID_IFlatStorage,
                (void**)&pstg);
        break;

    default:
        printf("Bad file open mode\n");
        exit(0);
        break;
    }

    
    if(FAILED(hr))
    {
        printf("Stg{Create/Open}StorageEx failed %x\n", hr);
        exit(0);
    }
    return pstg;
}

CLSID CLSID_JunkClassFile = { /* ce8103fd-905b-11d1-83eb-00c04fc2c6d4 */
    0xce8103fd,
    0x905b,
    0x11d1,
    {0x83, 0xeb, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0xd4}
};


void
Call_SetClass(IStorage *pstg)
{
    HRESULT sc;

    sc = pstg->SetClass(CLSID_JunkClassFile);
    if(FAILED(sc))
    {
        printf("SetClass Failed %x\n", sc);
        exit(0); 
    }
}

void
Call_Stat(
        IStorage *pstg,
        STATSTG *pstat)
{
    HRESULT sc;

    sc = pstg->Stat(pstat, 0);
    if(FAILED(sc))
    {
        printf("Stat failed %x\n");
        exit(0);
    }
    printf("Pathname is: %ws\n", pstat->pwcsName);
    if( IsEqualGUID(pstat->clsid, CLSID_JunkClassFile) )
        printf("Class GUID is OK\n");
    else if( IsEqualGUID(pstat->clsid, CLSID_NULL) )
        printf("Class GUID is NULL_CLSID\n");
    else
        printf("Class GUID is not the JunkClassGuid!!\n");
}

void
Call_QI(IUnknown *punk, REFIID riid, void **pv)
{
    HRESULT hr;

    hr = punk->QueryInterface(riid, pv);
    if(FAILED(hr))
    {
        printf("QI failed %x\n", hr);
        exit(0);
    }
}

IStream *
Call_OpenStream(IStorage *pstg, DWORD grfMode, int num)
{
    WCHAR name[80];
    IStream *pstm;
    HRESULT hr;

    wsprintf(name, L"%02d", num);


    if(grfMode & STGM_CREATE)
    {
        hr = pstg->CreateStream(name, grfMode|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    }
    else
    {
        hr = pstg->OpenStream(name, 0, grfMode|STGM_SHARE_EXCLUSIVE, 0, &pstm);
    }
        
    if(FAILED(hr))
    {
        printf("CreateStream(%s) failed %x\n", name, hr);
        exit(0);
    }
    return pstm;
}

IStream *
Call_OpenCONTENTSStream(IStorage *pstg)
{
    IStream *pstm;
    HRESULT hr;

    hr = pstg->OpenStream(L"CONTENTS", 0,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            0,
            &pstm);
    
    if(FAILED(hr) || NULL == pstm)
    {
        printf("OpenContentStream failed %x\n", hr);
        exit(0);
    }
    return pstm;
}



IPropertyStorage *
Call_OpenPropStg(IStorage *pstg, DWORD mode, REFFMTID fmtid )
{
    IPropertySetStorage *ppropsetstg = NULL;
    IPropertyStorage *ppropstg = NULL;
    HRESULT hr = S_OK;

    hr = pstg->QueryInterface( IID_IPropertySetStorage, (void**)&ppropsetstg );
    if( FAILED(hr) )
    {
        printf( "QI for IPropertySetStorage failed %x\n", hr );
        exit(0);
    }

    switch(mode)
    {
    case CREATE:
        hr = ppropsetstg->Create(fmtid, NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                &ppropstg );
        break;

    case OPEN:
        hr = ppropsetstg->Open(fmtid,
                               STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                               &ppropstg );
        break;
        
    default:
        printf("Bad file open mode\n");
        exit(0);
        break;
    }
    if(FAILED(hr))
    {
        printf("OpenPropStg failed %x\n", hr);
        exit(0);
    }

    if( NULL != ppropsetstg )
        ppropsetstg->Release();

    return ppropstg;
}




void 
Call_SuppressChanges(ITimeAndNoticeControl *ptnc)
{
    HRESULT hr;

    hr = ptnc->SuppressChanges(0, 0);
    if(FAILED(hr))
    {
        printf("SuppressChanges failed %x\n", hr);
        exit(0);
    }
    printf("--------SuppressChanges called\n");
}

void
TestPause(char * sz)
{
    if(g_Pause)
    {
        printf("Before %s: press <return> to continue.", sz);
        getchar();
    }
}
    
EXTERN_C void
__cdecl
wmain(
        int argc,
        WCHAR **argv)
{
    IStorage *pstg=NULL;
    ITimeAndNoticeControl *ptnc=NULL;
    IFilterStatus *pIFS=NULL;
    DWORD fOpenMode;
    STATSTG stat;
    LONG cRefs;


    CoInitialize(NULL);

    ParseArgs(argc, argv);

    if(g_CheckTime)
        Call_CheckTime();

    if(g_CheckIsStg)
        printf("StgIsStorageFile = %x\n", StgIsStorageFile(g_tszFileName));

    if(g_UseUpdater)
    {
        Call_CreateUpdater(IID_IFilterStatus, (void**)&pIFS);
        Call_IFilterStatus(pIFS, g_tszFileName);
        pIFS->Release();

    }
    else if(!g_NoOpenStg)
    {
        if(g_CreateStg)
            fOpenMode = CREATE;
        else
            fOpenMode = OPEN;
    
        if(g_OplockFile)
            pstg = Call_CreateOplockStorageFile(fOpenMode);
        else
            pstg = Call_CreateStorageFile(fOpenMode);
    
        if(g_AddRefStg)
        {
            pstg->AddRef();
            pstg->Release();
        }

        if(g_SuppressTime)
        {
            Call_QI(pstg, IID_ITimeAndNoticeControl, (void**)&ptnc);
            Call_SuppressChanges(ptnc);
            ptnc->Release();
        }
    
        if(g_SetClass)
            Call_SetClass(pstg);
    
        if(g_Stat)
            Call_Stat(pstg, &stat);

        TestPause("OpenStream");

        if(!g_NoOpenStm)
        {
            char readBuffer[1024];
            ULONG cb, cbXfred;
            IStream *pstm=NULL;
            IStream *pstmContents=NULL;
            IPropertyStorage *ppropstg=NULL;
            PROPSPEC propspec;
            PROPVARIANT propvar;
            HRESULT hr;
    
            if(g_CreateStm)
            {
                pstm = Call_OpenStream(pstg, STGM_CREATE|STGM_READWRITE, 1);
                ppropstg = Call_OpenPropStg(pstg, CREATE, FMTID_SummaryInformation);
            }
            else
            {
                pstm = Call_OpenStream(pstg, STGM_READWRITE, 1);
                pstmContents = Call_OpenCONTENTSStream(pstg);
                ppropstg = Call_OpenPropStg(pstg, OPEN, FMTID_SummaryInformation);
            }
    
            if(g_AddRefStm)
            {
                pstm->AddRef();
                pstm->Release();
            }
    
            if( g_ReleaseStg )
            {
                pstg->Release();
                pstg = NULL;
            }
    
            if(g_WriteStm)
            {
                TestPause("WriteStream");

                hr = pstm->Write((void*)"First ", 6, &cbXfred);
                if(FAILED(hr))
                {
                    printf("First Write Failed with %x\n", hr);
                    exit(0);
                }
                hr = pstm->Write((void*)"Second", 6, &cb);
                if(FAILED(hr))
                {
                    printf("Second Write Failed with %x\n", hr);
                    exit(0);
                }
                printf("Wrote %d bytes, in two pieces\n", cbXfred+cb);

                propspec.ulKind = PRSPEC_PROPID;
                propspec.propid = PIDSI_TITLE;
                propvar.vt = VT_LPSTR;
                propvar.pszVal = "My Title";
                
                hr = ppropstg->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE );
                if(FAILED(hr))
                {
                    printf( "First WriteMultiple failed with %x\n", hr );
                    exit(0);
                }

                propspec.propid = PIDSI_COMMENTS;
                propvar.pszVal = "My Comments";

                hr = ppropstg->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE );
                if(FAILED(hr))
                {
                    printf( "Second WriteMultiple failed with %x\n", hr );
                    exit(0);
                }

                printf("Wrote two properties\n");

            }
            if(g_ReadStm)
            {
                TestPause("ReadStream");

                hr = pstm->Read((void*)readBuffer, sizeof(readBuffer), &cbXfred);
                if(FAILED(hr))
                {
                    printf("Read Failed with %x\n", hr);
                    exit(0);
                }
                readBuffer[cbXfred] = '\0';
                printf("Read %d bytes: \"%s\"\n", cbXfred, readBuffer);

                propspec.ulKind = PRSPEC_PROPID;
                propspec.propid = PIDSI_TITLE;

                hr = ppropstg->ReadMultiple( 1, &propspec, &propvar );
                if(FAILED(hr))
                {
                    printf("ReadMultiple failed with %x\n", hr );
                    exit(0);
                }

                printf("ReadMultiple the title:  \"%s\"\n", propvar.pszVal );
                PropVariantClear(&propvar);
            }
    
            if(NULL != pstm)
            {
                if( 0 != (cRefs = pstm->Release()))
                    printf("Last release of the Stream and still %d References!!\n", cRefs);
                pstm = NULL;
            }

            if(NULL != pstmContents)
            {
                if(0 != (cRefs = pstmContents->Release()))
                    printf("Last release of the PropertyStorage and still %d References!!\n", cRefs);
                pstmContents = NULL;
            }

            if(NULL != ppropstg)
            {
                if(0 != (cRefs = ppropstg->Release()))
                    printf("Last release of the PropertyStorage and still %d References!!\n", cRefs);
                ppropstg = NULL;
            }
        }
        
        if(NULL != pstg)
        {
            TestPause("Last Release");
            if(0 != (cRefs = pstg->Release()))
            {
                printf("Last release of the Storage and still %d References!!\n", cRefs);
            }
            pstg = NULL;
        }

    }

    if(g_CheckTime)
        Call_CheckTime();

    CoUninitialize();

    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\cpropvar.cxx ===
#include "pch.cxx"

#include "CPropVar.hxx"
#include "CHResult.hxx"
#include <stdio.h>
#include <tchar.h>


// Declare this prototype here, for now.  For non-Mac, the prototype
// in "iofs.h" uses C decorations, but the definition in
// ntpropb.cxx uses C++.

#ifdef _MAC_NODOC
EXTERN_C BOOLEAN
#else
BOOLEAN __declspec(dllimport) __stdcall
#endif
RtlCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2);




/*
CPropVariant::InitializeVector(
    VARENUM v,
    ULONG cElements)
{
    ULONG cbElement;
    BOOLEAN fZero = FALSE;

    // Ignore vector flag.  This constructor is always for vectors only.

    vt = v | VT_VECTOR;

    switch (vt)
    {
    case VT_VECTOR | VT_UI1:
        cbElement = sizeof(caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cbElement = sizeof(cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cbElement = sizeof(cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cbElement = sizeof(cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        cbElement = sizeof(GUID);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_CF:
        cbElement = sizeof(CLIPDATA);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
        cbElement = sizeof(VOID *);
        fZero = TRUE;
        break; 

    case VT_VECTOR | VT_VARIANT:
        cbElement = sizeof(PROPVARIANT);
        ASSERT(VT_EMPTY == 0);
        fZero = TRUE;
        break;

    default:
        ASSERT(!"CAllocStorageVariant -- Invalid vector type");
        vt = VT_EMPTY;
        break;
    }
    if (vt != VT_EMPTY)
    {
        caub.cElems = 0;
        caub.pElems = (BYTE *) CoTaskMemAlloc(cElements * cbElement);
        if (caub.pElems != NULL)
        {
            if (fZero)
            {
                memset(caub.pElems, 0, cElements * cbElement);
            }
            caub.cElems = cElements;
        }
    }
}
*/


VOID *
CPropVariant::_AddStringToVector(
    unsigned pos,
    const VOID *pv,
    ULONG cb,
    VARTYPE vtNew )
{
    vtNew |= VT_VECTOR;

    ASSERT(vtNew == (VT_VECTOR | VT_BSTR)   ||
           vtNew == (VT_VECTOR | VT_LPSTR)  ||
           vtNew == (VT_VECTOR | VT_LPWSTR) ||
           vtNew == (VT_VECTOR | VT_CF) );
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) CoTaskMemAlloc((pos + 1) * sizeof(calpstr.pElems[0]));
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(NULL);
        }

        if( NULL != ppsz )
            memcpy(calpstr.pElems, ppsz, calpstr.cElems * sizeof(calpstr.pElems[0]));

        memset(
            &calpstr.pElems[calpstr.cElems],
            0,
            ((pos + 1) - calpstr.cElems) * sizeof(calpstr.pElems[0]));

        calpstr.cElems = pos + 1;
        CoTaskMemFree(ppsz);
    }

    LPSTR psz;

    if( (VT_VECTOR | VT_BSTR) == vtNew )
    {
        if( NULL == pv )
        {
            psz = NULL;
        }
        else
        {
            psz = (LPSTR) SysAllocString( (BSTR) pv );
            if (psz == NULL)
            {
                return(NULL);
            }
        }

        if (calpstr.pElems[pos] != NULL)
        {
            SysFreeString((BSTR) calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }
    else
    {
        if( NULL == pv )
        {
            psz = NULL;
        }
        else
        {
            psz = (LPSTR) CoTaskMemAlloc((VT_BSTR == (vtNew & ~VT_VECTOR) )
                                           ? cb + sizeof(ULONG)
                                           : cb );
            if (psz == NULL)
            {
                return(NULL);
            }

            memcpy(psz, pv, cb);
        }

        if (calpstr.pElems[pos] != NULL)
        {
            CoTaskMemFree(calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }


    return(calpstr.pElems[pos]);
}


VOID *
CPropVariant::_AddScalerToVector(
    unsigned pos,
    const VOID *pv,
    ULONG cb)
{
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) CoTaskMemAlloc((pos + 1) * cb);
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(NULL);
        }

        memset(
            calpstr.pElems,
            0,
            ((pos + 1) - calpstr.cElems) * cb);

        if( NULL != ppsz )
            memcpy(calpstr.pElems, ppsz, calpstr.cElems * cb);

        calpstr.cElems = pos + 1;
        CoTaskMemFree(ppsz);
    }


    memcpy( (BYTE*)calpstr.pElems + pos*cb, pv, cb );
    return( (BYTE*)calpstr.pElems + pos*cb );

}



void
CPropVariant::SetCF(
    const CLIPDATA *pclipdata,
    ULONG pos)
{
    CLIPDATA *pclipdataNew;

    if (vt != (VT_VECTOR | VT_CF))
	{
		Clear();
		vt = VT_VECTOR | VT_CF;
	}

    pclipdataNew = (CLIPDATA*) _AddScalerToVector(pos, (VOID *) pclipdata, sizeof(CLIPDATA) );

    if( NULL != pclipdataNew
        &&
        NULL != pclipdata )
    {
        pclipdataNew->pClipData = (BYTE*) CoTaskMemAlloc( CBPCLIPDATA(*pclipdata) );
        if( NULL == pclipdataNew->pClipData )
        {
            ASSERT( !"Couldn't allocate pclipdataNew" );
            return;
        }
        else
        {
            pclipdataNew->cbSize = pclipdata->cbSize;
            pclipdataNew->ulClipFmt = pclipdata->ulClipFmt;

            memcpy( pclipdataNew->pClipData,
                    pclipdata->pClipData,
                    CBPCLIPDATA(*pclipdata) );
            return;
        }
    }
}


void
CPropVariant::SetBSTR(
    const BSTR posz,
    ULONG pos)
{
    ULONG cch;

    if( vt != (VT_BSTR | VT_VECTOR) ) Clear();

    if( NULL == posz )
        cch = 0;
    else
        cch = ocslen(posz) + 1;

    if (vt != (VT_VECTOR | VT_BSTR))
        Clear();

    _AddStringToVector(pos, (VOID *) posz,
                       sizeof(OLECHAR) * cch, VT_BSTR );

    vt = VT_BSTR | VT_VECTOR;
}




CPropVariant & CPropVariant::operator =(PROPVARIANT &propvar)
{
    if( INVALID_SUBSCRIPT == wReserved1 )
    {
        throw CHRESULT( (HRESULT) E_FAIL, OLESTR("Attempt to assign a singleton VT_VARIANT") );
        return (*this);
    }
    else
    {
        if( !(vt & VT_VECTOR)
            ||
            (vt & ~VT_VECTOR) != VT_VARIANT )
        {
            USHORT wReserved1Save = wReserved1;
            Clear();
            wReserved1 = wReserved1Save;
        }

        Set( VT_VARIANT | VT_VECTOR, (void*) &propvar, wReserved1 - 1 );
        wReserved1 = INVALID_SUBSCRIPT;
        return (*this);
    }
}
        

void
CPropVariant::SetPROPVARIANT( PROPVARIANT &propvar, ULONG pos )
{
    if( vt != (VT_VARIANT | VT_VECTOR) ) Clear();

    if (pos >= capropvar.cElems)
    {
        LPPROPVARIANT rgpropvar = capropvar.pElems;

        capropvar.pElems =
            (PROPVARIANT *) CoTaskMemAlloc((pos + 1) * sizeof(capropvar.pElems[0]));
        if (capropvar.pElems == NULL)
        {
            capropvar.pElems = rgpropvar;
            return;
        }

        if( NULL != rgpropvar )
            memcpy(capropvar.pElems, rgpropvar, capropvar.cElems * sizeof(capropvar.pElems[0]));

        memset(
            &capropvar.pElems[capropvar.cElems],
            0,
            ((pos + 1) - capropvar.cElems) * sizeof(capropvar.pElems[0]));
        capropvar.cElems = pos + 1;
        CoTaskMemFree(rgpropvar);
    }

    PropVariantClear( &capropvar.pElems[pos] );
    PropVariantCopy( &capropvar.pElems[pos], &propvar );

    vt = VT_VARIANT | VT_VECTOR;

    return;

}


void
CPropVariant::SetCF(const CLIPDATA *p)
{
    Clear();

    if( NULL == p )
        return;

    pclipdata = (CLIPDATA*) CoTaskMemAlloc( sizeof(CLIPDATA) );
    if( NULL == pclipdata )
    {
        return;
    }

    pclipdata->cbSize = p->cbSize;
    pclipdata->ulClipFmt = p->ulClipFmt;
    pclipdata->pClipData = NULL;

    if( sizeof(pclipdata->ulClipFmt) > p->cbSize )
    {
        throw CHRESULT( (HRESULT) E_FAIL, OLESTR("Invalid input CLIPDATA*") );
        return;
    }


    if( NULL != p->pClipData )
    {
        pclipdata->pClipData = (BYTE*) CoTaskMemAlloc( pclipdata->cbSize
                                                      - sizeof(pclipdata->ulClipFmt) );
        if( NULL == pclipdata->pClipData )
            return;

        memcpy( pclipdata->pClipData, p->pClipData, pclipdata->cbSize - sizeof(pclipdata->ulClipFmt) );
    }

    vt = VT_CF;

}

void
CPropVariant::SetCLSID( const CLSID *pclsid )
{
    Clear();

    puuid = (CLSID*) CoTaskMemAlloc( sizeof(CLSID) );
    if( NULL == puuid )
        throw CHRESULT( (HRESULT) E_OUTOFMEMORY, OLESTR("CPropVariant::SetCLSID couldn't alloc a new CLSID") );

    *puuid = *pclsid;
    vt = VT_CLSID;
}


void
CPropVariant::SetCLSID(
    const CLSID *pclsid,
    unsigned pos)
{
    CLSID *pclsidNew;

    if (vt != (VT_VECTOR | VT_CLSID))
	{
		Clear();
		vt = VT_VECTOR | VT_CLSID;
	}

    pclsidNew = (CLSID*) _AddScalerToVector(pos, (const VOID *) pclsid, sizeof(CLSID) );

    if( NULL != pclsidNew )
    {
        *pclsidNew = *pclsid;
    }
}

#define COMPARE_CHUNK_SIZE      4096

//+----------------------------------------------------------------------------
//
//  CPropVariant::Compare
//
//  Compare two CPropVariants.  This routine defers to the RtlCompareVariants
//  for most types.  Types not supported by that routine are handled here.
//
//+----------------------------------------------------------------------------

HRESULT
CPropVariant::Compare( PROPVARIANT *ppropvar1, PROPVARIANT *ppropvar2 )
{
    HRESULT hr = S_OK;

    VARTYPE vt1 = ppropvar1->vt;
    IStream *pStream1 = NULL, *pStream2 = NULL;
    BYTE *prgb1 = NULL, *prgb2 = NULL;
    CLargeInteger liCurrentSeek;

    switch( vt1 )
    {
    case VT_VERSIONED_STREAM:

        if( ppropvar1->pVersionedStream == NULL && ppropvar2->pVersionedStream == NULL )
            return( S_OK );
        else if( ppropvar1->pVersionedStream == NULL || ppropvar2->pVersionedStream == NULL )
            return( S_FALSE );
        else if( ppropvar1->pVersionedStream->guidVersion != ppropvar2->pVersionedStream->guidVersion )
            return( S_FALSE );

        pStream1 = ppropvar1->pVersionedStream->pStream;
        pStream2 = ppropvar2->pVersionedStream->pStream;

        // Fall through

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
        {
            // Note:  This comparisson effects the seek pointers, though
            // barring error they are restored on completion.

            STATSTG statstg1, statstg2;
            CULargeInteger uliSeek1, uliSeek2;

            if( NULL == pStream1 )
            {
                ASSERT( NULL == pStream2 );
                pStream1 = ppropvar1->pStream;
                pStream2 = ppropvar2->pStream;
            }

            if( ppropvar1->vt != ppropvar2->vt
                ||
                NULL == pStream1 && NULL != pStream2
                ||
                NULL != pStream1 && NULL == pStream2 )
            {
                return( S_FALSE );
            }

            hr = pStream1->Stat( &statstg1, STATFLAG_NONAME );
            if( FAILED(hr) ) goto Exit;
            hr = pStream2->Stat( &statstg2, STATFLAG_NONAME );
            if( FAILED(hr) ) goto Exit;

            if( CULargeInteger(statstg1.cbSize) != CULargeInteger(statstg2.cbSize) )
                return( S_FALSE );

            prgb1 = new BYTE[ COMPARE_CHUNK_SIZE ];
            if( NULL == prgb1 )
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            prgb2 = new BYTE[ COMPARE_CHUNK_SIZE ];
            if( NULL == prgb2 )
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            hr = pStream1->Seek( CLargeInteger(0), STREAM_SEEK_CUR, &uliSeek1 );
            if( FAILED(hr) ) goto Exit;
            hr = pStream2->Seek( CLargeInteger(0), STREAM_SEEK_CUR, &uliSeek2 );
            if( FAILED(hr) ) goto Exit;

            liCurrentSeek = CLargeInteger(0);

            CULargeInteger cbRemaining = statstg1.cbSize;
            while( cbRemaining > 0 )
            {
                ULONG cbRead1 = 0, cbRead2 = 0;

                hr = pStream1->Seek( liCurrentSeek, STREAM_SEEK_SET, NULL );
                if( FAILED(hr) ) goto Exit;

                hr = pStream1->Read( prgb1, COMPARE_CHUNK_SIZE, &cbRead1 );
                if( FAILED(hr) ) goto Exit;

                hr = pStream2->Seek( liCurrentSeek, STREAM_SEEK_SET, NULL );
                if( FAILED(hr) ) goto Exit;

                hr = pStream2->Read( prgb2, COMPARE_CHUNK_SIZE, &cbRead2 );
                if( FAILED(hr) ) goto Exit;

                if( cbRead1 != cbRead2 )
                {
                    hr = STG_E_READFAULT;
                    goto Exit;
                }

                if( memcmp( prgb1, prgb2, cbRead1 ) )
                {
                    hr = S_FALSE;
                    goto Exit;
                }

                liCurrentSeek += cbRead1;
                cbRemaining -= cbRead1;
            }

            hr = pStream1->Seek( static_cast<CLargeInteger>(uliSeek1), STREAM_SEEK_SET, NULL );
            if( FAILED(hr) ) goto Exit;

            hr = pStream2->Seek( static_cast<CLargeInteger>(uliSeek2), STREAM_SEEK_SET, NULL );
            if( FAILED(hr) ) goto Exit;

            hr = S_OK;
            goto Exit;

        }


    case VT_STORAGE:
    case VT_STORED_OBJECT:
        {

            if( ppropvar1->vt == ppropvar2->vt
                &&
                ( NULL == ppropvar1->vt
                  &&
                  NULL == ppropvar2->vt
                  ||
                  NULL != ppropvar1->vt
                  &&
                  NULL != ppropvar2->vt
                )
              )
            {
                return( S_OK );
            }
            else
            {
                return( S_FALSE );
            }
        }
        break;

    default:

        // For SafeArrays we just check the structure, not the data.

        if( VT_ARRAY & vt1 )
        {
            if( ppropvar1->vt != ppropvar2->vt 
                ||
                ppropvar1->parray->cDims != ppropvar2->parray->cDims
                ||
                SafeArrayGetElemsize(ppropvar1->parray) != SafeArrayGetElemsize(ppropvar2->parray) )
            {
                return (HRESULT) S_FALSE;
            }
            else
            {
                return (HRESULT) S_OK;
            }

        }
        else if( PropTestCompareVariants( CP_ACP,     // Ignored,
                                          ppropvar1,
                                          ppropvar2 ))
        {
            return( (HRESULT) S_OK );
        }
        else
        {
            return( (HRESULT) S_FALSE );
        }
        break;
    }

Exit:

    if( NULL != prgb1 )
        delete[] prgb1;
    if( NULL != prgb2 )
        delete[] prgb2;

    return( hr );
}


void
CPropVariant::Set( VARTYPE vtSet, void *pv, ULONG pos )
{
    BOOL fVector = (vtSet & VT_VECTOR) ? TRUE : FALSE;


    switch( vtSet & ~VT_VECTOR )
    {
        case VT_I1:

            if( fVector )
                SetI1( *(CHAR*) pv, pos );
            else
                SetI1( *(CHAR*) pv );

            break;

        case VT_UI1:

            if( fVector )
                SetUI1( *(UCHAR*) pv, pos );
            else
                SetUI1( *(UCHAR*) pv );

            break;

        case VT_I2:

            if( fVector )
                SetI2( *(short*) pv, pos );
            else
                SetI2( *(short*) pv );

            break;

        case VT_UI2:

            if( fVector )
                SetUI2( *(USHORT*) pv, pos );
            else
                SetUI2( *(USHORT*) pv );

            break;

        case VT_BOOL:

            if( fVector )
                SetBOOL( *(VARIANT_BOOL*) pv, pos );
            else
                SetBOOL( *(VARIANT_BOOL*) pv );

            break;

        case VT_I4:

            if( fVector )
                SetI4( *(long*) pv, pos );
            else
                SetI4( *(long*) pv );
            break;

        case VT_UI4:

            if( fVector )
                SetUI4( *(ULONG*) pv, pos );
            else
                SetUI4( *(ULONG*) pv );

            break;

        case VT_R4:

            if( fVector )
                SetR4( *(float*) pv, pos );
            else
                SetR4( *(float*) pv );

            break;

        case VT_ERROR:

            if( fVector )
                SetERROR( *(SCODE*) pv, pos );
            else
                SetERROR( *(SCODE*) pv );

            break;

        case VT_I8:

            if( fVector )
                SetI8( *(LARGE_INTEGER*) pv, pos );
            else
                SetI8( *(LARGE_INTEGER*) pv );
            break;

        case VT_UI8:

            if( fVector )
                SetUI8( *(ULARGE_INTEGER*) pv, pos );
            else
                SetUI8( *(ULARGE_INTEGER*) pv );

            break;

        case VT_R8:

            if( fVector )
                SetR8( *(double*) pv, pos );
            else
                SetR8( *(double*) pv );

            break;

        case VT_CY:

            if( fVector )
                SetCY( *(CY*) pv, pos );
            else
                SetCY( *(CY*) pv );

            break;

        case VT_DATE:

            if( fVector )
                SetDATE( *(DATE*) pv, pos );
            else
                SetDATE( *(DATE*) pv );

            break;

        case VT_FILETIME:

            if( fVector )
                SetFILETIME( *(FILETIME*) pv, pos );
            else
                SetFILETIME( *(FILETIME*) pv );

            break;

        case VT_CLSID:

            if( fVector )
                SetCLSID( *(CLSID*) pv, pos );
            else
                SetCLSID( *(CLSID*) pv );

            break;

        case VT_BLOB:

            ASSERT( !fVector );
            SetBLOB( *(BLOB*) pv );
            break;

        case VT_CF:

            if( fVector )
                SetCF( *(CLIPDATA**) pv, pos );
            else
                SetCF( *(CLIPDATA**) pv );
            
            break;

        case VT_STREAM:

            ASSERT( !fVector );
            SetSTREAM( *(IStream**) pv );
            break;

        case VT_STORAGE:

            ASSERT( !fVector );
            SetSTORAGE( *(IStorage**) pv );
            break;

        case VT_BSTR:

            if( fVector )
                SetBSTR( *(BSTR*) pv, pos );
            else
                SetBSTR( *(BSTR*) pv );

            break;

        case VT_LPSTR:

            if( fVector )
                SetLPSTR( *(LPSTR*) pv, pos );
            else
                SetLPSTR( *(LPSTR*) pv );

            break;

        case VT_LPWSTR:

            if( fVector )
                SetLPWSTR( *(LPWSTR*) pv, pos );
            else
                SetLPWSTR( *(LPWSTR*) pv );

            break;

        case VT_VARIANT:

            if( !fVector )
                throw CHRESULT( E_FAIL, OLESTR("CPropVariant::Set - attempt to set a singleton VT_VARIANT") );

            SetPROPVARIANT( *(PROPVARIANT*) pv, pos );

            break;

        case VT_DECIMAL:

            ASSERT( !fVector );
            SetDECIMAL( *(DECIMAL*) pv );
            break;

        default:

            ASSERT(0);
            throw CHRESULT( (HRESULT) E_FAIL, OLESTR("CPropVariant::Set invalid type") );

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\prpsetup\makefile.inc ===
############################################################################
#
#   Copyright (C) 1996-1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################
##
## Special MakeFile instructions for the IProp Setup
## (PrpSetup) utility
##
## This makefile compiles the resources.  Ordinarily,
## you cause the resources to be compiled by including
## the .rc file in your SOURCES macro.  This, however,
## compiles the .rc file during pass 1.  But our .rc
## file uses iprop.dll, which doesn't exist until pass 2.
## So, we don't include the .rc file in SOURCES, and
## we add all the necessary rules for building it here.
##

#
# Make sure we're not here on passes 0/1
#

!IF "$(NOLINK)" != ""
!ERROR *** PrpSetup makefile.inc included in pass 0/1
!ENDIF

#
# Make the exe file dependent on the res file.
#

$(TARGET) : $O\prpsetup.res

#
# Show how what resources need to be compiled.
#

$O\prpsetup.res : .\prpsetup.rc

# Show that the RC file should be re-compiled if the compressed
# DLL is updated.

prpsetup.rc : iprop.dl_

# Show how to build the compressed IProp DLL file

iprop.dl_ : $(_NTTREE)\iprop.dll
   @echo Compressing - $** to $@ > con:
   compress $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\propdump.cxx ===
//+============================================================================
//
//  File:   PropDump.cxx
//
//  Purpose:
//          This file contains routines to dump all the properties of all
//          the property sets of a DocFile.  It's started by calling
//          DumpOleStorage().
//
//+============================================================================

//  --------
//  Includes
//  --------

#include "pch.cxx"


//  -------
//  Globals
//  -------

OLECHAR *oszDays[] =
{
    OLESTR("Sun"),
    OLESTR("Mon"),
    OLESTR("Tue"),
    OLESTR("Wed"),
    OLESTR("Thu"),
    OLESTR("Fri"),
    OLESTR("Sat")
};

OLECHAR *oszMonths[] =
{
    OLESTR("Jan"), OLESTR("Feb"), OLESTR("Mar"), OLESTR("Apr"), OLESTR("May"), OLESTR("Jun"),
    OLESTR("Jul"), OLESTR("Aug"), OLESTR("Sep"), OLESTR("Oct"), OLESTR("Nov"), OLESTR("Dec")
};


//+----------------------------------------------------------------------------
//+----------------------------------------------------------------------------

OLECHAR *
oszft(FILETIME *pft)
{
    static OLECHAR oszbuf[32];

#ifdef _MAC

    soprintf( oszbuf, OLESTR("%08X-%08X"), pft->dwHighDateTime, pft->dwLowDateTime );

#else

    FILETIME ftlocal;
    SYSTEMTIME st;

    oszbuf[0] = '\0';
    if (pft->dwHighDateTime != 0 || pft->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(pft, &ftlocal) ||
            !FileTimeToSystemTime(&ftlocal, &st))
        {
            return(OLESTR("Time???"));
        }
        soprintf(
            oszbuf,
            OLESTR("%s %s %2d %2d:%02d:%02d %4d"),
            oszDays[st.wDayOfWeek],
            oszMonths[st.wMonth - 1],
            st.wDay,
            st.wHour,
            st.wMinute,
            st.wSecond,
            st.wYear);
    }

#endif

    return(oszbuf);
}


VOID
DumpTime(OLECHAR *pozname, FILETIME *pft)
{
    LARGE_INTEGER UNALIGNED *pli = (LARGE_INTEGER UNALIGNED *) pft;

    ASYNC_PRINTF(
	"%s%08lx:%08lx%hs%s\n",
	pozname,
	pli->HighPart,
	pli->LowPart,
	pli->QuadPart == 0? g_szEmpty : " - ",
	oszft((FILETIME *) pft));
}


VOID
PrintGuid(GUID *pguid)
{
    ASYNC_PRINTF(
        "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        pguid->Data1,
        pguid->Data2,
        pguid->Data3,
        pguid->Data4[0],
        pguid->Data4[1],
        pguid->Data4[2],
        pguid->Data4[3],
        pguid->Data4[4],
        pguid->Data4[5],
        pguid->Data4[6],
        pguid->Data4[7]);
}


VOID
ListPropSetHeader(
    STATPROPSETSTG *pspss,
    OLECHAR *poszName)
{
    BOOLEAN fDocumentSummarySection2;
    OLECHAR oszStream[CCH_PROPSETSZ];

    fDocumentSummarySection2 = (BOOLEAN)
	memcmp(&pspss->fmtid, &FMTID_UserDefinedProperties, sizeof(GUID)) == 0;

    ASYNC_PRINTF(" Property set ");
    PrintGuid(&pspss->fmtid);

    RtlGuidToPropertySetName(&pspss->fmtid, oszStream);

    ASYNC_OPRINTF(
	OLESTR("\n  %hs Name %s"),
	(pspss->grfFlags & PROPSETFLAG_NONSIMPLE)?
	    "Embedding" : "Stream",
	oszStream);
    if (poszName != NULL || fDocumentSummarySection2)
    {
	ASYNC_OPRINTF(
	    OLESTR(" (%s)"),
	    poszName != NULL? poszName : OLESTR("User defined properties"));
    }
    ASYNC_PRINTF("\n");

    if (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)
    {
	DumpTime(OLESTR("  Create Time "), &pspss->ctime);
    }
    DumpTime(OLESTR("  Modify Time "), &pspss->mtime);
    if (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)
    {
	DumpTime(OLESTR("  Access Time "), &pspss->atime);
    }
}




typedef enum _PUBLICPROPSET
{
    PUBPS_UNKNOWN = 0,
    PUBPS_SUMMARYINFO = 3,
    PUBPS_DOCSUMMARYINFO = 4,
    PUBPS_USERDEFINED = 5,
} PUBLICPROPSET;


#define BSTRLEN(bstrVal)      *((ULONG *) bstrVal - 1)
ULONG
SizeProp(PROPVARIANT *pv)
{
    ULONG j;
    ULONG cbprop = 0;

    switch (pv->vt)
    {
    default:
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_UI1:
        cbprop = sizeof(pv->bVal);
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        cbprop = sizeof(pv->iVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        cbprop = sizeof(pv->lVal);
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        cbprop = sizeof(pv->hVal);
        break;

    case VT_CLSID:
        cbprop = sizeof(*pv->puuid);
        break;

    case VT_BLOB_OBJECT:
    case VT_BLOB:
        cbprop = pv->blob.cbSize + sizeof(pv->blob.cbSize);
        break;

    case VT_CF:
        cbprop = sizeof(pv->pclipdata->cbSize) +
                 pv->pclipdata->cbSize;
        break;

    case VT_BSTR:
	// count + string
	cbprop = sizeof(ULONG);
	if (pv->bstrVal != NULL)
	{
	    cbprop += BSTRLEN(pv->bstrVal);
	}
	break;

    case VT_LPSTR:
	// count + string + null char
	cbprop = sizeof(ULONG);
	if (pv->pszVal != NULL)
	{
	    cbprop += strlen(pv->pszVal) + 1;
	}
	break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_LPWSTR:
	// count + string + null char
	cbprop = sizeof(ULONG);
	if (pv->pwszVal != NULL)
	{
	    cbprop += sizeof(pv->pwszVal[0]) * (wcslen(pv->pwszVal) + 1);
	}
	break;

    //  vectors
    case VT_VECTOR | VT_UI1:
        cbprop = sizeof(pv->caub.cElems) +
             pv->caub.cElems * sizeof(pv->caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cbprop = sizeof(pv->cai.cElems) +
             pv->cai.cElems * sizeof(pv->cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cbprop = sizeof(pv->cal.cElems) +
             pv->cal.cElems * sizeof(pv->cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cbprop = sizeof(pv->cah.cElems) +
             pv->cah.cElems * sizeof(pv->cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        cbprop = sizeof(pv->cauuid.cElems) +
             pv->cauuid.cElems * sizeof(pv->cauuid.pElems[0]);
        break;

    case VT_VECTOR | VT_CF:
        cbprop = sizeof(pv->caclipdata.cElems);
        for (j = 0; j < pv->caclipdata.cElems; j++)
        {
            cbprop += sizeof(pv->caclipdata.pElems[j].cbSize) +
                      DwordAlign(pv->caclipdata.pElems[j].cbSize);
        }
        break;

    case VT_VECTOR | VT_BSTR:
	cbprop = sizeof(pv->cabstr.cElems);
	for (j = 0; j < pv->cabstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->cabstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(BSTRLEN(pv->cabstr.pElems[j]));
	    }
	}
	break;

    case VT_VECTOR | VT_LPSTR:
	cbprop = sizeof(pv->calpstr.cElems);
	for (j = 0; j < pv->calpstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->calpstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(strlen(pv->calpstr.pElems[j]) + 1);
	    }
	}
	break;

    case VT_VECTOR | VT_LPWSTR:
	cbprop = sizeof(pv->calpwstr.cElems);
	for (j = 0; j < pv->calpwstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->calpwstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(
			sizeof(pv->calpwstr.pElems[j][0]) *
			(wcslen(pv->calpwstr.pElems[j]) + 1));
	    }
	}
	break;

    case VT_VECTOR | VT_VARIANT:
        cbprop = sizeof(pv->calpwstr.cElems);
        for (j = 0; j < pv->calpwstr.cElems; j++)
        {
            cbprop += SizeProp(&pv->capropvar.pElems[j]);
        }
        break;
    }
    return(DwordAlign(cbprop) + DwordAlign(sizeof(pv->vt)));
}


PUBLICPROPSET
GuidToPropSet(GUID *pguid)
{
    PUBLICPROPSET pubps = PUBPS_UNKNOWN;
	
    if (pguid != NULL)
    {
	if (memcmp(pguid, &FMTID_SummaryInformation, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_SUMMARYINFO;
	}
	else if (memcmp(pguid, &FMTID_DocSummaryInformation, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_DOCSUMMARYINFO;
	}
	else if (memcmp(pguid, &FMTID_UserDefinedProperties, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_USERDEFINED;
	}
    }
    return(pubps);
}


char
PrintableChar(char ch)
{
    if (ch < ' ' || ch > '~')
    {
        ch = '.';
    }
    return(ch);
}


VOID
DumpHex(BYTE *pb, ULONG cb, ULONG base)
{
    char *pszsep;
    ULONG r, i, cbremain;
    int fZero = FALSE;
    int fSame = FALSE;

    for (r = 0; r < cb; r += 16)
    {
        cbremain = cb - r;
        if (r != 0 && cbremain >= 16)
        {
            if (pb[r] == 0)
            {
                ULONG j;

                for (j = r + 1; j < cb; j++)
                {
                    if (pb[j] != 0)
                    {
                        break;
                    }
                }
                if (j == cb)
                {
                    fZero = TRUE;
                    break;
                }
            }
            if (memcmp(&pb[r], &pb[r - 16], 16) == 0)
            {
                fSame = TRUE;
                continue;
            }
        }
        if (fSame)
        {
            ASYNC_PRINTF("\n\t  *");
            fSame = FALSE;
        }
        for (i = 0; i < min(cbremain, 16); i++)
        {
            pszsep = " ";
            if ((i % 8) == 0)           // 0 or 8
            {
                pszsep = "  ";
                if (i == 0)             // 0
                {
		    // start a new line
		    ASYNC_PRINTF("%s    %04x:", r == 0? "" : "\n", r + base);
		    pszsep = " ";
                }
            }
            ASYNC_PRINTF("%s%02x", pszsep, pb[r + i]);
        }
        if (i != 0)
        {
            ASYNC_PRINTF("%*s", 3 + (16 - i)*3 + ((i <= 8)? 1 : 0), "");
            for (i = 0; i < min(cbremain, 16); i++)
            {
                ASYNC_PRINTF("%c", PrintableChar(pb[r + i]));
            }
        }
    }
    if (r != 0)
    {
        ASYNC_PRINTF("\n");
    }
    if (fZero)
    {
        ASYNC_PRINTF("    Remaining %lx bytes are zero\n", cbremain);
    }
}


// Property Id's for Summary Info
#define PID_TITLE		0x00000002L	// VT_LPSTR
#define PID_SUBJECT		0x00000003L	// VT_LPSTR
#define PID_AUTHOR		0x00000004L	// VT_LPSTR
#define PID_KEYWORDS		0x00000005L	// VT_LPSTR
#define PID_COMMENTS		0x00000006L	// VT_LPSTR
#define PID_TEMPLATE		0x00000007L	// VT_LPSTR
#define PID_LASTAUTHOR		0x00000008L	// VT_LPSTR
#define PID_REVNUMBER		0x00000009L	// VT_LPSTR
#define PID_EDITTIME		0x0000000aL	// VT_FILETIME
#define PID_LASTPRINTED		0x0000000bL	// VT_FILETIME
#define PID_CREATE_DTM		0x0000000cL	// VT_FILETIME
#define PID_LASTSAVE_DTM	0x0000000dL	// VT_FILETIME
#define PID_PAGECOUNT		0x0000000eL	// VT_I4
#define PID_WORDCOUNT		0x0000000fL	// VT_I4
#define PID_CHARCOUNT		0x00000010L	// VT_I4
#define PID_THUMBNAIL		0x00000011L	// VT_CF
#define PID_APPNAME		0x00000012L	// VT_LPSTR
#define PID_SECURITY_DSI	0x00000013L	// VT_I4

// Property Id's for Document Summary Info
#define PID_CATEGORY		0x00000002L	// VT_LPSTR
#define PID_PRESFORMAT		0x00000003L	// VT_LPSTR
#define PID_BYTECOUNT		0x00000004L	// VT_I4
#define PID_LINECOUNT		0x00000005L	// VT_I4
#define PID_PARACOUNT		0x00000006L	// VT_I4
#define PID_SLIDECOUNT		0x00000007L	// VT_I4
#define PID_NOTECOUNT		0x00000008L	// VT_I4
#define PID_HIDDENCOUNT		0x00000009L	// VT_I4
#define PID_MMCLIPCOUNT		0x0000000aL	// VT_I4
#define PID_SCALE		0x0000000bL	// VT_BOOL
#define PID_HEADINGPAIR		0x0000000cL	// VT_VECTOR | VT_VARIANT
#define PID_DOCPARTS		0x0000000dL	// VT_VECTOR | VT_LPSTR
#define PID_MANAGER		0x0000000eL	// VT_LPSTR
#define PID_COMPANY		0x0000000fL	// VT_LPSTR
#define PID_LINKSDIRTY		0x00000010L	// VT_BOOL
#define PID_CCHWITHSPACES	0x00000011L	// VT_I4
#define PID_GUID		0x00000012L	// VT_LPSTR
#define PID_SHAREDDOC		0x00000013L	// VT_BOOL
#define PID_LINKBASE		0x00000014L	// VT_LPSTR
#define PID_HLINKS		0x00000015L	// VT_VECTOR | VT_VARIANT
#define PID_HYPERLINKSCHANGED	0x00000016L	// VT_BOOL


VOID
DisplayProps(
    GUID *pguid,
    ULONG cprop,
    PROPID apid[],
    STATPROPSTG asps[],
    PROPVARIANT *av,
    BOOLEAN fsumcat,
    ULONG *pcbprop)
{
    PROPVARIANT *pv;
    PROPVARIANT *pvend;
    STATPROPSTG *psps;
    BOOLEAN fVariantVector;
    PUBLICPROPSET pubps;

    fVariantVector = (asps == NULL);

    pubps = GuidToPropSet(pguid);
    pvend = &av[cprop];
    for (pv = av, psps = asps; pv < pvend; pv++, psps++)
    {
        ULONG j;
        ULONG cbprop;
        PROPID propid;
        OLECHAR *postrName;
        char *psz;
        BOOLEAN fNewLine = TRUE;
        int ccol;
        static char szNoFormat[] = " (no display format)";
        char achvt[19 + 8 + 1];

        cbprop = SizeProp(pv);
        *pcbprop += cbprop;

        postrName = NULL;
        if (asps != NULL)
        {
            propid = psps->propid;
            postrName = psps->lpwstrName;
        }
        else
        {
            ASSERT(apid != NULL);
            propid = apid[0];
        }

        ASYNC_PRINTF(" ");
        ccol = 0;

        if (propid != PID_ILLEGAL)
        {
            ASYNC_PRINTF(" %04x", propid);
            ccol += 5;
            if (propid & (0xf << 28))
            {
                ccol += 4;
            }
            else if (propid & (0xf << 24))
            {
                ccol += 3;
            }
            else if (propid & (0xf << 20))
            {
                ccol += 2;
            }
            else if (propid & (0xf << 16))
            {
                ccol++;
            }
        }
        if (postrName != NULL)
        {
	    ASYNC_OPRINTF(OLESTR(" '%s'"), postrName);
	    ccol += ocslen(postrName) + 3;
        }
        else if (fVariantVector)
        {
            ULONG i = (ULONG) ((ULONG_PTR)pv - (ULONG_PTR)av);

            ASYNC_PRINTF("[%x]", i);
            do
            {
                ccol++;
                i >>= 4;
            } while (i != 0);
            ccol += 2;
        }
        else
        {
            psz = NULL;

            switch (propid)
            {
                case PID_LOCALE:               psz = "Locale";           break;
                case PID_SECURITY:             psz = "SecurityId";       break;
                case PID_MODIFY_TIME:          psz = "ModifyTime";       break;
                case PID_CODEPAGE:             psz = "CodePage";         break;
                case PID_DICTIONARY:           psz = "Dictionary";       break;
            }
            if (psz == NULL)
		switch (pubps)
		{
		case PUBPS_SUMMARYINFO:
		    switch (propid)
		    {
		    case PID_TITLE:              psz = "Title";          break;
		    case PID_SUBJECT:            psz = "Subject";        break;
		    case PID_AUTHOR:             psz = "Author";         break;
		    case PID_KEYWORDS:           psz = "Keywords";       break;
		    case PID_COMMENTS:           psz = "Comments";       break;
		    case PID_TEMPLATE:           psz = "Template";       break;
		    case PID_LASTAUTHOR:         psz = "LastAuthor";     break;
		    case PID_REVNUMBER:          psz = "RevNumber";      break;
		    case PID_EDITTIME:           psz = "EditTime";       break;
		    case PID_LASTPRINTED:        psz = "LastPrinted";    break;
		    case PID_CREATE_DTM:         psz = "CreateDateTime"; break;
		    case PID_LASTSAVE_DTM:       psz = "LastSaveDateTime";break;
		    case PID_PAGECOUNT:          psz = "PageCount";      break;
		    case PID_WORDCOUNT:          psz = "WordCount";      break;
		    case PID_CHARCOUNT:          psz = "CharCount";      break;
		    case PID_THUMBNAIL:          psz = "ThumbNail";      break;
		    case PID_APPNAME:            psz = "AppName";        break;
		    case PID_DOC_SECURITY:       psz = "Security";       break;

		    }
		    break;

		case PUBPS_DOCSUMMARYINFO:
		    switch (propid)
		    {
		    case PID_CATEGORY:          psz = "Category";        break;
		    case PID_PRESFORMAT:        psz = "PresFormat";      break;
		    case PID_BYTECOUNT:         psz = "ByteCount";       break;
		    case PID_LINECOUNT:         psz = "LineCount";       break;
		    case PID_PARACOUNT:         psz = "ParaCount";       break;
		    case PID_SLIDECOUNT:        psz = "SlideCount";      break;
		    case PID_NOTECOUNT:         psz = "NoteCount";       break;
		    case PID_HIDDENCOUNT:       psz = "HiddenCount";     break;
		    case PID_MMCLIPCOUNT:       psz = "MmClipCount";     break;
		    case PID_SCALE:             psz = "Scale";           break;
		    case PID_HEADINGPAIR:       psz = "HeadingPair";     break;
		    case PID_DOCPARTS:          psz = "DocParts";        break;
		    case PID_MANAGER:           psz = "Manager";         break;
		    case PID_COMPANY:           psz = "Company";         break;
		    case PID_LINKSDIRTY:        psz = "LinksDirty";      break;
		    case PID_CCHWITHSPACES:     psz = "CchWithSpaces";   break;
		    case PID_GUID:              psz = "Guid";            break;
		    case PID_SHAREDDOC:         psz = "SharedDoc";       break;
		    case PID_LINKBASE:          psz = "LinkBase";        break;
		    case PID_HLINKS:            psz = "HLinks";          break;
		    case PID_HYPERLINKSCHANGED:	psz = "HyperLinksChanged";break;
		    }
		    break;
            }
            if (psz != NULL)
            {
                ASYNC_PRINTF(" %s", psz);
                ccol += strlen(psz) + 1;
            }
        }
#define CCOLPROPID 20
        if (ccol != CCOLPROPID)
	{
	    if (ccol > CCOLPROPID)
	    {
		ccol = -1;
	    }
            ASYNC_PRINTF("%s%*s", ccol == -1? "\n" : "", CCOLPROPID - ccol, "");
	}
        ASYNC_PRINTF(" %08x  %04x  %04x ", propid, cbprop, pv->vt);

        psz = "";
        switch (pv->vt)
        {
        default:
            psz = achvt;
            sprintf(psz, "Unknown (vt = %hx)", pv->vt);
            break;

        case VT_EMPTY:
            ASYNC_PRINTF("EMPTY");
            break;

        case VT_NULL:
            ASYNC_PRINTF("NULL");
            break;

        case VT_UI1:
            ASYNC_PRINTF("UI1 = %02lx", pv->bVal);
            psz = "";
            break;

        case VT_I2:
            psz = "I2";
            goto doshort;

        case VT_UI2:
            psz = "UI2";
            goto doshort;

        case VT_BOOL:
            psz = "BOOL";
doshort:
            ASYNC_PRINTF("%s = %04hx", psz, pv->iVal);
            psz = g_szEmpty;
            break;

        case VT_I4:
            psz = "I4";
            goto dolong;

        case VT_UI4:
            psz = "UI4";
            goto dolong;

        case VT_R4:
            psz = "R4";
            goto dolong;

        case VT_ERROR:
            psz = "ERROR";
dolong:
            ASYNC_PRINTF("%s = %08lx", psz, pv->lVal);
            psz = g_szEmpty;
            break;

        case VT_I8:
            psz = "I8";
            goto dolonglong;

        case VT_UI8:
            psz = "UI8";
            goto dolonglong;

        case VT_R8:
            psz = "R8";
            goto dolonglong;

        case VT_CY:
            psz = "R8";
            goto dolonglong;

        case VT_DATE:
            psz = "R8";
dolonglong:
            ASYNC_PRINTF(
                "%s = %08lx:%08lx",
                psz,
                pv->hVal.HighPart,
                pv->hVal.LowPart);
            psz = g_szEmpty;
            break;

        case VT_FILETIME:
            DumpTime(OLESTR("FILETIME =\n\t  "), &pv->filetime);
            fNewLine = FALSE;           // skip newline printf
            break;

        case VT_CLSID:
            ASYNC_PRINTF("CLSID =\n\t  ");
            PrintGuid(pv->puuid);
            break;

        case VT_BLOB:
            psz = "BLOB";
            goto doblob;

        case VT_BLOB_OBJECT:
            psz = "BLOB_OBJECT";
doblob:
            ASYNC_PRINTF("%s (cbSize %x)", psz, pv->blob.cbSize);
            if (pv->blob.cbSize != 0)
            {
                ASYNC_PRINTF(" =\n");
                DumpHex(pv->blob.pBlobData, pv->blob.cbSize, 0);
            }
            psz = g_szEmpty;
            break;

        case VT_CF:
            ASYNC_PRINTF(
                "CF (cbSize %x, ulClipFmt %x)\n",
                pv->pclipdata->cbSize,
                pv->pclipdata->ulClipFmt);
            DumpHex(pv->pclipdata->pClipData,
                    pv->pclipdata->cbSize - sizeof(pv->pclipdata->ulClipFmt),
                    0);
            break;

        case VT_STREAM:
            psz = "STREAM";
            goto dostring;

        case VT_STREAMED_OBJECT:
            psz = "STREAMED_OBJECT";
            goto dostring;

        case VT_STORAGE:
            psz = "STORAGE";
            goto dostring;

        case VT_STORED_OBJECT:
            psz = "STORED_OBJECT";
            goto dostring;

        case VT_BSTR:
            ASYNC_PRINTF(
		"BSTR (cb = %04lx)%s\n",
		pv->bstrVal == NULL? 0 : BSTRLEN(pv->bstrVal),
		pv->bstrVal == NULL? " NULL" : g_szEmpty);
            if (pv->bstrVal != NULL)
	    {
		DumpHex(
		    (BYTE *) pv->bstrVal,
		    BSTRLEN(pv->bstrVal) + sizeof(WCHAR),
		    0);
	    }
            break;

        case VT_LPSTR:
            psz = "LPSTR";
            ASYNC_PRINTF(
		"%s = %s%s%s",
		psz,
		pv->pszVal == NULL? g_szEmpty : "'",
		pv->pszVal == NULL? "NULL" : pv->pszVal,
		pv->pszVal == NULL? g_szEmpty : "'");
	    psz = g_szEmpty;
            break;

        case VT_LPWSTR:
            psz = "LPWSTR";
dostring:
            ASYNC_PRINTF(
		"%s = %s%ws%s",
		psz,
		pv->pwszVal == NULL? g_szEmpty : "'",
		pv->pwszVal == NULL? L"NULL" : pv->pwszVal,
		pv->pwszVal == NULL? g_szEmpty : "'");
            psz = g_szEmpty;
            break;

        //  vectors

        case VT_VECTOR | VT_UI1:
            ASYNC_PRINTF("UI1[%x] =", pv->caub.cElems);
            for (j = 0; j < pv->caub.cElems; j++)
            {
                if ((j % 16) == 0)
                {
                    ASYNC_PRINTF("\n    %02hx:", j);
                }
                ASYNC_PRINTF(" %02hx", pv->caub.pElems[j]);
            }
            break;

        case VT_VECTOR | VT_I2:
            psz = "I2";
            goto doshortvector;

        case VT_VECTOR | VT_UI2:
            psz = "UI2";
            goto doshortvector;

        case VT_VECTOR | VT_BOOL:
            psz = "BOOL";
doshortvector:
            ASYNC_PRINTF("%s[%x] =", psz, pv->cai.cElems);
            for (j = 0; j < pv->cai.cElems; j++)
            {
                if ((j % 8) == 0)
                {
                    ASYNC_PRINTF("\n    %04hx:", j);
                }
                ASYNC_PRINTF(" %04hx", pv->cai.pElems[j]);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_I4:
            psz = "I4";
            goto dolongvector;

        case VT_VECTOR | VT_UI4:
            psz = "UI4";
            goto dolongvector;

        case VT_VECTOR | VT_R4:
            psz = "R4";
            goto dolongvector;

        case VT_VECTOR | VT_ERROR:
            psz = "ERROR";
dolongvector:
            ASYNC_PRINTF("%s[%x] =", psz, pv->cal.cElems);
            for (j = 0; j < pv->cal.cElems; j++)
            {
                if ((j % 4) == 0)
                {
                    ASYNC_PRINTF("\n    %04x:", j);
                }
                ASYNC_PRINTF(" %08lx", pv->cal.pElems[j]);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_I8:
            psz = "I8";
            goto dolonglongvector;

        case VT_VECTOR | VT_UI8:
            psz = "UI8";
            goto dolonglongvector;

        case VT_VECTOR | VT_R8:
            psz = "R8";
            goto dolonglongvector;

        case VT_VECTOR | VT_CY:
            psz = "CY";
            goto dolonglongvector;

        case VT_VECTOR | VT_DATE:
            psz = "DATE";
dolonglongvector:
            ASYNC_PRINTF("%s[%x] =", psz, pv->cah.cElems);
            for (j = 0; j < pv->cah.cElems; j++)
            {
                if ((j % 2) == 0)
                {
                    ASYNC_PRINTF("\n    %04x:", j);
                }
                ASYNC_PRINTF(
                    " %08lx:%08lx",
                    pv->cah.pElems[j].HighPart,
                    pv->cah.pElems[j].LowPart);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_FILETIME:
            ASYNC_PRINTF("FILETIME[%x] =\n", pv->cafiletime.cElems);
            for (j = 0; j < pv->cafiletime.cElems; j++)
            {
		ASYNC_PRINTF("    %04x: ", j);
		DumpTime(OLESTR(""), &pv->cafiletime.pElems[j]);
            }
            fNewLine = FALSE;           // skip newline printf
            break;

        case VT_VECTOR | VT_CLSID:
            ASYNC_PRINTF("CLSID[%x] =", pv->cauuid.cElems);
            for (j = 0; j < pv->cauuid.cElems; j++)
            {
                ASYNC_PRINTF("\n    %04x: ", j);
                PrintGuid(&pv->cauuid.pElems[j]);
            }
            break;

        case VT_VECTOR | VT_CF:
            ASYNC_PRINTF("CF[%x] =", pv->caclipdata.cElems);
            for (j = 0; j < pv->caclipdata.cElems; j++)
            {
                ASYNC_PRINTF("\n    %04x: (cbSize %x, ulClipFmt %x) =\n",
                    j,
                    pv->caclipdata.pElems[j].cbSize,
                    pv->caclipdata.pElems[j].ulClipFmt);
                DumpHex(
                    pv->caclipdata.pElems[j].pClipData,
                    pv->caclipdata.pElems[j].cbSize - sizeof(pv->caclipdata.pElems[j].ulClipFmt),
		    0);
            }
            break;

        case VT_VECTOR | VT_BSTR:
            ASYNC_PRINTF("BSTR[%x] =", pv->cabstr.cElems);
            for (j = 0; j < pv->cabstr.cElems; j++)
            {
		BSTR bstr = pv->cabstr.pElems[j];

                ASYNC_PRINTF(
		    "\n    %04x: cb = %04lx%s\n",
		    j,
		    bstr == NULL? 0 : BSTRLEN(pv->cabstr.pElems[j]),
		    bstr == NULL? " NULL" : g_szEmpty);
		if (bstr != NULL)
		{
		    DumpHex((BYTE *) bstr, BSTRLEN(bstr) + sizeof(WCHAR), 0);
		}
            }
            break;

        case VT_VECTOR | VT_LPSTR:
            ASYNC_PRINTF("LPSTR[%x] =", pv->calpstr.cElems);
            for (j = 0; j < pv->calpstr.cElems; j++)
            {
		CHAR *psz = pv->calpstr.pElems[j];

                ASYNC_PRINTF(
		    "\n    %04x: %s%s%s",
		    j,
		    psz == NULL? g_szEmpty : "'",
		    psz == NULL? "NULL" : psz,
		    psz == NULL? g_szEmpty : "'");
            }
            break;

        case VT_VECTOR | VT_LPWSTR:
            ASYNC_PRINTF("LPWSTR[%x] =", pv->calpwstr.cElems);
            for (j = 0; j < pv->calpwstr.cElems; j++)
            {
		WCHAR *pwsz = pv->calpwstr.pElems[j];

                ASYNC_PRINTF(
		    "\n    %04x: %s%ws%s",
		    j,
		    pwsz == NULL? g_szEmpty : "'",
		    pwsz == NULL? L"NULL" : pwsz,
		    pwsz == NULL? g_szEmpty : "'");
            }
            break;

        case VT_VECTOR | VT_VARIANT:
            ASYNC_PRINTF("VARIANT[%x] =\n", pv->capropvar.cElems);
            DisplayProps(
		    pguid,
                    pv->capropvar.cElems,
                    &propid,
                    NULL,
                    pv->capropvar.pElems,
		    fsumcat,
                    pcbprop);
            fNewLine = FALSE;           // skip newline printf
            break;
        }
        if (*psz != '\0')
        {
            ASYNC_PRINTF("%s", psz);
            if (pv->vt & VT_VECTOR)
            {
                ASYNC_PRINTF("[%x]", pv->cal.cElems);
            }
            ASYNC_PRINTF("%s", szNoFormat);
        }
        if (!fVariantVector && apid != NULL && apid[pv - av] != propid)
        {
            ASYNC_PRINTF(" (bad PROPID: %04x)", apid[pv - av]);
            fNewLine = TRUE;
        }
        if (asps != NULL && pv->vt != psps->vt)
        {
            ASYNC_PRINTF(" (bad STATPROPSTG VARTYPE: %04x)", psps->vt);
            fNewLine = TRUE;
        }
        if (fNewLine)
        {
            ASYNC_PRINTF("\n");
        }
    }
}


STATPROPSTG aspsStatic[] = {
    { NULL, PID_CODEPAGE,    VT_I2 },
    { NULL, PID_MODIFY_TIME, VT_FILETIME },
    { NULL, PID_SECURITY,    VT_UI4 },
};
#define CPROPSTATIC      (sizeof(aspsStatic)/sizeof(aspsStatic[0]))


#define CB_STREAM_OVERHEAD      28
#define CB_PROPSET_OVERHEAD     (CB_STREAM_OVERHEAD + 8)
#define CB_PROP_OVERHEAD        8

HRESULT
DumpOlePropertySet(
    IPropertySetStorage *ppsstg,
    STATPROPSETSTG *pspss,
    ULONG *pcprop,
    ULONG *pcbprop)
{
    HRESULT hr;
    IEnumSTATPROPSTG *penumsps = NULL;
    IPropertyStorage *pps;
    ULONG cprop, cbpropset;
    PROPID propid;
    OLECHAR *poszName;
    ULONG ispsStatic;

    *pcprop = *pcbprop = 0;

    hr = ppsstg->Open(
		    pspss->fmtid,
		    STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
		    &pps);

    if( FAILED(hr) )
        return(hr);

    propid = PID_DICTIONARY;

    hr = pps->ReadPropertyNames(1, &propid, &poszName);
    if( (HRESULT) S_FALSE == hr )
        hr = S_OK;
    Check( S_OK, hr );

    ListPropSetHeader(pspss, poszName);
    if (poszName != NULL)
    {
	CoTaskMemFree(poszName);
    }

    cprop = cbpropset = 0;

    Check(S_OK, pps->Enum(&penumsps) );

    ispsStatic = 0;
    hr = S_OK;
    while (hr == S_OK)
    {
	STATPROPSTG sps;
	PROPSPEC propspec;
	PROPVARIANT propvar;
	ULONG count;

	hr = (HRESULT) S_FALSE;
	if (ispsStatic == 0)
	{
	    hr = penumsps->Next(1, &sps, &count);
	}

	if (hr != S_OK)
	{
	    if (hr == (HRESULT) S_FALSE)
	    {
		hr = S_OK;
		if (ispsStatic >= CPROPSTATIC)
		{
		    break;
		}
		sps = aspsStatic[ispsStatic];
		ispsStatic++;
		count = 1;
	    }
            Check( S_OK, hr );
	}
	PropVariantInit(&propvar);
	if (sps.lpwstrName != NULL)
	{
	    propspec.ulKind = PRSPEC_LPWSTR;
	    propspec.lpwstr = sps.lpwstrName;
	}
	else
	{
	    propspec.ulKind = PRSPEC_PROPID;
	    propspec.propid = sps.propid;
	}

        hr = pps->ReadMultiple(1, &propspec, &propvar);
	if (hr == (HRESULT) S_FALSE)
	{
	    if (g_fVerbose)
	    {
		ASYNC_PRINTF(
		    "%s(%u, %x) vt=%x returned hr=%x\n",
		    "IPropertyStorage::ReadMultiple",
		    ispsStatic,
		    propspec.propid,
		    propvar.vt,
		    hr);
	    }
	    ASSERT(propvar.vt == VT_EMPTY);
	    hr = S_OK;
	}
        Check( S_OK, hr );

	if (ispsStatic == 0 || propvar.vt != VT_EMPTY)
	{
	    ASSERT(count == 1);
	    cprop += count;
	    if (cprop == 1)
	    {
		ASYNC_PRINTF(g_szPropHeader);
	    }

	    DisplayProps(
		    &pspss->fmtid,
		    1,
		    NULL,
		    &sps,
		    &propvar,
		    FALSE,
		    &cbpropset);
	    g_pfnPropVariantClear(&propvar);
	}
	if (sps.lpwstrName != NULL)
	{
	    CoTaskMemFree(sps.lpwstrName);
	}
    }
    if (penumsps != NULL)
    {
	penumsps->Release();
    }
    pps->Release();
    if (cprop != 0)
    {
	cbpropset += CB_PROPSET_OVERHEAD + cprop * CB_PROP_OVERHEAD;
	ASYNC_PRINTF("  %04x bytes in %u properties\n\n", cbpropset, cprop);
    }
    *pcprop = cprop;
    *pcbprop = cbpropset;
    return(hr);
}


HRESULT
DumpOlePropertySets(
    IStorage *pstg,
    IPropertySetStorage *pIPropSetStorage,
    OLECHAR *aocpath)
{

    HRESULT hr = S_OK;
    IPropertySetStorage *ppsstg = pIPropSetStorage;
    ULONG cbproptotal = 0;
    ULONG cproptotal = 0;
    ULONG cpropset = 0;
    IID IIDpsstg = IID_IPropertySetStorage;

    if (ppsstg == NULL)
    {
        Check(S_OK, StgToPropSetStg( pstg, &ppsstg ));
    }

    {
	IEnumSTATPROPSETSTG *penumspss = NULL;

	Check(S_OK, ppsstg->Enum(&penumspss) );

	while (hr == S_OK)
	{
	    STATPROPSETSTG spss;
	    ULONG count;
	    BOOLEAN fDocumentSummarySection2;

	    hr = penumspss->Next(1, &spss, &count);

	    if (hr != S_OK)
	    {
		if (hr == (HRESULT) S_FALSE)
		{
		    hr = (HRESULT) S_OK;
		}

                Check( (HRESULT) S_OK, hr );
		break;
	    }
	    ASSERT(count == 1);

	    fDocumentSummarySection2 = FALSE;
	    while (TRUE)
	    {
		ULONG cprop, cbprop;
                HRESULT hr;

		hr = DumpOlePropertySet(
				ppsstg,
				&spss,
				&cprop,
				&cbprop);

                if( (HRESULT) STG_E_FILENOTFOUND == hr
                    &&
                    fDocumentSummarySection2 )
                {
                    hr = S_OK;
                }

		cpropset++;
		cproptotal += cprop;
		cbproptotal += cbprop;

		if (memcmp(&spss.fmtid, &FMTID_DocSummaryInformation, sizeof(FMTID)))
		{
		    break;
		}
		spss.fmtid = FMTID_UserDefinedProperties;
		fDocumentSummarySection2 = TRUE;
	    }
	}

	if (penumspss != NULL)
	{
	    penumspss->Release();
	}
	ppsstg->Release();
    }
    if ((cbproptotal | cproptotal | cpropset) != 0)
    {
	ASYNC_PRINTF(
	    " %04x bytes in %u properties in %u property sets\n",
	    cbproptotal,
	    cproptotal,
	    cpropset);
    }
    return(hr);
}


NTSTATUS
DumpOleStream(
    LPSTREAM pstm,
    ULONG cb)
{
    ULONG cbTotal = 0;

    while (TRUE)
    {
	ULONG cbOut;
	BYTE ab[4096];

	Check(S_OK, pstm->Read(ab, min(cb, sizeof(ab)), &cbOut) );
	if (cbOut == 0)
	{
	    break;
	}
	if (g_fVerbose)
	{
	    DumpHex(ab, cbOut, cbTotal);
	}
	cb -= cbOut;
	cbTotal += cbOut;
    }
    return(STATUS_SUCCESS);
}

VOID
DumpOleStorage(
    IStorage *pstg,
    IPropertySetStorage *pIPropertySetStorage,
    LPOLESTR aocpath )
{
    LPENUMSTATSTG penum;
    STATSTG ss;
    IStorage* pstgChild;
    LPSTREAM pstmChild;
    char *szType;
    OLECHAR *pocChild;
    HRESULT hr;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    Check( S_OK, DumpOlePropertySets(pstg, pIPropertySetStorage, aocpath) );

    if (NULL == pstg)
    {
        return;
    }
    Check( S_OK, pstg->EnumElements(0, NULL, 0, &penum) );

    pocChild = &aocpath[ocslen(aocpath)];

    // Continue enumeration until IEnumStatStg::Next returns non-S_OK

    while (TRUE)
    {
	ULONG ulCount;

        // Enumerate one element at a time
        hr = penum->Next(1, &ss, &ulCount);
        if( (HRESULT) S_FALSE == hr )
            break;
        else
            Check( S_OK, hr );

        // Select the human-readable type of object to display
        switch (ss.type)
        {
	    case STGTY_STREAM:    szType = "Stream";    break;
	    case STGTY_STORAGE:   szType = "Storage";   break;
	    case STGTY_LOCKBYTES: szType = "LockBytes"; break;
	    case STGTY_PROPERTY:  szType = "Property";  break;
	    default:              szType = "<Unknown>"; break;
        }
	if (g_fVerbose)
	{
	    ASYNC_OPRINTF(
		OLESTR("Type=%hs Size=%lx Mode=%lx LocksSupported=%lx StateBits=%lx '%s' + '%s'\n"),
		szType,
		ss.cbSize.LowPart,
		ss.grfMode,
		ss.grfLocksSupported,
		ss.grfStateBits,
		aocpath,
		ss.pwcsName);
	    ASYNC_PRINTF("ss.clsid = ");
	    PrintGuid(&ss.clsid);
	    ASYNC_PRINTF("\n");
	}

        // If a stream, output the data in hex format.

        if (ss.type == STGTY_STREAM)
        {
	    ASYNC_OPRINTF(
		OLESTR("Stream  %s:%s, Size=%lx\n"),
		aocpath,
		ss.pwcsName,
		ss.cbSize.LowPart);

	    Check(S_OK, pstg->OpenStream(
				    ss.pwcsName,
				    NULL,
				    STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
				    0,
				    &pstmChild) );

	    Check(S_OK, DumpOleStream(pstmChild, ss.cbSize.LowPart) );
	    pstmChild->Release();
	}

        // If a storage, recurse
        if (ss.type == STGTY_STORAGE)
        {
	    ASYNC_OPRINTF(
		OLESTR("Storage %s\\%s, Size=%lx\n"),
		aocpath,
		ss.pwcsName,
		ss.cbSize.LowPart);
            Check( S_OK, pstg->OpenStorage(
				    ss.pwcsName,
				    NULL,
				    STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
				    NULL,
				    0,
				    &pstgChild) );
	    *pocChild = L'\\';
	    ocscpy(pocChild + 1, ss.pwcsName);

	    DumpOleStorage(pstgChild, NULL, aocpath);
	    pstgChild->Release();

	    *pocChild = L'\0';
        }
        CoTaskMemFree(ss.pwcsName);
        PRINTF( "\n" );
    }
    penum->Release();
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\open.cxx ===
//+-----------------------------------------------------------------------
//
// File:        open.cxx
//
// Synopsis:    Helper functions for opening all kinds of FILE_STORAGE_TYPEs.
//
// History:     06-May-95       DaveStr     created
//
// Notes:
//
//------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <stgint.h>
#include <stgprop.h>
#define _CAIROSTG_
#include <olecairo.h>

extern BOOL g_fOFS;

HRESULT _Open(
    WCHAR        *path,
    FILE_STORAGE_TYPE type,
    BOOL         fCreate,
    HANDLE       *ph)
{
    NTSTATUS            status;
    UNICODE_STRING      str;
    IO_STATUS_BLOCK     iosb;
    OBJECT_ATTRIBUTES   oa;
    HRESULT             hr = S_OK;

    if ( !RtlDosPathNameToNtPathName_U(path,&str,NULL,NULL) )
    {
        hr = HRESULT_FROM_NT(STATUS_OBJECT_PATH_INVALID);
    }
    else
    {
        InitializeObjectAttributes(
                        &oa,
                        &str,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        (PSECURITY_DESCRIPTOR) NULL);

        status = NtCreateFile(ph,
                              FILE_GENERIC_READ  |
                                    FILE_GENERIC_WRITE |
                                    WRITE_OWNER |
                                    WRITE_DAC |
                                    SYNCHRONIZE |
                                    DELETE,
                              &oa,
                              &iosb, 
                              NULL,
                              0,
                              FILE_SHARE_READ,
                              ( fCreate ) ? FILE_CREATE : 0,
                              FILE_SYNCHRONOUS_IO_NONALERT |
                              (g_fOFS ? (FILE_STORAGE_TYPE_SPECIFIED |
                                    (type << FILE_STORAGE_TYPE_SHIFT)) : 0),
                              NULL,
                              0);

        if ( !NT_SUCCESS(status) )
        {
            hr = HRESULT_FROM_NT(status);
        }

        RtlFreeUnicodeString(&str);
    }

    return(hr);
}

static DWORD grfmode = (STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

HRESULT OpenDir(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)
{
    if ( fCreate )
    {
        return(StgCreateStorage(path,
                                grfmode,
                                STGFMT_DIRECTORY,
                                NULL,
                                ppistg));
    }
    else
    {
        return(StgOpenStorage(path,
                              NULL,
                              grfmode,
                              NULL,
                              0,
                              ppistg));
    }
}

HRESULT OpenFile(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)
{
    if ( fCreate )
    {
        return(StgCreateStorage(path,
                                grfmode,
                                STGFMT_FILE,
                                NULL,
                                ppistg));
    }
    else
    {
        return(StgOpenStorage(path,
                              NULL,
                              grfmode,
                              NULL,
                              0,
                              ppistg));
    }
}

HRESULT OpenJP(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)
{
    HRESULT hr;
    HANDLE  h;

    hr = _Open(path, StorageTypeJunctionPoint, fCreate, &h);

    if ( SUCCEEDED(hr) )
    {
        if ( fCreate )
        {
            hr = StgCreateStorageOnHandle(h,
                                          grfmode,
                                          STGFMT_DIRECTORY,
                                          ppistg);
        }
        else
        {
            hr = StgOpenStorageOnHandle(h,
                                        grfmode,
                                        ppistg);
        }

        NtClose(h);
    }

    return(hr);
}

HRESULT OpenSC(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)
{
    if ( fCreate )
    {
        return(StgCreateStorage(path,
                                grfmode,
                                STGFMT_CATALOG,
                                NULL,
                                ppistg));
    }
    else
    {
        return(StgOpenStorage(path,
                              NULL,
                              grfmode,
                              NULL,
                              0,
                              ppistg));
    }
}

HRESULT OpenStg(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)

{
    if ( fCreate )
    {
        return(StgCreateStorage(path,
                                grfmode,
                                STGFMT_DOCUMENT,
                                NULL,
                                ppistg));
    }
    else
    {
        return(StgOpenStorage(path,
                              NULL,
                              grfmode,
                              NULL,
                              0,
                              ppistg));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pch.cxx ===
//+============================================================================
//
//  File:       pch.cxx
//
//  Purpose:    This file composes the pre-compiled header for the
//              PropTest DRT.
//
//+============================================================================

#pragma warning( disable : 4291 )

#ifdef _MAC_NODOC

//  ================
//  Mac NODOC Format
//  ================

// The following set of pre-compiler directives is used in the
// Mac "NODOC" build environment.

    //  ----------------------------------------
    //  Build Environment Configuration Settings
    //  ----------------------------------------

    #define _PPCMAC                 // Macintosh PPC build
    #define OLE2ANSI                // Ansi OLE (OLECHAR == char)
    #undef WIN32                    // Do not include Win32 information
    #define IPROPERTY_DLL           // Use code for IProp.DLL
    #define BIGENDIAN 1             // Enable byte-swapping.
    #define IPROP_NO_OLEAUTO_H 1    // Don't try to include "oleauto.h"

    // If the NODOC environment's "debug" flag is set, then set the
    // NT environment's corresponding flag.

    #ifdef _DEBUG
        #define DBG 1   
    #endif

    //  ------
    //  Macros
    //  ------

    // The default Ansi CodePage
    #define CP_ACP   0

    // unsigned-long to Ansi
    #define ULTOA(ul, ch, i) _ultoa( ul, ch, i )

    // NTSTATUS and HRESULT information not available in the NODOC build.

    #define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

    #define FACILITY_WIN32                  7
    #define FACILITY_NT_BIT                 0x10000000
    #define HRESULT_FROM_WIN32(x)      (x ? ((HRESULT) (((x) &0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : 0 )
    #define ERROR_NO_UNICODE_TRANSLATION    1113L
    #define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
    #define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)


    //  --------------
    //  Basic Includes
    //  --------------

    // NOOP two #defines that are unnecessary in the NODOC environment.

    #define __RPC_FAR
    #define __RPC_STUB

    // Include the property set information (this same file is included
    // in the shipping package for use by ISVs.
    #include "iprop.h"

    // Include macros for dealing with OLECHARs
    #include <olechar.h>


    //  --------
    //  TypeDefs
    //  --------

    typedef LONG        NTSTATUS;
    typedef ULONG       PROPID;


    //  ----------
    //  Prototypes
    //  ----------

    // IMalloc wrappers

    LPVOID __cdecl CoTaskMemAlloc( ULONG cb );
    LPVOID __cdecl CoTaskMemRealloc( LPVOID pvInput, ULONG cb );
    VOID __cdecl CoTaskMemFree( LPVOID pv );

    // wide-character routines.
    int wcscmp( const WCHAR*, const WCHAR* );
    UINT __cdecl wcslen( const WCHAR* ); // MACBUG: size_t?
    int wcsnicmp( const WCHAR*, const WCHAR*, UINT );
    WCHAR *wcscpy( WCHAR* wszDest, const WCHAR* wszSource );

    // Ansi/Unicode routines

    UINT __cdecl GetACP();

    // BSTR routines

    BSTR SysAllocString(BSTR);
    VOID SysFreeString(BSTR);


    //  -------
    //  Externs
    //  -------

    // An array used by UuidCreate()
    extern GUID g_curUuid;


    //  -------
    //  Inlines
    //  -------

    // Compare two FMTIDs
    inline BOOL operator == (const FMTID &fmtid1, const FMTID &fmtid2)
    {
        return IsEqualGUID( fmtid1, fmtid2 );
    }

    // Stub out the Win32 GetLastError() API.
    inline DWORD GetLastError(){ return 0; }

    // Stub out UuidCreate() by using a global list of
    // GUIDs

    inline void UuidCreate ( OUT GUID * pUuid )
    {
        g_curUuid.Data1++;
        *pUuid = g_curUuid;         // member to member copy
    }


    //  -----------------
    //  Extended Includes
    //  -----------------

    #include <propmac.hxx>      // Property macros
    #include "cpropvar.hxx"     // CPropVariant class
    #include "CDisplay.hxx"     // CDisplay class (used by PRINTF macros)
    #include "PropTest.hxx"     // General information


#else   // #ifdef _MAC_NODOC

//  =========
//  NT Format
//  =========

    #include <new.h>

    // We'll take all the same abstractions that IProp.dll uses
    #define IPROPERTY_DLL

    #define DfpAssert Win4Assert

    #define _OLE32_ 1
    extern "C"
    {
        #include <nt.h>
        #include <ntrtl.h>
        #include <nturtl.h>
        #include <windows.h>
    }

    #define _CAIROSTG_
    #include <stdio.h>
    #include <time.h>

    #define INITGUID
    #include "initguid.h"

    // Don't use the Win32 Unicode wcs routines, since they're
    // not available on Win95.

    #ifndef OLE2ANSI
        #undef ocscpy
        #undef ocscmp
        #undef ocscat
        #undef ocschr

        #define ocscpy      wcscpy
        #define ocscmp      wcscmp
        #define ocscat      wcscat
        #define ocschr      wcschr
    #endif

    #include <safedecl.hxx>
    #include <infs.hxx>
    #include <oaidl.h>
    #include <propset.h>
    #include <expdf.hxx>
    #include <propmac.hxx>
    #include <olechar.h>
    #include <propidl.h>

    /*
    #define NT5PROPS_CI_APIS
    #include "..\\..\\iprop\\nt5props.h"	// Map PrivStgEx to StgEx APIs
    #define PROPS_DLL   "nt5props.dll"
    */

    #include "global.hxx"
    #include "cpropvar.hxx"

    #include "PStgServ.h"
    #include "PropMshl.hxx"
    #include "PropTest.hxx"
    #include "cli.hxx"


    // We include these here instead of #including stgprops.hxx, because proptest
    // is built with DBG turned off so that it can run on Win95, and these declarations
    // are DBG only.

    EXTERN_C const IID IID_IStorageTest; //40621cf8-a17f-11d1-b28d-00c04fb9386d

    interface IStorageTest : public IUnknown
    {
    public:

        STDMETHOD(UseNTFS4Streams)( BOOL fUseNTFS4Streams ) = 0;
        STDMETHOD(GetFormatVersion)(WORD *pw) = 0;
        STDMETHOD(SimulateLowMemory)( BOOL fSimulate ) = 0;
        STDMETHOD(GetLockCount)() = 0;
        STDMETHOD(IsDirty)() = 0;
    };



    #pragma hdrstop

#endif

//  ==================
//  NT/Mac Information
//  ==================

//  ------
//  Macros
//  ------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\prpsetup\prpsetup.cxx ===
//+============================================================================
//
//  File:       PrpSetup.cxx
//
//  Purpose:    This file builds to an executable which installs the
//              IProp DLL in the System(32) directory.  This is provided
//              for the use of applications which re-distribute that DLL.
//
//  Usage:      PrpSetup [/u] [/c]
//
//              The /u option indicates that an un-install should be performed.
//              The /c option indicates that console output is desired.
//
//  History:    10/30/96    MikeHill    Get "iprop.dl_" from the exe's resources.
//
//+============================================================================

//  --------
//  Includes
//  --------

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <stdio.h>

//  -------------
//  Global values
//  -------------

// Name-related information for the DLL
const LPTSTR tszResourceType       = TEXT( "FILE" );        // Resource type
const LPTSTR tszCompressedFilename = TEXT( "IPROP.DL_" );   // Temp file name
const LPTSTR tszTargetFilename     = TEXT( "IPROP.DLL" );   // Final file name

// The reg key where we keep the DLL's install ref-count.
const LPTSTR tszRegSharedDLLs
                = TEXT( "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs" );

// Registration functions in IProp DLL.
const LPTSTR tszRegistrationFunction    = TEXT( "DllRegisterServer" );
const LPTSTR tszUnregistrationFunction  = TEXT( "DllUnregisterServer" );


//  ------------
//  Return Codes
//  ------------

#define RETURN_SUCCESS                          0
#define RETURN_ARGUMENT_ERROR                   1
#define RETURN_COULDNT_CREATE_TEMP_FILE         2
#define RETURN_COULDNT_INSTALL_DLL              3
#define RETURN_COULDNT_DELETE_DLL               4
#define RETURN_COULDNT_REGISTER_DLL             5
#define RETURN_COULDNT_ACCESS_REGISTRY          6
#define RETURN_OUT_OF_MEMORY                    7
#define RETURN_INTERNAL_ERROR                   8


//+----------------------------------------------------------------------------
//
//  Function:   Register
//
//  Synopsis:   This function registers or de-registers the IProp DLL.
//
//  Inputs:     [BOOL] fUninstall (in)
//                  If true, call DllUnregisterServer, otherwise call
//                  DllRegisterServer
//
//  Returns:    [HRESULT]
//
//+----------------------------------------------------------------------------


HRESULT Register( BOOL fUninstall )
{
    HRESULT hr;
    HINSTANCE hinst = NULL;

    // A function pointer for the registration function
    typedef HRESULT (STDAPICALLTYPE FNREGISTRATION)();
    FNREGISTRATION *pfnRegistration = NULL;

    // Load the DLL

    hinst = LoadLibrary( tszTargetFilename );
    if( NULL == hinst )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Get the registration function

    pfnRegistration = (FNREGISTRATION*)
                      GetProcAddress( hinst,
                                      fUninstall ? tszUnregistrationFunction
                                                 : tszRegistrationFunction );
    if( NULL == pfnRegistration )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Register or De-register IProp.

    hr = (*pfnRegistration)();
    if( FAILED(hr) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hinst )
        FreeLibrary( hinst );

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  Function:   main()
//
//  Synopsis:   This program loads/removes IProp.DLL into/from the
//              System directory.  A ref-count of the number of installs
//              of this DLL is kept in the Registry.  The DLL is
//              also registered/deregistered.
//
//+----------------------------------------------------------------------------

HRESULT __cdecl main(int argc, char **argv)
{
    // File names and paths

    TCHAR tszSystemPath[_MAX_PATH+1];        // Path to System(32) directory
    TCHAR tszTempFilename[_MAX_PATH+1];      // Used by VerInstallFile()
    UINT cbTempFilename = sizeof( tszTempFilename ) - sizeof(TCHAR);
    TCHAR tszTargetPathAndFile[_MAX_PATH+1]; // E.g. "C:\Win\System32\IProp.dll"
    TCHAR tszTempPath[_MAX_PATH+1];          // E.g. "C:\Temp\"
                                             // E.g. "C:\Temp\iprop.dl_"
    TCHAR tszTempPathAndFile[_MAX_PATH+1] = {""};

    // Index into argv
    int nArgIndex;
    
    // User-settable flags.
    BOOL fConsole = FALSE;
    BOOL fInstall = FALSE;
    BOOL fUninstall = FALSE;

    // Registry data
    HKEY hkey;
    DWORD dwRegValueType;
    DWORD dwRefCount;
    DWORD cbRefCountSize = sizeof( dwRefCount );
    DWORD dwDisposition;

    // Handles for reading "iprop.dl_" out of the resources
    HRSRC hrsrcIProp = NULL;       // Handle to the "iprop.dl_" resource.
    HGLOBAL hglobIProp = NULL;     // Handle to the "iprop.dl_" data.
    LPVOID lpvIProp = NULL;        // Pointer to the "iprop.dl_" data.
    HMODULE hmodCurrent = NULL;    // Our module handle
    HANDLE hfileIProp = NULL;      // Handle to "%TEMP%\iprop.dl_" file


    // Misc.
    HRESULT hr = S_OK;
    INT  nReturnCode = RETURN_INTERNAL_ERROR;

    //  -----------------
    //  Process the Input
    //  -----------------

    for( nArgIndex = 1; nArgIndex < argc; nArgIndex++ )
    {
        if( // Is this argument an option?
            ( argv[nArgIndex][0] == '/'
              ||
              argv[nArgIndex][0] == '-'
            )
            && // and is it more than one character?
            argv[nArgIndex][1] != '\0'
            && // and is it exactly two characters?
            argv[nArgIndex][2] == '\0'
          )
        {
            // See if it's an argument we recognize.
            switch( argv[nArgIndex][1] )
            {
                // Installation

                case 'i':
                case 'I':

                    fInstall = TRUE;
                    break;

                // Uninstall
                case 'u':
                case 'U':

                    fUninstall = TRUE;
                    break;

                // Console output
                case 'c':
                case 'C':

                    fConsole = TRUE;
                    break;
            }
        }   // if( ( argv[nArgIndex][0] == '/' ...
    }   // for( nArgIndex = 1; nArgIndex < argc; nArgIndex++ )

    // Did we get an illegal command-line combination?

    if( fInstall && fUninstall )
    {
        nReturnCode = RETURN_ARGUMENT_ERROR;
        goto Exit;
    }

    // Did the user fail to tell us what to do?  If so,
    // display usage information.

    if( !fInstall && !fUninstall )
    {
        _tprintf( TEXT("\n") );
        _tprintf( TEXT("   Installation program for the Microsoft OLE Property Set Implementation\n") );
        _tprintf( TEXT("   Usage:    IProp [/i | /u] [/c]\n") );
        _tprintf( TEXT("   Options:  /i => Install\n")
                  TEXT("             /u => Uninstall\n")
                  TEXT("             /c => Console output\n") );
        _tprintf( TEXT("   Examples: IProp /i\n")
                  TEXT("             IProp /u /c\n") );
        
        nReturnCode = RETURN_SUCCESS;
        goto Exit;
    }


    //  ----------
    //  Initialize
    //  ----------

    // Find the target installation directory.

    if( GetSystemDirectory( tszSystemPath,
                            sizeof(tszSystemPath) - sizeof(TCHAR))
        == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        nReturnCode = RETURN_COULDNT_INSTALL_DLL;
        goto Exit;
    }
      
    // Determine the target's total path & filename.

    _tcscpy( tszTargetPathAndFile, tszSystemPath );
    _tcscat( tszTargetPathAndFile, TEXT("\\") );
    _tcscat( tszTargetPathAndFile, tszTargetFilename );

    // Generate the filename we'll use for the compressed
    // IProp DLL file ("iprop.dl_"); get the temp directory
    // and post-pend a filename to it.

    if( !GetTempPath( sizeof(tszTempPath), tszTempPath ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        nReturnCode = RETURN_COULDNT_CREATE_TEMP_FILE;
        goto Exit;
    }

    _tcscpy( tszTempPathAndFile, tszTempPath );
    _tcscat( tszTempPathAndFile, tszCompressedFilename );

    // Open the registry key that holds this DLL's ref-count.

    hr = RegCreateKeyEx( HKEY_LOCAL_MACHINE,    // Open key
                       tszRegSharedDLLs,        // Name of subkey
                       0L,                      // Reserved
                       NULL,                    // Class
                       0,                       // Options
                       KEY_ALL_ACCESS,          // SAM desired
                       NULL,                    // Security attributes
                       &hkey,                   // Result
                       &dwDisposition );        // "Created" or "Opened"
    if( ERROR_SUCCESS != hr )
    {
        hr = HRESULT_FROM_WIN32( hr );
        nReturnCode = RETURN_COULDNT_ACCESS_REGISTRY;
        goto Exit;
    }

    // Attempt to read our ref-count

    hr = RegQueryValueEx( hkey,                 // Open key
                          tszTargetPathAndFile, // Value name
                          NULL,                 // Reserved
                          &dwRegValueType,      // Out: value type
                          (LPBYTE) &dwRefCount, // Out: value
                          &cbRefCountSize );    // In: buf size, out: data size

    if( ERROR_FILE_NOT_FOUND == hr )
        // This entry didn't already exist.
        dwRefCount = 0;

    else if( ERROR_SUCCESS != hr )
    {
        // There was a real error during the Query attempt.
        hr = HRESULT_FROM_WIN32(hr);
        nReturnCode = RETURN_COULDNT_ACCESS_REGISTRY;
        goto Exit;
    }

    else if ( REG_DWORD != dwRegValueType )
    {
        // This is an invalid entry.  We won't abort, we'll just
        // re-initialize it to zero, and at the end we'll overwrite
        // whatever was already there.

        dwRefCount = 0;
    }


    if( fConsole )
    {
        if( fUninstall )
            _tprintf ( TEXT("Uninstalling \"%s\"\n"), tszTargetPathAndFile );
        else
            _tprintf( TEXT("Installing \"%s\"\n"), tszTargetPathAndFile );
    }

    //  ------------------------------
    //  Installation or Uninstallation
    //  ------------------------------

    if( fUninstall )
    {   // We're doing an Un-Install

        // Should we actually delete it?  We haven't done a dec-ref yet,
        // so in the normal case, on the last delete, the RefCount will 
        // currently be 1.

        if( dwRefCount <= 1 )
        {
            // Yes - we need to do a delete.  First unregister the IProp
            // DLL.  If there's an error we'll abort.  So we might leave
            // an unused file on the machine, but that's better than
            // possibly deleting a file that is still in use by another
            // app.

            hr = Register( fUninstall );
            if( FAILED(hr) )
            {
                nReturnCode = RETURN_COULDNT_REGISTER_DLL;
                goto Exit;
            }

            // And delete the file

            if( !DeleteFile( tszTargetPathAndFile )
                &&
                ERROR_FILE_NOT_FOUND != GetLastError() )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                nReturnCode = RETURN_COULDNT_DELETE_DLL;
                goto Exit;
            }

            if( fConsole )
                _tprintf( TEXT("Removed IProp.DLL\n") );

            // Zero-out the ref count.  We'll delete it from the 
            // registry later
 
            dwRefCount = 0;
        }
        else
        {
            // We don't need to delete it, just dec-ref it.
            dwRefCount--;

            if( fConsole )
                _tprintf( TEXT("IProp.DLL not removed (reference count is now %d)\n"), dwRefCount );
        }
    }   // if( fUninstall )

    else
    {   // We're doing an Install

        DWORD dwSize;           // Size of "iprop.dl_".
        DWORD cbWritten = 0;

        if( fConsole )
            _tprintf( TEXT("Extracting \"%s\"\n"), tszTempPathAndFile );

        // Get our module handle;

        hmodCurrent = GetModuleHandle( NULL );
        if( NULL == hmodCurrent )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Get the resource which is actually the compressed IProp DLL

        hrsrcIProp = FindResource( hmodCurrent,
                                   tszCompressedFilename,
                                   tszResourceType );
        if( NULL == hrsrcIProp )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Get the size of "iprop.dl_"

        dwSize = SizeofResource( hmodCurrent, hrsrcIProp );
        if( 0 == dwSize )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Get "iprop.dl_" into a memory buffer.

        hglobIProp = LoadResource( hmodCurrent, hrsrcIProp );
        if( NULL == hglobIProp )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Get a pointer to the "iprop.dl_" data.

        lpvIProp = LockResource( hglobIProp );
        if( NULL == lpvIProp )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Create a temporary file, which will be "iprop.dl_"

        hfileIProp = CreateFile(
                            tszTempPathAndFile,             // E.g. "C:\Temp\iprop.dl_"
                            GENERIC_READ | GENERIC_WRITE,   // Requested access
                            FILE_SHARE_READ,                // Sharing mode
                            NULL,                           // No security attributes
                            CREATE_ALWAYS,                  // Overwrite existing
                            FILE_ATTRIBUTE_NORMAL,          // Default attributes
                            NULL );                         // No template file
        if( INVALID_HANDLE_VALUE == hfileIProp )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_COULDNT_CREATE_TEMP_FILE;
            goto Exit;
        }
        
        // Write the contents of "iprop.dl_"

        if( !WriteFile( hfileIProp, lpvIProp, dwSize, &cbWritten, NULL ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_COULDNT_CREATE_TEMP_FILE;
            goto Exit;
        }

        // We must close the file, or VerInstallFile won't open it.

        CloseHandle( hfileIProp );
        hfileIProp = NULL;

        // Install the file.

        hr = VerInstallFile(  0,                      // Flags
                              tszCompressedFilename,  // Source filename
                              tszTargetFilename,      // Dest filename
                              tszTempPath,            // Source location
                              tszSystemPath,          // Target location
                              tszSystemPath,          // Location of old version
                              tszTempFilename,        // Out: name of temp file
                              &cbTempFilename);       // In: size of buf, Out: name

        // If VerInstallFile left a temporary file, delete it now.

        if( hr & VIF_TEMPFILE )
        {
            TCHAR tszDeleteTempFile[_MAX_PATH+1];

            _tcscpy( tszDeleteTempFile, tszSystemPath );
            _tcscat( tszDeleteTempFile, TEXT("\\") );
            _tcscat( tszDeleteTempFile, tszTempFilename );
            DeleteFile( tszDeleteTempFile );
        }

        // If the file was installed successfully, register it.

        if( 0 == hr )
        {
            hr = Register( fUninstall );
            if( FAILED(hr) )
            {
                nReturnCode = RETURN_COULDNT_REGISTER_DLL;
                goto Exit;
            }
        }

        // If the error wasn't "newer version exists", then we
        // have a fatal error.

        else if( 0 == (hr & VIF_SRCOLD) )
        {
            nReturnCode = RETURN_COULDNT_INSTALL_DLL;
            goto Exit;
        }
        else if( fConsole )
        {
            _tprintf( TEXT("A newer version of the file is already installed\n") );
        }


        // Do an add-ref.
        dwRefCount++;

    }   // if( fUninstall ) ... else


    //  ------------------
    //  Save the Ref-Count
    //  ------------------

    // Did we actually delete the DLL?

    if( 0 == dwRefCount )
    {
        // Delete our entry from the SharedDlls entry
        hr = RegDeleteValue( hkey, tszTargetPathAndFile );
        
        if( ERROR_FILE_NOT_FOUND == hr )
            hr = ERROR_SUCCESS;

        else if( ERROR_SUCCESS != hr )
        {
            hr = HRESULT_FROM_WIN32(hr);
            nReturnCode = RETURN_COULDNT_ACCESS_REGISTRY;
            goto Exit;
        }
    }
    else
    {
        // Otherwise, put the new ref-count in the registry.
        hr = RegSetValueEx(  hkey,                  // Open key
                             tszTargetPathAndFile,  // Value name
                             0,                     // Reserved
                             REG_DWORD,             // Value type
                             (LPBYTE) &dwRefCount,  // Value buffer
                             sizeof( dwRefCount )); // Size of value
        if( ERROR_SUCCESS != hr )
        {
            hr = HRESULT_FROM_WIN32(hr);
            nReturnCode = RETURN_COULDNT_ACCESS_REGISTRY;
            goto Exit;
        }
    }    // if( 0 == dwRefCount ) ... else


    //  ----
    //  Exit
    //  ----

Exit:

    if( fConsole )
    {
        // We only succeeded if hr is 0; VerInstallFile might return
        // a bitmapped error that doesn't look like an HRESULT error
        // code.

        if( 0 == hr )
            _tprintf( TEXT("%s successful\n"),
                      fUninstall ? TEXT("Uninstall") : TEXT("Install") );
        else
            _tprintf( TEXT("%s failed.  Return code = %d (%08X)\n"),
                      nReturnCode,
                      fUninstall ? TEXT("Uninstall") : TEXT("Install"),
                      hr );
    }

    // Remove the temporary file (we initialized this to "", so this
    // call should always return success or file-not-found).

    DeleteFile( tszTempPathAndFile );

    // Free all the handles we've used.

    if( hfileIProp ) CloseHandle( hfileIProp );
    if( lpvIProp )   GlobalUnlock( lpvIProp );


    return( nReturnCode );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\proptest.cxx ===
//+=================================================================
//
//  File:
//      PropTest.cxx
//
//  Description:
//      This file contains the main() and most supporting functions
//      for the PropTest command-line DRT.  Run "PropTest /?" for
//      usage information.
//
//+=================================================================




// tests to do:
//   IEnumSTATPROPSTG
//          Create some properties, named and id'd
//          Enumerate them and check
//              (check vt, lpwstrName, propid)
//              (check when asking for more than there is: S_FALSE, S_OK)
//          Delete one
//          Reset the enumerator
//          Enumerate them and check
//          Delete one
//
//          Reset the enumeratorA
//          Read one from enumeratorA
//          Clone enumerator -> enumeratorB
//          Loop comparing rest of enumerator contents
//
//          Reset the enumerator
//          Skip all
//          Check none left
//
//          Reset the enumerator
//          Skip all but one
//          Check one left
//
//       Check refcounting and IUnknown
//
// IPropertyStorage tests
//
//       Multiple readers/writers access tests
//


//+----------------------------------------------------------------------------
//
//  I n c l u d e s
//
//+----------------------------------------------------------------------------

#include "pch.cxx"          // Brings in most other includes/defines/etc.
#include "propstm.hxx"
#include "propstg.hxx"

//#include <memory.h>         //


//+----------------------------------------------------------------------------
//
//  G l o b a l s
//
//+----------------------------------------------------------------------------


OLECHAR g_aocMap[CCH_MAP + 1] = OLESTR("abcdefghijklmnopqrstuvwxyz012345");

// Special-case property set names

const OLECHAR oszSummaryInformation[] = OLESTR("\005SummaryInformation");
ULONG cboszSummaryInformation = sizeof(oszSummaryInformation);
const OLECHAR oszDocSummaryInformation[] = OLESTR("\005DocumentSummaryInformation");
ULONG cboszDocSummaryInformation = sizeof(oszDocSummaryInformation);
const OLECHAR oszGlobalInfo[] = OLESTR("\005Global Info");
ULONG cboszGlobalInfo = sizeof(oszGlobalInfo);
const OLECHAR oszImageContents[] = OLESTR("\005Image Contents");
ULONG cboszImageContents = sizeof(oszImageContents);
const OLECHAR oszImageInfo[] = OLESTR("\005Image Info");
ULONG cboszImageInfo = sizeof(oszImageInfo);


// Enumeration indicating how to get an IPropertySetStorage

EnumImplementation g_enumImplementation = PROPIMP_UNKNOWN;
DWORD g_Restrictions;

BOOL g_fRegisterLocalServer = TRUE;
BOOL g_fUseNt5PropsDll = FALSE;

// Property Set APIs (which may be in OLE32.dll or IProp.dll)

HINSTANCE g_hinstDLL = NULL;
FNSTGCREATEPROPSTG *g_pfnStgCreatePropStg = NULL;
FNSTGOPENPROPSTG *g_pfnStgOpenPropStg = NULL;
FNSTGCREATEPROPSETSTG *g_pfnStgCreatePropSetStg = NULL;
FNFMTIDTOPROPSTGNAME *g_pfnFmtIdToPropStgName = NULL;
FNPROPSTGNAMETOFMTID *g_pfnPropStgNameToFmtId = NULL;
FNPROPVARIANTCLEAR *g_pfnPropVariantClear = NULL;
FNPROPVARIANTCOPY *g_pfnPropVariantCopy = NULL;
FNFREEPROPVARIANTARRAY *g_pfnFreePropVariantArray = NULL;

FNSTGCREATESTORAGEEX             *g_pfnStgCreateStorageEx = NULL;
FNSTGOPENSTORAGEEX               *g_pfnStgOpenStorageEx = NULL;
FNSTGOPENSTORAGEONHANDLE         *g_pfnStgOpenStorageOnHandle = NULL;
FNSTGCREATESTORAGEONHANDLE       *g_pfnStgCreateStorageOnHandle = NULL;
FNSTGPROPERTYLENGTHASVARIANT     *g_pfnStgPropertyLengthAsVariant = NULL;
FNSTGCONVERTVARIANTTOPROPERTY    *g_pfnStgConvertVariantToProperty = NULL;
FNSTGCONVERTPROPERTYTOVARIANT    *g_pfnStgConvertPropertyToVariant = NULL;

// PictureIt! Format IDs

const FMTID fmtidGlobalInfo =
    { 0x56616F00,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

const FMTID fmtidImageContents =
    { 0x56616400,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

const FMTID fmtidImageInfo =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };


BOOL          g_fOFS;
LARGE_INTEGER g_li0;

CPropVariant  g_rgcpropvarAll[ CPROPERTIES_ALL ];
CPropSpec     g_rgcpropspecAll[ CPROPERTIES_ALL ];
const OLECHAR* g_rgoszpropnameAll[ CPROPERTIES_ALL ];

char g_szPropHeader[] = "  propid/name          propid    cb   type value\n";
char g_szEmpty[] = "";
BOOL g_fVerbose = FALSE;
BOOL g_stgmDumpFlags = 0;

// This flag indicates whether or not the run-time system supports
// IPropertySetStorage on the DocFile IStorage object.

BOOL g_fQIPropertySetStorage = FALSE;


// g_curUuid is used by UuidCreate().  Everycall to that function
// returns the current value of g_curUuid, and increments the DWORD
// field.

GUID g_curUuid =
{ /* e4ecf7f0-e587-11cf-b10d-00aa005749e9 */
    0xe4ecf7f0,
    0xe587,
    0x11cf,
    {0xb1, 0x0d, 0x00, 0xaa, 0x00, 0x57, 0x49, 0xe9}
};

// Instantiate an object for the Marshaling tests

#ifndef _MAC_NODOC
CPropStgMarshalTest g_cpsmt;
#endif

// On the Mac, instantiate a CDisplay object, which is used
// by these tests to write to the screen (see #define PRINTF).

#ifdef _MAC
CDisplay *g_pcDisplay;
#endif

// System information

SYSTEMINFO g_SystemInfo;


int g_nIndent = 0;
void Status( char* szMessage )
{
    for( int i = 0; i < g_nIndent; i++ )
        PRINTF( "    " );

    if( g_fVerbose )
        PRINTF( szMessage );
    else
        PRINTF( "." );

}   // STATUS()



//+----------------------------------------------------------------------------
//
//  Function:   IsOriginalPropVariantType
//
//  Determines if a VARTYPE was one of the ones in the original PropVariant
//  definition (as defined in the OLE2 spec and shipped with NT4/DCOM95).
//
//+----------------------------------------------------------------------------

// *** Duped from props\utils.cxx ***

BOOL
IsOriginalPropVariantType( VARTYPE vt )
{
    if( vt & ~VT_TYPEMASK & ~VT_VECTOR )
        return( FALSE );

    switch( vt )
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_CLSID:
    case VT_BLOB:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_UI1|VT_VECTOR:
    case VT_I2|VT_VECTOR:
    case VT_UI2|VT_VECTOR:
    case VT_BOOL|VT_VECTOR:
    case VT_I4|VT_VECTOR:
    case VT_UI4|VT_VECTOR:
    case VT_R4|VT_VECTOR:
    case VT_ERROR|VT_VECTOR:
    case VT_I8|VT_VECTOR:
    case VT_UI8|VT_VECTOR:
    case VT_R8|VT_VECTOR:
    case VT_CY|VT_VECTOR:
    case VT_DATE|VT_VECTOR:
    case VT_FILETIME|VT_VECTOR:
    case VT_CLSID|VT_VECTOR:
    case VT_CF|VT_VECTOR:
    case VT_BSTR|VT_VECTOR:
    case VT_BSTR_BLOB|VT_VECTOR:
    case VT_LPSTR|VT_VECTOR:
    case VT_LPWSTR|VT_VECTOR:
    case VT_VARIANT|VT_VECTOR:

        return( TRUE );
    }

    return( FALSE );
}





//+=================================================================
//
//  Function:   _Check
//
//  Synopsis:   Verify that the actual HR is the expected
//              value.  If not, report an error and exit.
//
//  Inputs:     [HRESULT] hrExpected
//                  What we expected
//              [HRESULT] hrActual
//                  The actual HR of the previous operation.
//              [int] line
//                  The line number of the operation.
//
//  Outputs:    None.
//
//+=================================================================

void _Check(HRESULT hrExpected, HRESULT hrActual, LPCSTR szFile, int line)
{
    if (hrExpected != hrActual)
    {
        PRINTF("\nFailed with hr=%08x at line %d\n"
               "in \"%s\"\n"
               "(expected hr=%08x, GetLastError=%lu)\n",
                hrActual, line, szFile, hrExpected, GetLastError() );

        // On NT, we simply exit here.  On the Mac, where PropTest is a function rather
        // than a main(), we throw an exception so that the test may terminate somewhat
        // cleanly.

#ifdef _MAC
        throw CHRESULT( hrActual, OLESTR("Fatal Error") );
#else
        if( IsDebuggerPresent() )
            DebugBreak();

        exit(1);
#endif

    }
}

OLECHAR * GetNextTest()
{
    static int nTest;
    static OLECHAR ocsBuf[10];

    soprintf(ocsBuf, OLESTR("%d"), nTest++);

    return(ocsBuf);
}


VOID
CalcSafeArrayIndices( LONG iLinear, LONG rgIndices[], const SAFEARRAYBOUND rgsaBounds[], ULONG cDims )
{
    for( long i = 0; i < static_cast<long>(cDims) - 1; i++ )
    {
        LONG lProduct = rgsaBounds[cDims-1].cElements;

        for( int j = cDims-2; j > i; j-- )
            lProduct *= rgsaBounds[j].cElements;

        rgIndices[ i ] = rgsaBounds[i].lLbound + (iLinear / lProduct);
        iLinear %= lProduct;
    }

    rgIndices[ cDims-1 ] = rgsaBounds[cDims-1].lLbound + (iLinear % rgsaBounds[cDims-1].cElements);
}

ULONG
CalcSafeArrayElementCount( const SAFEARRAY *psa )
{
    ULONG cElems = 1;

    ULONG cDims = SafeArrayGetDim( const_cast<SAFEARRAY*>(psa) );

    for( ULONG i = 1; i <= cDims; i++ )
    {
        LONG lUpperBound = 0, lLowerBound = 0;

        Check( S_OK, SafeArrayGetLBound( const_cast<SAFEARRAY*>(psa), i, &lLowerBound ));
        Check( S_OK, SafeArrayGetUBound( const_cast<SAFEARRAY*>(psa), i, &lUpperBound ));

        cElems *= lUpperBound - lLowerBound + 1;
    }

    return( cElems );

}

VOID
CompareSafeArrays( SAFEARRAY *psa1, SAFEARRAY *psa2 )
{
    VARTYPE vt1, vt2;
    UINT cDims1, cDims2;
    UINT i;
    UINT cElems = 0;

    SAFEARRAYBOUND *rgsaBounds = NULL;
    LONG *rgIndices = NULL;

    Check( S_OK, SafeArrayGetVartype( psa1, &vt1 ));
    Check( S_OK, SafeArrayGetVartype( psa2, &vt2 ));
    Check( vt1, vt2 );

    cDims1 = SafeArrayGetDim( psa1 );
    cDims2 = SafeArrayGetDim( psa2 );
    Check( cDims1, cDims2 );

    Check( 0, memcmp( psa1->rgsabound, psa2->rgsabound, cDims1 * sizeof(SAFEARRAYBOUND) ));
    Check( psa1->fFeatures, psa2->fFeatures );
    Check( psa1->cbElements, psa2->cbElements );

    cElems = CalcSafeArrayElementCount( psa1 );

    switch( vt1 )
    {
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_BOOL:
    case VT_R4:
    case VT_R8:
    case VT_I8:
    case VT_UI8:

        Check( 0, memcmp( psa1->pvData, psa2->pvData, cDims1 * psa1->cbElements ));
        break;

    case VT_BSTR:

        rgsaBounds = new SAFEARRAYBOUND[ cDims1 ];
        Check( FALSE, NULL == rgsaBounds );
        rgIndices = new LONG[ cDims1 ];
        Check( FALSE, NULL == rgIndices );

        // The Bounds are stored in the safearray in reversed order.  Correct them so
        // that we can use CalcSafeArrayIndices

        for( i = 0; i < cDims1; i++ )
            rgsaBounds[i] = psa1->rgsabound[ cDims1-1-i ];

        for( i = 0; i < cElems; i++ )
        {
            BSTR *pbstr1 = NULL, *pbstr2 = NULL;
            CalcSafeArrayIndices( i, rgIndices, rgsaBounds, cDims1 );

            Check( S_OK, SafeArrayPtrOfIndex( psa1, rgIndices, reinterpret_cast<void**>(&pbstr1) ));
            Check( S_OK, SafeArrayPtrOfIndex( psa2, rgIndices, reinterpret_cast<void**>(&pbstr2) ));

            Check( *(reinterpret_cast<ULONG*>(*pbstr1)-1), *(reinterpret_cast<ULONG*>(*pbstr2)-1) );
            Check( 0, ocscmp( *pbstr1, *pbstr2 ));
        }

        break;

    case VT_VARIANT:

        rgsaBounds = new SAFEARRAYBOUND[ cDims1 ];
        Check( FALSE, NULL == rgsaBounds );
        rgIndices = new LONG[ cDims1 ];
        Check( FALSE, NULL == rgIndices );

        // The Bounds are stored in the safearray in reversed order.  Correct them so
        // that we can use CalcSafeArrayIndices

        for( i = 0; i < cDims1; i++ )
            rgsaBounds[i] = psa1->rgsabound[ cDims1-1-i ];

        for( i = 0; i < cElems; i++ )
        {
            CPropVariant *pcpropvar1 = NULL, *pcpropvar2 = NULL;
            CalcSafeArrayIndices( i, rgIndices, rgsaBounds, cDims1 );

            Check( S_OK, SafeArrayPtrOfIndex( psa1, rgIndices, reinterpret_cast<void**>(&pcpropvar1) ));
            Check( S_OK, SafeArrayPtrOfIndex( psa2, rgIndices, reinterpret_cast<void**>(&pcpropvar2) ));

            Check( TRUE, *pcpropvar1 == *pcpropvar2 );
        }


        break;

    default:
        Check( FALSE, TRUE );

    }   // switch( vt1 )


    delete[] rgIndices;
    delete[] rgsaBounds;
}


#ifndef _MAC    // SYSTEMTIME isn't supported on the Mac.
void Now(FILETIME *pftNow)
{
                SYSTEMTIME stStart;
                GetSystemTime(&stStart);
                SystemTimeToFileTime(&stStart, pftNow);
}
#endif


IStorage *_pstgTemp = NULL;
IStorage *_pstgTempCopyTo = NULL;  // _pstgTemp is copied to _pstgTempCopyTo

unsigned int CTempStorage::_iName;



PROPVARIANT * CGenProps::GetNext(int HowMany, int *pActual, BOOL fWrapOk, BOOL fNoNonSimple)
{
    PROPVARIANT *pVar = new PROPVARIANT[HowMany];

    if (pVar == NULL)
        return(NULL);

    for (int l=0; l<HowMany && _GetNext(pVar + l, fWrapOk, fNoNonSimple); l++) { };

    if (pActual)
        *pActual = l;

    if (l == 0)
    {
        delete pVar;
        return(NULL);
    }

    return(pVar);
}

BOOL CGenProps::_GetNext(PROPVARIANT *pVar, BOOL fWrapOk, BOOL fNoNonSimple)
{
    if (_vt == (VT_VECTOR | VT_CLSID)+1)
    {
        if (!fWrapOk)
            return(FALSE);
        else
            _vt = (VARENUM)2;
    }

    PROPVARIANT Var;
    BOOL fFirst = TRUE;

    do
    {
        GUID *pg;

        if (!fFirst)
        {
            g_pfnPropVariantClear(&Var);
        }

        fFirst = FALSE;

        memset(&Var, 0, sizeof(Var));
        Var.vt = _vt;
        (*((int*)&_vt))++;

        switch (Var.vt)
        {
        case VT_LPSTR:
                Var.pszVal = new CHAR[ 6 ];
                strcpy(Var.pszVal, "lpstr");
                break;
        case VT_LPWSTR:
                Var.pwszVal = new WCHAR[ 7 ];
                wcscpy(Var.pwszVal, L"lpwstr");
                break;
        case VT_CLSID:
                pg = new GUID;
                UuidCreate(pg);
                Var.puuid = pg;
                break;
        case VT_CF:
                Var.pclipdata = new CLIPDATA;
                Var.pclipdata->cbSize = 10;
                Var.pclipdata->pClipData = new BYTE[ 10 ];
                Var.pclipdata->ulClipFmt = 0;
                break;
        case VT_VERSIONED_STREAM:
                Var.pVersionedStream = new VERSIONEDSTREAM;
                UuidCreate( &Var.pVersionedStream->guidVersion );
                Var.pVersionedStream->pStream = NULL;
                break;
        }
    } while ( (fNoNonSimple && (Var.vt == VT_STREAM || Var.vt == VT_STREAMED_OBJECT ||
               Var.vt == VT_STORAGE || Var.vt == VT_STORED_OBJECT || Var.vt == VT_VERSIONED_STREAM)
              )
              ||
              !IsOriginalPropVariantType(Var.vt) );

    g_pfnPropVariantCopy(pVar, &Var);
    g_pfnPropVariantClear(&Var);

    return(TRUE);
}

VOID
CleanStat(ULONG celt, STATPROPSTG *psps)
{
    while (celt--)
    {
        delete [] psps->lpwstrName;
        psps++;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   PopulateRGPropVar
//
//  Synopsis:   This function fills an input array of PROPVARIANTs
//              with an assortment of properties.
//
//  Note:       For compatibility with the marshaling test, all
//              non-simple properties must be at the end of the array.
//
//+----------------------------------------------------------------------------


HRESULT
PopulateRGPropVar( CPropVariant rgcpropvar[],
                   CPropSpec    rgcpropspec[],
                   const OLECHAR *rgoszpropname[],
                   IStorage     *pstg )
{
    HRESULT hr = (HRESULT) E_FAIL;
    int  i;
    ULONG ulPropIndex = 0;
    CLIPDATA clipdataNull = {0, 0, NULL}, clipdataNonNull = {0, 0, NULL};

    CClipData cclipdataEmpty;
    cclipdataEmpty.Set( (ULONG) -1, "", 0 );


    // Initialize the PropVariants

    for( i = 0; i < CPROPERTIES_ALL; i++ )
    {
        rgcpropvar[i].Clear();
    }


    /*
    // Create a I1 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "I1 Property" );
    rgcpropvar[ulPropIndex] = (CHAR) 38;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_I1 );
    ulPropIndex++;

    // Create a vector of I1s

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "Vector|I1 Property" );
    rgcpropvar[ulPropIndex][1] = (CHAR) 22;
    rgcpropvar[ulPropIndex][0] = (CHAR) 23;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_VECTOR|VT_I1) );
    ulPropIndex++;
    */

    // Create a UI1 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "UI1 Property" );
    rgcpropvar[ulPropIndex] = (UCHAR) 39;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_UI1 );
    ulPropIndex++;

    // Create an I2 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "I2 Property" );
    rgcpropvar[ulPropIndex] = (short) -502;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_I2 );
    ulPropIndex++;

    // Create a UI2 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "UI2 Property" );
    rgcpropvar[ulPropIndex] = (USHORT) 502;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_UI2 );
    ulPropIndex++;

    // Create a BOOL property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "Bool Property" );
    rgcpropvar[ulPropIndex].SetBOOL( VARIANT_TRUE );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_BOOL );
    ulPropIndex++;

    // Create a I4 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "I4 Property" );
    rgcpropvar[ulPropIndex] = (long) -523;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_I4 );
    ulPropIndex++;

    // Create a UI4 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "UI4 Property" );
    rgcpropvar[ulPropIndex] = (ULONG) 530;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_UI4 );
    ulPropIndex++;

    // Create a R4 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "R4 Property" );
    rgcpropvar[ulPropIndex] = (float) 5.37;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_R4 );
    ulPropIndex++;

    // Create an ERROR property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "ERROR Property" );
    rgcpropvar[ulPropIndex].SetERROR( STG_E_FILENOTFOUND );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_ERROR );
    ulPropIndex++;

    // Create an I8 property

    LARGE_INTEGER large_integer;
    large_integer.LowPart = 551;
    large_integer.HighPart = 30;
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "I8 Property" );
    rgcpropvar[ulPropIndex] = large_integer;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_I8 );
    ulPropIndex++;

    // Create a UI8 property

    ULARGE_INTEGER ularge_integer;
    ularge_integer.LowPart = 561;
    ularge_integer.HighPart = 30;
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "UI8 Property" );
    rgcpropvar[ulPropIndex] = ularge_integer;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_UI8 );
    ulPropIndex++;

    // Create an R8 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "R8 Property" );
    rgcpropvar[ulPropIndex] = (double) 571.36;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_R8 );
    ulPropIndex++;

    // Create a CY property

    CY cy;
    cy.Hi = 123;
    cy.Lo = 456;
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "Cy Property" );
    rgcpropvar[ulPropIndex] = cy;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_CY );
    ulPropIndex++;

    // Create a DATE property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "DATE Property" );
    rgcpropvar[ulPropIndex].SetDATE( 587 );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_DATE );
    ulPropIndex++;

    // Create a FILETIME property

    FILETIME filetime;
    filetime.dwLowDateTime = 0x767c0570;
    filetime.dwHighDateTime = 0x1bb7ecf;
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "FILETIME Property" );
    rgcpropvar[ulPropIndex] = filetime;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_FILETIME );
    ulPropIndex++;

    // Create a CLSID property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "CLSID Property" );
    rgcpropvar[ulPropIndex] = FMTID_SummaryInformation;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_CLSID );
    ulPropIndex++;

    // Create a vector of CLSIDs

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "CLSID Vector Property" );
    rgcpropvar[ulPropIndex][0] = FMTID_SummaryInformation;
    rgcpropvar[ulPropIndex][1] = FMTID_DocSummaryInformation;
    rgcpropvar[ulPropIndex][2] = FMTID_UserDefinedProperties;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_CLSID | VT_VECTOR) );
    ulPropIndex++;

    // Create a BSTR property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("BSTR");
    rgcpropvar[ulPropIndex].SetBSTR( OLESTR("BSTR Value") );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_BSTR );
    ulPropIndex++;

    // Create a BSTR Vector property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("BSTR Vector");
    for( i = 0; i < 3; i++ )
    {
        OLECHAR olestrElement[] = OLESTR("# - BSTR Vector Element");
        olestrElement[0] = (OLECHAR) i%10 + OLESTR('0');
        rgcpropvar[ulPropIndex].SetBSTR( olestrElement, i );
    }

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_BSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create a variant vector BSTR property.

    rgcpropspec[ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("BSTR Variant Vector");

    for( i = 0; i < 3; i++ )
    {
        if( i == 0 )
        {
            rgcpropvar[ulPropIndex][0] = (PROPVARIANT) CPropVariant((long) 0x1234);
        }
        else
        {
            CPropVariant cpropvarBSTR;
            cpropvarBSTR.SetBSTR( OLESTR("# - Vector Variant BSTR") );
            (cpropvarBSTR.GetBSTR())[0] = (OLECHAR) i%10 + OLESTR('0');
            rgcpropvar[ulPropIndex][i] = (PROPVARIANT) cpropvarBSTR;
        }
    }

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_VARIANT | VT_VECTOR) );
    ulPropIndex++;

    // Create an LPSTR property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("LPSTR Property");
    rgcpropvar[ulPropIndex]  = "LPSTR Value";

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_LPSTR );
    ulPropIndex++;

    // Create some ClipFormat properties

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("ClipFormat property");
    rgcpropvar[ ulPropIndex ]  = CClipData( L"Clipboard Data" );
    Check(TRUE,  rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("Empty ClipFormat property (NULL pointer)");
    clipdataNull.cbSize = 4;
    clipdataNull.ulClipFmt = (ULONG) -1;
    clipdataNull.pClipData = NULL;
    rgcpropvar[ ulPropIndex ] = clipdataNull;
    Check(TRUE,  rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("Empty ClipFormat property (non-NULL pointer)");
    clipdataNonNull.cbSize = 4;
    clipdataNonNull.ulClipFmt = (ULONG) -1;
    clipdataNonNull.pClipData = new BYTE[ 0 ];
    rgcpropvar[ ulPropIndex ] = clipdataNonNull;
    Check(TRUE,  rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    // Create a vector of ClipFormat properties

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("ClipFormat Array Property");
    rgcpropvar[ ulPropIndex ][0] = CClipData( L"Clipboard Date element 1" );
    rgcpropvar[ ulPropIndex ][1] = cclipdataEmpty;
    rgcpropvar[ ulPropIndex ][2] = clipdataNull;
    rgcpropvar[ ulPropIndex ][3] = clipdataNonNull;
    rgcpropvar[ ulPropIndex ][4] = CClipData( L"Clipboard Date element 2" );

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_CF | VT_VECTOR) );
    Check(TRUE,  rgcpropvar[ulPropIndex].Count() == 5 );
    ulPropIndex++;

    // Create an LPSTR|Vector property (e.g., the DocSumInfo
    // Document Parts array).

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("LPSTR|Vector property");
    rgcpropvar[ ulPropIndex ][0] = "LPSTR Element 0";
    rgcpropvar[ ulPropIndex ][1] = "LPSTR Element 1";

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_LPSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create an LPWSTR|Vector property

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("LPWSTR|Vector property");
    rgcpropvar[ ulPropIndex ][0] = L"LPWSTR Element 0";
    rgcpropvar[ ulPropIndex ][1] = L"LPWSTR Element 1";

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_LPWSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create a DocSumInfo HeadingPairs array.

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("HeadingPair array");

    rgcpropvar[ ulPropIndex ][0] = (PROPVARIANT) CPropVariant( "Heading 0" );
    rgcpropvar[ ulPropIndex ][1] = (PROPVARIANT) CPropVariant( (long) 1 );
    rgcpropvar[ ulPropIndex ][2] = (PROPVARIANT) CPropVariant( "Heading 1" );
    rgcpropvar[ ulPropIndex ][3] = (PROPVARIANT) CPropVariant( (long) 1 );

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_VARIANT | VT_VECTOR) );
    ulPropIndex++;

    // Create some NULL (but extant) properties

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("Empty LPSTR");
    rgcpropvar[ulPropIndex]  = "";
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_LPSTR );
    ulPropIndex++;

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("Empty LPWSTR");
    rgcpropvar[ulPropIndex]  = L"";
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_LPWSTR );
    ulPropIndex++;

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("Empty BLOB");
    rgcpropvar[ulPropIndex] = CBlob(0);
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_BLOB );
    ulPropIndex++;

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("Empty BSTR");
    rgcpropvar[ulPropIndex].SetBSTR( OLESTR("") );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_BSTR );
    ulPropIndex++;

    // Create some NULL (and non-extant) properties

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("NULL BSTR");
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->vt = VT_BSTR;
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->bstrVal = NULL;
    ulPropIndex++;

    // ***
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("NULL LPSTR");
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->vt = VT_LPSTR;
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->pszVal = NULL;
    ulPropIndex++;

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("NULL LPWSTR");
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->vt = VT_LPWSTR;
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->pwszVal = NULL;
    ulPropIndex++;
    // ***

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("BSTR Vector with NULL element");
    rgcpropvar[ulPropIndex].SetBSTR( NULL, 0 );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_VECTOR | VT_BSTR) );
    ulPropIndex++;

    /*
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("LPSTR Vector with NULL element");
    rgcpropvar[ulPropIndex].SetLPSTR( NULL, 0 );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_VECTOR | VT_LPSTR );
    ulPropIndex++;
    */


    if( !(g_Restrictions & RESTRICT_SIMPLE_ONLY) )
    {
    // Create an IStream property

    IStream *pstmProperty = NULL;

        CheckLockCount( pstg, 0 );

    Check(S_OK, pstg->CreateStream( OLESTR("Stream Property"),
                                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        0L, 0L,
                                        &pstmProperty ));
        CheckLockCount( pstg, 0 );

    Check(S_OK, pstmProperty->Write("Hi There", 9, NULL ));
        Check(S_OK, pstmProperty->Seek( CLargeInteger(0), STREAM_SEEK_SET, NULL ));
        CheckLockCount( pstmProperty, 0 );

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("Stream Property");
    rgcpropvar[ ulPropIndex ] = pstmProperty;
    pstmProperty->Release();
    pstmProperty = NULL;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_STREAM );
    ulPropIndex++;

        // Create a VersionedStream property

        VERSIONEDSTREAM VersionedStreamProperty;

        UuidCreate( &VersionedStreamProperty.guidVersion );

    Check(S_OK, pstg->CreateStream( OLESTR("Versioned Stream Property"),
                                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        0L, 0L,
                                        &VersionedStreamProperty.pStream ));
    Check(S_OK, VersionedStreamProperty.pStream->Write("Hi There, version", 9, NULL ));
        Check(S_OK, VersionedStreamProperty.pStream->Seek( CLargeInteger(0), STREAM_SEEK_SET, NULL ));

        rgcpropspec[ ulPropIndex ] = rgoszpropname[ ulPropIndex ] = OLESTR("Versioned Stream Property");
        rgcpropvar[ ulPropIndex ] = VersionedStreamProperty;
        RELEASE_INTERFACE( VersionedStreamProperty.pStream );
        Check( TRUE, rgcpropvar[ulPropIndex].VarType() == VT_VERSIONED_STREAM );
        ulPropIndex++;


    // Create an IStorage property

    IStorage *pstgProperty = NULL;
        Check(S_OK, StgCreateDocfile(NULL, STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_DELETEONRELEASE,
                                     0, &pstgProperty ));

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("Storage Property");
    rgcpropvar[ ulPropIndex ] = pstgProperty;
    pstgProperty->Release();
    pstgProperty = NULL;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_STORAGE );
    ulPropIndex++;
    }

    //  ----
    //  Exit
    //  ----

    delete [] clipdataNonNull.pClipData;
    memset( &clipdataNonNull, 0, sizeof(clipdataNonNull) );

    Check(TRUE,  CPROPERTIES_ALL >= ulPropIndex );
    hr = S_OK;
    return(hr);

}



HRESULT
ResetRGPropVar( CPropVariant rgcpropvar[] )
{
    HRESULT hr = S_OK;

    for( int i = 0; i < CPROPERTIES_ALL; i++ )
    {
        IStream *pstm = NULL;

        if( VT_STREAM == rgcpropvar[i].VarType()
            ||
            VT_STREAMED_OBJECT == rgcpropvar[i].VarType() )
        {
            pstm = rgcpropvar[i].GetSTREAM();
        }
        else if( VT_VERSIONED_STREAM == rgcpropvar[i].VarType() )
        {
            pstm = rgcpropvar[i].GetVERSIONEDSTREAM().pStream;
        }

        if( NULL != pstm )
        {
            hr = pstm->Seek( CLargeInteger(0), STREAM_SEEK_SET, NULL );
            if( FAILED(hr) ) goto Exit;
        }
    }

Exit:
    return( hr) ;
}


void
CheckFormatVersion( IPropertyStorage *ppropstg, WORD wExpected )
{
    HRESULT hr = S_OK;
    NTSTATUS status;
    WORD wActual;
    IStorageTest *ptest = NULL;

    hr = ppropstg->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
    if( SUCCEEDED(hr) )
    {
        Check( S_OK, ptest->GetFormatVersion(&wActual) );
        Check( wExpected, wActual );
        RELEASE_INTERFACE(ptest);
    }

    return;
}


void
CheckLockCount( IUnknown *punk, LONG lExpected )
{
    IStorageTest *ptest = NULL;
    HRESULT hr = S_OK;

    hr = punk->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
    if( SUCCEEDED(hr) )
        Check( lExpected, ptest->GetLockCount() );

    RELEASE_INTERFACE(ptest);
    return;
}




FILETIME operator - ( const FILETIME &ft1, const FILETIME &ft2 )
{
    FILETIME ftDiff;

    if( ft1 < ft2 )
    {
        ftDiff.dwLowDateTime  = 0;
        ftDiff.dwHighDateTime = 0;
    }

    else if( ft1.dwLowDateTime >= ft2.dwLowDateTime )
    {
        ftDiff.dwLowDateTime  = ft1.dwLowDateTime  - ft2.dwLowDateTime;
        ftDiff.dwHighDateTime = ft1.dwHighDateTime - ft2.dwHighDateTime;
    }
    else
    {
        ftDiff.dwLowDateTime = ft1.dwLowDateTime - ft2.dwLowDateTime;
        ftDiff.dwLowDateTime = (DWORD) -1 - ftDiff.dwLowDateTime;

        ftDiff.dwHighDateTime = ft1.dwHighDateTime - ft2.dwHighDateTime - 1;
    }

    return( ftDiff );
}

FILETIME operator -= ( FILETIME &ft1, const FILETIME &ft2 )
{
    ft1 = ft1 - ft2;
    return( ft1 );
}




void CheckTime(const FILETIME &ftStart, const FILETIME &ftPropSet)
{
    FILETIME ftNow;
    CoFileTimeNow(&ftNow);

    if (ftPropSet.dwLowDateTime == 0 && ftPropSet.dwHighDateTime == 0)
    {
        return;
    }

    // if ftPropSet < ftStart || ftNow < ftPropSet, error
    Check(TRUE,  ftStart <= ftPropSet && ftPropSet <= ftNow );
}


void
CheckStat(  IPropertyStorage *pPropSet, REFFMTID fmtid,
            REFCLSID clsid, ULONG PropSetFlag,
            const FILETIME & ftStart, DWORD dwOSVersion )
{
    STATPROPSETSTG StatPropSetStg;
    Check(S_OK, pPropSet->Stat(&StatPropSetStg));

    Check(TRUE, StatPropSetStg.fmtid == fmtid);
    Check(TRUE, StatPropSetStg.clsid == clsid);
    Check(TRUE, StatPropSetStg.grfFlags == PropSetFlag);
    Check(TRUE, StatPropSetStg.dwOSVersion == dwOSVersion);
    CheckTime(ftStart, StatPropSetStg.mtime);
    CheckTime(ftStart, StatPropSetStg.ctime);
    CheckTime(ftStart, StatPropSetStg.atime);
}


BOOL
IsEqualSTATPROPSTG(const STATPROPSTG *p1, const STATPROPSTG *p2)
{
    BOOL f1 = p1->propid == p2->propid;
    BOOL f2 = p1->vt == p2->vt;
    BOOL f3 = (p1->lpwstrName == NULL && p2->lpwstrName == NULL) ||
              ((p1->lpwstrName != NULL && p2->lpwstrName != NULL) &&
               ocscmp(p1->lpwstrName, p2->lpwstrName) == 0);
    return(f1 && f2 && f3);
}


void
CreateCodePageTestFile( LPOLESTR poszFileName, IStorage **ppStg )
{
    Check(TRUE,  poszFileName != NULL );

    //  --------------
    //  Initialization
    //  --------------

    TSafeStorage< IPropertySetStorage > pPSStg;
    TSafeStorage< IPropertyStorage > pPStg;

    PROPSPEC propspec;
    CPropVariant cpropvar;

    *ppStg = NULL;

    // Create the Docfile.

    Check(S_OK, g_pfnStgCreateStorageEx( poszFileName,
                                    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    DetermineStgFmt( g_enumImplementation ),
                                    0, NULL, NULL,
                                    DetermineStgIID( g_enumImplementation ),
                                    reinterpret_cast<void**>(ppStg) ));

    // Get an IPropertySetStorage

    Check(S_OK, StgToPropSetStg( *ppStg, &pPSStg ));

    // Create an IPropertyStorage

    Check(S_OK, pPSStg->Create( FMTID_NULL,
                                NULL,
                                PROPSETFLAG_ANSI,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));

    //  ----------------------
    //  Write a named property
    //  ----------------------

    // Write a named I4 property

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = CODEPAGE_TEST_NAMED_PROPERTY;

    cpropvar = (LONG) 0x12345678;
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    //  --------------------------
    //  Write singleton properties
    //  --------------------------

    // Write an un-named BSTR.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_BSTR_PROPID;

    cpropvar.SetBSTR( OLESTR("BSTR Property") );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Write an un-named I4

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_I4_PROPID;

    cpropvar = (LONG) 0x76543210;
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    //  -----------------------
    //  Write vector properties
    //  -----------------------

    // Write a vector of BSTRs.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VBSTR_PROPID;

    cpropvar.SetBSTR( OLESTR("BSTR Element 1"), 1 );
    cpropvar.SetBSTR( OLESTR("BSTR Element 0"), 0 );
    Check(TRUE,  (VT_VECTOR | VT_BSTR) == cpropvar.VarType() );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    //  -------------------------------
    //  Write Variant Vector Properties
    //  -------------------------------

    // Write a variant vector that has a BSTR

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VPROPVAR_BSTR_PROPID;

    CPropVariant cpropvarT;
    cpropvarT.SetBSTR( OLESTR("PropVar Vector BSTR") );
    cpropvar[1] = (PROPVARIANT) cpropvarT;
    cpropvar[0] = (PROPVARIANT) CPropVariant((long) 44);
    Check(TRUE,  (VT_VARIANT | VT_VECTOR) == cpropvar.VarType() );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

}   // CreateCodePageTestFile()


void
ModifyPropSetCodePage( IStorage *pStg, const FMTID &fmtid, USHORT usCodePage )
{

    Check(TRUE,  pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    DWORD dwVT;
    ULONG cbWritten = 0;
    TSafeStorage< IStream > pStm;
    CPropVariant cpropvar;

    // Open the Stream

    RtlGuidToPropertySetName( &fmtid, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                  NULL,
                                  &pStm ));

    // Seek to the codepage property
    SeekToProperty( pStm, PID_CODEPAGE );

    // Move past the VT
    Check(S_OK, pStm->Read( &dwVT, sizeof(DWORD), NULL ));

    // Write the new code page.

    PropByteSwap( &usCodePage );
    Check(S_OK, pStm->Write( &usCodePage, sizeof(usCodePage), &cbWritten ));
    Check(TRUE, cbWritten == sizeof(usCodePage) );

}   // ModifyPropSetCodePage()

void
ModifyPropertyType( IStorage *pStg, const FMTID &fmtid, PROPID propid, VARTYPE vt )
{

    Check(TRUE,  pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    DWORD dwVT;
    ULONG cbWritten = 0;
    TSafeStorage< IStream > pStm;
    CPropVariant cpropvar;

    // Open the Stream

    RtlGuidToPropertySetName( &fmtid, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                  NULL,
                                  &pStm ));

    // Seek to the property
    SeekToProperty( pStm, propid );

    // Write the new VT

    PropByteSwap( &vt );
    Check(S_OK, pStm->Write( &vt, sizeof(DWORD), &cbWritten ));
    Check(TRUE, cbWritten == sizeof(DWORD) );

}   // ModifyPropertyType()


void
SeekToProperty( IStream *pStm, PROPID propidSearch )
{

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    DWORD dwOffset = 0;
    DWORD dwcbSection = 0;
    DWORD dwcProperties = 0;
    ULONG ulcbWritten = 0;

    LARGE_INTEGER   liSectionOffset, liCodePageOffset;

    CPropVariant cpropvar;

    // Seek past the propset header and the format ID.

    liSectionOffset.HighPart = 0;
    liSectionOffset.LowPart = sizeof(PROPERTYSETHEADER) + sizeof(FMTID);
    Check(S_OK, pStm->Seek(liSectionOffset, STREAM_SEEK_SET, NULL ));

    // Move to the beginning of the property set.

    liSectionOffset.HighPart = 0;
    Check(S_OK, pStm->Read( &liSectionOffset.LowPart, sizeof(DWORD), NULL ));
    PropByteSwap(&liSectionOffset.LowPart);
    Check(S_OK, pStm->Seek( liSectionOffset, STREAM_SEEK_SET, NULL ));

    // Get the section size & property count.

    Check(S_OK, pStm->Read( &dwcbSection, sizeof(DWORD), NULL ));
    PropByteSwap( &dwcbSection );

    Check(S_OK, pStm->Read( &dwcProperties, sizeof(DWORD), NULL ));
    PropByteSwap( &dwcProperties );

    // Scan for the property.

    for( ULONG ulIndex = 0; ulIndex < dwcProperties; ulIndex++ )
    {
        PROPID propid;

        // Read in the PROPID
        Check(S_OK, pStm->Read( &propid, sizeof(PROPID), NULL ));

        // Read in this PROPIDs offset (we may not need it, but we want
        // to seek past it.
        Check(S_OK, pStm->Read( &dwOffset, sizeof(dwOffset), NULL ));
        PropByteSwap(dwOffset);

        // Is it the one we're looking for?
        if( PropByteSwap(propid) == propidSearch )
            break;

    }

    // Verify that the above for loop terminated because we found
    // the codepage.
    Check( TRUE, ulIndex < dwcProperties );

    // Move to the property.

    liSectionOffset.LowPart += dwOffset;
    Check(S_OK, pStm->Seek( liSectionOffset, STREAM_SEEK_SET, NULL ));

    return;

}   // SeekToProperty()





void
ModifyOSVersion( IStorage* pStg, DWORD dwOSVersion )
{

    Check(TRUE,  pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    ULONG ulcbWritten = 0;

    LARGE_INTEGER   liOffset;
    TSafeStorage< IStream > pStm;

    // Open the Stream

    RtlGuidToPropertySetName( &FMTID_NULL, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                  NULL,
                                  &pStm ));


    // Seek to the OS Version field in the header.

    liOffset.HighPart = 0;
    liOffset.LowPart = sizeof(WORD) /*(byte-order)*/ + sizeof(WORD) /*(format)*/ ;
    Check(S_OK, pStm->Seek( liOffset, STREAM_SEEK_SET, NULL ));

    // Set the new OS Version

    PropByteSwap( &dwOSVersion );
    Check(S_OK, pStm->Write( &dwOSVersion, sizeof(dwOSVersion), &ulcbWritten ));
    Check(TRUE, ulcbWritten == sizeof(dwOSVersion) );


}   // ModifyOSVersion()



//+---------------------------------------------------------
//
//  Function:   MungePropertyStorage
//
//  Synopsis:   This routine munges the properties in a
//              Property Storage.  The values of the properties
//              remain the same, but the underlying serialization
//              is new (the properties are read, the property
//              storage is deleted, and the properties are
//              re-written).
//
//  Inputs:     [IPropertySetStorage*] ppropsetgstg (in)
//                  The Property Storage container.
//              [FMTID] fmtid
//                  The Property Storage to munge.
//
//  Returns:    None.
//
//  Note:       Property names in the dictionary for which
//              there is no property are not munged.
//
//+---------------------------------------------------------

#define MUNGE_PROPVARIANT_STEP  10

void
MungePropertyStorage( IPropertySetStorage *ppropsetstg,
                      FMTID fmtid )
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    ULONG celt, ulIndex;
    TSafeStorage< IPropertyStorage > ppropstg;

    IEnumSTATPROPSTG *penumstatpropstg;

    PROPVARIANT *rgpropvar = NULL;
    STATPROPSTG *rgstatpropstg = NULL;
    ULONG        cProperties = 0;

    // Allocate an array of PropVariants.  We may grow this later.
    rgpropvar = new PROPVARIANT[ MUNGE_PROPVARIANT_STEP ];
    Check( FALSE, NULL == rgpropvar );

    // Allocate an array of STATPROPSTGs.  We may grow this also.
    rgstatpropstg = new STATPROPSTG[ MUNGE_PROPVARIANT_STEP ];
    Check( FALSE, NULL == rgstatpropstg );

    //  -----------------
    //  Get an Enumerator
    //  -----------------

    // Open the Property Storage.  We may get an error if we're attempting
    // the UserDefined propset.  If it's file-not-found, then simply return,
    // it's not an error, and there's nothing to do.

    hr = ppropsetstg->Open( fmtid,
                            STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            &ppropstg );
    if( FMTID_UserDefinedProperties == fmtid
        &&
        (HRESULT) STG_E_FILENOTFOUND == hr )
    {
        goto Exit;
    }
    Check( S_OK, hr );

    // Get an Enumerator
    Check(S_OK, ppropstg->Enum( &penumstatpropstg ));


    //  --------------------------------------------
    //  Read & delete in all of the properties/names
    //  --------------------------------------------

    // Get the first property from the enumerator
    hr = penumstatpropstg->Next( 1, &rgstatpropstg[cProperties], &celt );
    Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );

    // Iterate through the properties.
    while( celt > 0 )
    {
        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = rgstatpropstg[cProperties].propid;

        // Read and delete the property

        Check(S_OK, ppropstg->ReadMultiple( 1, &propspec, &rgpropvar[cProperties] ));
        Check(S_OK, ppropstg->DeleteMultiple( 1, &propspec ));

        // If there is a property name, delete it also.

        if( NULL != rgstatpropstg[cProperties].lpwstrName )
        {
            // We have a name.
            Check(S_OK, ppropstg->DeletePropertyNames( 1, &rgstatpropstg[cProperties].propid ));
        }

        // Increment the property count.
        cProperties++;

        // Do we need to grow the arrays?

        if( 0 != cProperties
            &&
            (cProperties % MUNGE_PROPVARIANT_STEP) == 0 )
        {
            // Yes - they must be reallocated.

            rgpropvar = (PROPVARIANT*)
                        CoTaskMemRealloc( rgpropvar,
                                          ( (cProperties + MUNGE_PROPVARIANT_STEP)
                                            *
                                            sizeof(*rgpropvar)
                                          ));
            Check( FALSE, NULL == rgpropvar );

            rgstatpropstg = (STATPROPSTG*)
                            CoTaskMemRealloc( rgstatpropstg,
                                              ( (cProperties + MUNGE_PROPVARIANT_STEP)
                                                 *
                                                 sizeof(*rgstatpropstg)
                                              ));
            Check( FALSE, NULL == rgstatpropstg );
        }

        // Move on to the next property.
        hr = penumstatpropstg->Next( 1, &rgstatpropstg[cProperties], &celt );
        Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );

    }   // while( celt > 0 )


    //  -------------------------------------
    //  Write the properties & names back out
    //  -------------------------------------

    for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
    {

        // Write the property.

        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = rgstatpropstg[ ulIndex ].propid;

        Check(S_OK, ppropstg->WriteMultiple(1, &propspec, &rgpropvar[ulIndex], PID_FIRST_USABLE ));

        // If this property has a name, write it too.
        if( rgstatpropstg[ ulIndex ].lpwstrName != NULL )
        {
            Check(S_OK, ppropstg->WritePropertyNames(
                                            1,
                                            &rgstatpropstg[ulIndex].propid,
                                            &rgstatpropstg[ulIndex].lpwstrName ));
        }

    }   // for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )


    //  ----
    //  Exit
    //  ----

Exit:

    if( penumstatpropstg )
    {
        penumstatpropstg->Release();
        penumstatpropstg = NULL;
    }

    // Free the PropVariants
    if( rgpropvar )
    {
        g_pfnFreePropVariantArray( cProperties, rgpropvar );
        delete [] rgpropvar;
    }

    // Free the property names
    if( rgstatpropstg )
    {
        for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
        {
            if( NULL != rgstatpropstg[ ulIndex ].lpwstrName )
            {
                delete [] rgstatpropstg[ ulIndex ].lpwstrName;
            }
        }   // for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )

        delete [] rgstatpropstg;
    }


}   // MungePropertyStorage

//+---------------------------------------------------------
//
//  Function:   MungeStorage
//
//  Synopsis:   This routine munges the property sets in a
//              Storage.  The properties themselves are not
//              modified, but the serialized bytes are.
//              For each property set, all the properties are
//              read, the property set is deleted, and
//              the properties are re-written.
//
//  Inputs:     [IStorage*] pstg (in)
//                  The Storage to munge.
//
//  Returns:    None.
//
//  Note:       This routine only munges simple property
//              sets.
//
//+---------------------------------------------------------

void
MungeStorage( IStorage *pstg )
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    ULONG celt;

    STATPROPSETSTG statpropsetstg;
    STATSTG statstg;

    TSafeStorage< IPropertySetStorage > ppropsetstg;
    TSafeStorage< IPropertyStorage > ppropstg;

    IEnumSTATPROPSETSTG *penumstatpropsetstg;
    IEnumSTATSTG *penumstatstg;

    //  -----------------------------------------------
    //  Munge each of the property sets in this Storage
    //  -----------------------------------------------

    // Get the IPropertySetStorage interface
    Check(S_OK, StgToPropSetStg( pstg, &ppropsetstg ));

    // Get a property storage enumerator
    Check(S_OK, ppropsetstg->Enum( &penumstatpropsetstg ));

    // Get the first STATPROPSETSTG
    hr = penumstatpropsetstg->Next( 1, &statpropsetstg, &celt );
    Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );

    // Loop through the STATPROPSETSTGs.
    while( celt > 0 )
    {
        // Is this a simple property storage (we don't
        // handle non-simple sets)?

        if( !(statpropsetstg.grfFlags & PROPSETFLAG_NONSIMPLE) )
        {
            // Munge the Property Storage.
            MungePropertyStorage( ppropsetstg, statpropsetstg.fmtid );
        }

        // Get the next STATPROPSETSTG
        // If we just did the first section of the DocSumInfo
        // property set, then attempt the second section.

        if( FMTID_DocSummaryInformation == statpropsetstg.fmtid )
        {
            statpropsetstg.fmtid = FMTID_UserDefinedProperties;
        }
        else
        {
            hr = penumstatpropsetstg->Next( 1, &statpropsetstg, &celt );
            Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );
        }
    }

    // We're done with the Property Storage enumerator.
    penumstatpropsetstg->Release();
    penumstatpropsetstg = NULL;

    //  ------------------------------------------
    //  Recursively munge each of the sub-storages
    //  ------------------------------------------

    // Get the IEnumSTATSTG enumerator
    Check(S_OK, pstg->EnumElements( 0L, NULL, 0L, &penumstatstg ));

    // Get the first STATSTG structure.
    hr = penumstatstg->Next( 1, &statstg, &celt );
    Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );

    // Loop through the elements of this Storage.
    while( celt > 0 )
    {
        // Is this a sub-Storage which must be
        // munged?

        if( STGTY_STORAGE & statstg.type  // This is a Storage
            &&
            0x20 <= *statstg.pwcsName )   // But not a system Storage.
        {
            // We'll munge it.
            IStorage *psubstg;

            // Open the sub-storage.
            Check(S_OK, pstg->OpenStorage( statstg.pwcsName,
                                           NULL,
                                           STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                           NULL,
                                           0L,
                                           &psubstg ));

            // Munge the sub-storage.
            MungeStorage( psubstg );
            psubstg->Release();
            psubstg = NULL;
        }

        delete [] statstg.pwcsName;
        statstg.pwcsName = NULL;

        // Move on to the next Storage element.
        hr = penumstatstg->Next( 1, &statstg, &celt );
        Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );
    }

    penumstatstg->Release();
    penumstatstg = NULL;


}   // MungeStorage



//+----------------------------------------------------------------------------
//+----------------------------------------------------------------------------

CLSID CObjectWithPersistStorage::_clsid = { /* 01c0652e-c97c-11d1-b2a8-00c04fb9386d */
    0x01c0652e,
    0xc97c,
    0x11d1,
    {0xb2, 0xa8, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };

CObjectWithPersistStorage::CObjectWithPersistStorage()
{
    _poszData = NULL;
    _cRefs = 1;
    _fDirty = FALSE;
}

CObjectWithPersistStorage::CObjectWithPersistStorage( const OLECHAR *posz )
{
    new(this) CObjectWithPersistStorage;
    _poszData = new OLECHAR[ ocslen(posz) + 1 ];
    Check( TRUE, NULL != _poszData );
    ocscpy( _poszData, posz );
    _fDirty = TRUE;
}

CObjectWithPersistStorage::~CObjectWithPersistStorage()
{
    delete[] _poszData;
}


ULONG
CObjectWithPersistStorage::AddRef()
{
    ULONG cRefs = InterlockedIncrement( &_cRefs );
    return( cRefs );
}

ULONG
CObjectWithPersistStorage::Release()
{
    ULONG cRefs = InterlockedDecrement( &_cRefs );
    if( 0 == cRefs )
        delete this;

    return( cRefs );
}


HRESULT
CObjectWithPersistStorage::QueryInterface( REFIID iid, void **ppvObject )
{
    if( IID_IPersistStorage == iid || IID_IUnknown == iid )
    {
        *ppvObject = static_cast<IPersistStorage*>(this);
        AddRef();
        return( S_OK );
    }
    else
        return( E_NOINTERFACE );
}


HRESULT
CObjectWithPersistStorage::GetClassID( CLSID *pclsid )
{
    *pclsid = GetClassID();
    return( S_OK );
}


HRESULT
CObjectWithPersistStorage::IsDirty( void)
{
    return( _fDirty );
}

HRESULT
CObjectWithPersistStorage::InitNew(
        /* [unique][in] */ IStorage __RPC_FAR *pStg)
{
    return( E_NOTIMPL );
}

HRESULT
CObjectWithPersistStorage::Load(
        /* [unique][in] */ IStorage __RPC_FAR *pStg)
{
    IStream *pStm = NULL;
    ULONG cbRead;

    Check( S_OK, pStg->OpenStream( OLESTR("CObjectWithPersistStorage"), NULL,
                                   STGM_READWRITE|STGM_SHARE_EXCLUSIVE, 0, &pStm ));

    _poszData = new OLECHAR[ MAX_PATH ];
    Check( TRUE, NULL != _poszData );

    Check( S_OK, pStm->Read( _poszData, sizeof(OLECHAR)*MAX_PATH, &cbRead ));
    _poszData[ MAX_PATH-1 ] = OLESTR('\0');

    Check( 0, RELEASE_INTERFACE( pStm ));

    return( S_OK );
}

HRESULT
CObjectWithPersistStorage::Save(
        /* [unique][in] */ IStorage __RPC_FAR *pStgSave,
        /* [in] */ BOOL fSameAsLoad)
{
    IStream *pStm = NULL;
    ULONG cbData, cbWritten;

    Check( S_OK, pStgSave->CreateStream( OLESTR("CObjectWithPersistStorage"),
                                         STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                         0, 0, &pStm ));

    cbData = sizeof(OLECHAR)*( 1 + ocslen(_poszData) );
    Check( S_OK, pStm->Write( _poszData, cbData, &cbWritten ));
    Check( TRUE, cbData == cbWritten );
    Check( 0, RELEASE_INTERFACE(pStm) );

    return( S_OK );
}


HRESULT
CObjectWithPersistStorage::SaveCompleted(
        /* [unique][in] */ IStorage __RPC_FAR *pStgNew)
{
    return( S_OK );
}

HRESULT
CObjectWithPersistStorage::HandsOffStorage( void)
{
    return( E_NOTIMPL );
}


BOOL
CObjectWithPersistStorage::operator ==( const CObjectWithPersistStorage &Other )
{
    return( Other._poszData == _poszData
            ||
            0 == ocscmp( Other._poszData, _poszData ));
}



CLSID
CObjectWithPersistStream::_clsid= { /* b447cba0-c991-11d1-b2a8-00c04fb9386d */
    0xb447cba0,
    0xc991,
    0x11d1,
    {0xb2, 0xa8, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };


CObjectWithPersistStream::CObjectWithPersistStream()
{
    _poszData = NULL;
    _cRefs = 1;
    _fDirty = FALSE;
}

CObjectWithPersistStream::CObjectWithPersistStream( const OLECHAR *posz )
{
    new(this) CObjectWithPersistStream;
    _poszData = new OLECHAR[ ocslen(posz) + 1 ];
    Check( TRUE, NULL != _poszData );
    ocscpy( _poszData, posz );
    _fDirty = TRUE;
}

CObjectWithPersistStream::~CObjectWithPersistStream()
{
    delete[] _poszData;
}


ULONG
CObjectWithPersistStream::AddRef()
{
    ULONG cRefs = InterlockedIncrement( &_cRefs );
    return( cRefs );
}

ULONG
CObjectWithPersistStream::Release()
{
    ULONG cRefs = InterlockedDecrement( &_cRefs );
    if( 0 == cRefs )
        delete this;

    return( cRefs );
}


HRESULT
CObjectWithPersistStream::QueryInterface( REFIID iid, void **ppvObject )
{
    if( IID_IPersistStream == iid || IID_IUnknown == iid )
    {
        *ppvObject = static_cast<IPersistStream*>(this);
        AddRef();
        return( S_OK );
    }
    else
        return( E_NOINTERFACE );
}


HRESULT
CObjectWithPersistStream::GetClassID( CLSID *pclsid )
{
    *pclsid = GetClassID();
    return( S_OK );
}


HRESULT
CObjectWithPersistStream::IsDirty( void)
{
    return( _fDirty );
}



HRESULT
CObjectWithPersistStream::Load(
       /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    ULONG cbRead;

    _poszData = new OLECHAR[ MAX_PATH ];
    Check( TRUE, NULL != _poszData );

    Check( S_OK, pStm->Read( _poszData, sizeof(OLECHAR)*MAX_PATH, &cbRead ));
    _poszData[ MAX_PATH-1 ] = OLESTR('\0');

    return( S_OK );
}

HRESULT
CObjectWithPersistStream::Save(
       /* [unique][in] */ IStream __RPC_FAR *pStm,
       /* [in] */ BOOL fClearDirty)
{
    ULONG cbData, cbWritten;

    cbData = sizeof(OLECHAR)*( 1 + ocslen(_poszData) );
    Check( S_OK, pStm->Write( _poszData, cbData, &cbWritten ));
    Check( TRUE, cbData == cbWritten );

    return( S_OK );
}

HRESULT
CObjectWithPersistStream::GetSizeMax(
   /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
    return( E_NOTIMPL );
}

BOOL
CObjectWithPersistStream::operator ==( const CObjectWithPersistStream &Other )
{
    return( Other._poszData == _poszData
            ||
            0 == ocscmp( Other._poszData, _poszData ));
}



//+----------------------------------------------------------------------------
//+----------------------------------------------------------------------------

void
DeleteBagExProperties( IPropertyBagEx *pbag, const OLECHAR *poszPrefix )
{
    HRESULT hr = S_OK;
    IEnumSTATPROPBAG *penum = NULL;
    STATPROPBAG statpropbag;

    // Get an enumerator of the properties to be deleted.

    Check( S_OK, pbag->Enum( poszPrefix, 0, &penum ));

    // Loop through and delete the properties

    hr = penum->Next(1, &statpropbag, NULL );
    Check( TRUE, SUCCEEDED(hr) );

    while( S_OK == hr )
    {
        Check( S_OK, pbag->DeleteMultiple(1, &statpropbag.lpwstrName, 0 ));

        delete [] statpropbag.lpwstrName;
        statpropbag.lpwstrName = NULL;

        hr = penum->Next(1, &statpropbag, NULL );
        Check( TRUE, SUCCEEDED(hr) );

    }   // while( S_OK == hr )

    RELEASE_INTERFACE(penum);

    return;

}   // EmptyPropertyBagEx



//+----------------------------------------------------------------------------
//
//  Function:   DetermineSystemInfo
//
//  Synopsis:   Fill in the g_SystemInfo structure.
//
//  Inputs:     None.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void DetermineSystemInfo()
{
    // Initilize g_SystemInfo.

    g_SystemInfo.osenum = osenumUnknown;
    g_SystemInfo.fIPropMarshaling = FALSE;

#ifdef _MAC

    // Set the OS type.
    g_SystemInfo.osenum = osenumMac;

#else

    DWORD dwVersion;

    // Get the OS Version
    dwVersion = GetVersion();

    // Is this an NT system?

    if( (dwVersion & 0x80000000) == 0 )
    {
        // Is this at least NT4?
        if( LOBYTE(LOWORD( dwVersion )) >= 4 )
            g_SystemInfo.osenum = osenumNT4;

        // Or, is this pre-NT4?
        else
        if( LOBYTE(LOWORD( dwVersion )) == 3 )
        {
            g_SystemInfo.osenum = osenumNT3;
        }
    }

    // Otherwise, this is some kind of Win95 machine.
    else
    {
        HINSTANCE hinst;
        FARPROC farproc;

        // Load OLE32, and see if CoIntializeEx exists.  If it does,
        // then DCOM95 is installed.  Otherwise, this is just the base
        // Win95.

        hinst = LoadLibraryA( "ole32.dll" );
        Check( TRUE, hinst != NULL );

        farproc = GetProcAddress( hinst, "CoInitializeEx" );

        if( NULL != farproc )
        {
            g_SystemInfo.osenum = osenumDCOM95;
        }
        else if( ERROR_PROC_NOT_FOUND == GetLastError() )
        {
            g_SystemInfo.osenum = osenumWin95;
        }
    }   // if( (dwVersion & 0x80000000) == 0 )

    Check( TRUE, g_SystemInfo.osenum != osenumUnknown );

#endif // #ifdef _MAC ... #else

    if( osenumWin95 == g_SystemInfo.osenum
        ||
        osenumNT3 == g_SystemInfo.osenum
      )
    {
        g_SystemInfo.fIPropMarshaling = TRUE;
    }
}


void
DisplayUsage( LPSTR pszCommand )
{
#ifndef _MAC
    printf("\n");
    printf("   Usage: %s [options]\n", pszCommand);
    printf("   Options:\n");
    printf("      /s  run Standard tests\n" );
    printf("      /w  run the Word 6 test\n");
    printf("      /m  run the Marshaling test\n");
    printf("      /c  run the CoFileTimeNow\n");
    printf("      /p  run the Performance test\n");
    printf("      /a  run All tests\n" );
    printf("      /k  run the simple leaK test\n" );
    printf("      /n  use nt5props.dll rather than ole32.dll where possible\n");
    printf("          (mostly for STGFMT_FILE)\n" );
    printf("\n");
    printf("      /i# Implementation to use:\n");
    printf("             0 => Use DocFile and QI for IPropSetStg (default)\n");
    printf("             1 => Use DocFile and use Stg*Prop*Stg\n");
    printf("             3 => Use NSS\n");
    printf("             4 => Use NTFS native property sets\n");
    printf("      /l  Don't register the local server\n");
    printf("      /v  Verbose output\n" );
    printf("\n");
    printf("   File & Directory Options:\n" );
    printf("      /t <directory> specifies temporary directory\n" );
    printf("          (used during standard & optional tests - if not specified,\n" );
    printf("          a default will be used)\n" );
    printf("      /g <file> specifies a file to be munGed\n" );
    printf("          (propsets are read, deleted, & re-written)\n" );
    printf("      /d <file> specifies a file to be Dumped\n" );
    printf("          (propsets are dumped to stdout\n" );
    printf("\n");
    printf("   For Example:\n" );
    printf("      %s -smw /i1 -t d:\\test\n", pszCommand );
    printf("      %s -d word6.doc\n", pszCommand );
    printf("      %s -g word6.doc\n", pszCommand );
    printf("\n");

#endif

    return;
}



ULONG
ProcessCommandLine( int cArg, const LPSTR rgszArg[],
                    LPSTR *ppszFileToDump, LPSTR *ppszFileToMunge, LPSTR *ppszTemporaryDirectory )
{
    ULONG ulTestOptions = 0;
    ULONG ulTestOptionsT = 0;
    int nArgIndex;

    if( 2 > cArg )
    {
        goto Exit;
    }

    for( nArgIndex = 1; nArgIndex < cArg; nArgIndex++ )
    {
        if( rgszArg[nArgIndex][0] == '/'
            ||
            rgszArg[nArgIndex][0] == '-'
          )
        {
            BOOL fNextArgument = FALSE;

            for( int nOptionSubIndex = 1;
                 rgszArg[nArgIndex][nOptionSubIndex] != '\0' && !fNextArgument;
                 nOptionSubIndex++
               )
            {
                switch( rgszArg[nArgIndex][nOptionSubIndex] )
                {
                    case 's':
                    case 'S':

                        ulTestOptionsT |= TEST_STANDARD;
                        break;

                    case 'a':
                    case 'A':

                        ulTestOptionsT |= TEST_WORD6 | TEST_MARSHALING | TEST_COFILETIMENOW | TEST_PERFORMANCE;
                        break;

                    case 'g':
                    case 'G':

                        if( NULL != *ppszFileToMunge )
                            printf( "Error:  Only one file may be munged\n" );
                        else
                        {
                            nArgIndex++;
                            *ppszFileToMunge = &rgszArg[nArgIndex][0];
                            fNextArgument = TRUE;
                            if(**ppszFileToMunge == '-' || **ppszFileToMunge == '/')
                            {
                                printf( "Error:  Missing filename for munge option\n" );
                                goto Exit;
                            }
                        }
                        break;

                    case 'w':
                    case 'W':

                        ulTestOptionsT |= TEST_WORD6;
                        break;

                    case 'm':
                    case 'M':

                        ulTestOptionsT |= TEST_MARSHALING;
                        break;

                    case 'k':
                    case 'K':

                        ulTestOptionsT |= TEST_SIMPLE_LEAKS;
                        break;

                    case 'c':
                    case 'C':

                        ulTestOptionsT |= TEST_COFILETIMENOW;
                        break;

                    case 'p':
                    case 'P':

                        ulTestOptionsT |= TEST_PERFORMANCE;
                        break;

                    case 'i':
                    case 'I':
                    {
                        int nSubOption = rgszArg[nArgIndex][++nOptionSubIndex];

                        if( PROPIMP_UNKNOWN != g_enumImplementation )
                        {
                            printf( "Error in \"/i\" option (too many occurrences)\n" );
                            goto Exit;
                        }

                        switch( nSubOption )
                        {
                            case '0':   // default, if unspecified

                                g_enumImplementation = PROPIMP_DOCFILE_QI;
                                break;

                            case '1':

                                g_enumImplementation = PROPIMP_DOCFILE_OLE32;
                                break;

                            case '3':

                                g_enumImplementation = PROPIMP_STORAGE;
                                break;

                            case '4':

                                g_enumImplementation = PROPIMP_NTFS;
                                break;

                            default:

                                printf( "Error in \"/i\" option\n" );
                                goto Exit;
                        }

                        break;
                    }

                    case 't':
                    case 'T':

                        if( NULL != *ppszTemporaryDirectory )
                        {
                            printf( "Error:  Only one temporary directory may be specified\n" );
                        }
                        else
                        {
                            nArgIndex++;
                            *ppszTemporaryDirectory = &rgszArg[nArgIndex][0];
                            fNextArgument = TRUE;
                            if(**ppszTemporaryDirectory == '-'
                                ||
                               **ppszTemporaryDirectory == '/'
                              )
                            {
                                printf( "Error:  Missing name for temporary directory option\n" );
                                goto Exit;
                            }
                        }
                        break;

                    case 'l':
                    case 'L':

                        g_fRegisterLocalServer = FALSE;
                        break;

                    case 'n':
                    case 'N':

                        g_fUseNt5PropsDll = TRUE;
                        break;

                    case '?':

                        return( FALSE );
                        break;

                    case 'd':
                    case 'D':

                        if( NULL != *ppszFileToDump )
                        {
                            printf( "Error:  Only one file may be dumped\n" );
                            goto Exit;
                        }
                        else
                        {
                            nOptionSubIndex++;
                            switch (rgszArg[nArgIndex][nOptionSubIndex])
                            {
                            case 's':
                                g_stgmDumpFlags = STGM_SIMPLE;
                                break;
                            case '\0':
                                break;
                            default:
                                printf( "Error:  Invalid Flag used with dump option\n" );
                                return( FALSE );
                                break;
                            }
                            nArgIndex++;
                            *ppszFileToDump = &rgszArg[nArgIndex][0];
                            fNextArgument = TRUE;
                            if(**ppszFileToDump == '-' || **ppszFileToDump == '/')
                            {
                                printf( "Error:  Missing filename for dump option\n" );
                                goto Exit;
                            }
                        }
                        break;

                    case 'v':
                    case 'V':

                        g_fVerbose = TRUE;
                        break;

                    default:

                        printf( "Option '%c' ignored\n", rgszArg[nArgIndex][nOptionSubIndex] );
                        break;

                }   // switch( argv[nArgIndex][1] )

            }   // for( int nOptionSubIndex = 1; ...
        }   // if( argv[nArgIndex][0] == '/'
        else
        {
            break;
        }
    }   // for( ULONG nArgIndex = 2; nArgIndex < argc; nArgIndex++ )


    ulTestOptions = ulTestOptionsT;

    //  ----
    //  Exit
    //  ----

Exit:

    return( ulTestOptions );

}   // ProcessCommandLine




#define Out wprintf

NTSTATUS GetProcessInfo(
    PSYSTEM_PROCESS_INFORMATION pspi )
{

    NUMBERFMT NumberFmt;
    LCID lcid = GetUserDefaultLCID();

    typedef NTSTATUS (__stdcall*PFNNtQuerySystemInformation)(ULONG,BYTE*,ULONG,VOID*);
    static BYTE ab[81920];
    static HINSTANCE hinstNTDLL = NULL;
    static PFNNtQuerySystemInformation pfnNtQuerySystemInformation = NULL;

    WCHAR *pwcImage = L"proptest.exe";

    if( NULL == pfnNtQuerySystemInformation )
    {
        if( NULL == hinstNTDLL )
        {
            hinstNTDLL = LoadLibrary( TEXT("ntdll.dll") );
            Check( FALSE, NULL == hinstNTDLL );
        }

        pfnNtQuerySystemInformation = (PFNNtQuerySystemInformation)
                                      GetProcAddress( hinstNTDLL,
                                                      "NtQuerySystemInformation" );
        Check( FALSE, NULL == pfnNtQuerySystemInformation );
    }

    NTSTATUS status = pfnNtQuerySystemInformation( SystemProcessInformation,
                                                   ab,
                                                   sizeof ab,
                                                   NULL );

    if ( NT_SUCCESS( status ) )
    {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
        DWORD cbOffset = 0;
        PSYSTEM_PROCESS_INFORMATION p = 0;
        do
        {
            p = (PSYSTEM_PROCESS_INFORMATION)&(ab[cbOffset]);

            if ( ( L'*' == *pwcImage ) ||
                 ( 0 == *pwcImage ) ||
                 ( p->ImageName.Buffer &&
                   !_wcsicmp( pwcImage, p->ImageName.Buffer ) ) )
            {
                status = STATUS_SUCCESS;
                *pspi = *p;
                break;
            }

            cbOffset += p->NextEntryOffset;
        } while ( 0 != p->NextEntryOffset );
    }

    return( status );

} //GetProcessInfo


#ifdef _MAC
int __cdecl PropTestMain(int argc, char **argv, CDisplay *pcDisplay )
#else
int __cdecl main(int cArg, char *rgszArg[])
#endif
{
    ULONG ulTestOptions = 0L;
    CHAR* pszFileToMunge = NULL;
    CHAR* pszTemporaryDirectory = NULL;
    CHAR* pszFileToDump = NULL;

    #ifdef _MAC
        g_pcDisplay = pcDisplay;
        Check( S_OK, InitOleManager( OLEMGR_BIND_NORMAL ));

        #if DBG
            FnAssertOn( TRUE );
        #endif
    #endif

    // Print an appropriate header message

    #ifdef WINNT
    #ifdef _CAIRO_
        PRINTF("\nCairo Property Set Tests\n");
    #else
        PRINTF("\nSUR Property Set Tests\n");
    #endif
    #elif defined(_MAC)
        PRINTF("\nMacintosh Property Set Tests\n" );
    #else
        PRINTF("\nChicago Property Set Tests\n");
    #endif

    // Process the command-line

    ulTestOptions = ProcessCommandLine( cArg, rgszArg, &pszFileToDump, &pszFileToMunge, &pszTemporaryDirectory );
    if(( 0 == ulTestOptions ) && (NULL == pszFileToDump))
    {
        DisplayUsage( rgszArg[0] );
        exit(0);
    }

    // Ensure that that one of the "-i" options is specified.

    if( PROPIMP_UNKNOWN == g_enumImplementation )
    {
        g_enumImplementation = PROPIMP_DOCFILE_QI; // The default
    }

    if( PROPIMP_NTFS == g_enumImplementation )
        g_Restrictions = RESTRICT_DIRECT_ONLY | RESTRICT_NON_HIERARCHICAL;
    else
        g_Restrictions = RESTRICT_NONE;

    // This 'try' wraps the remainder of the routine.
    try
    {
        OLECHAR ocsDir[MAX_PATH+1], ocsTest[MAX_PATH+1],
                ocsTest2[MAX_PATH+1], ocsMarshalingTest[MAX_PATH+1],
                ocsTestOffice[MAX_PATH+1];

        CHAR    szDir[ MAX_PATH+1 ];
        CHAR    pszGeneratedTempDir[ MAX_PATH + 1 ];

        HRESULT hr;
        DWORD dwFileAttributes;

        UNREFERENCED_PARAMETER( dwFileAttributes );
        UNREFERENCED_PARAMETER( pszGeneratedTempDir );

        CoInitialize(NULL);

        ocscpy( ocsDir, OLESTR("") );

        //  ----------------------------------------------------
        //  Get the pointers to the necessary exported functions
        //  ----------------------------------------------------

        // We use explicit linking so that we can use either the OLE32.dll
        // or nt5props.dll exports.

        if( g_fUseNt5PropsDll )
        {
            // We're to use the propset APIs from nt5props.dll

            g_hinstDLL = LoadLibraryA( "nt5props.dll" );
            Check( TRUE, NULL != g_hinstDLL );

        }
        else
        {
            // We're to use the propset APIs from OLE32

            g_hinstDLL = LoadLibraryA( "ole32.dll" );
            Check( TRUE, NULL != g_hinstDLL );

        }

        g_pfnPropVariantCopy = (FNPROPVARIANTCOPY*)
                               GetProcAddress( g_hinstDLL,
                                               "PropVariantCopy" );
        Check( FALSE, NULL == g_pfnPropVariantCopy );

        g_pfnPropVariantClear = (FNPROPVARIANTCLEAR*)
                                GetProcAddress( g_hinstDLL,
                                                "PropVariantClear" );
        Check( FALSE, NULL == g_pfnPropVariantClear );

        g_pfnFreePropVariantArray = (FNFREEPROPVARIANTARRAY*)
                                    GetProcAddress( g_hinstDLL,
                                                    "FreePropVariantArray" );
        Check( FALSE, NULL == g_pfnFreePropVariantArray );

        g_pfnStgCreatePropSetStg = (FNSTGCREATEPROPSETSTG*)
                                   GetProcAddress( g_hinstDLL,
                                                   "StgCreatePropSetStg" );
        Check( FALSE, NULL == g_pfnStgCreatePropSetStg );

        g_pfnStgCreatePropStg = (FNSTGCREATEPROPSTG*)
                                GetProcAddress( g_hinstDLL,
                                                "StgCreatePropStg" );
        Check( FALSE, NULL == g_pfnStgCreatePropStg );

        g_pfnStgOpenPropStg = (FNSTGOPENPROPSTG*)
                              GetProcAddress( g_hinstDLL,
                                              "StgOpenPropStg" );
        Check( FALSE, NULL == g_pfnStgOpenPropStg );

        g_pfnFmtIdToPropStgName = (FNFMTIDTOPROPSTGNAME*)
                                  GetProcAddress( g_hinstDLL,
                                                  "FmtIdToPropStgName" );
        Check( FALSE, NULL == g_pfnFmtIdToPropStgName );

        g_pfnPropStgNameToFmtId = (FNPROPSTGNAMETOFMTID*)
                                  GetProcAddress( g_hinstDLL,
                                                  "PropStgNameToFmtId" );
        Check( FALSE, NULL == g_pfnPropStgNameToFmtId );

        g_pfnStgCreateStorageEx = (FNSTGCREATESTORAGEEX*)
                                  GetProcAddress( g_hinstDLL, "StgCreateStorageEx" );
        Check( FALSE, NULL == g_pfnStgCreateStorageEx );

        g_pfnStgOpenStorageEx = (FNSTGOPENSTORAGEEX*)
                                  GetProcAddress( g_hinstDLL, "StgOpenStorageEx" );
        Check( FALSE, NULL == g_pfnStgOpenStorageEx );

        g_pfnStgOpenStorageOnHandle = (FNSTGOPENSTORAGEONHANDLE*)
                                      GetProcAddress( g_hinstDLL, "StgOpenStorageOnHandle" );
        Check( FALSE, NULL == g_pfnStgOpenStorageOnHandle );

        /*
        g_pfnStgCreateStorageOnHandle = (FNSTGCREATESTORAGEONHANDLE*)
                                        GetProcAddress( g_hinstDLL, "StgCreateStorageOnHandle" );
        Check( FALSE, NULL == g_pfnStgCreateStorageOnHandle );
        */

        g_pfnStgPropertyLengthAsVariant = (FNSTGPROPERTYLENGTHASVARIANT*)
                                          GetProcAddress( g_hinstDLL, "StgPropertyLengthAsVariant" );
        Check( FALSE, NULL == g_pfnStgPropertyLengthAsVariant );

        g_pfnStgConvertVariantToProperty = (FNSTGCONVERTVARIANTTOPROPERTY*)
                                           GetProcAddress( g_hinstDLL, "StgConvertVariantToProperty" );
        Check( FALSE, NULL == g_pfnStgConvertVariantToProperty );

        g_pfnStgConvertPropertyToVariant = (FNSTGCONVERTPROPERTYTOVARIANT*)
                                           GetProcAddress( g_hinstDLL, "StgConvertPropertyToVariant" );
        Check( FALSE, NULL == g_pfnStgConvertPropertyToVariant );



        //  ------------------------
        //  Is there a file to dump?
        //  ------------------------

        if( NULL != pszFileToDump )
        {
            IStorage *pstg;
            IPropertySetStorage *pPropSetStg = NULL;
            IPropertyStorage *pPropStg = NULL;
            PROPSPEC psTest = {1, 2 }; // { 0, (ULONG) L"cimax" };
            PROPVARIANT propvar;

#if 0
            GUID const guidTest = { 0xCF2EAF90, 0x9311, 0x11CF, 0xBF, 0x8C,
                                    0x00, 0x20, 0xAF, 0xE5, 0x05, 0x08 };
            GetProcessInfo( L"proptest.exe" );
#endif

            PropTest_mbstoocs( ocsDir, sizeof(ocsDir), pszFileToDump );

            for( int i = 0; i < 1; i++ )
            {
                HRESULT     hr;

                if ( 0 == ( i % 100 ) )
                    printf(".");

                //
                // Attempt to open as docfile or NSS. If that fails,
                // then attempt to open as a FLAT_FILE.
                //
                hr = StgOpenStorageEx( ocsDir,
                                       g_stgmDumpFlags | STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                       STGFMT_ANY,
                                       0L,
                                       NULL,
                                       NULL,
                                       IID_IStorage,
                                       (PVOID*)&pstg );
                if (FAILED(hr))
                {
                    hr = StgOpenStorageEx( ocsDir,
                                           g_stgmDumpFlags | STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                           STGFMT_ANY,
                                           0L,
                                           NULL,
                                           NULL,
                                           IID_IPropertySetStorage,
                                           (PVOID*)&pPropSetStg );
                }
                Check(S_OK,hr);
                DumpOleStorage( pstg, pPropSetStg, ocsDir );

#if 0
                Check(S_OK, StgToPropSetStg( pstg, &pPropSetStg ));

                Check(S_OK, pPropSetStg->Open( guidTest,
                                               STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                               &pPropStg ));

                Check(S_OK, pPropStg->ReadMultiple( 1,
                                                    &psTest,
                                                    &propvar ));
                Check( TRUE, propvar.vt == VT_I4 );

                pPropStg->Release();

                pPropSetStg->Release();

#endif
                if (pstg)
                {
                    pstg->Release();
                }

            }

//            GetProcessInfo( L"proptest.exe" );

            printf( "Press enter key to exit ..." );
            getchar();

            return(0);
        }


        //  -------------------------
        //  Is there a file to munge?
        //  -------------------------

        if( NULL != pszFileToMunge )
        {
            IStorage *pstg;

            PropTest_mbstoocs( ocsDir, sizeof(ocsDir), pszFileToMunge );
            Check(S_OK, StgOpenStorage( ocsDir,
                                        NULL,
                                        STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        NULL,
                                        0L,
                                        &pstg ));
            MungeStorage( pstg );
            OPRINTF( OLESTR("\"%s\" successfully munged\n"), ocsDir );
            pstg->Release();
            return(0);
        }

        //  ----------------------------
        //  Create a temporary directory
        //  ----------------------------

        // If no temporary directory was specified, generate one.

    #ifndef _MAC
        if( NULL == pszTemporaryDirectory )
        {
            GetTempPathA(sizeof(pszGeneratedTempDir)/sizeof(pszGeneratedTempDir[0]), pszGeneratedTempDir);
            pszTemporaryDirectory = pszGeneratedTempDir;

        }

        // If necessary, add a path separator to the end of the
        // temp directory name.

        {
            CHAR chLast = pszTemporaryDirectory[ strlen(pszTemporaryDirectory) - 1];
            if( (CHAR) '\\' != chLast
                &&
                (CHAR) ':'  != chLast )
            {
                strcat( pszTemporaryDirectory, "\\" );
            }
        }
    #endif  // #ifndef _MAC

        int i=0;

    #ifndef _MAC
        // Verify that the user-provided directory path
        // exists

        dwFileAttributes = GetFileAttributesA( pszTemporaryDirectory );

        if( (DWORD) -1 ==  dwFileAttributes )
        {
            printf( "Error:  couldn't open temporary directory:  \"%s\"\n", pszTemporaryDirectory );
            exit(1);
        }
        else if( !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            printf( "Error:  \"%s\" is not a directory\n", pszTemporaryDirectory );
            exit(1);
        }

        // Find a new directory name to use for temporary
        // files ("PrpTstX", where "X" is a number).

        do
        {
            // Post-pend a subdirectory name and counter
            // to the temporary directory name.

            strcpy( szDir, pszTemporaryDirectory );
            strcat( szDir, "PrpTst" );
            sprintf( strchr(szDir,0), "%d", i++ );

        }
        while (!PropTest_CreateDirectory(szDir, NULL));

        printf( "Generated files will be put in \"%s\"\n", szDir );
        strcat( szDir, "\\" );

        // Convert to an OLESTR.
        PropTest_mbstoocs( ocsDir, sizeof(ocsDir), szDir );

    #endif  // #ifndef _MAC

        //  --------------------------------
        //  Create necessary temporary files
        //  --------------------------------

        // If any of the standard or extended tests will be run,
        // create "testdoc" and "testdoc2".

        if( ulTestOptions )
        {
            IPropertySetStorage *pPropSetStg;

            // Create "testdoc"

            ocscpy(ocsTest, ocsDir);
            ocscat(ocsTest, OLESTR("testdoc"));

            hr = g_pfnStgCreateStorageEx (
                    ocsTest,
                    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                    DetermineStgFmt( g_enumImplementation ),
                    0,
                    NULL,
                    NULL,
                    DetermineStgIID( g_enumImplementation ),
                    (void**) &_pstgTemp );
            if (hr != S_OK)
            {
                OPRINTF( OLESTR("Can't create %s\n"), ocsTest);
                exit(1);
            }

            // Create "testdoc2"

            ocscpy(ocsTest2, ocsDir);
            ocscat(ocsTest2, OLESTR("testdoc2"));

            hr = StgCreateDocfile(ocsTest2, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      0, &_pstgTempCopyTo);
            if (hr != S_OK)
            {
                OPRINTF(OLESTR("Can't create %s\n"), ocsTest2);
                exit(1);
            }


        }   // if( ulTestOptions )

        //  ---------------------
        //  Finish initialization
        //  ---------------------

        // Indicate what type of marshaling is being used:  OLE32 or IPROP.

        DetermineSystemInfo();
        if( g_SystemInfo.fIPropMarshaling )
            PRINTF( "Using IPROP.DLL for marshaling\n" );
        else
            PRINTF( "Using OLE32.DLL for marshaling\n" );

        // Populate an array of propvars for use in tests.

        Check(S_OK, PopulateRGPropVar( g_rgcpropvarAll, g_rgcpropspecAll, g_rgoszpropnameAll, _pstgTemp ));


        //  --------------
        //  Standard Tests
        //  --------------

        // These are the standard tests that should run in
        // any environment.

        if( ulTestOptions & TEST_STANDARD )
        {

            PRINTF( "\nStandard Tests: " );
            g_nIndent++;

            if( g_fVerbose )
                PRINTF( "\n---------------\n" );

            // Run the quick tests.
            test_WriteReadAllProperties( ocsDir );

            // The codepage & lcid should be settable iff the property set is ~empty
            test_SettingLocalization( _pstgTemp );

            // Test the StgOpenStorageOnHandle API
            test_StgOnHandle( ocsDir );

            // Test invalid VTs
            test_UnsupportedProperties( _pstgTemp );

            // Test support for the new (to NT5) VTs (VTs from the Variant)
            test_ExtendedTypes( _pstgTemp );

            // Test the calculation of external memory requirements.
            test_PropertyLengthAsVariant( );

            // Test VT_ARRAY
            test_SafeArray( _pstgTemp );

            // Test each of the interfaces
            test_PropertyInterfaces(_pstgTemp);

            // Test StgCreate/OpenPropStg on CreateStreamOnHGlobal
            test_PropsetOnHGlobal();

            // Test the read-only range of reserved PROPIDs
            test_ReadOnlyReservedProperties( _pstgTemp );

            // Writing PID_ILLEGAL should be silently ignored.
            test_PidIllegal( _pstgTemp );

            // Test the Standalone APIs
            test_StandaloneAPIs( ocsDir );

            // Test for robustness (NTFS only)
            //test_Robustness( ocsDir );

            // Test read-only open of file with no property sets (NTFS only)
            test_PropsetOnEmptyFile( ocsDir );

            // Test having two read-only readers.
            test_MultipleReader( ocsDir );

            // Test PROPSETFLAG_CASE_SENSITIVE & long names
            test_VersionOneNames( _pstgTemp );

            // Test the low-memory support in IMappedStream
            test_LowMemory( _pstgTemp );

            // Test VT_BYREF
            test_ByRef( _pstgTemp );

            // Run the property bag tests

            Status( "Bag Tests\n" );
            g_nIndent++;
            {
                test_IPropertyBag( _pstgTemp );

                test_BagVtUnknown( _pstgTemp );
                test_BagDelete( _pstgTemp );
                test_EmptyBag( ocsDir );
                test_BagEnum( _pstgTemp );
                test_BagCoercion( _pstgTemp );
                test_BagOpenMethod( _pstgTemp );
            }
            --g_nIndent;

            // Test that code pages are handled properly.
            test_CodePages( ocsDir );

            // Test the PROPSETFLAG_UNBUFFERED flag in Stg*PropStg APIs
            test_PROPSETFLAG_UNBUFFERED( _pstgTemp );

            // Test FMTID<->Name conversions
            test_PropStgNameConversion( _pstgTemp );

            // Test the FMTID<->Name conversion APIs
            test_PropStgNameConversion2( );

            // Test StgOpenStorageEx for NTFS flat file support.
            test_ex_api(ocsDir);

            // Test Simple Mode DocFile
            test_SimpleDocFile(ocsDir);

            // Test the IStorage::CopyTo operation, using all combinations of
            // direct and transacted mode for the base and PropSet storages.
            // We don't run this test on the Mac because it doesn't have IStorages
            // which support IPropertySetStorages.

            #ifndef _MAC_NODOC

            if( PROPIMP_STORAGE == g_enumImplementation
                ||
                PROPIMP_DOCFILE_QI == g_enumImplementation )
        {
            for( int iteration = 0; iteration < 4; iteration++ )
            {
            OLECHAR aocStorageName[] = OLESTR( "#0 Test CopyTo" );
            aocStorageName[1] = (OLECHAR) iteration + OLESTR('0');

            test_CopyTo( _pstgTemp, _pstgTempCopyTo,
                         iteration & 2 ? STGM_TRANSACTED : STGM_DIRECT,  // For the base Storage
                         iteration & 1 ? STGM_TRANSACTED : STGM_DIRECT,  // For the PropSet Storages
                         aocStorageName );
            }
        }

            #endif  // #ifndef _MAC_NODOC


            // Generate the stock ticker property set example
            // from the OLE programmer's reference spec.
            test_OLESpecTickerExample( _pstgTemp );

            // Test Office Property Sets

            ocscpy(ocsTestOffice, ocsDir);
            ocscat(ocsTestOffice, OLESTR("Office"));
            test_Office( ocsTestOffice );
            test_Office2( _pstgTemp );

            // Verify parameter validation
            test_ParameterValidation( _pstgTemp );

            // Test PropVariantCopy
            test_PropVariantCopy();

            if( PROPIMP_NTFS != g_enumImplementation )
            {
                // Verify PropVariant validation
                test_PropVariantValidation( _pstgTemp );
            }

            if( !g_fVerbose )
                printf( "\n" );

            --g_nIndent;
            PRINTF( "Standard tests PASSED\n" );

        }   // if( ulTestOptions & TEST_STANDARD )

        //  --------------
        //  Extended Tests
        //  --------------

        if( ulTestOptions & ~TEST_STANDARD )
        {
            PRINTF( "\nExtended Tests: " );
            g_nIndent++;

            if( g_fVerbose )
                PRINTF( "\n---------------\n" );

            // Check the CoFileTimeNow fix.
            if( ulTestOptions & TEST_COFILETIMENOW )
                test_CoFileTimeNow();


            // Test for compatibility with Word 6.0 files.
            if( ulTestOptions & TEST_WORD6 )
                test_Word6(_pstgTemp, szDir);

            if( ulTestOptions & TEST_SIMPLE_LEAKS )
                test_SimpleLeaks( ocsDir );

            // Get some performance numbers.
            if ( ulTestOptions & TEST_PERFORMANCE )
                test_Performance( _pstgTemp );

            // Test marshaling.
#ifndef _MAC    // No property marshaling support on the Mac.

            if( ulTestOptions & TEST_MARSHALING )
            {
                PRINTF( "   Marshaling Test\n" );

                ocscpy(ocsMarshalingTest, ocsDir);
                ocscat(ocsMarshalingTest, OLESTR("Marshal"));

                Check(S_OK, g_cpsmt.Init( ocsMarshalingTest,
                                          (PROPVARIANT*) g_rgcpropvarAll,
                                          (PROPSPEC*) g_rgcpropspecAll,
                                          CPROPERTIES_ALL,
                                          CPROPERTIES_ALL_SIMPLE ));
                Check(S_OK, g_cpsmt.Run());

            }
#endif

            if( !g_fVerbose )
                PRINTF( "\n" );

            --g_nIndent;
            PRINTF( "Extended tests PASSED\n" );

        }   // if( ulTestOptions )
    }   // try

    catch( CHResult chr )
    {
    }
//Exit:
    // Clean up and exit.

    if( _pstgTemp != NULL )
        _pstgTemp->Release();

    if( _pstgTempCopyTo != NULL )
        _pstgTempCopyTo->Release();

    g_pfnFreePropVariantArray( CPROPERTIES_ALL, g_rgcpropvarAll );

    // Free the propspec array too.  It will free itself in its
    // destructor anyway, but by then it will be too late to
    // call CoTaskMemFree (since CoUninit will have been called
    // by then).
    {
        for( int i = 0; i < CPROPERTIES_ALL; i++ )
            g_rgcpropspecAll[i].FreeResources();
    }

    CoUninitialize();

#ifdef _MAC
    UninitOleManager();

    #if DBG
        FnAssertOn( FALSE );
    #endif

#endif

    if( g_hinstDLL ) FreeLibrary( g_hinstDLL );
    CoFreeUnusedLibraries();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\propmshl.cxx ===
/*
#include <stdio.h>
#include "PStgServ.h"
#include "PropMshl.hxx"
#include "CPropVar.hxx"
#include "CHResult.hxx"
#include "proptest.hxx"
*/

#include "pch.cxx"
#include <shellapi.h>

const IID IID_IPropertyStorageServer    = {0xaf4ae0d0,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1a}};
const IID IID_IPropertyStorageServerApp = {0xaf4ae0d1,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1a}};

CPropSpec g_rgcpropspecVariant[] = { OLESTR("SafeArray") };


CPropStgMarshalTest::CPropStgMarshalTest( )
{
    m_cAllProperties = 0;
    m_cSimpleProperties = 0;
    m_rgpropspec = NULL;
    m_rgpropvar = NULL;
    m_pwszDocFileName = NULL;
    m_fInitialized = FALSE;
}


CPropStgMarshalTest::~CPropStgMarshalTest()
{
    if( m_pwszDocFileName != NULL )
        delete m_pwszDocFileName;
}



CPropStgMarshalTest::Init( OLECHAR *pwszDocFileName,
                           PROPVARIANT rgpropvar[],
                           PROPSPEC    rgpropspec[],
                           ULONG       cAllProperties,
                           ULONG       cSimpleProperties )
{
    HRESULT hr = E_FAIL;

    // Validate the input.

    if( pwszDocFileName == NULL )
    {
        hr = STG_E_INVALIDPARAMETER;
        goto Exit;
    }

    m_cAllProperties = cAllProperties;
    m_cSimpleProperties = cSimpleProperties;
    m_rgpropvar = rgpropvar;
    m_rgpropspec = rgpropspec;

    // Copy the docfile name.

    m_pwszDocFileName = new WCHAR[ wcslen(pwszDocFileName) + 1 ];

    if( m_pwszDocFileName != NULL )
    {
        wcscpy( m_pwszDocFileName, pwszDocFileName );
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Register the local server.  We assume that it's either in
    // the local directory or in the path.

    if( g_fRegisterLocalServer )
    {
        HINSTANCE hinst = 0;
        DWORD dwWait;
        PROCESS_INFORMATION ProcessInformation;
        STARTUPINFO StartupInfo;

        memset( &StartupInfo, 0, sizeof(StartupInfo) );
        StartupInfo.cb = sizeof(StartupInfo);
        TCHAR tszCommand[] = TEXT("PStgServ.exe /RegServer");

        if( !CreateProcess( NULL,
                            tszCommand,
                            NULL, NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInformation ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

        if( WAIT_OBJECT_0 != WaitForSingleObject( ProcessInformation.hProcess, INFINITE ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

    }


    hr = S_OK;

Exit:

    return( hr );
}




CPropStgMarshalTest::Run()
{

    HRESULT hr = S_OK;

    IPropertyStorageServer *pserver = NULL;
    IStorage *pstg = NULL;
    IPropertySetStorage *ppsstg = NULL;
    IPropertyStorage *ppstg = NULL;
    DWORD   grfFlags=0;

    //  ------------------------
    //  Create a PropSet locally
    //  ------------------------

    // Create a local IPropertySetStorage

    hr = g_pfnStgCreateStorageEx (
            m_pwszDocFileName,
            STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            DetermineStgFmt( g_enumImplementation ),
            0,
            NULL,
            NULL,
            PROPIMP_NTFS == g_enumImplementation ? IID_IFlatStorage : IID_IStorage,
            (void**) &pstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed open of local Storage") );

    hr = StgToPropSetStg( pstg, &ppsstg );
    if( FAILED(hr) ) ERROR_EXIT( TEXT("Couldn't create local IPropertySetStorage") );

    // Create an IPropertyStorage

    grfFlags = PROPSETFLAG_ANSI | PROPSETFLAG_NONSIMPLE;

    hr = ppsstg->Create( IID_IPropertyStorageServer, NULL,
                         grfFlags,
                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                         &ppstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't create a local IPropertyStorage") );
    RELEASE_INTERFACE( ppsstg );

    // Write properties to it and close it.

    hr = WriteProperties( ppstg, FALSE /* Not Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed to write properties to local PropStg") );

    RELEASE_INTERFACE( ppstg );
    RELEASE_INTERFACE( pstg );

    //  -----------------------------------------
    //  Verify the properties through a marshaled
    //  IPropertySetStorage
    //  -----------------------------------------

    // Get a remote IPropertySetStorage

    Status( TEXT("Starting Server") );
    hr = CoCreateInstance( IID_IPropertyStorageServerApp,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IPropertyStorageServer,
                           (void **)&pserver );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed CoCreateInstance") );

    hr = pserver->Initialize( g_enumImplementation, g_Restrictions );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't initialize property set storage server") );

    Status( TEXT("Requesting remote IPropertySetStorage") );
    hr = pserver->StgOpenPropSetStg( m_pwszDocFileName,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     &ppsstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed to open remote PropSetStg") );

    // Get an IPropertyStorage

    hr = ppsstg->Open( IID_IPropertyStorageServer,
                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                       &ppstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't create a local IPropertyStorage") );
    RELEASE_INTERFACE( ppsstg );

    // Read from the marshalled Storage and compare the properties against
    // the local copy we kept.

    Status( TEXT("Reading/verifying properties from marshalled IPropertySetStorage") );
    hr = ReadAndCompareProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed marshalled read and compare") );

    // Remove the existing properties via the marhsalled interface, and
    // re-write them.

    hr = DeleteProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't delete properties from remote IPropertySetStorage") );

    // Write the properties back to the remote storage.

    Status( TEXT("Writing properties through marshalled IPropertySetStorage") );
    hr = WriteProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't write properties to remote Storage") );
    RELEASE_INTERFACE( ppstg );


    //  -----------------------------------------
    //  Verify the properties through a marshaled
    //  IPropertyStorage
    //  -----------------------------------------

    // Get a remote IPropertyStorage

    Status( TEXT("Requesting remote IPropertyStorage") );
    hr = pserver->StgOpenPropStg( m_pwszDocFileName,
                                  IID_IPropertyStorageServer,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                  &ppstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed to open remote PropStg") );

    // Read from the marshalled Storage and compare the properties against
    // the local copy we kept.

    Status( TEXT("Reading/verifying properties from marshalled IPropertyStorage") );
    hr = ReadAndCompareProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed marshalled read and compare") );

    // Remove the existing properties via the marhsalled interface, and
    // re-write them.

    hr = DeleteProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't delete properties from remote Storage") );

    // Write the properties back to the remote storage.

    Status( TEXT("Writing properties through marshalled IPropertyStorage") );
    hr = WriteProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't write properties to remote Storage") );

    RELEASE_INTERFACE( ppstg );
    RELEASE_INTERFACE( pserver );

    //  --------------------------------
    //  Re-verify the properties locally
    //  --------------------------------

    // Re-open the DocFile locally.

    hr = g_pfnStgOpenStorageEx( m_pwszDocFileName,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                STGFMT_ANY, //DetermineStgFmt( g_enumImplementation )
                                0L,
                                NULL,
                                NULL,
                                PROPIMP_NTFS == g_enumImplementation ? IID_IFlatStorage : IID_IStorage,
                                (PVOID*)&pstg );
    if (SUCCEEDED(hr))
    {
        hr = StgToPropSetStg( pstg, &ppsstg );
        if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't create IPropertySetStorage on local DocFile") );
    }
    else
    {
        hr = g_pfnStgOpenStorageEx( m_pwszDocFileName,
                                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    STGFMT_ANY, //DetermineStgFmt( g_enumImplementation )
                                    0L,
                                    NULL,
                                    NULL,
                                    IID_IPropertySetStorage,
                                    (PVOID*)&ppsstg );
    }

    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't re-open the File locally") );


    hr = ppsstg->Open( IID_IPropertyStorageServer,
                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                       &ppstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't open load IPropertyStorage") );
    RELEASE_INTERFACE( ppsstg );

    // Compare the properties in the property set, which we wrote through
    // the marshalled interface, against what they should be.

    Status( TEXT("Reading/verifying properties from local IPropertyStorage") );
    hr = ReadAndCompareProperties( ppstg, FALSE /* Not Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Properties written through marshalled interface do not appear correct") );

    RELEASE_INTERFACE( ppstg );
    RELEASE_INTERFACE( pstg );

Exit:

    RELEASE_INTERFACE( pstg );
    RELEASE_INTERFACE( ppsstg );
    RELEASE_INTERFACE( ppstg );
    RELEASE_INTERFACE( pserver );

    return( hr );
	
}



HRESULT CPropStgMarshalTest::WriteProperties( IPropertyStorage *ppstg, BOOL fMarshaled )
{
    HRESULT hr = E_FAIL;


    // Are we restricted to simple properties?
    if( RESTRICT_SIMPLE_ONLY & g_Restrictions )
    {
        // Write the simple properties
        hr = ppstg->WriteMultiple( m_cSimpleProperties, m_rgpropspec, m_rgpropvar, PID_FIRST_USABLE );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed WriteMultiple") );
    }

    // Or, are we marshaling with IProp (where non-simple properties don't work)?
    else if( fMarshaled && g_SystemInfo.fIPropMarshaling )
    {
        // Verify that we can't write the non-simple properties
        hr = ppstg->WriteMultiple( m_cAllProperties, m_rgpropspec, m_rgpropvar, PID_FIRST_USABLE );
        if( RPC_E_CLIENT_CANTMARSHAL_DATA != hr )
        {
            hr = E_FAIL;
            ERROR_EXIT( TEXT("Failed WriteMultiple") );
        }

        // Write the simple properties
        hr = ppstg->WriteMultiple( m_cSimpleProperties, m_rgpropspec, m_rgpropvar, PID_FIRST_USABLE );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed WriteMultiple") );
    }

    // Otherwise, write all the properties
    else
    {
        hr = ppstg->WriteMultiple( m_cAllProperties, m_rgpropspec, m_rgpropvar, PID_FIRST_USABLE );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed WriteMultiple") );
        Check( S_OK, ResetRGPropVar( (CPropVariant*)m_rgpropvar ));

        // Test with a SafeArray too.

        PROPVARIANT propvar;
        SAFEARRAY *psa = NULL;
        SAFEARRAYBOUND rgsaBound[] = { {2, 0} };

        psa = SafeArrayCreateEx( VT_I4, 1, rgsaBound, NULL );

        LONG rgIndices[] = {0};
        LONG lVal = 0;
        Check( S_OK, SafeArrayPutElement( psa, rgIndices, &lVal ));
        
        rgIndices[0] = lVal = 1;
        Check( S_OK, SafeArrayPutElement( psa, rgIndices, &lVal ));

        PropVariantInit( &propvar );
        propvar.vt = VT_ARRAY | VT_I4;
        propvar.parray = psa;
        psa = NULL;

        hr = ppstg->WriteMultiple( 1, g_rgcpropspecVariant, &propvar, PID_FIRST_USABLE );
        PropVariantClear( &propvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed WriteMultiple") );

    }


    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    return( hr );

}



HRESULT CPropStgMarshalTest::ReadAndCompareProperties( IPropertyStorage *ppstg, BOOL fMarshaled )
{
    HRESULT hr = E_FAIL;
    ULONG i;
    ULONG cProperties = 0;

    // Allocate a PROPVARIANT[] into which we can read the
    // properties

    PROPVARIANT *rgpropvar = new PROPVARIANT[ m_cAllProperties ];
    if( NULL == rgpropvar )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Are we restricted to only simple properties?
    if( RESTRICT_SIMPLE_ONLY & g_Restrictions )
    {
        cProperties = m_cSimpleProperties;

        // Read just the simple properties
        hr = ppstg->ReadMultiple( cProperties, m_rgpropspec, rgpropvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed ReadMultiple") );

    }

    // Or, are we marshaling with IProp (where non-simple properties don't work)?
    else if( fMarshaled && g_SystemInfo.fIPropMarshaling )
    {
        cProperties = m_cSimpleProperties;

        // Try to read all the properties, including the non-simples.
        hr = ppstg->ReadMultiple( m_cAllProperties, m_rgpropspec, rgpropvar );
        if( RPC_E_SERVER_CANTMARSHAL_DATA != hr )
        {
            hr = E_FAIL;
            ERROR_EXIT( TEXT("Failed ReadMultiple") );
        }

        // Now read just the simple properties
        hr = ppstg->ReadMultiple( cProperties, m_rgpropspec, rgpropvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed ReadMultiple") );
    }

    // Otherwise, read all the properties
    else
    {
        cProperties = m_cAllProperties;

        // Read the properties
        hr = ppstg->ReadMultiple( cProperties, m_rgpropspec, rgpropvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed ReadMultiple") );

        // Read and compare the safearray property

        PROPVARIANT propvar;
        PropVariantInit( &propvar );

        hr = ppstg->ReadMultiple( 1, g_rgcpropspecVariant, &propvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed ReadMultiple") );

        if( (VT_ARRAY | VT_I4) != propvar.vt
            ||
            NULL == propvar.parray
            ||
            1 != SafeArrayGetDim(propvar.parray) )
        {
            ERROR_EXIT( TEXT("Invalid type returned in ReadMultiple") );
        }

        LONG rgIndices[] = { 0 };
        LONG rglVal[] = { -1, -1 };

        hr = SafeArrayGetElement( propvar.parray, rgIndices, &rglVal[0] );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed SafeArrayGetElement") );

        rgIndices[0] = 1;
        hr = SafeArrayGetElement( propvar.parray, rgIndices, &rglVal[1] );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed SafeArrayGetElement") );

        if( 0 != rglVal[0] || 1 != rglVal[1] )
            ERROR_EXIT( TEXT("SafeArray types don't match") );

        PropVariantClear( &propvar );
    }


    // Compare the properties with what we expect.

    for( i = 0; i < cProperties; i++ )
    {
        hr = CPropVariant::Compare( &rgpropvar[i], &m_rgpropvar[i] );
        if( S_OK != hr )
        {
            hr = E_FAIL;
            ERROR_EXIT( TEXT("Property mismatch") );
        }
    }

    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    if( NULL != rgpropvar )
    {
        g_pfnFreePropVariantArray( m_cAllProperties, rgpropvar );
        delete[]( rgpropvar );
    }

    return( hr );

}



HRESULT CPropStgMarshalTest::DeleteProperties( IPropertyStorage *ppstg, BOOL fMarshaled  )
{
    HRESULT hr = E_FAIL;
    ULONG cProperties;

    // Determine the correct number of properties to delete.

    if( (RESTRICT_SIMPLE_ONLY & g_Restrictions)
        ||
        (fMarshaled && g_SystemInfo.fIPropMarshaling) )
    {
        cProperties = m_cSimpleProperties;
    }
    else
        cProperties = m_cAllProperties;

    // Delete the properties

    hr = ppstg->DeleteMultiple( cProperties, m_rgpropspec );
    if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed DeleteMultiple") );

    hr = S_OK;

Exit:

    return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\chicago\makefile.inc ===
############################################################################
#
#   Copyright (C) 1996-1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!MESSAGE Old TARGET_DBG_DEFINES = "$(TARGET_DBG_DEFINES)"
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES:-DDBG=-DNOT_DBG)
!MESSAGE New TARGET_DBG_DEFINES = "$(TARGET_DBG_DEFINES)"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\daytona\makefile.inc ===
############################################################################
#
#   Copyright (C) 1996-1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!MESSAGE Old TARGET_DBG_DEFINES = "$(TARGET_DBG_DEFINES)"
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES:-DDBG=-DNOT_DBG)
!MESSAGE New TARGET_DBG_DEFINES = "$(TARGET_DBG_DEFINES)"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\testdoc.cxx ===
#include "pch.cxx"

unsigned char g_achTestDoc[] = {
    0xd0,0xcf,0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0xfe,0xff,0x09,0x00,//........>.......
    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x03,0x00,0x00,0x00,//................
    0x01,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x52,0x00,0x6f,0x00,0x6f,0x00,0x74,0x00,0x20,0x00,0x45,0x00,0x6e,0x00,0x74,0x00,//R.o.o.t. .E.n.t.
    0x72,0x00,0x79,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//r.y.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x16,0x00,0x05,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x03,0x00,0x00,0x00,//................
    0x00,0x09,0x02,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,//...............F
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x7f,0xd9,0x7b,//............P..{
    0x1a,0x05,0xba,0x01,0x06,0x00,0x00,0x00,0x40,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,//........@.......
    0x01,0x00,0x43,0x00,0x6f,0x00,0x6d,0x00,0x70,0x00,0x4f,0x00,0x62,0x00,0x6a,0x00,//..C.o.m.p.O.b.j.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x12,0x00,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//........n.......
    0x57,0x00,0x6f,0x00,0x72,0x00,0x64,0x00,0x44,0x00,0x6f,0x00,0x63,0x00,0x75,0x00,//W.o.r.d.D.o.c.u.
    0x6d,0x00,0x65,0x00,0x6e,0x00,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//m.e.n.t.........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x1a,0x00,0x02,0x01,0xff,0xff,0xff,0xff,0x04,0x00,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xb5,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x4f,0x00,0x62,0x00,0x6a,0x00,0x65,0x00,0x63,0x00,0x74,0x00,0x50,0x00,0x6f,0x00,//O.b.j.e.c.t.P.o.
    0x6f,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//o.l.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x16,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x81,0x8f,0x87,0x7a,0x04,0xba,0x01,0x00,0x81,0x8f,0x87,//........z.......
    0x7a,0x04,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//z...............
    0x02,0x00,0x00,0x00,0xfd,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,//................
    0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x08,0x00,0x00,0x00,//................
    0x09,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x05,0x00,0x53,0x00,0x75,0x00,0x6d,0x00,0x6d,0x00,0x61,0x00,0x72,0x00,0x79,0x00,//..S.u.m.m.a.r.y.
    0x49,0x00,0x6e,0x00,0x66,0x00,0x6f,0x00,0x72,0x00,0x6d,0x00,0x61,0x00,0x74,0x00,//I.n.f.o.r.m.a.t.
    0x69,0x00,0x6f,0x00,0x6e,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//i.o.n...........
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x28,0x00,0x02,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//(...............
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0xdd,0x01,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x01,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,//................
    0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x08,0x00,0x00,0x00,//................
    0x09,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,//................
    0x0d,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,0x17,0x00,0x00,0x00,0x10,0x00,0x00,0x00,//................
    0x11,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x13,0x00,0x00,0x00,0x14,0x00,0x00,0x00,//................
    0x15,0x00,0x00,0x00,0x16,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x18,0x00,0x00,0x00,//................
    0x19,0x00,0x00,0x00,0x1a,0x00,0x00,0x00,0x1b,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,//................
    0x1d,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x1f,0x00,0x00,0x00,0x20,0x00,0x00,0x00,//............ ...
    0x21,0x00,0x00,0x00,0x22,0x00,0x00,0x00,0x23,0x00,0x00,0x00,0x24,0x00,0x00,0x00,//!..."...#...$...
    0x25,0x00,0x00,0x00,0x26,0x00,0x00,0x00,0x27,0x00,0x00,0x00,0x28,0x00,0x00,0x00,//%...&...'...(...
    0x29,0x00,0x00,0x00,0x2a,0x00,0x00,0x00,0x2b,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,//)...*...+...,...
    0x2d,0x00,0x00,0x00,0x2e,0x00,0x00,0x00,0x2f,0x00,0x00,0x00,0x30,0x00,0x00,0x00,//-......./...0...
    0x31,0x00,0x00,0x00,0x32,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x34,0x00,0x00,0x00,//1...2...3...4...
    0x35,0x00,0x00,0x00,0x36,0x00,0x00,0x00,0x37,0x00,0x00,0x00,0x38,0x00,0x00,0x00,//5...6...7...8...
    0x39,0x00,0x00,0x00,0x3a,0x00,0x00,0x00,0x3b,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,//9...:...;...<...
    0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x02,0x00,0x00,0x00,0xab,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xca,0x00,0x00,0x00,//................
    0x05,0x00,0x00,0x00,0xeb,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x0d,0x01,0x00,0x00,//................
    0x04,0x00,0x00,0x00,0x2f,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x4f,0x01,0x00,0x00,//..../.......O...
    0x01,0x00,0x00,0x00,0x62,0x01,0x00,0x00,0x0f,0x00,0x00,0x00,0x68,0x01,0x00,0x00,//....b.......h...
    0x10,0x00,0x00,0x00,0x70,0x01,0x00,0x00,0x12,0x00,0x00,0x00,0x78,0x01,0x00,0x00,//....p.......x...
    0x0e,0x00,0x00,0x00,0x93,0x01,0x00,0x00,0x09,0x00,0x00,0x00,0x9b,0x01,0x00,0x00,//................
    0x13,0x00,0x00,0x00,0xa5,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,//................
    0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x2e,0x64,0x6f,0x74,0x00,0x1e,0x00,0x00,0x00,0x17,//Normal.dot......
    0x00,0x00,0x00,0x54,0x69,0x74,0x6c,0x65,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,//...Title of the 
    0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,0x00,0x19,0x00,//document........
    0x00,0x00,0x53,0x75,0x62,0x6a,0x65,0x63,0x74,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,//..Subject of the
    0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,0x00,0x1a,// document.......
    0x00,0x00,0x00,0x4b,0x65,0x79,0x77,0x6f,0x72,0x64,0x73,0x20,0x6f,0x66,0x20,0x74,//...Keywords of t
    0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,//he document.....
    0x00,0x1a,0x00,0x00,0x00,0x43,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x73,0x20,0x6f,0x66,//.....Comments of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,// the document...
    0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x41,0x75,0x74,0x68,0x6f,0x72,0x20,0x6f,0x66,//.......Author of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,// the document...
    0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,//.......Bill More
    0x6c,0x00,0x02,0x00,0x00,0x00,0xe4,0x04,0x03,0x00,0x00,0x00,0x07,0x00,0x00,0x00,//l...............
    0x03,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x13,0x00,0x00,0x00,//....A...........
    0x4d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x20,0x57,0x6f,0x72,0x64,0x20,0x36,//Microsoft Word 6
    0x2e,0x30,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x02,//.0..............
    0x00,0x00,0x00,0x33,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,0x11,//...3............
    0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0xfe,0xff,0x09,0x00,0x06,0x00,0x00,//.....>..........
    0x73,0x64,0x66,0x6f,0x69,0x68,0x73,0x64,0x66,0x0d,0xff,0xff,0xff,0xff,0xff,0xff,//sdfoihsdf.......
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x03,0x00,0x01,0x00,//................
    0x01,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x52,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..R.............
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..j.......j.....
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x08,0x00,0x00,0x08,0x00,//..........~.....
    0x00,0x00,0x86,0x08,0x00,0x00,0x0e,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..........j.....
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..j.......j.....
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x2a,0x00,//..............*.
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x46,0x6f,0x6f,0x20,0x42,0x61,0x72,0x0d,0x0d,0x73,0x64,0x66,0x6b,0x6a,0x68,0x73,//Foo Bar..sdfkjhs
    0x64,0x66,0x6b,0x6a,0x68,0x73,0x64,0x66,0x20,0x0d,0x73,0x20,0x64,0x6a,0x6b,0x73,//dfkjhsdf .s djks
    0x61,0x66,0x64,0x6c,0x6a,0x73,0x61,0x66,0x64,0x0d,0x73,0x64,0x66,0x6c,0x6b,0x68,//afdljsafd.sdflkh
    0x6a,0x73,0x66,0x61,0x64,0x6c,0x68,0x73,0x66,0x61,0x64,0x0d,0x73,0x64,0x66,0x68,//jsfadlhsfad.sdfh
    0xfe,0xff,0x00,0x00,0x03,0x33,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//.....3..........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xe0,0x85,0x9f,0xf2,//................
    0xf9,0x4f,0x68,0x10,0xab,0x91,0x08,0x00,0x2b,0x27,0xb3,0xd9,0x30,0x00,0x00,0x00,//.Oh.....+'..0...
    0xad,0x01,0x00,0x00,0x0e,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x98,0x00,0x00,0x00,//................
    0x01,0x00,0xfe,0xff,0x03,0x0a,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x09,0x02,0x00,//................
    0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x1c,0x00,0x00,0x00,//...........F....
    0x4d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x20,0x57,0x6f,0x72,0x64,0x20,0x36,//Microsoft Word 6
    0x2e,0x30,0x20,0x44,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x00,0x0a,0x00,0x00,0x00,//.0 Document.....
    0x4d,0x53,0x57,0x6f,0x72,0x64,0x44,0x6f,0x63,0x00,0x10,0x00,0x00,0x00,0x57,0x6f,//MSWordDoc.....Wo
    0x72,0x64,0x2e,0x44,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x36,0x00,0xf4,0x39,//rd.Document.6..9
    0xb2,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,//.q..............
    0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xdc,0xa5,0x68,0x00,0x45,0xc0,0x09,0x04,0x00,0x00,0x24,0x00,0x65,0x00,0x00,0x00,//..h.E.....$.e...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x09,0x03,0x00,0x00,//................
    0xb5,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//....J...........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x6a,0x00,0x00,0x00,//............j...
    0x00,0x08,0x00,0x00,0x6a,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//....j...j.......
    0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//j.......j.......
    0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x14,0x00,0x00,0x00,//j.......j.......
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x94,0x08,0x00,0x00,0x36,0x00,0x00,0x00,//............6...
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x0a,0x00,0x00,0x00,//................
    0xd4,0x08,0x00,0x00,0x0a,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x97,0x0b,0x00,0x00,0x31,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//....1...........
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x09,0x00,0x00,0x02,0x00,0x00,0x00,//................
    0x0a,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x09,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x0a,0x09,0x00,0x00,0x52,0x00,0x00,0x00,0x5c,0x09,0x00,0x00,0xec,0x00,0x00,0x00,//....R...\.......
    0x48,0x0a,0x00,0x00,0xec,0x00,0x00,0x00,0x34,0x0b,0x00,0x00,0x1e,0x00,0x00,0x00,//H.......4.......
    0xc8,0x0b,0x00,0x00,0x58,0x00,0x00,0x00,0x20,0x0c,0x00,0x00,0x95,0x00,0x00,0x00,//....X... .......
    0x52,0x0b,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//R...E...........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//........j.......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x03,0x00,0x00,0x09,0x03,0x00,0x00,0x19,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,//............J...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,//................
    0x00,0x03,0x00,0x00,0x08,0x03,0x00,0x00,0x09,0x03,0x00,0x00,0x1a,0x03,0x00,0x00,//................
    0x2a,0x03,0x00,0x00,0x3c,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,0xfe,0x00,0x01,0xc0,//*...<...J.......
    0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,//!......!......!.
    0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,//.....!......!...
    0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...!............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x06,//................
    0x0e,0x00,0x0f,0x00,0x08,0x00,0x01,0x00,0x4b,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,//........K.......
    0x1a,0x00,0x00,0x40,0xf1,0xff,0x02,0x00,0x1a,0x00,0x06,0x4e,0x6f,0x72,0x6d,0x61,//...@.......Norma
    0x6c,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x61,0x09,0x04,0x00,0x00,0x00,0x00,0x00,//l.......a.......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x00,//..............".
    0x41,0x40,0xf2,0xff,0xa1,0x00,0x22,0x00,0x16,0x44,0x65,0x66,0x61,0x75,0x6c,0x74,//A@...."..Default
    0x20,0x50,0x61,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x20,0x46,0x6f,0x6e,0x74,0x00,// Paragraph Font.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,//..............J.
    0x00,0x00,0x02,0x00,0xff,0xff,0xff,0xff,0x02,0x00,0xff,0xff,0xff,0xff,0x01,0x00,//................
    0x04,0x20,0xff,0xff,0x01,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,//. ........J.....
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x28,0x00,0x00,0x00,//............(...
    0x3a,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x01,0xc0,0x21,//:...H...J......!
    0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x01,//.....!.....!....
    0xc0,0x21,0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x03,0x00,0x00,0x4a,0x03,//.!.....!......J.
    0x00,0x00,0x02,0x00,0x00,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,0x03,0x00,0x2a,0x00,//........J.....*.
    0x0a,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,0x6c,0x1c,0x43,0x3a,0x5c,0x75,//.Bill Morel.C:\u
    0x73,0x65,0x72,0x73,0x5c,0x64,0x65,0x66,0x61,0x75,0x6c,0x74,0x5c,0x74,0x65,0x73,//sers\default\tes
    0x74,0x64,0x6f,0x63,0x2e,0x64,0x6f,0x63,0xff,0x40,0x5c,0x5c,0x4d,0x53,0x50,0x52,//tdoc.doc.@\\MSPR
    0x49,0x4e,0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,0x4f,0x52,//INT35\1/1049 COR
    0x50,0x41,0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x4e,0x65,0x30,0x30,0x3a,0x00,//PA 141B97.Ne00:.
    0x77,0x69,0x6e,0x73,0x70,0x6f,0x6f,0x6c,0x00,0x48,0x50,0x20,0x4c,0x61,0x73,0x65,//winspool.HP Lase
    0x72,0x4a,0x65,0x74,0x20,0x49,0x49,0x49,0x53,0x69,0x20,0x50,0x6f,0x73,0x74,0x53,//rJet IIISi PostS
    0x63,0x72,0x69,0x70,0x74,0x20,0x76,0x35,0x32,0x2e,0x33,0x00,0x5c,0x5c,0x4d,0x53,//cript v52.3.\\MS
    0x50,0x52,0x49,0x4e,0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,//PRINT35\1/1049 C
    0x4f,0x52,0x50,0x41,0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x20,0x03,0x50,0x03,//ORPA 141B97. .P.
    0x7c,0x00,0x70,0x00,0x13,0xdd,0x01,0x00,0x01,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,//|.p...........o.
    0x64,0x00,0x01,0x00,0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,//d.....,.........
    0x00,0x00,0x4c,0x65,0x74,0x74,0x65,0x72,0x00,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,//..Letter......o.
    0x64,0x00,0x01,0x00,0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,//d.....,.........
    0x00,0x00,0x4c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//..L.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x52,0x49,0x56,0x20,0x00,0x00,0x00,//........PRIV ...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x18,0x00,0x00,0x00,0x00,0x00,0x20,0x4e,0x20,0x4e,0x20,0x4e,0x00,0x00,0x10,0x27,//...... N N N...'
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5c,0x5c,0x4d,0x53,0x50,0x52,0x49,0x4e,//........\\MSPRIN
    0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,0x4f,0x52,0x50,0x41,//T35\1/1049 CORPA
    0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x20,0x03,0x50,0x03,0x7c,0x00,0x70,0x00,// 141B97. .P.|.p.
    0x13,0xdd,0x01,0x00,0x01,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,0x64,0x00,0x01,0x00,//..........o.d...
    0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x4c,0x65,//..,...........Le
    0x74,0x74,0x65,0x72,0x00,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,0x64,0x00,0x01,0x00,//tter......o.d...
    0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x4c,0x00,//..,...........L.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x50,0x52,0x49,0x56,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//....PRIV .......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,//................
    0x00,0x00,0x20,0x4e,0x20,0x4e,0x20,0x4e,0x00,0x00,0x10,0x27,0x00,0x00,0x00,0x00,//.. N N N...'....
    0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x00,0x48,0x00,0x00,0x00,0x48,0x00,0x00,0x00,//........H...H...
    0x08,0x00,0x01,0x00,0x01,0x00,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0x00,//......H.........
    0x00,0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x17,//...@............
    0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x49,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x21,//...H...I...J...!
    0x00,0x09,0x03,0x00,0x00,0x00,0x00,0x21,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x20,//.......!....... 
    0x00,0x19,0x03,0x00,0x00,0x00,0x00,0x20,0x00,0x07,0x03,0x00,0x00,0x00,0x00,0x20,//....... ....... 
    0x00,0x08,0x03,0x00,0x00,0x00,0x00,0x31,0x00,0x15,0x16,0x90,0x01,0x00,0x00,0x54,//.......1.......T
    0x69,0x6d,0x65,0x73,0x20,0x4e,0x65,0x77,0x20,0x52,0x6f,0x6d,0x61,0x6e,0x00,0x0c,//imes New Roman..
    0x16,0x90,0x01,0x02,0x00,0x53,0x79,0x6d,0x62,0x6f,0x6c,0x00,0x0b,0x26,0x90,0x01,//.....Symbol..&..
    0x00,0x00,0x41,0x72,0x69,0x61,0x6c,0x00,0x22,0x00,0x04,0x00,0x31,0x08,0x8a,0x18,//..Arial."...1...
    0x00,0x00,0xd0,0x02,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,0x40,0x34,0xf4,0x85,//......h.....@4..
    0x05,0x3b,0xf4,0xa5,0x04,0x3b,0xf4,0xa5,0x03,0x00,0x03,0x00,0x00,0x00,0x07,0x00,//.;...;..........
    0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x83,0x10,//..A.............
    0x05,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x04,0x00,//........A.......
    0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x74,0x03,0x00,0x00,0x00,0x00,//..........t.....
    0x95,0x00,0x00,0x00,0x16,0x54,0x69,0x74,0x6c,0x65,0x20,0x6f,0x66,0x20,0x74,0x68,//.....Title of th
    0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x18,0x53,0x75,0x62,0x6a,//e document..Subj
    0x65,0x63,0x74,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,//ect of the docum
    0x65,0x6e,0x74,0x2e,0x19,0x4b,0x65,0x79,0x77,0x6f,0x72,0x64,0x73,0x20,0x6f,0x66,//ent..Keywords of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x19,0x43,// the document..C
    0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x73,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,//omments of the d
    0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x17,0x41,0x75,0x74,0x68,0x6f,0x72,0x20,//ocument..Author 
    0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,//of the document.
    0x0a,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,0x6c,0x00,0x00,0x00,0x00,0x00,//.Bill Morel.....
    0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff //................
};

unsigned int g_cbTestDoc = sizeof(g_achTestDoc)/sizeof(g_achTestDoc[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\rtlstub.cxx ===
//+============================================================================
//
//  File:   RtlStub.cxx
//
//  Purpose:
//          This file provides some RTL routines which are also implemented
//          in NTDLL.  They are duplicated here so that we can build
//          PropTest without linking to NTDLL, which doesn't exist
//          on Win95.
//
//+============================================================================



#include "pch.cxx"          // Brings in most other includes/defines/etc.

#define BSTRLEN(bstrVal)      *((ULONG *) bstrVal - 1)

// we use static array instead of string literals because some systems
// have 4 bytes string literals, and would not produce the correct result
// for REF's 2 byte Unicode convention
// 
OLECHAR aocMap[CCH_MAP + 1] = {'a','b','c','d','e','f','g',
                               'h','i','j','k','l','m','n',
                               'o','p','q','r','s','t','u',
                               'v','w','x','y','z',
                               '0','1','2','3','4','5','\0'};

GUID guidSummary =
    { 0xf29f85e0,
      0x4ff9, 0x1068,
      { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };

OLECHAR oszSummary[] = {'S','u','m','m','a','r','y',
                        'I','n','f','o','r','m','a','t','i','o','n','\0'};

GUID guidDocumentSummary =
    { 0xd5cdd502,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

OLECHAR oszDocumentSummary[] = {'D','o','c','u','m','e','n','t',
                                'S','u','m','m','a','r','y',
                                'I','n','f','o','r','m','a','t','i','o','n',
                                '\0'};

// Note that user defined properties are placed in section 2 with the below
// GUID as the FMTID -- alas, we did not expect Office95 to actually use it.

GUID guidDocumentSummarySection2 =
    { 0xd5cdd505,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

// *Global Info*

GUID guidGlobalInfo =
    { 0x56616F00,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Contents*

GUID guidImageContents =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Info*

GUID guidImageInfo =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };


//+--------------------------------------------------------------------------
// Function:    RtlGuidToPropertySetName
//
// Synopsis:    Map property set GUID to null-terminated UNICODE name string.
//
//              The awcname parameter is assumed to be a buffer with room for
//              CWC_PROPSETSZ (28) UNICODE characters.  The first character
//              is always WC_PROPSET0 (0x05), as specified by the OLE Appendix
//              B documentation.  The colon character normally used as an NT
//              stream name separator is not written to the caller's buffer.
//
//              No error is possible.
//
// Arguments:   IN GUID *pguid        -- pointer to GUID to convert
//              OUT OLECHAR aocname[] -- output string buffer
//
// Returns:     count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[])
{
    ULONG cbitRemain = CBIT_BYTE;
    OLECHAR *poc = aocname;

    BYTE *pb;
    BYTE *pbEnd;    

    *poc++ = OC_PROPSET0;

    //  -----------------------
    //  Check for special-cases
    //  -----------------------

    // Note: CCH_PROPSET includes the OC_PROPSET0, and sizeof(osz...)
    // includes the trailing '\0', so sizeof(osz...) is ok because the
    // OC_PROPSET0 character compensates for the trailing NULL character.

    // Is this the SummaryInformation propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszSummary)/sizeof(OLECHAR));

    if (*pguid == guidSummary)
    {
        RtlCopyMemory(poc, oszSummary, sizeof(oszSummary));
        return(sizeof(oszSummary)/sizeof(OLECHAR));
    }

    // Is this The DocumentSummaryInformation or User-Defined propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszDocumentSummary)/sizeof(OLECHAR));

    if (*pguid == guidDocumentSummary || *pguid == guidDocumentSummarySection2)
    {
        RtlCopyMemory(poc, oszDocumentSummary, sizeof(oszDocumentSummary));
        return(sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    }

    // Is this the Global Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    if (*pguid == guidGlobalInfo)
    {
        RtlCopyMemory(poc, oszGlobalInfo, cboszGlobalInfo);
        return(cboszGlobalInfo/sizeof(OLECHAR));
    }

    // Is this the Image Contents propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageContents)/sizeof(OLECHAR));
    if (*pguid == guidImageContents)
    {
        RtlCopyMemory(poc, oszImageContents, cboszImageContents);
        return(cboszImageContents/sizeof(OLECHAR));
    }

    // Is this the Image Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageInfo)/sizeof(OLECHAR));
    if (*pguid == guidImageInfo)
    {
        RtlCopyMemory(poc, oszImageInfo, cboszImageInfo);
        return(cboszImageInfo/sizeof(OLECHAR));
    }


    //  ------------------------------
    //  Calculate the string-ized GUID
    //  ------------------------------

    // If this is a big-endian system, we need to convert
    // the GUID to little-endian for the conversion.

#if BIGENDIAN
    GUID guidByteSwapped = *pguid;
    PropByteSwap( &guidByteSwapped );
    pguid = &guidByteSwapped;
#endif

    // Point to the beginning and ending of the GUID
    pb = (BYTE*) pguid;
    pbEnd = pb + sizeof(*pguid);

    // Walk 'pb' through each byte of the GUID.

    while (pb < pbEnd)
    {
        ULONG i = *pb >> (CBIT_BYTE - cbitRemain);

        if (cbitRemain >= CBIT_CHARMASK)
        {
            *poc = MapChar(i);
            if (cbitRemain == CBIT_BYTE && *poc >= (OLECHAR)'a' 
                && *poc <= ((OLECHAR)'z'))
            {
                *poc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a') );
            }
            poc++;
            cbitRemain -= CBIT_CHARMASK;
            if (cbitRemain == 0)
            {
                pb++;
                cbitRemain = CBIT_BYTE;
            }
        }
        else
        {
            if (++pb < pbEnd)
            {
                i |= *pb << cbitRemain;
            }
            *poc++ = MapChar(i);
            cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
        }
    }   // while (pb < pbEnd)

    *poc = OLESTR( '\0' );
    return(CCH_PROPSET);

}


//+--------------------------------------------------------------------------
// Function:    RtlPropertySetNameToGuid
//
// Synopsis:    Map non null-terminated UNICODE string to a property set GUID.
//
//              If the name is not properly formed as per
//              RtlGuidToPropertySetName(), STATUS_INVALID_PARAMETER is
//              returned.  The pguid parameter is assumed to point to a buffer
//              with room for a GUID structure.
//
// Arguments:   IN ULONG cocname     -- count of OLECHARs in string to convert
//              IN OLECHAR aocname[] -- input string to convert
//              OUT GUID *pguid      -- pointer to buffer for converted GUID
//
// Returns:     NTSTATUS
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cocname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    OLECHAR const *poc = aocname;

    if (poc[0] == OC_PROPSET0)
    {
        //  -----------------------
        //  Check for Special-Cases 
        //  -----------------------

        // Note: cocname includes the OC_PROPSET0, and sizeof(osz...)
        // includes the trailing OLESTR('\0'), but the comparison excludes both
        // the leading OC_PROPSET0 and the trailing '\0'.

        // Is this SummaryInformation?
        if (cocname == sizeof(oszSummary)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszSummary, cocname - 1) == 0)
        {
            *pguid = guidSummary;
            return(STATUS_SUCCESS);
        }

        // Is this DocumentSummaryInformation?
        if (cocname == sizeof(oszDocumentSummary)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszDocumentSummary, cocname - 1) == 0)
        {
            *pguid = guidDocumentSummary;
            return(STATUS_SUCCESS);
        }

        // Is this Global Info?
        if (cocname == cboszGlobalInfo/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszGlobalInfo, cocname - 1) == 0)
        {
            *pguid = guidGlobalInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Info?
        if (cocname == cboszImageInfo/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszImageInfo, cocname - 1) == 0)
        {
            *pguid = guidImageInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Contents?
        if (cocname == cboszImageContents/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszImageContents, cocname - 1) == 0)
        {
            *pguid = guidImageContents;
            return(STATUS_SUCCESS);
        }

        //  ------------------
        //  Calculate the GUID
        //  ------------------

        // None of the special-cases hit, so we must calculate
        // the GUID from the name.

        if (cocname == CCH_PROPSET)
        {
            ULONG cbit;
            BYTE *pb = (BYTE *) pguid - 1;

            RtlZeroMemory(pguid, sizeof(*pguid));
            for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)
            {
                ULONG cbitUsed = cbit % CBIT_BYTE;
                ULONG cbitStored;
                OLECHAR oc;

                if (cbitUsed == 0)
                {
                    pb++;
                }

                oc = *++poc - (OLECHAR)'A'; // assume upper case 
                // for wchar (unsigned) -ve values becomes a large number
                // but for char, which is signed, -ve is -ve
                if (oc > CALPHACHARS || oc < 0)
                {
                    // oops, try lower case
                    oc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a'));
                    if (oc > CALPHACHARS || oc < 0)
                    {
                        // must be a digit
                        oc += ((OLECHAR)'a') - ((OLECHAR)'0') + CALPHACHARS;
                        if (oc > CHARMASK)
                        {
                            goto Exit;                  // invalid character
                        }
                    }
                }
                *pb |= (BYTE) (oc << cbitUsed);

                cbitStored = min(CBIT_BYTE - cbitUsed, CBIT_CHARMASK);

                // If the translated bits wouldn't all fit in the current byte

                if (cbitStored < CBIT_CHARMASK)
                {
                    oc >>= CBIT_BYTE - cbitUsed;

                    if (cbit + cbitStored == CBIT_GUID)
                    {
                        if (oc != 0)
                        {
                            goto Exit;                  // extra bits
                        }
                        break;
                    }
                    pb++;

                    *pb |= (BYTE) oc;
                }
            }   // for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)

            Status = STATUS_SUCCESS;

            // If byte-swapping is necessary, do so now on the calculated
            // GUID.

            PropByteSwap( pguid );

        }   // if (cocname == CCH_PROPSET)
    }   // if (poc[0] == OC_PROPSET0)


    //  ----
    //  Exit
    //  ----

Exit:

    return(Status);
}



inline BOOLEAN
_Compare_VT_BOOL(VARIANT_BOOL bool1, VARIANT_BOOL bool2)
{
    // Allow any non-zero value to match any non-zero value

    return((bool1 == FALSE) == (bool2 == FALSE));
}


BOOLEAN
_Compare_VT_CF(CLIPDATA *pclipdata1, CLIPDATA *pclipdata2)
{
    BOOLEAN fSame;

    if (pclipdata1 != NULL && pclipdata2 != NULL)
    {
        fSame = ( pclipdata1->cbSize == pclipdata2->cbSize
                  &&
                  pclipdata1->ulClipFmt == pclipdata2->ulClipFmt );

        if (fSame)
        {
            if (pclipdata1->pClipData != NULL && pclipdata2->pClipData != NULL)
            {
                fSame = memcmp(
                            pclipdata1->pClipData,
                            pclipdata2->pClipData,
                            CBPCLIPDATA(*pclipdata1)
                              ) == 0;
            }
            else
            {
                // They're the same if both are NULL, or if
                // they have a zero length (if they have a zero
                // length, either one may or may not be NULL, but they're
                // still considered the same).

                fSame = pclipdata1->pClipData == pclipdata2->pClipData
                        ||
                        CBPCLIPDATA(*pclipdata1) == 0;
            }
        }
    }
    else
    {
        fSame = pclipdata1 == pclipdata2;
    }
    return(fSame);
}


//+---------------------------------------------------------------------------
// Function:    RtlCompareVariants, public
//
// Synopsis:    Compare two passed PROPVARIANTs -- case sensitive for strings
//
// Arguments:   [CodePage]      -- CodePage
//              [pvar1]         -- pointer to PROPVARIANT
//              [pvar2]         -- pointer to PROPVARIANT
//
// Returns:     TRUE if identical, else FALSE
//---------------------------------------------------------------------------

#ifdef _MAC
EXTERN_C    // The Mac linker doesn't seem to be able to export with C++ decorations
#endif

BOOLEAN PROPSYSAPI PROPAPI
PropTestCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2)
{
    if (pvar1->vt != pvar2->vt)
    {
        return(FALSE);
    }

    BOOLEAN fSame;
    ULONG i;

    switch (pvar1->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        fSame = TRUE;
        break;

    case VT_I1:
    case VT_UI1:
        fSame = pvar1->bVal == pvar2->bVal;
        break;

    case VT_I2:
    case VT_UI2:
        fSame = pvar1->iVal == pvar2->iVal;
        break;

    case VT_BOOL:
        fSame = _Compare_VT_BOOL(pvar1->boolVal, pvar2->boolVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        fSame = pvar1->lVal == pvar2->lVal;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        fSame = pvar1->hVal.HighPart == pvar2->hVal.HighPart
                &&
                pvar1->hVal.LowPart  == pvar2->hVal.LowPart;
        break;

    case VT_CLSID:
        fSame = memcmp(pvar1->puuid, pvar2->puuid, sizeof(CLSID)) == 0;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        fSame = ( pvar1->blob.cbSize == pvar2->blob.cbSize );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->blob.pBlobData,
                        pvar2->blob.pBlobData,
                        pvar1->blob.cbSize) == 0;
        }
        break;

    case VT_CF:
        fSame = _Compare_VT_CF(pvar1->pclipdata, pvar2->pclipdata);
        break;

    case VT_BSTR:
        if (pvar1->bstrVal != NULL && pvar2->bstrVal != NULL)
        {
            fSame = ( BSTRLEN(pvar1->bstrVal) == BSTRLEN(pvar2->bstrVal) );
            if (fSame)
            {
                fSame = memcmp(
                            pvar1->bstrVal,
                            pvar2->bstrVal,
                            BSTRLEN(pvar1->bstrVal)) == 0;
            }
        }
        else
        {
            fSame = pvar1->bstrVal == pvar2->bstrVal;
        }
        break;

    case VT_LPSTR:
        if (pvar1->pszVal != NULL && pvar2->pszVal != NULL)
        {
            fSame = strcmp(pvar1->pszVal, pvar2->pszVal) == 0;
        }
        else
        {
            fSame = pvar1->pszVal == pvar2->pszVal;
        }
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_LPWSTR:
        if (pvar1->pwszVal != NULL && pvar2->pwszVal != NULL)
        {
            fSame = Prop_wcscmp(pvar1->pwszVal, pvar2->pwszVal) == 0;
        }
        else
        {
            fSame = pvar1->pwszVal == pvar2->pwszVal;
        }
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        fSame = ( pvar1->caub.cElems == pvar2->caub.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->caub.pElems,
                        pvar2->caub.pElems,
                        pvar1->caub.cElems * sizeof(pvar1->caub.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
        fSame = ( pvar1->cai.cElems == pvar2->cai.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cai.pElems,
                        pvar2->cai.pElems,
                        pvar1->cai.cElems * sizeof(pvar1->cai.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_BOOL:
        fSame = ( pvar1->cabool.cElems == pvar2->cabool.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->cabool.cElems; i++)
            {
                fSame = _Compare_VT_BOOL(
                                pvar1->cabool.pElems[i],
                                pvar2->cabool.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        fSame = ( pvar1->cal.cElems == pvar2->cal.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cal.pElems,
                        pvar2->cal.pElems,
                        pvar1->cal.cElems * sizeof(pvar1->cal.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        fSame = ( pvar1->cah.cElems == pvar2->cah.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cah.pElems,
                        pvar2->cah.pElems,
                        pvar1->cah.cElems *
                            sizeof(pvar1->cah.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CLSID:
        fSame = ( pvar1->cauuid.cElems == pvar2->cauuid.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cauuid.pElems,
                        pvar2->cauuid.pElems,
                        pvar1->cauuid.cElems *
                            sizeof(pvar1->cauuid.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CF:
        fSame = ( pvar1->caclipdata.cElems == pvar2->caclipdata.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->caclipdata.cElems; i++)
            {
                fSame = _Compare_VT_CF(
                                &pvar1->caclipdata.pElems[i],
                                &pvar2->caclipdata.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_BSTR:
        fSame = ( pvar1->cabstr.cElems == pvar2->cabstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->cabstr.cElems; i++)
            {
                if (pvar1->cabstr.pElems[i] != NULL &&
                    pvar2->cabstr.pElems[i] != NULL)
                {
                    fSame = ( BSTRLEN(pvar1->cabstr.pElems[i])
                              ==
                              BSTRLEN(pvar2->cabstr.pElems[i]) );
                    if (fSame)
                    {
                        fSame = memcmp(
                                    pvar1->cabstr.pElems[i],
                                    pvar2->cabstr.pElems[i],
                                    BSTRLEN(pvar1->cabstr.pElems[i])) == 0;
                    }
                }
                else
                {
                    fSame = pvar1->cabstr.pElems[i] == pvar2->cabstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        fSame = ( pvar1->calpstr.cElems == pvar2->calpstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->calpstr.cElems; i++)
            {
                if (pvar1->calpstr.pElems[i] != NULL &&
                    pvar2->calpstr.pElems[i] != NULL)
                {
                    fSame = strcmp(
                                pvar1->calpstr.pElems[i],
                                pvar2->calpstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpstr.pElems[i] == 
                            pvar2->calpstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        fSame = ( pvar1->calpwstr.cElems == pvar2->calpwstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->calpwstr.cElems; i++)
            {
                if (pvar1->calpwstr.pElems[i] != NULL &&
                    pvar2->calpwstr.pElems[i] != NULL)
                {
                    fSame = Prop_wcscmp(
                                pvar1->calpwstr.pElems[i],
                                pvar2->calpwstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpwstr.pElems[i] == 
                            pvar2->calpwstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        fSame = ( pvar1->capropvar.cElems == pvar2->capropvar.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->capropvar.cElems; i++)
            {
                fSame = PropTestCompareVariants(
                                CodePage,
                                &pvar1->capropvar.pElems[i],
                                &pvar2->capropvar.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT Comparison");
        fSame = FALSE;
        break;

    }
    return(fSame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\testcase.cxx ===
//+============================================================================
//
//  File:   TestCase.cxx
//
//  Description:
//          This file provides all of the actual test-cases for the
//          PropTest DRT.  Each test is a function, with a "test_"
//          prefix.
//
//+============================================================================

#include "pch.cxx"
#include <ddeml.h>      // For CP_WINUNICODE
#include "propstm.hxx"
#include "propstg.hxx"
#include "stgint.h"


EXTERN_C const IID
IID_IStorageTest = { /* 40621cf8-a17f-11d1-b28d-00c04fb9386d */
    0x40621cf8,
    0xa17f,
    0x11d1,
    {0xb2, 0x8d, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };


//+---------------------------------------------------------------
//
//  Function:   test_WriteReadAllProperties
//
//  Synopsis:   This test simply creates two new property
//              sets in a new file (one Ansi and one Unicode),
//              writes all the properties in g_rgcpropvarAll,
//              reads them back, and verifies that it reads what
//              it wrote.
//
//  Inputs:     [LPOLESTR] ocsDir (in)
//                  The directory in which a file can be created.
//
//  Outputs:    None.
//
//+---------------------------------------------------------------

void
test_WriteReadAllProperties( LPOLESTR ocsDir )
{
    OLECHAR ocsFile[ MAX_PATH ];
    FMTID fmtidAnsi, fmtidUnicode;
    UINT ExpectedCodePage;

    IStorage *pstg = NULL, *psubstg = NULL;
    IStream *pstm = NULL;
    IPropertySetStorage *ppropsetstg = NULL;
    IPropertyStorage *ppropstgAnsi = NULL, *ppropstgUnicode = NULL;

    CPropVariant rgcpropvar[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarAnsi[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarUnicode[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarBag[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarDefault[ 2 ];
    CPropSpec rgcpropspecDefault[ 2 ];

    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    IPropertyBagEx *pbag = NULL;

    ULONG ulIndex;

    ULONG cPropertiesAll = CPROPERTIES_ALL;


    Status( "Simple Write/Read Test\n" );

    //  ----------
    //  Initialize
    //  ----------

    // Generate FMTIDs.

    UuidCreate( &fmtidAnsi );
    UuidCreate( &fmtidUnicode );

    // Generate a filename from the directory name.

    ocscpy( ocsFile, ocsDir );
    ocscat( ocsFile, OLESTR( "AllProps.stg" ));

    //  ----------------
    //  Create a docfile
    //  ----------------

    Check( S_OK, g_pfnStgCreateStorageEx( ocsFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     (void**) &pstg )); //(void**) &ppropsetstg ));
    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, (void**) &ppropsetstg ));

    // Create the Property Storages

    Check( S_OK, ppropsetstg->Create( fmtidAnsi,
                                      &CLSID_NULL,
                                      ( (g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI )
                                      |
                                      ( (g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_DEFAULT: PROPSETFLAG_NONSIMPLE ),
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &ppropstgAnsi ));

    Check( S_OK, ppropsetstg->Create( fmtidUnicode,
                                      &CLSID_NULL,
                                      (g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_DEFAULT: PROPSETFLAG_NONSIMPLE,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &ppropstgUnicode ));


    // Get a property bag.  This is also a convenient place to test that we can QI between
    // the storage and bag.

    IStorage *pstg2 = NULL;
    IPropertyBagEx *pbag2 = NULL;
    IUnknown *punk1 = NULL;
    IUnknown *punk2 = NULL;

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    Check( S_OK, pbag->QueryInterface( DetermineStgIID( g_enumImplementation ), reinterpret_cast<void**>(&pstg2) ));
    Check( S_OK, pstg2->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag2) ));
    Check( TRUE, pbag == pbag2 && pstg == pstg2 );

    RELEASE_INTERFACE(pbag2);
    RELEASE_INTERFACE(pstg2);

    Check( S_OK, pstg->QueryInterface( IID_IUnknown, reinterpret_cast<void**>(&punk1) ));
    Check( S_OK, pbag->QueryInterface( IID_IUnknown, reinterpret_cast<void**>(&punk2) ));
    Check( TRUE, punk1 == punk2 );
    RELEASE_INTERFACE(punk1);
    RELEASE_INTERFACE(punk2);

    // Write some simple properties

    Check( S_OK, ppropstgAnsi->WriteMultiple( CPROPERTIES_ALL_SIMPLE,
                                              g_rgcpropspecAll,
                                              g_rgcpropvarAll,
                                              PID_FIRST_USABLE ));

    // Verify the format version is 0
    CheckFormatVersion(ppropstgAnsi, 0);


    // Write to all property sets.

    Check( S_OK, ppropstgAnsi->WriteMultiple( cPropertiesAll,
                                              g_rgcpropspecAll,
                                              g_rgcpropvarAll,
                                              PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    // Verify that the format is now version 1, since we wrote a VersionedStream property
    CheckFormatVersion(ppropstgAnsi, 1);

    Check( S_OK, ppropstgUnicode->WriteMultiple( cPropertiesAll,
                                                 g_rgcpropspecAll,
                                                 g_rgcpropvarAll,
                                                 PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    Check( S_OK, pbag->WriteMultiple( cPropertiesAll,
                                      g_rgoszpropnameAll,
                                      g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));


    // Close and re-open everything

    RELEASE_INTERFACE(pstg);
    RELEASE_INTERFACE(ppropsetstg);
    RELEASE_INTERFACE(ppropstgAnsi);
    RELEASE_INTERFACE(ppropstgUnicode);

    Check( 0, pbag->Release() );
    pbag = NULL;

    Check( S_OK, g_pfnStgOpenStorageEx( ocsFile,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     (void**) &pstg )); //(void**) &ppropsetstg ));
    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, (void**) &ppropsetstg ));

    // Create the Property Storages

    Check( S_OK, ppropsetstg->Open( fmtidAnsi,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &ppropstgAnsi ));

    Check( S_OK, ppropsetstg->Open( fmtidUnicode,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &ppropstgUnicode ));

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));

    // Read and verify the auto-generated properties.

    rgcpropspecDefault[0] = static_cast<PROPID>(PID_CODEPAGE);
    rgcpropspecDefault[1] = static_cast<PROPID>(PID_LOCALE);

    Check( S_OK, ppropstgAnsi->ReadMultiple( 2, rgcpropspecDefault, rgcpropvarDefault ));

    ExpectedCodePage = (g_Restrictions & RESTRICT_UNICODE_ONLY) ? CP_WINUNICODE : GetACP();
    Check( TRUE, VT_I2  == rgcpropvarDefault[0].vt );
    Check( TRUE, ExpectedCodePage == (UINT) rgcpropvarDefault[0].iVal );
    Check( TRUE, VT_UI4 == rgcpropvarDefault[1].vt );
    Check( TRUE, GetUserDefaultLCID() == rgcpropvarDefault[1].ulVal );

    Check( S_OK, ppropstgUnicode->ReadMultiple( 2, rgcpropspecDefault, rgcpropvarDefault ));

    ExpectedCodePage = CP_WINUNICODE;
    Check( TRUE, VT_I2  == rgcpropvarDefault[0].vt );
    Check( TRUE, ExpectedCodePage == (UINT) rgcpropvarDefault[0].iVal );
    Check( TRUE, VT_UI4 == rgcpropvarDefault[1].vt );
    Check( TRUE, GetUserDefaultLCID() == rgcpropvarDefault[1].ulVal );

    // Read from all property sets

    Check( S_OK, ppropstgAnsi->ReadMultiple( cPropertiesAll,
                                             g_rgcpropspecAll,
                                             rgcpropvarAnsi ));

    Check( S_OK, ppropstgUnicode->ReadMultiple( cPropertiesAll,
                                                g_rgcpropspecAll,
                                                rgcpropvarUnicode ));

    Check( S_OK, pbag->ReadMultiple( cPropertiesAll, g_rgoszpropnameAll, rgcpropvarBag, NULL ));

    // Compare the properties

    for( int i = 0; i < (int)cPropertiesAll; i++ )
    {
        Check( TRUE, rgcpropvarAnsi[i]    == g_rgcpropvarAll[i] );
        Check( TRUE, rgcpropvarUnicode[i] == g_rgcpropvarAll[i] );
        Check( TRUE, rgcpropvarBag[i] == g_rgcpropvarAll[i] );
    }

    // Show that we can delete everything

    Check( S_OK, ppropstgAnsi->DeleteMultiple( cPropertiesAll, g_rgcpropspecAll ));
    Check( S_OK, ppropstgUnicode->DeleteMultiple( cPropertiesAll, g_rgcpropspecAll ));
    Check( S_OK, pbag->DeleteMultiple( cPropertiesAll, g_rgoszpropnameAll, 0 ));

    // Re-write the properties, because it's convenient for debug sometimes
    // to have a file around with lots of properties in it.

    Check( S_OK, ppropstgAnsi->WriteMultiple( cPropertiesAll,
                                              g_rgcpropspecAll,
                                              g_rgcpropvarAll,
                                              PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    Check( S_OK, ppropstgUnicode->WriteMultiple( cPropertiesAll,
                                                 g_rgcpropspecAll,
                                                 g_rgcpropvarAll,
                                                 PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    RELEASE_INTERFACE(pstg);
    RELEASE_INTERFACE(ppropsetstg);
    RELEASE_INTERFACE(ppropstgAnsi);
    RELEASE_INTERFACE(ppropstgUnicode);

    Check( 0, pbag->Release() );
    pbag = NULL;

}   // test_WriteReadProperties



BOOL

StgConvertPropertyToVariantWrapper(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus )
{
    BOOL boolRet = FALSE;
    *pstatus = STATUS_SUCCESS;

    __try
    {
        boolRet = g_pfnStgConvertPropertyToVariant( pprop, CodePage, pvar, pma );
//        boolRet = RtlConvertPropertyToVariant( pprop, CodePage, pvar, pma );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        *pstatus = GetExceptionCode();
    }

    return( boolRet );
}



ULONG
StgPropertyLengthAsVariantWrapper( SERIALIZEDPROPERTYVALUE *pprop, ULONG cbprop, USHORT CodePage, BYTE flags,
                                   NTSTATUS *pstatus )
{
    ULONG cbRet = 0;
    *pstatus = STATUS_SUCCESS;

    __try
    {
        cbRet = g_pfnStgPropertyLengthAsVariant( pprop, cbprop, CodePage, 0 );
//        cbRet = PropertyLengthAsVariant( pprop, cbprop, CodePage, 0 );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        *pstatus = GetExceptionCode();
    }

    return( cbRet );
}


SERIALIZEDPROPERTYVALUE *
StgConvertVariantToPropertyWrapper(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVector,
    OPTIONAL OUT ULONG *pcIndirect,
    OUT NTSTATUS *pstatus )
{
    SERIALIZEDPROPERTYVALUE * ppropRet = NULL;
    *pstatus = STATUS_SUCCESS;

    __try
    {
        ppropRet = g_pfnStgConvertVariantToProperty( pvar, CodePage, pprop, pcb, pid, fVector, pcIndirect );
//        ppropRet = RtlConvertVariantToProperty( pvar, CodePage, pprop, pcb, pid, fVariantVectorOrArray, pcIndirect );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        *pstatus = GetExceptionCode();
    }

    return( ppropRet );

}


void
test_PidIllegal( IStorage *pstg )
{
    IPropertySetStorage *ppropsetstg = NULL;
    IPropertyStorage *ppropstg = NULL;
    ULONG cRefsOriginal = GetRefCount(pstg);
    CPropVariant rgcpropvarWrite[3], rgcpropvarRead[3];
    CPropSpec    rgcpropspec[3];
    PROPID       rgpropid[3];
    LPOLESTR     rgoszNames[3] = { NULL, NULL, NULL };

    // Get an IPropertyStorage

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&ppropsetstg) ));
    Check( S_OK, ppropsetstg->Create( FMTID_NULL, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                      &ppropstg ));

    // Write a PID_ILLEGAL property.  Since it's ignored, nothing should be written.

    rgcpropvarWrite[0] = (long) 1234;
    rgcpropspec[0] = PID_ILLEGAL;
    Check( S_OK, ppropstg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
    Check( S_FALSE, ppropstg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));

    // Write several normal properties
    SHORT sOriginal = 1234;
    LPOLESTR oszOriginalName = OLESTR("Second");

    rgcpropvarWrite[0] = (long) 5678;
    rgcpropvarWrite[1] = sOriginal;
    rgcpropvarWrite[2] = (float) 23.5;

    rgcpropspec[0] = OLESTR("First");
    rgcpropspec[1] = oszOriginalName;
    rgcpropspec[2] = OLESTR("Third");

    Check( S_OK, ppropstg->WriteMultiple( 3, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, ppropstg->ReadMultiple( 3, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
    Check( TRUE, rgcpropvarWrite[2] == rgcpropvarRead[2] );

    // Re-write the properties except for one.  The value of that property shouldn't change,
    // nor should its name.

    rgcpropvarWrite[0] = (short) 1234;
    rgcpropvarWrite[1] = (long) 5678;
    rgcpropvarWrite[2] = (double) 12.4;

    rgcpropspec[1] = PID_ILLEGAL;

    Check( S_OK, ppropstg->WriteMultiple( 3, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
    rgcpropspec[1] = oszOriginalName;
    Check( S_OK, ppropstg->ReadMultiple( 3, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarWrite[0]      == rgcpropvarRead[0] );
    Check( TRUE, CPropVariant(sOriginal) == rgcpropvarRead[1] );
    Check( TRUE, rgcpropvarWrite[2]      == rgcpropvarRead[2] );

    rgpropid[0] = PID_FIRST_USABLE;
    rgpropid[1] = PID_FIRST_USABLE + 1;
    rgpropid[2] = PID_FIRST_USABLE + 2;

    Check( S_OK, ppropstg->ReadPropertyNames( 3, rgpropid, rgoszNames ));
    Check( 0, wcscmp( rgcpropspec[0].lpwstr, rgoszNames[0] ));
    Check( 0, wcscmp( oszOriginalName, rgoszNames[1] ));
    Check( 0, wcscmp( rgcpropspec[2].lpwstr, rgoszNames[2] ));

    for( int i = 0; i < 3; i++ )
    {
        CoTaskMemFree( rgoszNames[i] );
        rgoszNames[i] = NULL;
    }

    // Re-write the names, again skipping one of them.

    rgoszNames[0] = OLESTR("Updated first");
    rgoszNames[1] = OLESTR("Updated second");
    rgoszNames[2] = OLESTR("Updated third");

    rgpropid[1] = PID_ILLEGAL;

    Check( S_OK, ppropstg->WritePropertyNames( 3, rgpropid, rgoszNames ));
    rgoszNames[0] = rgoszNames[1] = rgoszNames[2] = NULL;

    rgpropid[1] = PID_FIRST_USABLE + 1;
    Check( S_OK, ppropstg->ReadPropertyNames( 3, rgpropid, rgoszNames ));

    Check( 0, wcscmp( rgoszNames[0], OLESTR("Updated first") ));
    Check( 0, wcscmp( rgoszNames[1], oszOriginalName ));
    Check( 0, wcscmp( rgoszNames[2], OLESTR("Updated third") ));

    // Re-write just the one name, but skipping it.

    rgpropid[1] = PID_ILLEGAL;
    CoTaskMemFree( rgoszNames[1] );
    rgoszNames[1] = OLESTR("Write just the second");
    Check( S_OK, ppropstg->WritePropertyNames( 1, &rgpropid[1], &rgoszNames[1] ));

    rgoszNames[1] = NULL;
    rgpropid[1] = PID_FIRST_USABLE + 1;
    Check( S_OK, ppropstg->ReadPropertyNames( 1, &rgpropid[1], &rgoszNames[1] ));

    Check( 0, wcscmp( rgoszNames[1], oszOriginalName ));


    // Exit

    for( i = 0; i < 3; i++ )
        CoTaskMemFree( rgoszNames[i] );

    Check( 0, RELEASE_INTERFACE(ppropstg) );
    Check( cRefsOriginal, RELEASE_INTERFACE(ppropsetstg) );
}



void
test_PropertyLengthAsVariant( )
{
    Status( "StgPropertyLengthAsVariant, StgConvert*\n" );

    ULONG i = 0;
    BYTE *rgb = new BYTE[ 8192 ];
    Check( TRUE, NULL != rgb );

    CPropVariant rgcpropvar[ 7 ];
    ULONG rgcbExpected[ 7 ];

    CPropVariant *rgcpropvarSafeArray = NULL;
    SAFEARRAY *rgpsa[3];
    SAFEARRAYBOUND rgsaBounds[] = { {2,0}, {3,10}, {4,20} };  // [0..1], [10..12], [20..23]
    ULONG cDims = sizeof(rgsaBounds)/sizeof(rgsaBounds[0]);
    ULONG cElems = 0;

    rgcpropvar[i] = (long) 1234;    // VT_I4
    rgcbExpected[i] = 0;
    i++;

    rgcpropvar[i].SetBSTR( OLESTR("Hello, world") );    // Creates a copy
    rgcbExpected[i] = sizeof(OLESTR("Hello, world")) + sizeof(ULONG);
    i++;

    rgcpropvar[i][2] = (short) 2;    // VT_VECTOR | VT_I2
    rgcpropvar[i][1] = (short) 1;
    rgcpropvar[i][0] = (short) 0;
    rgcbExpected[i] = 3 * sizeof(short);
    i++;

    rgcpropvar[i][1] = (PROPVARIANT) CPropVariant( (unsigned long) 4 );       // VT_VECTOR | VT_VARIANT
    rgcpropvar[i][0] = (PROPVARIANT) CPropVariant( (BSTR) OLESTR("Hi there") );
    rgcbExpected[i] = 2 * sizeof(PROPVARIANT) + sizeof(OLESTR("Hi there")) + sizeof(ULONG);
    i++;


    rgpsa[0] = SafeArrayCreateEx( VT_I4, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[0] );
    cElems = CalcSafeArrayElementCount( rgpsa[0] );
    rgcbExpected[i+0] = sizeof(SAFEARRAY) - sizeof(SAFEARRAYBOUND)
                        + 3 * sizeof(SAFEARRAYBOUND)
                        + cElems * sizeof(LONG);

    rgpsa[1] = SafeArrayCreateEx( VT_BSTR, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[1] );
    rgcbExpected[i+1] = sizeof(SAFEARRAY) - sizeof(SAFEARRAYBOUND)
                        + 3 * sizeof(SAFEARRAYBOUND)
                        + cElems * sizeof(BSTR);

    rgpsa[2] = SafeArrayCreateEx( VT_VARIANT, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[2] );
    rgcbExpected[i+2] = sizeof(SAFEARRAY) - sizeof(SAFEARRAYBOUND)
                        + 3 * sizeof(SAFEARRAYBOUND)
                        + cElems * sizeof(PROPVARIANT);

    rgcpropvarSafeArray = new CPropVariant[ cElems ];
    Check( FALSE, NULL == rgcpropvar );

    for( ULONG j = 0; j < cElems; j++ )
    {
        LONG rgIndices[3];
        CalcSafeArrayIndices( j, rgIndices, rgsaBounds, cDims );

        LONG lVal = static_cast<LONG>(j);
        Check( S_OK, SafeArrayPutElement( rgpsa[0], rgIndices, &lVal ));

        BSTR bstrVal = SysAllocString( OLESTR("0 BSTR Val") );
        *bstrVal = OLESTR('0') + static_cast<OLECHAR>(j);
        Check( S_OK, SafeArrayPutElement( rgpsa[1], rgIndices, bstrVal ));
        rgcbExpected[i+1] += ocslen(bstrVal) + sizeof(OLECHAR) + sizeof(ULONG);

        if( j & 1 )
            rgcpropvarSafeArray[j] = (long) j;
        else
        {
            rgcpropvarSafeArray[j].SetBSTR( bstrVal );
            rgcbExpected[i+2] += ocslen(bstrVal)*sizeof(OLECHAR) + sizeof(OLECHAR) + sizeof(ULONG);
        }
        Check( S_OK, SafeArrayPutElement( rgpsa[2], rgIndices, &rgcpropvarSafeArray[j] ));
        SysFreeString( bstrVal );
    }

    rgcpropvar[i].vt = VT_ARRAY | VT_I4;
    reinterpret_cast<VARIANT*>(&rgcpropvar[i])->parray = rgpsa[0];
    i++;

    rgcpropvar[i].vt = VT_ARRAY | VT_BSTR;
    reinterpret_cast<VARIANT*>(&rgcpropvar[i])->parray = rgpsa[1];
    i++;

    rgcpropvar[i].vt = VT_ARRAY | VT_VARIANT;
    reinterpret_cast<VARIANT*>(&rgcpropvar[i])->parray = rgpsa[2];
    i++;

    Check( sizeof(rgcpropvar)/sizeof(rgcpropvar[0]), i );

    for( i = 0; i < sizeof(rgcpropvar)/sizeof(rgcpropvar[0]); i++ )
    {
        PropTestMemoryAllocator ma;
        SERIALIZEDPROPERTYVALUE *pprop = NULL;
        CPropVariant cpropvarOut;
        ULONG cbWritten = 8192, cbAsVariant = 0;
        NTSTATUS status;
        ULONG cIndirect;

        pprop = StgConvertVariantToPropertyWrapper(
                        &rgcpropvar[i], CP_WINUNICODE,
                        reinterpret_cast<SERIALIZEDPROPERTYVALUE*>(rgb),
                        &cbWritten, PID_FIRST_USABLE,
                        FALSE,
                        &cIndirect,
                        &status );
        Check( TRUE, NT_SUCCESS(status) );
        Check( TRUE, NULL != pprop );

        cbAsVariant = StgPropertyLengthAsVariantWrapper(
                                reinterpret_cast<SERIALIZEDPROPERTYVALUE*>(rgb),
                                cbWritten, CP_WINUNICODE, 0, &status );
        Check( TRUE, NT_SUCCESS(status) );

        // Check that the cbAsVariant is at least big enough.  Also sanity check that
        // it's not huge.  We use a fudge multiple of 3 for this because the
        // StgPropertyLengthAsVariant can way overestimate (primarily because it
        // doesn't know if BSTRs will need conversion).

        Check( TRUE, cbAsVariant >= rgcbExpected[i] );
        Check( TRUE, cbAsVariant <= rgcbExpected[i]*3 );

        // Check that we can convert back to a PropVariant
        // (False because it's not an indirect property we're converting)

        Check( FALSE, StgConvertPropertyToVariantWrapper( reinterpret_cast<SERIALIZEDPROPERTYVALUE*>(rgb),
                                                         CP_WINUNICODE, &cpropvarOut,
                                                         &ma, &status ));
        Check( TRUE, NT_SUCCESS(status) );

        Check( TRUE, cpropvarOut == rgcpropvar[i] );

    }

    g_pfnFreePropVariantArray( cElems, rgcpropvarSafeArray );
    delete[] rgcpropvarSafeArray;
    g_pfnFreePropVariantArray( sizeof(rgcpropvar)/sizeof(rgcpropvar[0]), rgcpropvar );

    delete[] rgb;
}




void
test_LargePropertySet( IStorage *pstg )
{
    FMTID fmtid;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    STATPROPSETSTG statpropsetstg;

    CPropSpec cpropspec;
    PROPVARIANT propvar;

    Status( "Large property sets\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));

    // Create a new property set.
    
    UuidCreate( &fmtid );
    Check( S_OK, pPropSetStg->Create( fmtid, NULL,
                                      PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                      &pPropStg ));

    // Create a big property to write.  Make it just about the max, 1M
    // (it's hard to make it exactly the right size, because it depends on the
    // size of the propset header, overallocs, etc.).

    propvar.vt = VT_BLOB;    
    
    propvar.blob.cbSize = 1023 * 1024;
    propvar.blob.pBlobData = new BYTE[ propvar.blob.cbSize ];
    Check( FALSE, NULL == propvar.blob.pBlobData );

    cpropspec = OLESTR("Name");

    // Write this big property
    Check( S_OK, pPropStg->WriteMultiple( 1, &cpropspec, &propvar, PID_FIRST_USABLE ));

    // Create a slightly too large property set.

    PropVariantClear( &propvar );
    delete propvar.blob.pBlobData;

    propvar.vt = VT_BLOB;    
    propvar.blob.cbSize = 1024 * 1024;
    propvar.blob.pBlobData = new BYTE[ propvar.blob.cbSize ];
    Check( FALSE, NULL == propvar.blob.pBlobData );

    // Write this too-big property 
    Check( STG_E_MEDIUMFULL, pPropStg->WriteMultiple( 1, &cpropspec, &propvar, PID_FIRST_USABLE ));

    delete propvar.blob.pBlobData;
    RELEASE_INTERFACE( pPropStg );
    
}


void
test_VersionOneNames( IStorage *pstg )
{
    FMTID fmtidInsensitive, fmtidSensitive, fmtidLongNames;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    STATPROPSETSTG statpropsetstg;

    CPropSpec rgcpropspec[2];
    CPropVariant rgcpropvarWrite[2], rgcpropvarRead[2];
    LPOLESTR rgposzNames[2] = { NULL, NULL };
    PROPID rgpropid[2] = { PID_FIRST_USABLE, PID_FIRST_USABLE+1 };

    Status( "PROPSETFLAG_CASE_SENSITIVE flag and long names\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));

    UuidCreate( &fmtidInsensitive );
    UuidCreate( &fmtidSensitive );
    UuidCreate( &fmtidLongNames );

    // Make two passes, Unicode first, then Ansi.

    for( int iPass = 0; iPass < 2; iPass++ )
    {
        DWORD propsetflagAnsi = 0 == iPass ? 0 : PROPSETFLAG_ANSI;
        ULONG cbLongPropertyName = 1020 * 1024;
        ULONG cchLongPropertyName = 0 == iPass ? cbLongPropertyName/sizeof(OLECHAR) : cbLongPropertyName;

        //  ------------------------
        //  Case insensitive propset
        //  ------------------------

        Check( S_OK, pPropSetStg->Create( fmtidInsensitive, NULL,
                                          PROPSETFLAG_DEFAULT | propsetflagAnsi,
                                          STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                          &pPropStg ));

        // This should still be a version zero (original) propery set.
        CheckFormatVersion( pPropStg, 0);

        rgcpropspec[0] = OLESTR("Name");
        rgcpropspec[1] = OLESTR("name");
        rgcpropvarWrite[0] = (long) 0;
        rgcpropvarWrite[1] = (short) 1;

        // Write two properties with the same name (their the same because this is a
        // case-insensitive property set).

        Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        // Read the names back.
        Check( S_OK, pPropStg->ReadPropertyNames( 2, rgpropid, rgposzNames ));

        // Since we really only wrote one property, we should only get one name back
        // Note that we get back the first name, but it's the second value!

        Check( 0, ocscmp( rgcpropspec[0].lpwstr, rgposzNames[0] ));
        Check( TRUE, NULL == rgposzNames[1] );

        delete[] rgposzNames[0];
        rgposzNames[0] = NULL;

        // Double check that we really one wrote one property (the second).
        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, VT_I2 == rgcpropvarRead[0].VarType() && rgcpropvarRead[0] == CPropVariant((short) 1) );
        Check( TRUE, VT_I2 == rgcpropvarRead[1].VarType() && rgcpropvarRead[1] == CPropVariant((short) 1) );

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( 0, statpropsetstg.grfFlags & PROPSETFLAG_CASE_SENSITIVE );

        RELEASE_INTERFACE( pPropStg );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        //  ----------------------
        //  Case sensitive propset
        //  ----------------------

        Check( S_OK, pPropSetStg->Create( fmtidSensitive, NULL,
                                          PROPSETFLAG_CASE_SENSITIVE | propsetflagAnsi,
                                          STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                          &pPropStg ));

        // Case-sensitivity requires a version 1 property set.
        CheckFormatVersion( pPropStg, 1 );

        // Write the two names that differ only by case.
        Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        // Read the names back and validate.
        Check( S_OK, pPropStg->ReadPropertyNames( 2, rgpropid, rgposzNames ));
        Check( TRUE, !ocscmp( rgcpropspec[0].lpwstr, rgposzNames[0] ));
        Check( TRUE, !ocscmp( rgcpropspec[1].lpwstr, rgposzNames[1] ));

        delete[] rgposzNames[0]; rgposzNames[0] = NULL;
        delete[] rgposzNames[1]; rgposzNames[1] = NULL;

        // Read the values and validate them too.

        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, VT_I4 == rgcpropvarRead[0].VarType() && rgcpropvarRead[0] == CPropVariant((long) 0) );
        Check( TRUE, VT_I2 == rgcpropvarRead[1].VarType() && rgcpropvarRead[1] == CPropVariant((short) 1) );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( PROPSETFLAG_CASE_SENSITIVE, statpropsetstg.grfFlags & PROPSETFLAG_CASE_SENSITIVE );

        RELEASE_INTERFACE( pPropStg );

        //  -----------------------
        //  Propset with long names
        //  -----------------------

        Check( S_OK, pPropSetStg->Create( fmtidLongNames, NULL,
                                          PROPSETFLAG_DEFAULT | propsetflagAnsi,
                                          STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                          &pPropStg ));

        // So far we haven't done anything that requires a post-original property set.
        CheckFormatVersion( pPropStg, 0 );

        // Write a short name, validate it, and validate that the format version doesn't change.
        rgcpropspec[0] = OLESTR("A short name");
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadPropertyNames( 1, rgpropid, rgposzNames ));  // PROPID == 2
        Check( TRUE, !ocscmp( rgcpropspec[0].lpwstr, rgposzNames[0] ));
        CheckFormatVersion( pPropStg, 0 );
        delete[] rgposzNames[0]; rgposzNames[0] = NULL;

        // Now create a really, really, long name.
        rgcpropspec[0].Alloc( cchLongPropertyName );

        for( ULONG i = 0; i < cchLongPropertyName; i++ )
            rgcpropspec[0][i] = OLESTR('a') + ( static_cast<OLECHAR>(i) % 26 );
        rgcpropspec[0][cchLongPropertyName-1] = OLESTR('\0');

        // Write this long name.
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        // The property set's format version should have been automatically bumped up.
        CheckFormatVersion( pPropStg, 1);

        // Read the property using the long name
        Check( S_OK, pPropStg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        rgcpropvarRead[0].Clear();

        // Read and validate the property name.
        Check( S_OK, pPropStg->ReadPropertyNames( 1, &rgpropid[1], rgposzNames )); // PROPID == 3
        Check( TRUE, !ocscmp( rgcpropspec[0].lpwstr, rgposzNames[0] ));
        delete[] rgposzNames[0]; rgposzNames[0] = NULL;

        // Try to write a long, different name.
        rgcpropspec[0][0] = OLESTR('#');
        Check( STG_E_MEDIUMFULL, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        RELEASE_INTERFACE( pPropStg );

    }   // for( int iPass = 0; iPass < 2; iPass++ )

    RELEASE_INTERFACE( pPropSetStg );

}   // test_VersionOneNames()



void
test_MultipleReader( LPOLESTR ocsDir )
{
    OLECHAR ocsFile[ MAX_PATH ];
    IPropertyBagEx *pBag1 = NULL, *pBag2 = NULL;
    CPropVariant rgcpropvarRead1[ CPROPERTIES_ALL ], rgcpropvarRead2[ CPROPERTIES_ALL ];
    OLECHAR oszPropertyName[] = OLESTR("Simple property");
    IEnumSTATPROPBAG *penum = NULL;
    STATPROPBAG rgstatpropbag[ CPROPERTIES_ALL + 1];
    ULONG cEnum = 0;

    Status( "Multiple stgm_read|stgm_deny_write\n" );

    ocscpy( ocsFile, ocsDir );
    ocscat( ocsFile, OLESTR("test_MultipleReader") );


    Check( S_OK, g_pfnStgCreateStorageEx( ocsFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L, NULL, NULL,
                                     IID_IPropertyBagEx,
                                     reinterpret_cast<void**>(&pBag1) ));


    Check( S_OK, pBag1->WriteMultiple( CPROPERTIES_ALL,
                                       g_rgoszpropnameAll,
                                       g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
    Check( 0, RELEASE_INTERFACE(pBag1) );

    Check( S_OK, g_pfnStgOpenStorageEx( ocsFile,
                                   STGM_READ | STGM_SHARE_DENY_WRITE,
                                   STGFMT_ANY,
                                   0L, NULL, NULL,
                                   IID_IPropertyBagEx,
                                   reinterpret_cast<void**>(&pBag1) ));

    Check( S_OK, g_pfnStgOpenStorageEx( ocsFile,
                                   STGM_READ | STGM_SHARE_DENY_WRITE,
                                   STGFMT_ANY,
                                   0L, NULL, NULL,
                                   IID_IPropertyBagEx,
                                   reinterpret_cast<void**>(&pBag2) ));


    Check( S_OK, pBag2->Enum( NULL, 0, &penum )); //OLESTR(""), 0, &penum ));

    Check( S_OK, penum->Next( CPROPERTIES_ALL, rgstatpropbag, &cEnum ));
    Check( CPROPERTIES_ALL, cEnum );

    Check( S_OK, pBag1->ReadMultiple( CPROPERTIES_ALL, g_rgoszpropnameAll,
                                      rgcpropvarRead1, NULL ));

    Check( S_OK, pBag2->ReadMultiple( CPROPERTIES_ALL, g_rgoszpropnameAll,
                                      rgcpropvarRead2, NULL ));

    for( int i = 0; i < CPROPERTIES_ALL; i++ )
    {
        Check( TRUE, rgcpropvarRead1[i] == g_rgcpropvarAll[i] );
        Check( TRUE, rgcpropvarRead2[i] == g_rgcpropvarAll[i] );

        delete[] rgstatpropbag[i].lpwstrName;
        rgstatpropbag[i].lpwstrName = NULL;
    }


    Check( 0, RELEASE_INTERFACE(penum) );
    Check( 0, RELEASE_INTERFACE(pBag1) );
    Check( 0, RELEASE_INTERFACE(pBag2) );

    return;

}   // test_MultipleReader






void
test_Robustness(OLECHAR *poszDir)
{
    if( PROPIMP_NTFS != g_enumImplementation ) return;

    Status( "NTFS property set robustness\n" );

    HRESULT hr = S_OK;
    IStorage *pStorage = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    IStorageTest *pPropStgTest = NULL;
    IStream *pStm = NULL;
    FMTID fmtid;
    STATSTG statstg;
    OLECHAR oszFile[ MAX_PATH ];
    OLECHAR oszName[ MAX_PATH ];
    OLECHAR oszUpdateName[ MAX_PATH ];

    CPropSpec rgcpropspec[2];
    CPropVariant rgcpropvarWrite[2], rgcpropvarRead[2];

    ocscpy( oszFile, poszDir );
    ocscat( oszFile, OLESTR("test_Robustness") );

    // Create a property set and put a property into it.

    Check( S_OK, g_pfnStgCreateStorageEx( oszFile, STGM_READWRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt(g_enumImplementation),
                                     0, NULL, NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     reinterpret_cast<void**>(&pStorage) ));


    Check( S_OK, pStorage->QueryInterface( IID_IPropertySetStorage,
                                           reinterpret_cast<void**>(&pPropSetStg) ));

    UuidCreate( &fmtid );
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    rgcpropspec[0] = OLESTR("Property Name");
    rgcpropspec[1] = OLESTR("Second property name");

    rgcpropvarWrite[0] = static_cast<long>(23);
    rgcpropvarWrite[1] = OLESTR("Second property value");

    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[0], &rgcpropvarWrite[0], PID_FIRST_USABLE ));
    Check( 0, RELEASE_INTERFACE(pPropStg) );

    // Rename the property set's stream to "Updt_*", and create any empty stream
    // in its place.  This simulates a crash during the flush of a property set.

    RtlGuidToPropertySetName( &fmtid, oszName );
    oszName[ 0 ] = OC_PROPSET0;
    wcscpy( oszUpdateName, OLESTR("Updt_") );
    wcscat( oszUpdateName, oszName );

    Check( S_OK, pStorage->RenameElement( oszName, oszUpdateName ));

    Check( S_OK, pStorage->CreateStream( oszName, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pStm ));
    Check( 0, RELEASE_INTERFACE(pStm) );

    // Open the property set in read-only mode, and verify that we can still ready
    // the property.  Since we're opening in read-only, the streams should remain
    // unchanged.

    Check( S_OK, pPropSetStg->Open( fmtid, STGM_READ|STGM_SHARE_EXCLUSIVE, &pPropStg ));

    Check( S_OK, pPropStg->ReadMultiple( 1, &rgcpropspec[0], &rgcpropvarRead[0] ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( 0, RELEASE_INTERFACE(pPropStg) );

    // Verify that the streams do not appear to have been changed.

    Check( S_OK, pStorage->OpenStream( oszName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
    Check( S_OK, pStm->Stat( &statstg, STATFLAG_NONAME ));
    Check( TRUE, CULargeInteger(0) == CULargeInteger(statstg.cbSize) );
    Check( 0, RELEASE_INTERFACE(pStm) );

    Check( S_OK, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
    Check( S_OK, pStm->Stat( &statstg, STATFLAG_NONAME ));
    Check( FALSE, CULargeInteger(0) == CULargeInteger(statstg.cbSize) );
    Check( 0, RELEASE_INTERFACE(pStm) );

    // Now open the property set for write.  This should cause the problem to be fixed.

    Check( S_OK, pPropSetStg->Open( fmtid, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pPropStg ));

    // Read the property back
    Check( S_OK, pPropStg->ReadMultiple( 1, &rgcpropspec[0], &rgcpropvarRead[0] ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );

    // Write another property and read both properties back

    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[1], &rgcpropvarWrite[1], PID_FIRST_USABLE ));
    Check( S_OK, pPropStg->ReadMultiple( 2, &rgcpropspec[0], &rgcpropvarRead[0] ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
    rgcpropvarRead[1].Clear();

    Check( 0, RELEASE_INTERFACE(pPropStg) );

    // Verify that the streams look corrected.

    Check( S_OK, pStorage->OpenStream( oszName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
    Check( S_OK, pStm->Stat( &statstg, STATFLAG_NONAME ));
    Check( TRUE, CULargeInteger(0) != CULargeInteger(statstg.cbSize) );
    Check( 0, RELEASE_INTERFACE(pStm) );

    Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));

    // Write/read after disabling the stream-rename

    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT, STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE, &pPropStg ));

    hr = pPropStg->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&pPropStgTest) );
    if( SUCCEEDED(hr) )
        Check( S_OK, pPropStgTest->UseNTFS4Streams( TRUE ));
    if( E_NOINTERFACE == hr )
    {
        Status( "   ... Partially skipping, IStorageTest not available (free build?)\n" );
    }
    else
    {
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( S_OK, pPropStg->WriteMultiple( 2, &rgcpropspec[0], &rgcpropvarWrite[0], PID_FIRST_USABLE ));
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( S_OK, pPropStg->Commit( STGC_DEFAULT ));
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        RELEASE_INTERFACE( pPropStgTest );
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( 0, RELEASE_INTERFACE(pPropStg) );

        Check( S_OK, pPropSetStg->Open( fmtid, STGM_READ|STGM_SHARE_DENY_WRITE, &pPropStg ));
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( STG_E_FILENOTFOUND, pStorage->OpenStream( oszUpdateName, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pStm ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );
    }

    // Write to the property set, then cause it to be shutdown and reverted.

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( S_OK, pPropSetStg->Open( fmtid, STGM_SHARE_EXCLUSIVE|STGM_READWRITE, &pPropStg ));

    rgcpropvarWrite[0] = OLESTR("Hello");
    rgcpropvarWrite[1] = OLESTR("World");
    Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    RELEASE_INTERFACE(pPropSetStg);
    Check( 0, RELEASE_INTERFACE(pStorage) );    // Should flush the properties
    Check( STG_E_REVERTED, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
    Check( 0, RELEASE_INTERFACE(pPropStg) );

    Check( S_OK, g_pfnStgOpenStorageEx( oszFile, STGM_READ|STGM_SHARE_DENY_WRITE,
                                   STGFMT_ANY,
                                   0, NULL, NULL,
                                   IID_IPropertySetStorage,
                                   reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Open( fmtid, STGM_READ|STGM_SHARE_EXCLUSIVE, &pPropStg ));

    Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
    Check( 0, RELEASE_INTERFACE(pPropStg) );
    g_pfnFreePropVariantArray( 2, rgcpropvarRead );


    //
    //  Exit
    //

    RELEASE_INTERFACE(pPropSetStg);

    g_pfnFreePropVariantArray( 2, rgcpropvarWrite );
    g_pfnFreePropVariantArray( 2, rgcpropvarRead );

}   // test_Robustness



void
test_EmptyBag( OLECHAR *poszDir )
{
    OLECHAR oszFile[ MAX_PATH ];
    IStorage *pstg = NULL;
    IPropertyBagEx *pbag = NULL;
    PROPVARIANT propvar;
    IEnumSTATPROPBAG *penum = NULL;
    STATPROPBAG statpropbag;
    ULONG cFetched;

    ocscpy( oszFile, poszDir );
    ocscat( oszFile, OLESTR("test_EmptyBag") );

    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertyBagEx,
                                     (void**) &pbag ));

    PropVariantInit( &propvar );
    OLECHAR *poszName = OLESTR("test");
    Check( S_FALSE, pbag->ReadMultiple( 1, &poszName, &propvar, NULL ));
    Check( VT_EMPTY, propvar.vt );

    Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));
    Check( S_FALSE, penum->Next( 1, &statpropbag, &cFetched ));
    Check( 0, cFetched );

    Check( 0, RELEASE_INTERFACE(penum));
    Check( 0, RELEASE_INTERFACE(pbag));

}   // test_EmptyBag


void
test_BagDelete( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertyBagEx *pbag = NULL;
    IEnumSTATPROPBAG* penum = NULL;
    ULONG cFetched;
    ULONG i, j;
    OLECHAR * rgoszDelete[2];

    // Note that some of these names only differ by case, which is legal in a bag
    OLECHAR *rgoszNames[] = { OLESTR("www.microsoft.com/bag/test?prop1"),
                              OLESTR("www.microsoft.com/bag/test?PROP1"),
                              OLESTR("www.microsoft.com/bag/2test?prop1"),
                              OLESTR("www.microsoft.com/bag2/test?prop1") };

    CPropVariant rgcpropvarRead[ ELEMENTS(rgoszNames) + 1 ];
    STATPROPBAG rgstatpropbag[ ELEMENTS(rgoszNames) + 1 ];

    Status( "Property bag deletions\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    DeleteBagExProperties( pbag, OLESTR("") );

    //  ------------------------------------------
    //  Delete bag2/test?prop1 by name & by prefix
    //  ------------------------------------------

    for( i = 0; i < 2; i++ )
    {
        ULONG cFetchedExpected;

        switch(i)
        {
        case 0:
            // Delete by name
            rgoszDelete[0] = OLESTR("www.microsoft.com/bag2/test?prop1");
            cFetchedExpected = ELEMENTS(rgoszNames) - 1;
            break;

        case 1:
            // Delete by prefix
            rgoszDelete[0] = OLESTR("www.microsoft.com/bag2/test");
            cFetchedExpected = ELEMENTS(rgoszNames) - 1;
            break;

        default:
            Check( FALSE, TRUE ); //Check( FALSE, 0 == OLESTR("Invalid switch") );

        }   // switch(i)


        Check( S_OK, pbag->WriteMultiple( ELEMENTS(rgoszNames), rgoszNames, g_rgcpropvarAll ));
        Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
        DeleteBagExProperties( pbag, rgoszDelete[0] );
        Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));

        Check( ELEMENTS(rgoszNames) == cFetchedExpected ? S_OK : S_FALSE,
               penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));

        Check( TRUE, cFetchedExpected == cFetched );
        RELEASE_INTERFACE(penum);

        for( j = 0; j < cFetched; j++ )
        {
            Check( TRUE, !wcscmp(rgoszNames[j], rgstatpropbag[j].lpwstrName) );
            delete [] rgstatpropbag[j].lpwstrName;
        }

    }   // for( i = 0; i < 2; i++ )

    //  -----------------------------------------------
    //  Delete the two "/bag/test" properties by prefix
    //  -----------------------------------------------

    rgoszDelete[0] = OLESTR("www.microsoft.com/bag/test");
    Check( S_OK, pbag->WriteMultiple( ELEMENTS(rgoszNames), rgoszNames, g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
    DeleteBagExProperties( pbag, rgoszDelete[0] );
    Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));

    Check( S_FALSE, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, 2 == cFetched );
    RELEASE_INTERFACE(penum);

    for( j = 0; j < cFetched; j++ )
    {
        Check( TRUE, !wcscmp(rgoszNames[j+2], rgstatpropbag[j].lpwstrName) );
        delete [] rgstatpropbag[j].lpwstrName;
    }

    /*
    //  -------------------------
    //  Delete all the properties
    //  -------------------------

    rgoszDelete[0] = NULL;
    Check( S_OK, pbag->WriteMultiple( ELEMENTS(rgoszNames), rgoszNames, g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
    Check( S_OK, pbag->Delete( OLESTR(""), DELETEPROPERTY_MASK));
    Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));

    Check( S_FALSE, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, 0 == cFetched );
    RELEASE_INTERFACE(penum);
    */

    pbag->Release();

}   // test_BagDelete


void
test_IPropertyBag( IStorage *pstg )
{
    Status( "IPropertyBag\n" );
    IPropertyBagEx *pbagex = NULL;
    IPropertyBag *pbag = NULL;

    ULONG cRefsOriginal = GetRefCount( pstg );

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbagex) ));
    DeleteBagExProperties( pbagex, OLESTR("") );
    RELEASE_INTERFACE(pbagex);

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBag, reinterpret_cast<void**>(&pbag) ));

    VARIANT varWrite, varRead;
    VariantInit( &varWrite );
    VariantInit( &varRead );

    varWrite.vt = VT_I4;
    varWrite.lVal = 1234;

    Check( S_OK, pbag->Write( OLESTR("Variant I4"), &varWrite ));
    Check( S_OK, pbag->Read( OLESTR("Variant I4"), &varRead, NULL ));

    Check( TRUE, varWrite.vt == varRead.vt );
    Check( TRUE, varWrite.lVal == varRead.lVal );

    Check( cRefsOriginal, RELEASE_INTERFACE(pbag) );

}




void
test_BagVtUnknown( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertyBagEx *pbag = NULL;
    ULONG cRefsOriginal = 0;

    Status( "VT_UNKNOWN in an IPropertyBagEx\n" );

    pstg->AddRef();
    cRefsOriginal = pstg->Release();

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    DeleteBagExProperties( pbag, OLESTR("") );

    CObjectWithPersistStorage *pStgObjectWritten = NULL, *pStgObjectRead = NULL;
    CObjectWithPersistStream *pStmObjectWritten = NULL, *pStmObjectRead = NULL;

    pStgObjectWritten = new CObjectWithPersistStorage( OLESTR("VtUnknown-Storage") );
    pStgObjectRead    = new CObjectWithPersistStorage();

    pStmObjectWritten = new CObjectWithPersistStream( OLESTR("VtUnknown-Stream") );
    pStmObjectRead    = new CObjectWithPersistStream();

    Check( TRUE, NULL != pStgObjectWritten && NULL != pStgObjectRead );
    Check( TRUE, NULL != pStmObjectWritten && NULL != pStmObjectRead );

    VARIANT rgvarRead[2], rgvarWritten[2];

    VariantInit( &rgvarRead[0] );
    VariantInit( &rgvarRead[1] );
    VariantInit( &rgvarWritten[0] );
    VariantInit( &rgvarWritten[1] );

    rgvarWritten[0].vt = VT_UNKNOWN;
    rgvarWritten[0].punkVal = static_cast<IUnknown*>(pStgObjectWritten);

    rgvarWritten[1].vt = VT_BYREF | VT_UNKNOWN;
    IUnknown *punkByRefVal = static_cast<IUnknown*>(pStmObjectWritten);
    rgvarWritten[1].ppunkVal = &punkByRefVal;

    rgvarRead[0].vt = VT_UNKNOWN;
    rgvarRead[0].punkVal = static_cast<IUnknown*>(pStgObjectRead);
    rgvarRead[1].vt = VT_UNKNOWN;
    rgvarRead[1].punkVal = static_cast<IUnknown*>(pStmObjectRead);

    OLECHAR *rgoszName[2] = { OLESTR("VtUnknown (persisted as Storage)"),
                              OLESTR("ByRef VtUnknown (persisted as Stream)") };

    Check( S_OK, pbag->WriteMultiple( 2, rgoszName, reinterpret_cast<PROPVARIANT*>(rgvarWritten) ));
    Check( S_OK, pbag->ReadMultiple( 2, rgoszName, reinterpret_cast<PROPVARIANT*>(rgvarRead), NULL ));

    Check( TRUE, *pStgObjectRead == *pStgObjectWritten );
    Check( TRUE, *pStmObjectRead == *pStmObjectWritten );

    Check( 0, RELEASE_INTERFACE( pStgObjectRead ));
    Check( 0, RELEASE_INTERFACE( pStmObjectRead ));

    PROPVARIANT rgpropvarReadRaw[2];

    PropVariantInit( &rgpropvarReadRaw[0] );
    PropVariantInit( &rgpropvarReadRaw[1] );

    Check( S_OK, pbag->ReadMultiple( 2, rgoszName, rgpropvarReadRaw, NULL ));

    Check( VT_STORED_OBJECT, rgpropvarReadRaw[0].vt );
    Check( VT_STREAMED_OBJECT, rgpropvarReadRaw[1].vt );

    STATSTG statstg;
    Check( S_OK, rgpropvarReadRaw[0].pStorage->Stat( &statstg, STATFLAG_NONAME ));
    Check( TRUE, statstg.clsid == pStgObjectWritten->GetClassID() );

    Check( 0, RELEASE_INTERFACE( pStgObjectWritten ));
    Check( S_OK, PropVariantClear( &rgpropvarReadRaw[0] ));


    CLSID clsid;
    ULONG cbRead;
    Check( S_OK, rgpropvarReadRaw[1].pStream->Read( &clsid, sizeof(clsid), &cbRead ));
    Check( sizeof(clsid), cbRead );
    Check( TRUE, clsid == pStmObjectWritten->GetClassID() );

    Check( 0, RELEASE_INTERFACE( pStmObjectWritten ));
    Check( S_OK, PropVariantClear( &rgpropvarReadRaw[1] ));


    Check( cRefsOriginal, RELEASE_INTERFACE(pbag) );

}   // test_BagVtUnknown


void
test_BagEnum( IStorage *pstg )
{
    IPropertyBagEx *pbag = NULL;
    IEnumSTATPROPBAG *penum = NULL;
    ULONG cFetched;
    ULONG i;
    const OLECHAR * rgoszDelete[] = { OLESTR("") };

    const OLECHAR *rgoszNames[] = { OLESTR("www.microsoft.com/bag/test?prop1"),
                                    OLESTR("www.microsoft.com/bag/test?prop2"),
                                    OLESTR("www.microsoft.com/bag/2test?prop1"),
                                    OLESTR("www.microsoft.com/bag2/test?prop1") };
    STATPROPBAG rgstatpropbag[ ELEMENTS(rgoszNames) + 1 ];

    Status( "Property bag enumeration\n" );

    // Initialize the bag
    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    DeleteBagExProperties( pbag, OLESTR("") );
    Check( S_OK, pbag->WriteMultiple( ELEMENTS(rgoszNames), rgoszNames, g_rgcpropvarAll ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    // Try to enum n+1 elements (to get an S_FALSE)
    Check( S_OK, pbag->Enum( NULL, 0, &penum ));
    Check( S_FALSE, penum->Next( ELEMENTS(rgstatpropbag), rgstatpropbag, &cFetched ));
    Check( TRUE, ELEMENTS(rgoszNames) == cFetched );
    for( i = 0; i < cFetched; i++ )
        delete [] rgstatpropbag[i].lpwstrName;
    RELEASE_INTERFACE(penum);

    // Try to enum n elements (should get an S_OK)
    Check( S_OK, pbag->Enum( OLESTR(""), 0, &penum ));
    Check( S_OK, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, ELEMENTS(rgoszNames) == cFetched );
    for( i = 0; i < cFetched; i++ )
        delete [] rgstatpropbag[i].lpwstrName;
    RELEASE_INTERFACE(penum);

    // Enum a subset
    Check( S_OK, pbag->Enum( OLESTR("www.microsoft.com/bag/test"), 0, &penum ));
    Check( S_FALSE, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, 2 == cFetched );
    for( i = 0; i < cFetched; i++ )
        delete [] rgstatpropbag[i].lpwstrName;
    RELEASE_INTERFACE(penum);

    // Enum a non-extant subset
    Check( S_OK, pbag->Enum( OLESTR("dummy"), 0, &penum ));
    Check( S_FALSE, penum->Next( ELEMENTS(rgoszNames), rgstatpropbag, &cFetched ));
    Check( TRUE, 0 == cFetched );
    RELEASE_INTERFACE(penum);

    // Enum a single property
    Check( S_OK, pbag->Enum( OLESTR("www.microsoft.com/bag/test?prop1"), 0, &penum ));
    Check( S_FALSE, penum->Next( 2, rgstatpropbag, &cFetched ));
    Check( 1, cFetched );
    delete[] rgstatpropbag[0].lpwstrName;
    rgstatpropbag[0].lpwstrName = NULL;
    RELEASE_INTERFACE(penum);

    RELEASE_INTERFACE(pbag);


}   // test_BagEnum



void
test_BagCoercion( IStorage *pstg )
{
    IPropertyBag   *pbag = NULL;
    IPropertyBagEx *pbagX = NULL;
    const OLECHAR *rgosz[2];
    PROPVARIANT rgpropvar[2];

    Status( "Property bag coercion\n" );

    // Get a bag and a bagex, and clean the bag.

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBag,
                                reinterpret_cast<void**>(&pbag) ));
    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx,
                                reinterpret_cast<void**>(&pbagX) ));

    DeleteBagExProperties( pbagX, OLESTR("") );

    // Initialize the bag with some properties

    rgpropvar[0].vt = VT_I2;
    rgpropvar[0].iVal = 2;
    rgosz[0] = OLESTR("www.microsoft.com/test/i2");

    rgpropvar[1].vt = VT_UI2;
    rgpropvar[1].uiVal = 3;
    rgosz[1] = OLESTR("www.microsoft.com/test/ui2");

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));
    g_pfnFreePropVariantArray( 2, rgpropvar );

    // Read back the properties as (U)I4s with explicit coercion

    rgpropvar[0].vt = VT_I4;
    rgpropvar[1].vt = VT_UI4;

    Check( S_OK, pbagX->ReadMultiple( 2, rgosz, rgpropvar, NULL ));
    Check( TRUE, VT_I4 == rgpropvar[0].vt && 2 == rgpropvar[0].lVal );
    Check( TRUE, VT_UI4 == rgpropvar[1].vt && 3 == rgpropvar[1].ulVal );

    // This is an unrelated test, but while we're here, let's verify that we
    // can't write a PropVariant (non-Variant) type through the Bag interface.

    rgpropvar[0].vt= VT_I8;
    rgpropvar[0].hVal.QuadPart = 1;

    Check( STG_E_INVALIDPARAMETER, pbag->Write( rgosz[0],
                                                reinterpret_cast<VARIANT*>(&rgpropvar[0]) ));

    //--------
    rgpropvar[0].vt = VT_LPSTR;
    rgpropvar[0].pszVal = "Hello, world";
    rgpropvar[1].vt = VT_I4;
    rgpropvar[1].iVal = 123;

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));

    rgpropvar[0].vt = VT_EMPTY;
    rgpropvar[0].pszVal = NULL;
    rgpropvar[1].vt = VT_EMPTY;
    rgpropvar[1].iVal = -1;

    Check( S_OK, pbagX->ReadMultiple( 2, rgosz, rgpropvar, NULL ));
    Check( TRUE, VT_LPSTR == rgpropvar[0].vt
                        && 0==strcmp( "Hello, world", rgpropvar[0].pszVal ) );
    Check( TRUE, VT_I4 == rgpropvar[1].vt && 123 == rgpropvar[1].iVal );
    g_pfnFreePropVariantArray( 2, rgpropvar );

    //-------- Coercing Variant to Variant ------------------

    rgpropvar[0].vt = VT_I4;
    rgpropvar[0].lVal = 123;
    rgpropvar[1].vt = VT_I4;
    rgpropvar[1].lVal = 123;

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));

    rgpropvar[0].vt = VT_BSTR;
    rgpropvar[1].vt = VT_I4;

    Check( S_OK, pbagX->ReadMultiple( 2, rgosz, rgpropvar, NULL ));

    Check( TRUE, VT_BSTR == rgpropvar[0].vt
                        && !wcscmp( L"123", rgpropvar[0].bstrVal ));
    Check( TRUE, VT_I4 == rgpropvar[1].vt && 123 == rgpropvar[1].iVal );
    g_pfnFreePropVariantArray( 2, rgpropvar );


    //-------- Coercing PropVariant To PropVariant ------------
#define TEST_I8_VAL ((LONGLONG)1024*1000*1000*1000+42);


    rgpropvar[0].vt = VT_LPWSTR;
    rgpropvar[0].pwszVal = L"-312";
    rgpropvar[1].vt = VT_I8;
    rgpropvar[1].hVal.QuadPart = TEST_I8_VAL;

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));

    rgpropvar[0].vt = VT_I4;
    rgpropvar[0].pszVal = NULL;
    rgpropvar[1].vt = VT_LPWSTR;
    rgpropvar[1].hVal.QuadPart = -1;

    Check( S_OK, pbagX->ReadMultiple(2, rgosz, rgpropvar, NULL ) );

    Check( TRUE, VT_I4 == rgpropvar[0].vt && -312 == rgpropvar[0].lVal );
    Check( TRUE, VT_LPWSTR == rgpropvar[1].vt
                        && !wcscmp( L"1024000000042", rgpropvar[1].pwszVal ) );
    g_pfnFreePropVariantArray( 2, rgpropvar );


    //-------- Implcit Coercion PropVariant To Variant ------------
    rgpropvar[0].vt = VT_I8;
    rgpropvar[0].hVal.QuadPart = -666;
    rgpropvar[1].vt = VT_VECTOR | VT_LPSTR;
    rgpropvar[1].calpstr.cElems = 5;
    rgpropvar[1].calpstr.pElems = new LPSTR[5];
    rgpropvar[1].calpstr.pElems[0] = "Thirty Days hath September,";
    rgpropvar[1].calpstr.pElems[1] = "April, June and No Wonder?";
    rgpropvar[1].calpstr.pElems[2] = "All the Rest Have Thirty One";
    rgpropvar[1].calpstr.pElems[3] = "Except my dear Grand Mother.";
    rgpropvar[1].calpstr.pElems[4] = "She Has a Bright Red Tricycle.";

    Check( S_OK, pbagX->WriteMultiple( 2, rgosz, rgpropvar ));
    delete rgpropvar[1].calpstr.pElems;
    PropVariantInit(&rgpropvar[0]);
    PropVariantInit(&rgpropvar[1]);

    rgpropvar[0].vt = VT_EMPTY;
    rgpropvar[1].vt = VT_EMPTY;

    Check( S_OK, pbag->Read(rgosz[0], (VARIANT*)&rgpropvar[0], NULL ) );
    Check( S_OK, pbag->Read(rgosz[1], (VARIANT*)&rgpropvar[1], NULL ) );

    Check( TRUE, VT_I4 == rgpropvar[0].vt && -666 == rgpropvar[0].lVal );
    Check( TRUE, (VT_BSTR|VT_ARRAY) == rgpropvar[1].vt );
    g_pfnFreePropVariantArray( 2, rgpropvar );

    //
    // UnCoercible.
    //
    rgpropvar[0].vt = VT_UNKNOWN;
    rgpropvar[0].iVal = 42;   // GARBAGE value; untouched in the error path
    Check( DISP_E_TYPEMISMATCH, pbagX->ReadMultiple( 1, rgosz, rgpropvar, NULL ));
    Check( TRUE, VT_UNKNOWN == rgpropvar[0].vt && 42==rgpropvar[0].iVal );

    RELEASE_INTERFACE(pbagX);
    RELEASE_INTERFACE(pbag);

}   // test_BagCoercion

#define LOAD_VARIANT(var,vartype,field,value) (var).field = (value); (var).vt = vartype

void
test_ByRef( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    FMTID fmtid;

    Status( "ByRef Variants\n" );

    UuidCreate( &fmtid );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    PROPVARIANT rgvarWrite[17], rgvarRead[17];
    CPropSpec rgcpropspec[17];

    BYTE bVal = 1;
    LOAD_VARIANT(rgvarWrite[0], VT_UI1|VT_BYREF, pbVal, &bVal);
    rgcpropspec[0] = OLESTR("VT_UI1|VT_BYREF");

    SHORT iVal = 2;
    LOAD_VARIANT(rgvarWrite[1], VT_I2|VT_BYREF, piVal, &iVal );
    rgcpropspec[1] = OLESTR("VT_I2|VY_BYREF");

    LONG lVal = 3;
    LOAD_VARIANT(rgvarWrite[2], VT_I4|VT_BYREF, plVal, &lVal );
    rgcpropspec[2] = OLESTR("VT_I4|VY_BYREF");

    FLOAT fltVal = (float)4.1;
    LOAD_VARIANT(rgvarWrite[3], VT_R4|VT_BYREF, pfltVal, &fltVal );
    rgcpropspec[3] = OLESTR("VT_I4|VT_BYREF");

    DOUBLE dblVal = 5.2;
    LOAD_VARIANT(rgvarWrite[4], VT_R8|VT_BYREF, pdblVal, &dblVal );
    rgcpropspec[4] = OLESTR("VT_R8|VT_BYREF");

    VARIANT_BOOL boolVal = VARIANT_TRUE;
    LOAD_VARIANT(rgvarWrite[5], VT_BOOL|VT_BYREF, pboolVal, &boolVal );
    rgcpropspec[5] = OLESTR("VT_BOOL|VT_BYREF");

    SCODE scode = 6;
    LOAD_VARIANT(rgvarWrite[6], VT_ERROR|VT_BYREF, pscode, &scode );
    rgcpropspec[6] = OLESTR("VT_ERROR|VT_BYREF");

    CY cyVal = { 7 };
    LOAD_VARIANT(rgvarWrite[7], VT_CY|VT_BYREF, pcyVal, &cyVal );
    rgcpropspec[7] = OLESTR("VT_CY|VT_BYREF");

    DATE date = 8;
    LOAD_VARIANT(rgvarWrite[8], VT_DATE|VT_BYREF, pdate, &date );
    rgcpropspec[8] = OLESTR("VT_DATE|VT_BYREF");

    BSTR bstrVal = SysAllocString( OLESTR("9") );
    LOAD_VARIANT(rgvarWrite[9], VT_BSTR|VT_BYREF, pbstrVal, &bstrVal );
    rgcpropspec[9] = OLESTR("VT_BSTR|VT_BYREF");

    DECIMAL decVal = { 10, 9, 8, 7, 6 };
    LOAD_VARIANT(rgvarWrite[10], VT_DECIMAL|VT_BYREF, pdecVal, &decVal );
    rgcpropspec[10] = OLESTR("VT_DECIMAL|VT_BYREF");

    CHAR cVal = 11;
    LOAD_VARIANT(rgvarWrite[11], VT_I1 | VT_BYREF, pcVal, &cVal );
    rgcpropspec[11] = OLESTR("VT_I1|VT_BYREF");

    USHORT uiVal = 12;
    LOAD_VARIANT(rgvarWrite[12], VT_UI2 | VT_BYREF, puiVal, &uiVal );
    rgcpropspec[12] = OLESTR("VT_UI2|VT_BYREF");

    ULONG ulVal = 13;
    LOAD_VARIANT(rgvarWrite[13], VT_UI4 | VT_BYREF, pulVal, &ulVal );
    rgcpropspec[13] = OLESTR("VT_UI4|VT_BYREF");

    INT intVal = 14;
    LOAD_VARIANT(rgvarWrite[14], VT_INT | VT_BYREF, pintVal, &intVal );
    rgcpropspec[14] = OLESTR("VT_INT|VT_BYREF");

    UINT uintVal = 15;
    LOAD_VARIANT(rgvarWrite[15], VT_UINT | VT_BYREF, puintVal, &uintVal );
    rgcpropspec[15] = OLESTR("VT_UINT | VT_BYREF");

    CPropVariant cpropvarVal = (long) 16;
    Check( VT_I4, cpropvarVal.vt );
    LOAD_VARIANT(rgvarWrite[16], VT_VARIANT| VT_BYREF, pvarVal, &cpropvarVal );
    rgcpropspec[16] = OLESTR("VT_VARIANT | VT_BYREF");


    Check( S_OK, pPropStg->WriteMultiple( sizeof(rgvarWrite)/sizeof(rgvarWrite[0]),
                                          rgcpropspec,
                                          reinterpret_cast<PROPVARIANT*>(rgvarWrite),
                                          PID_FIRST_USABLE ));

    for( int i = 0; i < sizeof(rgvarRead)/sizeof(rgvarRead[0]); i++ )
        PropVariantInit( &rgvarRead[i] );

    Check( S_OK, pPropStg->ReadMultiple( sizeof(rgvarRead)/sizeof(rgvarRead[0]),
                                         rgcpropspec,
                                         reinterpret_cast<PROPVARIANT*>(rgvarRead) ));

    Check( VT_UI1, rgvarRead[0].vt );
    Check( TRUE, rgvarRead[0].bVal == *rgvarWrite[0].pbVal );

    Check( VT_I2, rgvarRead[1].vt );
    Check( TRUE, rgvarRead[1].iVal == *rgvarWrite[1].piVal );

    Check( VT_I4, rgvarRead[2].vt );
    Check( TRUE, rgvarRead[2].lVal == *rgvarWrite[2].plVal );

    Check( VT_R4, rgvarRead[3].vt );
    Check( TRUE, rgvarRead[3].fltVal == *rgvarWrite[3].pfltVal );

    Check( VT_R8, rgvarRead[4].vt );
    Check( TRUE, rgvarRead[4].dblVal == *rgvarWrite[4].pdblVal );

    Check( VT_BOOL, rgvarRead[5].vt );
    Check( TRUE, rgvarRead[5].boolVal == *rgvarWrite[5].pboolVal );

    Check( VT_ERROR, rgvarRead[6].vt );
    Check( TRUE, rgvarRead[6].scode == *rgvarWrite[6].pscode );

    Check( VT_CY, rgvarRead[7].vt );
    Check( 0, memcmp( &rgvarRead[7].cyVal, rgvarWrite[7].pcyVal, sizeof(CY) ));

    Check( VT_DATE, rgvarRead[8].vt );
    Check( TRUE, rgvarRead[8].date == *rgvarWrite[8].pdate );

    Check( VT_BSTR, rgvarRead[9].vt );
    Check( 0, ocscmp( rgvarRead[9].bstrVal, *rgvarWrite[9].pbstrVal ));

    Check( VT_DECIMAL, rgvarRead[10].vt );
    Check( 0, memcmp( &rgvarRead[10].decVal.scale, &rgvarWrite[10].pdecVal->scale,
                      sizeof(decVal) - sizeof(decVal.wReserved) ));

    Check( VT_I1, rgvarRead[11].vt );
    Check( TRUE, rgvarRead[11].cVal == *rgvarWrite[11].pcVal );

    Check( VT_UI2, rgvarRead[12].vt );
    Check( TRUE, rgvarRead[12].uiVal == *rgvarWrite[12].puiVal );

    Check( VT_UI4, rgvarRead[13].vt );
    Check( TRUE, rgvarRead[13].ulVal == *rgvarWrite[13].pulVal );

    Check( VT_INT, rgvarRead[14].vt );
    Check( TRUE, rgvarRead[14].intVal == *rgvarWrite[14].pintVal );

    Check( VT_UINT, rgvarRead[15].vt );
    Check( TRUE, rgvarRead[15].uintVal == *rgvarWrite[15].puintVal );

    Check( VT_I4, rgvarRead[16].vt );
    Check( TRUE, rgvarRead[16].lVal == rgvarWrite[16].pvarVal->lVal );


    Check( 0, RELEASE_INTERFACE(pPropStg) );
    RELEASE_INTERFACE(pPropSetStg);

    g_pfnFreePropVariantArray( sizeof(rgvarRead)/sizeof(rgvarRead[0]), rgvarRead );
    SysFreeString( bstrVal );

}



void
test_SettingLocalization( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    FMTID fmtid;
    CPropVariant rgcpropvarWrite[3], rgcpropvarRead[3];
    CPropSpec    rgcpropspec[3];
    ULONG cRefsOriginal = GetRefCount( pstg );

    Status( "Changing localization properties\n" );

    UuidCreate( &fmtid );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));

    for( int i = 0; i < 2; i++ )
    {
        // Create a unicode or ansi property set

        Check( S_OK, pPropSetStg->Create( fmtid, NULL,
                                          0 == i ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI,
                                          STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                          &pPropStg ));

        //  ---------------------------
        //  Change the codepage to Ansi
        //  ---------------------------

        // Set the codepage.  This should work because it's currently empty
        // (note that it's also currently Unicode).  Set it to GetACP+1 just
        // to be sure that we can set a non-default codepage.

        rgcpropspec[0] = PID_CODEPAGE;
        rgcpropvarWrite[0] = (short) (GetACP() + 1);
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );

        // Now set the codepage to GetACP so that we can work on it.

        rgcpropvarWrite[0] = (short) GetACP();
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );

        // Write some named properties.  The VT_LPSTR shouldn't get converted to Unicode
        // now that this is an Ansi property set.

        rgcpropvarWrite[0] = "Hello, world";
        rgcpropvarWrite[1].SetBSTR( OLESTR("How are you?") );
        rgcpropspec[0] = PID_FIRST_USABLE;
        rgcpropspec[1] = OLESTR("Second property name");
        Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        // If we stat the IPropertyStorage, it should call itself Ansi.

        STATPROPSETSTG statpropsetstg;
        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( PROPSETFLAG_ANSI, PROPSETFLAG_ANSI & statpropsetstg.grfFlags );

        // Verify that we can close and re-open it and everything's still the same.

        Check( 0, RELEASE_INTERFACE(pPropStg) );
        Check( S_OK, pPropSetStg->Open( fmtid, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pPropStg ));

        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( PROPSETFLAG_ANSI, PROPSETFLAG_ANSI & statpropsetstg.grfFlags );

        //  ------------------------------
        //  Change the codepage to Unicode
        //  ------------------------------

        // Clear out the property set.

        PROPID propidDictionary = PID_DICTIONARY;
        Check( S_OK, pPropStg->DeleteMultiple( 2, rgcpropspec ));
        Check( S_OK, pPropStg->DeletePropertyNames( 1, &propidDictionary ));

        // Switch to Unicode

        rgcpropvarWrite[0] = (short) CP_WINUNICODE;
        rgcpropspec[0] = PID_CODEPAGE;
        Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarRead[0] == rgcpropvarWrite[0] );

        // Verify with a Stat

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( 0, PROPSETFLAG_ANSI & statpropsetstg.grfFlags );

        // Write & read some properties again.  This time the LPSTR should be converted.

        rgcpropvarWrite[0] = "Hello, world";
        rgcpropvarWrite[1].SetBSTR( OLESTR("How are you?") );
        rgcpropspec[0] = PID_FIRST_USABLE;
        rgcpropspec[1] = OLESTR("Second property name");
        Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        // Close, reopen, and read/stat again

        Check( 0, RELEASE_INTERFACE(pPropStg) );
        Check( S_OK, pPropSetStg->Open( fmtid, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pPropStg ));

        Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        Check( S_OK, pPropStg->Stat( &statpropsetstg ));
        Check( 0, PROPSETFLAG_ANSI & statpropsetstg.grfFlags );

        Check( 0, RELEASE_INTERFACE(pPropStg) );

    }   // for( int i = 0; i < 2; i++ )


    //  -----------------------
    //  Validate error checking
    //  -----------------------

    // Create a new property set

    Check( S_OK, pPropSetStg->Create( fmtid, NULL,
                                      0 == i ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    // After writing a property, we shouldn't be able to set the codepage or LCID

    rgcpropspec[0] = PID_FIRST_USABLE;
    rgcpropvarWrite[0] = (long) 1234;
    Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    rgcpropspec[0] = PID_CODEPAGE;
    rgcpropvarWrite[0] = (short) 1234;
    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    rgcpropspec[0] = PID_LOCALE;
    rgcpropvarWrite[0] = (ULONG) 5678;
    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    // But it's settable after deleting the property

    rgcpropspec[0] = PID_FIRST_USABLE;
    Check( S_OK, pPropStg->DeleteMultiple( 1, rgcpropspec ));

    rgcpropspec[0] = PID_CODEPAGE;
    rgcpropvarWrite[0] = (short) 1234;
    Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    rgcpropspec[1] = PID_LOCALE;
    rgcpropvarWrite[1] = (ULONG) 5678;
    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[1], &rgcpropvarWrite[1], PID_FIRST_USABLE ));

    Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPropStg->ReadMultiple(2, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );

    // But again it's not writable if there's a name in the dictionary

    rgcpropspec[0] = PID_CODEPAGE;
    rgcpropvarWrite[0] = (short) CP_WINUNICODE;
    Check( S_OK, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    PROPID rgpropid[1] = { PID_FIRST_USABLE };
    LPOLESTR rglposz[1] = { OLESTR("Hello") };

    Check( S_OK, pPropStg->WritePropertyNames( 1, rgpropid, rglposz ));

    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));


    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( cRefsOriginal, RELEASE_INTERFACE(pPropSetStg) );

}



void
test_ExtendedTypes( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    FMTID fmtid;

    Status( "Extended Types\n" );

    UuidCreate( &fmtid );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    CPropVariant rgcpropvarWrite[5], rgcpropvarRead[5];
    CPropSpec rgcpropspec[5];


    rgcpropvarWrite[0] = (CHAR) 1;
    rgcpropspec[0] = OLESTR("VT_I1");

    DECIMAL decVal = { 10, 9, 8, 7, 6 };
    rgcpropvarWrite[1] = decVal;
    rgcpropspec[1] = OLESTR("VT_DECIMAL");

    rgcpropvarWrite[2].SetINT( 2 );
    rgcpropspec[2] = OLESTR("VT_INT");

    rgcpropvarWrite[3].SetUINT( 3 );
    rgcpropspec[3] = OLESTR("VT_UINT");

    rgcpropvarWrite[4][1] = (CHAR) 2;
    rgcpropvarWrite[4][0] = (CHAR) 1;
    rgcpropspec[4] = OLESTR("VT_VECTOR|VT_I1");

    Check( S_OK, pPropStg->WriteMultiple( sizeof(rgcpropvarWrite)/sizeof(rgcpropvarWrite[0]),
                                          rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    for( int i = 0; i < sizeof(rgcpropvarRead)/sizeof(rgcpropvarRead[0]); i++ )
        PropVariantInit( &rgcpropvarRead[i] );
    CheckFormatVersion(pPropStg, PROPSET_WFORMAT_EXPANDED_VTS);


    Check( S_OK, pPropStg->ReadMultiple( sizeof(rgcpropvarRead)/sizeof(rgcpropvarRead[0]),
                                         rgcpropspec,
                                         reinterpret_cast<PROPVARIANT*>(rgcpropvarRead) ));

    Check( rgcpropvarRead[0].vt, rgcpropvarWrite[0].vt );
    Check( TRUE, rgcpropvarWrite[0].cVal == rgcpropvarRead[0].cVal );

    Check( rgcpropvarRead[1].vt, rgcpropvarWrite[1].vt );
    Check( 0, memcmp( &rgcpropvarRead[1].decVal.scale, &rgcpropvarWrite[1].decVal.scale,
                      sizeof(rgcpropvarRead[1].decVal) - sizeof(rgcpropvarRead[1].decVal.wReserved) ));

    Check( rgcpropvarRead[2].vt, rgcpropvarWrite[2].vt );
    Check( rgcpropvarRead[2].intVal, rgcpropvarWrite[2].intVal );

    Check( rgcpropvarRead[3].vt, rgcpropvarWrite[3].vt );
    Check( rgcpropvarRead[3].uintVal, rgcpropvarWrite[3].uintVal );

    Check( TRUE, rgcpropvarRead[4] == rgcpropvarWrite[4] );

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    RELEASE_INTERFACE(pPropSetStg);
}



void
test_StgOnHandle( OLECHAR *poszDir )
{
    HRESULT hr = S_OK;
    OLECHAR oszFile[ MAX_PATH ], oszDir[ MAX_PATH ];
    CPropVariant cpropvarWrite, cpropvarRead;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hDir = INVALID_HANDLE_VALUE;

    IPropertyBagEx *pbag = NULL;

    Status( "StgOpenStorageOnHandle\n" );

    ocscpy( oszFile, poszDir );
    ocscat( oszFile, OLESTR("test_StgOnHandle") );
    ocscpy( oszDir, poszDir );
    ocscat( oszDir, OLESTR("test_StgOnHandle Dir") );

    // Create a storage and put a property in it.

    Check( S_OK, g_pfnStgCreateStorageEx( oszFile, STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                          DetermineStgFmt( g_enumImplementation ),
                                          0, NULL, NULL,
                                          IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));


    OLECHAR *poszPropName = OLESTR("Prop Name");
    cpropvarWrite = (long) 123;  // VT_I4

    Check( S_OK, pbag->WriteMultiple( 1, &poszPropName, &cpropvarWrite ));
    Check( 0, RELEASE_INTERFACE(pbag) );

    // Create a directory and put a property in it too.

    Check( TRUE, CreateDirectory( oszDir, NULL ));

    hDir = CreateFile( oszDir, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                       NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, INVALID_HANDLE_VALUE );
    Check( TRUE, INVALID_HANDLE_VALUE != hDir );

    Check( S_OK, g_pfnStgOpenStorageOnHandle( hDir, STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                              NULL, NULL,
                                              IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    CloseHandle( hDir );

    Check( S_OK, pbag->WriteMultiple( 1, &poszPropName, &cpropvarWrite ));
    Check( 0, RELEASE_INTERFACE(pbag) );

    // Open the file and read the properties

    hFile = CreateFile( oszFile, GENERIC_READ|GENERIC_WRITE, 0,
                        NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL );
    Check( TRUE, INVALID_HANDLE_VALUE != hFile );

    Check( S_OK, g_pfnStgOpenStorageOnHandle( hFile, STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                              NULL, NULL,
                                              IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));

    CloseHandle( hFile );

    PropVariantClear( &cpropvarRead );
    Check( S_OK, pbag->ReadMultiple( 1, &poszPropName, &cpropvarRead, NULL ));
    Check( TRUE, cpropvarRead == cpropvarWrite );

    Check( 0, RELEASE_INTERFACE(pbag) );

    // Open the directory and read the properties

    hFile = CreateFile( oszDir, GENERIC_READ|GENERIC_WRITE, 0,
                        NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
    Check( TRUE, INVALID_HANDLE_VALUE != hFile );

    Check( S_OK, g_pfnStgOpenStorageOnHandle( hFile, STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                              NULL, NULL,
                                              IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));

    CloseHandle( hFile );

    PropVariantClear( &cpropvarRead );
    Check( S_OK, pbag->ReadMultiple( 1, &poszPropName, &cpropvarRead, NULL ));
    Check( TRUE, cpropvarRead == cpropvarWrite );

    Check( 0, RELEASE_INTERFACE(pbag) );


}



void
test_PropsetOnEmptyFile( OLECHAR *poszDir )
{
    HRESULT hr = S_OK;
    OLECHAR oszFile[ MAX_PATH ];
    CPropVariant cpropvarWrite, cpropvarRead;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    IPropertySetStorage *pset = NULL;

    // We only run this test for NFF property sets; there's special code there
    // for the case of a read-only open of an empty file.

    if( PROPIMP_NTFS != g_enumImplementation ) return;
    Status( "Empty file\n" );

    ocscpy( oszFile, poszDir );
    ocscat( oszFile, OLESTR("test_PropsetOnEmptyFile") );

    // Create a file

    hFile = CreateFile( oszFile, GENERIC_READ|GENERIC_WRITE, 0,
                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE );
    Check( FALSE, INVALID_HANDLE_VALUE == hFile );
    CloseHandle( hFile );

    // Get a read-only property interface on the file.

    Check( S_OK, StgOpenStorageEx( oszFile, STGM_READ|STGM_SHARE_DENY_WRITE,
                                   STGFMT_ANY, 0, NULL, NULL,
                                   IID_IPropertySetStorage,
                                   reinterpret_cast<void**>(&pset) ));

    Check( 0, RELEASE_INTERFACE(pset) );

}

void
test_PropsetOnHGlobal()
{
    HANDLE hglobal = NULL;
    IPropertyStorage *pPropStg = NULL;
    IStream *pStm = NULL;

    Status( "StgCreate/OpenPropStg on CreateStreamOnHGlobal\n" );

    // Build up an IPropertyStorage on a memory block

    hglobal = GlobalAlloc( GHND, 0 );
    Check( FALSE, NULL == hglobal );

    Check( S_OK, CreateStreamOnHGlobal( hglobal, FALSE, &pStm ));
    hglobal = NULL;

    Check( S_OK, StgCreatePropStg( (IUnknown*) pStm, FMTID_NULL, &CLSID_NULL,
                                   PROPSETFLAG_DEFAULT,
                                   0L, // Reserved
                                   &pPropStg ));

    // Write a Unicode string property to the property set

    CPropVariant rgcpropvarWrite[2] = { L"First Value", L"Second Value" };
    CPropSpec rgcpropspec[2] = { L"First Name", L"Second Name" };


    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[0], &rgcpropvarWrite[0], PID_FIRST_USABLE ));

    // Close the IPropertyStorage and IStream.

    Check( S_OK, pPropStg->Commit( STGC_DEFAULT )); // Flush to pStm
    Check( 0, RELEASE_INTERFACE(pPropStg) );

    Check( S_OK, GetHGlobalFromStream( pStm, &hglobal ));
    Check( 0, RELEASE_INTERFACE(pStm) );

    // Reopen everything

    Check( S_OK, CreateStreamOnHGlobal( hglobal, FALSE, &pStm ));
    hglobal = NULL;

    Check( S_OK, StgOpenPropStg( (IUnknown*) pStm, FMTID_NULL,
                                 PROPSETFLAG_DEFAULT,
                                 0L, // Reserved
                                 &pPropStg ));

    // Write another property

    Check( S_OK, pPropStg->WriteMultiple( 1, &rgcpropspec[1], &rgcpropvarWrite[1], PID_FIRST_USABLE ));

    // Read and verify the properties

    CPropVariant rgcpropvarRead[2];

    Check( S_OK, pPropStg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarRead[0] == rgcpropvarWrite[0] );
    Check( TRUE, rgcpropvarRead[1] == rgcpropvarWrite[1] );

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( S_OK, GetHGlobalFromStream( pStm, &hglobal ));
    Check( 0, RELEASE_INTERFACE(pStm) );

    // Reopen everything using a read-only stream.

    Check( S_OK, CreateStreamOnHGlobal( hglobal, TRUE, &pStm ));
    hglobal = NULL;

    CReadOnlyStream ReadOnlyStream( pStm );

    Check( S_OK, StgOpenPropStg( (IUnknown*) &ReadOnlyStream, FMTID_NULL,
                                 PROPSETFLAG_DEFAULT,
                                 0L, // Reserved
                                 &pPropStg ));

    Check( STG_E_ACCESSDENIED, pPropStg->WriteMultiple( 1, &rgcpropspec[1],
           &rgcpropvarWrite[1], PID_FIRST_USABLE ));

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( 0, RELEASE_INTERFACE(pStm) );

}


void
test_SafeArray( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    FMTID fmtid;
    ULONG crefpstg = 0;

    Status( "SafeArrays\n" );

    UuidCreate( &fmtid );

    pstg->AddRef();
    crefpstg = pstg->Release();

    // Get an IPropertyStorage from the input IStorage

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));


    SAFEARRAY *rgpsa[] = { NULL, NULL, NULL }; //, NULL, NULL };
    CPropVariant *rgcpropvar = NULL;
    SAFEARRAYBOUND rgsaBounds[] = { {2,0}, {3,10}, {4,20} };  // [0..1], [10..12], [20..23]
    ULONG cDims = sizeof(rgsaBounds)/sizeof(rgsaBounds[0]);
    ULONG cElems = 0;

    // Create three SafeArrays to test a fixed sized type, a variable sized type
    // (which is also ByRef), and a Variant.

    rgpsa[0] = SafeArrayCreate( VT_I4, 3, rgsaBounds );   // Try both Create and CreateEx
    Check( TRUE, NULL != rgpsa[0] );

    rgpsa[1] = SafeArrayCreateEx( VT_BSTR, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[1] );

    rgpsa[2] = SafeArrayCreateEx( VT_VARIANT, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[2] );

    /*
    rgpsa[3] = SafeArrayCreateEx( VT_I8, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[3] );

    rgpsa[4] = SafeArrayCreateEx( VT_UI8, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[4] );
    */


    // Determine how many elements are in the SafeArrays, and alloc that
    // many PropVariants.  We'll need this for the SafeArray of Variants.

    cElems = CalcSafeArrayElementCount( rgpsa[0] );
    rgcpropvar = new CPropVariant[ cElems ];
    Check( FALSE, NULL == rgcpropvar );

    // Fill in each of the SafeArrays.

    for( ULONG i = 0; i < cElems; i++ )
    {
        LONG rgIndices[3];

        // Map this this element from linear space to bounds space
        CalcSafeArrayIndices( i, rgIndices, rgsaBounds, cDims );

        // Add an I4
        LONG lVal = static_cast<LONG>(i);
        Check( S_OK, SafeArrayPutElement( rgpsa[0], rgIndices, &lVal ));

        // Add a BSTR
        BSTR bstrVal = SysAllocString( OLESTR("0 BSTR Val") );
        *bstrVal = OLESTR('0') + static_cast<OLECHAR>(i);
        Check( S_OK, SafeArrayPutElement( rgpsa[1], rgIndices, bstrVal ));

        // Add a PropVariant that could be an I4 or a BSTR

        if( i & 1 )
            rgcpropvar[i] = (long) i;
        else
            rgcpropvar[i].SetBSTR( bstrVal );   // Copies string

        Check( S_OK, SafeArrayPutElement( rgpsa[2], rgIndices, &rgcpropvar[i] ));

        // The SafeArrays have copied the BSTR, so we can free our local copy
        SysFreeString( bstrVal );

        // Add I8/UI8
        /*
        LONGLONG llVal = i;
        Check( S_OK, SafeArrayPutElement( rgpsa[3], rgIndices, &llVal ));

        llVal += 1000;
        Check( S_OK, SafeArrayPutElement( rgpsa[4], rgIndices, &llVal ));
        */
    }


    VARIANT rgvarWrite[3], rgvarRead[3];
    PROPVARIANT rgpropvarCopy[3];
    CPropSpec rgcpropspec[3];

    // Load the SafeArrays into PropVariants

    LOAD_VARIANT(rgvarWrite[0], VT_ARRAY|VT_I4, parray, rgpsa[0] );
    rgcpropspec[0] = OLESTR("VT_ARRAY|VT_I4");

    LOAD_VARIANT(rgvarWrite[1], VT_BYREF|VT_ARRAY|VT_BSTR, pparray, &rgpsa[1] );
    rgcpropspec[1] = OLESTR("VT_BYREF|VT_ARRAY|VT_BSTR");

    LOAD_VARIANT(rgvarWrite[2], VT_ARRAY|VT_VARIANT, parray, rgpsa[2] );
    rgcpropspec[2] = OLESTR("VT_ARRAY|VT_VARIANT");

    /*
    LOAD_VARIANT(rgvarWrite[3], VT_ARRAY|VT_I8, parray, rgpsa[3] );
    rgcpropspec[3] = OLESTR("VT_ARRAY|VT_I8");

    LOAD_VARIANT(rgvarWrite[4], VT_ARRAY|VT_UI8, parray, rgpsa[4] );
    rgcpropspec[4] = OLESTR("VT_ARRAY|VT_UI8");
    */

    // Write the PropVariant SafeArrays and verify that the propset version in the
    // header gets incremented.

    Check( S_OK, pPropStg->WriteMultiple( sizeof(rgvarWrite)/sizeof(rgvarWrite[0]),
                                          rgcpropspec,
                                          reinterpret_cast<PROPVARIANT*>(rgvarWrite),
                                          PID_FIRST_USABLE ));
    CheckFormatVersion(pPropStg, PROPSET_WFORMAT_EXPANDED_VTS);

    // Test PropVariantCopy by copying each of the PropVariants and comparing the result.

    for( i = 0; i < sizeof(rgvarRead)/sizeof(rgvarRead[0]); i++ )
    {
        PropVariantInit( &rgpropvarCopy[i] );
        Check( S_OK, g_pfnPropVariantCopy( &rgpropvarCopy[i], reinterpret_cast<PROPVARIANT*>(&rgvarWrite[i]) ));
        Check( rgpropvarCopy[i].vt, rgvarWrite[i].vt );

        if( VT_BYREF & rgpropvarCopy[i].vt )
            CompareSafeArrays( *rgpropvarCopy[i].pparray, *rgvarWrite[i].pparray );
        else
            CompareSafeArrays( rgpropvarCopy[i].parray, rgvarWrite[i].parray );

        // As long as we're looping, let's start init-ing the Read array too.
        VariantInit( &rgvarRead[i] );
    }

    // Read back the values that we wrote.

    Check( S_OK, pPropStg->ReadMultiple( sizeof(rgvarRead)/sizeof(rgvarRead[0]),
                                         rgcpropspec,
                                         reinterpret_cast<PROPVARIANT*>(rgvarRead) ));

    // Validate the Read values.  For the second one, the byref should no longer
    // be set.

    Check( rgvarWrite[0].vt, rgvarRead[0].vt );
    CompareSafeArrays( rgvarWrite[0].parray, rgvarRead[0].parray );

    Check( 0, rgvarRead[1].vt & VT_BYREF );
    Check( rgvarWrite[1].vt, rgvarRead[1].vt|VT_BYREF );
    CompareSafeArrays( *rgvarWrite[1].pparray, rgvarRead[1].parray );

    Check( rgvarWrite[2].vt, rgvarRead[2].vt );
    CompareSafeArrays( rgvarWrite[2].parray, rgvarRead[2].parray );

    /*
    Check( rgvarWrite[3].vt, rgvarRead[3].vt );
    CompareSafeArrays( rgvarWrite[3].parray, rgvarRead[3].parray );

    Check( rgvarWrite[4].vt, rgvarRead[4].vt );
    CompareSafeArrays( rgvarWrite[4].parray, rgvarRead[4].parray );
    */

    // Free the safearrays (they're in rgvarWrite, but we don't clear that).
    Check( S_OK, SafeArrayDestroy( rgpsa[0] ));
    Check( S_OK, SafeArrayDestroy( rgpsa[1] ));
    Check( S_OK, SafeArrayDestroy( rgpsa[2] ));
    /*
    Check( S_OK, SafeArrayDestroy( rgpsa[3] ));
    Check( S_OK, SafeArrayDestroy( rgpsa[4] ));
    */

    Check( S_OK, g_pfnFreePropVariantArray( sizeof(rgpropvarCopy)/sizeof(rgpropvarCopy[0]),
                                            reinterpret_cast<PROPVARIANT*>(rgpropvarCopy) ));
    Check( S_OK, g_pfnFreePropVariantArray( sizeof(rgvarRead)/sizeof(rgvarRead[0]),
                                            reinterpret_cast<PROPVARIANT*>(rgvarRead) ));

    Check( S_OK, g_pfnFreePropVariantArray( cElems, rgcpropvar ));


    //  ------------------------------------------------------
    //  Verify that we can't write a safearray with a bad type
    //  ------------------------------------------------------

    LONG rgIndices[] = { 0 };
    VARIANT *pvar;

    rgpsa[0] = SafeArrayCreateVector( VT_VARIANT, 0, 1 );
    Check( TRUE, NULL != rgpsa[0] );
    SafeArrayPtrOfIndex( rgpsa[0], rgIndices, reinterpret_cast<void**>(&pvar) );
    pvar->vt = VT_STREAM;

    rgcpropvar[0].vt = VT_ARRAY | VT_VARIANT;
    rgcpropvar[0].parray = rgpsa[0];
    rgpsa[0] = NULL;


    // In NT5, this returned HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), which was
    // the error that StgConvertVariantToPropertyNoEH got from SafeArrayGetVartype.
    // In Whistler, SafeArrayGetVartype is returning success, so the error doesn't
    // get caught until the recursive call to StgConvertVariantToPropertyNoEH,
    // which returns STATUS_INVALID_PARAMETER, which gets translated into
    // STG_E_INVALIDPARAMETER.

    Check( STG_E_INVALIDPARAMETER,
           pPropStg->WriteMultiple( 1, rgcpropspec, rgcpropvar, PID_FIRST_USABLE ));

    // Clear the propvar we just used (which also destroys the safearray)
    Check( S_OK, g_pfnPropVariantClear( &rgcpropvar[0] ) );



    Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvar, PID_FIRST_USABLE ));

    Check( S_OK, g_pfnFreePropVariantArray( 2, rgcpropvar ));



    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( crefpstg, RELEASE_INTERFACE(pPropSetStg) );

    delete[] rgcpropvar;
}


void
test_ReadOnlyReservedProperties( IStorage *pStg )
{
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    CPropVariant cpropvar = L"Property Value";
    CPropSpec cpropspec;
    FMTID fmtid;
    ULONG cRefsOriginal = GetRefCount(pStg);

    Status( "Read-only reserved PROPIDs\n" );

    UuidCreate( &fmtid );

    Check( S_OK, pStg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    cpropspec = PID_BEHAVIOR + 1;
    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, &cpropspec, &cpropvar, PID_FIRST_USABLE ));

    cpropspec = PID_MAX_READONLY;
    Check( STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, &cpropspec, &cpropvar, PID_FIRST_USABLE ));

    cpropspec = PID_MAX_READONLY + 1;
    Check( S_OK, pPropStg->WriteMultiple( 1, &cpropspec, &cpropvar, PID_FIRST_USABLE ));

    Check( 0, RELEASE_INTERFACE(pPropStg) );
    Check( cRefsOriginal, RELEASE_INTERFACE(pPropSetStg) );


}


void
test_LowMemory( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertySetStorage *psetstg = NULL;
    IPropertyStorage *ppropstg = NULL;
    IStorageTest *ptest = NULL;
    CPropSpec rgcpropspec[2];
    CPropVariant rgcpropvarWrite[2], rgcpropvarRead[2];
    int i;

    Status( "Low-memory mapped stream code\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&psetstg) ));

    for( i = 0; i < 2; i++ )
    {
        DWORD propsetflag = i == 0 ? PROPSETFLAG_DEFAULT : PROPSETFLAG_NONSIMPLE;

        FMTID fmtid;
        UuidCreate( &fmtid );

        Check( S_OK, psetstg->Create( fmtid, NULL, propsetflag,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &ppropstg ));

        // Go into low-memory mode

        hr = ppropstg->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
        if( SUCCEEDED(hr) )
            hr = ptest->SimulateLowMemory( TRUE );

        // IStorageTest isn't available in a free build.  As of this writing
        // it's not available in docfile.

        if( E_NOINTERFACE == hr )
        {
            Status( "   ... Partially skipping, IStorageTest not available\n" );
            continue;
        }
        else
            Check( S_OK, hr );


        // Write and read properties

        rgcpropspec[0] = OLESTR("First property");
        rgcpropvarWrite[0] = "Hello, world";
        rgcpropspec[1] = OLESTR("Second property");
        rgcpropvarWrite[1] = "How are you?";

        Check( S_OK, ppropstg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, ppropstg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        // Write, commit, and read

        g_pfnFreePropVariantArray( 2, rgcpropvarWrite );
        rgcpropvarWrite[0] = CBlob( L"go blue" );
        rgcpropvarWrite[1] = static_cast<CLSID>(fmtid);

        Check( S_OK, ppropstg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, ppropstg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));

        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        Check( S_OK, ppropstg->Commit( STGC_DEFAULT ));
        Check( S_OK, ppropstg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        // Write, close, reopen, and read

        g_pfnFreePropVariantArray( 2, rgcpropvarWrite );
        rgcpropvarWrite[0] = 0.1234;
        rgcpropvarWrite[1] = CClipData("Hi");
        Check( S_OK, ppropstg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

        RELEASE_INTERFACE(ptest);
        RELEASE_INTERFACE(ppropstg);

        Check( S_OK, psetstg->Open( fmtid, STGM_READ|STGM_SHARE_EXCLUSIVE, &ppropstg ));
        Check( S_OK, ppropstg->ReadMultiple( 2, rgcpropspec, rgcpropvarRead ));
        Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
        Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
        g_pfnFreePropVariantArray( 2, rgcpropvarRead );

        RELEASE_INTERFACE(ppropstg);

    }   // for( i = 0; i < 2; i++ )

//Exit:

    RELEASE_INTERFACE(ptest);
    RELEASE_INTERFACE(ppropstg);
    RELEASE_INTERFACE(psetstg);

}


void
test_BagOpenMethod( IStorage *pstg )
{
    HRESULT hr = S_OK;
    IPropertyBagEx *pbag = NULL;
    OLECHAR * rgoszDelete[2];
    CPropVariant cpropvar;
    PROPVARIANT propvar;
    VERSIONEDSTREAM VersionedStream;
    GUID guidVersion2;
    OLECHAR *pwszName = { OLESTR("Versioned Stream") };
    IUnknown *punk = NULL;
    IStream *pstm = NULL;
    CHAR rgbStreamDataWrite[50] = "Stream data";
    CHAR rgbStreamDataRead[100];
    ULONG cbRead;
    STATSTG statstg;

    Status( "IPropertyBagEx::Open\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));

    // Create a VersionedStream
    UuidCreate( &VersionedStream.guidVersion );
    VersionedStream.pStream = NULL;
    cpropvar = VersionedStream;

    // Write the versioned stream (causing a stream to be created) and read it back.

    Check( S_OK, pbag->WriteMultiple( 1, &pwszName, &cpropvar ));
    cpropvar.Clear();

    Check( S_OK, pbag->ReadMultiple( 1, &pwszName, &cpropvar, NULL ));
    Check( TRUE, VT_VERSIONED_STREAM == cpropvar.VarType() && NULL != cpropvar.pVersionedStream->pStream );

    // Put some data in the stream and release it.
    Check( S_OK, cpropvar.pVersionedStream->pStream->Write( rgbStreamDataWrite, sizeof(rgbStreamDataWrite), NULL ));

    cpropvar.Clear();

    // Now read that VersionedStream, with the proper GUID
    Check( S_OK, pbag->Open( NULL, pwszName, VersionedStream.guidVersion, 0, IID_IStream, &punk ));
    Check( S_OK, punk->QueryInterface( IID_IStream, reinterpret_cast<void**>(&pstm) ));

    // Verify the data.

    Check( S_OK, pstm->Read( rgbStreamDataRead, sizeof(rgbStreamDataRead), &cbRead ));
    Check( TRUE, cbRead == sizeof(rgbStreamDataWrite) );
    Check( TRUE, 0 == strcmp( rgbStreamDataWrite, rgbStreamDataRead ));

    RELEASE_INTERFACE(pstm);
    RELEASE_INTERFACE(punk);

    // Attempt to read the same VersionedStream with a bad GUID
    UuidCreate( &guidVersion2 );
    Check( STG_E_FILEALREADYEXISTS, pbag->Open( NULL, pwszName, guidVersion2, 0, IID_IStream, &punk ));

    // Attempt with a bad guid again, but this time cause a new property to be created.
    Check( S_OK, pbag->Open( NULL, pwszName, guidVersion2, OPENPROPERTY_OVERWRITE, IID_IStream, &punk ));
    Check( S_OK, punk->QueryInterface( IID_IStream, reinterpret_cast<void**>(&pstm) ));
    Check( S_OK, pstm->Stat( &statstg, STATFLAG_NONAME ));
    Check( TRUE, CULargeInteger(0) == statstg.cbSize );

    RELEASE_INTERFACE(pstm);
    RELEASE_INTERFACE(punk);

    // Show that we can overwrite an existing property of a different type, but only
    // by setting the overwrite flag.

    cpropvar = static_cast<long>(45);
    Check( S_OK, pbag->WriteMultiple( 1, &pwszName, &cpropvar ));
    Check( STG_E_FILEALREADYEXISTS, pbag->Open( NULL, pwszName, guidVersion2, 0, IID_IStream, &punk ));
    Check( S_OK, pbag->Open( NULL, pwszName, guidVersion2, OPENPROPERTY_OVERWRITE, IID_IStream, &punk ));
    RELEASE_INTERFACE(punk);

    // Show that if a property doesn't exist, Open creates it.

    Check( S_OK, pbag->DeleteMultiple( 1, &pwszName, 0 ));
    PropVariantClear( &cpropvar );
    Check( S_FALSE, pbag->ReadMultiple( 1, &pwszName, &cpropvar, NULL ));
    Check( S_OK, pbag->Open( NULL, pwszName, guidVersion2, 0, IID_IStream, &punk ));
    RELEASE_INTERFACE(punk);


    RELEASE_INTERFACE(pbag);

}   // test_BagOpenMethod

void
test_StandaloneAPIs( LPOLESTR ocsDir )
{

    OLECHAR ocsFile[ MAX_PATH + 1 ];
    FMTID fmtidStgPropStg, fmtidStgPropSetStg;

    IStorage *pstg = NULL; //TSafeStorage< IStorage > pstg;

    IStream *pstmInMemory = NULL;
    IStorage *pstgInMemory = NULL;

    IPropertySetStorage *ppropsetstg = NULL; //TSafeStorage< IPropertySetStorage > ppropsetstg;

    CPropVariant rgcpropvar[ CPROPERTIES_ALL ];

    IPropertySetStorage *pPropSetStg;
    IPropertyStorage *pPropStg;
    DWORD propsetflag;
    ULONG cPropertiesAll;

    ULONG ulIndex;

    Status( "Standalone API test\n" );

    // Generate FMTIDs.

    UuidCreate( &fmtidStgPropStg );
    UuidCreate( &fmtidStgPropSetStg );

    // Generate a filename from the directory name.

    ocscpy( ocsFile, ocsDir );
    ocscat( ocsFile, OLESTR( "IPropAPIs.stg" ));

    // Create a storage.

    Check( S_OK, g_pfnStgCreateStorageEx( ocsFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     (void**) &pstg ));

    // Run the following part of the test twice; once for a simple
    // property set and once for a non-simple.


    for( int i = 0; i < 2; i++ )
    {
        ILockBytes *pLockBytes = NULL;
        IStorage *pstgInMemory = NULL;

        #ifdef _MAC
            Handle hglobal;
            hglobal = NewHandle( 0 );
        #else
            HANDLE hglobal;
            hglobal = GlobalAlloc( GPTR, 0 );
        #endif
        Check( TRUE, NULL != hglobal );

        if( 0 == i )
        {
            // Create simple IPropertyStorage

            Check(S_OK, CreateStreamOnHGlobal( hglobal, TRUE, &pstmInMemory ));

            Check( S_OK, g_pfnStgCreatePropStg( (IUnknown*) pstmInMemory,
                                                fmtidStgPropStg,
                                                &CLSID_NULL,
                                                PROPSETFLAG_ANSI,
                                                0L, // Reserved
                                                &pPropStg ));
        }
        else
        {
            // If we're not allowed to do non-simple, skip out now.

            if( (RESTRICT_SIMPLE_ONLY & g_Restrictions)
                ||
                (RESTRICT_NON_HIERARCHICAL & g_Restrictions) )
            {
                break;
            }

            // Create a non-simple IPropertyStorage

            Check( S_OK, CreateILockBytesOnHGlobal( hglobal, TRUE, &pLockBytes ));

            Check( S_OK, StgCreateDocfileOnILockBytes( pLockBytes,
                                                       STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                                       0,
                                                       &pstgInMemory ));

            Check( S_OK, g_pfnStgCreatePropStg( (IUnknown*) pstgInMemory,
                                                fmtidStgPropStg,
                                                &CLSID_NULL,
                                                PROPSETFLAG_ANSI | PROPSETFLAG_NONSIMPLE,
                                                0,
                                                &pPropStg ));
        }
                                                

        // Write to the property set.

        Check( S_OK, pPropStg->WriteMultiple( 0 == i ? CPROPERTIES_ALL_SIMPLE : CPROPERTIES_ALL,
                                              g_rgcpropspecAll,
                                              g_rgcpropvarAll,
                                              PID_FIRST_USABLE ));
        Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));


        // Read from the property set

        Check( S_OK, pPropStg->ReadMultiple( 0 == i ? CPROPERTIES_ALL_SIMPLE : CPROPERTIES_ALL,
                                              g_rgcpropspecAll,
                                              rgcpropvar ));


        // Compare the properties

        for( ulIndex = 0;
             0 == i ? (ulIndex < CPROPERTIES_ALL_SIMPLE) : (ulIndex < CPROPERTIES_ALL);
             ulIndex++ )
        {
            Check( TRUE, rgcpropvar[ulIndex] == g_rgcpropvarAll[ulIndex] );
            rgcpropvar[ulIndex].Clear();
        }

        pPropStg->Release();
        pPropStg = NULL;

        //  -------------------
        //  Test StgOpenPropStg
        //  -------------------

        // Open the IPropertyStorage

        Check( S_OK, g_pfnStgOpenPropStg( 0 == i
                                            ? (IUnknown*) pstmInMemory
                                            : (IUnknown*) pstgInMemory,
                                          fmtidStgPropStg,
                                          PROPSETFLAG_DEFAULT
                                             | (0 == i ? 0 : PROPSETFLAG_NONSIMPLE),
                                          0L, // Reserved
                                          &pPropStg ));


        // Read from the property set

        Check( S_OK, pPropStg->ReadMultiple( 0 == i ? CPROPERTIES_ALL_SIMPLE : CPROPERTIES_ALL,
                                             g_rgcpropspecAll,
                                             rgcpropvar ));


        // Compare the properties

        for( ulIndex = 0;
             0 == i ? (ulIndex < CPROPERTIES_ALL_SIMPLE) : (ulIndex < CPROPERTIES_ALL);
             ulIndex++ )
        {
            Check( TRUE, rgcpropvar[ulIndex] == g_rgcpropvarAll[ulIndex] );
            rgcpropvar[ulIndex].Clear();
        }

        pPropStg->Release();
        pPropStg = NULL;

        RELEASE_INTERFACE( pstmInMemory );
        RELEASE_INTERFACE( pstgInMemory );
        RELEASE_INTERFACE( pLockBytes );
    }

    //  --------------------------------
    //  Test StgCreatePropSetStg::Create
    //  --------------------------------

    // This is equivalent to the previous tests, but
    // uses StgCreatePropSetStg to create an IPropertySetStorage,
    // and uses that to create a property set.

    // Create the IPropertySetStorage

    Check( S_OK, g_pfnStgCreatePropSetStg( pstg,
                                           0L, // Reserved
                                           &pPropSetStg ));

    // Create an IPropertyStorage.  Create it non-simple, unless the underlying
    // IStorage (i.e. NTFS) doesn't support it.

    if( (RESTRICT_SIMPLE_ONLY & g_Restrictions) || (RESTRICT_NON_HIERARCHICAL & g_Restrictions) )
    {
        propsetflag = PROPSETFLAG_DEFAULT;
        cPropertiesAll = CPROPERTIES_ALL_SIMPLE;
    }
    else
    {
        propsetflag = PROPSETFLAG_NONSIMPLE;
        cPropertiesAll = CPROPERTIES_ALL;
    }

    Check( S_OK, pPropSetStg->Create( fmtidStgPropSetStg,
                                      &CLSID_NULL,
                                      propsetflag,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    // Write to the property set.

    Check( S_OK, pPropStg->WriteMultiple( cPropertiesAll,
                                          g_rgcpropspecAll,
                                          g_rgcpropvarAll,
                                          PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));


    //-----------------------------------------------------------------------
    //  Close it all up and then open it again.
    //  This will exercise the g_pfnStgOpenStorageEx API
    //
    pPropStg->Commit(STGC_DEFAULT);
    pPropStg->Release();
    pPropStg = NULL;
    pPropSetStg->Release();
    pPropSetStg = NULL;
    pstg->Release();
    pstg = NULL;

    Check( S_OK, g_pfnStgOpenStorageEx(   ocsFile,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     STGFMT_ANY, //DetermineStgFmt( g_enumImplementation ), // BUGBUG: Use STGFMT_ANY when StgEx can handle it
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertySetStorage,
                                     (void**) &pPropSetStg ));

    Check( S_OK, pPropSetStg->Open(  fmtidStgPropSetStg,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     &pPropStg));

    //pPropSetStg->Release();
    //
    //-----------------------------------------------------------------------

    //
    // Read from the property set
    //
    Check( S_OK, pPropStg->ReadMultiple( cPropertiesAll,
                                         g_rgcpropspecAll,
                                         rgcpropvar ));


    // Compare the properties

    for( ulIndex = 0; ulIndex < cPropertiesAll; ulIndex++ )
    {
        Check( TRUE, rgcpropvar[ulIndex] == g_rgcpropvarAll[ulIndex] );
        rgcpropvar[ulIndex].Clear();
    }

    // Clean up

    RELEASE_INTERFACE( pPropStg );
    RELEASE_INTERFACE( pPropSetStg );

}


//
// IPropertySetStorage tests
//

void
test_IPropertySetStorage_IUnknown(IStorage *pStorage)
{
    // Only use this an IStorage-based property set, since this test
    // assumes that IStorage & IPropertySetStorage are on the same
    // object.

    if( PROPIMP_DOCFILE_IPROP == g_enumImplementation )
    {
        return;
    }

    Status( "IPropertySetStorage::IUnknown\n" );

    //       Check ref counting through different interfaces on object
    //
    //          QI to IPropertySetStorage
    //          QI to IUnknown on IStorage
    //          QI to IUnknown on IPropertySetStorage
    //          QI back to IPropertySetStorage from IUnknown
    //          QI back to IStorage from IPropertySetStorage
    //
    //          Release all.
    //

    IStorage *pStorage2;
    IPropertySetStorage *ppss1, *ppss2, *ppss3;
    IUnknown *punk1,*punk2;
    HRESULT hr=S_OK;

    Check(S_OK, pStorage->QueryInterface(IID_IPropertySetStorage, (void**)&ppss1));
    Check(S_OK, pStorage->QueryInterface(IID_IUnknown, (void **)&punk1));
    Check(S_OK, ppss1->QueryInterface(IID_IUnknown, (void **)&punk2));
    Check(S_OK, ppss1->QueryInterface(DetermineStgIID( g_enumImplementation ), (void **)&pStorage2));
    Check(S_OK, ppss1->QueryInterface(IID_IPropertySetStorage, (void **)&ppss2));
    Check(S_OK, punk1->QueryInterface(IID_IPropertySetStorage, (void **)&ppss3));

    ppss1->AddRef();
    ppss1->Release();

    //pStorage.Release();
    ppss1->Release();
    punk1->Release();
    punk2->Release();
    pStorage2->Release();
    ppss2->Release();
//    void *pvVirtFuncTable = *(void**)ppss3;
    ppss3->Release();


//    Check(STG_E_INVALIDHANDLE, ((IPropertySetStorage*)&pvVirtFuncTable)->QueryInterface(IID_IUnknown, (void**)&punk3));
}


#define INVALID_POINTER     ( (void *) 0xFFFFFFFF )
#define VTABLE_MEMBER_FN(pObj,entry)  ( (*(ULONG ***)(pObj))[ (entry) ] )


//+---------------------------------------------------------
//
//  Template:   Alloc2PageVector
//
//  Purpose:    This function template allocates two pages
//              of memory, and then sets a vector pointer
//              so that its first element is wholy within
//              the first page, and the second element is
//              wholy within the second.  Then, the protection
//              of the second page is set according to the
//              caller-provided parameter.
//
//
//  Inputs:     [TYPE**] ppBase
//                  Points to the beginning of the two pages.
//              [TYPE**] ppVector
//                  Points to the beginning of the vector of TYPEs.
//              [DWORD] dwProtect
//                  The desired protection on the second page
//                  (from the PAGE_* enumeration).
//              [LPWSTR] lpwstr (optional)
//                  If not NULL, used to initialize the vector
//                  elements.
//
//  Output:     TRUE iff successful.
//
//+---------------------------------------------------------


template< class TYPE > BOOL Alloc2PageVector( TYPE** ppBase,
                                              TYPE** ppVector,
                                              DWORD  dwProtect,
                                              TYPE*  pInit )
{
    DWORD dwOldProtect;
    SYSTEM_INFO si;

    GetSystemInfo( &si );

    *ppBase = (TYPE*) VirtualAlloc( NULL, 2 * si.dwPageSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
    if( NULL == *ppBase )
        return( FALSE );

    *ppVector = (TYPE*) ( (BYTE*) *ppBase + si.dwPageSize - sizeof(TYPE) );

    if( NULL != pInit )
    {
        memcpy( &((LPWSTR*)*ppVector)[0], pInit, sizeof(TYPE) );
        memcpy( &((LPWSTR*)*ppVector)[1], pInit, sizeof(TYPE) );
    }

    if( !VirtualProtect( (BYTE*) *ppBase + si.dwPageSize, si.dwPageSize, dwProtect, &dwOldProtect ) )
        return( FALSE );

    return( TRUE );
}



void
test_PropVariantValidation( IStorage *pStg )
{

    Status( "PropVariant Validation\n" );

    IPropertySetStorage *pPSStg = NULL; // TSafeStorage< IPropertySetStorage > pPSStg( pStg );
    IPropertyStorage *pPStg = NULL; // TSafeStorage< IPropertyStorage > pPStg;

    CPropVariant cpropvar;
    CLIPDATA     clipdata;
    PROPSPEC     propspec;

    const LPWSTR wszText = L"Unicode Text String";

    FMTID fmtid;
    UuidCreate( &fmtid );

    Check( S_OK, StgToPropSetStg( pStg, &pPSStg ));

    Check(S_OK, pPSStg->Create( fmtid,
                                NULL,
                                PROPSETFLAG_DEFAULT,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));


    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 2;

    //  -------------------------------
    //  Test invalid VT_CF Propvariants
    //  -------------------------------

    // NULL clip format.

    clipdata.cbSize = 4;
    clipdata.ulClipFmt = (ULONG) -1;
    clipdata.pClipData = NULL;

    cpropvar = clipdata;

    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Too short cbSize.

    ((PROPVARIANT*)&cpropvar)->pclipdata->cbSize = 3;
    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Too short pClipData (it should be 1 byte, but the pClipData is NULL).

    ((PROPVARIANT*)&cpropvar)->pclipdata->cbSize = 5;
    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));


    Check( 0, RELEASE_INTERFACE(pPStg) );
    RELEASE_INTERFACE(pPSStg);
}


void
test_ParameterValidation(IStorage *pStg)
{
    // We only run this test on WIN32 builds, because we need
    // the VirtualAlloc routine.

#ifdef WIN32

    Status( "Parameter Validation\n" );

    IPropertySetStorage *pPSStg = NULL;
    IPropertyStorage *pPStg = NULL;
    FMTID fmtid;

    UuidCreate( &fmtid );

    LPFMTID pfmtidNULL = NULL;
    LPFMTID pfmtidInvalid = (LPFMTID) INVALID_POINTER;
    PAPP_COMPAT_INFO pAppCompatInfo = NULL;

    DWORD dwOldProtect;

    Check( S_OK, StgToPropSetStg( pStg, &pPSStg ));

    // By default, pointer validation is turned off in ole32 (as of Whistler).
    // Enable it for our process so that we can test the checks.

    PAPP_COMPAT_INFO pAppCompatInfoSave = (PAPP_COMPAT_INFO) NtCurrentPeb()->AppCompatInfo;
    APP_COMPAT_INFO AppCompatInfoNew;
    memset( &AppCompatInfoNew, 0, sizeof(AppCompatInfoNew) );
    AppCompatInfoNew.CompatibilityFlags.QuadPart |= KACF_OLE32VALIDATEPTRS;

    NtCurrentPeb()->AppCompatInfo = &AppCompatInfoNew;
    
    NtCurrentPeb()->AppCompatFlags.QuadPart = AppCompatInfoNew.CompatibilityFlags.QuadPart;

    // Define two invalid property names

    OLECHAR oszTooLongName[ CCH_MAXPROPNAMESZ + 1 ];
    LPOLESTR poszTooLongName = oszTooLongName;
    OLECHAR oszTooShortName[] = { L"" };
    LPOLESTR poszTooShortName = oszTooShortName;

    PROPSPEC propspecTooLongName = { PRSPEC_LPWSTR };
    PROPSPEC propspecTooShortName = { PRSPEC_LPWSTR };

    propspecTooLongName.lpwstr = oszTooLongName;
    propspecTooShortName.lpwstr = oszTooShortName;

    for( int i = 0; i < sizeof(oszTooLongName)/sizeof(oszTooLongName[0]); i++ )
        oszTooLongName[i] = OLESTR('a');
    oszTooLongName[ sizeof(oszTooLongName)/sizeof(oszTooLongName[0]) ] = OLESTR('\0');

    // Define several arrays which will be created with special
    // protections.  For all of this vectors, the first element
    // will be in a page to which we have all access rights.  The
    // second element will be in a page for which we have no access,
    // read access, or all access.  The variables are named
    // according to the access rights in the second element.
    // The '...Base' variables are pointers to the base of
    // the allocated memory (and must therefore be freed).
    // The corresponding variables without the "Base" postfix
    // are the vector pointers.

    PROPSPEC       *rgpropspecNoAccessBase,    *rgpropspecNoAccess;
    CPropVariant   *rgcpropvarReadAccessBase,  *rgcpropvarReadAccess;
    CPropVariant   *rgcpropvarNoAccessBase,    *rgcpropvarNoAccess;
    PROPID         *rgpropidNoAccessBase,      *rgpropidNoAccess;
    PROPID         *rgpropidReadAccessBase,    *rgpropidReadAccess;
    LPWSTR         *rglpwstrNoAccessBase,      *rglpwstrNoAccess;
    LPWSTR         *rglpwstrReadAccessBase,    *rglpwstrReadAccess;
    STATPROPSETSTG *rgStatPSStgReadAccessBase, *rgStatPSStgReadAccess;
    STATPROPSTG    *rgStatPStgReadAccessBase,  *rgStatPStgReadAccess;

    PROPSPEC       rgpropspecAllAccess[1];
    CPropVariant   rgcpropvarAllAccess[1];
    PROPID         rgpropidAllAccess[1];
    LPWSTR         rglpwstrAllAccess[1];
    LPWSTR         rglpwstrInvalid[1];
    STATPROPSETSTG rgStatPSStgAllAccess[1];
    STATPROPSTG    rgStatPStgAllAccess[1];

    // Allocate memory for the vectors and set the vector
    // pointers.

    PROPID propidDefault = PID_FIRST_USABLE;
    LPWSTR lpwstrNameDefault = L"Property Name";

    Check(TRUE, Alloc2PageVector( &rgpropspecNoAccessBase,
                                  &rgpropspecNoAccess,
                                  (ULONG) PAGE_NOACCESS,
                                  (PROPSPEC*) NULL ));
    Check(TRUE, Alloc2PageVector( &rgcpropvarReadAccessBase,
                                  &rgcpropvarReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  (CPropVariant*) NULL ));
    Check(TRUE, Alloc2PageVector( &rgcpropvarNoAccessBase,
                                  &rgcpropvarNoAccess,
                                  (ULONG) PAGE_NOACCESS,
                                  (CPropVariant*) NULL ));
    Check(TRUE, Alloc2PageVector( &rgpropidNoAccessBase,
                                  &rgpropidNoAccess,
                                  (ULONG) PAGE_NOACCESS,
                                  &propidDefault ));
    Check(TRUE, Alloc2PageVector( &rgpropidReadAccessBase,
                                  &rgpropidReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  &propidDefault ));
    Check(TRUE, Alloc2PageVector( &rglpwstrNoAccessBase,
                                  &rglpwstrNoAccess,
                                  (ULONG) PAGE_NOACCESS,
                                  &lpwstrNameDefault ));
    Check(TRUE, Alloc2PageVector( &rglpwstrReadAccessBase,
                                  &rglpwstrReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  &lpwstrNameDefault ));
    Check(TRUE, Alloc2PageVector( &rgStatPSStgReadAccessBase,
                                  &rgStatPSStgReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  (STATPROPSETSTG*) NULL ));
    Check(TRUE, Alloc2PageVector( &rgStatPStgReadAccessBase,
                                  &rgStatPStgReadAccess,
                                  (ULONG) PAGE_READONLY,
                                  (STATPROPSTG*) NULL ));

    rglpwstrAllAccess[0] = rglpwstrNoAccess[0] = rglpwstrReadAccess[0] = L"Property Name";

    // Create restricted buffers for misc tests

    BYTE *pbReadOnly = (BYTE*) VirtualAlloc( NULL, 1, MEM_COMMIT, PAGE_READONLY );
    Check( TRUE, pbReadOnly != NULL );

    BYTE *pbNoAccess = (BYTE*) VirtualAlloc( NULL, 1, MEM_COMMIT, PAGE_NOACCESS );


    //  ----------------------------------------
    //  Test IPropertySetStorage::QueryInterface
    //  ----------------------------------------

    IUnknown *pUnk = NULL;

#if 0

    // This test cannot run because CPropertySetStorage::QueryInterface is a virtual
    // function, and since CExposedDocFile is derived from CPropertySetStorage,
    // it is inaccessibl.

    // Invalid REFIID

    Check(E_INVALIDARG, ((CExposedDocFile*)&pPSStg)->CPropertySetStorage::QueryInterface( (REFIID) *pfmtidNULL, (void**)&pUnk ));
    Check(E_INVALIDARG, pPSStg->QueryInterface( (REFIID) *pfmtidInvalid, (void**)&pUnk ));

    // Invalid IUnknown*

    Check(E_INVALIDARG, pPSStg->QueryInterface( IID_IUnknown, NULL ));
    Check(E_INVALIDARG, pPSStg->QueryInterface( IID_IUnknown, (void**) INVALID_POINTER ));
#endif


    //  --------------------------------
    //  Test IPropertySetStorage::Create
    //  --------------------------------

    // Invalid REFFMTID

    Check(E_INVALIDARG, pPSStg->Create( *pfmtidNULL,
                                        NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    Check(E_INVALIDARG, pPSStg->Create( *pfmtidInvalid,
                                        NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    // Invalid Class ID pointer

    Check(E_INVALIDARG, pPSStg->Create( FMTID_NULL,
                                        (GUID*) INVALID_POINTER,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    // Invalid PropSetFlag

    Check(STG_E_INVALIDFLAG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        PROPSETFLAG_UNBUFFERED, // Only supported in APIs
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    Check(STG_E_INVALIDFLAG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        0xffffffff,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    // Invalid mode

    Check(STG_E_INVALIDFLAG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_DIRECT | STGM_SHARE_DENY_NONE,
                                        &pPStg ));

    // Invalid IPropertyStorage**

    Check(E_INVALIDARG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        NULL ));

    Check(E_INVALIDARG, pPSStg->Create( FMTID_NULL,
                                        &CLSID_NULL,
                                        PROPSETFLAG_DEFAULT,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        (IPropertyStorage **) INVALID_POINTER ));

    //  ------------------------------
    //  Test IPropertySetStorage::Open
    //  ------------------------------

    // Invalid REFFMTID

    Check(E_INVALIDARG, pPSStg->Open(   *pfmtidNULL,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));

    Check(E_INVALIDARG, pPSStg->Open(   *pfmtidInvalid,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPStg ));


    Check(STG_E_INVALIDFLAG, pPSStg->Open( FMTID_NULL, STGM_DIRECT | STGM_SHARE_DENY_NONE, &pPStg ));

    // Invalid IPropertyStorage**

    Check(E_INVALIDARG, pPSStg->Open(   FMTID_NULL,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        NULL ));

    Check(E_INVALIDARG, pPSStg->Open(   FMTID_NULL,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        (IPropertyStorage**) INVALID_POINTER ));

    //  --------------------------------
    //  Test IPropertySetStorage::Delete
    //  --------------------------------

    // Invalid REFFMTID.

    Check(E_INVALIDARG, pPSStg->Delete( *pfmtidNULL ));
    Check(E_INVALIDARG, pPSStg->Delete( (REFFMTID) *pfmtidInvalid ));

    //  ------------------------------
    //  Test IPropertySetStorage::Enum
    //  ------------------------------

    // Invalid IEnumSTATPROPSETSTG

    Check(E_INVALIDARG, pPSStg->Enum( (IEnumSTATPROPSETSTG **) NULL ));
    Check(E_INVALIDARG, pPSStg->Enum( (IEnumSTATPROPSETSTG **) INVALID_POINTER ));


    //  -------------
    //  Test PROPSPEC
    //  -------------

    // Create a PropertyStorage

    Check(S_OK, pPSStg->Create( fmtid,
                                NULL,
                                PROPSETFLAG_DEFAULT,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));


    // Invalid ulKind

    rgpropspecAllAccess[0].ulKind = (ULONG) -1;
    rgpropspecAllAccess[0].lpwstr = NULL;
    Check(E_INVALIDARG, pPStg->ReadMultiple(   1,
                                               rgpropspecAllAccess,
                                               rgcpropvarAllAccess ));
    Check(E_INVALIDARG, pPStg->WriteMultiple(  1,
                                               rgpropspecAllAccess,
                                               rgcpropvarAllAccess,
                                               2 ));
    Check(E_INVALIDARG, pPStg->DeleteMultiple( 1,
                                               rgpropspecAllAccess ));

    // Too short PROPSPEC

    rgpropspecNoAccess[0].ulKind = PRSPEC_PROPID;
    rgpropspecNoAccess[0].propid = 2;

    Check(E_INVALIDARG, pPStg->ReadMultiple( 2,
                                             rgpropspecNoAccess,
                                             rgcpropvarAllAccess ));

    Check(E_INVALIDARG, pPStg->WriteMultiple( 2,
                                              rgpropspecNoAccess,
                                              rgcpropvarAllAccess,
                                              2 ));

    Check(E_INVALIDARG, pPStg->DeleteMultiple( 2,
                                               rgpropspecNoAccess ));


    //  -------------------------------------
    //  Test IPropertyStorage::QueryInterface
    //  -------------------------------------

    // Invalid REFIID

    Check(E_INVALIDARG, pPStg->QueryInterface( (REFIID) *pfmtidNULL, (void**)&pUnk ));
    Check(E_INVALIDARG, pPStg->QueryInterface( (REFIID) *pfmtidInvalid, (void**)&pUnk ));

    // Invalid IUnknown*

    Check(E_INVALIDARG, pPStg->QueryInterface( IID_IUnknown, NULL ));
    Check(E_INVALIDARG, pPStg->QueryInterface( IID_IUnknown, (void**) INVALID_POINTER ));


    //  -----------------------------------
    //  Test IPropertyStorage::ReadMultiple
    //  -----------------------------------

    rgpropspecAllAccess[0].ulKind = PRSPEC_LPWSTR;
    rgpropspecAllAccess[0].lpwstr = OLESTR("Test Property");

    // Too short count

    Check(S_FALSE, pPStg->ReadMultiple( 0,
                                        rgpropspecAllAccess,
                                        rgcpropvarAllAccess));

    // Too long a count for the PropVariant

    Check(E_INVALIDARG, pPStg->ReadMultiple( 2,
                                             rgpropspecAllAccess,
                                             (PROPVARIANT*) (void*) rgcpropvarReadAccess ));


    // Invalid PropVariant[]

    Check(E_INVALIDARG, pPStg->ReadMultiple( 1,
                                             rgpropspecAllAccess,
                                             NULL ));
    Check(E_INVALIDARG, pPStg->ReadMultiple( 1,
                                             rgpropspecAllAccess,
                                             (LPPROPVARIANT) INVALID_POINTER ));

    // Bad PROPSPECs

    // If we ever add a version-0 property set compatibility mode, we should add this test back.
    // Check(STG_E_INVALIDPARAMETER, pPStg->ReadMultiple( 1, &propspecTooLongName, rgcpropvarAllAccess ));
    Check(STG_E_INVALIDPARAMETER, pPStg->ReadMultiple( 1, &propspecTooShortName, rgcpropvarAllAccess ));

    //  ------------------------------------
    //  Test IPropertyStorage::WriteMultiple
    //  ------------------------------------

    rgpropspecAllAccess[0].ulKind = PRSPEC_LPWSTR;
    rgpropspecAllAccess[0].lpwstr = L"Test Property";
    rgcpropvarAllAccess[0] = (long) 1;

    // Too short count

    Check(S_OK, pPStg->WriteMultiple( 0,
                                     rgpropspecAllAccess,
                                     (PROPVARIANT*)(void*)rgcpropvarAllAccess,
                                     2));

    // Too short PropVariant

    Check(E_INVALIDARG, pPStg->WriteMultiple( 2,
                                              rgpropspecAllAccess,
                                              (PROPVARIANT*)(void*)rgcpropvarNoAccess,
                                              PID_FIRST_USABLE ));

    // Invalid PropVariant[]

    Check(E_INVALIDARG, pPStg->WriteMultiple( 1,
                                              rgpropspecAllAccess,
                                              NULL,
                                              2));
    Check(E_INVALIDARG, pPStg->WriteMultiple( 1,
                                              rgpropspecAllAccess,
                                              (LPPROPVARIANT) INVALID_POINTER,
                                              PID_FIRST_USABLE));

    // Bad PROPSPECs

    // If we ever add a version-0 property set compatibility mode, we should add this test back.
    // Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspecTooLongName, rgcpropvarAllAccess,
    //                                                     PID_FIRST_USABLE ));

    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspecTooShortName, rgcpropvarAllAccess,
                                                        PID_FIRST_USABLE ));


    //  -------------------------------------
    //  Test IPropertyStorage::DeleteMultiple
    //  -------------------------------------


    // Invalid count

    Check(S_OK, pPStg->DeleteMultiple( 0,
                                       rgpropspecAllAccess ));


    // Bad PROPSPECs
    // If we ever add a version-0 property set compatibility mode, we should add this test back.
    // Check(STG_E_INVALIDPARAMETER, pPStg->DeleteMultiple( 1, &propspecTooLongName ));

    Check(STG_E_INVALIDPARAMETER, pPStg->DeleteMultiple( 1, &propspecTooShortName ));

    //  ----------------------------------------
    //  Test IPropertyStorage::ReadPropertyNames
    //  ----------------------------------------

    // Create a property with the name we're going to use.

    rgpropspecAllAccess[0].ulKind = PRSPEC_LPWSTR;
    rgpropspecAllAccess[0].lpwstr = rglpwstrAllAccess[0];

    Check(S_OK, pPStg->WriteMultiple( 1,
                                      rgpropspecAllAccess,
                                      &rgcpropvarAllAccess[0],
                                      PID_FIRST_USABLE ));

    // Invalid count

    Check(S_FALSE, pPStg->ReadPropertyNames( 0,
                                             rgpropidAllAccess,
                                             rglpwstrAllAccess ));

    // Too short PROPID[] or LPWSTR[]

    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 2,
                                                  rgpropidNoAccess,
                                                  rglpwstrAllAccess ));
    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 2,
                                                  rgpropidAllAccess,
                                                  rglpwstrReadAccess ));

    // Invalid rgpropid[]

    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 1,
                                                  NULL,
                                                  rglpwstrAllAccess ));
    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 1,
                                                  (PROPID*) INVALID_POINTER,
                                                  rglpwstrAllAccess ));

    // Invalid rglpwstr[]

    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 1,
                                                  rgpropidAllAccess,
                                                  NULL ));
    Check(E_INVALIDARG, pPStg->ReadPropertyNames( 1,
                                                  rgpropidAllAccess,
                                                  (LPWSTR*) INVALID_POINTER ));

    //  -----------------------------------------
    //  Test IPropertyStorage::WritePropertyNames
    //  -----------------------------------------

    // Invalid count

    Check(S_OK, pPStg->WritePropertyNames( 0,
                                           NULL,
                                           rglpwstrAllAccess ));

    // Too short PROPID[] or LPWSTR[]

    Check(E_INVALIDARG, pPStg->WritePropertyNames( 2,
                                                   rgpropidNoAccess,
                                                   rglpwstrAllAccess ));
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 2,
                                                   rgpropidAllAccess,
                                                   rglpwstrNoAccess ));
    Check(S_OK, pPStg->WritePropertyNames( 2,
                                           rgpropidAllAccess,
                                           rglpwstrReadAccess ));

    // Invalid rgpropid[]

    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   NULL,
                                                   rglpwstrAllAccess ));
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   (PROPID*) INVALID_POINTER,
                                                   rglpwstrAllAccess ));

    // Invalid rglpwstr[]

    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   rgpropidAllAccess,
                                                   NULL ));
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   rgpropidAllAccess,
                                                   (LPWSTR*) INVALID_POINTER ));

    // Invalid name.

    rglpwstrInvalid[0] = NULL;
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   rgpropidAllAccess,
                                                   rglpwstrInvalid ));

    rglpwstrInvalid[0] = (LPWSTR) INVALID_POINTER;
    Check(E_INVALIDARG, pPStg->WritePropertyNames( 1,
                                                   rgpropidAllAccess,
                                                   rglpwstrInvalid ));

    // Invalid length names

    // If we ever add a version-0 property set compatibility mode, we should add this test back.
    // Check(STG_E_INVALIDPARAMETER, pPStg->WritePropertyNames( 1, rgpropidAllAccess, &poszTooLongName ));
    Check(STG_E_INVALIDPARAMETER, pPStg->WritePropertyNames( 1, rgpropidAllAccess, &poszTooShortName ));


    //  ------------------------------------------
    //  Test IPropertyStorage::DeletePropertyNames
    //  ------------------------------------------

    // Invalid count

    Check(S_OK, pPStg->DeletePropertyNames( 0,
                                            rgpropidAllAccess ));

    // Too short PROPID[]

    Check(E_INVALIDARG, pPStg->DeletePropertyNames( 2,
                                                    rgpropidNoAccess ));
    Check(S_OK, pPStg->DeletePropertyNames( 2,
                                            rgpropidReadAccess ));

    // Invalid rgpropid[]

    Check(E_INVALIDARG, pPStg->DeletePropertyNames( 1,
                                                    NULL ));
    Check(E_INVALIDARG, pPStg->DeletePropertyNames( 1,
                                                    (PROPID*) INVALID_POINTER ));

    //  ---------------------------
    //  Test IPropertyStorage::Enum
    //  ---------------------------

    // Invalid IEnumSTATPROPSTG

    Check(E_INVALIDARG, pPStg->Enum( NULL ));
    Check(E_INVALIDARG, pPStg->Enum( (IEnumSTATPROPSTG**) INVALID_POINTER ));

    //  --------------------------------------
    //  Test IPropertyStorage::SetElementTimes
    //  --------------------------------------

    Check(E_INVALIDARG, pPStg->SetTimes( (FILETIME*) INVALID_POINTER,
                                         NULL, NULL ));
    Check(E_INVALIDARG, pPStg->SetTimes( NULL,
                                         (FILETIME*) INVALID_POINTER,
                                         NULL ));
    Check(E_INVALIDARG, pPStg->SetTimes( NULL, NULL,
                                         (FILETIME*) INVALID_POINTER ));

    //  -------------------------------
    //  Test IPropertyStorage::SetClass
    //  -------------------------------

    Check(E_INVALIDARG, pPStg->SetClass( (REFCLSID) *pfmtidNULL ));
    Check(E_INVALIDARG, pPStg->SetClass( (REFCLSID) *pfmtidInvalid ));

    //  ---------------------------
    //  Test IPropertyStorage::Stat
    //  ---------------------------

    Check(E_INVALIDARG, pPStg->Stat( NULL ));
    Check(E_INVALIDARG, pPStg->Stat( (STATPROPSETSTG*) INVALID_POINTER ));


    //  ------------------------------
    //  Test IEnumSTATPROPSETSTG::Next
    //  ------------------------------

    ULONG cEltFound;
    IEnumSTATPROPSETSTG *pESPSStg = NULL; // TSafeStorage< IEnumSTATPROPSETSTG > pESPSStg;
    Check(S_OK, pPSStg->Enum( &pESPSStg ));

    // Invalid STATPROPSETSTG*

    Check(E_INVALIDARG, pESPSStg->Next( 1, NULL, &cEltFound ));
    Check(E_INVALIDARG, pESPSStg->Next( 1, (STATPROPSETSTG*) INVALID_POINTER, &cEltFound ));

    // Invalid pceltFound

    Check(S_OK, pESPSStg->Next( 1, rgStatPSStgAllAccess, NULL ));
    Check(STG_E_INVALIDPARAMETER, pESPSStg->Next( 2, rgStatPSStgAllAccess, NULL ));
    Check(E_INVALIDARG, pESPSStg->Next( 2, rgStatPSStgAllAccess, (ULONG*) INVALID_POINTER ));

    // Too short STATPROPSETSTG[]

    Check(E_INVALIDARG, pESPSStg->Next( 2, rgStatPSStgReadAccess, &cEltFound ));

    //  -------------------------------
    //  Test IEnumSTATPROPSETSTG::Clone
    //  -------------------------------

    // Invalid IEnumSTATPROPSETSTG**

    Check(E_INVALIDARG, pESPSStg->Clone( NULL ));
    Check(E_INVALIDARG, pESPSStg->Clone( (IEnumSTATPROPSETSTG**) INVALID_POINTER ));


    //  ---------------------------
    //  Test IEnumSTATPROPSTG::Next
    //  ---------------------------

    IEnumSTATPROPSTG *pESPStg = NULL; // TSafeStorage< IEnumSTATPROPSTG > pESPStg;
    Check(S_OK, pPStg->Enum( &pESPStg ));

    // Invalid STATPROPSETSTG*

    Check(E_INVALIDARG, pESPStg->Next( 1, NULL, &cEltFound ));
    Check(E_INVALIDARG, pESPStg->Next( 1, (STATPROPSTG*) INVALID_POINTER, &cEltFound ));

    // Invalid pceltFound

    Check(S_OK, pESPStg->Next( 1, rgStatPStgAllAccess, NULL ));
    Check(STG_E_INVALIDPARAMETER, pESPStg->Next( 2, rgStatPStgAllAccess, NULL ));
    Check(E_INVALIDARG, pESPStg->Next( 2, rgStatPStgAllAccess, (ULONG*) INVALID_POINTER ));

    // Too short STATPROPSTG[]

    Check(E_INVALIDARG, pESPStg->Next( 2, rgStatPStgReadAccess, &cEltFound ));


    //  ----------------------------
    //  Test IEnumSTATPROPSTG::Clone
    //  ----------------------------

    // Invalid IEnumSTATPROPSETSTG**

    Check(E_INVALIDARG, pESPStg->Clone( NULL ));
    Check(E_INVALIDARG, pESPStg->Clone( (IEnumSTATPROPSTG**) INVALID_POINTER ));

    //  --------------------------------------------
    //  Test PropStgNameToFmtId & FmtIdToPropStgName
    //  --------------------------------------------

    // We're done with the IPropertyStorage and IPropertySetStorage
    // now, but we need the pointers for some calls below, so let's
    // free them now.

    RELEASE_INTERFACE(pPStg);
    RELEASE_INTERFACE(pPSStg);

    RELEASE_INTERFACE(pESPStg);


    // In some cases we can't test these APIs, so only test them
    // if we have the function pointers.

    if( g_pfnPropStgNameToFmtId && g_pfnFmtIdToPropStgName )
    {
        OLECHAR oszPropStgName[ CCH_MAX_PROPSTG_NAME+1 ];
        FMTID fmtidPropStgName = FMTID_NULL;

        // Validate the FMTID parm

        Check( E_INVALIDARG, g_pfnPropStgNameToFmtId( oszPropStgName, pfmtidNULL ));
        Check( E_INVALIDARG, g_pfnPropStgNameToFmtId( oszPropStgName, pfmtidInvalid ));
        Check( E_INVALIDARG, g_pfnPropStgNameToFmtId( oszPropStgName, (FMTID*) pbReadOnly ));

        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( pfmtidNULL, oszPropStgName ));
        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( pfmtidInvalid, oszPropStgName ));
        Check( S_OK, g_pfnFmtIdToPropStgName( (FMTID*) pbReadOnly, oszPropStgName ));

        // Validate the name parameter

        /*
        Check( STG_E_INVALIDNAME, g_pfnPropStgNameToFmtId( NULL, &fmtidPropStgName ));
        Check( STG_E_INVALIDNAME, g_pfnPropStgNameToFmtId( (LPOLESTR) INVALID_POINTER, &fmtidPropStgName ));
        Check( STG_E_INVALIDNAME, g_pfnPropStgNameToFmtId( (LPOLESTR) pbNoAccess, &fmtidPropStgName));
        Check( S_OK, g_pfnPropStgNameToFmtId( (LPOLESTR) pbReadOnly, &fmtidPropStgName ));

        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( &fmtidPropStgName, NULL ));
        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( &fmtidPropStgName, (LPOLESTR) INVALID_POINTER ));
        Check( E_INVALIDARG, g_pfnFmtIdToPropStgName( &fmtidPropStgName, (LPOLESTR) pbReadOnly ));
        */

    }   // if( g_pfnPropStgNameToFmtId && g_pfnFmtIdToPropStgName )

    //  ------------------------------------------
    //  Test StgCreatePropStg, StgOpenPropStg APIs
    //  ------------------------------------------

    // In some cases we can't test these APIs, so only test them
    // if we have the function pointers.

    if( g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg && g_pfnStgOpenPropStg
        &&
        !(RESTRICT_SIMPLE_ONLY & g_Restrictions) )
    {
        FMTID fmtidPropStgName = FMTID_NULL;
        IStream *pStm = NULL; // TSafeStorage< IStream > pStm;

        // We need a Stream for one of the tests.

        Check( S_OK, pStg->CreateStream( OLESTR( "Parameter Validation" ),
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0L, 0L,
                                         &pStm ));

        // Test the IUnknown

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( NULL, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT, 0, &pPStg ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( NULL, fmtidPropStgName, PROPSETFLAG_DEFAULT, 0L, &pPStg ));

        // Test the FMTID

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, *pfmtidNULL, NULL, PROPSETFLAG_DEFAULT, 0, &pPStg ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, *pfmtidNULL, PROPSETFLAG_DEFAULT, 0, &pPStg ));

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, *pfmtidInvalid, NULL, PROPSETFLAG_DEFAULT, 0, &pPStg ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, *pfmtidInvalid, PROPSETFLAG_DEFAULT, 0, &pPStg ));

        // Test the CLSID

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, (CLSID*) pfmtidInvalid, PROPSETFLAG_DEFAULT, 0, &pPStg ));

        // Test grfFlags

        Check( STG_E_INVALIDFLAG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, 0x8000, 0L, &pPStg ));
        Check( STG_E_INVALIDFLAG, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, 0x8000, 0L, &pPStg ));

        Check( E_NOINTERFACE, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, PROPSETFLAG_NONSIMPLE, 0L, &pPStg ));
        Check( E_NOINTERFACE, g_pfnStgCreatePropStg( (IUnknown*) pStg, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT,   0L, &pPStg ));
        Check( E_NOINTERFACE, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, PROPSETFLAG_NONSIMPLE, 0L, &pPStg ));
        Check( E_NOINTERFACE, g_pfnStgOpenPropStg( (IUnknown*) pStg, fmtidPropStgName, PROPSETFLAG_DEFAULT  , 0L, &pPStg ));

        // Test IPropertyStorage**

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT, 0L, NULL ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, PROPSETFLAG_DEFAULT, 0L, NULL ));

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT, 0L, (IPropertyStorage**) INVALID_POINTER ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, PROPSETFLAG_DEFAULT, 0L, (IPropertyStorage**) INVALID_POINTER ));

        Check( E_INVALIDARG, g_pfnStgCreatePropStg( (IUnknown*) pStm, fmtidPropStgName, NULL, PROPSETFLAG_DEFAULT, 0L, (IPropertyStorage**) pbReadOnly ));
        Check( E_INVALIDARG, g_pfnStgOpenPropStg( (IUnknown*) pStm, fmtidPropStgName, PROPSETFLAG_DEFAULT, 0L, (IPropertyStorage**) pbReadOnly ));

        RELEASE_INTERFACE(pStm);

    }   // if( g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg && g_pfnStgOpenPropStg )

    // If we're not using IStorage::QueryInterface to get an IPropertySetStorage,
    // we must be using the new APIs, so let's test them.

        //  ----------------------------
        //  Test StgCreatePropSetStg API
        //  ----------------------------

    // In some cases we can't test these APIs, so only test them
    // if we have the function pointers.

    if( g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg && g_pfnStgOpenPropStg )
    {
        // Test the IStorage*

        Check( E_INVALIDARG, g_pfnStgCreatePropSetStg( NULL, 0L, &pPSStg ));
        Check( E_INVALIDARG, g_pfnStgCreatePropSetStg( (IStorage*) INVALID_POINTER, 0L, &pPSStg ));

        // Test the IPropertySetStorage**

        Check( E_INVALIDARG, g_pfnStgCreatePropSetStg( pStg, 0L, NULL ));
        Check( E_INVALIDARG, g_pfnStgCreatePropSetStg( pStg, 0L, (IPropertySetStorage**) INVALID_POINTER ));


        //  -------------------------------------------------------------
        //  Test g_pfnPropVariantCopy, PropVariantClear & FreePropVariantArray
        //  -------------------------------------------------------------

        // PropVariantCopy

        Check( E_INVALIDARG, g_pfnPropVariantCopy( rgcpropvarAllAccess, NULL ));
        Check( E_INVALIDARG, g_pfnPropVariantCopy( rgcpropvarAllAccess, (PROPVARIANT*) INVALID_POINTER ));

        Check( E_INVALIDARG, g_pfnPropVariantCopy( NULL, rgcpropvarAllAccess ));
        Check( E_INVALIDARG, g_pfnPropVariantCopy( (PROPVARIANT*) INVALID_POINTER, rgcpropvarAllAccess ));
        Check( E_INVALIDARG, g_pfnPropVariantCopy( (PROPVARIANT*) pbReadOnly, rgcpropvarAllAccess ));

        // PropVariantClear

        Check( S_OK, g_pfnPropVariantClear( NULL ));
        Check( E_INVALIDARG, g_pfnPropVariantClear( (PROPVARIANT*) INVALID_POINTER ));
        Check( E_INVALIDARG, g_pfnPropVariantClear( (PROPVARIANT*) pbReadOnly ));

        // FreePropVariantArray

        Check( E_INVALIDARG, g_pfnFreePropVariantArray( 1, NULL ));
        Check( E_INVALIDARG, g_pfnFreePropVariantArray( 1, (PROPVARIANT*) INVALID_POINTER ));

        Check( S_OK, g_pfnFreePropVariantArray( 1, (PROPVARIANT*) (void*)rgcpropvarReadAccess ));
        Check( E_INVALIDARG, g_pfnFreePropVariantArray( 2, (PROPVARIANT*) (void*)rgcpropvarReadAccess ));

    }   // if( g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg && g_pfnStgOpenPropStg )


    //  ----
    //  Exit
    //  ----

    VirtualFree( rgpropspecNoAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgcpropvarReadAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgcpropvarNoAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgpropidNoAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgpropidReadAccessBase, 0, MEM_RELEASE );
    VirtualFree( rglpwstrNoAccessBase, 0, MEM_RELEASE );
    VirtualFree( rglpwstrReadAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgStatPSStgReadAccessBase, 0, MEM_RELEASE );
    VirtualFree( rgStatPStgReadAccessBase, 0, MEM_RELEASE );

    RELEASE_INTERFACE(pPSStg);
    RELEASE_INTERFACE(pPStg);
    RELEASE_INTERFACE(pESPSStg);


    NtCurrentPeb()->AppCompatInfo = pAppCompatInfoSave;

#endif // #ifdef WIN32

}   // test_ParameterValidation(IStorage *pStg)





//       Check creation/open/deletion of property sets (check fmtid and predefined names)
//          Create a property set
//          Try recreate of same
//          Try delete
//          Close the property set
//          Try recreate of same
//          Reopen the property set
//          Try recreate of same
//          Try delete
//          Close the property set
//          Delete the property set
//          Repeat the test once more

void
test_IPropertySetStorage_CreateOpenDelete(IStorage *pStorage)
{
    Status( "IPropertySetStorage::Create/Open/Delete\n" );

    FMTID fmtid;
    PROPSPEC propspec;

    UuidCreate(&fmtid);

    for (int i=0; i<4; i++)
    {
        DWORD propsetflag;


        if( !(g_Restrictions & RESTRICT_SIMPLE_ONLY) )
            propsetflag = (i & 2) == 0 ? PROPSETFLAG_DEFAULT : PROPSETFLAG_NONSIMPLE;
        else
            propsetflag = PROPSETFLAG_DEFAULT;

        {
            IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
            IPropertyStorage *PropStg, *PropStg2;

            Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

            Check( S_OK, pPropSetStg->Create(fmtid,
                    NULL,
                    propsetflag,
                    STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &PropStg));

            Check( S_OK, pPropSetStg->Create(fmtid,
                    NULL,
                    propsetflag,
                    STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &PropStg2 ));

            Check( STG_E_REVERTED, PropStg->Commit(0) );

            RELEASE_INTERFACE( PropStg );
            RELEASE_INTERFACE( PropStg2 );
            RELEASE_INTERFACE( pPropSetStg );
        }
        {
            IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
            IPropertyStorage *PropStg, *PropStg2;

            Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

            // use STGM_FAILIFTHERE
            Check(STG_E_FILEALREADYEXISTS, pPropSetStg->Create(fmtid,
                    NULL,
                    propsetflag,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &PropStg));

            Check(S_OK, pPropSetStg->Open(fmtid,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &PropStg));

            Check( STG_E_ACCESSDENIED,
                   pPropSetStg->Open(fmtid,
                                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                    &PropStg2));

            Check( STG_E_ACCESSDENIED,
                   pPropSetStg->Create( fmtid,
                                        NULL,
                                        propsetflag,
                                        STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                        &PropStg2));


            // Docfile allows an open element to be deleted (putting open objects
            // in the reverted state).  NTFS doesn't allow the delete though.

            Check( (g_Restrictions & RESTRICT_NON_HIERARCHICAL)
                      ? STG_E_SHAREVIOLATION
                      : S_OK,
                    pPropSetStg->Delete(fmtid) );


            propspec.ulKind = PRSPEC_PROPID;
            propspec.propid = 1000;
            PROPVARIANT propvar;
            propvar.vt = VT_I4;
            propvar.lVal = 12345;

            Check((g_Restrictions & RESTRICT_NON_HIERARCHICAL) ? S_OK : STG_E_REVERTED,
                  PropStg->WriteMultiple(1, &propspec, &propvar, 2)); // force dirty

            RELEASE_INTERFACE(PropStg);
            RELEASE_INTERFACE(pPropSetStg);

            //Check(S_OK, pPropSetStg->Delete(fmtid));
        }
    }

}


void
test_IPropertySetStorage_SummaryInformation(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;
    Status( "SummaryInformation\n" );
    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    IPropertyStorage *PropStg;
    IStream *pstm;

    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Create(FMTID_SummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &PropStg));

    RELEASE_INTERFACE(PropStg);

    Check(S_OK, pStorage->OpenStream(OLESTR("\005SummaryInformation"),
            NULL,
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            0,
            &pstm));

    RELEASE_INTERFACE(pstm);
    RELEASE_INTERFACE(pPropSetStg);
}

//
//       Check STGM_FAILIFTHERE and ~STGM_FAILIFTHERE in following cases
//          Check overwriting simple with extant non-simple
//          Check overwriting simple with simple
//          Check overwriting non-simple with simple
//          Check overwriting non-simple with non-simple

void
test_IPropertySetStorage_FailIfThere(IStorage *pStorage)
{

    // (Use "fale" instead of "fail" in this printf so the output won't
    // alarm anyone with the word "fail" uncessarily).
    Status( "IPropertySetStorage, FaleIfThere\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    // Iter       0        1          2         3          4        5          6         7
    // Create     simple   nonsimple  simple    nonsimple  simple   nonsimple  simple    nonsimple
    // ReCreate   simple   simple     nonsimple nonsimple  simple   simple     nonsimple nonsimple
    //            failif   failif     failif    failif     overw    overw      overw     overw
    //
    // expected   exists   exists     exists    exists     ok       ok         ok        ok

    for (int i=0; i<8; i++)
    {
        FMTID fmtid;
        IPropertyStorage *PropStg;
        DWORD propsetflagNonSimple = (g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_DEFAULT : PROPSETFLAG_NONSIMPLE;

        UuidCreate(&fmtid);

        Check(S_OK, pPropSetStg->Create(fmtid,
                NULL,
                (i & 1) == 1 ? propsetflagNonSimple : 0,
                STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg));

        PropStg->Release();

        Check((i&4) == 4 ? S_OK : STG_E_FILEALREADYEXISTS,
            pPropSetStg->Create(fmtid,
                NULL,
                (i & 2) == 2 ? propsetflagNonSimple : 0,
                ( (i & 4) == 4 ? STGM_CREATE : STGM_FAILIFTHERE )
                |
                STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg));

        if (PropStg)
        {
            PropStg->Release();
        }
    }

    RELEASE_INTERFACE( pPropSetStg );
    Check( cStorageRefs, GetRefCount( pStorage ));
}

//
//
//
//       Bad this pointer.
//          Call all methods with a bad this pointer, check we get STG_E_INVALIDHANDLE
//

void
test_IPropertySetStorage_BadThis(IStorage *pIgnored)
{
    Status( "Bad IPropertySetStorage 'this' pointer\n" );

    IPropertySetStorage *pBad;
    IID iid;
    FMTID fmtid;
    void *pv;
    IPropertyStorage *pps;
    IEnumSTATPROPSETSTG *penm;

    pBad = reinterpret_cast<IPropertySetStorage*>(&iid);

    Check(STG_E_INVALIDHANDLE,pBad->QueryInterface(iid, &pv));
    Check(0, pBad->AddRef());
    Check(0, pBad->Release());
    Check(STG_E_INVALIDHANDLE,pBad->Create( fmtid, NULL, 0, 0, &pps));
    Check(STG_E_INVALIDHANDLE,pBad->Open(fmtid, 0, &pps));
    Check(STG_E_INVALIDHANDLE,pBad->Delete( fmtid ));
    Check(STG_E_INVALIDHANDLE,pBad->Enum( &penm ));

}

//       Transacted mode
//          Create a non-simple property set with one VT_STREAM child, close it
//          Open it in transacted mode
//          Write another VT_STORAGE child
//          Close and revert
//          Check that the second child does not exist.
//          Repeat and close and commit and check the child exists.

void
test_IPropertySetStorage_TransactedMode(IStorage *pStorage)
{
    FMTID fmtid;

    UuidCreate(&fmtid);

    if( g_Restrictions & ( RESTRICT_DIRECT_ONLY | RESTRICT_SIMPLE_ONLY )) return;
    Status( "Transacted Mode\n" );


    {
        //
        // create a substorage "teststg" with a propset
        // create a stream "src" which is then written via VT_STREAM as propid 7fffffff

        CTempStorage pSubStorage(coCreate, pStorage, OLESTR("teststg"));
        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pSubStorage);
        Check( S_OK, StgToPropSetStg( pSubStorage, &pPropSetStg ));
        IPropertyStorage *pPropSet;
        IStream *pstm;

        Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));

        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 0x7ffffffd;

        Check(S_OK, pStorage->CreateStream(OLESTR("src"), STGM_DIRECT|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
            0,0, &pstm));
        Check(S_OK, pstm->Write(L"billmo", 14, NULL));
        Check(S_OK, pstm->Seek(g_li0, STREAM_SEEK_SET, NULL));

        PROPVARIANT pv;
        pv.vt = VT_STREAM;
        pv.pStream = pstm;
        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 2)); // copies the stream in

        Check( 0, RELEASE_INTERFACE(pPropSet) );
        Check( 0, RELEASE_INTERFACE(pstm) );
        RELEASE_INTERFACE(pPropSetStg);
    }

    {
        IPropertyStorage *pPropSet;
        // Reopen the propset in transacted and add one with id 0x7ffffffe
        CTempStorage pSubStorage(coOpen, pStorage, OLESTR("teststg"), STGM_TRANSACTED);
        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pSubStorage);
        Check( S_OK, StgToPropSetStg( pSubStorage, &pPropSetStg ));

        // Create a storage object to copy
        CTempStorage pstgSrc;
        CTempStorage pTestChild(coCreate, pstgSrc, OLESTR("testchild"));

        Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));

        // copy in the storage object
        PROPSPEC ps[2];
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = 0x7ffffffe;
        ps[1].ulKind = PRSPEC_PROPID;
        ps[1].propid = 0x7ffffff0;

        PROPVARIANT pv[2];
        pv[0].vt = VT_STORAGE;
        pv[0].pStorage = pTestChild;
        pv[1].vt = VT_I4;
        pv[1].lVal = 123;

        Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 2)); // copies the storage in


        pSubStorage->Revert(); // throws away the storage

        // check that property set operations return stg_e_reverted

        Check(STG_E_REVERTED, pPropSet->WriteMultiple(2, ps, pv, 2));
        Check(STG_E_REVERTED, pPropSet->ReadMultiple(1, ps+1, pv+1));
        Check(STG_E_REVERTED, pPropSet->DeleteMultiple(1, ps+1));
        LPOLESTR pstr = L"pstr";
        Check(STG_E_REVERTED, pPropSet->ReadPropertyNames(1, &ps[1].propid, &pstr));
        Check(STG_E_REVERTED, pPropSet->WritePropertyNames(1, &ps[1].propid, &pstr));
        Check(STG_E_REVERTED, pPropSet->DeletePropertyNames(1, &ps[1].propid));
        Check(STG_E_REVERTED, pPropSet->Commit(STGC_DEFAULT));
        Check(STG_E_REVERTED, pPropSet->Revert());
        IEnumSTATPROPSTG *penum;
        Check(STG_E_REVERTED, pPropSet->Enum(&penum));
        FILETIME ft;
        Check(STG_E_REVERTED, pPropSet->SetTimes(&ft, &ft, &ft));
        CLSID clsid;
        Check(STG_E_REVERTED, pPropSet->SetClass(clsid));
        STATPROPSETSTG statpropsetstg;
        Check(STG_E_REVERTED, pPropSet->Stat(&statpropsetstg));

        Check( 0, RELEASE_INTERFACE(pPropSet) );
        RELEASE_INTERFACE(pPropSetStg);
    }

    {
        IPropertyStorage *pPropSet;
        // Reopen the propset in direct mode and check that the
        // second child is not there.

        CTempStorage pSubStorage(coOpen, pStorage, OLESTR("teststg"));
        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pSubStorage);
        Check( S_OK, StgToPropSetStg( pSubStorage, &pPropSetStg ));

        Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));

        // read out the storage object
        PROPSPEC aps[2];
        aps[0].ulKind = PRSPEC_PROPID;
        aps[0].propid = 0x7ffffffe; // storage not expected
        aps[1].ulKind = PRSPEC_PROPID;
        aps[1].propid = 0x7ffffffd; // stream is expected

        PROPVARIANT apv[2];
                Check(S_FALSE, pPropSet->ReadMultiple(1, aps, apv));
        Check(S_OK, pPropSet->ReadMultiple(2, aps, apv)); // opens the stream
        Check(TRUE, apv[0].vt == VT_EMPTY);
        Check(TRUE, apv[1].vt == VT_STREAM);
        Check(TRUE, apv[1].pStream != NULL);


        WCHAR wcsBillMo[7];
        Check(S_OK, apv[1].pStream->Read(wcsBillMo, 14, NULL));
        Check(TRUE, wcscmp(L"billmo", wcsBillMo) == 0);

        Check( 0, RELEASE_INTERFACE(apv[1].pStream) );
        Check( 0, RELEASE_INTERFACE(pPropSet) );
        RELEASE_INTERFACE(pPropSetStg);
    }
}

//
// test that the buffer is correctly reverted
//

void
test_IPropertySetStorage_TransactedMode2(IStorage *pStorage)
{
    if( g_Restrictions & (RESTRICT_DIRECT_ONLY | RESTRICT_SIMPLE_ONLY )) return;
    Status( "Transacted Mode 2\n" );

    //
    // write and commit a property A
    // write and revert a property B
    // write and commit a property C
    // check that property B does not exist

    FMTID fmtid;
    PROPSPEC ps;
    PROPVARIANT pv;
    IPropertyStorage *pPropStg;

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    UuidCreate(&fmtid);

    // We'll run this test twice, once with a Create and the other
    // with an Open (this way, we test both of the CPropertyStorage
    // constructors).

    for( int i = 0; i < 2; i++ )
    {
        if( i == 0 )
        {
            Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
                STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));
        }
        else
        {
            Check(S_OK, pPropSetStg->Open(fmtid,
                STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));
        }

        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 6;
        pv.vt = VT_I4;
        pv.lVal = 1;

        Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 0x2000));
        Check(S_OK, pPropStg->Commit(STGC_DEFAULT));

        ps.propid = 7;
        pv.lVal = 2;

        Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 0x2000));
        Check(S_OK, pPropStg->Revert());

        ps.propid = 8;
        pv.lVal = 3;

        Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 0x2000));
        Check(S_OK, pPropStg->Commit(STGC_DEFAULT));

        ps.propid = 6;
        Check(S_OK, pPropStg->ReadMultiple(1, &ps, &pv));
        Check(TRUE, pv.lVal == 1);
        Check(TRUE, pv.vt == VT_I4);

        ps.propid = 7;
        Check(S_FALSE, pPropStg->ReadMultiple(1, &ps, &pv));

        ps.propid = 8;
        Check(S_OK, pPropStg->ReadMultiple(1, &ps, &pv));
        Check(TRUE, pv.lVal == 3);
        Check(TRUE, pv.vt == VT_I4);

        RELEASE_INTERFACE(pPropStg);

    }   // for( int i = 0; i < 2; i++ )

    RELEASE_INTERFACE(pPropSetStg);
}

void
test_IPropertySetStorage_SubPropertySet(IStorage *pStorage)
{
    FMTID fmtid;
    PROPSPEC ps;
    PROPVARIANT pv;
    IPropertyStorage *pPropStg;
    IPropertySetStorage *pSubSetStg;
    IPropertyStorage *pPropStg2;

    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    Status( "Sub Property Set\n" );

    for (int i=0; i<2; i++)
    {

        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);

        ULONG cStorageRefs = GetRefCount( pStorage );
        Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

        UuidCreate(&fmtid);


        Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 6;
        pv.vt = VT_STORAGE;
        pv.pStorage = NULL;

        Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 0x2000));

        Check(S_OK, pPropStg->ReadMultiple(1, &ps, &pv));


        Check(S_OK, StgToPropSetStg( pv.pStorage, &pSubSetStg ));

        Check(S_OK, pSubSetStg->Create(fmtid, NULL, i==0 ? PROPSETFLAG_NONSIMPLE : PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg2));

        IStorage *pstgTmp = pv.pStorage;
        pv.pStorage = NULL;

        if (i==1)
        {
            pv.vt = VT_I4;
        }

        Check(S_OK, pPropStg2->WriteMultiple(1, &ps, &pv, 0x2000));

        pPropStg->Release();
        pstgTmp->Release();
        pSubSetStg->Release();
        pPropStg2->Release();

        RELEASE_INTERFACE(pPropSetStg);
        Check( cStorageRefs, GetRefCount(pStorage) );
    }
}

/*
The following sequence of operations:

- open transacted docfile
- open property set inside docfile
- write properties
- commit docfile
- release property set

results in a STG_E_REVERTED error being detected
*/

void
test_IPropertySetStorage_CommitAtRoot(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_DIRECT_ONLY ) return;
    Status( "Commit at root\n" );

    for (int i=0; i<6; i++)
    {
        FMTID fmtid;
        IStorage *pstgT = NULL;

        Check(S_OK, g_pfnStgCreateStorageEx(NULL,
                                       STGM_CREATE | STGM_DELETEONRELEASE | STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                       STGFMT_STORAGE,
                                       0, NULL, NULL,
                                       IID_IStorage,
                                       reinterpret_cast<void**>(&pstgT) ));

        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
        Check( S_OK, StgToPropSetStg( pstgT, &pPropSetStg ));

        UuidCreate(&fmtid);

        IPropertyStorage *pPropStg = NULL;

        Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = 1000;
        PROPVARIANT propvar;
        propvar.vt = VT_I4;
        propvar.lVal = 12345;

        Check(S_OK, pPropStg->WriteMultiple(1, &propspec, &propvar, 2)); // force dirty

        switch (i)
        {
        case 0:
            Check(S_OK, pstgT->Commit(STGC_DEFAULT));
            pstgT->Release();
            pPropStg->Release();
            break;
        case 1:
            Check(S_OK, pstgT->Commit(STGC_DEFAULT));
            pPropStg->Release();
            pstgT->Release();
            break;
        case 2:
            pstgT->Release();
            pPropStg->Release();
            break;
        case 3:
            pPropStg->Commit(STGC_DEFAULT);
            pPropStg->Release();
            pstgT->Release();
            break;
        case 4:
            pPropStg->Commit(STGC_DEFAULT);
            pstgT->Release();
            pPropStg->Release();
            break;
        case 5:
            pPropStg->Release();
            pstgT->Release();
            break;
        }

        Check( 0, RELEASE_INTERFACE(pstgT) );
    }
}

void
test_IPropertySetStorage(IStorage *pStorage)
{
    //       Check ref counting through different interfaces on object

    test_IPropertySetStorage_IUnknown(pStorage);
    test_IPropertySetStorage_CreateOpenDelete(pStorage);
    test_IPropertySetStorage_SummaryInformation(pStorage);
    test_IPropertySetStorage_FailIfThere(pStorage);

    test_IPropertySetStorage_TransactedMode(pStorage);
    test_IPropertySetStorage_TransactedMode2(pStorage);
    test_IPropertySetStorage_SubPropertySet(pStorage);
    test_IPropertySetStorage_CommitAtRoot(pStorage);
}


//  IEnumSTATPROPSETSTG
//
//       Check enumeration of property sets
//
//          Check refcounting and IUnknown
//
//          Create some property sets, predefined and not, simple and not, one through IStorage
//          Enumerate them and check
//              (check fmtid, grfFlags)
//              (check when asking for more than there is: S_FALSE, S_OK)
//          Delete one
//          Reset the enumerator
//          Enumerate them and check
//          Delete one
//
//          Reset the enumeratorA
//          Read one from enumeratorA
//          Clone enumerator -> enumeratorB
//          Loop comparing rest of enumerator contents
//
//          Reset the enumerator
//          Skip all
//          Check none left
//
//          Reset the enumerator
//          Skip all but one
//          Check one left
//
void test_IEnumSTATPROPSETSTG(IStorage *pStorage)
{
    Status( "IEnumSTATPROPSETSTG\n" );

    FMTID afmtid[8];
    CLSID aclsid[8];
    IPropertyStorage *pPropSet;

    memset( afmtid, 0, sizeof(afmtid) );
    memset( aclsid, 0, sizeof(aclsid) );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FILETIME ftStart;

    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    CoFileTimeNow(&ftStart);

    IEnumSTATPROPSETSTG *penum, *penum2;
    STATPROPSETSTG StatBuffer[6];

    Check(S_OK, pPropSetStg->Enum(&penum));
    while( S_OK == penum->Next( 1, &StatBuffer[0], NULL ))
        pPropSetStg->Delete( StatBuffer[0].fmtid );
    RELEASE_INTERFACE( penum );

    Check(S_OK, pPropSetStg->Enum(&penum));
    Check( S_FALSE, penum->Next( 1, &StatBuffer[0], NULL ));
    RELEASE_INTERFACE( penum );

    for (int i=0; i<5; i++)
    {
        ULONG cFetched;

        if (i & 4)
            afmtid[i] = FMTID_SummaryInformation;
        else
            UuidCreate(&afmtid[i]);

        UuidCreate(&aclsid[i]);

        Check(S_OK, pPropSetStg->Create(
            afmtid[i],
            aclsid+i,
            ( (i & 1) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : 0)
            |
            ( (i & 2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0),
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));
        pPropSet->Release();

        Check(S_OK, pPropSetStg->Enum(&penum));
        Check( S_FALSE, penum->Next( i+2, &StatBuffer[0], &cFetched ));
        Check( S_OK,    penum->Reset() );
        Check( S_OK,    penum->Next( i+1, &StatBuffer[0], &cFetched ));
        RELEASE_INTERFACE( penum );

    }


    ULONG celt;

    Check(S_OK, pPropSetStg->Enum(&penum));

    IUnknown *punk, *punk2;
    IEnumSTATPROPSETSTG *penum3;
    Check(S_OK, penum->QueryInterface(IID_IUnknown, (void**)&punk));
    Check(S_OK, punk->QueryInterface(IID_IEnumSTATPROPSETSTG, (void**)&penum3));
    Check(S_OK, penum->QueryInterface(IID_IEnumSTATPROPSETSTG, (void**)&punk2));
    Check(TRUE, punk == punk2);
    punk->Release();
    penum3->Release();
    punk2->Release();

    // test S_FALSE
    Check(S_FALSE, penum->Next(6, StatBuffer, &celt));
    Check(TRUE, celt == 5);
    penum->Reset();


    // test reading half out, then cloning, then comparing
    // rest of enumeration with other clone.

    Check(S_OK, penum->Next(3, StatBuffer, &celt));
    Check(TRUE, celt == 3);
    celt = 0;
    Check(S_OK, penum->Clone(&penum2));
    Check(S_OK, penum->Next(2, StatBuffer, &celt));
    Check(TRUE, celt == 2);

    // check the clone
    for (int c=0; c<2; c++)
    {
        STATPROPSETSTG CloneStat;
        Check(S_OK, penum2->Next(1, &CloneStat, NULL));
        Check(TRUE, 0 == memcmp(&CloneStat, StatBuffer+c, sizeof(CloneStat)));
        Check(TRUE, CloneStat.dwOSVersion == PROPSETHDR_OSVERSION_UNKNOWN);
    }

    // check both empty
    celt = 0;
    Check(S_FALSE, penum->Next(1, StatBuffer, &celt));
    Check(TRUE, celt == 0);

    Check(S_FALSE, penum2->Next(1, StatBuffer, &celt));
    Check(TRUE, celt == 0);

    penum->Reset();

    //
    // loop deleting one propset at a time
    // enumerate the propsets checking that correct ones appear.
    //


    for (ULONG d = 0; d<5; d++)
    {
        // d is for delete

        BOOL afFound[5];

        Check(S_FALSE, penum->Next(5+1-d, StatBuffer, &celt));
        Check(TRUE, celt == 5-d );
        penum->Reset();


        memset(afFound, 0, sizeof(afFound));
        for (ULONG iPropSet=0; iPropSet<5; iPropSet++)
        {
            for (ULONG iSearch=0; iSearch<5-d; iSearch++)
            {
                if (0 == memcmp(&StatBuffer[iSearch].fmtid, &afmtid[iPropSet], sizeof(StatBuffer[0].fmtid)))
                {
                    Check(FALSE, afFound[iPropSet]);
                    afFound[iPropSet] = TRUE;
                    break;
                }
            }

            if (iPropSet < d)
                Check(FALSE, afFound[iPropSet]);

            if (iSearch == 5-d)
            {
                Check(TRUE, iPropSet < d);
                continue;
            }

            Check(TRUE, ( (StatBuffer[iSearch].grfFlags & PROPSETFLAG_NONSIMPLE) ? 1u : 0u )
                        ==
                        ( (!(g_Restrictions & RESTRICT_SIMPLE_ONLY) && (iPropSet & 1)) ? 1u : 0u)
                 );

            Check(TRUE, (StatBuffer[iSearch].grfFlags & PROPSETFLAG_ANSI) == 0);

            // We should have a clsid if this is a non-simple property set and we're not disallowing
            // hierarchical storages (i.e. it's not NTFS).

            if( (PROPSETFLAG_NONSIMPLE & StatBuffer[iSearch].grfFlags) && !(RESTRICT_NON_HIERARCHICAL & g_Restrictions) )
                Check(TRUE, StatBuffer[iSearch].clsid == aclsid[iPropSet]);
            else
                Check(TRUE, StatBuffer[iSearch].clsid == CLSID_NULL);

            CheckTime(ftStart, StatBuffer[iSearch].mtime);
            CheckTime(ftStart, StatBuffer[iSearch].atime);
            CheckTime(ftStart, StatBuffer[iSearch].ctime);
        }

        Check(S_OK, pPropSetStg->Delete(afmtid[d]));
        penum->Release();
        Check(S_OK, pPropSetStg->Enum(&penum));
//        Check(S_OK, penum->Reset());
    }

    penum->Release();
    penum2->Release();
    pPropSetStg->Release();

}


//   Creation tests
//
//       Access flags/Valid parameters/Permissions
//          Check readonly cannot be written -
//              WriteProperties, WritePropertyNames
void
test_IPropertyStorage_Access(IStorage *pStorage)
{
    Status( "IPropertyStorage creation (access) tests\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount(pStorage);
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    // check by name
    IPropertyStorage *pPropStg;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, 0,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

//   QueryInterface tests
//          QI to IPropertyStorage
//          QI to IUnknown on IPropertyStorage
//          QI back to IPropertyStorage from IUnknown
//
//          Release all.
    IPropertyStorage *pPropStg2,*pPropStg3;
    IUnknown *punk;

    Check(S_OK, pPropStg->QueryInterface(IID_IPropertyStorage,
        (void**)&pPropStg2));

    Check(S_OK, pPropStg->QueryInterface(IID_IUnknown,
        (void**)&punk));

    Check(S_OK, punk->QueryInterface(IID_IPropertyStorage,
        (void**)&pPropStg3));

    pPropStg3->Release();
    pPropStg2->Release();
    punk->Release();

    PROPSPEC ps;
    ps.ulKind = PRSPEC_LPWSTR;
    ps.lpwstr = OLESTR("testprop");

    PROPVARIANT pv;
    pv.vt = VT_LPSTR;
    pv.pszVal = (LPSTR) "testval";

    Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 2));
    pPropStg->Release();

    Check(S_OK, pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READ, &pPropStg));
    Check(STG_E_ACCESSDENIED, pPropStg->WriteMultiple(1, &ps, &pv, 2));
    Check(STG_E_ACCESSDENIED, pPropStg->DeleteMultiple(1, &ps));
    PROPID propid=3;
    Check(STG_E_ACCESSDENIED, pPropStg->WritePropertyNames(1, &propid, (LPOLESTR*) &pv.pszVal));
    Check(STG_E_ACCESSDENIED, pPropStg->DeletePropertyNames(1, &propid));
    FILETIME ft;
    Check(STG_E_ACCESSDENIED, pPropStg->SetTimes(&ft, &ft, &ft));
    CLSID clsid;
    Check(STG_E_ACCESSDENIED, pPropStg->SetClass(clsid));

    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
}

//   Creation tests
//       Check VT_STREAM etc not usable with simple.
//

void
test_IPropertyStorage_Create(IStorage *pStorage)
{
    Status( "IPropertyStorage creation (simple/non-simple) tests\n" );

    IPropertySetStorage *pPropSetStg = NULL;
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    // check by name
    IPropertyStorage *pPropStg;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_DEFAULT,
                                    STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                    &pPropStg));

    PROPSPEC ps;
    ps.ulKind = PRSPEC_PROPID;
    ps.propid = 2;

    PROPVARIANT pv;
    pv.vt = VT_STREAM;
    pv.pStream = NULL;

    Check(STG_E_PROPSETMISMATCHED, pPropStg->WriteMultiple(1, &ps, &pv, 2000));

    pPropStg->Release();

    Check( cStorageRefs, RELEASE_INTERFACE(pStorage) );
}

//
//
//   Stat (Create four combinations)
//       Check non-simple/simple flag
//       Check ansi/wide fflag
//     Also test clsid on propset

void test_IPropertyStorage_Stat(IStorage *pStorage)
{
    Status( "IPropertyStorage::Stat\n" );

    DWORD dwOSVersion = 0;

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;
    UuidCreate(&fmtid);
    IPropertyStorage *pPropSet;
    STATPROPSETSTG StatPropSetStg;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    // Calculate the OS Version

#ifdef _MAC
    {
        // Get the Mac System Version (e.g., 7.53).

        OSErr oserr;
        SysEnvRec theWorld;
        oserr = SysEnvirons( curSysEnvVers, &theWorld );
        Check( TRUE, noErr == oserr );

        dwOSVersion = MAKEPSVER( OSKIND_MACINTOSH,
                                 HIBYTE(theWorld.systemVersion),
                                 LOBYTE(theWorld.systemVersion) );

    }
#else
    dwOSVersion = MAKELONG( LOWORD(GetVersion()), OSKIND_WIN32 );
#endif


    for (ULONG i=0; i<4; i++)
    {
        FILETIME ftStart;
        CoFileTimeNow(&ftStart);

        memset(&StatPropSetStg, 0, sizeof(StatPropSetStg));
        CLSID clsid;
        UuidCreate(&clsid);

        Check(S_OK, pPropSetStg->Create(fmtid, &clsid,
            ((i & 1) && 0 == (g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : 0)
            |
            ((i & 2) && 0 == (g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0),
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

        CheckStat(pPropSet, fmtid,
                  clsid,
                  (
                     ((i & 1) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : 0)
                     |
                     ((i & 2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0)
                  ),
                  ftStart, dwOSVersion );
        pPropSet->Release();

        Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

        CheckStat(pPropSet, fmtid, clsid,
            ((i & 1) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_NONSIMPLE : 0) |
            ((i & 2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY)? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );

        UuidCreate(&clsid);
        Check(S_OK, pPropSet->SetClass(clsid));
        pPropSet->Release();

        Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
        CheckStat(pPropSet, fmtid, clsid,
                  ((i & 1) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : 0)
                  |
                  ((i & 2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );
        pPropSet->Release();
    }

    RELEASE_INTERFACE(pPropSetStg);

}

//   ReadMultiple
//     Check none found S_FALSE
//
//     Success case non-simple readmultiple
//       Create a non-simple property set
//       Create two sub non-simples
//       Close all
//       Open the non-simple
//       Query for the two sub-nonsimples
//       Try writing to them
//       Close all
//       Open the non-simple
//       Query for the two sub-nonsimples
//       Check read back
//       Close all

void
test_IPropertyStorage_ReadMultiple_Normal(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    Status( "IPropertyStorage::ReadMultiple (normal)\n" );

    IPropertySetStorage *pPropSetStg = NULL;
    FMTID fmtid;
    UuidCreate(&fmtid);
    IPropertyStorage *pPropSet;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            PROPSETFLAG_NONSIMPLE,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

    // none found
    PROPSPEC ps[2];

    ps[0].ulKind = PRSPEC_LPWSTR;
    ps[0].lpwstr = L"testname";

    ps[1].ulKind = PRSPEC_PROPID;
    ps[1].propid = 1000;

    PROPVARIANT pv[2];
    PROPVARIANT pvSave[2];
    PROPVARIANT pvExtra[2];

    Check(S_FALSE, pPropSet->ReadMultiple(2, ps, pv));

    PropVariantInit( &pv[0] );
    pv[0].vt = VT_STREAM;
    pv[0].pStream = NULL;

    PropVariantInit( &pv[1] );
    pv[1].vt = VT_STORAGE;
    pv[1].pStorage = NULL;

    memcpy(pvSave, pv, sizeof(pvSave));
    memcpy(pvExtra, pv, sizeof(pvExtra));

    // write the two sub non-simples
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 1000));

    // re-open them
    Check(S_OK, pPropSet->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].pStream != NULL);
    Check(TRUE, pv[1].pStorage != NULL);

    // check status of write when already open
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pvSave, 1000));


    Check(STG_E_REVERTED, pv[0].pStream->Commit(0));
    Check(STG_E_REVERTED, pv[1].pStorage->Commit(0));
    Check(S_OK, pPropSet->ReadMultiple(2, ps, pvExtra));
    Check(TRUE, pvExtra[0].pStream != NULL);
    Check(TRUE, pvExtra[1].pStorage != NULL);
    Check(S_OK, pvExtra[0].pStream->Commit(0));
    Check(S_OK, pvExtra[1].pStorage->Commit(0));

    pvExtra[0].pStream->Release();
    pvExtra[1].pStorage->Release();

    pv[0].pStream->Release();
    pv[1].pStorage->Release();

    Check(S_OK, pPropSet->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].pStream != NULL);
    Check(TRUE, pv[1].pStorage != NULL);

    Check(S_OK, pv[0].pStream->Write("billmotest", sizeof("billmotest"), NULL));
    IStream *pStm;
    Check(S_OK, pv[1].pStorage->CreateStream(OLESTR("teststream"),
        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
        0, 0, &pStm));
    pStm->Release();
    pv[0].pStream->Release();
    pv[1].pStorage->Release();
    pPropSet->Release();

    // re-re-open them
    Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
    Check(S_OK, pPropSet->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].pStream != NULL);
    Check(TRUE, pv[0].pStorage != NULL);

    // read the stream and storage and check the contents.
    char szBillMo[32];
    Check(S_OK, pv[0].pStream->Read(szBillMo, 11, NULL));
    Check(TRUE, 0 == strcmp(szBillMo, "billmotest"));
    Check(S_OK, pv[1].pStorage->OpenStream(OLESTR("teststream"), NULL,
        STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pStm));
    pStm->Release();
    pv[1].pStorage->Release();
    pv[0].pStream->Release();
    pPropSet->Release();

    RELEASE_INTERFACE(pPropSetStg);

}

//
//     CleanupOpenedObjects for ReadMultiple (two iterations one for "VT_STORAGE then VT_STREAM", one for
//              "VT_STREAM then VT_STORAGE")
//       Create property set
//       Create a "VT_STREAM then VT_STORAGE"
//       Open the second one exclusive
//       Formulate a query so that both are read - > will fail but ...
//       Check that the first one is still openable
//

void
test_IPropertyStorage_ReadMultiple_Cleanup(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    Status( "IPropertyStorage::ReadMultiple (cleanup)\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);


    for (LONG i=0;i<2;i++)
    {
        IPropertyStorage * pPropSet;
        Check(S_OK, pPropSetStg->Create(fmtid, NULL,
                PROPSETFLAG_NONSIMPLE,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                &pPropSet));

        // none found
        PROPSPEC ps[2];
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = 1000;
        ps[1].ulKind = PRSPEC_PROPID;
        ps[1].propid = 2000;

        PROPVARIANT pv[2];

        pv[0].vt = (i == 0) ? VT_STREAM : VT_STORAGE;
        pv[0].pStream = NULL;
        pv[1].vt = (i == 1) ? VT_STORAGE : VT_STREAM;
        pv[1].pStorage = NULL;

        // write the two sub non-simples

        // OFS gives driver internal error when overwriting a stream with a storage.
        Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 1000));

        // open both
        Check(S_OK, pPropSet->ReadMultiple(2, ps, pv)); // **

        // close the first ONLY and reopen both

        PROPVARIANT pv2[2];

        if (i==0)
            pv[0].pStream->Release();
        else
            pv[0].pStorage->Release();

        // reading both should fail because second is still open
        Check(STG_E_ACCESSDENIED, pPropSet->ReadMultiple(2, ps, pv2));
        // failure should not prevent this from succeeding
        Check(S_OK, pPropSet->ReadMultiple(1, ps, pv2)); // ***

        // cleanup from ** and ***
        if (i==0)
        {
            pv2[0].pStream->Release(); // ***
            pv[1].pStorage->Release(); // **
        }
        else
        {
            pv2[0].pStorage->Release(); // ***
            pv[1].pStream->Release(); // **
        }

        pPropSet->Release();
    }

    RELEASE_INTERFACE(pPropSetStg);
}

//     Reading an inconsistent non-simple
//       Create a non-simple
//       Create a sub-stream/storage
//       Close all
//       Delete the actual stream
//       Read the indirect property -> should not exist.
//

void
test_IPropertyStorage_ReadMultiple_Inconsistent(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    if( PROPIMP_NTFS == g_enumImplementation ) return;

    Status( "IPropertyStorage::ReadMultiple (inconsistent test)\n" );

    IPropertySetStorage *pPropSetStg = NULL;
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    IPropertyStorage * pPropSet;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            PROPSETFLAG_NONSIMPLE,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

    // none found
    PROPSPEC ps[3];
    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = 1000;
    ps[1].ulKind = PRSPEC_PROPID;
    ps[1].propid = 2000;
    ps[2].ulKind = PRSPEC_PROPID;
    ps[2].propid = 3000;

    PROPVARIANT pv[3];

    pv[0].vt = VT_STREAM;
    pv[0].pStream = NULL;
    pv[1].vt = VT_STORAGE;
    pv[1].pStorage = NULL;
    pv[2].vt = VT_UI4;
    pv[2].ulVal = 12345678;

    // write the two sub non-simples
    Check(S_OK, pPropSet->WriteMultiple(3, ps, pv, 1000));
    pPropSet->Release();
    Check(S_OK, pStorage->Commit(STGC_DEFAULT));

    // delete the propsets
    OLECHAR ocsPropsetName[48];

    // get name of the propset storage
    RtlGuidToPropertySetName(&fmtid, ocsPropsetName);

    // open it
    CTempStorage pStgPropSet(coOpen, pStorage, ocsPropsetName);

    // enumerate the non-simple properties.
    IEnumSTATSTG *penum;
    STATSTG stat[4];
    ULONG celt;
    Check(S_OK, pStgPropSet->EnumElements(0, NULL, 0, &penum));
    Check(S_OK, penum->Next(3, stat, &celt));
    penum->Release();


    for (ULONG i=0;i<celt;i++)
    {
        if (ocscmp(OLESTR("CONTENTS"), stat[i].pwcsName) != 0)
                        pStgPropSet->DestroyElement(stat[i].pwcsName);
        delete [] stat[i].pwcsName;
    }
    pStgPropSet.Release();

    Check(S_OK, pPropSetStg->Open(fmtid,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
    Check(S_OK, pPropSet->ReadMultiple(3, ps, pv));
    Check(TRUE, pv[0].vt == VT_EMPTY);
    Check(TRUE, pv[1].vt == VT_EMPTY);
    Check(TRUE, pv[2].vt == VT_UI4);
    Check(TRUE, pv[2].ulVal == 12345678);
    pPropSet->Release();

    RELEASE_INTERFACE(pPropSetStg);
}

void
test_IPropertyStorage_ReadMultiple(IStorage *pStorage)
{
    test_IPropertyStorage_ReadMultiple_Normal(pStorage);
    test_IPropertyStorage_ReadMultiple_Cleanup(pStorage);
    test_IPropertyStorage_ReadMultiple_Inconsistent(pStorage);
}


//       Overwrite a non-simple property with a simple in a simple propset
void
test_IPropertyStorage_WriteMultiple_Overwrite1(IStorage *pStgBase)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    if( PROPIMP_NTFS == g_enumImplementation ) return;

    Status( "IPropertyStorage::WriteMultiple (overwrite 1)\n" );

    CTempStorage pStgSimple(coCreate, pStgBase, OLESTR("ov1_simp"));
    CTempStorage pStorage(coCreate, pStgBase, OLESTR("ov1_stg"));
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertySetStorage *pPropSetSimpleStg = NULL;

    FMTID fmtid, fmtidSimple;

    UuidCreate(&fmtid);
    UuidCreate(&fmtidSimple);

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    Check( S_OK, StgToPropSetStg( pStgSimple, &pPropSetSimpleStg ));

    // create a simple set with a non-simple child by copying the contents
    // stream a non-simple to a property set stream (simple)

    // create a nonsimple propset (will contain the contents stream)
    IPropertyStorage * pPropSet;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            PROPSETFLAG_NONSIMPLE,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
    // none found
    PROPSPEC ps[2];
    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = 1000;
    ps[1].ulKind = PRSPEC_LPWSTR;
    ps[1].lpwstr = OLESTR("foobar");
    PROPVARIANT pv[2];
    pv[0].vt = VT_STREAM;
    pv[0].pStream = NULL;
    pv[1].vt = VT_UI1;
    pv[1].bVal = 66;
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 100));

    // invalid parameter
    PROPVARIANT pvInvalid[2];
    PROPSPEC psInvalid[2];

    psInvalid[0].ulKind = PRSPEC_PROPID;
    psInvalid[0].propid = 1000;
    psInvalid[1].ulKind = PRSPEC_PROPID;
    psInvalid[1].propid = 1001;
    pvInvalid[0].vt = (VARTYPE)-99;
    pvInvalid[1].vt = (VARTYPE)-100;

    Check(HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED), pPropSet->WriteMultiple(1, psInvalid, pvInvalid, 100));
    Check(HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED), pPropSet->WriteMultiple(2, psInvalid, pvInvalid, 100));

    pPropSet->Release();

    // create a simple propset (will be overwritten)
    IPropertyStorage * pPropSetSimple;
    Check(S_OK, pPropSetSimpleStg->Create(fmtidSimple, NULL,
            0,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSetSimple));
    pPropSetSimple->Release();

    OLECHAR ocsNonSimple[48];
    OLECHAR ocsSimple[48];
    // get the name of the simple propset
    RtlGuidToPropertySetName(&fmtidSimple, ocsSimple);
    // get the name of the non-simple propset
    RtlGuidToPropertySetName(&fmtid, ocsNonSimple);

    // open non-simple as a storage (will copy the simple to this)
    IStorage *pstgPropSet;
    Check(S_OK, pStorage->OpenStorage(ocsNonSimple, NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, NULL, 0, &pstgPropSet));

    // copy the contents of the non-simple to the propset of the simple
    IStream *pstmNonSimple;
    Check(S_OK, pstgPropSet->OpenStream(OLESTR("CONTENTS"), NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, 0, &pstmNonSimple));

    IStream *pstmSimple;
    Check(S_OK, pStgSimple->OpenStream(ocsSimple,
        NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pstmSimple));

    ULARGE_INTEGER uli;
    memset(&uli, 0xff, sizeof(uli));

    Check(S_OK, pstmNonSimple->CopyTo(pstmSimple, uli, NULL, NULL));
    pstmSimple->Release();
    pstmNonSimple->Release();
    pstgPropSet->Release();

    // But now the FMTID *in* the simple property set doesn't
    // match the string-ized FMTID which is the Stream's name.  So,
    // rename the Stream to match the property set's FMTID.

    Check(S_OK, pStgSimple->RenameElement( ocsSimple, ocsNonSimple ));

    // now we have a simple propset with a non-simple VT type
    Check(S_OK, pPropSetSimpleStg->Open(fmtid, // Use the non-simple FMTID now
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSetSimple));

    Check(S_FALSE, pPropSetSimple->ReadMultiple(1, ps, pv));
    Check(S_OK, pPropSetSimple->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].vt == VT_EMPTY);
    Check(TRUE, pv[1].vt == VT_UI1);
    Check(TRUE, pv[1].bVal == 66);

    RELEASE_INTERFACE( pPropSetSimpleStg );

    pPropSetSimple->Release();
    RELEASE_INTERFACE(pPropSetStg);
}

//       Overwrite a non-simple with a simple in a non-simple
//          check that the non-simple is actually deleted
//       Delete a non-simple
//          check that the non-simple is actually deleted
void
test_IPropertyStorage_WriteMultiple_Overwrite2(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    if( PROPIMP_NTFS == g_enumImplementation ) return;

    Status( "IPropertyStorage::WriteMultiple (overwrite 2)\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    IPropertyStorage *pPropSet;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropSet));

    // create the non-simple
    PROPSPEC ps[5];
    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = 1000;
    ps[1].ulKind = PRSPEC_PROPID;
    ps[1].propid = 1001;
    ps[2].ulKind = PRSPEC_PROPID;
    ps[2].propid = 1002;
    ps[3].ulKind = PRSPEC_PROPID;
    ps[3].propid = 1003;
    ps[4].ulKind = PRSPEC_PROPID;
    ps[4].propid = 1004;
    PROPVARIANT pv[5];
    pv[0].vt = VT_STORAGE;
    pv[0].pStorage = NULL;
    pv[1].vt = VT_STREAM;
    pv[1].pStream = NULL;
    pv[2].vt = VT_STORAGE;
    pv[2].pStorage = NULL;
    pv[3].vt = VT_STREAM;
    pv[3].pStream = NULL;
    pv[4].vt = VT_STREAM;
    pv[4].pStream = NULL;

    Check(S_OK, pPropSet->WriteMultiple(5, ps, pv, 2000));
    pPropSet->Release();

    // get the name of the propset
    OLECHAR ocsPropsetName[48];
    RtlGuidToPropertySetName(&fmtid, ocsPropsetName);

    IStorage *pstgPropSet;
    Check(S_OK, pStorage->OpenStorage(ocsPropsetName, NULL,
        STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
        NULL, 0, &pstgPropSet));

    // get the names of the non-simple property
    IEnumSTATSTG *penum;
    STATSTG statProp[6];
    ULONG celt;
    Check(S_OK, pstgPropSet->EnumElements(0, NULL, 0, &penum));
    Check(S_OK, penum->Next(5, statProp, &celt));
    Check(TRUE, celt == 5);
    delete [] statProp[0].pwcsName;
    delete [] statProp[1].pwcsName;
    delete [] statProp[2].pwcsName;
    delete [] statProp[3].pwcsName;
    delete [] statProp[4].pwcsName;
    penum->Release();

    // reopen the property set and delete the non-simple
    pstgPropSet->Release();

    Check(S_OK, pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
        &pPropSet));

    pv[0].vt = VT_LPWSTR;
    pv[0].pwszVal = L"Overwrite1";
    pv[1].vt = VT_LPWSTR;
    pv[1].pwszVal = L"Overwrite2";
    pv[2].vt = VT_LPWSTR;
    pv[2].pwszVal = L"Overwrite3";
    pv[3].vt = VT_LPWSTR;
    pv[3].pwszVal = L"Overwrite4";
    pv[4].vt = VT_LPWSTR;
    pv[4].pwszVal = L"Overwrite5";

    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 2000));
    Check(S_OK, pPropSet->DeleteMultiple(1, ps+2));
    Check(S_OK, pPropSet->DeleteMultiple(2, ps+3));
    pPropSet->Release();

    // open the propset as storage again and check that the VT_STORAGE is gone.
    Check(S_OK, pStorage->OpenStorage(ocsPropsetName, NULL,
        STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
        NULL, 0, &pstgPropSet));

    // check they were removed
    STATSTG statProp2[5];
    Check(S_OK, pstgPropSet->EnumElements(0, NULL, 0, &penum));
    Check(S_FALSE, penum->Next(5, statProp2, &celt));
    Check(TRUE, celt == 1);   // contents
    delete [] statProp2[0].pwcsName;

    penum->Release();
    pstgPropSet->Release();
    RELEASE_INTERFACE(pPropSetStg);
}

//       Write a VT_STORAGE over a VT_STREAM
//          check for cases: when not already open, when already open(access denied)
//       Write a VT_STREAM over a VT_STORAGE
//          check for cases: when not already open, when already open(access denied)
void
test_IPropertyStorage_WriteMultiple_Overwrite3(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_SIMPLE_ONLY ) return;
    Status( "IPropertyStorage::WriteMultiple (overwrite 3)\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    IPropertyStorage *pPropSet;

    Check(S_OK, pPropSetStg->Create(fmtid, NULL, PROPSETFLAG_NONSIMPLE,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
        &pPropSet));
    PROPSPEC ps[2];
    ps[0].ulKind = PRSPEC_LPWSTR;
    ps[0].lpwstr = OLESTR("stream_storage");
    ps[1].ulKind = PRSPEC_LPWSTR;
    ps[1].lpwstr = OLESTR("storage_stream");
    PROPVARIANT pv[2];
    pv[0].vt = VT_STREAMED_OBJECT;
    pv[0].pStream = NULL;
    pv[1].vt = VT_STORED_OBJECT;
    pv[1].pStorage = NULL;

    PROPVARIANT pvSave[2];
    pvSave[0] = pv[0];
    pvSave[1] = pv[1];

    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 1000));

    // swap them around
    PROPVARIANT pvTemp;
    pvTemp = pv[0];
    pv[0] = pv[1];
    pv[1] = pvTemp;
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pv, 1000));
    memset(pv, 0, sizeof(pv));
    Check(S_OK, pPropSet->ReadMultiple(2, ps, pv));
    Check(TRUE, pv[0].vt == VT_STORED_OBJECT);
    Check(TRUE, pv[1].vt == VT_STREAMED_OBJECT);
    Check(TRUE, pv[0].pStorage != NULL);
    Check(TRUE, pv[1].pStream != NULL);
    STATSTG stat; stat.type = 0;
    Check(S_OK, pv[0].pStorage->Stat(&stat, STATFLAG_NONAME));
    Check(TRUE, stat.type == STGTY_STORAGE);
    Check(S_OK, pv[1].pStream->Stat(&stat, STATFLAG_NONAME));
    Check(TRUE, stat.type == STGTY_STREAM);

    STATSTG stat2; stat2.type = 0;
    // swap them around again, but this time with access denied
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pvSave, 1000));
    Check(STG_E_REVERTED, pv[0].pStorage->Stat(&stat, STATFLAG_NONAME));
    pv[0].pStorage->Release();
    Check(S_OK, pPropSet->WriteMultiple(2, ps, pvSave, 1000));
    Check(STG_E_REVERTED, pv[1].pStream->Stat(&stat, STATFLAG_NONAME));
    pv[1].pStream->Release();

    pPropSet->Release();
    RELEASE_INTERFACE(pPropSetStg);
}

//
// test using IStorage::Commit to commit the changes in a nested
// property set
//

void
test_IPropertyStorage_Commit(IStorage *pStorage)
{
    if( g_Restrictions & ( RESTRICT_SIMPLE_ONLY | RESTRICT_DIRECT_ONLY) ) return;
    Status( "IPropertyStorage::Commit\n" );

    // 8 scenarios: (simple+non-simple)  * (direct+transacted) * (release only + commit storage + commit propset)
    for (int i=0; i<32; i++)
    {
        CTempStorage pDeeper(coCreate, pStorage, GetNextTest(), (i & 1) ? STGM_TRANSACTED : STGM_DIRECT);
        IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pDeeper);
        FMTID fmtid;

        ULONG cDeeperRefs = GetRefCount( pDeeper );
        Check( S_OK, StgToPropSetStg( pDeeper, &pPropSetStg ));
        UuidCreate(&fmtid);

        IPropertyStorage *pPropSet;

        Check(S_OK, pPropSetStg->Create(fmtid, NULL, (i&8) ? PROPSETFLAG_NONSIMPLE : PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE | ((i&16) && (i&8) ? STGM_TRANSACTED : STGM_DIRECT),
            &pPropSet));

        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 100;
        PROPVARIANT pv;
        pv.vt = VT_I4;
        pv.lVal = 1234;

        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 1000));

        memset(&pv, 0, sizeof(pv));
        Check(S_OK, pPropSet->ReadMultiple(1, &ps, &pv));
        Check(TRUE, pv.lVal == 1234);

        pv.lVal = 2345; // no size changes
        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 1000));

        if (i & 4)
            Check(S_OK, pPropSet->Commit(0));
        if (i & 2)
            Check(S_OK, pStorage->Commit(0));

        Check(0, pPropSet->Release()); // implicit commit if i&2 is false

        if (S_OK == pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                    &pPropSet))
        {
            memset(&pv, 0, sizeof(pv));
            Check( !((i&16) && (i&8)) || (i&0x1c)==0x1c ? S_OK : S_FALSE, pPropSet->ReadMultiple(1, &ps, &pv));
            if (!((i&16) && (i&8))  || (i&0x1c)==0x1c)
                Check(TRUE, pv.lVal == 2345);

            pPropSet->Release();
        }

        RELEASE_INTERFACE(pPropSetStg);
        Check( cDeeperRefs, GetRefCount( pDeeper ));
    }
}

void
test_IPropertyStorage_WriteMultiple(IStorage *pStorage)
{
    test_IPropertyStorage_WriteMultiple_Overwrite1(pStorage);
    test_IPropertyStorage_WriteMultiple_Overwrite2(pStorage);
    test_IPropertyStorage_WriteMultiple_Overwrite3(pStorage);
    test_IPropertyStorage_Commit(pStorage);

}

// this serves as a test for WritePropertyNames, ReadPropertyNames, DeletePropertyNames
// DeleteMultiple, PropVariantCopy, FreePropVariantArray.

void
test_IPropertyStorage_DeleteMultiple(IStorage *pStorage)
{
    Status( "IPropertyStorage::DeleteMultiple\n" );

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    ULONG cStorageRefs = GetRefCount( pStorage );
    Check( S_OK, StgToPropSetStg( pStorage, &pPropSetStg ));
    UuidCreate(&fmtid);

    IPropertyStorage *pPropSet;

    int PropId = 3;

    for (int type=0; type<2; type++)
    {
        BOOL fSimple = ( type == 0 || (g_Restrictions & RESTRICT_SIMPLE_ONLY) );

        UuidCreate(&fmtid);
        Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            fSimple ? PROPSETFLAG_DEFAULT : PROPSETFLAG_NONSIMPLE,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

        // create and delete each type.

        PROPVARIANT *pVar;

        for (int AtOnce=1; AtOnce <3; AtOnce++)
        {
            CGenProps gp;
            int Actual;
            while (pVar = gp.GetNext(AtOnce, &Actual, FALSE, fSimple ))
            {
                PROPSPEC ps[3];
                PROPID   rgpropid[3];
                LPOLESTR rglpostrName[3];
                OLECHAR  aosz[3][16];

                for (int s=0; s<3; s++)
                {
                    PROPGENPROPERTYNAME( &aosz[s][0], PropId );
                    rgpropid[s] = PropId++;
                    rglpostrName[s] = &aosz[s][0];
                    ps[s].ulKind = PRSPEC_LPWSTR;
                    ps[s].lpwstr = &aosz[s][0];
                }

                for (int l=1; l<Actual; l++)
                {
                    PROPVARIANT VarRead[3];
                    Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                    Check(S_OK, pPropSet->WritePropertyNames(l, rgpropid, rglpostrName));
                    Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));

                    Check(S_OK, pPropSet->WriteMultiple(l, ps, pVar, 1000));
                    Check(S_OK, pPropSet->ReadMultiple(l, ps, VarRead));
                    Check(S_OK, g_pfnFreePropVariantArray(l, VarRead));
                    Check(S_OK, pPropSet->DeleteMultiple(l, ps));

                    Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                    Check(S_OK, g_pfnFreePropVariantArray(l, VarRead));

                    LPOLESTR rglpostrNameCheck[3];
                    Check(S_OK, pPropSet->ReadPropertyNames(l, rgpropid, rglpostrNameCheck));
                    for (int c=0; c<l; c++)
                    {
                        Check( 0, ocscmp(rglpostrNameCheck[c], rglpostrName[c]) );
                        delete [] rglpostrNameCheck[c];
                    }
                    Check(S_OK, pPropSet->DeletePropertyNames(l, rgpropid));
                    Check(S_FALSE, pPropSet->ReadPropertyNames(l, rgpropid, rglpostrNameCheck));
                }

                g_pfnFreePropVariantArray(Actual, pVar);
                delete pVar;
            }
        }
        pPropSet->Release();
    }

    RELEASE_INTERFACE(pPropSetStg);
}

void
test_IPropertyStorage(IStorage *pStorage)
{
    test_IPropertyStorage_Access(pStorage);
    test_IPropertyStorage_Create(pStorage);
    test_IPropertyStorage_Stat(pStorage);
    test_IPropertyStorage_ReadMultiple(pStorage);
    test_IPropertyStorage_WriteMultiple(pStorage);
    test_IPropertyStorage_DeleteMultiple(pStorage);
}





//
//   Word6.0 summary information
//      Open
//      Read fields
//      Stat
//


void test_Word6(IStorage *pStorage, CHAR *pszTemporaryDirectory)
{

    Status( "Word 6.0 compatibility test\n" );

    extern unsigned char g_achTestDoc[];
    extern unsigned g_cbTestDoc;

    OLECHAR oszTempFile[ MAX_PATH + 1 ];
    CHAR    szTempFile[ MAX_PATH + 1 ];

    strcpy( szTempFile, pszTemporaryDirectory );
    strcat( szTempFile, "word6.doc" );

    PropTest_mbstoocs( oszTempFile, sizeof(oszTempFile), szTempFile );
    PROPTEST_FILE_HANDLE hFile = PropTest_CreateFile( szTempFile );

#ifdef _MAC
    Check(TRUE, (PROPTEST_FILE_HANDLE) -1 != hFile);
#else
    Check(TRUE, INVALID_HANDLE_VALUE != hFile);
#endif

    DWORD cbWritten;


    PropTest_WriteFile(hFile, g_achTestDoc, g_cbTestDoc, &cbWritten);
    Check(TRUE, cbWritten == g_cbTestDoc);

    PropTest_CloseHandle(hFile);

    IStorage *pStg;
    Check(S_OK, g_pfnStgOpenStorageEx(oszTempFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pStg) ));

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pStg);
    IPropertyStorage *pPropStg;

    ULONG cStorageRefs = GetRefCount( pStg );
    Check( S_OK, StgToPropSetStg( pStg, &pPropSetStg ));
    Check(S_OK, pPropSetStg->Open(FMTID_SummaryInformation,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READ,
                    &pPropStg));

#define WORDPROPS 18

    static struct tagWordTest {
        VARENUM vt;
        void *pv;
    } avt[WORDPROPS] = {
        VT_LPSTR, "Title of the document.",    // PID_TITLE
        VT_LPSTR, "Subject of the document.",  // PID_SUBJECT
        VT_LPSTR, "Author of the document.",   // PID_AUTHOR
        VT_LPSTR, "Keywords of the document.", // PID_KEYWORDS
        VT_LPSTR, "Comments of the document.", // PID_COMMENTS
        VT_LPSTR, "Normal.dot",                // PID_TEMPLATE -- Normal.dot
        VT_LPSTR, "Bill Morel",                // PID_LASTAUTHOR --
        VT_LPSTR, "3",                         // PID_REVNUMBER -- '3'
        VT_EMPTY, 0,                           // PID_EDITTIME -- 3 Minutes FILETIME
        VT_EMPTY, 0,                           // PID_LASTPRINTED -- 04/07/95 12:04 FILETIME
        VT_EMPTY, 0,                           // PID_CREATE_DTM
        VT_EMPTY, 0,                           // PID_LASTSAVE_DTM
        VT_I4, (void*) 1,                      // PID_PAGECOUNT
        VT_I4, (void*) 7,                      // PID_WORDCOUNT
        VT_I4, (void*) 65,                     // PID_CHARCOUNT
        VT_EMPTY, 0,                           // PID_THUMBNAIL
        VT_LPSTR, "Microsoft Word 6.0",        // PID_APPNAME
        VT_I4, 0  };                           // PID_SECURITY

    PROPSPEC propspec[WORDPROPS+2];

    for (int i=2; i<WORDPROPS+2; i++)
    {
        propspec[i].ulKind = PRSPEC_PROPID;
        propspec[i].propid = (PROPID)i;
    }

    PROPVARIANT propvar[WORDPROPS+2];

    Check(S_OK, pPropStg->ReadMultiple(WORDPROPS, propspec+2, propvar+2));

    for (i=2; i<WORDPROPS+2; i++)
    {
        if ( propvar[i].vt != avt[i-2].vt )
        {
            PRINTF( " PROPTEST: 0x%x retrieved type 0x%x, expected type 0x%x\n",
                    i, propvar[i].vt, avt[i-2].vt );
            Check(TRUE, propvar[i].vt == avt[i-2].vt);
        }

        switch (propvar[i].vt)
        {
        case VT_LPSTR:
            Check(TRUE, strcmp(propvar[i].pszVal, (char*)avt[i-2].pv)==0);
            break;
        case VT_I4:
            Check(TRUE, (ULONG_PTR) propvar[i].lVal == (ULONG_PTR)avt[i-2].pv);
            break;
        }
    }

    g_pfnFreePropVariantArray( WORDPROPS, propvar+2 );

    RELEASE_INTERFACE( pPropStg );
    RELEASE_INTERFACE( pPropSetStg );
    Check( 0, RELEASE_INTERFACE(pStg) );
}


void
test_IEnumSTATPROPSTG(IStorage *pstgTemp)
{
    Status( "IEnumSTATPROPSTG\n" );

    PROPID apropid[8];
    LPOLESTR alpostrName[8];
    OLECHAR aosz[8][32];
    PROPID PropId=2;
    PROPSPEC ps[8];

    FMTID fmtid;
    IPropertyStorage *pPropStg;

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pstgTemp);

    ULONG cStorageRefs = GetRefCount( pstgTemp );
    Check( S_OK, StgToPropSetStg( pstgTemp, &pPropSetStg ));
    UuidCreate(&fmtid);

    for (int setup=0; setup<8; setup++)
    {
        alpostrName[setup] = &aosz[setup][0];
    }


    CGenProps gp;

    // simple/non-simple, ansi/wide, named/not named
    for (int outer=0; outer<8; outer++)
    {
        UuidCreate(&fmtid);

        Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            ((outer&4) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_NONSIMPLE : 0)
            |
            ((outer&2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : 0),
            STGM_CREATE | STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropStg));


        for (int i=0; i<CPROPERTIES; i++)
        {
            apropid[i] = PropId++;
            if (outer & 1)
            {
                ps[i].ulKind = PRSPEC_LPWSTR;
                PROPGENPROPERTYNAME( aosz[i], apropid[i] );
                ps[i].lpwstr = aosz[i];
            }
            else
            {
                ps[i].ulKind = PRSPEC_PROPID;
                ps[i].propid = apropid[i];
            }
        }

        if (outer & 1)
        {
            Check(S_OK, pPropStg->WritePropertyNames(CPROPERTIES, apropid, alpostrName));
        }

        PROPVARIANT *pVar = gp.GetNext(CPROPERTIES, NULL, TRUE, (outer&4)==0);  // no non-simple
        Check(TRUE, pVar != NULL);

        Check(S_OK, pPropStg->WriteMultiple(CPROPERTIES, ps, pVar, 1000));
        g_pfnFreePropVariantArray(CPROPERTIES, pVar);
        delete pVar;

        // Allocate enough STATPROPSTGs for one more than the actual properties
        // in the set.

        STATPROPSTG StatBuffer[CPROPERTIES+1];
        ULONG celt;
        IEnumSTATPROPSTG *penum, *penum2;

        Check(S_OK, pPropStg->Enum(&penum));

        IUnknown *punk, *punk2;
        IEnumSTATPROPSTG *penum3;
        Check(S_OK, penum->QueryInterface(IID_IUnknown, (void**)&punk));
        Check(S_OK, punk->QueryInterface(IID_IEnumSTATPROPSTG, (void**)&penum3));
        Check(S_OK, penum->QueryInterface(IID_IEnumSTATPROPSTG, (void**)&punk2));
        Check(TRUE, punk == punk2);
        punk->Release();
        penum3->Release();
        punk2->Release();

        // test S_FALSE
        Check(S_FALSE, penum->Next( CPROPERTIES+1, StatBuffer, &celt));
        Check(TRUE, celt == CPROPERTIES);

        CleanStat(celt, StatBuffer);

        penum->Reset();


        // test reading half out, then cloning, then comparing
        // rest of enumeration with other clone.

        Check(S_OK, penum->Next(CPROPERTIES/2, StatBuffer, &celt));
        Check(TRUE, celt == CPROPERTIES/2);
        CleanStat(celt, StatBuffer);
        celt = 0;
        Check(S_OK, penum->Clone(&penum2));
        Check(S_OK, penum->Next(CPROPERTIES - CPROPERTIES/2, StatBuffer, &celt));
        Check(TRUE, celt == CPROPERTIES - CPROPERTIES/2);
        // check the clone
        for (int c=0; c<CPROPERTIES - CPROPERTIES/2; c++)
        {
            STATPROPSTG CloneStat;
            Check(S_OK, penum2->Next(1, &CloneStat, NULL));
            Check(TRUE, IsEqualSTATPROPSTG(&CloneStat, StatBuffer+c));
            CleanStat(1, &CloneStat);
        }

        CleanStat(celt, StatBuffer);

        // check both empty
        celt = 0;
        Check(S_FALSE, penum->Next(1, StatBuffer, &celt));
        Check(TRUE, celt == 0);

        Check(S_FALSE, penum2->Next(1, StatBuffer, &celt));
        Check(TRUE, celt == 0);

        penum->Reset();

        //
        // loop deleting one property at a time
        // enumerate the propertys checking that correct ones appear.
        //
        for (ULONG d = 0; d<CPROPERTIES; d++)
        {
            // d is for delete

            BOOL afFound[CPROPERTIES];
            ULONG cTotal = 0;

            Check(S_OK, penum->Next(CPROPERTIES-d, StatBuffer, &celt));
            Check(TRUE, celt == CPROPERTIES-d);
            penum->Reset();

            memset(afFound, 0, sizeof(afFound));

            for (ULONG iProperty=0; iProperty<CPROPERTIES; iProperty++)
            {

                // Search the StatBuffer for this property.

                for (ULONG iSearch=0; iSearch<CPROPERTIES-d; iSearch++)
                {

                    // Compare this entry in the StatBuffer to the property for which we're searching.
                    // Use the lpstrName or propid, whichever is appropriate for this pass (indicated
                    // by 'outer').

                    if ( ( (outer & 1) == 1 && 0 == ocscmp(StatBuffer[iSearch].lpwstrName, ps[iProperty].lpwstr) )
                         ||
                         ( (outer & 1) == 0 && StatBuffer[iSearch].propid == apropid[iProperty] )
                       )
                    {
                        ASSERT (!afFound[iSearch]);
                        afFound[iSearch] = TRUE;
                        cTotal++;
                        break;
                    }
                }
            }

            CleanStat(celt, StatBuffer);

            Check(TRUE, cTotal == CPROPERTIES-d);

            Check(S_OK, pPropStg->DeleteMultiple(1, ps+d));
            Check(S_OK, penum->Reset());
        }

        penum->Release();
        penum2->Release();

        pPropStg->Release();

    }

    RELEASE_INTERFACE( pPropSetStg );
    Check( cStorageRefs, GetRefCount(pstgTemp) );
}

void
test_MaxPropertyName(IStorage *pstgTemp)
{

    if( PROPIMP_NTFS == g_enumImplementation ) return;
    Status( "Max Property Name length\n" );

    //  ----------
    //  Initialize
    //  ----------

    CPropVariant cpropvar;

    // Create a new storage, because we're going to create
    // well-known property sets, and this way we can be sure
    // that they don't already exist.

    IStorage *pstg = NULL; // TSafeStorage< IStorage > pstg;

    Check(S_OK, pstgTemp->CreateStorage( OLESTR("MaxPropNameTest"),
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0L, 0L,
                                         &pstg ));

    // Generate a new Format ID.

    FMTID fmtid;
    UuidCreate(&fmtid);

    // Get a IPropertySetStorage from the IStorage.

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pstg);
    IPropertyStorage *pPropStg = NULL; // TSafeStorage< IPropertyStorage > pPropStg;
    Check( S_OK, StgToPropSetStg( pstg, &pPropSetStg ));

    //  ----------------------------------
    //  Test the non-SumInfo property set.
    //  ----------------------------------

    // Create a new PropertyStorage.

    Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));

    // Generate a property name which greater than the old max length
    // (NT5 removes the name length limitation, was 255 not including the terminator).

    OLECHAR *poszPropertyName;
    poszPropertyName = new OLECHAR[ (CCH_MAXPROPNAMESZ+1) * sizeof(OLECHAR) ];
    Check(TRUE, poszPropertyName != NULL );

    for( ULONG ulIndex = 0; ulIndex < CCH_MAXPROPNAMESZ; ulIndex++ )
        poszPropertyName[ ulIndex ] = OLESTR('a') + (OLECHAR) ( ulIndex % 26 );
    poszPropertyName[ CCH_MAXPROPNAMESZ ] = OLESTR('\0');


    // Write out a property with this oldmax+1 name.

    PROPSPEC propspec;

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = poszPropertyName;

    cpropvar = (long) 0x1234;

    Check(S_OK, pPropStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a minimum-character name.

    propspec.lpwstr = OLESTR("X");
    Check(S_OK, pPropStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a below-minimum-character name.

    propspec.lpwstr = OLESTR("");
    Check(STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    delete [] poszPropertyName;

    Check( 0, RELEASE_INTERFACE(pPropStg ));
    RELEASE_INTERFACE(pPropSetStg);
    Check( 0, RELEASE_INTERFACE(pstg) );

}

void
test_CodePages( LPOLESTR poszDirectory )
{

    if( g_Restrictions & RESTRICT_UNICODE_ONLY ) return;
    Status( "Code Page compatibility\n" );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR oszBadFile[ MAX_PATH ];
    OLECHAR oszGoodFile[ MAX_PATH ];
    OLECHAR oszUnicodeFile[ MAX_PATH ];
    OLECHAR oszMacFile[ MAX_PATH ];
    HRESULT hr = S_OK;

    IStorage *pStgBad = NULL, *pStgGood = NULL, *pStgUnicode = NULL, *pStgMac = NULL; // TSafeStorage< IStorage > pStgBad, pStgGood, pStgUnicode, pStgMac;
    CPropVariant cpropvarWrite, cpropvarRead;

    Check( TRUE, GetACP() == CODEPAGE_DEFAULT );

    //  ------------------------------
    //  Create test ANSI property sets
    //  ------------------------------

    // Create a property set with a bad codepage.

    ocscpy( oszBadFile, poszDirectory );
    ocscat( oszBadFile, OLESTR( "\\BadCP.stg" ));
    CreateCodePageTestFile( oszBadFile, &pStgBad );
    ModifyPropSetCodePage( pStgBad, FMTID_NULL, CODEPAGE_BAD );

    // Create a property set with a good codepage.

    ocscpy( oszGoodFile, poszDirectory );
    ocscat( oszGoodFile, OLESTR("\\GoodCP.stg") );
    CreateCodePageTestFile( oszGoodFile, &pStgGood );
    ModifyPropSetCodePage( pStgGood, FMTID_NULL, CODEPAGE_GOOD );


    // Create a property set that has the OS Kind (in the
    // header) set to "Mac".

    ocscpy( oszMacFile, poszDirectory );
    ocscat( oszMacFile, OLESTR("\\MacKind.stg") );
    CreateCodePageTestFile( oszMacFile, &pStgMac );
    ModifyOSVersion( pStgMac, 0x00010904 );

    //  ---------------------------
    //  Open the Ansi property sets
    //  ---------------------------


    IPropertySetStorage *pPropSetStgBad = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgBad(pStgBad);
    Check( S_OK, StgToPropSetStg( pStgBad, &pPropSetStgBad ));

    IPropertySetStorage *pPropSetStgGood = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgGood(pStgGood);
    Check( S_OK, StgToPropSetStg( pStgGood, &pPropSetStgGood ));

    IPropertySetStorage *pPropSetStgMac = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgMac(pStgMac);
    Check( S_OK, StgToPropSetStg( pStgMac, &pPropSetStgMac ));

    IPropertyStorage *pPropStgBad = NULL, *pPropStgGood = NULL, *pPropStgMac = NULL;

    Check(S_OK, pPropSetStgBad->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgBad));

    Check(S_OK, pPropSetStgGood->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgGood));

    Check(S_OK, pPropSetStgMac->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgMac));

    //  ------------------------------------------
    //  Test BSTRs in the three ANSI property sets
    //  ------------------------------------------

    PROPSPEC propspec;
    PROPVARIANT propvar;
    PropVariantInit( &propvar );

    // Attempt to read by name.

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = CODEPAGE_TEST_NAMED_PROPERTY;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(
        HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
#endif

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write by name.  If this test fails, it may be because
    // the machine doesn't support CODEPAGE_GOOD (this is the case by default
    // on Win95).  To remedy this situation, go to control panel, add/remove
    // programs, windows setup (tab), check MultiLanguage support, then
    // click OK.  You'll have to restart the computer after this.

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
#endif

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );

    // Attempt to read the BSTR property

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_BSTR_PROPID;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
#endif

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write the BSTR property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
#endif

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );

    // Attempt to read the BSTR Vector property

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VBSTR_PROPID;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
#endif

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write the BSTR Vector property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
#endif
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );

    // Attempt to read the Variant Vector which has a BSTR

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VPROPVAR_BSTR_PROPID;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
#endif

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write the Variant Vector which has a BSTR

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

#ifndef OLE2ANSI  // No error is generated if BSTRs are Ansi
    Check(HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION),
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
#endif

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );

    // Attempt to read the I4 property.  Reading the bad property set
    // takes special handling, because it will return a different result
    // depending on whether NTDLL is checked or free (the free will work,
    // the checked generates an error in its validation checking).

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 4;

    Check(S_OK,
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    g_pfnPropVariantClear( &propvar );

    hr = pPropStgBad->ReadMultiple( 1, &propspec, &propvar );
    Check(TRUE, S_OK == hr || HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) == hr );
    g_pfnPropVariantClear( &propvar );

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));

    // Attempt to write the I4 property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

    hr = pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE );
    Check(TRUE, S_OK == hr || HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) == hr );

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    g_pfnPropVariantClear( &propvar );


    //  ---------------------------------------
    //  Test LPSTRs in the Unicode property set
    //  ---------------------------------------

    // This test doesn't verify that the LPSTRs are actually
    // written in Unicode.  A manual test is required for that.

    // Create a Unicode property set.  We'll make it
    // non-simple so that we can test a VT_STREAM (which
    // is stored like an LPSTR).

    ocscpy( oszUnicodeFile, poszDirectory );
    ocscat( oszUnicodeFile, OLESTR("\\UnicodCP.stg") );

    Check(S_OK, g_pfnStgCreateStorageEx(oszUnicodeFile,
                                   STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                   DetermineStgFmt( g_enumImplementation ),
                                   0, NULL, NULL,
                                   DetermineStgIID( g_enumImplementation ),
                                   reinterpret_cast<void**>(&pStgUnicode) ));

    IPropertySetStorage *pPropSetStgUnicode = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgUnicode(pStgUnicode);
    Check( S_OK, StgToPropSetStg( pStgUnicode, &pPropSetStgUnicode ));

    IPropertyStorage *pPropStgUnicode = NULL; // TSafeStorage< IPropertyStorage > pPropStgUnicode;

    Check(S_OK, pPropSetStgUnicode->Create(FMTID_NULL,
                                           &CLSID_NULL,
                                           PROPSETFLAG_NONSIMPLE,
                                           STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                           &pPropStgUnicode));


    // Write/verify an LPSTR property.

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = OLESTR("LPSTR Property");

    cpropvarWrite = "An LPSTR Property";

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, &cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, &cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite, (LPSTR) cpropvarRead ));
    cpropvarRead.Clear();

    // Write/verify a vector of LPSTR properties

    propspec.lpwstr = OLESTR("Vector of LPSTR properties");

    cpropvarWrite[1] = "LPSTR Property #1";
    cpropvarWrite[0] = "LPSTR Property #0";

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, &cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, &cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite[1], (LPSTR) cpropvarRead[1] ));
    Check(0, strcmp( (LPSTR) cpropvarWrite[0], (LPSTR) cpropvarRead[0] ));
    cpropvarRead.Clear();

    // Write/verify a vector of variants which has an LPSTR

    propspec.lpwstr = OLESTR("Variant Vector with an LPSTR");

    cpropvarWrite[1] = (PROPVARIANT) CPropVariant("LPSTR in a Variant Vector");
    cpropvarWrite[0] = (PROPVARIANT) CPropVariant((long) 22); // an I4
    Check(TRUE,  (VT_VECTOR | VT_VARIANT) == cpropvarWrite.VarType() );

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, &cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, &cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite[1], (LPSTR) cpropvarRead[1] ));
    cpropvarRead.Clear();

    // Write/verify a Stream.

    cpropvarWrite = (IStream*) NULL;
    propspec.lpwstr = OLESTR("An IStream");

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, &cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, &cpropvarRead ));
    cpropvarRead.Clear();

    // There's nothing more we can check for the VT_STREAM property, a manual
    // check is required to verify that it was written correctly.

    RELEASE_INTERFACE(pStgBad);
    RELEASE_INTERFACE(pStgGood);
    RELEASE_INTERFACE(pStgUnicode);
    RELEASE_INTERFACE(pStgMac);
    RELEASE_INTERFACE(pPropSetStgBad);
    RELEASE_INTERFACE(pPropStgBad);
    RELEASE_INTERFACE(pPropStgGood);
    RELEASE_INTERFACE(pPropStgMac);
    RELEASE_INTERFACE(pPropSetStgGood);
    RELEASE_INTERFACE(pPropSetStgMac);
    RELEASE_INTERFACE(pPropSetStgUnicode);
    RELEASE_INTERFACE(pPropStgUnicode);

}

void
test_PropertyInterfaces(IStorage *pstgTemp)
{
    Status( "Property Interface\n" );
    g_nIndent++;

    // this test depends on being first for enumerator
    test_IEnumSTATPROPSETSTG(pstgTemp);

    test_MaxPropertyName(pstgTemp);
    test_IPropertyStorage(pstgTemp);
    test_IPropertySetStorage(pstgTemp);
    test_IEnumSTATPROPSTG(pstgTemp);

    --g_nIndent;
}


//===================================================================
//
//  Function:   test_CopyTo
//
//  Synopsis:   Verify that IStorage::CopyTo copies an
//              un-flushed property set.
//
//              This test creates and writes to a simple property set,
//              a non-simple property set, and a new Storage & Stream,
//              all within the source (caller-provided) Storage.
//
//              It then copies the entire source Storage to the
//              destination Storage, and verifies that all commited
//              data in the Source is also in the destination.
//
//              All new Storages and property sets are created
//              under a new base storage.  The caller can specify
//              if this base Storage is direct or transacted, and
//              can specify if the property sets are direct or
//              transacted.
//
//===================================================================

void test_CopyTo(IStorage *pstgSource,          // Source of the CopyTo
                 IStorage *pstgDestination,     // Destination of the CopyTo
                 ULONG ulBaseStgTransaction,    // Transaction bit for the base storage.
                 ULONG ulPropSetTransaction,    // Transaction bit for the property sets.
                 LPOLESTR oszBaseStorageName )
{
    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;

    char szMessage[ 128 ];

    sprintf( szMessage, "IStorage::CopyTo (Base Storage is %s, PropSets are %s)\n",
                        ulBaseStgTransaction & STGM_TRANSACTED ? "transacted" : "direct",
                        ulPropSetTransaction & STGM_TRANSACTED ? "transacted" : "direct" );
    Status( szMessage );


    //  ---------------
    //  Local Variables
    //  ---------------

    OLECHAR const *poszTestSubStorage     = OLESTR( "TestStorage" );
    OLECHAR const *poszTestSubStream      = OLESTR( "TestStream" );
    OLECHAR const *poszTestDataPreCommit  = OLESTR( "Test Data (pre-commit)" );
    OLECHAR const *poszTestDataPostCommit = OLESTR( "Test Data (post-commit)" );

    long lSimplePreCommit = 0x0123;
    long lSimplePostCommit = 0x4567;

    long lNonSimplePreCommit  = 0x89AB;
    long lNonSimplePostCommit = 0xCDEF;

    BYTE acReadBuffer[ 80 ];
    ULONG cbRead;

    FMTID fmtidSimple, fmtidNonSimple;

    // Base Storages for the Source & Destination.  All
    // new Streams/Storages/PropSets will be created below here.

    IStorage *pstgBaseSource = NULL;
    IStorage *pstgBaseDestination = NULL;

    IStorage *pstgSub = NULL;   // A sub-storage of the base.
    IStream *pstmSub = NULL;    // A Stream in the sub-storage (pstgSub)

    PROPSPEC propspec;
    PROPVARIANT propvarSourceSimple,
                propvarSourceNonSimple,
                propvarDestination;


    //  -----
    //  Begin
    //  -----

    // Create new format IDs

    UuidCreate(&fmtidSimple);
    UuidCreate(&fmtidNonSimple);

    //  -----------------------
    //  Create the base Storage
    //  -----------------------

    // Create a base Storage for the Source.  All of this test will be under
    // that Storage.

    // In the source Storage.

    Check( S_OK, pstgSource->CreateStorage(
                                oszBaseStorageName,
                                STGM_CREATE | ulBaseStgTransaction | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgBaseSource ));


    // And in the destination Storage.

    Check( S_OK, pstgDestination->CreateStorage(
                                oszBaseStorageName,
                                STGM_CREATE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgBaseDestination ));



    //  -------------------------------------------
    //  Write data to a new Stream in a new Storage
    //  -------------------------------------------

    // We'll partially verify the CopyTo by checking that this data
    // makes it into the destination Storage.


    // Create a Storage, and then a Stream within it.

    Check( S_OK, pstgBaseSource->CreateStorage(
                                poszTestSubStorage,
                                STGM_CREATE | ulPropSetTransaction | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgSub ));

    Check( S_OK, pstgSub->CreateStream(
                            poszTestSubStream,
                            STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0L, 0L,
                            &pstmSub ));

    // Write data to the Stream.

    Check( S_OK, pstmSub->Write(
                    poszTestDataPreCommit,
                    ( sizeof(OLECHAR)
                      *
                      (ocslen( poszTestDataPreCommit ) + sizeof(OLECHAR))
                    ),
                    NULL ));


    //  ---------------------------------------------------------
    //  Write to a new simple property set in the Source storage.
    //  ---------------------------------------------------------

    IPropertySetStorage *pPropSetStgSource = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgSource(pstgBaseSource);
    Check( S_OK, StgToPropSetStg( pstgBaseSource, &pPropSetStgSource ));

    IPropertyStorage *pPropStgSource1 = NULL, *pPropStgSource2 = NULL, *pPropStgDestination = NULL;

    // Create a property set mode.

    Check(S_OK, pPropSetStgSource->Create(fmtidSimple,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropStgSource1));

    // Write the property set name (just to test this functionality).

    PROPID pidDictionary = 0;
    OLECHAR *poszPropSetName = OLESTR("Property Set for CopyTo Test");
    Check(TRUE,  CWC_MAXPROPNAMESZ >= ocslen(poszPropSetName) + sizeof(OLECHAR) );

    Check(S_OK, pPropStgSource1->WritePropertyNames( 1, &pidDictionary, &poszPropSetName ));

    // Create a PROPSPEC.  We'll use this throughout the rest of the routine.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 1000;

    // Create a PROPVARIANT for this test of the Simple case.

    propvarSourceSimple.vt = VT_I4;
    propvarSourceSimple.lVal = lSimplePreCommit;

    // Write the PROPVARIANT to the property set.

    Check(S_OK, pPropStgSource1->WriteMultiple(1, &propspec, &propvarSourceSimple, 2));


    //  ---------------------------------------------------------------
    //  Write to a new *non-simple* property set in the Source storage.
    //  ---------------------------------------------------------------


    // Create a property set.

    Check(S_OK, pPropSetStgSource->Create(fmtidNonSimple,
            NULL,
            PROPSETFLAG_NONSIMPLE,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | ulPropSetTransaction | STGM_READWRITE,
            &pPropStgSource2));

    // Set data in the PROPVARIANT for the non-simple test.

    propvarSourceNonSimple.vt = VT_I4;
    propvarSourceNonSimple.lVal = lNonSimplePreCommit;

    // Write the PROPVARIANT to the property set.

    Check(S_OK, pPropStgSource2->WriteMultiple(1, &propspec, &propvarSourceNonSimple, 2));


    //  -------------------------
    //  Commit everything so far.
    //  -------------------------

    // Commit the sub-Storage.
    Check(S_OK, pstgSub->Commit( STGC_DEFAULT ));

    // Commit the simple property set.
    Check(S_OK, pPropStgSource1->Commit( STGC_DEFAULT ));

    // Commit the non-simple property set.
    Check(S_OK, pPropStgSource2->Commit( STGC_DEFAULT ));

    // Commit the base Storage which holds all of the above.
    Check(S_OK, pstgBaseSource->Commit( STGC_DEFAULT ));


    //  -------------------------------------------------
    //  Write new data to everything but don't commit it.
    //  -------------------------------------------------

    // Write to the sub-storage.
    Check(S_OK, pstmSub->Seek(g_li0, STREAM_SEEK_SET, NULL));
    Check( S_OK, pstmSub->Write(
                    poszTestDataPostCommit,
                    ( sizeof(OLECHAR)
                      *
                      (ocslen( poszTestDataPostCommit ) + sizeof(OLECHAR))
                    ),
                    NULL ));


    // Write to the simple property set.
    propvarSourceSimple.lVal = lSimplePostCommit;
    Check(S_OK, pPropStgSource1->WriteMultiple(1, &propspec, &propvarSourceSimple, 2));

    // Write to the non-simple property set.
    propvarSourceNonSimple.lVal = lNonSimplePostCommit;
    Check(S_OK, pPropStgSource2->WriteMultiple(1, &propspec, &propvarSourceNonSimple, PID_FIRST_USABLE ));


    //  -------------------------------------------
    //  Copy the source Storage to the destination.
    //  -------------------------------------------

    // Release the sub-Storage (which is below the base Storage, and has
    // a Stream with data in it), just to test that the CopyTo can
    // handle it.

    pstgSub->Release();
    pstgSub = NULL;

    Check(S_OK, pstgBaseSource->CopyTo( 0, NULL, NULL, pstgBaseDestination ));


    //  ----------------------------------------------------------
    //  Verify the simple property set in the destination Storage.
    //  ----------------------------------------------------------


    IPropertySetStorage *pPropSetStgDestination = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStgDestination(pstgBaseDestination);
    Check( S_OK, StgToPropSetStg( pstgBaseDestination, &pPropSetStgDestination ));

    // Open the simple property set.

    Check(S_OK, pPropSetStgDestination->Open(fmtidSimple,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropStgDestination));

    // Verify the property set name.

    OLECHAR *poszPropSetNameDestination;
    BOOL   bReadPropertyNamePassed = FALSE;

    Check(S_OK, pPropStgDestination->ReadPropertyNames( 1, &pidDictionary,
                                                        &poszPropSetNameDestination ));
    if( poszPropSetNameDestination  // Did we get a name back?
        &&                          // If so, was it the correct name?
        !ocscmp( poszPropSetName, poszPropSetNameDestination )
      )
    {
        bReadPropertyNamePassed = TRUE;
    }
    delete [] poszPropSetNameDestination;
    poszPropSetNameDestination = NULL;

    Check( TRUE, bReadPropertyNamePassed );

    // Read the PROPVARIANT that we wrote earlier.

    Check(S_OK, pPropStgDestination->ReadMultiple(1, &propspec, &propvarDestination));

    // Verify that it's correct.

    Check(TRUE, propvarDestination.vt   == propvarSourceSimple.vt );
    Check(TRUE, propvarDestination.lVal == lSimplePostCommit);

    Check(S_OK, pPropStgDestination->Commit( STGC_DEFAULT ));
    Check(S_OK, pPropStgDestination->Release());
    pPropStgDestination = NULL;


    //  ----------------------------------------------------------------
    //  Verify the *non-simple* property set in the destination Storage.
    //  ----------------------------------------------------------------

    // Open the non-simple property set.

    Check(S_OK,
          pPropSetStgDestination->Open(fmtidNonSimple,
                STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &pPropStgDestination));

    // Read the PROPVARIANT that we wrote earlier.

    Check(S_OK, pPropStgDestination->ReadMultiple(1, &propspec, &propvarDestination));

    // Verify that they're the same.

    Check(TRUE, propvarDestination.vt   == propvarSourceNonSimple.vt );

    Check(TRUE, propvarDestination.lVal
                ==
                ( STGM_TRANSACTED & ulPropSetTransaction
                  ?
                  lNonSimplePreCommit
                  :
                  lNonSimplePostCommit
                ));

    Check(S_OK, pPropStgDestination->Commit( STGC_DEFAULT ));
    Check(S_OK, pPropStgDestination->Release());
    pPropStgDestination = NULL;

    //  ------------------------------------------------
    //  Verify the test data in the destination Storage.
    //  ------------------------------------------------

    // Now we can release and re-use the Stream pointer that
    // currently points to the sub-Stream in the source docfile.

    Check(STG_E_REVERTED, pstmSub->Commit( STGC_DEFAULT ));
    Check(S_OK, pstmSub->Release());
    pstmSub = NULL;

    // Get the Storage then the Stream.

    Check( S_OK, pstgBaseDestination->OpenStorage(
                                poszTestSubStorage,
                                NULL,
                                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
                                NULL,
                                0L,
                                &pstgSub ));

    Check( S_OK, pstgSub->OpenStream(
                            poszTestSubStream,
                            NULL,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0L,
                            &pstmSub ));

    // Read the data and compare it against what we wrote.

    Check( S_OK, pstmSub->Read(
                    acReadBuffer,
                    sizeof( acReadBuffer ),
                    &cbRead ));

    OLECHAR const *poszTestData = ( STGM_TRANSACTED & ulPropSetTransaction )
                                  ?
                                  poszTestDataPreCommit
                                  :
                                  poszTestDataPostCommit;

    Check( TRUE, cbRead == sizeof(OLECHAR)
                           *
                           (ocslen( poszTestData ) + sizeof(OLECHAR))
         );

    Check( FALSE, ocscmp( poszTestData, (OLECHAR *) acReadBuffer ));


    //  ----
    //  Exit
    //  ----

    RELEASE_INTERFACE( pPropSetStgSource );
    RELEASE_INTERFACE(pPropStgSource1);
    RELEASE_INTERFACE(pPropStgSource2);
    RELEASE_INTERFACE(pPropStgDestination);
    RELEASE_INTERFACE(pPropSetStgDestination);

    RELEASE_INTERFACE(pstgBaseSource);
    RELEASE_INTERFACE(pstgBaseDestination);

    RELEASE_INTERFACE(pstgSub);
    RELEASE_INTERFACE(pstmSub);

    // We're done.  Don't bother to release anything;
    // they'll release themselves in their destructors.

    return;

}   // test_CopyTo()



//--------------------------------------------------------
//
//  Function:   test_OLESpecTickerExample
//
//  Synopsis:   This function generates the ticker property set
//              example that's used in the OLE Programmer's Reference
//              (when describing property ID 0 - the dictionary).
//
//--------------------------------------------------------


#define PID_SYMBOL  0x7
#define PID_OPEN    0x3
#define PID_CLOSE   0x4
#define PID_HIGH    0x5
#define PID_LOW     0x6
#define PID_LAST    0x8
#define PID_VOLUME  0x9

void test_OLESpecTickerExample( IStorage* pstg )
{
    Status( "Generate the Stock Ticker example from the OLE Programmer's Ref\n" );

    //  ------
    //  Locals
    //  ------

    FMTID fmtid;

    PROPSPEC propspec;

    LPOLESTR oszPropSetName = OLESTR( "Stock Quote" );

    LPOLESTR oszTickerSymbolName = OLESTR( "Ticker Symbol" );
    LPOLESTR oszOpenName   = OLESTR( "Opening Price" );
    LPOLESTR oszCloseName  = OLESTR( "Last Closing Price" );
    LPOLESTR oszHighName   = OLESTR( "High Price" );
    LPOLESTR oszLowName    = OLESTR( "Low Price" );
    LPOLESTR oszLastName   = OLESTR( "Last Price" );
    LPOLESTR oszVolumeName = OLESTR( "Volume" );

    //  ---------------------------------
    //  Create a new simple property set.
    //  ---------------------------------

    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg(pstg);
    IPropertyStorage *pPropStg;

    ULONG cStorageRefs = GetRefCount( pstg );
    Check( S_OK, StgToPropSetStg( pstg, &pPropSetStg ));
    UuidCreate( &fmtid );

    Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            PROPSETFLAG_DEFAULT,    // Unicode
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));


    //  ---------------------------------------------
    //  Fill in the simply property set's dictionary.
    //  ---------------------------------------------

    // Write the property set's name.

    PROPID pidDictionary = 0;
    Check(S_OK, pPropStg->WritePropertyNames(1, &pidDictionary, &oszPropSetName ));

    // Write the High price, forcing the dictionary to pad.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_HIGH;

    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszHighName ));


    // Write the ticker symbol.

    propspec.propid = PID_SYMBOL;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszTickerSymbolName));

    // Write the rest of the dictionary.

    propspec.propid = PID_LOW;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszLowName));

    propspec.propid = PID_OPEN;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszOpenName));

    propspec.propid = PID_CLOSE;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszCloseName));

    propspec.propid = PID_LAST;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszLastName));

    propspec.propid = PID_VOLUME;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &oszVolumeName));


    // Write out the ticker symbol.

    propspec.propid = PID_SYMBOL;

    PROPVARIANT propvar;
    propvar.vt = VT_LPWSTR;
    propvar.pwszVal = L"MSFT";

    Check(S_OK, pPropStg->WriteMultiple(1, &propspec, &propvar, 2));


    //  ----
    //  Exit
    //  ----

    Check(S_OK, pPropStg->Commit( STGC_DEFAULT ));
    Check(0, pPropStg->Release());
    Check(S_OK, pstg->Commit( STGC_DEFAULT ));
    RELEASE_INTERFACE( pPropSetStg );
    Check( cStorageRefs, GetRefCount(pstg) );

    return;


}  // test_OLESpecTickerExample()


void
test_Office( LPOLESTR wszTestFile )
{
    Status( "Generate Office Property Sets\n" );

    IStorage *pStg = NULL;
    IPropertyStorage *pPStgSumInfo=NULL, *pPStgDocSumInfo=NULL, *pPStgUserDefined=NULL;
    IPropertySetStorage *pPSStg = NULL; // TSafeStorage<IPropertySetStorage> pPSStg;

    PROPVARIANT propvarWrite, propvarRead;
    PROPSPEC    propspec;

    PropVariantInit( &propvarWrite );
    PropVariantInit( &propvarRead );

    // Create the file

    Check( S_OK, g_pfnStgCreateStorageEx( wszTestFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertySetStorage,
                                     (void**) &pPSStg ));

    // Create the SummaryInformation property set.

    Check(S_OK, pPSStg->Create( FMTID_SummaryInformation,
                                NULL,
                                (g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgSumInfo ));

    // Write a Title to the SumInfo property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_LPSTR;
    propvarWrite.pszVal = "Title from PropTest";
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_TITLE;

    Check( S_OK, pPStgSumInfo->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgSumInfo->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( FALSE, strcmp( propvarWrite.pszVal, propvarRead.pszVal ));

    g_pfnPropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgSumInfo->Release();
    pPStgSumInfo = NULL;


    // Create the DocumentSummaryInformation property set.

    Check(S_OK, pPSStg->Create( FMTID_DocSummaryInformation,
                                NULL,
                                (g_Restrictions & RESTRICT_UNICODE_ONLY ) ? PROPSETFLAG_DEFAULT: PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgDocSumInfo ));

    // Write a word-count to the DocSumInfo property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_I4;
    propvarWrite.lVal = 100;
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_WORDCOUNT;

    Check( S_OK, pPStgDocSumInfo->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgDocSumInfo->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( TRUE, propvarWrite.lVal == propvarRead.lVal );

    g_pfnPropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgDocSumInfo->Release();
    pPStgDocSumInfo = NULL;


    // Create the UserDefined property set.

    Check(S_OK, pPSStg->Create( FMTID_UserDefinedProperties,
                                NULL,
                                (g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgUserDefined ));

    // Write named string to the UserDefined property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_LPSTR;
    propvarWrite.pszVal = "User-Defined string from PropTest";
    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = OLESTR("PropTest String");

    Check( S_OK, pPStgUserDefined->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgUserDefined->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( FALSE, strcmp( propvarWrite.pszVal, propvarRead.pszVal ));

    g_pfnPropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgUserDefined->Release();
    pPStgUserDefined = NULL;

    RELEASE_INTERFACE(pPSStg);

    // And we're done!  (Everything releases automatically)

    return;

}


void
test_Office2(IStorage *pStorage)
{
    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;
    Status( "Testing Office Property Sets\n" );

    IStorage *pSubStorage = NULL; // TSafeStorage< IStorage > pSubStorage;
    IPropertySetStorage *pPropSetStg = NULL; // TSafeStorage< IPropertySetStorage > pPropSetStg;
    IPropertyStorage *pPropStg = NULL; // TSafeStorage< IPropertyStorage > pPropStg;
    CPropSpec cpropspec;

    //  ----------------------------------
    //  Create a sub-storage for this test
    //  ----------------------------------

    Check(S_OK, pStorage->CreateStorage( OLESTR("test_Office2"),
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0, 0, &pSubStorage ));

    Check(S_OK, StgToPropSetStg( pSubStorage, &pPropSetStg ));


    //  --------------------------------------------------------
    //  Test the Create/Delete of the DocumentSummaryInformation
    //  property set (this requires special code because it
    //  has two sections).
    //  --------------------------------------------------------

    // Create & Delete a DSI propset with just the first section.

    Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));

    pPropStg->Release(); pPropStg = NULL;
    Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));

    // Create & Delete a DSI propset with just the second section

    Check(S_OK, pPropSetStg->Create(FMTID_UserDefinedProperties,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg ));

    pPropStg->Release(); pPropStg = NULL;
    Check(S_OK, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
    Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));


    //  --------------------------------------------
    //  Test the Create/Open of the DSI property set
    //  --------------------------------------------

    // Create & Delete a DocumentSummaryInformation propset with both sections.
    // If you delete the DSI propset first, it should delete both sections.
    // If you delete the UD propset first, the DSI propset should still
    // remain.  We'll loop twice, trying both combinations.

    for( int i = 0; i < 2; i++ )
    {

        // Create the first section.

        Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
                NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &pPropStg));
        pPropStg->Release(); pPropStg = NULL;

        // Create the second section.

        Check(S_OK, pPropSetStg->Create(FMTID_UserDefinedProperties,
                NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &pPropStg));
        pPropStg->Release(); pPropStg = NULL;

        if( i == 0 )
        {
            // Delete the second section, then the first.
            Check(S_OK, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
            Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));
        }
        else
        {
            // Delete the first section, then *attempt* to delete the second.
            Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));
            Check(STG_E_FILENOTFOUND, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
        }
    }   // for( i = 0; i < 2; i++ )

    //  ------------------------------------------------------------------
    //  Verify that we can create the UD propset (the 2nd section) without
    //  harming the first section.
    //  ------------------------------------------------------------------

    {
        CPropSpec rgcpropspec[2];
        CPropVariant rgcpropvarWrite[2];
        CPropVariant cpropvarRead;

        // Create the first section.

        Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
                        NULL,
                        PROPSETFLAG_DEFAULT,
                        STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                        &pPropStg));

        // Write a property to the first section.

        rgcpropspec[0] = OLESTR("Test DSI Property");
        rgcpropvarWrite[0] = (DWORD) 1;
        Check(S_OK, pPropStg->WriteMultiple( 1, rgcpropspec[0], &rgcpropvarWrite[0],
                                             PID_FIRST_USABLE ));
        pPropStg->Release(); pPropStg = NULL;

        // *Create* the second section

        Check(S_OK, pPropSetStg->Create(FMTID_UserDefinedProperties,
                        NULL,
                        PROPSETFLAG_DEFAULT,
                        STGM_SHARE_EXCLUSIVE | STGM_READWRITE | STGM_CREATE,
                        &pPropStg ));

        // Write a property to the second section

        rgcpropspec[1] = OLESTR("Test UD Property");
        rgcpropvarWrite[1] = (DWORD) 2;
        Check(S_OK, pPropStg->WriteMultiple( 1, rgcpropspec[1], &rgcpropvarWrite[1],
                                             PID_FIRST_USABLE ));
        pPropStg->Release(); pPropStg = NULL;

        // Verify the properties from each of the sections.

        Check(S_OK, pPropSetStg->Open(FMTID_DocSummaryInformation,
                        STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                        &pPropStg ));
        Check(S_OK, pPropStg->ReadMultiple( 1, rgcpropspec[0], &cpropvarRead ));
        Check(TRUE, rgcpropvarWrite[0] == cpropvarRead );
        cpropvarRead.Clear();
        pPropStg->Release(); pPropStg = NULL;

        Check(S_OK, pPropSetStg->Open(FMTID_UserDefinedProperties,
                        STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                        &pPropStg ));
        Check(S_OK, pPropStg->ReadMultiple( 1, rgcpropspec[1], &cpropvarRead ));
        Check(TRUE, rgcpropvarWrite[1] == cpropvarRead );
        cpropvarRead.Clear();
        pPropStg->Release(); pPropStg = NULL;
    }

    //  -------------------------------------
    //  Test special properties in DocSumInfo
    //  -------------------------------------

    // This verifies that when we Create a DocSumInfo
    // property set, and write a Vector or LPSTRs,
    // we can read it again.  We test this because
    // Vectors of LPSTRs are a special case in the DocSumInfo,
    // and the Create & Open path are slightly different
    // in CPropertySetStream::_LoadHeader.

    // Create a new property set.

    Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));

    // Create a vector of LPSTRs.  Make the strings
    // varying lengths to ensure we get plenty of
    // opportunity for alignment problems.

    CPropVariant cpropvarWrite, cpropvarRead;

    cpropvarWrite[3] = "12345678";
    cpropvarWrite[2] = "1234567";
    cpropvarWrite[1] = "123456";
    cpropvarWrite[0] = "12345";
    Check(TRUE,  cpropvarWrite.Count() == 4 );

    // Write the property

    cpropspec = OLESTR("A Vector of LPSTRs");

    Check(S_OK, pPropStg->WriteMultiple( 1, cpropspec, &cpropvarWrite, 2 ));

    // Read the property back.

    Check(S_OK, pPropStg->ReadMultiple( 1, cpropspec, &cpropvarRead ));

    // Verify that we read what we wrote.

    for( i = 0; i < (int) cpropvarWrite.Count(); i++ )
    {
        Check(0, strcmp( (LPSTR) cpropvarWrite[i], (LPSTR) cpropvarRead[i] ));
    }

    //  ----
    //  Exit
    //  ----

    RELEASE_INTERFACE(pSubStorage);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pPropStg);

    return;
}



void test_PropVariantCopy( )
{
    Status( "PropVariantCopy\n" );

    PROPVARIANT propvarCopy;
    PropVariantInit( &propvarCopy );

    VERSIONEDSTREAM VersionedStream;
    UuidCreate( &VersionedStream.guidVersion );
    VersionedStream.pStream = NULL;

    for( int i = 0; i < CPROPERTIES_ALL; i++ )
    {
        Check(S_OK, g_pfnPropVariantCopy( &propvarCopy, &g_rgcpropvarAll[i] )); // g_pfnPropVariantCopy( &propvarCopy, &g_rgcpropvarAll[i] ));
        Check(S_OK, CPropVariant::Compare( &propvarCopy, &g_rgcpropvarAll[i] ));
        g_pfnPropVariantClear( &propvarCopy );

        // If this is a stream, take the opportunity to do a test of vt_versioned_stream.
        if( VT_STREAM == g_rgcpropvarAll[i].vt )
        {
            VersionedStream.pStream = g_rgcpropvarAll[i].pStream;
            CPropVariant cpropvar = VersionedStream;
            Check( S_OK, g_pfnPropVariantCopy( &propvarCopy, &cpropvar ));
            Check( S_OK, CPropVariant::Compare( &propvarCopy, &cpropvar ));
            g_pfnPropVariantClear( &propvarCopy );
        }

    }
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

}



#define PERFORMANCE_ITERATIONS      300
#define STABILIZATION_ITERATIONS    10

void
test_Performance( IStorage *pStg )
{
//#ifndef _MAC

    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;
    Status( "Performance\n" );

    CPropVariant rgcpropvar[2];
    CPropSpec    rgpropspec[2];

    IPropertySetStorage *pPSStg = NULL; // TSafeStorage< IPropertySetStorage > pPSStg( pStg );
    Check( S_OK, StgToPropSetStg( pStg, &pPSStg ));

    IPropertyStorage *pPStg = NULL; // TSafeStorage< IPropertyStorage > pPStg;
    IStream *pStm = NULL; // TSafeStorage< IStream > pStm;

    FMTID fmtid;
    ULONG ulCount;
    DWORD dwSumTimes;
    FILETIME filetimeStart, filetimeEnd;

    BYTE  *pPropertyBuffer;
    ULONG cbPropertyBuffer;

    UuidCreate( &fmtid );

    rgcpropvar[0][0] = L"I wish I were an Oscar Meyer wiener,";
    rgcpropvar[0][1] = L"That is what I'd truly like to be.";
    rgcpropvar[1][0] = "For if I were an Oscar Meyer wiener,";
    rgcpropvar[1][1] = "Everyone would be in love with me.";

    Check(TRUE,  (VT_LPWSTR | VT_VECTOR) == rgcpropvar[0].VarType() );
    Check(TRUE,  (VT_LPSTR  | VT_VECTOR) == rgcpropvar[1].VarType() );


    //  ----------------
    //  Test an IStorage
    //  ----------------

    // Create a buffer to write which is the same size as
    // the properties in rgcpropvar.

    cbPropertyBuffer =  sizeof(WCHAR)
                        *
                        (2 + wcslen(rgcpropvar[0][0]) + wcslen(rgcpropvar[0][1]));

    cbPropertyBuffer += (2 + strlen(rgcpropvar[1][0]) + strlen(rgcpropvar[1][1]));

    pPropertyBuffer = new BYTE[ cbPropertyBuffer ];

    PRINTF( "        Docfile CreateStream/Write/Release = " );
    dwSumTimes = 0;

    // Perform the test iterations

    for( ulCount = 0;
         ulCount < PERFORMANCE_ITERATIONS + STABILIZATION_ITERATIONS;
         ulCount++ )
    {
        if( ulCount == STABILIZATION_ITERATIONS )
            CoFileTimeNow( &filetimeStart );

        Check(S_OK, pStg->CreateStream(  OLESTR("StoragePerformance"),
                                         STGM_CREATE | STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0L, 0L,
                                         &pStm ));

        Check(S_OK, pStm->Write( pPropertyBuffer, cbPropertyBuffer, NULL ));
        pStm->Release(); pStm = NULL;

    }

    CoFileTimeNow( &filetimeEnd );
    filetimeEnd -= filetimeStart;
    PRINTF( "%4.2f ms\n", (float)filetimeEnd.dwLowDateTime
                          /
                          10000 // # of 100 nanosec units in 1 ms
                          /
                          PERFORMANCE_ITERATIONS );

    //  ------------------------------------------------------
    //  Try Creating a Property Set and writing two properties
    //  ------------------------------------------------------

    rgpropspec[0] = OLESTR("First Property");
    rgpropspec[1] = OLESTR("Second Property");

    PRINTF( "        PropSet Create(Overwrite)/WriteMultiple/Release = " );
    dwSumTimes = 0;

    for( ulCount = 0;
         ulCount < PERFORMANCE_ITERATIONS + STABILIZATION_ITERATIONS;
         ulCount++ )
    {
        if( ulCount == STABILIZATION_ITERATIONS )
            CoFileTimeNow( &filetimeStart) ;

        Check(S_OK, pPSStg->Create( fmtid,
                                    NULL,
                                    PROPSETFLAG_DEFAULT | PROPSETFLAG_NONSIMPLE,
                                    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    &pPStg ));

        Check(S_OK, pPStg->WriteMultiple( 2, rgpropspec, rgcpropvar, PID_FIRST_USABLE ));
        pPStg->Release(); pPStg = NULL;

    }

    CoFileTimeNow( &filetimeEnd );
    filetimeEnd -= filetimeStart;
    PRINTF( "%4.2f ms\n", (float)filetimeEnd.dwLowDateTime
                          /
                          10000     // 100 ns units to 1 ms units
                          /
                          PERFORMANCE_ITERATIONS );



    //  ------------------------------------------------------
    //  WriteMultiple (with named properties) Performance Test
    //  ------------------------------------------------------


    PRINTF( "        WriteMultiple (named properties) = " );

    Check(S_OK, pPSStg->Create( fmtid,
                                NULL,
                                PROPSETFLAG_DEFAULT | PROPSETFLAG_NONSIMPLE,
                                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));

    for( ulCount = 0;
         ulCount < PERFORMANCE_ITERATIONS + STABILIZATION_ITERATIONS;
         ulCount++ )
    {
        if( ulCount == STABILIZATION_ITERATIONS )
            CoFileTimeNow( &filetimeStart );

        for( int i = 0; i < CPROPERTIES_ALL; i++ )
        {
            Check(S_OK, pPStg->WriteMultiple( 1, &g_rgcpropspecAll[i], &g_rgcpropvarAll[i], PID_FIRST_USABLE ));
        }
        Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    }

    CoFileTimeNow( &filetimeEnd );
    filetimeEnd -= filetimeStart;
    PRINTF( "%4.2f ms\n", (float) filetimeEnd.dwLowDateTime
                          /
                          10000 // 100 ns units to 1 ms units
                          /
                          PERFORMANCE_ITERATIONS );

    pPStg->Release();
    pPStg = NULL;


    //  --------------------------------------------------------
    //  WriteMultiple (with unnamed properties) Performance Test
    //  --------------------------------------------------------


    {
        CPropSpec rgcpropspecPIDs[ CPROPERTIES_ALL ];

        PRINTF( "        WriteMultiple (unnamed properties) = " );

        Check(S_OK, pPSStg->Create( fmtid,
                                    NULL,
                                    PROPSETFLAG_DEFAULT | PROPSETFLAG_NONSIMPLE,
                                    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    &pPStg ));

        for( ulCount = 0; ulCount < CPROPERTIES_ALL; ulCount++ )
        {
            rgcpropspecPIDs[ ulCount ] = ulCount + PID_FIRST_USABLE;
        }


        for( ulCount = 0;
             ulCount < PERFORMANCE_ITERATIONS + STABILIZATION_ITERATIONS;
             ulCount++ )
        {
            if( ulCount == STABILIZATION_ITERATIONS )
                CoFileTimeNow( &filetimeStart );

            for( int i = 0; i < CPROPERTIES_ALL; i++ )
            {
                Check(S_OK, pPStg->WriteMultiple( 1, &rgcpropspecPIDs[i], &g_rgcpropvarAll[i], PID_FIRST_USABLE ));
            }
            Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
        }

        CoFileTimeNow( &filetimeEnd );
        filetimeEnd -= filetimeStart;
        PRINTF( "%4.2f ms\n", (float) filetimeEnd.dwLowDateTime
                              /
                              10000 // 100 ns units to 1 ms units
                              /
                              PERFORMANCE_ITERATIONS );

        pPStg->Release();
        pPStg = NULL;
    }

//#endif // #ifndef _MAC

}   // test_Performance()




//
//  Function:   test_CoFileTimeNow
//
//  This function has nothing to do with the property set code,
//  but a property test happenned to expose a bug in it, so this
//  was just as good a place as any to test the fix.
//


void
test_CoFileTimeNow()
{
#ifndef _MAC    // No need to test this on the Mac, and we can't
                // because it doesn't support SYSTEMTIME.

    Status( "CoFileTimeNow " );

    FILETIME    ftCoFileTimeNow;
    FILETIME    ftCalculated;
    SYSTEMTIME  stCalculated;


    // Test the input validation

    Check(E_INVALIDARG, CoFileTimeNow( NULL ));
    Check(E_INVALIDARG, CoFileTimeNow( (FILETIME*) 0x01234567 ));


    // The bug in CoFileTimeNow caused it to report a time that was
    // 900 ms short, 50% of the time.  So let's just bounds check
    // it several times as a verification.

    for( int i = 0; i < 20; i++ )
    {
        Check(S_OK, CoFileTimeNow( &ftCoFileTimeNow ));
        GetSystemTime(&stCalculated);
        Check(TRUE, SystemTimeToFileTime(&stCalculated, &ftCalculated));
        Check(TRUE, ftCoFileTimeNow <= ftCalculated );

        Check(S_OK, CoFileTimeNow( &ftCoFileTimeNow ));
        Check(TRUE, ftCoFileTimeNow >= ftCalculated );

        // The CoFileTimeNow bug caused it to report the correct
        // time for a second, then the 900 ms short time for a second.
        // So let's sleep in this loop and ensure that we cover both
        // seconds.

        if( g_fVerbose )
            PRINTF( "." );

        Sleep(200);
    }
    PRINTF( "\n" );

#endif  // #ifndef _MAC

}


void
test_PROPSETFLAG_UNBUFFERED( IStorage *pStg )
{
    //  ----------
    //  Initialize
    //  ----------

    if( PROPIMP_DOCFILE_OLE32 != g_enumImplementation
        &&
        PROPIMP_DOCFILE_IPROP != g_enumImplementation )
        return;

    Status( "PROPSETFLAG_UNBUFFERED\n" );

    IStorage *pStgBase = NULL;
    IPropertyStorage *pPropStgUnbuffered = NULL, *pPropStgBuffered = NULL;
    IStream *pstmUnbuffered = NULL, *pstmBuffered = NULL;

    CPropSpec cpropspec;
    CPropVariant cpropvar;

    FMTID fmtidUnbuffered, fmtidBuffered;
    OLECHAR oszPropStgNameUnbuffered[ CCH_MAX_PROPSTG_NAME+1 ],
            oszPropStgNameBuffered[ CCH_MAX_PROPSTG_NAME+1 ];

    // Generate two FMTIDs

    UuidCreate( &fmtidUnbuffered );
    UuidCreate( &fmtidBuffered );

    //  ----------------------------
    //  Create the Property Storages
    //  ----------------------------

    // Create a transacted Storage

    Check( S_OK, pStg->CreateStorage(
                        OLESTR("test_PROPSETFLAG_UNBUFFERED"),
                        STGM_CREATE | STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        0L, 0L,
                        &pStgBase ));

    // Verify that we have the necessary APIs

    Check( TRUE, g_pfnFmtIdToPropStgName && g_pfnPropStgNameToFmtId
                 && g_pfnStgCreatePropSetStg && g_pfnStgCreatePropStg
                 && g_pfnStgOpenPropStg );

    // What are the property storages' stream names?

    g_pfnFmtIdToPropStgName( &fmtidUnbuffered, oszPropStgNameUnbuffered );
    g_pfnFmtIdToPropStgName( &fmtidBuffered,   oszPropStgNameBuffered );

    // Create Streams for the property storages

    Check( S_OK, pStgBase->CreateStream(
                                oszPropStgNameUnbuffered,
                                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0L, 0L,
                                &pstmUnbuffered ));

    Check( S_OK, pStgBase->CreateStream(
                                oszPropStgNameBuffered,
                                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0L, 0L,
                                &pstmBuffered ));


    // Create two direct-mode IPropertyStorages (one buffered, one not)

    Check( S_OK, g_pfnStgCreatePropStg( (IUnknown*) pstmUnbuffered,
                                        fmtidUnbuffered,
                                        &CLSID_NULL,
                                        PROPSETFLAG_UNBUFFERED,
                                        0L, // Reserved
                                        &pPropStgUnbuffered ));
    pPropStgUnbuffered->Commit( STGC_DEFAULT );
    pstmUnbuffered->Release(); pstmUnbuffered = NULL;

    Check( S_OK, g_pfnStgCreatePropStg( (IUnknown*) pstmBuffered,
                                        fmtidBuffered,
                                        &CLSID_NULL,
                                        PROPSETFLAG_DEFAULT,
                                        0L, // Reserved
                                        &pPropStgBuffered ));
    pPropStgBuffered->Commit( STGC_DEFAULT );
    pstmBuffered->Release(); pstmBuffered = NULL;


    //  -------------------------
    //  Write, Commit, and Revert
    //  -------------------------

    // Write to both property storages

    cpropvar = "A Test String";
    cpropspec = OLESTR("Property Name");

    Check( S_OK, pPropStgUnbuffered->WriteMultiple( 1,
                                                    cpropspec,
                                                    &cpropvar,
                                                    PID_FIRST_USABLE ));

    Check( S_OK, pPropStgBuffered->WriteMultiple( 1,
                                                  cpropspec,
                                                  &cpropvar,
                                                  PID_FIRST_USABLE ));

    // Commit the base Storage.  This should only cause
    // the Unbuffered property to be commited.

    pStgBase->Commit( STGC_DEFAULT );

    // Revert the base Storage, and release the property storages.
    // This should cause the property in the buffered property storage
    // to be lost.

    pStgBase->Revert();
    pPropStgUnbuffered->Release(); pPropStgUnbuffered = NULL;
    pPropStgBuffered->Release(); pPropStgBuffered = NULL;

    //  -----------------------------
    //  Re-Open the property storages
    //  -----------------------------

    // Open the property storage Streams

    Check( S_OK, pStgBase->OpenStream( oszPropStgNameUnbuffered,
                                       0L,
                                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                       0L,
                                       &pstmUnbuffered ));

    Check( S_OK, pStgBase->OpenStream( oszPropStgNameBuffered,
                                       0L,
                                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                       0L,
                                       &pstmBuffered ));

    // Get IPropertyStorage interfaces

    Check( S_OK, g_pfnStgOpenPropStg( (IUnknown*) pstmUnbuffered,
                                      fmtidUnbuffered,
                                      PROPSETFLAG_UNBUFFERED,
                                      0L, // Reserved
                                      &pPropStgUnbuffered ));
    pstmUnbuffered->Release(); pstmUnbuffered = NULL;

    Check( S_OK, g_pfnStgOpenPropStg( (IUnknown*) pstmBuffered,
                                      fmtidBuffered,
                                      PROPSETFLAG_DEFAULT,
                                      0L, // Reserved
                                      &pPropStgBuffered ));
    pstmBuffered->Release(); pstmBuffered = NULL;


    //  --------------------
    //  Validate the results
    //  --------------------

    // We should only find the property in the un-buffered property set.

    cpropvar.Clear();
    Check( S_OK, pPropStgUnbuffered->ReadMultiple( 1, cpropspec, &cpropvar ));
    cpropvar.Clear();
    Check( S_FALSE, pPropStgBuffered->ReadMultiple( 1, cpropspec, &cpropvar ));
    cpropvar.Clear();


}   // test_PROPSETFLAG_UNBUFFERED()


void
test_PropStgNameConversion2()
{
    Status( "FmtIdToPropStgName & PropStgNameToFmtId\n" );

    //  ------
    //  Locals
    //  ------

    FMTID fmtidOriginal, fmtidNew;
    OLECHAR oszPropStgName[ CCH_MAX_PROPSTG_NAME+1 ];

    //  ----------------------------------
    //  Do a simple conversion and inverse
    //  ----------------------------------

    UuidCreate( &fmtidOriginal );
    fmtidNew = FMTID_NULL;

    Check( S_OK, g_pfnFmtIdToPropStgName( &fmtidOriginal, oszPropStgName ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));

    Check( TRUE, fmtidOriginal == fmtidNew );

    //  -----------------------
    //  Check the special-cases
    //  -----------------------

    // Summary Information

    Check( S_OK, g_pfnFmtIdToPropStgName( &FMTID_SummaryInformation, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszSummaryInformation ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, FMTID_SummaryInformation == fmtidNew );

    // DocSumInfo (first section)

    Check( S_OK, g_pfnFmtIdToPropStgName( &FMTID_DocSummaryInformation, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszDocSummaryInformation ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, FMTID_DocSummaryInformation == fmtidNew );

    // DocSumInfo (second section)

    Check( S_OK, g_pfnFmtIdToPropStgName( &FMTID_UserDefinedProperties, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszDocSummaryInformation ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, FMTID_DocSummaryInformation == fmtidNew );

    // GlobalInfo (for PictureIt!)

    Check( S_OK, g_pfnFmtIdToPropStgName( &fmtidGlobalInfo, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszGlobalInfo ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, fmtidGlobalInfo == fmtidNew );

    // ImageContents (for PictureIt!)

    Check( S_OK, g_pfnFmtIdToPropStgName( &fmtidImageContents, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszImageContents ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, fmtidImageContents == fmtidNew );

    // ImageInfo (for PictureIt!)

    Check( S_OK, g_pfnFmtIdToPropStgName( &fmtidImageInfo, oszPropStgName ));
    Check( 0, ocscmp( oszPropStgName, oszImageInfo ));
    Check( S_OK, g_pfnPropStgNameToFmtId( oszPropStgName, &fmtidNew ));
    Check( TRUE, fmtidImageInfo == fmtidNew );


}   // test_PropStgNameConversion()

void
test_PropStgNameConversion( IStorage *pStg )
{
    if( g_Restrictions & RESTRICT_NON_HIERARCHICAL ) return;
    Status( "Special-case property set names\n" );

    //  ------
    //  Locals
    //  ------

    IStorage *pStgSub = NULL;
    IPropertyStorage *pPropStg = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    IEnumSTATSTG *pEnumStg = NULL;
    IEnumSTATPROPSETSTG *pEnumPropSet = NULL;

    STATSTG rgstatstg[ NUM_WELL_KNOWN_PROPSETS ];
    STATPROPSETSTG rgstatpropsetstg[ NUM_WELL_KNOWN_PROPSETS ];
    UINT i;
    DWORD cEnum;

    BOOL bSumInfo= FALSE,
         bDocSumInfo= FALSE,
         bGlobalInfo= FALSE,
         bImageContents= FALSE,
         bImageInfo= FALSE;


    //  ------------------------------
    //  Create a Storage for this test
    //  ------------------------------

    Check( S_OK, pStg->CreateStorage( OLESTR("Special Cases"),
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      0, 0,
                                      &pStgSub ));

    // And get an IPropertySetStorage

    Check( S_OK, StgToPropSetStg( pStgSub, &pPropSetStg ));


    //  --------------------------------------------------
    //  Create one of each of the well-known property sets
    //  --------------------------------------------------

    Check( S_OK, pPropSetStg->Create( FMTID_SummaryInformation,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( FMTID_DocSummaryInformation,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( FMTID_UserDefinedProperties,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( fmtidGlobalInfo,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( fmtidImageContents,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );

    Check( S_OK, pPropSetStg->Create( fmtidImageInfo,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    RELEASE_INTERFACE( pPropStg );


    //  ---------------------------------
    //  Verify the FMTID->Name conversion
    //  ---------------------------------

    // We verify this by enumerating the Storage's streams,
    // and checking for the expected names (e.g., we should see
    // "SummaryInformation", "DocumentSummaryInformation", etc.)

    Check( S_OK, pStgSub->EnumElements( 0, NULL, 0, &pEnumStg ));

    // Get all of the names.

    Check( S_FALSE, pEnumStg->Next( NUM_WELL_KNOWN_PROPSETS,
                                    rgstatstg,
                                    &cEnum ));

    // There should only be WellKnown-1 stream names, since
    // the UserDefined property set is part of the
    // DocumentSummaryInformation stream.

    Check( TRUE, cEnum == NUM_WELL_KNOWN_PROPSETS - 1 );


    for( i = 0; i < cEnum; i++ )
    {
        if( !ocscmp( rgstatstg[i].pwcsName, oszSummaryInformation ))
            bSumInfo= TRUE;
        else if( !ocscmp( rgstatstg[i].pwcsName, oszDocSummaryInformation ))
            bDocSumInfo= TRUE;
        else if( !ocscmp( rgstatstg[i].pwcsName, oszGlobalInfo ))
            bGlobalInfo= TRUE;
        else if( !ocscmp( rgstatstg[i].pwcsName, oszImageContents ))
            bImageContents= TRUE;
        else if( !ocscmp( rgstatstg[i].pwcsName, oszImageInfo ))
            bImageInfo= TRUE;

        delete [] rgstatstg[i].pwcsName;
    }

    // Verify that we found all the names we expected to find.

    Check( TRUE, bSumInfo && bDocSumInfo
                 && bGlobalInfo && bImageContents && bImageInfo );


    RELEASE_INTERFACE( pEnumStg );

    //  ---------------------------------
    //  Verify the Name->FMTID Conversion
    //  ---------------------------------

    // We do this by enumerating the property sets with IPropertySetStorage,
    // and verify that it correctly converts the Stream names to the
    // expected FMTIDs.

    bSumInfo = bDocSumInfo = bGlobalInfo = bImageContents = bImageInfo = FALSE;

    // Get the enumerator.

    Check( S_OK, pPropSetStg->Enum( &pEnumPropSet ));

    // Get all the property sets.

    Check( S_FALSE, pEnumPropSet->Next( NUM_WELL_KNOWN_PROPSETS,
                                        rgstatpropsetstg,
                                        &cEnum ));
    Check( TRUE, cEnum == NUM_WELL_KNOWN_PROPSETS - 1 );


    // Look for each of the expected FMTIDs.  We only look at WellKnown-1,
    // because the UserDefined property set doesn't get enumerated.

    for( i = 0; i < NUM_WELL_KNOWN_PROPSETS - 1; i++ )
    {
        if( rgstatpropsetstg[i].fmtid == FMTID_SummaryInformation )
            bSumInfo = TRUE;
        else if( rgstatpropsetstg[i].fmtid == FMTID_DocSummaryInformation )
            bDocSumInfo = TRUE;
        else if( rgstatpropsetstg[i].fmtid == fmtidGlobalInfo )
            bGlobalInfo = TRUE;
        else if( rgstatpropsetstg[i].fmtid == fmtidImageContents )
            bImageContents = TRUE;
        else if( rgstatpropsetstg[i].fmtid == fmtidImageInfo )
            bImageInfo = TRUE;

    }

    // NOTE:  There is no way(?) to test the name-to-FMTID
    // conversion for the UserDefined property set without
    // calling the conversion function directly, but that
    // function isn't exported on Win95.


    // Verify that we found all of the expected FMTIDs

    Check( TRUE, bSumInfo && bDocSumInfo
                 && bGlobalInfo && bImageContents && bImageInfo );


    RELEASE_INTERFACE( pEnumPropSet );
    RELEASE_INTERFACE( pPropSetStg );
    RELEASE_INTERFACE( pStgSub );

}   // test_PropStgNameConversion()




//-----------------------------------------------------------------------------
//
//  Function:   test_SimpleLeaks
//
//  This is a simple leak test.  It doesn't test all functionality for
//  leaks; it just checks the common path:  create, open, read, write,
//  and delete.
//
//-----------------------------------------------------------------------------

void test_SimpleLeaks( LPOLESTR poszDir )
{
    IStorage *pStg = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    SYSTEM_PROCESS_INFORMATION spiStart, spiEnd;

    OLECHAR oszTempFile[ MAX_PATH + 1 ];

    ocscpy( oszTempFile, poszDir );
    ocscat( oszTempFile, OLESTR("SimpleLeakTest") );

    Status( "Simple Leak Test " );

    Check( STATUS_SUCCESS, GetProcessInfo(&spiStart) );

    for( long i = 0; i < 1*1000*1000; i++ )
    {
        if( i % (50*1000) == 0 )
            PRINTF( "x");

        CPropSpec rgpropspec[2];
        CPropVariant rgpropvarWrite[2], rgpropvarRead[2];

        IPropertyStorage *pPropStg = NULL;

        Check( S_OK, g_pfnStgCreateStorageEx( oszTempFile,
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE
                                         |
                                         ( ((i&1) && !(g_Restrictions & RESTRICT_DIRECT_ONLY)) ? STGM_TRANSACTED : STGM_DIRECT ),
                                         DetermineStgFmt( g_enumImplementation ),
                                         0L,
                                         NULL,
                                         NULL,
                                         IID_IPropertySetStorage,
                                         (void**) &pPropSetStg));

        Check( S_OK, pPropSetStg->Create( FMTID_NULL, NULL,
                                          ( (i&2) && !(g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_ANSI : PROPSETFLAG_DEFAULT )
                                          |
                                          ( (i&4) && !(g_Restrictions & RESTRICT_SIMPLE_ONLY)  ? PROPSETFLAG_NONSIMPLE : PROPSETFLAG_DEFAULT ),
                                          STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE
                                          |
                                          ( (i&8) && !(g_Restrictions & RESTRICT_DIRECT_ONLY)  ? STGM_TRANSACTED : STGM_DIRECT ),
                                          &pPropStg ));

        rgpropspec[0] = OLESTR("Property Name");
        rgpropspec[1] = 1000;

        rgpropvarWrite[0] = "Hello, world";
        rgpropvarWrite[1] = (ULONG) 23;

        Check( S_OK, pPropStg->WriteMultiple( 2, rgpropspec, rgpropvarWrite, PID_FIRST_USABLE ));
        Check( S_OK, pPropStg->Commit( STGC_DEFAULT ));
        Check( 0, pPropStg->Release() );

        Check( S_OK, pPropSetStg->Open( FMTID_NULL,
                                        ( (i&16) && !(g_Restrictions & RESTRICT_DIRECT_ONLY) ? STGM_TRANSACTED : STGM_DIRECT )
                                        |
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        &pPropStg ));

        Check( S_OK, pPropStg->ReadMultiple( 2, rgpropspec, rgpropvarRead ));

        Check( TRUE, rgpropvarRead[0] == rgpropvarWrite[0]
                     &&
                     rgpropvarRead[1] == rgpropvarWrite[1] );

        Check( S_OK, pPropStg->DeleteMultiple( 2, rgpropspec ));
        Check( S_OK, pPropStg->Commit( STGC_DEFAULT ));

        Check( 0, pPropStg->Release() );

        Check( S_OK, pPropSetStg->Delete( FMTID_NULL ));
        Check( 0, pPropSetStg->Release() );

    }

    Check( STATUS_SUCCESS, GetProcessInfo(&spiEnd) );

    if( g_fVerbose )
    {
        PRINTF( "\n" );
        PRINTF( "        process id %I64u\n", (ULONG_PTR) spiEnd.UniqueProcessId );
        PRINTF( "        threads %lu, %lu\n", spiStart.NumberOfThreads, spiEnd.NumberOfThreads );
        PRINTF( "        handles %lu, %lu\n", spiStart.HandleCount, spiEnd.HandleCount );
        PRINTF( "        virtual size %lu, %lu\n", spiStart.VirtualSize, spiEnd.VirtualSize );
        PRINTF( "        peak virtual size %lu, %lu\n", spiStart.PeakVirtualSize, spiEnd.PeakVirtualSize );
        PRINTF( "        working set %lu, %lu\n", spiStart.WorkingSetSize, spiEnd.WorkingSetSize );
        PRINTF( "        peak working set %lu, %lu\n", spiStart.PeakWorkingSetSize, spiEnd.PeakWorkingSetSize );
        PRINTF( "        pagefile usage %lu, %lu\n", spiStart.PagefileUsage, spiEnd.PagefileUsage );
        PRINTF( "        peak pagefile usage %lu, %lu\n", spiStart.PeakPagefileUsage, spiEnd.PeakPagefileUsage );
        PRINTF( "        private memory %lu, %lu\n", spiStart.PrivatePageCount, spiEnd.PrivatePageCount );
        PRINTF( "        quota paged pool %lu, %lu\n", spiStart.QuotaPagedPoolUsage, spiEnd.QuotaPagedPoolUsage );
        PRINTF( "        peak quota paged pool %lu, %lu\n", spiStart.QuotaPeakPagedPoolUsage, spiEnd.QuotaPeakPagedPoolUsage );
        PRINTF( "        quota non-paged pool %lu, %lu\n", spiStart.QuotaNonPagedPoolUsage, spiEnd.QuotaNonPagedPoolUsage );
        PRINTF( "        peak quota non-paged pool %lu, %lu\n", spiStart.QuotaPeakNonPagedPoolUsage, spiEnd.QuotaPeakNonPagedPoolUsage );
    }


    // Ensure that the working set and pagefile usage didn't change by
    // more than 5%

    ULONG ulWorkingSetDifference = spiEnd.WorkingSetSize > spiStart.WorkingSetSize
                                   ? spiEnd.WorkingSetSize - spiStart.WorkingSetSize
                                   : spiStart.WorkingSetSize - spiEnd.WorkingSetSize;

    ULONG ulPagefileUsageDifference = spiEnd.PagefileUsage > spiStart.PagefileUsage
                                      ? spiEnd.PagefileUsage - spiStart.PagefileUsage
                                      : spiStart.PagefileUsage - spiEnd.PagefileUsage;


    Check( TRUE,
                 ( ulWorkingSetDifference == 0
                   ||
                   spiStart.WorkingSetSize/ulWorkingSetDifference >= 20
                 )
                 &&
                 ( ulPagefileUsageDifference == 0
                   ||
                   spiStart.PagefileUsage/ulPagefileUsageDifference >= 20
                 )
         );

}   // test_SimpleLeaks

//-----------------------------------------------------------------------------
//
//  Function:   test_SimpleDocFile
//
//  This function tests PropSet functionality on Simple DocFile.
//  This test comes in multiple phases:
//  1)  A simple docfile is created and a minimal amount of data is stored
//      in it.
//  2)  The docfile is closed and opened again.  The test attempts to write
//      a small string to the property storage in it.  This should succeed.
//      Then it attempts to write a 4K string, which should fail.
//  3)  The docfile is closed and opened again.  The test writes 3 small
//      strings to the prop storage.  This should be successful.
//
//  4)  The docfile is deleted.  A new docfile with a property set storage is
//      created, and more than 4K data is written to it.
//  5)  The docfile is opened and writing additional data to it should fail.
//
//-----------------------------------------------------------------------------

#define FOUR_K_SIZE     0x1000      // Make it at least 4K.
#define THREE_H_SIZE    300         // 300 bytes
#define ONE_H_SIZE      100         // 100 bytes
void
test_SimpleDocFile(LPOLESTR oszDir)
{
    IStorage *pDfStg = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;

    OLECHAR         oszFile[MAX_PATH];
    CPropSpec       rgPropSpec[3];
    CPropVariant    rgPropVariant[3];
    LPSTR           pFourKString;
    int             i;

    if( RESTRICT_NON_HIERARCHICAL & g_Restrictions ) return;    // NFF doesn't support simp mode
    Status( "Simple-mode docfile\n" );

    //
    // Generate a filename from the directory name.
    //
    ocscpy( oszFile, oszDir );
    ocscat( oszFile, OLESTR( "SimpDoc.stg" ));

    //
    // allocate a buffer with 1 less than 4K
    // and fill it with characters.
    //
    pFourKString = new CHAR[ FOUR_K_SIZE ];
    Check(TRUE, pFourKString != NULL);

    pFourKString[0] = '\0';
    for (i=0; i < ((FOUR_K_SIZE/8)-1); i++)
    {
        strcat(pFourKString,"abcd1234");
    }
    strcat(pFourKString,"abcd123");

    rgPropSpec[0]  = 0x10;
    rgPropSpec[1]  = 0x11;
    rgPropSpec[2]  = 0x12;

    //-------------------
    // 1st Test - setup
    //-------------------
    // Create a Docfile.
    //
    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L, NULL, NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    // Test that we can QI between IStorage and IPropertySetStorage

    if( UsingQIImplementation() )
    {
        IStorage *pstg2 = NULL, *pstg3 = NULL;
        IPropertySetStorage *ppropsetstg2 = NULL, *ppropsetstg3 = NULL;
        ULONG cRefs = GetRefCount( pDfStg );

        Check( S_OK, pDfStg->QueryInterface( IID_IStorage, reinterpret_cast<void**>(&pstg2) ));
        Check( S_OK, pstg2->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&ppropsetstg2) ));
        Check( S_OK, ppropsetstg2->QueryInterface( IID_IStorage, reinterpret_cast<void**>(&pstg3) ));
        Check( TRUE, pstg2 == pstg3 );

        Check( S_OK, pstg3->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&ppropsetstg3) ));
        Check( TRUE, ppropsetstg2 == ppropsetstg3 );

        RELEASE_INTERFACE(ppropsetstg3);
        RELEASE_INTERFACE(ppropsetstg2);
        RELEASE_INTERFACE(pstg3);
        Check( cRefs, RELEASE_INTERFACE(pstg2) );
    }

    Check( S_OK, pPropSetStg->Create( FMTID_UserDefinedProperties,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    //
    // Write several strings to the property storage
    //
    rgPropVariant[0] = "Hello, world";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    rgPropVariant[0] = "New string for offset 0";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    rgPropVariant[1] = "First string for offset 1";
    Check(S_OK, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    //
    // Release the storages and docfile.
    //
    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //--------------
    // 2nd Test
    //--------------
    //
    // Now Open the DocFile and storages
    // and write a small stream followed by a 4K stream.
    //
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                 STGFMT_ANY,
                                 0L, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(FMTID_UserDefinedProperties,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    //
    // Write a small string followed by a string that is at least 4K.
    // The large string write should fail because the simple stream allocates
    // a minimum size stream of 4K, and on an Open will not allow the stream to
    // grow.
    //
    rgPropVariant[0] = "After Open, Hello, world";
    rgPropVariant[1] = pFourKString;
    rgPropVariant[2] = "Another string after the long one";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(STG_E_INVALIDFUNCTION, pPropStg->WriteMultiple(2, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(STG_E_INVALIDFUNCTION, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));


    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //--------------
    // 3rd Test
    //--------------
    //
    // Open the DocFile again, and write smaller strings to the same
    // location.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(FMTID_UserDefinedProperties,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    //
    // The smaller strings can be written because they fit in under the 4K
    // size of the simple stream buffer.
    //
    rgPropVariant[0] = "2nd open, small string";
    rgPropVariant[1] = "small string2";
    rgPropVariant[2] = "small string3";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(S_OK, pPropStg->WriteMultiple(2, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));
    Check(S_OK, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //---------------------------------
    // 4th Test - Create Large PropSet
    //---------------------------------
    //
    // Create a Docfile and fill with more than 4K.
    //
    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L, NULL, NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));


    Check( S_OK, pPropSetStg->Create( FMTID_NULL,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    rgPropSpec[0]  = 0x10;
    rgPropSpec[1]  = 0x11;
    rgPropSpec[2]  = 0x12;

    //
    // Write several strings to the property storage
    // The first one is a 4K string.
    //
    rgPropVariant[0] = pFourKString;
    rgPropVariant[1] = "First string for offset 1";
    rgPropVariant[2] = "small string3";
    Check(S_OK, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    //
    // Release the storages and docfile.
    //
    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //--------------
    // 5th Test
    //--------------
    //
    // Open the DocFile again, and write the same strings in a different
    // order.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(CLSID_NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    //
    // The smaller strings can be written because they fit in under the 4K
    // size of the simple stream buffer.
    //
    rgPropVariant[0] = "small string0";
    rgPropVariant[1] = "First string for offset 1";
    rgPropVariant[2] = pFourKString;
    Check(S_OK, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //--------------
    // 6th Test
    //--------------
    //
    // Open the DocFile again, and write larger strings to the same
    // location.  This should fail.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_SIMPLE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(CLSID_NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    //
    // Now write the same thing again, only with one extra character.
    // This should fail.
    //
    rgPropVariant[0] = "First string for offset 0";
    rgPropVariant[1] = pFourKString;
    rgPropVariant[2] = "small string00000";
    Check(STG_E_INVALIDFUNCTION, pPropStg->WriteMultiple(3, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    delete [] pFourKString;

    //--------------
    // 7th Test  - - A NON-SIMPLE MODE TEST
    //--------------
    //
    // Create and write to a property set with an element of 400 bytes.
    // Then delete 100 bytes.  Commit the changes.  The property set should
    // have shrunk by at least 100 bytes.
    //
    // allocate a buffer with 300 bytes and fill it.
    // and fill it with characters.
    //
    LPSTR           pThreeHString = NULL;
    LPSTR           pOneHString = NULL;

    //
    // Fill the 3 Hundred Byte String
    //
    pThreeHString = new CHAR[ THREE_H_SIZE ];
    Check(TRUE, pThreeHString != NULL);

    pThreeHString[0] = '\0';
    for (i=0; i < ((THREE_H_SIZE/8)-1); i++)
    {
        strcat(pThreeHString,"abcd1234");
    }
    strcat(pThreeHString,"abc");

    //
    // Fill the 1 Hundred Byte String
    //
    pOneHString = new CHAR[ ONE_H_SIZE ];
    Check(TRUE, pOneHString != NULL);

    pOneHString[0] = '\0';
    for (i=0; i < ((ONE_H_SIZE/8)-1); i++)
    {
        strcat(pOneHString,"xyxy8787");
    }
    strcat(pOneHString,"xyx");

    //
    // Create a Docfile and fill with the string
    //
    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0, NULL, NULL,
                                     DetermineStgIID( g_enumImplementation ),
                                     reinterpret_cast<void**>(&pDfStg) ));

    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));


    Check( S_OK, pPropSetStg->Create( FMTID_NULL,
                                      &CLSID_NULL,
                                      PROPSETFLAG_ANSI,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));
    rgPropSpec[0]  = 0x10;
    rgPropSpec[1]  = 0x11;

    //
    // Write the string to the property storage
    //
    rgPropVariant[0] = pThreeHString;
    rgPropVariant[1] = pOneHString;
    Check(S_OK, pPropStg->WriteMultiple(2, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    //
    // Commit the changes and close.
    //
    Check(S_OK, pPropStg->Commit( STGC_DEFAULT ));
    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //
    // Check the size of the property set.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    IStream *pStm;
    STATSTG StatBuf;
    OLECHAR ocsPropSetName[30];
    DWORD   cbStream;

    RtlGuidToPropertySetName(&FMTID_NULL, ocsPropSetName);
    Check(S_OK, pDfStg->OpenStream(
            ocsPropSetName,
            NULL,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            0,
            &pStm));


    Check(S_OK, pStm->Stat( &StatBuf,STATFLAG_NONAME));
    if (StatBuf.cbSize.HighPart != 0)
    {
        printf("FAILURE: test_SimpleDocFile: Test 7: Size High part is not zero\n");
    }
    cbStream = StatBuf.cbSize.LowPart;

    RELEASE_INTERFACE(pStm);

    //
    // Delete
    //
    Check(S_OK, StgToPropSetStg( pDfStg, &pPropSetStg ));

    Check(S_OK, pPropSetStg->Open(CLSID_NULL,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

    Check(S_OK, pPropStg->DeleteMultiple(1, &rgPropSpec[1]));

    //
    // Commit the changes and close.
    //
    Check(S_OK, pPropStg->Commit( STGC_DEFAULT ));
    RELEASE_INTERFACE(pPropStg);
    RELEASE_INTERFACE(pPropSetStg);
    RELEASE_INTERFACE(pDfStg);

    //
    // Check the size of the property set.
    //
    Check(S_OK, g_pfnStgOpenStorageEx(oszFile,
                                 STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                 STGFMT_ANY,
                                 0, NULL, NULL,
                                 IID_IStorage,
                                 reinterpret_cast<void**>(&pDfStg) ));

    RtlGuidToPropertySetName(&FMTID_NULL, ocsPropSetName);
    Check(S_OK, pDfStg->OpenStream(
            ocsPropSetName,
            NULL,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            0,
            &pStm));

    Check(S_OK, pStm->Stat( &StatBuf,STATFLAG_NONAME));
    Check(TRUE, (StatBuf.cbSize.HighPart == 0));

    Check(TRUE, (cbStream - StatBuf.cbSize.LowPart > 100));

    //
    // Release the storages and docfile.
    //

    delete [] pThreeHString;
    delete [] pOneHString;

    RELEASE_INTERFACE(pStm);
    RELEASE_INTERFACE(pDfStg);


}   // test_SimpleDocFile

//-----------------------------------------------------------------------------
//
//  Function:   test_ex_api
//
//  This function tests the StgOpenStorageEx API to make sure it correctly
//  opens an NTFS flat file property set when called with STGFMT_ANY for a
//  property set that was created on an NTFS flat file.
//
//-----------------------------------------------------------------------------
void
test_ex_api(LPOLESTR oszDir)
{
    IStorage *pDfStg = NULL;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;

    OLECHAR         oszFile[MAX_PATH];
    CPropSpec       rgPropSpec[3];
    CPropVariant    rgPropVariant[3];
    LPSTR           pFourKString;
    int             i;
    HRESULT         hr;
    FMTID           fmtidAnsi;

    Status( "Ex API Tests\n" );

    //
    // Generate a filename from the directory name.
    //
    ocscpy( oszFile, oszDir );

    ocscat( oszFile, OLESTR( "StgApi.dat" ));

    //
    // Create a property set storage and a prop storage
    //
    Check( S_OK, g_pfnStgCreateStorageEx( oszFile,
                                     STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     DetermineStgFmt( g_enumImplementation ),
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertySetStorage,
                                     (void**) &pPropSetStg));

    Check(S_OK,pPropSetStg->Create( FMTID_NULL, NULL,
                                      PROPSETFLAG_DEFAULT,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    //
    // Write a string to it.
    //
    rgPropSpec[0]  = 0x10;
    rgPropVariant[0] = "Hello, world";
    Check(S_OK, pPropStg->WriteMultiple(1, rgPropSpec, rgPropVariant, PID_FIRST_USABLE));

    //
    // Close it
    //
    pPropStg->Release();
    pPropStg = NULL;
    pPropSetStg->Release();
    pPropSetStg = NULL;

    //
    // Open it.
    //
    Check(S_OK,g_pfnStgOpenStorageEx(   oszFile,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     STGFMT_ANY,
                                     0L,
                                     NULL,
                                     NULL,
                                     IID_IPropertySetStorage,
                                     (void**) &pPropSetStg ));
    UuidCreate( &fmtidAnsi );

    //
    // Attempt to create an ANSI prop storage
    //
    Check(S_OK, pPropSetStg->Create( fmtidAnsi, &CLSID_NULL,
                                     PROPSETFLAG_ANSI,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     &pPropStg ));

    //
    // Clean up before exiting.
    //

    if (pPropStg)
    {
        pPropStg->Release();
        pPropStg = NULL;
    }

    if (pPropSetStg)
    {
        pPropSetStg->Release();
        pPropSetStg = NULL;
    }
}


void
test_UnsupportedProperties( IStorage *pStg )
{
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    CPropVariant rgcpropvarWrite[2], cpropvarRead;
    CPropSpec    rgcpropspec[2];

    Status( "Unsupported VarTypes\n" );

    FMTID fmtid;
    UuidCreate(&fmtid);

    // Start by creating a property set with a couple of properties in it.

    Check( S_OK, StgToPropSetStg( pStg, &pPropSetStg ));
    Check( S_OK, pPropSetStg->Create( fmtid, NULL,
                                      PROPSETFLAG_DEFAULT | PROPSETFLAG_CASE_SENSITIVE,
                                      STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                      &pPropStg ));

    rgcpropvarWrite[0] = (long) 1234; // VT_I4
    rgcpropvarWrite[1] = (short) 56;  // VT_I2
    rgcpropspec[0] = PID_FIRST_USABLE;
    rgcpropspec[1] = PID_FIRST_USABLE + 1;

    Check( S_OK, pPropStg->WriteMultiple( 2, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));

    // Modify the first property so that it has an invalid VT

    RELEASE_INTERFACE( pPropStg );
    ModifyPropertyType( pStg, fmtid, rgcpropspec[0].propid, 0x500 );

    // Try to read that property back (the one with the invalid VT)

    Check( S_OK, pPropSetStg->Open( fmtid, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pPropStg ));
    Check( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED),
           pPropStg->ReadMultiple( 1, &rgcpropspec[0], &cpropvarRead ));

    // Verify that we can read back the other property

    Check( S_OK, pPropStg->ReadMultiple( 1, &rgcpropspec[1], &cpropvarRead ));
    Check( TRUE, cpropvarRead == rgcpropvarWrite[1] );

    // And verify that we can't write a property with an invalid VT

    rgcpropvarWrite[0].vt = 0x500;
    Check( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED),
           pPropStg->WriteMultiple( 1, &rgcpropspec[0], &rgcpropvarWrite[0], PID_FIRST_USABLE ));

    RELEASE_INTERFACE( pPropStg );
    RELEASE_INTERFACE( pPropSetStg );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pstgserv\pch.cxx ===
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pstgserv\main.cxx ===
#include "pch.cxx"

#include <ole2.h>
#include <stdio.h>
#include <tchar.h>
#include <pstgserv.hxx>

CPropertyStorageServerApp cPropStgServerApp;


const TCHAR tszCLSIDInterface[]    = "{af4ae0d0-a37f-11cf-8d73-00aa004cd01a}";
const TCHAR tszCLSIDApp[]          = "{af4ae0d1-a37f-11cf-8d73-00aa004cd01a}";


void
SelfRegistration( HINSTANCE hinst )
{
    LONG lRet;
    DWORD dwDisposition;

    HKEY hkeyBase = NULL;
    HKEY hkey = NULL;

    LPTSTR tszError = NULL;

    LPTSTR tszServerName = TEXT("PropTest Local Server");
    LPTSTR tszProxyStubName = TEXT("PropTest Local Server Proxy/Stub");
    TCHAR  tszModulePathAndName[ MAX_PATH + 1 ];
    TCHAR  tszKeyName[ MAX_PATH + 1 ];
    LPTSTR tszNumMethods = TEXT("5");


    //  ----------------------------------------
    //  Update the CLSID key for the application
    //  ----------------------------------------

    // Open HKEY_CLASSES_ROOT\CLSID\{af4ae0d1-...1a}

    _tcscpy( tszKeyName, TEXT("CLSID\\") );
    _tcscat( tszKeyName, tszCLSIDApp );

    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                          tszKeyName,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkeyBase,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create primary CLSID key");
        goto Exit;
    }

    // Write a name for this CLSID

    lRet = RegSetValueEx( hkeyBase,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszServerName,
                          _tcslen(tszServerName) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set local server name");
        goto Exit;
    }

    // Get this program's path and name

    if( !GetModuleFileName( hinst, tszModulePathAndName,
                            sizeof(tszModulePathAndName)/sizeof(TCHAR) ))
    {
        tszError = TEXT("Couldn't get Module file name");
        goto Exit;
    }

    // Set the LocalServer32 value

    lRet = RegCreateKeyEx(hkeyBase,
                          TEXT("LocalServer32"),
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create LocalServer32 key");
        goto Exit;
    }


    lRet = RegSetValueEx( hkey,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszModulePathAndName,
                          (1 + _tcslen(tszModulePathAndName) ) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set local server name");
        goto Exit;
    }

    CloseHandle( hkey );
    hkey = NULL;

    CloseHandle( hkeyBase );
    hkeyBase = NULL;


    //  ---------------------------------------
    //  Update the CLSID key for the proxy/stub
    //  ---------------------------------------

    // Set the InProcServer32 value (the proxy/stub)
    // We assume that the proxy/stub has the same name as this
    // local server (except with a dll extension), and we assume
    // that it's in the same path.  We really should have a
    // DllRegisterServer function in the DLL itself that does this,
    // but we do it here instead to save some code.

    _tcscpy( &tszModulePathAndName[ _tcslen(tszModulePathAndName) - 3 ],
             TEXT("dll") );

    _tcscpy( tszKeyName, TEXT("CLSID\\") );
    _tcscat( tszKeyName, tszCLSIDInterface );

    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                          tszKeyName,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkeyBase,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create proxy/stub CLSID key");
        goto Exit;
    }

    // Write a name for this CLSID

    lRet = RegSetValueEx( hkeyBase,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszProxyStubName,
                          _tcslen(tszProxyStubName) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set proxy/stub name");
        goto Exit;
    }

    // Set the InproxServer32 value

    lRet = RegCreateKeyEx(hkeyBase,
                          TEXT("InprocServer32"),
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create InprocServer32 key");
        goto Exit;
    }


    lRet = RegSetValueEx( hkey,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszModulePathAndName,
                          (1 + _tcslen(tszModulePathAndName) ) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set proxy/stub value");
        goto Exit;
    }

    CloseHandle( hkey );
    hkey = NULL;

    CloseHandle( hkeyBase );
    hkeyBase = NULL;

    //  ------------------------
    //  Update the Interface key
    //  ------------------------

    // Open HKEY_CLASSES_ROOT\Interface\{af4ae0d0-...1a}

    _tcscpy( tszKeyName, TEXT("Interface\\") );
    _tcscat( tszKeyName, tszCLSIDInterface );

    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                          tszKeyName,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkeyBase,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create interface key");
        goto Exit;
    }



    // Write a name for this IID

    lRet = RegSetValueEx( hkeyBase,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszServerName,
                          _tcslen(tszServerName) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set local server name");
        goto Exit;
    }


    // Set the NumMethods value

    lRet = RegCreateKeyEx(hkeyBase,
                          TEXT("NumMethods"),
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create NumMethods key");
        goto Exit;
    }

    lRet = RegSetValueEx( hkey,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszNumMethods,
                          (1 + _tcslen(tszNumMethods) ) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set number of methods");
        goto Exit;
    }

    CloseHandle( hkey );
    hkey = NULL;
                        
    // Set the Proxy/Stub CLSID

    lRet = RegCreateKeyEx(hkeyBase,
                          TEXT("ProxyStubClsid32"),
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDisposition );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't create ProxyStubClsid32 key");
        goto Exit;
    }

    lRet = RegSetValueEx( hkey,
                          NULL,
                          0,
                          REG_SZ,
                          (const BYTE*) tszCLSIDInterface,
                          (1 + _tcslen(tszCLSIDInterface) ) * sizeof(TCHAR) );
    if( ERROR_SUCCESS != lRet )
    {
        tszError = TEXT("Couldn't set ProxyStubClsid32");
        goto Exit;
    }

    CloseHandle( hkey );
    hkey = NULL;

    CloseHandle( hkeyBase );
    hkeyBase = NULL;


    //  ----
    //  Exit
    //  ----

Exit:

    if( ERROR_SUCCESS != lRet )
    {
        TCHAR tszErrorMessage[ 256 ];
        _tcscpy( tszErrorMessage, tszError );
        _stprintf( &tszErrorMessage[ _tcslen(tszErrorMessage) ],
                   TEXT("\nError = %lu"), 
                   GetLastError() );
        
        MessageBox( NULL, tszErrorMessage, TEXT("PStgServ (PropTest) Self-Registration Error"), MB_OK );

        if( hkey ) CloseHandle( hkey );
        if( hkeyBase ) CloseHandle( hkeyBase );
    }


    return;

}



int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		    LPSTR lpszCmdLine, int nCmdShow )
{

    if( !strcmp( lpszCmdLine, "/RegServer" )
        ||
        !strcmp( lpszCmdLine, "-RegServer" ))
    {
        SelfRegistration( hInstance );
    }
    else if( cPropStgServerApp.Init(hInstance, hPrevInstance,
                                    lpszCmdLine, nCmdShow) )
    {
        return( cPropStgServerApp.Run() );
    }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pstgserv\pstgserv.cxx ===
#include "pch.cxx"
#include <stdio.h>
#include <ole2.h>
#include <pstgserv.hxx>


HWND            CPropertyStorageServerApp::m_hwnd;
DWORD           CPropertyStorageServerApp::m_dwReg;
CClassFactory  *CPropertyStorageServerApp::m_pClassFactory;
CHAR            CPropertyStorageServerApp::m_szAppName[80];
HINSTANCE       CPropertyStorageServerApp::m_hInstance;
int             CPropertyStorageServerApp::m_nCmdShow;
BOOL            CPropertyStorageServerApp::m_fCloseOnFinalRelease;

EXTERN_C const IID IID_IPropertyStorageServerApp= {0xaf4ae0d1,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1a}};

__declspec(dllexport)
LONG_PTR FAR PASCAL
CPropertyStorageServerApp::WndProc (HWND hwnd, UINT message,
                                    WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_USER :

            if( m_fCloseOnFinalRelease )
                PostMessage( hwnd, WM_CLOSE, 0, 0 );
            break;

        case WM_CLOSE :

            DestroyWindow( hwnd );
            break;

        case WM_DESTROY :

            CoUninitialize();
            CoRevokeClassObject( m_dwReg );
            delete m_pClassFactory;

            PostQuitMessage (0) ;
            return 0 ;
    }

    return (long) DefWindowProc (hwnd, message, wParam, lParam) ;
}



BOOL
CPropertyStorageServerApp::Init( HANDLE hInstance, HANDLE hPrevInstance,
                                 LPSTR lpszCmdLine, int nCmdShow )
{
    WNDCLASSA wndclass;

    if( strcmp( lpszCmdLine, "/Embedding" )
        &&
        strcmp( lpszCmdLine, "-Embedding" ))
    {
        m_fCloseOnFinalRelease = FALSE;
    }

    sprintf( m_szAppName, "IPropertyStorage Server" );
    m_hInstance = (HINSTANCE) hInstance;
    m_nCmdShow = nCmdShow;

    if( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc    = CPropertyStorageServerApp::WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = m_hInstance;
        wndclass.hIcon          = LoadIconA( m_hInstance, m_szAppName );
        wndclass.hCursor        = LoadCursorA( NULL, MAKEINTRESOURCEA(32512) ); // IDC_ARROW
        wndclass.hbrBackground  = (HBRUSH) GetStockObject( WHITE_BRUSH );
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = m_szAppName;

        RegisterClassA( &wndclass );
    }

    return( TRUE ); // Successful
}


#ifdef CreateWindowA
#undef CreateWindow
#endif

WORD
CPropertyStorageServerApp::Run( void )
{
    MSG msg;
    HRESULT hr;
    CHAR szErrorMessage[80];

    msg.wParam = 0;

    m_hwnd = CreateWindowA( m_szAppName,
                           "IPropertyStorage Server",
                           WS_OVERLAPPEDWINDOW,
                           CW_USEDEFAULT, CW_USEDEFAULT,
                           CW_USEDEFAULT, CW_USEDEFAULT,
                           NULL, NULL, m_hInstance, NULL );
    if( NULL == m_hwnd )
    {
        sprintf( szErrorMessage, "Failed CreateWindowA (%lu)", GetLastError() );
        goto Exit;
    }

    ShowWindow( m_hwnd, SW_MINIMIZE );
    UpdateWindow( m_hwnd );

    if( FAILED( hr = CoInitialize( NULL )))
    {
        sprintf( szErrorMessage, "Failed CoInitialize (%08x)", hr );
        goto Exit;
    }

    m_pClassFactory = (CClassFactory*) new CClassFactory( m_hwnd );
    if( m_pClassFactory == NULL )
    {
        hr = E_OUTOFMEMORY;
        sprintf( szErrorMessage, "Couldn't create CClassFactory" );
        goto Exit;
    }

    if( FAILED( hr = CoRegisterClassObject( IID_IPropertyStorageServerApp,
                                            m_pClassFactory,
                                            CLSCTX_LOCAL_SERVER,
                                            REGCLS_MULTIPLEUSE,
                                            &m_dwReg )))
    {
        sprintf( szErrorMessage, "Couldn't register class object" );
        goto Exit;
    }

    while( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

Exit:

    return( (WORD) msg.wParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pstgserv\proxstub\dllmain.cxx ===
#include <windows.h>

HANDLE g_hInst = NULL;

BOOL   WINAPI   DllMain (HANDLE hInst, 
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
   g_hInst = hInst;
   return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pstgserv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BStrMarshalServer.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_BSTRMARSHALSERVER_DIALOG    102
#define IDR_MAINFRAME                   128
#define IDC_STRING                      1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pstgserv\pssclass.cxx ===
#include "pch.cxx"
#include <windows.h>
#include <ole2.h>

#include "PStgServ.h"
#include "PStgServ.hxx"
#include "global.hxx"  // PropTest global information

const IID IID_IPropertyStorageServer = {0xaf4ae0d0,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1a}};
const IID IID_IPropertyStorageServer2= {0xaf4ae0d0,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1b}};

EnumImplementation g_enumImplementation;
DWORD g_Restrictions;

HINSTANCE g_hinstDLL = NULL;

FNSTGCREATEPROPSTG *g_pfnStgCreatePropStg = NULL;
FNSTGOPENPROPSTG *g_pfnStgOpenPropStg = NULL;
FNSTGCREATEPROPSETSTG *g_pfnStgCreatePropSetStg = NULL;
FNFMTIDTOPROPSTGNAME *g_pfnFmtIdToPropStgName = NULL;
FNPROPSTGNAMETOFMTID *g_pfnPropStgNameToFmtId = NULL;
FNPROPVARIANTCLEAR *g_pfnPropVariantClear = NULL;
FNPROPVARIANTCOPY *g_pfnPropVariantCopy = NULL;
FNFREEPROPVARIANTARRAY *g_pfnFreePropVariantArray = NULL;


STDMETHODIMP
CClassFactory::QueryInterface( REFIID riid, void **ppvObject )
{
    IUnknown *pUnk = NULL;

    if( riid == IID_IUnknown
        ||
        riid == IID_IClassFactory
      )
    {
        pUnk = this;
    }

    if( pUnk != NULL )
    {
        pUnk->AddRef();
        *ppvObject = pUnk;
        return S_OK;
    }

    *ppvObject = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CClassFactory::AddRef( void )
{
    return( ++m_cRefs );
}


STDMETHODIMP_(ULONG)
CClassFactory::Release( void )
{
    m_cRefs--;

    if( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}


STDMETHODIMP
CClassFactory::CreateInstance( IUnknown *pUnkOuter,
                               REFIID riid,
                               void **ppvObject )
{
    CPropertyStorageServer *pObj = NULL;

    if( pUnkOuter != NULL )
    {
        return( CLASS_E_NOAGGREGATION );
    }

    pObj = new CPropertyStorageServer( this );
    if( pObj == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    return pObj->QueryInterface( riid, ppvObject );
}


STDMETHODIMP
CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
    {
        m_cLocks++;
    }
    else
    {
        m_cLocks--;
    }

    if( m_cLocks == 0 )
    {
        PostMessage( m_hWnd, WM_USER, 0, 0 );
    }

    return S_OK;
}


STDMETHODIMP
CPropertyStorageServer::QueryInterface( REFIID riid, void **ppvObject )
{
    *ppvObject = NULL;
    IUnknown *pUnk = NULL;

    if( riid == IID_IUnknown
        ||
        riid == IID_IPropertyStorageServer
      )
    {
        pUnk = this;
    }

    if( pUnk != NULL )
    {
        pUnk->AddRef();
        *ppvObject = pUnk;
        return S_OK;
    }

    *ppvObject = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CPropertyStorageServer::AddRef( void )
{
    return( ++m_cRefs );
}


STDMETHODIMP_(ULONG)
CPropertyStorageServer::Release( void )
{
    if( --m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}


STDMETHODIMP
CPropertyStorageServer::StgOpenPropStg( const OLECHAR *pwcsName,
                                        REFFMTID fmtid,
                                        DWORD grfMode,
                                        IPropertyStorage **pppstg )
{
    HRESULT hr;
    IPropertySetStorage *ppsstg = NULL;

    if( m_pstg )
    {
        m_pstg->Release();
        m_pstg = NULL;
    }

    hr = ::StgOpenStorageEx (
            pwcsName,
            grfMode,
            DetermineStgFmt( g_enumImplementation ),
            0,
            NULL,
            NULL,
            PROPIMP_NTFS == g_enumImplementation ? IID_IFlatStorage : IID_IStorage,
            (void**) &m_pstg );
    if( FAILED(hr) ) goto Exit;

    hr = m_pstg->QueryInterface( IID_IPropertySetStorage, (void**) &ppsstg );
    if( FAILED(hr) ) goto Exit;

    hr = ppsstg->Open( fmtid, grfMode, pppstg );
    if( FAILED(hr) ) goto Exit;

Exit:

    if( FAILED(hr)
        &&
        m_pstg != NULL )
    {
        m_pstg->Release();
        m_pstg = NULL;
    }

    if( ppsstg ) ppsstg->Release();

    return( hr );
}

STDMETHODIMP
CPropertyStorageServer::StgOpenPropSetStg(
                                     const OLECHAR *pwcsName,
                                     DWORD grfMode,
                                     IPropertySetStorage **pppsstg )
{
    HRESULT hr;

    if( m_pstg )
    {
        m_pstg->Release();
        m_pstg = NULL;
    }

    hr = ::StgOpenStorageEx (
            pwcsName,
            grfMode,
            DetermineStgFmt( g_enumImplementation ),
            0,
            NULL,
            NULL,
            PROPIMP_NTFS == g_enumImplementation ? IID_IFlatStorage : IID_IStorage,
            (void**) &m_pstg );
    if( FAILED(hr) ) goto Exit;

    hr = m_pstg->QueryInterface( IID_IPropertySetStorage, (void**) pppsstg );
    if( FAILED(hr) ) goto Exit;

Exit:

    if( FAILED(hr)
        &&
        m_pstg != NULL )
    {
        m_pstg->Release();
        m_pstg = NULL;
    }

    return( hr );
}

STDMETHODIMP
CPropertyStorageServer::MarshalUnknown( IUnknown *punk )
{
    punk->AddRef();
    punk->Release();

    return( S_OK );
}

STDMETHODIMP
CPropertyStorageServer::Initialize( EnumImplementation enumImplementation,
                                    ULONG Restrictions )
{
    HRESULT hr;

    g_enumImplementation = enumImplementation;
    g_Restrictions = Restrictions;


    if( PROPIMP_DOCFILE_IPROP == g_enumImplementation )
    {
        // We're to use the propset APIs from IProp

        g_hinstDLL = LoadLibraryA( "iprop.dll" );
    }
    else
    {
        // We're to use the propset APIs from OLE32

        g_hinstDLL = LoadLibraryA( "ole32.dll" );
    }

    if( NULL == g_hinstDLL )
    {
        hr = ERROR_MOD_NOT_FOUND;
        goto Exit;
    }

    // Get pointers to the functions that we always use
    // (e.g., PropVariantCopy, but not StgCreatePropSetStg)

    hr = ERROR_PROC_NOT_FOUND;

    g_pfnPropVariantCopy = (FNPROPVARIANTCOPY*)
                           GetProcAddress( g_hinstDLL,
                                           "PropVariantCopy" );
    if( NULL == g_pfnPropVariantCopy ) goto Exit;

    g_pfnPropVariantClear = (FNPROPVARIANTCLEAR*)
                            GetProcAddress( g_hinstDLL,
                                            "PropVariantClear" );
    if( NULL == g_pfnPropVariantClear ) goto Exit;

    g_pfnFreePropVariantArray = (FNFREEPROPVARIANTARRAY*)
                                GetProcAddress( g_hinstDLL,
                                                "FreePropVariantArray" );
    if( NULL == g_pfnFreePropVariantArray ) goto Exit;

    g_pfnStgCreatePropSetStg = (FNSTGCREATEPROPSETSTG*)
                               GetProcAddress( g_hinstDLL,
                                               "StgCreatePropSetStg" );
    if( NULL == g_pfnStgCreatePropSetStg ) goto Exit;

    g_pfnStgCreatePropStg = (FNSTGCREATEPROPSTG*)
                            GetProcAddress( g_hinstDLL,
                                            "StgCreatePropStg" );
    if( NULL == g_pfnStgCreatePropStg ) goto Exit;

    g_pfnStgOpenPropStg = (FNSTGOPENPROPSTG*)
                          GetProcAddress( g_hinstDLL,
                                          "StgOpenPropStg" );
    if( NULL == g_pfnStgOpenPropStg ) goto Exit;

    g_pfnFmtIdToPropStgName = (FNFMTIDTOPROPSTGNAME*)
                              GetProcAddress( g_hinstDLL,
                                              "FmtIdToPropStgName" );
    if( NULL == g_pfnFmtIdToPropStgName ) goto Exit;

    g_pfnPropStgNameToFmtId = (FNPROPSTGNAMETOFMTID*)
                              GetProcAddress( g_hinstDLL,
                                              "PropStgNameToFmtId" );
    if( NULL == g_pfnPropStgNameToFmtId ) goto Exit;


    
    hr = S_OK;

Exit:

    return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pstgserv\proxstub\chicago\makefile.inc ===
############################################################################
#
#   Copyright (C) 1996-1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

MIDL = midl.exe

MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Oi \
 -oldnames \
 -char unsigned \
 -error allocation \
 -error bounds_check \
 -error stub_data \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \
 -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES)

SSWITCH=-prefix sstub _

obj\pstgserv.h: ..\pstgserv.idl
     $(MIDL) $(MIDL_FLAGS) -header obj\pstgserv.h ..\pstgserv.idl


DEST_TREE=daytona

allidl:   obj\pstgserv.h

clean:
          -erase obj\pstgserv.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\utest\pstgserv\proxstub\daytona\makefile.inc ===
############################################################################
#
#   Copyright (C) 1996-1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

MIDL = midl.exe

MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Oi \
 -oldnames \
 -char unsigned \
 -error allocation \
 -error bounds_check \
 -error stub_data \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \
 -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES)

SSWITCH=-prefix sstub _

obj\pstgserv.h: ..\pstgserv.idl
     $(MIDL) $(MIDL_FLAGS) -header obj\pstgserv.h ..\pstgserv.idl


DEST_TREE=daytona

allidl:   obj\pstgserv.h

clean:
          -erase obj\pstgserv.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\cdocfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       cdocfile.cxx
//
//  Contents:   Implementation of CDocFile methods for DocFiles
//
//---------------------------------------------------------------

#include "dfhead.cxx"

#include "h/vectfunc.hxx"

//+--------------------------------------------------------------
//
//  Member:     PEntry::_dlBase, static private data
//
//  Synopsis:   luid allocation base
//
//  Notes:      Since DF_NOLUID is 0 and ROOT_LUID is 1 we start
//              issuing at 2.
//
//---------------------------------------------------------------

DFLUID PEntry::_dlBase = LUID_BASE;

//+--------------------------------------------------------------
//
//  Member:     CDocFile::InitFromEntry, public
//
//  Synopsis:   Creation/Instantiation constructor for embeddings
//
//  Arguments:  [pstghParent] - Parent handle
//              [pdfn] - Name
//              [fCreate] - Create/Instantiate
//              [dwType] - Type of entry
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CDocFile::InitFromEntry(CStgHandle *pstghParent,
                              CDfName const *pdfn,
                              BOOL const fCreate)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::InitFromEntry(%p, %ws, %d)\n",
                pstghParent, pdfn, fCreate));
    if (fCreate)
        sc = pstghParent->CreateEntry(pdfn, STGTY_STORAGE, &_stgh);
    else
        sc = pstghParent->GetEntry(pdfn, STGTY_STORAGE, &_stgh);
    if (SUCCEEDED(sc))
        AddRef();
    olDebugOut((DEB_ITRACE, "Out CDocFile::InitFromEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::CreateDocFile, public
//
//  Synopsis:   Creates a DocFile object in a parent
//
//  Arguments:  [pdfn] - Name of DocFile
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [dwType] - Type of entry
//              [ppdfDocFile] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//---------------------------------------------------------------


SCODE CDocFile::CreateDocFile(CDfName const *pdfn,
                              DFLAGS const df,
                              DFLUID dlSet,
                              CDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CreateDocFile:%p("
                "%ws, %X, %lu, %p)\n", this, pdfn, df, dlSet,
                ppdfDocFile));
    UNREFERENCED_PARM(df);

    if (dlSet == DF_NOLUID)
        dlSet = CDocFile::GetNewLuid();

    olMem(pdf = new CDocFile(dlSet, _pilbBase));

    olChkTo(EH_pdf, pdf->InitFromEntry(&_stgh, pdfn, TRUE));

    *ppdfDocFile = pdf;
    olDebugOut((DEB_ITRACE, "Out CDocFile::CreateDocFile => %p\n",
                SAFE_DREF(ppdfDocFile)));
    return S_OK;

EH_pdf:
    delete pdf;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetDocFile, public
//
//  Synopsis:   Instantiates an existing docfile
//
//  Arguments:  [pdfn] - Name of stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppdfDocFile] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//---------------------------------------------------------------


SCODE CDocFile::GetDocFile(CDfName const *pdfn,
                           DFLAGS const df,
                           CDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetDocFile:%p("
                "%ws, %X, %p)\n", this, pdfn, df, ppdfDocFile));
    UNREFERENCED_PARM(df);

    DFLUID dl = CDocFile::GetNewLuid();
    olMem(pdf = new CDocFile(dl, _pilbBase));

    olChkTo(EH_pdf, pdf->InitFromEntry(&_stgh, pdfn, FALSE));
    *ppdfDocFile = pdf;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

EH_pdf:
    delete pdf;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::Release, public
//
//  Synopsis:   Release resources for a DocFile
//
//---------------------------------------------------------------


void CDocFile::Release(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFile::Release()\n"));
    olAssert(_cReferences > 0);

    AtomicDec(&_cReferences);
    if (_cReferences == 0)
        delete this;
    olDebugOut((DEB_ITRACE, "Out CDocFile::Release\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::RenameEntry, public
//
//  Synopsis:   Renames a child
//
//  Arguments:  [pdfnName] - Old name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CDocFile::RenameEntry(CDfName const *pdfnName,
                            CDfName const *pdfnNewName)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::RenameEntry(%ws, %ws)\n",
                pdfnName, pdfnNewName));
    sc = _stgh.RenameEntry(pdfnName, pdfnNewName);
    olDebugOut((DEB_ITRACE, "Out CDocFile::RenameEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::DestroyEntry, public
//
//  Synopsis:   Permanently destroys a child
//
//  Arguments:  [pdfnName] - Name of child
//              [fClean] - Ignored
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CDocFile::DestroyEntry(CDfName const *pdfnName,
                             BOOL fClean)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::DestroyEntry:%p(%ws, %d)\n",
                this, pdfnName, fClean));
    UNREFERENCED_PARM(fClean);
    sc = _stgh.DestroyEntry(pdfnName);
    olDebugOut((DEB_ITRACE, "Out CDocFile::DestroyEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::IsEntry, public
//
//  Synopsis:   Determines whether the given object is a member
//              of the DocFile
//
//  Arguments:  [pdfnName] - Name
//              [peb] - Entry buffer to fill in
//
//  Returns:    Appropriate status code
//
//  Modifies:   [peb]
//
//---------------------------------------------------------------


SCODE CDocFile::IsEntry(CDfName const *pdfnName,
                        SEntryBuffer *peb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::IsEntry(%ws, %p)\n",
                pdfnName, peb));
    sc = _stgh.IsEntry(pdfnName, peb);
    olDebugOut((DEB_ITRACE, "Out CDocFile::IsEntry => %lu, %lu, %lu\n",
                sc, peb->luid, peb->dwType));
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CDocFile::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//---------------------------------------------------------------

void CDocFile::AddRef(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFile::AddRef()\n"));
    AtomicInc(&_cReferences);
    olDebugOut((DEB_ITRACE, "Out CDocFile::AddRef, %lu\n", _cReferences));
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetTime, public
//
//  Synopsis:   Gets a time
//
//  Arguments:  [wt] - Which time
//              [ptm] - Time return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ptm]
//
//---------------------------------------------------------------

SCODE CDocFile::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    return _stgh.GetTime(wt, ptm);
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::SetTime, public
//
//  Synopsis:   Sets a time
//
//  Arguments:  [wt] - Which time
//              [tm] - New time
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CDocFile::SetTime(WHICHTIME wt, TIME_T tm)
{
    return _stgh.SetTime(wt, tm);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::GetClass, public
//
//  Synopsis:   Gets the class ID
//
//  Arguments:  [pclsid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pclsid]
//
//----------------------------------------------------------------------------

SCODE CDocFile::GetClass(CLSID *pclsid)
{
    return _stgh.GetClass(pclsid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::SetClass, public
//
//  Synopsis:   Sets the class ID
//
//  Arguments:  [clsid] - New class ID
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CDocFile::SetClass(REFCLSID clsid)
{
    return _stgh.SetClass(clsid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::GetStateBits, public
//
//  Synopsis:   Gets the state bits
//
//  Arguments:  [pgrfStateBits] - State bits return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pgrfStateBits]
//
//----------------------------------------------------------------------------

SCODE CDocFile::GetStateBits(DWORD *pgrfStateBits)
{
    return _stgh.GetStateBits(pgrfStateBits);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::SetStateBits, public
//
//  Synopsis:   Sets the state bits
//
//  Arguments:  [grfStateBits] - Bits to set
//              [grfMask] - Mask
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return _stgh.SetStateBits(grfStateBits, grfMask);
}

//+---------------------------------------------------------------------------
//
//  Member:	CDocFile::FindGreaterEntry, public (virtual)
//
//  Synopsis:	Returns the next greater child
//
//  Arguments:	[pdfnKey]  - Previous key
//              [pNextKey] - The found key
//              [pstat]    - Full iterator buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:	[pstat]    - if it is not null
//              [pNextKey] - if it is not null
//
//----------------------------------------------------------------------------

SCODE CDocFile::FindGreaterEntry(CDfName const *pdfnKey,
                                 CDfName *pNextKey,
                                 STATSTGW *pstat)
{
    SID sid, sidChild;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::FindGreaterEntry:%p(%p, %p, %p)\n",
               this, pdfnKey, pNextKey, pstat));
    if (SUCCEEDED(sc = _stgh.GetMS()->GetChild(_stgh.GetSid(), &sidChild)))
    {
        if (sidChild == NOSTREAM)   
            sc = STG_E_NOMOREFILES;
        else if (SUCCEEDED(sc = _stgh.GetMS()->
                           FindGreaterEntry(sidChild, pdfnKey, &sid)))
        {
                sc = _stgh.GetMS()->StatEntry(sid, pNextKey, pstat);
        }
    }
    olDebugOut((DEB_ITRACE, "Out CDocFile::FindGreaterEntry\n"));
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CDocFile::ExcludeEntries, public
//
//  Synopsis:   Excludes the given entries
//
//  Arguments:  [snbExclude] - Entries to exclude
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CDocFile::ExcludeEntries(CDocFile *pdf, SNBW snbExclude)
{
    PDocFileIterator *pdfi;
    CDirectStream *pstChild;
    CDocFile *pdfChild;
    SCODE sc;
    SIterBuffer ib;

    olDebugOut((DEB_ITRACE, "In  PDocFile::ExcludeEntries(%p)\n",
                snbExclude));
    olChk(pdf->GetIterator(&pdfi));
    for (;;)
    {
        if (FAILED(pdfi->BufferGetNext(&ib)))
            break;
        if (NameInSNB(&ib.dfnName, snbExclude) == S_OK)
        {
            switch(REAL_STGTY(ib.type))
            {
            case STGTY_STORAGE:
                olChkTo(EH_pwcsName, pdf->GetDocFile(&ib.dfnName, DF_READ |
                                                     DF_WRITE, ib.type,
                                                     &pdfChild));
                olChkTo(EH_Get, pdfChild->DeleteContents());
                pdfChild->Release();
                break;
            case STGTY_STREAM:
                olChkTo(EH_pwcsName, pdf->GetStream(&ib.dfnName, DF_WRITE,
                                                    ib.type, &pstChild));
                olChkTo(EH_Get, pstChild->SetSize(0));
                pstChild->Release();
                break;
            }
        }
    }
    pdfi->Release();
    olDebugOut((DEB_ITRACE, "Out ExcludeEntries\n"));
    return S_OK;

EH_Get:
    if (REAL_STGTY(ib.type))
        pdfChild->Release();
    else
        pstChild->Release();
EH_pwcsName:
    pdfi->Release();
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\dfhead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       dfhead.cxx
//
//  Contents:   Precompiled headers
//
//--------------------------------------------------------------------------
#ifdef _MSC_VER
// some of these functions are a nuisance 
#pragma warning (disable:4127)  // conditional expression is constant
#pragma warning (disable:4514)  // unreferenced inline function
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "h/ole.hxx"
#include "h/ref.hxx"
#include "h/msf.hxx"

#include "h/dfexcept.hxx"
#include "h/cdocfile.hxx"
#include "expdf.hxx"
#include "h/docfilep.hxx"
#include "h/dffuncs.hxx"
#include "h/funcs.hxx"
#include "h/piter.hxx"
#include "h/sstream.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\ascii.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ascii.cxx
//
//  Contents:   char to WCHAR conversion layer
//
//  Notes:      Most of the functions that provide the conversions are
//              here. Note that is layer will not be present for _UNICODE
//              builds 
//
//---------------------------------------------------------------

#ifndef _UNICODE // If UNICODE is defined, none of this is necessary

#include "exphead.cxx"

#include "expdf.hxx"
#include "expiter.hxx"
#include "expst.hxx"
#include "ascii.hxx"

extern "C" {
#include <string.h>
};

//+--------------------------------------------------------------
//
//  Function:   ValidateSNBA, private
//
//  Synopsis:   Validates a char SNB
//
//  Arguments:  [snb] - SNB
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

static SCODE ValidateSNBA(SNB snb)
{
    SCODE sc;
    
    for (;;)
    {
        olChk(ValidatePtrBuffer(snb));
        if (*snb == NULL)
            break;
        olChk(ValidateNameA(*snb, CBMAXPATHCOMPLEN));
        snb++;
    }
    return S_OK;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   SNBToSNBW, private
//
//  Synopsis:   Converts a char SNB to a WCHAR SNB
//
//  Arguments:  [snbIn] - char SNB
//
//  Returns:    WCHAR SNB or NULL
//
//---------------------------------------------------------------

static SNBW SNBToSNBW(SNB snbIn)
{
    ULONG cbStrings = 0;
    SNB snb;
    ULONG cItems = 0;
    SNBW snbw, snbwOut;
    WCHAR *pwcs;
    BYTE *pb;
    
    for (snb = snbIn; *snb; snb++, cItems++)
        cbStrings += (strlen(*snb)+1)*sizeof(WCHAR);
    cItems++;
    pb = new BYTE[(size_t)(cbStrings+sizeof(WCHAR *)*cItems)];
    if (pb == NULL)
        return NULL;
    snbwOut = (SNBW)pb;
    pwcs = (WCHAR *)(pb+sizeof(WCHAR *)*cItems);
    for (snb = snbIn, snbw = snbwOut; *snb; snb++, snbw++)
    {
        *snbw = pwcs;
        _tbstowcs(*snbw, *snb, strlen(*snb)+1);
        pwcs += wcslen(*snbw)+1;
    }
    *snbw = NULL;
    return snbwOut;
}

//+--------------------------------------------------------------
//
//  Function:   CheckAName, public
//
//  Synopsis:   Checks name for illegal characters and length
//
//  Arguments:  [pwcsName] - Name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------
const char INVALIDCHARS[] = "\\/:!";

SCODE CheckAName(char const *pwcsName)
{
    SCODE sc;
    olDebugOut((DEB_ITRACE, "In  CheckAName(%s)\n", pwcsName));
    if (FAILED(sc = ValidateNameA(pwcsName, CBMAXPATHCOMPLEN)))
        return sc;
    // >= is used because the max len includes the null terminator
    if (strlen(pwcsName) >= CWCMAXPATHCOMPLEN)
        return STG_E_INVALIDNAME;
    for (; *pwcsName; pwcsName++)
        if (strchr(INVALIDCHARS, (int)*pwcsName))
        return STG_E_INVALIDNAME;
    olDebugOut((DEB_ITRACE, "Out CheckAName\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Next, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::Next(ULONG celt,
                                    STATSTG FAR *rgelt,
                                    ULONG *pceltFetched)
{
    SCODE sc;
    ULONG i;
    ULONG cnt;
    
    olAssert(sizeof(STATSTG) == sizeof(STATSTGW));
    
    olChk(sc = Next(celt, (STATSTGW *)rgelt, &cnt));
    for (i = 0; i<cnt; i++)
        if (rgelt[i].pwcsName)
        _wcstotbs(rgelt[i].pwcsName, (WCHAR *)rgelt[i].pwcsName,
        CWCSTORAGENAME);
    if (pceltFetched)
        *pceltFetched = cnt;
EH_Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Stat, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;
    
    olAssert(sizeof(STATSTG) == sizeof(STATSTGW));
    
    olChk(sc = Stat((STATSTGW *)pstatstg, grfStatFlag));
    if (pstatstg->pwcsName)
        _wcstotbs(pstatstg->pwcsName, (WCHAR *)pstatstg->pwcsName,
        CWCSTORAGENAME);
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Stat, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;    
    olAssert(sizeof(STATSTG) == sizeof(STATSTGW));
    
    // call the virtual (wide char) function
    olChk(sc = this->Stat((STATSTGW *)pstatstg, grfStatFlag));

    if (pstatstg->pwcsName)
        _wcstotbs(pstatstg->pwcsName, (WCHAR *)pstatstg->pwcsName,
        _MAX_PATH);
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStream, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::CreateStream(char const *pszName,
                                           DWORD grfMode,
                                           DWORD reserved1,
                                           DWORD reserved2,
                                           IStream **ppstm)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    sc = CreateStream(wcsName, grfMode, reserved1, reserved2, ppstm);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStream, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::OpenStream(char const *pszName,
                                         void *reserved1,
                                         DWORD grfMode,
                                         DWORD reserved2,
                                         IStream **ppstm)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    sc = OpenStream(wcsName, reserved1, grfMode, reserved2, ppstm);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStorage, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::CreateStorage(char const *pszName,
                                            DWORD grfMode,
                                            DWORD reserved1,
                                            DWORD reserved2,
                                            IStorage **ppstg)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    sc = CreateStorage(wcsName, grfMode, reserved1, reserved2, ppstg);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStorage, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::OpenStorage(char const *pszName,
                                          IStorage *pstgPriority,
                                          DWORD grfMode,
                                          SNB snbExclude,
                                          DWORD reserved,
                                          IStorage **ppstg)
{
    SNBW snbw;
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    

    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    if (snbExclude)
        olChk(STG_E_INVALIDFUNCTION);
    else
        snbw = NULL;
    sc = OpenStorage(wcsName, pstgPriority, grfMode, snbw,
        reserved, ppstg);
    delete snbw;
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::DestroyElement, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::DestroyElement(char const *pszName)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszName));
    _tbstowcs(wcsName, pszName, CWCSTORAGENAME);
    sc = DestroyElement(wcsName);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RenameElement, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::RenameElement(char const *pszOldName,
                                            char const *pszNewName)
{
    SCODE sc;
    WCHAR wcsOldName[CWCSTORAGENAME], wcsNewName[CWCSTORAGENAME];
    
    olChk(CheckAName(pszOldName));
    olChk(CheckAName(pszNewName));
    _tbstowcs(wcsOldName, pszOldName, CWCSTORAGENAME);
    _tbstowcs(wcsNewName, pszNewName, CWCSTORAGENAME);
    sc = RenameElement(wcsOldName, wcsNewName);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CopyTo, public
//
//  Synopsis:   ANSI version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::CopyTo(DWORD ciidExclude,
                                     IID const *rgiidExclude,
                                     SNB snbExclude,
                                     IStorage *pstgDest)
{
    SNBW snbw;
    SCODE sc;
    
    if (snbExclude)
    {
        olChk(ValidateSNBA(snbExclude));
        olMem(snbw = SNBToSNBW(snbExclude));
    }
    else
        snbw = NULL;
    sc = CopyTo(ciidExclude, rgiidExclude, snbw, pstgDest);
    delete snbw;
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::MoveElementTo, public
//
//  Synopsis:   ANSI version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::MoveElementTo(TCHAR const *lpszName,
                                            IStorage *pstgDest,
                                            TCHAR const *lpszNewName,
                                            DWORD grfFlags)
{ 
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(lpszName));
    _tbstowcs(wcsName, lpszName, CWCSTORAGENAME);
    sc = MoveElementTo(wcsName, pstgDest, lpszNewName, grfFlags);
    
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetElementTimes, public
//
//  Synopsis:   ANSI version
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::SetElementTimes(TCHAR const *lpszName,
                                              FILETIME const *pctime,
                                              FILETIME const *patime,
                                              FILETIME const *pmtime)
{
    SCODE sc;
    WCHAR wcsName[CWCSTORAGENAME];
    
    olChk(CheckAName(lpszName));
    _tbstowcs(wcsName, lpszName, CWCSTORAGENAME);
    sc = SetElementTimes(wcsName, pctime, patime, pmtime);
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Function:   DfOpenStorageOnILockBytes, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

HRESULT DfOpenStorageOnILockBytes(ILockBytes *plkbyt,
                                 IStorage *pstgPriority,
                                 DWORD grfMode,
                                 SNB snbExclude,
                                 DWORD reserved,
                                 IStorage **ppstgOpen,
                                 CLSID *pcid)
{
    SNBW snbw;
    SCODE sc;
    
    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    if (snbExclude)
    {
        olChk(ValidateSNBA(snbExclude));
        olMem(snbw = SNBToSNBW(snbExclude)); 
    }
    else
        snbw = NULL;

    sc = DfOpenStorageOnILockBytesW(plkbyt, pstgPriority, grfMode,
                                    snbw, reserved, ppstgOpen, pcid);
    delete snbw;
EH_Err:
    return ResultFromScode(sc);
}

#endif // ifndef _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\dffuncs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996
//
//  File:       dffuncs.cxx
//
//  Contents:   Private support functions for the DocFile code
//
//  Methods:    CopyTo 
//              DeleteContents
//
//---------------------------------------------------------------

#include "dfhead.cxx"


#include "iter.hxx"
#include "h/sstream.hxx"



//+--------------------------------------------------------------
//
//  Method:     CDocFile::DeleteContents, public
//
//  Synopsis:   Deletes all entries in a DocFile recursing on entries
//              with children
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CDocFile::DeleteContents(void)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::DeleteContents()\n"));
    sc = _stgh.DestroyEntry(NULL);
    olDebugOut((DEB_ITRACE, "Out CDocFile::DeleteContents\n"));
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CDocFile::CopyTo, public
//
//  Synopsis:   Copies the contents of one DocFile to another
//
//  Arguments:  [pdfTo] - Destination DocFile
//              [dwFlags] - Control flags
//              [snbExclude] - Partial instantiation list
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CDocFile::CopyTo(CDocFile *pdfTo,
                       DWORD dwFlags,
                       SNBW snbExclude)
{
    PDocFileIterator *pdfi;
    SIterBuffer ib;
    CDirectStream *pstFrom, *pstTo;
    CDocFile *pdfFromChild, *pdfToChild;
    DFLUID dlLUID = DF_NOLUID;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CopyTo:%p(%p, %lX, %p)\n", this,
               pdfTo, dwFlags, snbExclude));
    olChk(GetIterator(&pdfi));
    for (;;)
    {
        if (FAILED(pdfi->BufferGetNext(&ib)))
            break;

        switch(REAL_STGTY(ib.type))
        {
        case STGTY_STORAGE:
            // Embedded DocFile, create destination and recurse

            olChkTo(EH_pwcsName, GetDocFile(&ib.dfnName, DF_READ, ib.type,
                                            &pdfFromChild));
            // Destination must be a direct docfile
            olChkTo(EH_Reserve, pdfTo->CreateDocFile(&ib.dfnName, DF_WRITE,
                                                     dlLUID, ib.type,
                                                     &pdfToChild));
            if (dwFlags & CDF_EXACT)
                pdfToChild->CopyTimesFrom(pdfFromChild);

            CLSID clsid;
            olChkTo(EH_Create, pdfFromChild->GetClass(&clsid));
            olChkTo(EH_Create, pdfToChild->SetClass(clsid));

            DWORD grfStateBits;
            olChkTo(EH_Create, pdfFromChild->GetStateBits(&grfStateBits));
            olChkTo(EH_Create, pdfToChild->SetStateBits(grfStateBits,
                                                        0xffffffff));


            if ((dwFlags & CDF_ENTRIESONLY) == 0 &&
                !(snbExclude && NameInSNB(&ib.dfnName, snbExclude) ==
                  S_OK))
                olChkTo(EH_Create,
                        pdfFromChild->CopyTo(pdfToChild, dwFlags, NULL));

            pdfFromChild->Release();
            pdfToChild->Release();
            break;

        case STGTY_STREAM:
            olChkTo(EH_pwcsName, GetStream(&ib.dfnName, DF_READ,
                                           ib.type, &pstFrom));
            // Destination must be a direct docfile
            olChkTo(EH_Reserve,
                    pdfTo->CreateStream(&ib.dfnName, DF_WRITE, 
                                        dlLUID, &pstTo));
            if (dwFlags & CDF_EXACT)
                pstTo->CopyTimesFrom(pstFrom);

            if ((dwFlags & CDF_ENTRIESONLY) == 0 &&
                !(snbExclude && 
                  NameInSNB(&ib.dfnName, snbExclude) == S_OK))
                olChkTo(EH_Create, CopyStreamToStream(
                    pstFrom, pstTo));

            pstFrom->Release();
            pstTo->Release();
            break;

        default:
            olAssert(!aMsg("Unknown entry type in CDocFile::CopyTo"));
            break;
        }
    }
    pdfi->Release();
    olDebugOut((DEB_ITRACE, "Out CDocFile::CopyTo\n"));
    return S_OK;

 EH_Create:
    if (REAL_STGTY(ib.type))
        pdfToChild->Release();
    else
        pstTo->Release();
    olAssert(&ib.dfnName);
    olVerSucc(pdfTo->DestroyEntry(&ib.dfnName, TRUE));
    goto EH_Get;
 EH_Reserve:
 EH_Get:
    if (REAL_STGTY(ib.type))
        pdfFromChild->Release();
    else
        pstFrom->Release();
 EH_pwcsName:
    pdfi->Release();
 EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\dfiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       dfiter.cxx
//
//  Contents:   Implementations of CDocFile iterator methods
//
//---------------------------------------------------------------

#include "dfhead.cxx"


#include "h/msfiter.hxx"
#include "iter.hxx"



//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetIterator, public
//
//  Synopsis:   Gets a new iterator
//
//  Arguments:  [ppdfi] - Iterator object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfi]
//
//---------------------------------------------------------------

SCODE CDocFile::GetIterator(PDocFileIterator **ppdfi)
{
    CDocFileIterator *pdfi;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetIterator(%p)\n", ppdfi));
    olMem(pdfi = new CDocFileIterator);
    olChkTo(EH_pdfi, pdfi->Init(&_stgh));
    *ppdfi = pdfi;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetIterator => %p\n", *ppdfi));
    return S_OK;

EH_pdfi:
    delete pdfi;
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\chinst.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996
//
//  File:       chinst.cxx
//
//  Contents:   DocFile child instance management code
//
//---------------------------------------------------------------
 
#include "dfhead.cxx"
#include "h/chinst.hxx"
#include "h/revert.hxx"

// Permissions checked in the less-restrictive rule
#define TCANTSET DF_READ
#define DCANTSET (DF_READ | DF_WRITE)
#define CANTCLEAR (DF_DENYREAD | DF_DENYWRITE)

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::Add, private
//
//  Synopsis:   Registers an instance of a child
//
//  Arguments:  [prv] - Child
//
//---------------------------------------------------------------

void CChildInstanceList::Add(PRevertable *prv)
{
    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::Add(%p)\n", prv));
    prv->_prvNext = _prvHead;
    _prvHead = prv;
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::Add\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CChildInstanceList::FindByName, private
//
//  Synopsis:   Finds a child instance by name
//
//  Arguments:  [pdfn] - Name
//
//  Returns:    Pointer to instance or NULL
//
//----------------------------------------------------------------------------

PRevertable *CChildInstanceList::FindByName(CDfName const *pdfn)
{
    PRevertable *prv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::FindByName:%p(%ws)\n",
                this, pdfn->GetBuffer()));
    for (prv = _prvHead; prv; prv = prv->_prvNext)
        if (prv->_dfn.IsEqual(pdfn))
            return prv;
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::FindByName\n"));
    return NULL;
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::DeleteByName, private
//
//  Synopsis:   Removes an instance from the instance list
//              and reverts it
//
//  Arguments:  [pdfn] - Name or NULL
//
//  Notes:      The entry does not have to exist
//              There can be multiple entries
//              If name is NULL, all entries match
//
//---------------------------------------------------------------

void CChildInstanceList::DeleteByName(CDfName const *pdfn)
{
    PRevertable **pprv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::DeleteByName(%ws)\n",
                pdfn->GetBuffer()));
    for (pprv = &_prvHead; *pprv; )
        if (NULL == pdfn || (*pprv)->_dfn.IsEqual(pdfn))
        {
            (*pprv)->RevertFromAbove();
            *pprv = (*pprv)->_prvNext;
        }
        else
            pprv = &(*pprv)->_prvNext;
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::DeleteByName\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::RemoveRv, private
//
//  Synopsis:   Removes a specific instance from the instance list
//
//  Arguments:  [prv] - Instance
//
//  Notes:      The entry does not have to exist
//
//---------------------------------------------------------------

void CChildInstanceList::RemoveRv(PRevertable *prvRv)
{
    PRevertable **prv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::RemoveRv(%p)\n", prvRv));
    for (prv = &_prvHead; *prv; prv = &(*prv)->_prvNext)
        if (*prv == prvRv)
        {
            *prv = (*prv)->_prvNext;
            break;
        }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::RemoveRv\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::IsDenied, private
//
//  Synopsis:   Checks the parent instantiation list for a previous
//              instance of the given child with DENY flags on
//              Also determines whether child mode flags are
//              less restrictive than the parent's
//
//  Arguments:  [pdfn] - Instance name
//              [dfCheck] - Access modes to check for denial
//              [dfAgainst] - Access modes to check against
//
//  Returns:    Appropriate status code
//
//  Notes:      The instance doesn't have to be in the list.
//              If it isn't, it's not denied
//
//---------------------------------------------------------------

SCODE CChildInstanceList::IsDenied(CDfName const *pdfn,
                                   DFLAGS const dfCheck,
                                   DFLAGS const dfAgainst)
{
    PRevertable *prv;
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::IsDenied("
                "%p, %lX, %lX)\n", pdfn, dfCheck, dfAgainst));

    olAssert(pdfn != NULL && aMsg("IsDenied, null name"));

    // Check to see if permissions are less restrictive than
    // parent permissions
    // This checks to see that a child isn't specifying
    // a permission that its parent doesn't
    // For example, giving read permission when the parent
    // doesn't
    if ((~dfAgainst & dfCheck & DCANTSET) 
        ||
        (dfAgainst & ~dfCheck & CANTCLEAR))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // Check for DENY_*
    olAssert((DF_DENYALL >> DF_DENIALSHIFT) == DF_READWRITE);
    for (prv = _prvHead; prv != NULL; prv = prv->GetNext())
    {
        if (prv->_dfn.IsEqual(pdfn))
        {
            // Check for existing instance with DENY_* mode
            if ((((prv->GetDFlags() & DF_DENYALL) >> DF_DENIALSHIFT) &
                 dfCheck) != 0 ||
            // Check for instance with permission already given that
            // new instance wants to deny
                (((dfCheck & DF_DENYALL) >> DF_DENIALSHIFT) &
                 prv->GetDFlags()) != 0)
            {
                sc = STG_E_ACCESSDENIED;
                break;
            }
        }
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::IsDenied\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::RenameChild, public
//
//  Synopsis:   Renames the child
//
//  Arguments:  [pdfn] - old name
//              [pdfnName] - new name
//
//  Notes:      The entry might exist
//
//---------------------------------------------------------------

void CChildInstanceList::RenameChild(
        CDfName const *pdfn,
        CDfName const *pdfnNewName)
{
    PRevertable *prv;

    olDebugOut((DEB_ITRACE, "In CChildInstanceList::RenameChild(%p, %p)\n",
                pdfn, pdfnNewName));
    for (prv = _prvHead; prv; prv = prv->_prvNext)
    {
        if (prv->_dfn.IsEqual(pdfn))
        {
            prv->_dfn.Set(pdfnNewName->GetLength(), pdfnNewName->GetBuffer());
            break;
        }
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::RenameChild\n"));
}

#ifdef NEWPROPS
//+---------------------------------------------------------------------------
//
//  Member:     CChildInstanceList::FlushBufferedData, private
//
//  Synopsis:   Calls each child, instructing it to flush property data.
//
//  Returns:    SCODE
//
//----------------------------------------------------------------------------

SCODE CChildInstanceList::FlushBufferedData(void)
{
    PRevertable *prv;
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::FlushBufferedData:%p\n",
                this));

    for (prv = _prvHead; prv && sc == S_OK; prv = prv->_prvNext)
    {
        sc = prv->FlushBufferedData();
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::FlushBufferedData\n"));
    return sc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\difat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       difat.cxx
//
//  Contents:   Double Indirected Fat Code
//
//  Classes:    None.
//
//  Functions:
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/difat.hxx"
#include "mread.hxx"


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::CDIFat, public
//
//  Synopsis:   CDIFat constructor
//
//  Arguments:  [cbSector] -- size of a sector
//
//--------------------------------------------------------------------------

CDIFat::CDIFat(USHORT cbSector)
:   _pmsParent(NULL),
    _fv( SIDDIF,
         (FSOFFSET) (cbSector / sizeof(SECT)),
         (FSOFFSET) ((cbSector / sizeof(SECT)) - 1) )
{
    msfDebugOut((DEB_TRACE,"In CDIFat constructor\n"));
    _cfsTable = 0;
    msfDebugOut((DEB_TRACE,"Out CDIFat constructor\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CDIFat::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------

void CDIFat::Empty(void)
{
    _fv.Empty();
    _pmsParent = NULL;
    _cfsTable = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CIDFat::Flush, private
//
//  Synopsis:   Flush a sector to disk
//
//  Arguments:  none
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Write sector up to parent mstream.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Flush(void)
{
    return _fv.Flush();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::GetFatSect, public
//
//  Synopsis:   Given an offset into the Fat chain, return the sector
//              value for that FatSect.
//
//  Arguments:  [oSect] -- offset in Fat chain
//              [psect]  -- pointer to returned sector
//
//  Modifies:   [*psect]
//
//  Returns:    Sector value of FatSect.
//
//  Algorithm:  If sector is stored in the header, retrieve it from
//                  there.
//              If not, retrieve it from the FatVector.
//
//--------------------------------------------------------------------------

SCODE CDIFat::GetFatSect(const FSINDEX oSect, SECT *psect)
{
    SCODE sc = S_OK;
    SECT sectReturn;

    msfDebugOut((DEB_TRACE,"In CDIFat::GetFatSect(%lu)\n",oSect));
    if (oSect < CSECTFAT)
    {
        msfDebugOut((DEB_ITRACE,"Getting sect from header\n"));
        sectReturn = _pmsParent->GetHeader()->GetFatSect(oSect);
    }
    else
    {
        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(oSect,&ipfs,&isect);

        msfAssert(ipfs < _cfsTable);

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
        sectReturn = pfs->GetSect(isect);
        _fv.ReleaseTable(ipfs);
    }

    msfDebugOut((DEB_TRACE,"Out CDIFat::GetFatSect(%lu)=>%lu\n",oSect,sectReturn));
    *psect = sectReturn;

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::SetFatSect, public
//
//  Synopsis:   Given an offset into the Fat chain, set the sector
//              value.
//
//  Arguments:  [oSect] -- Offset into fat chain
//              [sect] -- New sector value for that offset.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  If the sector is stored in the header, set it and
//                  flush the header.
//              Otherwise, if the sector will not fit in the current
//                  CFatVector, resize it.
//              Set the sector in the FatVector and flush it.
//
//--------------------------------------------------------------------------

SCODE CDIFat::SetFatSect(const FSINDEX oSect, const SECT sect)
{
    msfDebugOut((DEB_TRACE,"In CDIFat::SetFatSect(%lu,%lu)\n",oSect,sect));
    SCODE sc = S_OK;

    if (oSect < CSECTFAT)
    {
        msfDebugOut((DEB_ITRACE,"Setting sect in header: %lu, %lu\n",oSect,sect));
        _pmsParent->GetHeader()->SetFatSect(oSect, sect);
    }
    else
    {
        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(oSect,&ipfs,&isect);
        if (ipfs >= _cfsTable)
        {
            msfChk(Resize(_cfsTable + 1));
        }

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));

        pfs->SetSect(isect, sect);
        _fv.ReleaseTable(ipfs);
        
        msfDebugOut((DEB_TRACE,"In CDIFat::SetFatSect(%lu,%lu)\n",oSect,sect));
    }

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::GetSect, public
//
//  Synopsis:   Given an offset into the DIFat chain, return the
//              sector value
//
//  Arguments:  [oSect] -- Offset into DIFat chain.
//              [psect] -- pointer to returned sector
//
//  Modifies:   [*psect]
//
//  Returns:    Sector value for given offset.
//
//  Algorithm:  Retrieve the information from the NextFat fields of
//                  the CFatVector
//
//--------------------------------------------------------------------------

SCODE CDIFat::GetSect(const FSINDEX oSect, SECT *psect)
{
    SCODE sc = S_OK;

    SECT sectReturn;

    msfDebugOut((DEB_TRACE,"In CDIFat::GetSect(%lu)\n",oSect));
    msfAssert(oSect < _cfsTable);

    if (oSect == 0)
    {
        sectReturn = _pmsParent->GetHeader()->GetDifStart();
    }
    else
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(oSect - 1, FB_NONE, &pfs));

        sectReturn = pfs->GetNextFat(_fv.GetSectTable());
        _fv.ReleaseTable(oSect - 1);
    }

    msfDebugOut((DEB_TRACE,"Out CDIFat::GetSect(%lu)=>%lu\n",oSect,sectReturn));
    *psect = sectReturn;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Init, public
//
//  Synopsis:   Init function for previously stored DIFat.
//
//  Arguments:  [pmsParent] -- pointer to stream parent
//              [cFatSect] -- Length of DIFat in sectors
//
//  Returns:    S_OK if call completed properly.
//
//  Algorithm:  Initialize all the variables
//
//--------------------------------------------------------------------------

SCODE CDIFat::Init(CMStream * pmsParent, const FSINDEX cFatSect)
{
    msfDebugOut((DEB_TRACE,"In CDIFat::Init(%lu)\n",cFatSect));
    SCODE sc;

    _pmsParent = pmsParent;
    
    msfChk(_fv.Init(_pmsParent, cFatSect));

    _cfsTable = cFatSect;

    msfDebugOut((DEB_TRACE,"Out CDIFat::Init(%lu)\n",cFatSect));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::InitConvert, public
//
//  Synopsis:   Init function for conversion
//
//  Arguments:  [pmsParent] -- pointer to stream parent
//              [sectMax] -- Last used sector in existing file  
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  See below
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::InitConvert(CMStream *pmsParent, SECT sectMax)
{
    msfDebugOut((DEB_TRACE,"In CDIFat::InitConvert(%lu)\n",sectMax));
    SCODE sc;

    _pmsParent = pmsParent;

    USHORT cbSector = _pmsParent->GetSectorSize();
    FSOFFSET csectPer = (FSOFFSET) (cbSector / sizeof(SECT));

    FSINDEX csectFat = 0;
    FSINDEX csectFatLast;
    
    FSINDEX csectDif = 0;
    FSINDEX csectDifLast;
    do
    {
        //Number of fat sectors needed to represent:
        //    Number of Data Sectors (sectMax) +
        //    Number of Fat Sectors (csectFat) +
        //    Number of DIF sectors (csectDif) +
        //    Number of Directory Sectors (1)

        //We must use a loop here, since the fat must be large
        //    enough to represent itself and the DIFat.  See
        //    CFat::InitConvert for a more lengthy discussion of
        //    this method.

        csectFatLast = csectFat;
        
        csectFat = (sectMax + csectFatLast + csectDif + 1 + csectPer - 1) /
            csectPer;
        
        csectDifLast = csectDif;

        if (csectFat < CSECTFAT)
        {
            csectDif = 0;
        }
        else
        {
            FSOFFSET ciSect;

            SectToPair(csectFat, &csectDif, &ciSect);
            csectDif++;
        }
    }
    while ((csectDif != csectDifLast) || (csectFat != csectFatLast));

    
    _cfsTable = csectDif;
    
    msfChk(_fv.Init(_pmsParent, _cfsTable));

    _pmsParent->GetHeader()->SetDifLength(_cfsTable);

    if (_cfsTable > 0)
    {
        _pmsParent->GetHeader()->SetDifStart(sectMax);

        FSINDEX i;
        for (i = 0; i < _cfsTable; i++)
        {
            CFatSect *pfs;

            msfChk(_fv.GetTable(i, FB_NEW, &pfs));
            _fv.SetSect(i, sectMax);
            
            sectMax++;
            pfs->SetNextFat(_fv.GetSectTable(),sectMax);
            _fv.ReleaseTable(i);
        }
    }

    msfDebugOut((DEB_TRACE,"Out CDIFat::InitConvert()\n"));

Err:
    return sc;
}





//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Resize, private
//
//  Synopsis:   Resize an existing DIFat.
//
//  Arguments:  [fsiSize] -- New size for object
//
//  Returns:    S_OK if success
//
//  Algorithm:  
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Resize(FSINDEX fsiSize)
{
    msfDebugOut((DEB_TRACE,"In CDIFat::Resize(%lu)\n",fsiSize));
    msfAssert(fsiSize == _cfsTable + 1);

    SCODE sc;

    msfChk(_fv.Resize(fsiSize));
    ULONG ipfs;
    ipfs = fsiSize - 1;

    CFatSect *pfs;
    msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));

    FSINDEX csect;
    csect = _cfsTable;
    _cfsTable = fsiSize;

    SECT sectNew;

    msfChk(_pmsParent->GetFat()->GetFree(1, &sectNew));
    msfChk(_pmsParent->GetFat()->SetNext(sectNew, DIFSECT));           
    
    _fv.SetSect(ipfs, sectNew);
    _fv.ReleaseTable(ipfs);

    if (csect == 0)
    {
        _pmsParent->GetHeader()->SetDifStart(sectNew);
    }
    else
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(csect - 1, FB_DIRTY, &pfs));

        pfs->SetNextFat(_fv.GetSectTable(),sectNew);
        _fv.ReleaseTable(csect - 1);
    }

    _pmsParent->GetHeader()->SetDifLength(_cfsTable);
    
    msfDebugOut((DEB_TRACE,"Out CDIFat::Resize(%lu)\n",fsiSize));

Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\dfstream.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       dfstream.cxx
//
//  Contents:   Implementations of CDocFile stream methods
//
//---------------------------------------------------------------

#include "dfhead.cxx"
#include "h/sstream.hxx"

//+--------------------------------------------------------------
//
//  Method:     CDocFile::CreateStream, public
//
//  Synopsis:   Creates a named stream in a DocFile
//
//  Arguments:  [pwcsName] - Name of the stream
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [ppstStream] - Pointer to storage for the stream pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:   [ppstStream]
//
//---------------------------------------------------------------


SCODE CDocFile::CreateStream(CDfName const *pdfn,
                             DFLAGS const df,
                             DFLUID dlSet,
                             CDirectStream **ppstStream)
{
    SCODE sc;
    CDirectStream *pstm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CreateStream("
            "%ws, %X, %lu, %p)\n",
                pdfn, df, dlSet, ppstStream));
    UNREFERENCED_PARM(df);

    if (dlSet == DF_NOLUID)
        dlSet = CDirectStream::GetNewLuid();
    olMem(pstm = new CDirectStream(dlSet));    
    olChkTo(EH_pstm, pstm->Init(&_stgh, pdfn, TRUE));

    *ppstStream = pstm;
    olDebugOut((DEB_ITRACE, "Out CDocFile::CreateStream => %p\n",
                *ppstStream));
    return S_OK;

EH_pstm:
    delete pstm;
EH_Err:    
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CDocFile::GetStream, public
//
//  Synopsis:   Retrieves an existing stream from a DocFile
//
//  Arguments:  [pwcsName] - Name of the stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppstStream] - Pointer to storage for the stream pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:   [ppstStream]
//
//---------------------------------------------------------------



SCODE CDocFile::GetStream(CDfName const *pdfn,
                          DFLAGS const df,
                          CDirectStream **ppstStream)
{
    SCODE sc;
    CDirectStream *pstm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetStream(%ws, %X, %p)\n",
                pdfn, df, ppstStream));
    UNREFERENCED_PARM(df);

    DFLUID dl = CDirectStream::GetNewLuid();
    olMem(pstm = new CDirectStream(dl));
    
    olChkTo(EH_pstm, pstm->Init(&_stgh, pdfn, FALSE));
    *ppstStream = pstm;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetStream => %p\n",
                *ppstStream));
    return S_OK;

EH_pstm:
    delete pstm;
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\dir.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       dir.cxx
//
//  Contents:   Directory Functions
//
//---------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"
#include "mread.hxx"

#define DEB_DIR (DEB_ITRACE | 0x00040000)

//+-------------------------------------------------------------------------
//
//  Member:     CMStream::KillStream, public
//
//  Synopsis:   Eliminate a given chain
//
//  Arguments:  [sectStart] -- Beginning of chain to eliminate
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  
//
//  Notes:
//
//--------------------------------------------------------------------------

inline SCODE CMStream::KillStream(SECT sectStart, ULONG ulSize)
{
    CFat *pfat;

    pfat = (ulSize < MINISTREAMSIZE) ?&_fatMini: &_fat;

    return pfat->SetChainLength(sectStart, 0);
}


//+-------------------------------------------------------------------------
//
//  Member:     GetNewDirEntryArray, public
//
//  Synopsis:   Obtain a new array of CDirEntry(s)
//
//  Arguments:  [cbSector] -- size of a sector
//
//  Returns:    New CDirEntry array
//
//  Algorithm:  calculates the number of entries need for the array and
//              allocate it
//
//  Notes:
//
//--------------------------------------------------------------------------

inline CDirEntry* GetNewDirEntryArray(USHORT cbSector)
{
    CDirEntry *temp;

    DIROFFSET cdeEntries = (USHORT) (cbSector / sizeof(CDirEntry));

    temp = new CDirEntry[cdeEntries];
    return temp;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirEntry::Init, public
//
//  Synopsis:   Initializes member data
//
//  Arguments:  [mse] -- multi-stream entry flags for the directory entry
//
//  Returns:    void
//
//  Algorithm:  
//
//  Notes:
//
//--------------------------------------------------------------------------

inline void CDirEntry::Init(MSENTRYFLAGS mse)
{
    msfAssert(sizeof(CDirEntry) == DIRENTRYSIZE);
    
    msfAssert(mse <= 0xff);
    _mse = (BYTE) mse;
    _bflags = 0;

    _dfn.Set((WORD)0, (BYTE *)NULL);
    _sidLeftSib = _sidRightSib = _sidChild = NOSTREAM;

    if (STORAGELIKE(_mse))
    {
        _clsId = IID_NULL;
        _dwUserFlags = 0;
    }
    if (STREAMLIKE(_mse))
    {
        _sectStart = ENDOFCHAIN;
        _ulSize = 0;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirEntry::CDirEntry, public
//
//  Synopsis:   Constructor for CDirEntry class
//
//  Effects:
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirEntry::CDirEntry()
{
    msfAssert(sizeof(CDirEntry) == DIRENTRYSIZE);
    Init(STGTY_INVALID);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirSect::Init, public
//
//  Synopsis:   Initializer for directory sectors
//
//  Arguments:  [cdeEntries] -- Number of DirEntries in the sector
//
//  Returns:    S_OK if call completed OK.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirSect::Init(USHORT cbSector)
{
    msfDebugOut((DEB_DIR,"Allocating sector with size %u\n",cbSector));

    DIROFFSET cdeEntries = (USHORT) (cbSector / sizeof(CDirEntry));

    for (ULONG i = 0; i < cdeEntries; i++)
    {
        _adeEntry[i].Init(STGTY_INVALID);
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::CDirectory
//
//  Synopsis:   Default constructor
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirectory::CDirectory(USHORT cbSector)
        : _pmsParent(NULL),
          _dv(cbSector)
{
    _cdsTable = _cdeEntries = 0;
    _sidFirstFree = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectory::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------

void CDirectory::Empty(void)
{
    _dv.Empty();
    _pmsParent = NULL;
    _cdsTable = 0;
    _cdeEntries = 0;
    _sidFirstFree = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::GetFree, public
//
//  Synposis:   Locates a free directory entry
//
//  Arguments:  [psid] Stream ID of free directory entry.
//
//  Returns:    S_OK if successful
//
//  Algorithm:  Do a linear search of all available directories.
//              If no free spot is found, resize the directory and
//              perform the search again.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::GetFree(SID* psid)
{
    msfDebugOut((DEB_DIR,"In CDirectory::GetFree()\n"));

    SCODE sc = S_OK;
    SID sidRet = NOSTREAM;
    CDirSect * pds;

    DIRINDEX ipdsStart;
    DIROFFSET ideStart;

    SidToPair(_sidFirstFree, &ipdsStart, &ideStart);
    while (TRUE)
    {
	DIRINDEX ipds;
        for (ipds = ipdsStart; ipds < _cdsTable; ipds++)
        {
            msfChk(_dv.GetTable(ipds, FB_NONE, &pds));
            for (DIROFFSET ide = ideStart; ide < _cdeEntries; ide++)
            {
                if (pds->GetEntry(ide)->IsFree())
                {
                    msfDebugOut((DEB_ITRACE,"GetFree found sid %lu\n",
                            PairToSid(ipds,ide)));

                    *psid = PairToSid(ipds, ide);
                    _sidFirstFree = *psid + 1;
                    _dv.ReleaseTable(ipds);
                    return S_OK;
                }
            }
            _dv.ReleaseTable(ipds);
            ideStart = 0;
        }
        ipdsStart = ipds;
        msfChk(Resize(_cdsTable+1));
    }

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::FindGreaterEntry
//
//  Synopsis:   finds next entry (for iteration)
//
//  Arguments:  [sidStart]   -- child sid to start looking
//		[pdfn]       -- previous entry name
//		[psidResult] -- place holder for returned sid
//
//  Requires:   sidStart != NOSTREAM
//
//  Returns:    S_OK, STG_E_NOMOREFILES, or other error
//
//  Modifies:   psidResult
//
//  Algorithm:  Iterate by returning the sid that has a name larger
//		than the given name.
//
//  Notes:      This method is called recursively
//
//--------------------------------------------------------------------------

SCODE CDirectory::FindGreaterEntry(SID sidStart, CDfName const *pdfn, 
                                   SID *psidResult)
{
    SCODE sc;
    CDirEntry *pde;
    msfAssert(sidStart != NOSTREAM);

    msfChk(GetDirEntry(sidStart, FB_NONE, &pde));

    int iCmp;
    iCmp = NameCompare(pdfn, pde->GetName());

    if (iCmp < 0)
    {
        //  Since the last name returned is less than this name,
        //  the sid to return must either be to our left or this sid

        SID sidLeft = pde->GetLeftSib();

        //  We can't hold onto sidStart as we recurse, (because we'll ask for
        //  a page each time we recurse)

        ReleaseEntry(sidStart);
        if (sidLeft == sidStart)
        {
            //Corrupt docfile - return error.
            return STG_E_DOCFILECORRUPT;
        }

        if ((sidLeft == NOSTREAM) ||
            (sc = FindGreaterEntry(sidLeft, pdfn, psidResult)) == STG_E_NOMOREFILES)
        {
            //  There was no left child with a name greater than pdfn, so
            //  we return ourself

            *psidResult = sidStart;
            sc = S_OK;
        }
    }
    else
    {
        //  The last name returned is greater than this one, so we've already
        //  returned this sidStart.  Look in the right subtree.

        SID sidRight = pde->GetRightSib();

        //  We can't hold onto sidStart as we recurse, (because we'll ask for
        //  a page each time we recurse)

        ReleaseEntry(sidStart);

        if (sidRight == sidStart)
        {
            //Corrupt docfile - return error.
            return STG_E_DOCFILECORRUPT;
        }

        if (sidRight == NOSTREAM)
            sc = STG_E_NOMOREFILES;
        else
            sc = FindGreaterEntry(sidRight, pdfn, psidResult);
    }
Err:
    return(sc);
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::SetStart, public
//
//  Synopsis:   Set starting sector for a dir entry
//
//  Arguments:  [sid] -- SID of entry to be modified
//              [sect] -- New starting sector for entry
//
//  Returns:    SID of modified entry
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::SetStart(const SID sid, const SECT sect)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetStart(sect);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetChild, public
//
//  Synposis:   Set the child SID of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [sidChild] -- SID of first child of this stream
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change child field on entry, then write to stream.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetChild(const SID sid, const SID sidChild)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetChild(sidChild);
    ReleaseEntry(sid);

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetSize, public
//
//  Synposis:   Set the size of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [cbSize] -- Size
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change size field on entry, then write to stream.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetSize(const SID sid, const ULONG cbSize)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetSize(cbSize);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetTime, public
//
//  Synposis:   Set the time of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [tt] - WT_*
//              [nt] - New time
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change time field on entry, then write to stream.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetTime(const SID sid, WHICHTIME tt, TIME_T nt)
{
    SCODE sc;

    CDirEntry *pde;

    // We don't support ACCESS times, so just ignore sets
    if (tt == WT_ACCESS)
        return S_OK;
    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetTime(tt, nt);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetFlags, public
//
//  Synposis:   Set the flags of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [mse] - New flags
//
//  Returns:    Status code
//
//  Algorithm:  Change Luid field on entry, then write to stream.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetFlags(const SID sid, const MSENTRYFLAGS mse)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetFlags(mse);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetClassId, public
//
//  Synposis:   Set the class ID of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [cls] - Class ID
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetClassId(const SID sid, const GUID cls)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetClassId(cls);
    ReleaseEntry(sid);
 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetUserFlags, public
//
//  Synposis:   Set the user flags of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [dwUserFlags] - Flags
//              [dwMask] - Mask
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetUserFlags(SID const sid,
                                        DWORD dwUserFlags,
                                        DWORD dwMask)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetUserFlags(dwUserFlags, dwMask);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::resize, private
//
//  Synposis:   Resize a directory.
//
//  Effects:    Reallocates space for directory table, copying over
//              old pointers as necessary.  Any new tables needed are
//              created here.
//
//  Arguments:  [uNewsize] -- New size for Directory
//
//  Returns:    void
//
//  Algorithm:  Allocate a new array of pointers of the necessary size.
//              Then, copy over all pointers from old array and allocate
//              new CDirSects for all new tables.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::Resize(DIRINDEX uNewsize)
{
    msfDebugOut((DEB_DIR,"In CDirectory::Resize(%i)\n",uNewsize));
    SCODE sc;

    if (uNewsize == _cdsTable) return S_OK;

    SECT sect;
    //GetESect call will make sure we have enough Fat space.
    msfChk(_pmsParent->GetESect(SIDDIR, uNewsize - 1, &sect));

        msfChk(_pmsParent->SetSize());

    msfChk(_dv.Resize(uNewsize));

    ULONG ipds;
    for (ipds = _cdsTable; ipds < uNewsize; ipds++)
    {
        CDirSect *pds;
        msfChk(_dv.GetTable(ipds, FB_NEW, &pds));
        
        SECT sect;
        msfChk(_pmsParent->GetESect(SIDDIR, ipds, &sect));
        _dv.SetSect(ipds, sect);
        _dv.ReleaseTable(ipds);
    }

    _cdsTable = uNewsize;

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::Init, public
//
//  Synposis:   Sets up a Directory instance and reads in all tables
//              from the stream
//
//  Arguments:  [cSect] -- Number of sectors in directory
//
//  Returns:    S_OK if call completed OK.
//              STG_E_READFAULT if not enough bytes were read for
//                                  a DirSector
//              Error code of read if read returned an error.
//
//  Algorithm:  Create array to hold appropriate number of tables.
//              Read in each table from disk.
//
//---------------------------------------------------------------------------

SCODE CDirectory::Init(
        CMStream *pmsParent,
        DIRINDEX cSect)
{
    msfDebugOut((DEB_DIR,"In CDirectory::Init(%lu)\n",cSect));
    SCODE sc;

    _pmsParent = pmsParent;

    _cdeEntries = (DIROFFSET) 
        ( _pmsParent->GetSectorSize() / sizeof(CDirEntry));

    msfChk(_dv.Init(_pmsParent, cSect));

    _cdsTable = cSect;

    msfDebugOut((DEB_DIR,"Out CDirectory::Init()\n"));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InitNew, public
//
//  Synposis:   Sets up a new Directory instance for a new Mstream
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//              STG_E_WRITEFAULT if not enough bytes were written.
//              Error code of write if write failed.
//
//  Algorithm:  Write initial DirSector to disk.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::InitNew(CMStream *pmsParent)
{
    SCODE sc;
#ifndef _MSC_VER
    #define ROOT_ENTRY "Root Entry"
    WCHAR *wcsRoot = new WCHAR[sizeof(ROOT_ENTRY)+1];
    _tbstowcs(wcsRoot, ROOT_ENTRY, sizeof(ROOT_ENTRY));
    CDfName const dfnRoot(wcsRoot);
#else
    CDfName const dfnRoot(L"Root Entry");
#endif

    msfDebugOut((DEB_DIR,"In CDirectory::setupnew()\n"));
    _pmsParent = pmsParent;

    _cdeEntries = (DIROFFSET)
        (_pmsParent->GetSectorSize() / sizeof(CDirEntry));

    msfChk(_dv.Init(_pmsParent, 1));

    CDirSect *pds;

    msfChk(_dv.GetTable(0, FB_NEW, &pds));
    _dv.SetSect(0, _pmsParent->GetHeader()->GetDirStart());
    _dv.ReleaseTable(0);

    _cdsTable = 1;

    SID sidRoot;

    msfChk(GetFree(&sidRoot));
    CDirEntry *pdeTemp;

    msfChk(GetDirEntry(sidRoot, FB_DIRTY, &pdeTemp));
    pdeTemp->Init(STGTY_ROOT);

    msfAssert(sidRoot == SIDROOT);

    pdeTemp->SetName(&dfnRoot);

    ReleaseEntry(sidRoot);

    msfDebugOut((DEB_DIR,"Exiting CDirectory::setupnew()\n"));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::CreateEntry, public
//
//  Synopsis:   Create a new directory entry
//
//  Arguments:  [sidParent] -- SID of parent for new entry
//		[pwcsName] -- Name of new entry
//		[mef] -- Flags for new entry
//		[psidNew] -- Return location for new SID
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Search directory for entry of the same name.  If one
//              is found, return STG_E_FILEALREADYEXISTS.
//              If not, create a new entry and return its SID.
//
//--------------------------------------------------------------------------


SCODE CDirectory::CreateEntry(
	SID sidParent,
	CDfName const *pdfn,
	MSENTRYFLAGS mef,
	SID *psidNew)
{
    SCODE sc;
    SID sidNew;
    CDirEntry *pdeNew;
    SEntryBuffer eb;

    sc = IsEntry(sidParent, pdfn, &eb);
    if (sc != STG_E_FILENOTFOUND)
    {
        if (SUCCEEDED(sc))
            sc = STG_E_FILEALREADYEXISTS;

        return(sc);
    }

    //  Allocate new sid

    msfChk(GetFree(psidNew));
    sidNew = *psidNew;

    msfChk(GetDirEntry(sidNew, FB_DIRTY, &pdeNew));

    //  Initialize new entry

    pdeNew->Init(mef);

    TIME_T timetemp;
    DfGetTOD(&timetemp);

    pdeNew->SetTime(WT_CREATION, timetemp);
    pdeNew->SetTime(WT_MODIFICATION, timetemp);
    pdeNew->SetName(pdfn);

    ReleaseEntry(sidNew);

    //  Insert new entry into the tree

    msfChk(InsertEntry(sidParent, sidNew, pdfn));

Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::RenameEntry, public
//
//  Synopsis:   Rename an entry
//
//  Arguments:  [sidParent] -- Sid of parent of entry to be renamed
//              [pwcsName] -- Old name of entry to be renamed
//              [pwcsName] -- New name
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Remove old entry
//		Rename entry
//		Insert as new entry
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CDirectory::RenameEntry(SID const sidParent,
        CDfName const *pdfn,
        CDfName const *pdfnNew)
{
    //  Make sure new name doesn't already exist
    SCODE sc;
    SEntryBuffer eb;

    sc = IsEntry(sidParent, pdfnNew, &eb);
    if (sc != STG_E_FILENOTFOUND)
    {
        if (SUCCEEDED(sc))
        {
            //  Entry did exist - fail this call
            sc = STG_E_ACCESSDENIED;
        }

        return(sc);
    }

    //  We can't just rename in place (because the tree is ordered)

    CDirEntry *pdeRename;
    SEntryBuffer ebRename;

    msfChk(FindEntry(sidParent, pdfn, DEOP_REMOVE, &ebRename));

    sc = GetDirEntry(ebRename.sid, FB_DIRTY, &pdeRename);

    msfAssert(SUCCEEDED(sc) && aMsg("Could get dir entry to rename"));

    msfChk(sc);

    pdeRename->SetName(pdfnNew);

    ReleaseEntry(ebRename.sid);

    //  If this InsertEntry fails, we've potentially lost the entry. This
    //  doesn't matter becase:
    //  a)  The only way we could fail is if we couldn't read or write
    //      the disk (hard error)
    //  b)  No one's going to call RenameEntry anyways
    //  c)  If we're transacted, the whole operation is made robust by
    //      CopyOnWrite mode
    //  d)  If we're direct, we already know we can fail in ways that leave
    //      the Docfile corrupt.

    sc = InsertEntry(sidParent, ebRename.sid, pdfnNew);

    msfAssert(SUCCEEDED(sc) && aMsg("Couldn't reinsert renamed dir entry"));

    msfChk(sc);

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::DestroyAllChildren
//
//  Synopsis:   destroy all child entries
//
//  Effects:    destroys child tree
//
//  Arguments:  [sidParent] -- storage entry
//
//  Returns:    S_OK or error code
//
//  Modifies:   sidParent's entry
//
//  Algorithm:  While there's a child
//		  destroy it
//
//  Notes:	We may want to consider a more efficient implementation
//
//--------------------------------------------------------------------------


SCODE CDirectory::DestroyAllChildren(
	SID const sidParent)
{
    SCODE sc;
    CDirEntry *pdeParent, *pdeChild;
    SID sidChild;
    CDfName dfnChild;

    for (;;)
    {
        CDfName dfnChild;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));
        sidChild = pdeParent->GetChild();
        ReleaseEntry(sidParent);

        if (sidChild == NOSTREAM)
            break;

        msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));

        dfnChild.Set(pdeChild->GetName());
        ReleaseEntry(sidChild);

        msfChk(DestroyChild(sidParent, &dfnChild));
    }

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::DestroyChild
//
//  Synopsis:   destroy a named child
//
//  Effects:    destroys named child's entry
//
//  Arguments:  [sidParent] -- storage entry
//		[pdfn]      -- child name
//
//  Returns:    S_OK, STG_E_FILENOTFOUND, or other error code
//
//  Modifies:   child's entry
//
//  Algorithm:  Find and remove child
//		Free child entry
//
//--------------------------------------------------------------------------

SCODE CDirectory::DestroyChild(
	SID const sidParent,
        CDfName const *pdfn)
{
    SCODE sc;
    SEntryBuffer ebChild;

    msfAssert(pdfn != NULL);

    //  remove the entry from the tree

    msfChk(FindEntry(sidParent, pdfn, DEOP_REMOVE, &ebChild));

    msfAssert(ebChild.sid != NOSTREAM);

    //  Before we remove this entry, we need to destroy it (including all
    //  its children).  Note that we can't hold onto the entry because it
    //  might have children which get destroyed, which have children which
    //  get destroyed, etc.

    if (STORAGELIKE(ebChild.dwType))
    {
        msfChk(DestroyAllChildren(ebChild.sid));
    }

    CDirEntry *pdeChild;
    msfChk(GetDirEntry(ebChild.sid, FB_DIRTY, &pdeChild));

    if (STREAMLIKE(ebChild.dwType))
    {
        //  Deallocate any used streams
        msfChkTo(EH_Rel, _pmsParent->KillStream(pdeChild->GetStart(),
				                pdeChild->GetSize()));
    }

    pdeChild->SetFlags(STGTY_INVALID);
    if (ebChild.sid < _sidFirstFree)
    {
        _sidFirstFree = ebChild.sid;
    }

EH_Rel:
    ReleaseEntry(ebChild.sid);

Err:
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::StatEntry
//
//  Synopsis:   For a given handle, fill in the Multistream specific
//                  information of a STATSTG.
//
//  Arguments:  [sid] -- SID that information is requested on.
//              [pName] -- name of the next key to fill in
//              [pstatstg] -- STATSTG to fill in.
//
//  Returns:    S_OK
//
//  Modifies:   [pName] -- if it is not null
//              [pstatstg] -- if it is not null
//
//  Algorithm:  Fill in time information and size and then return
//
//--------------------------------------------------------------------------


SCODE CDirectory::StatEntry(SID const sid, 
                                     CDfName *pName,
                                     STATSTGW *pstatstg)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_NONE, &pde));
    
    if (pName)
    {
        pName->Set(pde->GetName());
    }
    if (pstatstg)
    {        
        pstatstg->type = pde->GetFlags();
        // allocate memory
        msfChk(DfAllocWCS((WCHAR *)pde->GetName()->GetBuffer(),
                          &pstatstg->pwcsName)); 
        wcscpy(pstatstg->pwcsName, (WCHAR*) pde->GetName()->GetBuffer());

        pstatstg->mtime = pde->GetTime(WT_MODIFICATION);
        pstatstg->ctime = pde->GetTime(WT_CREATION);
        pstatstg->atime = pstatstg->mtime; // don't currently keep access times

        // Don't use REAL_STGTY here because we want this
        // to function properly for both property and non-property builds
        if ((pstatstg->type & STGTY_REAL) == STGTY_STORAGE)
        {
            ULISet32(pstatstg->cbSize, 0);
            pstatstg->clsid = pde->GetClassId();
            pstatstg->grfStateBits = pde->GetUserFlags();
        }
        else
        {
            ULISet32(pstatstg->cbSize, pde->GetSize());
            pstatstg->clsid = CLSID_NULL;
            pstatstg->grfStateBits = 0;
        }
    }

Err:
    ReleaseEntry(sid);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::GetDirEntry
//
//  Synopsis:   Get a directory entry with given permissions
//
//  Arguments:  [sid]     -- SID
//              [dwFlags] -- permissions
//              [ppde]    -- placeholder for directory entry
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//--------------------------------------------------------------------------


SCODE CDirectory::GetDirEntry(
	const SID sid,
	const DWORD dwFlags,
	CDirEntry **ppde)
{
    SCODE sc;
    CDirSect *pds;
    DIRINDEX id = sid / _cdeEntries;

    msfChk(_dv.GetTable(id, dwFlags, &pds));

    *ppde = pds->GetEntry((DIROFFSET)(sid % _cdeEntries));

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::ReleaseEntry
//
//  Synopsis:   Releases a directory entry
//
//  Arguments:  [sid]     -- SID
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//--------------------------------------------------------------------------

void CDirectory::ReleaseEntry(SID sid)
{
    _dv.ReleaseTable(sid / _cdeEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\exphead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       exphead.cxx
//
//  Contents:   Precompiled headers
//
//--------------------------------------------------------------------------
#ifdef _MSC_VER
// some of these warnings are a nuisance 
#pragma warning (disable:4514)  // unreferenced inline function
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "h/ref.hxx"
#include "h/dfexcept.hxx"
#include "h/msf.hxx"
#include "h/docfilep.hxx"
#include "expdf.hxx"
#include "h/funcs.hxx"
#include "h/piter.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\expdf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       expdf.cxx
//
//  Contents:   Exposed DocFile implementation
//
//  Notes:
//              The CExposedDocFile class is the implementation
//              of IStorage. It implements IPropertySetStorage
//              by inheriting from CPropertySetStorage. CPropertySetStorage
//              implements all the functionality of IPropertySetStorage.
//
//              Note that this interface is solely UNICODE, the ASCII layer
//              support which is present if _UNICODE is not defined, provides
//              the overloaded functions that handles the ASCII to Unicode
//              conversion. 
//
//---------------------------------------------------------------------------

// Initialize all the GUID's in ref.hxx
#ifdef INITGUID
#error "Something is Wrong: INIT_GUID should not be defined yet"
#else
#define INITGUID
#include "h/ref.hxx"
#endif

// enable memory leak detection if neccessary
#include "h/dbg.hxx"
 
#include "exphead.cxx"

#include "expdf.hxx"
#include "expst.hxx"
#include "expiter.hxx"
#include "logfile.hxx"
#include "h/rexpdf.hxx"
#include "h/docfilep.hxx"

// Check for proper single-instance flags
#define NOT_SINGLE(md) (((md) & STGM_DENY) != STGM_SHARE_EXCLUSIVE)

#define EnforceSingle(mode) (NOT_SINGLE(mode) ? STG_E_INVALIDFUNCTION : S_OK)
 
//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CExposedDocFile, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdf] - Public DocFile
//              [pdfb] - DocFile basis
//              [ppc] - Context
//              [fOwnContext] - Whether this object owns the context
//
//---------------------------------------------------------------


CExposedDocFile::CExposedDocFile(CExposedDocFile *pdfParent,
                                 CDocFile *pdf, 
                                 DFLAGS const df,
                                 DFLUID luid,
                                 ILockBytes *pilbBase,
                                 CDfName const *pdfn,
                                 CMStream* pmsBase,
                                 CDFBasis *pdfb)
#ifdef NEWPROPS
#ifdef _MSC_VER
#pragma warning(disable: 4355)
#endif // _MSC_VER
    : CPropertySetStorage(this)
#ifdef _MSC_VER
#pragma warning(default: 4355)
#endif // _MSC_VER
#endif // NEWPROPS
{
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CExposedDocFile(%p)\n",
                pdf));    
    _pdfb = pdfb;
    _pdfb->AddRef();
    _pdf = pdf;
    _df = df;
    _luid = luid;
    _pdfParent = pdfParent;
     // note: we don't addref here 'cos it is only done in the root
    _pilbBase = pilbBase;
    _pmsBase = pmsBase;
    if (pdfn) _dfn.Set(pdfn->GetLength(), pdfn->GetBuffer());
    else _dfn.Set((WORD)0, (BYTE*)NULL);
    if (!IsRoot())
        _pdfParent->AddChild(this);
    _fDirty = FALSE;
    _cReferences = 1;
    _ulAccessLockBase = 0;
    _sig = CEXPOSEDDOCFILE_SIG;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CExposedDocFile\n"));
    
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::~CExposedDocFile, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------

CExposedDocFile::~CExposedDocFile(void)
{
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::~CExposedDocFile\n"));
    olAssert(_cReferences == 0);
    if (_pdfb) _pdfb->Release();
    _sig = CEXPOSEDDOCFILE_SIGDEL;
    if (SUCCEEDED(CheckReverted()))
    {
        if (IsRoot()) {
            olDebugOut((DEB_TRACE, "Destr called for root\n"));
            olAssert(_pilbBase==NULL);  
        }
        else {
            _pdfParent->ReleaseChild(this);
        }
        _cilChildren.DeleteByName(NULL);
        if (_pdf) _pdf->Release();
    }
    olDebugOut((DEB_TRACE, "Out CExposedDocFile::~CExposedDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Release, public
//
//  Synopsis:   Releases resources for a CExposedDocFile
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CExposedDocFile::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CExposedDocFile::Release()\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Release()\n"));
    TRY 
    {
        if (FAILED(Validate())) return 0;
        olAssert(_cReferences > 0);
        lRet = AtomicDec(&_cReferences);
        if (_pdf && !P_TRANSACTED(_df) && SUCCEEDED(CheckReverted()))
        {
            TIME_T tm;
            olVerSucc(DfGetTOD(&tm));
            olVerSucc(_pdf->SetTime(WT_ACCESS, tm));
#ifdef NEWPROPS
            olVerSucc(FlushBufferedData());
#endif
            if (IsDirty())
            {
                olVerSucc(DfGetTOD(&tm));
                olVerSucc(_pdf->SetTime(WT_MODIFICATION, tm));
                if (!IsRoot())
                    _pdfParent->SetDirty();
                olAssert(P_WRITE(_df) &&
                          aMsg("Dirty & Direct but no write access"));
                SetClean();
            }
            if (IsRoot() && P_WRITE(_df))
            {
                SCODE sc;
                sc = _pmsBase->Flush(0);
#if DBG == 1
                if (FAILED(sc))
                {
                olDebugOut((DEB_ERROR,
                            "ILockBytes::Flush() failed in release path "
                            "with error %lx\n", sc));
                }
#endif            
            }
        }
        if (lRet == 0)
        {
            delete this;
        }
        else if (lRet < 0)
            lRet = 0;
    }
    CATCH(CException, e) 
    {
        UNREFERENCED_PARM(e);
        lRet = 0;
    }
    END_CATCH
        
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Release()\n"));
    olLog(("%p::Out CExposedDocFile::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return (ULONG)lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CheckCopyTo, private
//
//  Synopsis:   Checks for CopyTo legality
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

inline SCODE CExposedDocFile::CheckCopyTo(void)
{
    // it is an error to copy a parent to child
    return _pdfb->GetCopyBase() != NULL &&
        IsAtOrAbove(_pdfb->GetCopyBase()) ? STG_E_ACCESSDENIED : S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::ConvertInternalStream, private
//
//  Synopsis:   Converts an internal stream to a storage
//
//  Arguments:  [pwcsName] - Name
//              [pdfExp] - Destination docfile
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


static WCHAR const wcsIllegalName[] = {'\\','\0'};

SCODE CExposedDocFile::ConvertInternalStream(CExposedDocFile *pdfExp)
{
    CExposedStream *pstFrom=NULL, *pstTo=NULL;
    SCODE sc=S_OK;
    CDfName const dfnIllegal(wcsIllegalName);
    CDfName const dfnContents(wcsContents);

    olDebugOut((DEB_ITRACE, "In CExposedDocFile::ConvertInternalStream(%p)\n",
                pdfExp));

    olChk(GetExposedStream(&dfnIllegal, DF_READWRITE | DF_DENYALL,
                           &pstFrom));
    olChkTo(EH_pstFrom, 
            pdfExp->CreateExposedStream(&dfnContents, DF_WRITE | DF_DENYALL,
                                        &pstTo));
    olChkTo(EH_pstTo, CopyStreamToStream(pstFrom->GetDirectStream(), 
                                         pstTo->GetDirectStream()));
    olChkTo(EH_pstTo, DestroyEntry(&dfnIllegal, FALSE));

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::ConvertInternalStream\n"));
    // Fall through
EH_pstTo:
    pstTo->Release();
EH_pstFrom:
    pstFrom->Release();
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateEntry, private
//
//  Synopsis:   Creates elements, used in CreateStream, CreateStorage and
//              for properties
//
//  Arguments:  [pwcsName] - Name
//              [dwType] - Entry type
//              [grfMode] - Access mode
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//----------------------------------------------------------------------------

SCODE CExposedDocFile::CreateEntry(WCHAR const *pwcsName,
                                   DWORD dwType,
                                   DWORD grfMode,
                                   void **ppv)
{
    SCODE sc;
    SEntryBuffer eb;
    CDfName dfn;
    BOOL fRenamed = FALSE;
    CExposedStream *pstExp;
    CExposedDocFile *pdfExp;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CreateEntry:%p("
                "%ws, %lX, %lX, %p)\n", 
                this, pwcsName, dwType, grfMode, ppv));
    olChk(EnforceSingle(grfMode));
    olChk(CheckReverted());
    dfn.Set(pwcsName);

    if (grfMode & (STGM_CREATE | STGM_CONVERT))
    {
        if (FAILED(sc = _pdf->IsEntry(&dfn, &eb)))
        {
            if (sc != STG_E_FILENOTFOUND)
                olErr(EH_Err, sc);
        }
        else if (eb.dwType == dwType && (grfMode & STGM_CREATE))
            olChk(DestroyEntry(&dfn, FALSE));
        else if (eb.dwType == STGTY_STREAM && (grfMode & STGM_CONVERT) &&
                 dwType == STGTY_STORAGE)
        {
            CDfName const dfnIllegal(wcsIllegalName);
            olChk(RenameEntry(&dfn, &dfnIllegal));
            fRenamed = TRUE;
        }
        else
            olErr(EH_Err, STG_E_FILEALREADYEXISTS);
    }

    if (REAL_STGTY(dwType) == STGTY_STREAM)
    {
        olChk(CreateExposedStream(&dfn, ModeToDFlags(grfMode), &pstExp));
        *ppv = pstExp;
    }
    else
    {
        olAssert(REAL_STGTY(dwType) == STGTY_STORAGE);
        olChk(CreateExposedDocFile(&dfn, ModeToDFlags(grfMode), &pdfExp));
        // If we've renamed the original stream for conversion, convert
        if (fRenamed)
        {
            olChkTo(EH_pdfExpInit, ConvertInternalStream(pdfExp));
            sc = STG_S_CONVERTED;
        }
        *ppv = pdfExp;
    }
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CreateEntry\n"));
    return sc;

EH_pdfExpInit:
    pdfExp->Release();
    olVerSucc(DestroyEntry(&dfn, TRUE));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenEntry, private
//
//  Synopsis:   Opens elements, used in OpenStream, OpenStorage and
//              for properties
//
//  Arguments:  [pwcsName] - Name
//              [dwType] - Entry type
//              [grfMode] - Access mode
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::OpenEntry(WCHAR const *pwcsName,
                                 DWORD dwType,
                                 DWORD grfMode,
                                 void **ppv)
{
    CDfName dfn;
    SCODE sc;
    CExposedDocFile *pdfExp;
    CExposedStream *pstExp;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::OpenEntry:%p("
                "%ws, %lX, %lX, %p)\n", this, pwcsName, dwType, grfMode, ppv));
    olChk(EnforceSingle(grfMode));
        dfn.Set(pwcsName);


    if (REAL_STGTY(dwType) == STGTY_STREAM)
    {
        olChk(GetExposedStream(&dfn, ModeToDFlags(grfMode), &pstExp));
        *ppv = pstExp;
    }
    else
    {
        olAssert(REAL_STGTY(dwType) == STGTY_STORAGE);
        olChk(GetExposedDocFile(&dfn, ModeToDFlags(grfMode), &pdfExp));
        *ppv = pdfExp;
    }
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::OpenEntry\n"));
    return S_OK;

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStream, public
//
//  Synopsis:   Creates a stream
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::CreateStream(WCHAR const *pwcsName,
                                            DWORD grfMode,
                                            DWORD reserved1,
                                            DWORD reserved2,
                                            IStream **ppstm)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CreateStream("
                "%ws, %lX, %lu, %lu, %p)\n", pwcsName, grfMode, reserved1,
                reserved2, ppstm));
    olLog(("%p::In  CExposedDocFile::CreateStream(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstm));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppstm));
        *ppstm = NULL;
        olChk(CheckWName(pwcsName));

        if (reserved1 != 0 || reserved2 != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(VerifyPerms(grfMode));
        if (grfMode & (STGM_CONVERT | STGM_TRANSACTED | STGM_PRIORITY |
                       STGM_DELETEONRELEASE))
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(Validate());
        olChk(CheckCopyTo());
        sc = CreateEntry(pwcsName, STGTY_STREAM, grfMode, (void **)ppstm);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CreateStream => %p\n",
                *ppstm));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::CreateStream().  "
           "*ppstm == %p, ret == %lx\n", this, SAFE_DREF(ppstm), sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStream, public
//
//  Synopsis:   Opens an existing stream
//
//  Arguments:  [pwcsName] - Name
//              [reserved1]
//              [grfMode] - Permissions
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::OpenStream(WCHAR const *pwcsName,
                                          void *reserved1,
                                          DWORD grfMode,
                                          DWORD reserved2,
                                          IStream **ppstm)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::OpenStream("
                "%ws, %p, %lX, %lu, %p)\n", pwcsName, reserved1,
                grfMode, reserved2, ppstm));
    olLog(("%p::In  CExposedDocFile::OpenStream(%ws, %lu %lX, %lu, %p)\n",
           this, pwcsName, reserved1, grfMode, reserved2, ppstm));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppstm));
        *ppstm = NULL;
        olChk(CheckWName(pwcsName));

        if (reserved1 != NULL || reserved2 != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(VerifyPerms(grfMode));
        if (grfMode & (STGM_TRANSACTED | STGM_PRIORITY |
                       STGM_DELETEONRELEASE))
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(Validate());
        sc = OpenEntry(pwcsName, STGTY_STREAM, grfMode, (void **)ppstm);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::OpenStream => %p\n",
                SAFE_DREF(ppstm)));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::OpenStream().  "
           "*ppstm == %p, ret == %lx\n", this, SAVE_DREF(ppstm), sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStorage, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstg] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::CreateStorage(WCHAR const *pwcsName,
                                             DWORD grfMode,
                                             DWORD reserved1,
                                             DWORD reserved2,
                                             IStorage **ppstg)
{
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::CreateStorage(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstg));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CreateStorage:%p("
                "%ws, %lX, %lu, %lu, %p)\n", this, pwcsName, grfMode,
                reserved1, reserved2, ppstg));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppstg));
        *ppstg = NULL;
        olChk(CheckWName(pwcsName));

        if (reserved1 != 0 || reserved2 != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(VerifyPerms(grfMode));
        if (grfMode & (STGM_PRIORITY | STGM_DELETEONRELEASE))
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(Validate());
        olChk(CheckCopyTo());
        sc = CreateEntry(pwcsName, STGTY_STORAGE, grfMode, (void **)ppstg);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CreateStorage => %p\n",
                *ppstg));
EH_Err:
    olLog(("%p::Out CExposedDocFile::CreateStorage().  "
           "*ppstg == %p, ret == %lX\n", this, *ppstg, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStorage, public
//
//  Synopsis:   Gets an existing embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - Priority reopens
//              [reserved]
//              [ppstg] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::OpenStorage(WCHAR const *pwcsName,
                                           IStorage *pstgPriority,
                                           DWORD grfMode,
                                           SNBW snbExclude,
                                           DWORD reserved,
                                           IStorage **ppstg)
{
    SCODE sc;
    CExposedDocFile *pdfExp;

    olLog(("%p::In  CExposedDocFile::OpenStorage(%ws, %p, %lX, %p, %lu, %p)\n",
           this, pwcsName, pstgPriority, grfMode, snbExclude, reserved,
           ppstg));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::OpenStorage:%p("
                "%ws, %p, %lX, %p, %lu, %p)\n", this, pwcsName, pstgPriority,
                grfMode, snbExclude, reserved, ppstg));
    TRY
    {
#ifdef _UNICODE                 // for UNICODE API's we have to do validation, 
                                // else it had been done in the ascii layer 
        olChk(CheckWName(pwcsName));
#endif
        olChk(ValidateOutPtrBuffer(ppstg));
        *ppstg = NULL;
        if (reserved != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(VerifyPerms(grfMode));
        if (pstgPriority != NULL ||
            (grfMode & (STGM_PRIORITY | STGM_DELETEONRELEASE)))
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(Validate());
        if (snbExclude != NULL)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olChk(OpenEntry(pwcsName, STGTY_STORAGE, grfMode, (void **)&pdfExp));
        *ppstg = pdfExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::OpenStorage => %p\n",
                *ppstg));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::OpenStorage().  "
           "*ppstg == %p, ret == %lX\n", this, SAFE_DREF(ppstg), sc));
    return sc;

}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::MakeCopyFlags, public
//
//  Synopsis:   Translates IID array into bit fields
//
//  Arguments:  [ciidExclude] - Count of IIDs
//              [rgiidExclude] - IIDs not to copy
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------


DWORD CExposedDocFile::MakeCopyFlags(DWORD ciidExclude,
                                     IID const *rgiidExclude)
{
    DWORD dwCopyFlags;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::MakeCopyFlags(%lu, %p)\n",
                ciidExclude, rgiidExclude));
    // Copy everything by default
    dwCopyFlags = COPY_ALL;
    for (; ciidExclude > 0; ciidExclude--, rgiidExclude++)
        if (IsEqualIID(*rgiidExclude, IID_IStorage))
            dwCopyFlags &= ~COPY_STORAGES;
        else if (IsEqualIID(*rgiidExclude, IID_IStream))
            dwCopyFlags &= ~COPY_STREAMS;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::MakeCopyFlags\n"));
    return dwCopyFlags;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CopyTo, public
//
//  Synopsis:   Makes a copy of a DocFile
//
//  Arguments:  [ciidExclude] - Length of rgiid array
//              [rgiidExclude] - Array of IIDs to exclude
//              [snbExclude] - Names to exclude
//              [pstgDest] - Parent of copy
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

TSTDMETHODIMP CExposedDocFile::CopyTo(DWORD ciidExclude,
                                      IID const *rgiidExclude,
                                      SNBW snbExclude,
                                      IStorage *pstgDest)
{
    SCODE sc;
    DWORD i;

    olLog(("%p::In  CExposedDocFile::CopyTo(%lu, %p, %p, %p)\n",
           this, ciidExclude, rgiidExclude, snbExclude, pstgDest));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Copy(%lu, %p, %p, %p)\n",
                ciidExclude, rgiidExclude, snbExclude, pstgDest));

    TRY
    {
        if (snbExclude)
            olChk(ValidateSNBW(snbExclude));
        
        olChk(ValidateInterface(pstgDest, IID_IStorage));
        if (rgiidExclude)
        {
            olAssert(sizeof(IID)*ciidExclude <= 0xffffUL);
            olChk(ValidateBuffer(rgiidExclude,
                                 (size_t)(sizeof(IID)*ciidExclude)));
            for (i = 0; i<ciidExclude; i++)
                olChk(ValidateIid(rgiidExclude[i]));
        }
        olChk(Validate());
        olChk(CheckReverted());
        olAssert(_pdfb->GetCopyBase() == NULL);
        _pdfb->SetCopyBase(this);
#ifdef NEWPROPS
        // Flush all descendant property set buffers so that their
        // underlying Streams (which are about to be copied) are
        // up to date.        
        olChk(FlushBufferedData());
#endif
        olChk(CopyDocFileToIStorage(GetDF(), pstgDest, snbExclude,
                                    MakeCopyFlags(ciidExclude, rgiidExclude)));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Copy\n"));

EH_Err:
    _pdfb->SetCopyBase(NULL);

    olLog(("%p::Out ExposedDocFile::CopyTo().  ret == %lX\n",this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::Commit(DWORD dwFlags)
{
    SCODE sc=S_OK;
    TIME_T tm;

    olLog(("%p::In  CExposedDocFile::Commit(%lX)\n",this, dwFlags));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Commit(%lX)\n", dwFlags));
    TRY
    {
        if (!VALID_COMMIT(dwFlags))
            olErr(EH_Err, STG_E_INVALIDFLAG);
        olChk(Validate());
        olChk(CheckReverted());
        if (!P_WRITE(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);
        if (IsDirty())
        {
            olChk(DfGetTOD(&tm));
            olChk(_pdf->SetTime(WT_MODIFICATION, tm));
            olChk(_pmsBase->Flush(FLUSH_CACHE(dwFlags)));
            if (!IsRoot()) _pdfParent->SetDirty();
        }
        olChk(DfGetTOD(&tm));
        olChk(_pdf->SetTime(WT_ACCESS, tm));
#ifdef NEWPROPS
        olChk(FlushBufferedData());
#endif
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Commit\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::Commit().  ret == %lx\n",this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Revert, public
//
//  Synopsis:   Reverts transacted changes
//
//  Returns:    S_OK - for direct mode files, this function
//                     has not effect
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::Revert(void)
{
    // we don't supported transacted files
    // it is stated in the OLE documentation that for direct
    // files, this method has no effect
    return ResultFromScode(S_OK);  
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::EnumElements, public
//
//  Synopsis:   Starts an iterator
//
//  Arguments:  [reserved1]
//              [reserved2]
//              [reserved3]
//              [ppenm] - Enumerator return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::EnumElements(DWORD reserved1,
                                           void *reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG **ppenm)
{
    SCODE sc;
    CExposedIterator *pdiExp;
    CDfName dfnTemp;

    olLog(("%p::In  CExposedDocFile::EnumElements(%lu, %p, %lu, %p)\n",
           this, reserved1, reserved2, reserved3, ppenm));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::EnumElements(%p)\n",
                ppenm));
    TRY
    {
	olChk(ValidateOutPtrBuffer(ppenm));
	*ppenm = NULL;
	if (reserved1 != 0 || reserved2 != NULL || reserved3 != 0)
	    olErr(EH_Err, STG_E_INVALIDPARAMETER);
	olChk(Validate());
        olChk(CheckReverted());
	if (!P_READ(_df))
	    olErr(EH_Err, STG_E_ACCESSDENIED);
        olMem(pdiExp = new CExposedIterator(this, &dfnTemp)); 
        *ppenm = pdiExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

EH_Err:
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::EnumElements => %p\n",
               SAFE_DREF(ppenm)));
    olLog(("%p::Out CExposedDocFile::EnumElements().  ret == %lx\n",this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::DestroyElement, public
//
//  Synopsis:   Permanently deletes an element of a DocFile
//
//  Arguments:  [pwcsName] - Name of element
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::DestroyElement(WCHAR const *pwcsName)
{
    SCODE sc;
    CDfName dfn;

    olLog(("%p::In  CExposedDocFile::DestroyElement(%ws)\n", this, pwcsName));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::DestroyElement(%ws)\n",
                pwcsName));
    TRY
    {
        olChk(CheckWName(pwcsName));
        olChk(Validate());
        dfn.Set(pwcsName);
        olChk(DestroyEntry(&dfn, FALSE));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::DestroyElement\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::DestroyElement().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::MoveElementTo, public
//
//  Synopsis:   Move an element of a DocFile to an IStorage
//
//  Arguments:  [pwcsName] - Current name
//              [ptcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  Algorithm:  Open source as storage or stream (whatever works)
//              Create appropriate destination
//              Copy source to destination
//              Set create time of destination equal to create time of source
//              If appropriate, delete source
//
//---------------------------------------------------------------

TSTDMETHODIMP CExposedDocFile::MoveElementTo(WCHAR const *pwcsName,
                                             IStorage *pstgParent,
                                             TCHAR const *ptcsNewName,
                                             DWORD grfFlags)
{
    IUnknown *punksrc = NULL;
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::MoveElementTo(%ws, %p, %s, %lu)\n",
           this, pwcsName, pstgParent, ptcsNewName, grfFlags));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::MoveElementTo("
                "%ws, %p, %s, %lu)\n",
                pwcsName, pstgParent, ptcsNewName, grfFlags));
    TRY
    {
        IUnknown *punkdst;
        IStorage *pstgsrc;
        STATSTG statstg;

        olChk(CheckWName(pwcsName));
        olChk(Validate());
        olChk(VerifyMoveFlags(grfFlags));

        //  determine source type (determine its type)

        sc = OpenStorage(pwcsName, (IStorage*)NULL,
                         STGM_DIRECT| STGM_READ| STGM_SHARE_EXCLUSIVE,
                         (SNBW)NULL, (DWORD)NULL, &pstgsrc);

        if (SUCCEEDED(sc))
        {
            HRESULT hr;

            //  It's a storage
            punksrc = pstgsrc;

            IStorage *pstgdst;
            olHChkTo(EH_UnkSrc, pstgsrc->Stat(&statstg, STATFLAG_NONAME));

            hr = pstgParent->CreateStorage(ptcsNewName,
                                           STGM_DIRECT |
                                           STGM_WRITE |
                                           STGM_SHARE_EXCLUSIVE
                                           | STGM_FAILIFTHERE,
                                           0, 0, &pstgdst);
            if (DfGetScode(hr) == STG_E_FILEALREADYEXISTS &&
                grfFlags == STGMOVE_COPY)
            {
                hr = pstgParent->OpenStorage(ptcsNewName,
                                             NULL,
                                             STGM_DIRECT |
                                             STGM_WRITE |
                                             STGM_SHARE_EXCLUSIVE,
                                             NULL,
                                             0, &pstgdst);
            }
            olHChkTo(EH_UnkSrc, hr);

            punkdst = pstgdst;

            sc = DfGetScode(pstgsrc->CopyTo(0, NULL, NULL, pstgdst));
        }
        else if (sc == STG_E_FILENOTFOUND)
        {
            //  Try opening it as a stream

            IStream *pstmsrc, *pstmdst;
            olChk(OpenStream(pwcsName, (void *)NULL,
                             STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                             (DWORD)NULL, &pstmsrc));

            //  It's a stream
            punksrc = pstmsrc;

            olHChkTo(EH_UnkSrc, pstmsrc->Stat(&statstg, STATFLAG_NONAME));

            olHChkTo(EH_UnkSrc,
                     pstgParent->CreateStream(ptcsNewName,
                                              STGM_DIRECT |
                                              STGM_WRITE |
                                              STGM_SHARE_EXCLUSIVE |
                                              (grfFlags == STGMOVE_MOVE ?
                                               STGM_FAILIFTHERE :
                                               STGM_CREATE),
                                              0, 0, &pstmdst));

            punkdst = pstmdst;

            ULARGE_INTEGER cb;
            ULISetLow (cb, 0xffffffff);
            ULISetHigh(cb, 0xffffffff);
            sc = DfGetScode(pstmsrc->CopyTo(pstmdst, cb, NULL, NULL));
        }
        else
            olChk(sc);

        punkdst->Release();

        if (SUCCEEDED(sc))
        {
            //  Make destination create time match source create time
            //  Note that we don't really care if this call succeeded.

            pstgParent->SetElementTimes(ptcsNewName, &statstg.ctime,
                                        NULL, NULL);

            if ((grfFlags & STGMOVE_COPY) == STGMOVE_MOVE)
                sc = DestroyElement(pwcsName);
        }

        if (FAILED(sc))
        {
            //  The copy/move failed, so get rid of the partial result.

            pstgParent->DestroyElement(ptcsNewName);
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::MoveElementTo\n"));
    // Fall through
EH_UnkSrc:
    if (punksrc)
        punksrc->Release();
EH_Err:
    olLog(("%p::Out CExposedDocFile::MoveElementTo().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RenameElement, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pwcsName] - Current name
//              [pwcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::RenameElement(WCHAR const *pwcsName,
                                             WCHAR const *pwcsNewName)
{
    SCODE sc;
    CDfName dfnOld, dfnNew;

    olLog(("%p::In  CExposedDocFile::RenameElement(%ws, %ws)\n",
           this, pwcsName, pwcsNewName));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::RenameElement(%ws, %ws)\n",
               pwcsName, pwcsNewName));
    TRY
    {
        olChk(Validate());
        olChk(CheckWName(pwcsName));
        olChk(CheckWName(pwcsNewName));
        dfnOld.Set(pwcsName);
        dfnNew.Set(pwcsNewName);
        olChk(RenameEntry(&dfnOld, &dfnNew));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::RenameElement\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::RenameElement().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetElementTimes, public
//
//  Synopsis:   Sets element time stamps
//
//  Arguments:  [pwcsName] - Name
//              [pctime] - create time
//              [patime] - access time
//              [pmtime] - modify time
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


TSTDMETHODIMP CExposedDocFile::SetElementTimes(WCHAR const *pwcsName,
                                               FILETIME const *pctime,
                                               FILETIME const *patime,
                                               FILETIME const *pmtime)
{
    SCODE sc;
    CDfName dfn;
    CDocFile *pdf;

    olLog(("%p::In  CExposedDocFile::SetElementTimes(%ws, %p, %p, %p)\n",
           this, pwcsName, pctime, patime, pmtime));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::SetElementTimes:%p("
                "%ws, %p, %p, %p)\n", this, pwcsName, pctime, patime, pmtime));
    TRY
    {
        if (pwcsName)
            olChk(CheckWName(pwcsName));
        else  // function is meant to work on root storage
        {
            olAssert(FALSE && 
                     aMsg("SetTimes on root storage is not supported!\n"));
            // SetElementTimes on root storage is not portable
            // since it calls set filetimes. 
            return ResultFromScode(STG_E_UNIMPLEMENTEDFUNCTION);        
        }
        olChk(Validate());
        
        if (pctime)
            olChk(ValidateBuffer(pctime, sizeof(FILETIME)));
        if (patime)
            olChk(ValidateBuffer(patime, sizeof(FILETIME)));
        if (pmtime)
            olChk(ValidateBuffer(pmtime, sizeof(FILETIME)));
        dfn.Set(pwcsName);
        olChk(CheckReverted());
        if (!P_WRITE(_df) || _cilChildren.FindByName(&dfn) != NULL)
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(_pdf->GetDocFile(&dfn, DF_WRITE, &pdf));

        if (pctime)
            olChkTo(EH_pdf, pdf->SetTime(WT_CREATION, *pctime));
        if (pmtime)
            olChkTo(EH_pdf, pdf->SetTime(WT_MODIFICATION, *pmtime));
        if (patime)
            olChkTo(EH_pdf, pdf->SetTime(WT_ACCESS, *patime));
        SetDirty();
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::SetElementTimes\n"));
    // Fall thru
EH_pdf:
    pdf->Release();
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetElementTimes().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetClass, public
//
//  Synopsis:   Sets storage class
//
//  Arguments:  [clsid] - class id
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::SetClass(REFCLSID clsid)
{
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::SetClass(?)\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::SetClass:%p(?)\n", this));
    TRY
    {
        olChk(Validate());
        olChk(ValidateBuffer(&clsid, sizeof(CLSID)));
        olChk(CheckReverted());
        if (!P_WRITE(_df))
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(_pdf->SetClass(clsid));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::SetClass\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetClass().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetStateBits, public
//
//  Synopsis:   Sets state bits
//
//  Arguments:  [grfStateBits] - state bits
//              [grfMask] - state bits mask
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::SetStateBits(%lu, %lu)\n", this,
           grfStateBits, grfMask));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::SetStateBits:%p("
                "%lu, %lu)\n", this, grfStateBits, grfMask));
    TRY
    {
        olChk(Validate());
        olChk(CheckReverted());
        if (!P_WRITE(_df))
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(_pdf->SetStateBits(grfStateBits, grfMask));
        SetDirty();
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::SetStateBits\n"));
    // fall thru
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetStateBits().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Stat, public virtual
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//---------------------------------------------------------------

TSTDMETHODIMP CExposedDocFile::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;    

    // root storage should be handled by virtual funcs in CRootExposedDocFile
    olAssert(!IsRoot());        
    olLog(("%p::In  CExposedDocFile::Stat(%p)\n", this, pstatstg));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Stat(%p)\n", pstatstg));
    TRY
    {
        olChkTo(EH_RetSc, ValidateOutBuffer(pstatstg, sizeof(STATSTGW)));
        olChk(VerifyStatFlag(grfStatFlag));
        olChk(CheckReverted());
        olChk(_pdf->GetTime(WT_CREATION, &pstatstg->ctime));
        olChk(_pdf->GetTime(WT_MODIFICATION, &pstatstg->mtime));
        pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
        olChk(_pdf->GetClass(&pstatstg->clsid));
        olChk(_pdf->GetStateBits(&pstatstg->grfStateBits));
        pstatstg->pwcsName = NULL;
        if ((grfStatFlag & STATFLAG_NONAME) == 0)
        {
            olChk(DfAllocWCS((WCHAR *)_dfn.GetBuffer(), &pstatstg->pwcsName));
            wcscpy(pstatstg->pwcsName, (WCHAR *)_dfn.GetBuffer());
        }
        pstatstg->grfMode = DFlagsToMode(_df);
        pstatstg->type = STGTY_STORAGE;
        ULISet32(pstatstg->cbSize, 0); // irelevant for storage obj
        pstatstg->grfLocksSupported = 0;
        pstatstg->reserved = 0;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Stat\n"));
EH_Err:
    if (FAILED(sc))
        memset(pstatstg, 0, sizeof(STATSTGW));
EH_RetSc:
    olLog(("%p::Out CExposedDocFile::Stat().  *pstatstg == %p  ret == %lx\n",
           this, *pstatstg, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedDocFile::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CExposedDocFile::AddRef()\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::AddRef()\n"));
    TRY
    {
        if (FAILED(Validate()))
            return 0;
        AtomicInc(&_cReferences);
        ulRet = _cReferences;
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        ulRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::AddRef\n"));
    olLog(("%p::Out CExposedDocFile::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//---------------------------------------------------------------

STDMETHODIMP CExposedDocFile::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olLog(("%p::In  CExposedDocFile::QueryInterface(?, %p)\n",
           this, ppvObj));
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::QueryInterface(?, %p)\n",
                ppvObj));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppvObj));
        *ppvObj = NULL;
        olChk(ValidateIid(iid));
        olChk(Validate());
        olChk(CheckReverted());
        if ( IsEqualIID(iid, IID_IStorage) || IsEqualIID(iid, IID_IUnknown) )
        {
            olChk(CExposedDocFile::AddRef());
            *ppvObj = (IStorage*) this;
        }
#ifdef NEWPROPS
        else if (IsEqualIID(iid, IID_IPropertySetStorage))
        {
            olChk(CExposedDocFile::AddRef());
            *ppvObj = (IPropertySetStorage *) this;            
        }
#endif

        else
            olErr(EH_Err, E_NOINTERFACE);
        sc = S_OK;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::QueryInterface => %p\n",
                ppvObj));
EH_Err:
    olLog(("%p::Out CExposedDocFile::QueryInterface().  *ppvObj == %p  ret == %lx\n",
           this, SAFE_DREF(ppvObj), sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Method:     CExposedDocFile::CopyDStreamToIStream, private
//
//  Synopsis:   Copies a CDirectStream to an IStream
//
//  Arguments:  [pstFrom] - CDirectStream
//              [pstTo]   - IStream
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


SCODE CExposedDocFile::CopyDStreamToIStream(CDirectStream *pstFrom,
                                            IStream *pstTo)
{
    BYTE *pbBuffer; 
    SCODE sc; 
    ULONG cbRead, cbWritten, cbPos, cbSizeLow;
    ULARGE_INTEGER cbSize;

    // This is part of CopyTo and therefore we are allowed to
    // fail with out-of-memory
    olMem(pbBuffer = new BYTE[STREAMBUFFERSIZE]);

    // Set destination size for contiguity
    pstFrom->GetSize(&cbSizeLow);

    ULISet32(cbSize, cbSizeLow);
    //  Don't need to SetAccess0 here because pstTo is an IStream
    olHChk(pstTo->SetSize(cbSize));

    // Copy between streams
    cbPos = 0;
    for (;;)
    {
        olChk(pstFrom->ReadAt(cbPos, pbBuffer, STREAMBUFFERSIZE,
                               (ULONG STACKBASED *)&cbRead));
        if (cbRead == 0) // EOF
            break;

        //  Don't need to SetAccess0 here because pstTo is an IStream
        olHChk(pstTo->Write(pbBuffer, cbRead, &cbWritten));
        if (cbRead != cbWritten)
            olErr(EH_Err, STG_E_WRITEFAULT);
        cbPos += cbWritten;
    }
    sc = S_OK;

EH_Err:
    delete [] pbBuffer;
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CExposedDocFile::CopyDocFileToIStorage, private
//
//  Synopsis:   Copies a docfile's contents to an IStorage
//
//  Arguments:  [pdfFrom] - From
//              [pstgTo] - To
//              [snbExclude] - Names to not copy
//              [dwCopyFlags] - Bitwise flags for types of objects to copy
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CExposedDocFile::CopyDocFileToIStorage(CDocFile *pdfFrom,
                                             IStorage *pstgTo,
                                             SNBW snbExclude,
                                             DWORD dwCopyFlags)
{
    PDocFileIterator *pdfi;
    SIterBuffer ib;
    CDirectStream *pstFrom;
    IStream *pstTo;
    CDocFile *pdfFromChild;
    IStorage *pstgToChild;
    SCODE sc;
    TCHAR atcName[CWCSTORAGENAME];
    CLSID clsid;
    DWORD grfStateBits;

    olDebugOut((DEB_ITRACE, "In  CopyDocFileToIStorage:%p(%p, %p, %p, %lX)\n",
                this, pdfFrom, pstgTo, snbExclude, dwCopyFlags));

    olChk(pdfFrom->GetClass(&clsid));

    olHChk(pstgTo->SetClass(clsid));

    olChk(pdfFrom->GetStateBits(&grfStateBits));

    olHChk(pstgTo->SetStateBits(grfStateBits, 0xffffffff));

    olChk(pdfFrom->GetIterator(&pdfi));

    for (;;)
    {
        sc = pdfi->BufferGetNext(&ib);

        if (sc == STG_E_NOMOREFILES)
            break;
        else if (FAILED(sc))
            olErr(EH_pdfi, sc);

        if (snbExclude && NameInSNB(&ib.dfnName, snbExclude) == S_OK)
            continue;

        if ((ib.type == STGTY_STORAGE && (dwCopyFlags & COPY_STORAGES) == 0) ||
            (ib.type == STGTY_STREAM && (dwCopyFlags & COPY_STREAMS) == 0)
            )
            continue;

        switch(ib.type)
        {
        case STGTY_STORAGE:
            // Embedded DocFile, create destination and recurse

            sc = pdfFrom->GetDocFile(&ib.dfnName, DF_READ,
                                     ib.type, &pdfFromChild);
            olChkTo(EH_pdfi, sc);

            WTOT(atcName, (WCHAR *)ib.dfnName.GetBuffer(), CWCSTORAGENAME);

            //  Don't need to SetAccess0 here because pstgTo is an IStorage.

            sc = DfGetScode(pstgTo->CreateStorage(atcName, STGM_WRITE |
                                                  STGM_SHARE_EXCLUSIVE |
                                                  STGM_FAILIFTHERE,
                                                  0, 0, &pstgToChild));
            if (sc == STG_E_FILEALREADYEXISTS)
                olHChkTo(EH_Get, pstgTo->OpenStorage(atcName, NULL,
                                                     STGM_WRITE |
                                                     STGM_SHARE_EXCLUSIVE,
                                                     NULL, 0, &pstgToChild));
            else if (FAILED(sc))
                olErr(EH_Get, sc);
            olChkTo(EH_Create,
                  CopyDocFileToIStorage(pdfFromChild, pstgToChild, NULL,
                                        dwCopyFlags));
            pdfFromChild->Release();
            pstgToChild->Release();
            break;

        case STGTY_STREAM:
            sc = pdfFrom->GetStream(&ib.dfnName, DF_READ, ib.type, &pstFrom);
            olChkTo(EH_pdfi, sc);
            WTOT(atcName, (WCHAR *)ib.dfnName.GetBuffer(), CWCSTORAGENAME);

            //  Don't need to SetAccess0 here because pstgTo is an IStorage.

            olHChkTo(EH_Get,
                     pstgTo->CreateStream(atcName, STGM_WRITE |
                                          STGM_SHARE_EXCLUSIVE |
                                          STGM_CREATE,
                                          0, 0, &pstTo));
            olChkTo(EH_Create, CopyDStreamToIStream(pstFrom, pstTo));
            pstFrom->Release();
            pstTo->Release();
            break;


        default:
            olAssert(!aMsg("Unknown type in CopyDocFileToIStorage"));
            break;
        }
    }
    pdfi->Release();
    olDebugOut((DEB_ITRACE, "Out CopyDocFileToIStorage\n"));
    return S_OK;

EH_Create:
    if (ib.type == STGTY_STORAGE)
        pstgToChild->Release();
    else
        pstTo->Release();
    olVerSucc(pstgTo->DestroyElement(atcName));
EH_Get:
    if (ib.type == STGTY_STORAGE)
        pdfFromChild->Release();
    else
        pstFrom->Release();
EH_pdfi:
    pdfi->Release();
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::SwitchToFile, public
//
//  Synopsis:   Switches the underlying file to another file
//
//  Arguments:  [ptcsFile] - New file name
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------


STDMETHODIMP CExposedDocFile::SwitchToFile(TCHAR *ptcsFile)
{
    UNREFERENCED_PARM(ptcsFile);
    olAssert(FALSE && aMsg("Unimplemented Function called!\n"));
    return ResultFromScode(STG_E_UNIMPLEMENTEDFUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateExposedStream, private
//
//  Synopsis:   Creates an Exposed Stream
//              This is a private function that creates the exposed stream.
//              It is splitted out as a function so that the code can be 
//              reused.
//
//  Arguments:  [pdfnName] name of entry
//              [df] doc file flags
//              [ppStream] returned ExposedStream
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::CreateExposedStream( CDfName const *pdfnName,
                                            DFLAGS const df,
                                            CExposedStream **ppStream)
{
    CExposedStream *pstExp = NULL;
    CDirectStream *pstDirect = NULL;
    SCODE sc = S_OK;
    
    olChk(CheckReverted());
    if (!P_WRITE(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);
 
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));
    olChk(_pdf->CreateStream(pdfnName, df, DF_NOLUID, &pstDirect));
    
    //  As soon as we have a base we dirty ourself (in case
    //  we get an error later) so that we'll flush properly.
    SetDirty();
    olMemTo(EH_pst, pstExp = new CExposedStream());
    olChkTo(EH_pstExp, pstExp->Init(pstDirect, this, 
                                    df, pdfnName, (ULONG)NULL));
    *ppStream = pstExp;
    return S_OK;

EH_pstExp:
    delete pstExp;
EH_pst:
    pstDirect->Release();
    olVerSucc(DestroyEntry(pdfnName, TRUE));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::GetExposedStream, private
//
//  Synopsis:   Gets an existing exposed stream
//              This is a private function that gets the exposed stream.
//              It is splitted out as a function so that the code can be 
//              reused.
//
//  Arguments:  [pdfnName] name of entry
//              [df] doc file flags
//              [ppStream] returned ExposedStream
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::GetExposedStream( CDfName const *pdfnName,
                                         DFLAGS const df,
                                         CExposedStream **ppStream)
{
    CExposedStream *pstExp = NULL;
    CDirectStream *pstDirect = NULL;
    SCODE sc = S_OK;
    
    olChk(CheckReverted());
    if (!P_READ(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);

    // Check permissions
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(_pdf->GetStream(pdfnName, df, DF_NOLUID, &pstDirect));
    
    olMemTo(EH_pst, pstExp = new CExposedStream());
    olChkTo(EH_pstExp, pstExp->Init(pstDirect, this, 
                                    df, pdfnName, (ULONG)NULL));
    *ppStream = pstExp;
    return S_OK;

EH_pstExp:
    delete pstExp;
EH_pst:
    pstDirect->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CExposedDocFile::DestroyEntry, private
//
//  Synopsis:	Destroys an entry and removes it from the children
//              list.
//
//---------------------------------------------------------------
SCODE CExposedDocFile::DestroyEntry( CDfName const *pdfnName, 
                                     BOOL fClean)
{
    SCODE sc=S_OK;
    olChk(CheckReverted());
    if (!P_WRITE(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);

    olChk(_pdf->DestroyEntry(pdfnName, fClean));
    _cilChildren.DeleteByName(pdfnName);
    SetDirty();

    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CExposedDocFile::CreateExposedDocFile, private
//
//  Synopsis:	Creates an embedded DocFile
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdfDocFile] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//---------------------------------------------------------------

SCODE CExposedDocFile::CreateExposedDocFile(CDfName const *pdfnName,
                                            DFLAGS const df,
                                            CExposedDocFile **ppdfDocFile)
{
    SCODE sc;
    CDocFile *pdf=NULL;
    SEntryBuffer eb;

    olChk(CheckReverted());    

    if (!P_WRITE(_df)) olErr(EH_Err, STG_E_ACCESSDENIED);
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChkTo(EH_Reserve, _pdf->CreateDocFile(pdfnName, df, DF_NOLUID,
                                            &pdf));

    //  As soon as we have a base we dirty ourself (in case
    //  we get an error later) so that we'll flush properly.
    SetDirty();
    eb.luid = pdf->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("DocFile id is DF_NOLUID!"));
    olMemTo(EH_pdf,
            *ppdfDocFile = new CExposedDocFile(this, pdf, df, eb.luid,
                    _pilbBase, pdfnName, _pmsBase, _pdfb));
    return S_OK;

EH_pdf:
    pdf->Release();
    olVerSucc(_pdf->DestroyEntry(pdfnName, TRUE));
    return sc;
EH_Reserve:
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CExposedDocFile::GetExposedDocFile, private
//
//  Synopsis:	Retrieves an embedded DocFile
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdfDocFile] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//---------------------------------------------------------------

SCODE CExposedDocFile::GetExposedDocFile( CDfName const *pdfnName,
                                          DFLAGS const df,
                                          CExposedDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;
    SEntryBuffer eb;

    olChk(CheckReverted());
    if (!P_READ(_df))    olErr(EH_Err, STG_E_ACCESSDENIED);

    // Check to see if an instance with DENY_* exists
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(_pdf->GetDocFile(pdfnName, df, &pdf));
    eb.luid = pdf->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("DocFile id is DF_NOLUID!"));
    olMemTo(EH_pdf,
            *ppdfDocFile = new CExposedDocFile(this, pdf, df, eb.luid,
                    _pilbBase, pdfnName, _pmsBase, _pdfb));    
    return S_OK;

EH_pdf:
    pdf->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RenameEntry, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pdfnName] - Current name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CExposedDocFile::RenameEntry(CDfName const *pdfnName,
                                   CDfName const *pdfnNewName)
{
    SCODE sc;

    olChk(CheckReverted());
    if (!P_WRITE(_df)) 
        sc = STG_E_ACCESSDENIED;
    else
    {
        sc = _pdf->RenameEntry(pdfnName, pdfnNewName);
        if (SUCCEEDED(sc))
        {
            _cilChildren.RenameChild(pdfnName, pdfnNewName);
            SetDirty();
        }
    }

    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RevertFromAbove, public virtual from
//                                              PRevertable
//
//  Synopsis:   Parent has asked for reversion
//
//---------------------------------------------------------------

void CExposedDocFile::RevertFromAbove(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::RevertFromAbove:%p()\n", this));
    _df |= DF_REVERTED;

    _cilChildren.DeleteByName(NULL);

    _pdf->Release();
#if DBG == 1
    _pdf = NULL;
#endif
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::RevertFromAbove\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::IsAtOrAbove, public
//
//  Synopsis:   Determines whether the given docfile is an ancestor
//              of this docfile
//
//  Arguments:  [pdf] - Docfile to check
//
//  Returns:    TRUE or FALSE
//
//---------------------------------------------------------------

BOOL CExposedDocFile::IsAtOrAbove(CExposedDocFile *pdf)
{
    CExposedDocFile *pdfPar = this;

    olAssert(SUCCEEDED(CheckReverted()));

    do
    {
        if (pdfPar == pdf)
            break;
    }
    while (pdfPar = pdfPar->_pdfParent);
    return pdfPar == pdf;
}

#ifdef NEWPROPS
//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::GetStorage, public IPrivateStorage
//
//  Synopsis:   Returns the IStorage for this object.
//
//  Notes:      This member is called by CPropertyStorage.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(IStorage *)
CExposedDocFile::GetStorage(VOID)
{
    return this;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::FlushBufferedData
//                              : public, virtual : PRevertable
//
//  Synopsis:   Flush buffered data in any child streams.
//
//---------------------------------------------------------------

SCODE CExposedDocFile::FlushBufferedData(void)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, 
                "In CExposedDocFile::FlushBufferedData:%p()\n", this));

    sc = _cilChildren.FlushBufferedData();

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::FlushBufferedData\n"));

    return sc;
}

#endif  // #ifdef NEWPROPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\entry.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       entry.cxx
//
//  Contents:   Entry implementations
//
//---------------------------------------------------------------

#include "dfhead.cxx"


//+--------------------------------------------------------------
//
//  Member:     PEntry::CopyTimesFrom, public
//
//  Synopsis:   Copies one entries times to another
//
//  Arguments:  [penFrom] - From
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE PEntry::CopyTimesFrom(PEntry *penFrom)
{
    SCODE sc;
    TIME_T tm;

    olDebugOut((DEB_ITRACE, "In  PEntry::CopyTimesFrom(%p)\n",
                penFrom));
    olChk(penFrom->GetTime(WT_CREATION, &tm));
    olChk(SetTime(WT_CREATION, tm));
    olChk(penFrom->GetTime(WT_MODIFICATION, &tm));
    olChk(SetTime(WT_MODIFICATION, tm));
    olChk(penFrom->GetTime(WT_ACCESS, &tm));
    olChk(SetTime(WT_ACCESS, tm));
    olDebugOut((DEB_ITRACE, "Out PEntry::CopyTimesFrom\n"));
    // Fall through
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\dirp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	DirP.CXX
//
//  Contents:	Private CDirectory child tree methods
//
//  Notes:
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InsertEntry, private
//
//  Synopsis:   insert entry into child tree
//
//  Arguments:  [sidTree] -- storage entry in which to insert entry
//		[sidNew]  -- new entry
//		[pdfnNew] -- new entry name
//
//  Returns:	S_OK, STG_E_FILEALREADYEXISTS, or other error
//
//  Modifies:	sidParent's child tree
//
//  Algorithm:	Search down the binary tree to find the leaf node to which
//		to add the new entry (failing if we find the name already
//		exists).  Along the way we split nodes where needed to keep
//		the tree balanced.
//
//--------------------------------------------------------------------------

SCODE  CDirectory::InsertEntry(
	SID sidTree,
        SID sidNew,
        CDfName const *pdfnNew)
{
    SCODE sc;

    //  To insert the key and keep the tree balanced, we need to know
    //  the parent, grandparent, and greatgrandparent of the node we're
    //  inserting.

    SID sidChild, sidParent, sidGrandParent, sidGreatGrandParent;
    CDirEntry *pdeParent;
    int iCmp;

    //  When we're ready to insert, sidParent will be the entry to which we
    //  attach sidNew

    sidParent = sidGrandParent = sidGreatGrandParent = sidTree;

    //  Begin the search with the root of the child tree

    msfChk(GetDirEntry(sidTree, FB_NONE, &pdeParent));
    sidChild = pdeParent->GetChild();

    //  Search down the child tree to find the correct leaf entry

    while (sidChild != NOSTREAM)
    {
        //  The sidParent entry has a child along the search path, so we
        //  move down the tree (letting go of sidParent and taking hold of
        //  its child)

        ReleaseEntry(sidParent);

        //  Check to see if we need to split this node (nothing is held)

        do
        {
            SID sidLeft, sidRight;
            BOOL fRed;

            {
                CDirEntry *pdeChild;

                msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));

                msfAssert(((sidTree != sidParent) ||
                           (pdeChild->GetColor() == DE_BLACK)) &&
                           aMsg("Dir tree corrupt - root child not black!"));

                sidLeft = pdeChild->GetLeftSib();
                sidRight = pdeChild->GetRightSib();

                ReleaseEntry(sidChild);
            }

            if (sidLeft == NOSTREAM || sidRight == NOSTREAM)
                break;

	    {
                CDirEntry *pdeLeft;

                msfChk(GetDirEntry(sidLeft, FB_NONE, &pdeLeft));
                fRed = (pdeLeft->GetColor() == DE_RED);
                ReleaseEntry(sidLeft);
            }

            if (!fRed)
                break;

            {
                CDirEntry *pdeRight;

		msfChk(GetDirEntry(sidRight, FB_NONE, &pdeRight));
		fRed = (pdeRight->GetColor() == DE_RED);
		ReleaseEntry(sidRight);
            }

            if (fRed)
                msfChk(SplitEntry(pdfnNew, sidTree, sidGreatGrandParent,
			          sidGrandParent, sidParent, sidChild,
                                  &sidChild));
        }
        while (FALSE);

        //

        msfAssert(sidChild != NOSTREAM);

        //  Advance the search

        sidGreatGrandParent = sidGrandParent;
        sidGrandParent = sidParent;
        sidParent = sidChild;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));

        iCmp = NameCompare(pdfnNew, pdeParent->GetName());

        if (iCmp == 0)
        {
            //  The new name exactly matched an existing name.  Fail.
            msfChkTo(EH_RelParent, STG_E_FILEALREADYEXISTS);
        }

        //  Move down the tree, left or right depending on the comparison

        if (iCmp < 0)
            sidChild = pdeParent->GetLeftSib();
        else
            sidChild = pdeParent->GetRightSib();
    }

    msfAssert(sidChild == NOSTREAM);

    //  We've found the position to insert the new entry.

    //  We're going to dirty sidParent, so we need to change our holding flags
    ReleaseEntry(sidParent);
    msfChk(GetDirEntry(sidParent, FB_DIRTY, &pdeParent));

    if (sidParent == sidTree)
    {
        //  sidParent never made it past sidTree - we must be inserting the
        //  first child into sidTree

        msfAssert(pdeParent->GetChild() == NOSTREAM);

        //  The SplitInsert call below will make sidNew black.
        pdeParent->SetChild(sidNew);
    }
    else
    {
        msfAssert(iCmp != 0);

        //  Use the comparison to determine which side to insert the new entry

        if (iCmp < 0)
        {
            msfAssert(pdeParent->GetLeftSib() == NOSTREAM);
            msfAssert(NameCompare(pdfnNew, pdeParent->GetName()) < 0);

            pdeParent->SetLeftSib(sidNew);
        }
        else
        {
            msfAssert(pdeParent->GetRightSib() == NOSTREAM);
            msfAssert(NameCompare(pdfnNew, pdeParent->GetName()) > 0);

            pdeParent->SetRightSib(sidNew);
        }
    }

EH_RelParent:
    ReleaseEntry(sidParent);

    if (SUCCEEDED(sc))
    {
        SID sidTemp;
        sc = SplitEntry(pdfnNew, sidTree, sidGreatGrandParent, sidGrandParent,
		        sidParent, sidNew, &sidTemp);
    }
Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SplitEntry, private
//
//  Synopsis:   Split 4-node
//
//  Effects:    Passes up red link to parent
//
//  Arguments:  [pdfn]      -- search key
//		[sidTree]   -- child tree sid
//		[sidGreat]  -- greatgrandparent of child to split
//		[sidGrand]  -- grandparent of child to split
//		[sidParent] -- parent of child to split
//		[sidChild]  -- child to split
//		[psid]      -- place holder for tree position
//
//  Returns:	S_OK, or error
//
//  Modifies:	psid, tree
//
//  Algorithm:
//
//  Notes:	
//
//--------------------------------------------------------------------------

SCODE CDirectory::SplitEntry(
	CDfName const *pdfn,
        SID sidTree,
        SID sidGreat,
        SID sidGrand,
        SID sidParent,
        SID sidChild,
        SID *psid)
{
    SCODE sc;
    CDirEntry *pdeChild;
    SID sidLeft, sidRight;

    //  pn is a 4-node;  start split by moving red link up

    //  pn->GetLeft()->SetColor(BLACK);

    msfChk(GetDirEntry(sidChild, FB_DIRTY, &pdeChild));
    sidLeft = pdeChild->GetLeftSib();
    sidRight = pdeChild->GetRightSib();

    //  The root must always be black;  new non-root children are red
    pdeChild->SetColor((sidParent == sidTree) ? DE_BLACK : DE_RED);

    ReleaseEntry(sidChild);

    if (sidLeft != NOSTREAM)
    {
        msfChk(SetColorBlack(sidLeft));
    }

    //  pn->GetRight()->SetColor(BLACK);

    if (sidRight != NOSTREAM)
    {
        msfChk(SetColorBlack(sidRight));
    }

    if (sidParent != sidTree)
    {
        CDirEntry *pdeParent;
        BOOL fRedParent;
        int iCmpParent;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));

        fRedParent = (pdeParent->GetColor() == DE_RED);

        if (fRedParent)
            iCmpParent = NameCompare(pdfn, pdeParent->GetName());

        ReleaseEntry(sidParent);

        //  if (pnp->IsRed())

        if (fRedParent)
        {
            int iCmpGrand;

            //  parent is red - adjacent red links are not allowed

            //  Note - grandparent may be sidTree

            if (sidGrand == sidTree)
            {
                iCmpGrand = 1;
            }
            else
            {
                CDirEntry *pdeGrand;
                msfChk(GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

                iCmpGrand = NameCompare(pdfn, pdeGrand->GetName());

                //  png->SetColor(RED);
                pdeGrand->SetColor(DE_RED);

                ReleaseEntry(sidGrand);
            }

            //  if ((ikey < png->GetKey()) != (ikey < pnp->GetKey()))

            if ((iCmpGrand < 0) != (iCmpParent < 0))
            {
                /*  two cases:
                //
                //    | |
                //    g g
                //   /   \
                //  p     p
                //   \   /
                //    x x
                //
                //  the red links are oriented differently
                */

                //  pn = Rotate(ikey, png);
                msfChk(RotateEntry(pdfn, sidTree, sidGrand, &sidChild));

                /*
                //      | |
                //      g g
                //     /   \
                //    x     x
                //   /       \
                //  p         p
                */
            }

            //  the red links are now oriented the same - we balance the tree
            //  by rotating

            //  pn = Rotate(ikey, pngg);
            msfChk(RotateEntry(pdfn, sidTree, sidGreat, &sidChild));

            //  pn->SetColor(BLACK);
            msfAssert(sidChild != sidTree);
            msfChk(SetColorBlack(sidChild));
        }
    }

    //  return(pn);
    *psid = sidChild;

    //  The first node's link must always be black.
#if DBG == 1
    CDirEntry *pdeTree;
    msfChk(GetDirEntry(sidTree, FB_NONE, &pdeTree));
    sidChild = pdeTree->GetChild();
    ReleaseEntry(sidTree);

    msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));
    msfAssert(pdeChild->GetColor() == DE_BLACK);
    ReleaseEntry(sidChild);
#endif

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::RotateEntry
//
//  Synopsis:   rotation for balancing
//
//  Effects:    rotates localized portion of child tree
//
//  Arguments:  [pdfn] -- search key
//		[sidTree] -- child tree sid
//		[sidParent] -- root of rotation
//		[psid]      -- placeholder for root after rotation
//
//  Returns:    S_OK, or error
//
//  Modifies:   child tree
//
//  Algorithm:
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::RotateEntry(
	CDfName const *pdfn,
        SID sidTree,
        SID sidParent,
        SID *psid)
{
    SCODE sc;
    int iCmp;
    //  PNODE pnc, pngc;
    SID sidChild, sidGrand;

    //  find the child

    CDirEntry *pdeParent, *pdeChild, *pdeGrand;
    msfChk(GetDirEntry(sidParent, FB_DIRTY, &pdeParent));

    if (sidParent == sidTree)
    {
        sidChild = pdeParent->GetChild();
    }
    else
    {
        iCmp = NameCompare(pdfn, pdeParent->GetName());

        if (iCmp < 0)
            sidChild = pdeParent->GetLeftSib();
        else
            sidChild = pdeParent->GetRightSib();
    }

    //  find the grandchild

    msfChkTo(EH_RelParent, GetDirEntry(sidChild, FB_DIRTY, &pdeChild));
    msfAssert(sidChild != sidTree);

    iCmp = NameCompare(pdfn, pdeChild->GetName());

    if (iCmp < 0)
    {
        //  pngc = pnc->GetLeft();
        sidGrand = pdeChild->GetLeftSib();

        msfChkTo(EH_RelChild, GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

        /*
        //     |
        //     c
        //    / \
        //   /   \
        //  g     X
        //   \
        //    Y
        */

        //  pnc->SetLeft(pngc->GetRight());
        pdeChild->SetLeftSib(pdeGrand->GetRightSib());

        /*
        //     |
        //     c
        //    / \
        //    |  \
        //  g |   X
        //   \|
        //    Y
        */

        //  pngc->SetRight(pnc);
        pdeGrand->SetRightSib(sidChild);

        /*
        //  g
        //   \
        //    \|
        //     c
        //    / \
        //    |  \
        //    |   X
        //    |
        //    Y
        */
    }
    else
    {
        //  pngc = pnc->GetRight();
        sidGrand = pdeChild->GetRightSib();

        msfChkTo(EH_RelChild, GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

        // pnc->SetRight(pngc->GetLeft());
        pdeChild->SetRightSib(pdeGrand->GetLeftSib());

        // pngc->SetLeft(pnc);
        pdeGrand->SetLeftSib(sidChild);
    }


    //  update parent

    if (sidParent == sidTree)
    {
        //  The root must always be black
        pdeGrand->SetColor(DE_BLACK);
        pdeParent->SetChild(sidGrand);
    }
    else
    {
        iCmp = NameCompare(pdfn, pdeParent->GetName());

        if (iCmp < 0)
        {
            //  pnp->SetLeft(pngc);
            pdeParent->SetLeftSib(sidGrand);
        }
        else
        {
            //  pnp->SetRight(pngc);
            pdeParent->SetRightSib(sidGrand);
        }
    }

    ReleaseEntry(sidGrand);

    /*
    //  |
    //  g
    //   \
    //    \
    //     c
    //    / \
    //    |  \
    //    |   X
    //    |
    //    Y
    */

    //  return(pngc);
    *psid = sidGrand;

EH_RelChild:
    ReleaseEntry(sidChild);

EH_RelParent:
    ReleaseEntry(sidParent);

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::FindEntry, private
//
//  Synopsis:	find entry info based on name (optionally removing it)
//
//  Effects:	find - none, remove - takes entry out of child list
//
//  Arguments:	[sidParent] -- sid of parent entry to search
//		[pdfn]      -- name to search for
//		[deop]      -- entry operation (find or remove)
//		[peb]       -- entry information buffer
//
//  Returns:	S_OK, STG_E_FILENOTFOUND, or other error
//
//  Modifies:	peb
//
//  Algorithm:	To find the entry we search down the binary tree.
//		To remove the entry, we need to patch the tree to keep it
//		as a valid binary tree.
//
//--------------------------------------------------------------------------

SCODE  CDirectory::FindEntry(
	SID sidParent,
        CDfName const *pdfn,
        DIRENTRYOP deop,
        SEntryBuffer *peb)
{
    SCODE sc;
    SID sidPrev, sidFind;
    CDirEntry *pdePrev, *pdeFind;
    int iCmp;

    //  Once we've found the right child, sidPrev will be that entry's parent
    //  in the child tree

    sidPrev = sidParent;

    //  Begin the search with the root of the child tree

    msfChk(GetDirEntry(sidPrev, FB_NONE, &pdePrev));
    sidFind = pdePrev->GetChild();

    //  sidPrev is held

    for(;;)
    {
        if (sidFind == NOSTREAM)
        {
            //  we didn't find the child.  fail.
            sc = STG_E_FILENOTFOUND;
            goto EH_RelPrev;
// Removed this line to supress the debug error print.
//	    msfChkTo(EH_RelPrev, STG_E_FILENOTFOUND);
        }

        msfChkTo(EH_RelPrev, GetDirEntry(sidFind, FB_NONE, &pdeFind));

        //  sidPrev and sidFind are held

        int tmpCmp = NameCompare(pdfn, pdeFind->GetName());

        if (tmpCmp == 0)
        {
            //  We found the entry that matches our search name
            break;
        }

        //  The names did not match.  Advance the search down the tree.
        ReleaseEntry(sidPrev);
        pdePrev = pdeFind;
        sidPrev = sidFind;

        //  sidPrev is held

        //  remember the comparison with sidPrev so we can use it to insert
        //  an entry when we patch the tree

        iCmp = tmpCmp;

        if (iCmp < 0)
            sidFind = pdePrev->GetLeftSib();
        else
            sidFind = pdePrev->GetRightSib();
    }

    msfAssert(sidFind != NOSTREAM);

    //  sidFind is held
    //  sidPrev is held

    msfAssert(NameCompare(pdfn, pdeFind->GetName()) == 0);

    //  fill in entry information

    peb->sid = sidFind;
    peb->dwType = pdeFind->GetFlags();
    peb->luid = DF_NOLUID;

    if (deop == DEOP_REMOVE)
    {
        ReleaseEntry(sidFind);
        ReleaseEntry(sidPrev);

        msfChk(GetDirEntry(sidPrev, FB_DIRTY, &pdePrev));
        msfChkTo(EH_RelPrev, GetDirEntry(sidFind, FB_DIRTY, &pdeFind));

        //  Remove the found child from tree (carefully!).  We remove it by
        //  finding another entry in the tree with which to replace it.
        //    sidFind is the node we're removing
        //    sidPrev is the parent of sidFind in the child tree
        //    sidInsert is the entry which will replace sidFind

        SID sidInsert = pdeFind->GetRightSib();

        if (sidInsert == NOSTREAM)
        {
            //  sidFind has no right child, so we can patch the tree by
            //  replacing sidFind with the sidFind's left child

            sidInsert = pdeFind->GetLeftSib();

            //  set the inserted to the right color
            if (sidInsert != NOSTREAM)
            {
                //  we always set the inserted node to black (since the
                //  parent may not exist (we could be inserting at the
                //  root)
                msfChkTo(EH_RelPrev, SetColorBlack(sidInsert));
            }
        }
        else
        {
            CDirEntry *pdeInsert;

            //  The node we're removing has a right child

            msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_NONE, &pdeInsert));

            //  sidPrev, sidFind, and sidInsert are all held

            if (pdeInsert->GetLeftSib() != NOSTREAM)
            {
                //  sidFind's right child has a left child.
                //  sidInsert will be the leftmost child of sidFind's right
                //    child (which will keep the tree ordered)

                //  sidPreInsert will be the leftmost child's parent int the
                //    child tree

                SID sidPreInsert = sidInsert;
                CDirEntry *pdePreInsert = pdeInsert;

                //  we wait to assign sidInsert so we can clean up
                msfChkTo(EH_RelIns, GetDirEntry(pdePreInsert->GetLeftSib(),
						FB_NONE, &pdeInsert));

                sidInsert = pdePreInsert->GetLeftSib();

                //  sidPrev, sidFind, sidPreInsert, sidInsert are held

                //  find the leftmost child of sidFind's right child

                SID sidLeft;
                while ((sidLeft = pdeInsert->GetLeftSib()) != NOSTREAM)
                {
                    ReleaseEntry(sidPreInsert);

                    //  sidPrev, sidFind, sidInsert are held

                    sidPreInsert = sidInsert;
                    pdePreInsert = pdeInsert;

                    //  we wait to assign sidInsert to we can clean up
                    msfChkTo(EH_RelIns, GetDirEntry(sidLeft,
						    FB_NONE, &pdeInsert));

                    sidInsert = sidLeft;
                }

                msfAssert(pdeInsert->GetLeftSib() == NOSTREAM);

                //  sidPrev, sidFind, sidPreInsert, sidInsert are held

                //  Remove sidInsert so we can reinsert it in place of sidFind.
                //  We remove sidInsert (which has no left child) by making
                //  sidPreInsert's left child point to sidInsert's right child

                ReleaseEntry(sidPreInsert);
                msfChkTo(EH_RelIns, GetDirEntry(sidPreInsert, FB_DIRTY,
				                &pdePreInsert));

                pdePreInsert->SetLeftSib(pdeInsert->GetRightSib());
                ReleaseEntry(sidPreInsert);

                //  sidPrev, sidFind, sidInsert is held

                //  Begin to replace sidFind with sidInsert by setting the
                //  right child of sidInsert to be the right child of sidFind

                ReleaseEntry(sidInsert);
                msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_DIRTY,
						 &pdeInsert));
                pdeInsert->SetRightSib(pdeFind->GetRightSib());
            }
            else
            {
                //  sidFind's right child has no left child, so we can patch
		//  the tree by making sidFind's right child's left child
                //  point to sidFind's left child, and then replacing sidFind
                //  with sidFind's right child.

                ReleaseEntry(sidInsert);
                msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_DIRTY,
				                 &pdeInsert));

                //  fall through to do the work
            }

            pdeInsert->SetColor(DE_BLACK);

            //  Complete sidInsert's patching by setting its left child to be
            //  the left child of sidFind

            pdeInsert->SetLeftSib(pdeFind->GetLeftSib());

EH_RelIns:
            ReleaseEntry(sidInsert);
        }

        if (SUCCEEDED(sc))
        {
            if (sidPrev == sidParent)
            {
                //  We're removing the first child;  update sidParent.
                //  We made sure sidInsert is black (above).
                pdePrev->SetChild(sidInsert);
            }
            else if (iCmp < 0)
            {
                pdePrev->SetLeftSib(sidInsert);
            }
            else
                pdePrev->SetRightSib(sidInsert);

            //  make sure sidFind is clean

            pdeFind->SetLeftSib(NOSTREAM);
            pdeFind->SetRightSib(NOSTREAM);
        }
    }

EH_RelFind:
    ReleaseEntry(sidFind);

EH_RelPrev:
    ReleaseEntry(sidPrev);

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::NameCompare, private static
//
//  Synopsis:   name ordering function for child tree
//
//  Arguments:  [pdfn1] - name 1
//              [pdfn2] - name 2
//
//  Requires:   One but not both names cannot may have zero length.
//
//  Returns:    <0 if name 1 < name 2
//               0 if name 1 = name 2
//              >0 if name 1 > name 2
//
//  Algorithm:  To speed the comparision (and to allow zero length names),
//              we first compare the name lengths.  (Shorter names are "less"
//              than longer names).  If the lengths are equal we compare the
//              strings.
//
//--------------------------------------------------------------------------

int CDirectory::NameCompare(CDfName const *pdfn1, CDfName const *pdfn2)
{
    int iCmp = pdfn1->GetLength() - pdfn2->GetLength();

    if (iCmp == 0)
    {
	msfAssert(pdfn1->GetLength() != 0);
	iCmp = dfwcsnicmp((WCHAR *)pdfn1->GetBuffer(),
	    (WCHAR *)pdfn2->GetBuffer(), pdfn1->GetLength());
    }

    return(iCmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::SetColorBlack, private
//
//  Synopsis:   Sets a directory entry to black
//
//  Arguments:  [sid] -- SID of entry to be modified
//
//  Returns:    S_OK or error
//
//  Notes:      Added to reduce code size
//
//--------------------------------------------------------------------------

SCODE  CDirectory::SetColorBlack(const SID sid)
{
    SCODE sc;

    CDirEntry *pde;
    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetColor(DE_BLACK);
    ReleaseEntry(sid);

 Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\docfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1996.
//
//  File:       docfile.c
//
//  Contents:   DocFile root functions (Stg* functions)
//
//---------------------------------------------------------------

#include "exphead.cxx"

#include "expst.hxx"
#include "h/rexpdf.hxx"
#include "h/docfile.hxx"
#include "ascii.hxx"
#include "logfile.hxx"
#include "h/refilb.hxx"

//+--------------------------------------------------------------
//
//  Function:   DfFromLB, private
//
//  Synopsis:   Starts a root Docfile on an ILockBytes
//
//  Arguments:  [plst] - LStream to start on
//              [df] - Permissions
//              [dwStartFlags] - Startup flags
//              [snbExclude] - Partial instantiation list
//              [ppdfExp] - DocFile return
//              [pcid] - Class ID return for opens
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfExp]
//              [pcid]
//
//---------------------------------------------------------------


SCODE DfFromLB(ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               CExposedDocFile **ppdfExp,
               CLSID *pcid)
{
    SCODE sc, scConv;
    CRootExposedDocFile *prpdf;
    CDFBasis *pdfb=NULL;

    UNREFERENCED_PARM(pcid);
    olDebugOut((DEB_ITRACE, "In  DfFromLB(%p, %X, %lX, %p, %p, %p)\n",
                plst, df, dwStartFlags, snbExclude, ppdfExp, pcid));

    // If we're not creating or converting, do a quick check
    // to make sure that the ILockBytes contains a storage
    if ((dwStartFlags & (RSF_CREATEFLAGS | RSF_CONVERT)) == 0)
        olHChk(StgIsStorageILockBytes(plst));


    // Make root
    olMem(pdfb = new CDFBasis);
    olMemTo(EH_pdfb, prpdf = new CRootExposedDocFile(pdfb));
    olChkTo(EH_ppcInit, scConv = prpdf->InitRoot(plst, dwStartFlags, df,
            snbExclude));
    *ppdfExp = prpdf;

    olDebugOut((DEB_ITRACE, "Out DfFromLB => %p\n", SAFE_DREF(ppdfExp)));
    return scConv;

EH_ppcInit:
    prpdf->Release();
EH_pdfb:
    delete pdfb;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   StgCreateDocfile, public
//
//  Synopsis:   char version
//
//---------------------------------------------------------------

STDAPI StgCreateDocfile(TCHAR const *pszName,
                        DWORD grfMode,
                        DWORD reserved,
                        IStorage **ppstgOpen)
{
    SCODE sc;
    CFileILB *pilb = NULL;    
    int i;

    olDebugOut((DEB_ITRACE, "In  StgCreateDocfile(%p, %lX, %lu, %p)\n",
				pszName, grfMode, reserved, ppstgOpen));

    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;

    olChk(VerifyPerms(grfMode));
    if ((grfMode & STGM_RDWR) == STGM_READ ||
        (grfMode & (STGM_DELETEONRELEASE | STGM_CONVERT)) ==
        (STGM_DELETEONRELEASE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);    

    pilb = new CFileILB(pszName, grfMode, FALSE);    
    if (!pilb) olErr(EH_Err, STG_E_INSUFFICIENTMEMORY);

    olChk( pilb->Create(grfMode) );

    if ( (grfMode & (STGM_CREATE|STGM_CONVERT)) == STGM_FAILIFTHERE)
        grfMode |= STGM_CREATE; // no file exists, we will 'overwrite' the new
                                // file
    grfMode &= (~STGM_DELETEONRELEASE); // remove the flag

    sc=GetScode(StgCreateDocfileOnILockBytes(pilb, grfMode, reserved,
                                             ppstgOpen));

EH_Err:
    if (pilb) 
    {
        if (FAILED(sc)) i=pilb->ReleaseOnError();
        else i=pilb->Release();
        olAssert(SUCCEEDED(sc) ? i==1 : i==0);
    }
    olDebugOut((DEB_ITRACE, "Out StgCreateDocfile: *ppstgOpen=%p ret=>%l\n",
                ppstgOpen?(*ppstgOpen):NULL, sc));
    return ResultFromScode(sc);
}



//+--------------------------------------------------------------
//
//  Function:   StgCreateDocfileOnILockBytes, public
//
//  Synopsis:   Creates a root Docfile on an lstream
//
//  Arguments:  [plkbyt] - LStream
//              [grfMode] - Permissions
//              [reserved] - Unused
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//---------------------------------------------------------------

STDAPI StgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
                                    DWORD grfMode,
                                    DWORD reserved,
                                    IStorage **ppstgOpen)
{
    CExposedDocFile *pdfExp;
    SCODE sc;
    DFLAGS df;

    olLog(("--------::In  StgCreateDocFileOnILockBytes(%p, %lX, %lu, %p)\n",
           plkbyt, grfMode, reserved, ppstgOpen));

    olDebugOut((DEB_ITRACE, "In  StgCreateDocfileOnILockBytes("
                "%p, %lX, %lu, %p)\n",
                plkbyt, grfMode, reserved, ppstgOpen));
    TRY
    {
        olChk(ValidatePtrBuffer(ppstgOpen));
        *ppstgOpen = NULL;
        olChk(ValidateInterface(plkbyt, IID_ILockBytes));
        if (reserved != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        if ((grfMode & (STGM_CREATE | STGM_CONVERT)) == 0)
            olErr(EH_Err, STG_E_FILEALREADYEXISTS);
        olChk(VerifyPerms(grfMode));
        if (grfMode & STGM_DELETEONRELEASE)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        df = ModeToDFlags(grfMode);
        if ((grfMode & (STGM_TRANSACTED | STGM_CONVERT)) ==
            (STGM_TRANSACTED | STGM_CONVERT))
            df |= DF_INDEPENDENT;
        olChkTo(EH_Truncate,
                sc = DfFromLB(plkbyt, df,
                            RSF_CREATE |
                            ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                            ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0),
                            NULL, &pdfExp, NULL));

        *ppstgOpen = pdfExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out StgCreateDocfileOnILockBytes => %p\n",
                ppstgOpen?(*ppstgOpen):NULL));
 EH_Err:
    olLog(("--------::Out StgCreateDocFileOnILockBytes().  *ppstgOpen == %p, ret == %lx\n",
           *ppstgOpen, sc));
    FreeLogFile();
    return ResultFromScode(sc);

 EH_Truncate:
    if ((grfMode & STGM_CREATE) && (grfMode & STGM_TRANSACTED) == 0)
    {
        ULARGE_INTEGER ulSize;

        ULISet32(ulSize, 0);
        olHChk(plkbyt->SetSize(ulSize));
    }
    goto EH_Err;
}


//+--------------------------------------------------------------
//
//  Function:   DfOpenStorageOnILockBytes, public
//
//  Synopsis:   Instantiates a root Docfile from an LStream,
//              converting if necessary
//
//  Arguments:  [plkbyt] - Source LStream
//              [pstgPriority] - For priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - For priority reopens
//              [reserved]
//              [ppstgOpen] - Docfile return
//              [pcid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//              [pcid]
//
//---------------------------------------------------------------

HRESULT DfOpenStorageOnILockBytesW(ILockBytes *plkbyt,
                                   IStorage *pstgPriority,
                                   DWORD grfMode,
                                   SNBW snbExclude,
                                   DWORD reserved,
                                   IStorage **ppstgOpen,
                                   CLSID *pcid)
{
    SCODE sc;
    CExposedDocFile *pdfExp;

    olLog(("--------::In  DfOpenStorageOnILockBytes("
           "%p, %p, %lX, %p, %lu, %p, %p)\n",
           plkbyt, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen,
           pcid));
    olDebugOut((DEB_ITRACE, "In  DfOpenStorageOnILockBytes("
                "%p, %p, %lX, %p, %lu, %p, %p)\n", plkbyt, pstgPriority,
                grfMode, snbExclude, reserved, ppstgOpen, pcid));
    TRY
    {
#ifdef _UNICODE  // do checking if there is an ANSI layer
        olChk(ValidatePtrBuffer(ppstgOpen));
        *ppstgOpen = NULL;
        if (snbExclude) olChk(ValidateSNBW(snbExclude));
#endif /!UNICODE

        olChk(ValidateInterface(plkbyt, IID_ILockBytes));
        if (pstgPriority)
            olChk(ValidateInterface(pstgPriority, IID_IStorage));
        olChk(VerifyPerms(grfMode));
        if (grfMode & STGM_DELETEONRELEASE)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        if (snbExclude)
        {
            if ((grfMode & STGM_RDWR) != STGM_READWRITE)
                olErr(EH_Err, STG_E_ACCESSDENIED);
        }
        if (reserved != 0)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        if (FAILED(DllIsMultiStream(plkbyt)))
            olErr(EH_Err, STG_E_FILEALREADYEXISTS); //file is not storage obj
        if (pstgPriority)
            olChk(pstgPriority->Release());
        olChk(DfFromLB(plkbyt, ModeToDFlags(grfMode), RSF_OPEN, snbExclude,
                       &pdfExp, pcid));

        *ppstgOpen = pdfExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out DfOpenStorageOnILockBytes => %p\n",
                ppstgOpen?(*ppstgOpen):NULL));
EH_Err:
    olLog(("--------::Out DfOpenStorageOnILockBytes().  *ppstgOpen == %p"
           ", ret == %lx\n", *ppstgOpen, sc));
    FreeLogFile();
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\expst.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       expst.cxx
//
//  Contents:   CExposedStream code
//
//  Notes:      See the header file expst.hxx for details
//
//--------------------------------------------------------------------------

#include "exphead.cxx"

#include "expst.hxx"
#include "logfile.hxx"

// Maximum stream size supported by exposed streams
// This is MAX_ULONG with one subtracted so that
// the seek pointer has a spot to sit even at the
// end of the stream
#define CBMAXSTREAM 0xfffffffeUL
// Maximum seek pointer value
#define CBMAXSEEK (CBMAXSTREAM+1)

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::CExposedStream, public
//
//  Synopsis:   Empty object constructor
//
//---------------------------------------------------------------


CExposedStream::CExposedStream()
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::CExposedStream()\n"));
    _cReferences = 0;
    _ulAccessLockBase = 0;
    _ulPos = 0;
    _pst = NULL;
    _pdfParent = NULL;
    _fDirty = FALSE;
#ifdef NEWPROPS
    _pb = NULL;
    _cbUsed = 0;
    _cbOriginalStreamSize = 0;
    _fChangePending = FALSE;
#endif

    olDebugOut((DEB_ITRACE, "Out CExposedStream::CExposedStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Init, public
//
//  Synopsis:   Base constructor
//
//  Arguments:  [pst] - Direct stream
//              [pdfParent] - the storage parent
//              [df]  - Permission flags
//              [pdfn] - name of stream
//              [ulPos] - offset
//
//  Returns:    Appropriate status code
//  
//  Note:       We add "this" as a child to the parent to
//              1) Check for multiple instantiation of a child
//              2) Uses the RevertFromAbove() function to check
//                 for reverted state.
//
//---------------------------------------------------------------

SCODE CExposedStream::Init(CDirectStream *pst,
                           CExposedDocFile* pdfParent,
                           const DFLAGS df,
                           const CDfName *pdfn,
                           const ULONG ulPos)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Init("
                "%p, %lu)\n", pst, ulPos));    
    _ulPos = ulPos;
    _pst = pst;
    _pdfParent = pdfParent;
    _df = df;
    _dfn.Set(pdfn->GetLength(), pdfn->GetBuffer());
    olAssert(pdfParent);
    _pdfParent->AddChild(this);
    _cReferences = 1;
    _sig = CEXPOSEDSTREAM_SIG;
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Init\n"));
    return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Read, public
//
//  Synopsis:   Read from a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return number of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Read(VOID HUGEP *pb, ULONG cb, ULONG *pcbRead)
{
    SCODE sc;
    ULONG cbRead = 0;

    olLog(("%p::In  CExposedStream::Read(%p, %lu, %p)\n",
           this, pb, cb, pcbRead));
    olDebugOut((DEB_ITRACE, "In CExposedStream::Read(%p,%lu,%p)\n",
                 pb, cb, pcbRead));
    TRY
    {
        if (pcbRead)
            olChkTo(EH_BadPtr, ValidateOutBuffer(pcbRead, sizeof(ULONG)));
        olChk(ValidateHugeOutBuffer(pb, cb));
        olChk(Validate());
        olChk(CheckReverted());

        if (!P_READ(_df))
            sc = STG_E_ACCESSDENIED;
        else
            sc = _pst->ReadAt(_ulPos, pb, cb,
                              (ULONG STACKBASED *)&cbRead);
        olAssert( CBMAXSEEK - _ulPos >= cbRead);
        _ulPos+=cbRead;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Read => %lu\n", cbRead));

EH_Err:
    if (pcbRead)
    {
        *pcbRead = cbRead;
        olLog(("%p::Out CExposedStream::Read() *pcbRead==%lu, ret=%lx\n",
               this, SAFE_DREF(pcbRead), sc));
    }
    else
    {
        olLog(("%p::Out CExposedStream::Read().  ret == %lx\n", this, sc));
    }

EH_BadPtr:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Write, public
//
//  Synopsis:   Write to a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Write(
        VOID const HUGEP *pb,
        ULONG cb,
        ULONG *pcbWritten)
{
    SCODE sc;
    ULONG cbWritten = 0;

    olLog(("%p::In  CExposedStream::Write(%p, %lu, %p)\n",
           this, pb, cb, pcbWritten));
    olDebugOut((DEB_ITRACE, 
                "In CExposedStream::Write(%p, %lu, %p)\n",
                pb, cb, pcbWritten));
    TRY
    {
        if (pcbWritten)
        {
            olChkTo(EH_BadPtr, 
                    ValidateOutBuffer(pcbWritten, sizeof(ULONG)));
        }
        olChk(ValidateHugeBuffer(pb, cb));
        olChk(Validate());
        olChk(CheckReverted());
        if (!P_WRITE(_df))
            sc = STG_E_ACCESSDENIED;
        else
        {
            sc = _pst->WriteAt(_ulPos, pb, cb,
                               (ULONG STACKBASED *)&cbWritten);
            if (SUCCEEDED(sc))
                SetDirty();
        }
        olAssert( CBMAXSEEK - _ulPos >= cbWritten);
        _ulPos += cbWritten;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Write => %lu\n",
                cbWritten));
EH_Err:
    if (pcbWritten)
    {
        *pcbWritten = cbWritten;
        olLog(("%p::Out CExposedStream::Write().  *pcbWritten == %lu, ret = %lx\n",
               this, *pcbWritten, sc));
    }
    else
    {
        olLog(("%p::Out CExposedStream::Write().  ret == %lx\n",this, sc));
    }

EH_BadPtr:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Seek, public
//
//  Synopsis:   Seek to a point in a stream
//
//  Arguments:  [dlibMove] - Offset to move by
//              [dwOrigin] - SEEK_SET, SEEK_CUR, SEEK_END
//              [plibNewPosition] - Return of new offset
//
//  Returns:    Appropriate status code
//
//  Modifies:   [plibNewPosition]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Seek(LARGE_INTEGER dlibMove,
                                  DWORD dwOrigin,
                                  ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc;
    LONG lMove;
    ULARGE_INTEGER ulPos;

    olLog(("%p::In  CExposedStream::Seek(%ld, %lu, %p)\n",
           this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Seek(%ld, %lu, %p)\n",
                LIGetLow(dlibMove), dwOrigin, plibNewPosition));
    TRY
    {
        if (plibNewPosition)
        {
            olChk(ValidateOutBuffer(plibNewPosition, sizeof(ULARGE_INTEGER)));
            ULISet32(*plibNewPosition, 0);
        }
        if (dwOrigin != STREAM_SEEK_SET && dwOrigin != STREAM_SEEK_CUR &&
            dwOrigin != STREAM_SEEK_END)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);

        // Truncate dlibMove to 32 bits
        if (dwOrigin == STREAM_SEEK_SET)
        {
            // Make sure we don't seek too far
            if (LIGetHigh(dlibMove) != 0)
                LISet32(dlibMove, /*(LONG)*/0xffffffff);
        }
        else
        {
            // High dword must be zero for positive values or -1 for
            // negative values
            // Additionally, for negative values, the low dword can't
            // exceed -0x80000000 because the 32nd bit is the sign
            // bit
            if (LIGetHigh(dlibMove) > 0 ||
                (LIGetHigh(dlibMove) == 0 &&
                 LIGetLow(dlibMove) >= 0x80000000))
                LISet32(dlibMove, 0x7fffffff);
            else if (LIGetHigh(dlibMove) < -1 ||
                     (LIGetHigh(dlibMove) == -1 &&
                      LIGetLow(dlibMove) <= 0x7fffffff))
                LISet32(dlibMove, /*(LONG)*/0x80000000);
        }

        lMove = (LONG)LIGetLow(dlibMove);
        olChk(Validate());
        olChk(CheckReverted());
        ULISet32(ulPos, _ulPos);
        switch(dwOrigin)
        {
        case STREAM_SEEK_SET:
            ULISetLow(ulPos, (ULONG)lMove);
            break;
        case STREAM_SEEK_END:
            ULONG cbSize;
            olChk(GetSize(&cbSize));
            if (lMove < 0)
            {
                if ((ULONG)(-lMove) > cbSize)
                    olErr(EH_Err, STG_E_INVALIDFUNCTION);
            }
            else if ((ULONG)lMove > CBMAXSEEK-cbSize)
                lMove = (LONG)(CBMAXSEEK-cbSize);
            ULISetLow(ulPos, cbSize+lMove);
            break;
        case STREAM_SEEK_CUR:
            if (lMove < 0)
            {
                if ((ULONG)(-lMove) > _ulPos)
                    olErr(EH_Err, STG_E_INVALIDFUNCTION);
            }
            else if ((ULONG)lMove > CBMAXSEEK - _ulPos)
                lMove = (LONG)(CBMAXSEEK- _ulPos);
            ULISetLow(ulPos, _ulPos+lMove);
            break;
        }
        _ulPos = ULIGetLow(ulPos);
        if (plibNewPosition)
            *plibNewPosition = ulPos;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Seek => %lu\n",
                ULIGetLow(ulPos)));
EH_Err:
    olLog(("%p::Out CExposedStream::Seek().  ulPos == %lu,  ret == %lx\n",
           this, ULIGetLow(ulPos), sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize, public
//
//  Synopsis:   Sets the size of a stream
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------
SCODE CExposedStream::SetSize(ULONG cb)
{    
    olDebugOut((DEB_ITRACE, 
                "In CExposedStream::SetSize(ULONG %lu)\n", cb));
    SCODE sc;
    TRY
    {
        olChk(Validate());
        olChk(CheckReverted());
        if (!P_WRITE(_df))
            sc = STG_E_ACCESSDENIED;
        else
        {
            olChk(_pst->SetSize(cb));
            SetDirty();
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

EH_Err:    
    olDebugOut((DEB_ITRACE, "Out  CExposedStream::SetSize()\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize, public
//
//  Synopsis:   Sets the size of a stream
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::SetSize(ULARGE_INTEGER ulNewSize)
{
    SCODE sc;

    olLog(("%p::In  CExposedStream::SetSize(%lu)\n",
           this, ULIGetLow(ulNewSize)));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::SetSize(%lu)\n",
                ULIGetLow(ulNewSize)));
    TRY
    {
        if (ULIGetHigh(ulNewSize) != 0)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        olChk(SetSize(ULIGetLow(ulNewSize)));
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::SetSize\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::SetSize().  ret == %lx\n", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::CopyTo, public
//
//  Synopsis:   Copies information from one stream to another
//
//  Arguments:  [pstm] - Destination
//              [cb] - Number of bytes to copy
//              [pcbRead] - Return number of bytes read
//              [pcbWritten] - Return number of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//              [pcbWritten]
//
//  Notes:      We do our best to handle overlap correctly.  This allows
//              CopyTo to be used to insert and remove space within a
//              stream.
//
//              In the error case, we make no gurantees as to the
//              validity of pcbRead, pcbWritten, or either stream's
//              seek position.
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::CopyTo(IStream *pstm,
                                    ULARGE_INTEGER cb,
                                    ULARGE_INTEGER *pcbRead,
                                    ULARGE_INTEGER *pcbWritten)
{
    SCODE sc;
    ULONG ulCopySize;
    ULONG ulSrcSize;
    ULONG ulSrcOrig;
    ULARGE_INTEGER uliDestOrig;
    LARGE_INTEGER liDestPos;
    BYTE *pb = NULL;
    BOOL fOverlap;
    ULONG ulBytesCopied = 0;

    olLog(("%p::In  CExposedStream::CopyTo(%p, %lu, %p, %p)\n",
           this, pstm, ULIGetLow(cb), pcbRead, pcbWritten));
    olDebugOut((DEB_TRACE, "In  CExposedStream::CopyTo("
                "%p, %lu, %p, %p)\n", pstm, ULIGetLow(cb),
                pcbRead, pcbWritten));

    TRY
    {        
        if (pcbRead) // okay to set to NULL => not interested
        {
            olChk(ValidateOutBuffer(pcbRead, sizeof(ULARGE_INTEGER)));
            ULISet32(*pcbRead, 0);
        }
        if (pcbWritten) // okay to set to NULL => not interested
        {
            olChk(ValidateOutBuffer(pcbWritten, sizeof(ULARGE_INTEGER)));
            ULISet32(*pcbWritten, 0);
        }

        olChk(ValidateInterface(pstm, IID_IStream));
        olChk(Validate());
        olChk(CheckReverted());

        //  Bound the size of the copy
        //  1.  The maximum we can copy is 0xffffffff

        if (ULIGetHigh(cb) == 0)
            ulCopySize = ULIGetLow(cb);
        else
            ulCopySize = 0xffffffff;

        //  2.  We can only copy what's available in the source stream
        
        olChk(GetSize(&ulSrcSize));

        ulSrcOrig = _ulPos;
        if (ulSrcSize < ulSrcOrig)
        {
            //  Nothing in source to copy
            ulCopySize = 0;
        }
        else if ((ulSrcSize - ulSrcOrig) < ulCopySize)
        {
            //  Shrink ulCopySize to fit bytes in source
            ulCopySize = ulSrcSize - ulSrcOrig;
        }

        //  3.  We can only copy what will fit in the destination

        LISet32(liDestPos, 0);
        olHChk(pstm->Seek(liDestPos, STREAM_SEEK_CUR, &uliDestOrig));
        olAssert(ULIGetHigh(uliDestOrig) == 0);

        if (ulCopySize > CBMAXSEEK - ULIGetLow(uliDestOrig))
            ulCopySize = CBMAXSEEK - ULIGetLow(uliDestOrig);

        //  We are allowed to fail here with out-of-memory
        olMem(pb = new BYTE[STREAMBUFFERSIZE]);

        // Since we have no reliable way to determine if the source and
        // destination represent the same stream, we assume they
        // do and always handle overlap.

        fOverlap = (ULIGetLow(uliDestOrig) > ulSrcOrig &&
                    ULIGetLow(uliDestOrig) < ulSrcOrig + ulCopySize);

        ULONG ulSrcCopyOffset;
        ULONG ulDstCopyOffset;
        if (fOverlap)
        {
            //  We're going to copy back to front, so determine the
            //  stream end positions
            ulSrcCopyOffset = ulSrcOrig + ulCopySize;

            //  uliDestOrig is the destination starting offset
            ulDstCopyOffset = ULIGetLow(uliDestOrig) + ulCopySize;
        }

        while (ulCopySize > 0)
        {
            //  We can only copy up to STREAMBUFFERSIZE bytes at a time
            ULONG cbPart = min(ulCopySize, STREAMBUFFERSIZE);

            if (fOverlap)
            {
                //  We're copying back to front so we need to seek to
                //  set up the streams correctly

                ulSrcCopyOffset -= cbPart;
                ulDstCopyOffset -= cbPart;

                //  Set source stream position
                _ulPos = ulSrcCopyOffset;

                //  Set destination stream position
                LISet32(liDestPos, ulDstCopyOffset);
                olHChk(pstm->Seek(liDestPos, STREAM_SEEK_SET, NULL));
            }

            {
                ULONG ulRead;
                olHChk(Read(pb, cbPart, &ulRead));
                if (cbPart != ulRead)
                {
                    //  There was no error, but we were unable to read cbPart
                    //  bytes.  Something's wrong (the underlying ILockBytes?)
                    //  but we can't control it;  just return an error.
                    olErr(EH_Err, STG_E_READFAULT);
                }
            }


            {
                ULONG ulWritten;
                olHChk(pstm->Write(pb, cbPart, &ulWritten));
                if (cbPart != ulWritten)
                {
                    //  There was no error, but we were unable to write
                    //  ulWritten bytes.  We can't trust the pstm
                    //  implementation, so all we can do here is return
                    //  an error.
                    olErr(EH_Err, STG_E_WRITEFAULT);
                }
            }

            olAssert(ulCopySize >= cbPart);
            ulCopySize -= cbPart;
            ulBytesCopied += cbPart;
        }

        if (fOverlap)
        {
            //  Set the seek pointers to the correct location
            _ulPos = ulSrcOrig + ulBytesCopied;

            LISet32(liDestPos, ULIGetLow(uliDestOrig) + ulBytesCopied);
            olHChk(pstm->Seek(liDestPos, STREAM_SEEK_SET, NULL));
        }

        if (pcbRead)
            ULISet32(*pcbRead, ulBytesCopied);
        if (pcbWritten)
            ULISet32(*pcbWritten, ulBytesCopied);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::CopyTo => %lu, %lu\n",
                pcbRead ? ULIGetLow(*pcbRead) : 0,
                pcbWritten ? ULIGetLow(*pcbWritten) : 0));
    // Fall through
EH_Err:
    delete [] pb;
    olLog(("%p::Out CExposedStream::CopyTo().  "
           "cbRead == %lu, cbWritten == %lu, ret == %lx\n",
           this, pcbRead ? ULIGetLow(*pcbRead) : 0,
           pcbWritten ? ULIGetLow(*pcbWritten) : 0, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Release, public
//
//  Synopsis:   Releases a stream
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedStream::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CExposedStream::Release()\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Release()\n"));
    TRY
    {
        if (FAILED(Validate()))
            return 0;
        olAssert(_cReferences > 0);
        lRet = AtomicDec(&_cReferences);
        if (lRet == 0)
        {
            Commit(0); //  flush data
            delete this;
        }
        else if (lRet < 0)
            lRet = 0;
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        lRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Release\n"));
    olLog(("%p::Out CExposedStream::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//---------------------------------------------------------------

 
STDMETHODIMP_(SCODE) CExposedStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc, scSem = STG_E_INUSE;

    olLog(("%p::In  CExposedStream::Stat(%p)\n", this, pstatstg));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Stat(%p)\n",
                pstatstg));
    TRY
    {
        olChkTo(EH_RetSc, ValidateOutBuffer(pstatstg, sizeof(STATSTGW)));
        olChk(VerifyStatFlag(grfStatFlag));
        olChk(Validate());
        olChk(CheckReverted());
        pstatstg->grfMode = DFlagsToMode(_df);

        pstatstg->clsid = CLSID_NULL;  // irrelevant for streams
        pstatstg->grfStateBits = 0;    // irrelevant for streams
        pstatstg->type = STGTY_STREAM;
        pstatstg->grfLocksSupported = 0;
        pstatstg->reserved = 0;

        // we null these values 'cos they are not interesting for
        // direct streams ...
        pstatstg->ctime.dwLowDateTime = pstatstg->ctime.dwHighDateTime = 0;
        pstatstg->mtime.dwLowDateTime = pstatstg->mtime.dwHighDateTime = 0;
        pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
        pstatstg->pwcsName = NULL;
        if ((grfStatFlag & STATFLAG_NONAME) == 0)
        {                       // fill in name
            olChk(DfAllocWCS((WCHAR *)_dfn.GetBuffer(), 
                             &pstatstg->pwcsName));
            wcscpy(pstatstg->pwcsName, (WCHAR *)_dfn.GetBuffer());
        }
        ULONG cbSize;
        GetSize(&cbSize);
        ULISet32(pstatstg->cbSize, cbSize);        
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Stat\n"));
EH_Err:
    if (FAILED(sc))
        memset(pstatstg, 0, sizeof(STATSTGW));
EH_RetSc:
    olLog(("%p::Out CExposedStream::Stat().  ret == %lx\n",
           this, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Clone, public
//
//  Synopsis:   Clones a stream
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Clone(IStream **ppstm)
{
    CExposedStream *pst;
    SCODE sc;

    olLog(("%p::In  CExposedStream::Clone(%p)\n", this, ppstm));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Clone(%p)\n", ppstm));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppstm));
        *ppstm = NULL;
        olChk(Validate());
        olChk(CheckReverted());
        olMemTo(EH_pst, pst = new CExposedStream);
        olChkTo(EH_pst, pst->Init(_pst, _pdfParent, _df, &_dfn, _ulPos));
        _pst->AddRef();
        *ppstm = pst;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Clone => %p\n", *ppstm));
    return ResultFromScode(sc);

EH_pst:
    delete pst;
EH_Err:
    olLog(("%p::Out CExposedStream::Clone(). *ppstm == %p, ret == %lx\n",
           this, SAFE_DREFppstm, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CExposedStream::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CExposedStream::AddRef()\n", this));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::AddRef()\n"));
    TRY
    {
        if (FAILED(Validate()))
            return 0;
        AtomicInc(&_cReferences);
        ulRet = _cReferences;
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        ulRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::AddRef\n"));
    olLog(("%p::Out CExposedStream::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::LockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::LockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::LockRegion("
                "%lu, %lu\n", ULIGetLow(cb), dwLockType));
    olDebugOut((DEB_ITRACE, "Out CExposedStream::LockRegion\n"));
    olLog(("%p::INVALID CALL TO CExposedStream::LockRegion()\n"));
    UNREFERENCED_PARM(libOffset);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(dwLockType);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::UnlockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::UnlockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::UnlockRegion(%lu, %lu)\n",
                ULIGetLow(cb), dwLockType));
    olDebugOut((DEB_ITRACE, "Out CExposedStream::UnlockRegion\n"));
    olLog(("%p::INVALID CALL TO CExposedStream::UnlockRegion()\n"));
    UNREFERENCED_PARM(libOffset);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(dwLockType);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Commit, public
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Commit(DWORD grfCommitFlags)
{
    SCODE sc, scSem = STG_E_INUSE;
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Commit(%lu)\n",
                grfCommitFlags));
    olLog(("%p::In  CExposedStream::Commit(%lx)\n", this, grfCommitFlags));

    TRY
    {
        olChk(Validate());
        olChk(CheckReverted());
        
        if (_fDirty)
        {   //  We're a stream so we must have a parent
            //  We dirty all parents up to the next 
            //  transacted storage
            _pdfParent->SetDirty();
            sc = _pdfParent->GetBaseMS()
                ->Flush(FLUSH_CACHE(grfCommitFlags));               
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Commit\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::Commit().  ret == %lx", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Revert, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Revert(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::Revert()\n"));
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Revert\n"));

    olLog(("%p::In  CExposedStream::Revert()\n", this));
    olLog(("%p::Out CExposedStream::Revert().  ret == %lx", this, S_OK));

    return ResultFromScode(STG_E_UNIMPLEMENTEDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olLog(("%p::In  CExposedStream::QueryInterface(?, %p)\n",
           this, ppvObj));
    olDebugOut((DEB_ITRACE, "In  CExposedStream::QueryInterface(?, %p)\n",
                ppvObj));
    TRY
    {
        olChk(ValidateOutPtrBuffer(ppvObj));
        *ppvObj = NULL;
        olChk(ValidateIid(iid));
        olChk(Validate());
        olChk(CheckReverted());
        if (IsEqualIID(iid, IID_IStream) || IsEqualIID(iid, IID_IUnknown))
        {
            olChk(AddRef());
            *ppvObj = this;
        }
        else
            olErr(EH_Err, E_NOINTERFACE);
        sc = S_OK;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedStream::QueryInterface => %p\n",
                ppvObj));
EH_Err:
    olLog(("%p::Out CExposedStream::QueryInterface().  *ppvObj == %p, ret == %lx\n",
           this, *ppvObj, sc));
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:	CExposedStream::RevertFromAbove, public (virtual)
//
//  Synopsis:	Parent has asked for reversion
//
//---------------------------------------------------------------


void CExposedStream::RevertFromAbove(void)
{
    msfDebugOut((DEB_ITRACE, 
                 "In CExposedStream::RevertFromAbove:%p()\n", this));
    _df |= DF_REVERTED;
    _pst->Release();
#if DBG == 1
    _pst = NULL;
#endif
    msfDebugOut((DEB_ITRACE, "Out CExposedStream::RevertFromAbove\n"));
}

#ifdef NEWPROPS
//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Open
//
//  Synopsis:   Opens mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Gets the size of the underlying stream and reads it
//              into memory so that it can be "mapped." 
//
//--------------------------------------------------------------------

VOID CExposedStream::Open(IN VOID *powner, OUT LONG *phr)
{
    LONG& sc = *phr;
    sc = S_OK;

    // If given a pointer to the owner of this mapped stream,
    // save it. This could be NULL. (i.e. when called from ReOpen)
    if( NULL != powner  )
        _powner = (BYTE*) powner;
  
    if (_pb == NULL)
    { 
        VOID *pv;
        _cbUsed = 0;
        olChk(CheckReverted());
        _pst->GetSize(&_cbOriginalStreamSize);

        if (_cbOriginalStreamSize > CBMAXPROPSETSTREAM)
            olErr(EH_Err, STG_E_INVALIDHEADER);

        _cbUsed = _cbOriginalStreamSize;
        olMemTo(EH_Err, pv = new BYTE[_cbOriginalStreamSize]);
        _pb = (BYTE*) pv;
        olChkTo(EH_Read, 
                    _pst->ReadAt(0, pv, _cbOriginalStreamSize, &_cbUsed));
        olAssert(_cbOriginalStreamSize == _cbUsed && 
                 "CExposedStream did not read in all the info!");

        // Notify our owner that we have new data
        if (*phr == S_OK && _powner != NULL && 0 != _cbUsed)
        {
            *phr = RtlOnMappedStreamEvent((VOID*)_powner, pv, _cbUsed );
        }

    }
    olDebugOut((DEB_PROP_MAP, "CExposedStream(%X):Open returns normally\n", this));
    return;

// Error handling
EH_Read:
    delete[] _pb;
    _pb = NULL;
    _cbUsed = 0;

EH_Err:
    olDebugOut((DEB_PROP_MAP, 
                "CExposedStream(%X):Open exception returns %08X\n", 
                this, *phr));
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Close
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Does nothing because the object may be mapped in
//              another process.
//
//--------------------------------------------------------------------

VOID CExposedStream::Close(OUT LONG *phr)
{
    // Write the changes.  We don't need to Commit them,
    // they will be implicitely committed when the 
    // Stream is Released.

    *phr = Write();

    if( FAILED(*phr) )
    {
        olDebugOut( (DEB_PROP_MAP, 
                     "CPubStream(%08X)::Close exception returns %08X\n", 
                     this, *phr));
    }

    return;    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::ReOpen
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Combined open and map.
//
//--------------------------------------------------------------------

VOID CExposedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
    *ppv = NULL;
    Open( (void*)NULL,          // unspecified owner
          phr);
    if ( SUCCEEDED(*phr) )
        *ppv = _pb;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Quiesce
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Meaningless for docfile mapped stream.
//
//--------------------------------------------------------------------

VOID CExposedStream::Quiesce(VOID)
{
    olAssert(_pb != NULL);
    DfpdbgCheckUnusedMemory();
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Map
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Return the address of the "mapping" buffer.
//
//--------------------------------------------------------------------

VOID CExposedStream::Map(BOOLEAN fCreate, VOID **ppv) 
{ 
    UNREFERENCED_PARM(fCreate);
    olAssert(_pb != NULL); 
    DfpdbgCheckUnusedMemory();
    *ppv = _pb; 
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Unmap
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Unmapping is merely zeroing the pointer.  We don't
//              flush because that's done explicitly by the 
//              CPropertyStorage class.
//              
//
//--------------------------------------------------------------------

VOID CExposedStream::Unmap(BOOLEAN fFlush, VOID **pv)
{
    UNREFERENCED_PARM(fFlush);
    DfpdbgCheckUnusedMemory();
    *pv = NULL;    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Flush
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//              Flush the memory property set to disk and commit it.
//
//--------------------------------------------------------------------

VOID CExposedStream::Flush(OUT LONG *phr)
{
    *phr = S_OK;
    // write out any data we have cached to the stream
    if (S_OK == (*phr = Write()))     
    {
        // commit the stream
        (*phr) = Commit(STGC_DEFAULT);
    }

    return;    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::GetSize
//
//  Synopsis:   Returns size of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//--------------------------------------------------------------------

ULONG CExposedStream::GetSize(OUT LONG *phr)
{
    *phr = S_OK;
    if (_pb == NULL)
        Open((void*)NULL,       // unspecified owner
             phr);

    if( SUCCEEDED(*phr) )
    {
        olAssert(_pb != NULL); 
        DfpdbgCheckUnusedMemory();
    }
    
    return _cbUsed;    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize
//
//  Synopsis:   Sets size of "map." Called by 
//              NtCreatePropertySet et al.
//
//  Arguments:  [cb] -- requested size.
//		[fPersistent] -- FALSE if expanding in-memory read-only image
//              [ppv] -- new mapped address.
//
//  Signals:    Not enough disk space.
//
//
//--------------------------------------------------------------------

VOID  CExposedStream::SetSize(ULONG cb, IN BOOLEAN fPersistent, 
                              VOID **ppv, OUT LONG *phr)
{
    *phr = S_OK;
    LONG& sc=*phr;
    BYTE *pbNew;

    olAssert(cb != 0);    
    DfpdbgCheckUnusedMemory();
    olChk(CheckReverted());

    //
    // if we are growing the data, we should grow the stream
    //
    if (fPersistent && cb > _cbUsed)
    {
        olChk(_pst->SetSize(cb));
    }

    olMem(pbNew = new BYTE[cb]);
        
    memcpy(pbNew, _pb, (cb < _cbUsed) ? cb : _cbUsed); // smaller of the 2
    delete[] _pb;
    
    _pb = pbNew;
    _cbUsed = cb;
    *ppv = _pb;
            
    DfpdbgFillUnusedMemory();

EH_Err:
    olDebugOut((DEB_PROP_MAP, "CPubStream(%08X):SetSize %s returns hr=%08X\n",
        this, *phr != S_OK ? "exception" : "", *phr));
    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QueryTimeStamps
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CExposedStream::QueryTimeStamps(STATPROPSETSTG *pspss, 
                                     BOOLEAN fNonSimple) const
{    
    UNREFERENCED_PARM(fNonSimple);
    UNREFERENCED_PARM(pspss);    
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QueryModifyTime
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    UNREFERENCED_PARM(pll);   
    return (FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QuerySecurity
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::QuerySecurity(OUT ULONG *pul) const
{
    UNREFERENCED_PARM(pul);   
    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsWriteable
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::IsWriteable() const
{
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetChangePending
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CExposedStream::SetChangePending(BOOLEAN f)
{
    BOOL fOld = _fChangePending;
    _fChangePending = f;
    return(_fChangePending);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsNtMappedStream
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CExposedStream::IsNtMappedStream(VOID) const
{
    return FALSE;
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::GetHandle
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

HANDLE CExposedStream::GetHandle(VOID) const
{
    return INVALID_HANDLE_VALUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CExposedStream::SetModified(VOID)
{
    _fDirty = TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::IsModified(VOID) const
{
    return _fDirty;
}

#if DBG
//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::DfpdbgFillUnusedMemory
//
//--------------------------------------------------------------------

VOID CExposedStream::DfpdbgFillUnusedMemory(VOID)
{
    if (_pb == NULL)
        return;

    BYTE * pbEndPlusOne = _pb + BytesCommitted();

    for (BYTE *pbUnused = _pb + _cbUsed;
         pbUnused < pbEndPlusOne;
         pbUnused++)
    {
        *pbUnused = (BYTE)(DWORD)pbUnused;
    }
}


//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::DfpdbgCheckUnusedMemory
//
//--------------------------------------------------------------------

VOID CExposedStream::DfpdbgCheckUnusedMemory(VOID)
{

    if (_pb == NULL)
        return;

    if (_cbUsed == 0)
        return;

    BYTE * pbEndPlusOne = _pb + BytesCommitted();

    for (BYTE *pbUnused =  _pb + _cbUsed;
         pbUnused < pbEndPlusOne;
         pbUnused ++)
    {
        olAssert(*pbUnused == (BYTE)(DWORD)pbUnused);
    }
}

#endif    // DBG


//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Write, private
//
//  Synopsis:   Writes a mapped view of an exposed Stream to the
//              underlying Stream.  Used by RtlCreatePropertySet et al.
//
//  Notes:      The Stream is not commited.  To commit the Stream, in
//              addition to writing it, the Flush method should be used.
//              The Commit is omitted so that it can be skipped in
//              the Property Set Close path, thus eliminating a
//              performance penalty.
//
//--------------------------------------------------------------------

HRESULT CExposedStream::Write(VOID)
{
    HRESULT hr;
    ULONG cbWritten;

    if (!_fDirty ||!_pb)
    {
        olDebugOut((DEB_PROP_MAP,
                 "CExposedStream(%08X):Flush returns with not-dirty\n", this));

        // flushing a stream which isn't a property stream
        // this could be optimized by propagating a 'no property streams'
        // flag up the storage hierachy such that FlushBufferedData is
        // not even called for non-property streams.
        return S_OK;     
    }
    
    hr=CheckReverted();
    if (S_OK!=hr) goto Exit;
    olAssert( _pst != NULL );
    olAssert( _pb != NULL );
    olAssert( _powner != NULL );

    // notify our owner that we are about to perform a write
    hr = RtlOnMappedStreamEvent( (void*)_powner, (void*) _pb, _cbUsed );
    if ( S_OK != hr ) goto Exit;

    hr = _pst->WriteAt(0, _pb, _cbUsed, &cbWritten);

    if( S_OK != hr ) goto Exit;
    // notify our owner that we are done with the write
    hr = RtlOnMappedStreamEvent( (VOID*)_powner, (VOID *) _pb, _cbUsed );
    if( S_OK != hr ) goto Exit;
    
    if (_cbUsed < _cbOriginalStreamSize)
    {
        // if the stream is shrinking, this is a good time to do it.
        hr = _pst->SetSize(_cbUsed);
        if (S_OK!=hr) goto Exit;
    }

Exit:
    if (hr == S_OK || hr == STG_E_REVERTED)
    {
        _fDirty = FALSE;
    }

    olDebugOut((DEB_PROP_MAP, "CPubStream(%08X):Flush %s returns hr=%08X\n",
        this, hr != S_OK ? "exception" : "", hr));

    return hr;
}

//+--------------------------------------------------------------
//
//  Member:         CExposedStream::FlushBufferedData, public
//
//  Synopsis:   Flush out the property buffers.
//
//---------------------------------------------------------------

SCODE CExposedStream::FlushBufferedData()
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CExposedStream::FlushBufferedData:%p()\n", 
                this));

    Flush(&sc);

    olDebugOut((DEB_PROP_MAP, 
                "CExposedStream(%08X):FlushBufferedData returns %08X\n",
                this, sc));

    return sc;
}

#endif // ifdef NEWPROPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\fat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       fat.cxx
//
//  Contents:   Allocation functions for MStream
//
//  Classes:    None. (defined in fat.hxx)
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/difat.hxx"
#include "h/sstream.hxx"
#include "mread.hxx"


//+-------------------------------------------------------------------------
//
//  Method:     CFatSect::Init, public
//
//  Synopsis:   CFatSect initialization function
//
//  Effects:    [uEntries] -- Number of entries in sector
//
//  Algorithm:  Allocate an array of SECT with size uEntries from
//              the heap.
//
//--------------------------------------------------------------------------

SCODE CFatSect::Init(FSOFFSET uEntries)
{
    msfDebugOut((DEB_FAT,"In CFatSect constructor\n"));

    //This assumes that FREESECT is always 0xFFFFFFFF
    memset(_asectEntry, 0xFF, uEntries * sizeof(SECT));

    msfDebugOut((DEB_FAT,"Out CFatSect constructor\n"));
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFatSect::InitCopy, public
//
//  Synopsis:   Initialization function for copying FatSects
//
//  Arguments:  [fsOld] -- Reference to FatSect to be copies
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  Allocate a new array of SECT and copy old
//                  information in.
//
//--------------------------------------------------------------------------

SCODE CFatSect::InitCopy(USHORT uSize, CFatSect& fsOld)
{
    msfDebugOut((DEB_FAT,"In CFatSect copy constructor\n"));
    msfDebugOut((DEB_FAT,"This = %p,  fsOld = %p\n",this,&fsOld));

    msfDebugOut((DEB_FAT,"Sector size is %u sectors\n",uSize));

    memcpy(_asectEntry,fsOld._asectEntry,sizeof(SECT)*uSize);
    msfDebugOut((DEB_FAT,"Out CFatSect copy constructor\n"));
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::CFat, public
//
//  Synopsis:   CFat constructor.
//
//  Arguments:  [pmsParent] -- Pointer to parent multistream.
//
//  Algorithm:  Set uFatEntries to match parent MS header info.
//              Initialize all member variables.
//
//  Notes:
//
//--------------------------------------------------------------------------

CFat::CFat(SID sid, USHORT cbSector, USHORT uSectorShift)
: _fv( sid,
       (USHORT) (cbSector >> 2),  // 4 bytes per entry
       (USHORT) (cbSector >> 2) ), 
  // left shift this amount for FAT
  _uFatShift((USHORT) (uSectorShift - 2) ),   
  // (# entries per sector) - 1
  _uFatMask( (USHORT) ((cbSector >> 2) - 1)), 
  _sid(sid),
  _pmsParent(NULL),
  _sectFirstFree( (SECT) 0),
  _sectMax(ENDOFCHAIN)
{
}




//+---------------------------------------------------------------------------
//
//  Member:	CFat::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------

void CFat::Empty(void)
{
    _fv.Empty();
    _pmsParent = NULL;
    _cfsTable = 0;
    _ulFreeSects = MAX_ULONG;
    _sectFirstFree = 0;
    _sectMax = ENDOFCHAIN;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::~CFat, public
//
//  Synopsis:   CFat Destructor
//
//  Algorithm:  delete dynamically allocated storage
//
//  Notes:
//
//--------------------------------------------------------------------------

CFat::~CFat()
{
    msfDebugOut((DEB_FAT,"In CFat destructor.  Size of fat is %lu\n",_cfsTable));

    msfDebugOut((DEB_FAT,"Exiting CFat destructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetFree, private
//
//  Synposis:   Locate and return a free sector in the FAT
//
//  Effects:    May modify full bit on full sectors
//
//  Arguments:  [psectRet] -- Pointer to return value
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  Do a linear search of all tables until a free sector is
//              found.  If all tables are full, extend the FAT by one
//              sector.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetFree(ULONG ulCount, SECT *psectRet)
{
    FSINDEX ipfs;
    FSOFFSET isect;
    SECT sectRetval;
    SCODE sc;
    
    SECT sectLast = ENDOFCHAIN;
    FSINDEX ipfsLast;
    FSOFFSET isectLast;
    
    *psectRet = ENDOFCHAIN;
    
    
    while (TRUE)
    {
        if (_ulFreeSects == MAX_ULONG)
        {
            msfChk(CountFree(&_ulFreeSects));
        }
#if DBG == 1
        else
        {
            ULONG ulFree;
            msfChk(CountFree(&ulFree));
            msfAssert((ulFree == _ulFreeSects) &&
                    aMsg("Free count doesn't match cached value."));
        }
#endif
        
        while (ulCount > _ulFreeSects)
        {
#if DBG == 1
            ULONG ulFree = _ulFreeSects;
#endif
            
            msfChk(Resize(_cfsTable +
                    ((ulCount - _ulFreeSects + _fv.GetSectTable() - 1) >>
                     _uFatShift)));
            
#if DBG == 1
            msfAssert(_ulFreeSects > ulFree &&
                aMsg("Number of free sectors didn't increase after Resize."));
#endif
        }
        
        FSOFFSET isectStart;
        FSINDEX ipfsStart;
        
        SectToPair(_sectFirstFree, &ipfsStart, &isectStart);
        
        for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
        {
            CVectBits *pfb = _fv.GetBits(ipfs);
            if ((pfb == NULL) || (!pfb->full))
            {
                CFatSect *pfs;
                msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
                if (pfb != NULL)
                {
                    isectStart = pfb->firstfree;
                }
                
                for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
                {
                    SECT sectCurrent = pfs->GetSect(isect);
                    SECT sectNew = PairToSect(ipfs, isect);
                    
                    
                    if (sectCurrent == FREESECT)
                    {
                        msfAssert(_ulFreeSects != MAX_ULONG &&
                                aMsg("Free sect count not set"));
                        
                        _ulFreeSects--;
                        
                        sectRetval = sectNew;
                        
                        if (pfb != NULL)
                        {
                            olAssert(isect+1 < USHRT_MAX);
                            pfb->firstfree = (USHORT) (isect + 1);
                        }
                        
                        msfAssert(sectRetval >= _sectFirstFree &&
                                aMsg("Found free sector before _sectFirstFree"));
                        _sectFirstFree = sectRetval + 1;
                        
                        pfs->SetSect(isect, ENDOFCHAIN);
                        msfChkTo(Err_Rel, _fv.SetDirty(ipfs));
                        
                        if (sectLast != ENDOFCHAIN)
                        {
                            if (ipfsLast == ipfs)
                            {
                                pfs->SetSect(isectLast, sectRetval);
                            }
                            else
                            {
                                CFatSect *pfsLast;
                                
                                msfChkTo(Err_Rel, _fv.GetTable(
                                        ipfsLast,
                                        FB_DIRTY,
                                        &pfsLast));
                                
                                pfsLast->SetSect(isectLast, sectRetval);
                                _fv.ReleaseTable(ipfsLast);
                            }
                        }
                        
                        if (*psectRet == ENDOFCHAIN)
                        {
                            *psectRet = sectRetval;
                        }
                        
                        ulCount--;
                        
                        if (ulCount == 0)
                        {
                            _fv.ReleaseTable(ipfs);

                            if (sectRetval >= _sectMax)
                            {
                                _sectMax = sectRetval + 1;
                            }
                            return S_OK;
                        }
                        else
                        {
                            sectLast = sectRetval;
                            ipfsLast = ipfs;
                            isectLast = isect;
                        }
                    }
                }
                _fv.ReleaseTable(ipfs);
                if (pfb != NULL)
                {
                    pfb->full = TRUE;
                }
            }
            isectStart = 0;
        }
        if (sectRetval >= _sectMax)
        {
            _sectMax = sectRetval + 1;
        }
    }
    msfAssert(0 &&
            aMsg("GetFree exited improperly."));
    sc = STG_E_ABNORMALAPIEXIT;
    
 Err:
    return sc;
    
 Err_Rel:
    _fv.ReleaseTable(ipfs);
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetLength, public
//
//  Synposis:   Return the length of a fat chain.
//
//  Arguments:  [sect] -- Sector to begin count at.
//
//  Returns:    Length of the chain, in sectors
//
//  Algorithm:  Traverse the chain until ENDOFCHAIN is reached.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetLength(SECT sect, ULONG * pulRet)
{
    msfDebugOut((DEB_FAT,"In CFat::GetLength(%lu)\n",sect));
    SCODE sc = S_OK;

    ULONG csect = 0;

    while (sect != ENDOFCHAIN)
    {
        msfChk(GetNext(sect, &sect));
        csect++;
    }

    msfDebugOut((DEB_FAT,"FAT: GetLength returned %u\n",csect));
    *pulRet =  csect;
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::Init, public
//
//  Synposis:   Sets up a FAT, reading data from an existing stream
//
//  Effects:    Changes all _apfsTable entries, _cfsTable, and all
//              flags fields
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Read size from first FAT in stream.
//              Resize array to necessary size.
//              Read in FAT sectors sequentially.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::Init(CMStream *pmsParent, FSINDEX cFatSect, BOOL fConvert)
{
    SCODE sc;
    UNREFERENCED_PARM(fConvert);
    msfDebugOut((DEB_FAT,"CFat::setup thinks the FAT is size %lu\n",cFatSect));

    _pmsParent = pmsParent;

    msfChk(_fv.Init(_pmsParent, cFatSect));

    _cfsTable = cFatSect;

    USHORT cbSectorSize;
    cbSectorSize = _pmsParent->GetSectorSize();

    _ulFreeSects = MAX_ULONG;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::InitConvert, public
//
//  Synopsis:   Init function used for conversion
//
//  Arguments:  [sectData] -- number of sectors used by file
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CFat::InitConvert(CMStream *pmsParent, SECT sectData)
{
    SCODE sc;
    msfDebugOut((DEB_FAT,"Doing conversion\n"));
    _pmsParent = pmsParent;

    msfAssert((sectData != 0) &&
            aMsg("Attempt to convert zero length file."));

    SECT sectMax = 0;
    FSINDEX csectFat = 0;
    FSINDEX csectLast;

    if (_sid == SIDFAT)
    {
        SECT sectTotal;

        //Since the fat needs to represent itself, we can't determine
        //   the actual number of sectors needed in one pass.  We
        //   therefore loop, factoring in the number of fat sectors
        //   at each iteration, until we reach a stable state.
        //
        //As an example, consider the case where each fat sector represents
        //   128 sectors and the file being converted is 128 sectors long.
        //   There will be no DIFat - therefore, we have 128 sectors needed
        //   on the first pass, which will require 1 fat sector to
        //   represent them.  On the second pass, we discover that we
        //   actually need 2 fat sectors, since we now have 129 total
        //   sectors to allocate space for.  The third pass will result
        //   in a stable state.
        do
        {
            csectLast = csectFat;
            sectTotal = sectData + _pmsParent->GetHeader()->GetDifLength() +
                csectFat + 1;
            csectFat = (sectTotal + _fv.GetSectTable() - 1) >> _uFatShift;
        }
        while (csectLast != csectFat);
        sectMax = sectData + _pmsParent->GetHeader()->GetDifLength();
    }
    else
    {
        //The minifat doesn't need to represent itself, so we can
        //  compute the number of sectors needed in one pass.
        sectMax = sectData;
        csectFat = (sectMax + _fv.GetSectTable() -1) >> _uFatShift;
    }

    msfChk(_fv.Init(_pmsParent, csectFat));

    FSINDEX i;

    if (_sid == SIDMINIFAT)
    {
        SECT sectFirst;
        msfChk(_pmsParent->GetFat()->Allocate(csectFat, &sectFirst));

        _pmsParent->GetHeader()->SetMiniFatStart(sectFirst);

        _pmsParent->GetHeader()->SetMiniFatLength(csectFat);
    }


    for (i = 0; i < csectFat; i++)
    {
        CFatSect *pfs;

        msfChk(_fv.GetTable(i, FB_NEW, &pfs));
        if (_sid == SIDFAT)
        {
            _fv.SetSect(i, sectMax + i);
            _pmsParent->GetDIFat()->SetFatSect(i, sectMax + i);
        }
        else
        {
            SECT sect;
            msfChk(_pmsParent->GetESect(_sid, i, &sect));
            _fv.SetSect(i, sect);
        }

        _fv.ReleaseTable(i);
    }


    _cfsTable = csectFat;

    if (_sid != SIDMINIFAT)
    {

        _pmsParent->GetHeader()->SetFatLength(_cfsTable);

        SECT sect;

        if (sectData > 1)
        {
            for (sect = 0; sect < sectData - 2; sect++)
            {
                msfChk(SetNext(sect, sect + 1));
            }

            msfChk(SetNext(sectData - 2, ENDOFCHAIN));
            msfChk(SetNext(sectData - 1, 0));
        }
        else
        {
            //In the event that the file to be converted is less
            //  than one sector long, we don't need to create a
            //  real chain, just a single terminated sector.
            msfChk(SetNext(0, ENDOFCHAIN));
        }


        for (sect = sectData; sect < sectMax; sect++)
        {
            msfChk(SetNext(sect, DIFSECT));
        }

        for (ULONG j = 0; j < csectFat; j++)
        {
            msfChk(SetNext(sectMax + j, FATSECT));
        }

        //Set up directory chain.
        msfChk(SetNext(sectMax + i, ENDOFCHAIN));

        _pmsParent->GetHeader()->SetDirStart(sectMax + i);

        _ulFreeSects = (_cfsTable << _uFatShift) - (sectMax + csectFat + 1);
    }
    else
    {
        for (SECT sect = 0; sect < sectData -1; sect++)
        {
            msfChk(SetNext(sect, sect + 1));
        }
        msfChk(SetNext(sectData - 1, ENDOFCHAIN));
        _ulFreeSects = (_cfsTable << _uFatShift) - sectData;
    }

        msfChk(_pmsParent->SetSize());

Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFat::InitNew, public
//
//  Synposis:   Sets up a FAT for a newly created multi-strean
//
//  Effects:    Changes all _apfsTable entries, _cfsTable, and all
//              flags fields
//
//  Arguments:  [pmsparent] -- pointer to parent Mstream
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Set parent pointer.
//              Allocate 1 sector for FAT and 1 for Directory.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::InitNew(CMStream *pmsParent)
{
    msfDebugOut((DEB_FAT,"In CFat::InitNew()\n"));
    SCODE sc;

    _pmsParent = pmsParent;

    FSINDEX count;
    if (SIDMINIFAT == _sid)
        count = _pmsParent->GetHeader()->GetMiniFatLength();
    else
        count = _pmsParent->GetHeader()->GetFatLength();

    msfDebugOut((DEB_FAT,"Setting up Fat of size %lu\n",count));

    msfChk(_fv.Init(_pmsParent, count));

    _cfsTable = count;

    if (SIDFAT == _sid)
    {
        FSINDEX ipfs;
        FSOFFSET isect;
        CFatSect *pfs;

        SectToPair(_pmsParent->GetHeader()->GetFatStart(), &ipfs, &isect);
        msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));
        _fv.SetSect(ipfs, _pmsParent->GetHeader()->GetFatStart());
        _fv.ReleaseTable(ipfs);

        msfChk(SetNext(_pmsParent->GetHeader()->GetFatStart(), FATSECT));
        msfDebugOut((DEB_ITRACE,"Set sector %lu (FAT) to ENDOFCHAIN\n",_pmsParent->GetHeader()->GetFatStart()));

        msfChk(SetNext(_pmsParent->GetHeader()->GetDirStart(), ENDOFCHAIN));
        msfDebugOut((DEB_ITRACE,"Set sector %lu (DIR) to ENDOFCHAIN\n",_pmsParent->GetHeader()->GetDirStart()));
        _ulFreeSects = (count << _uFatShift) - 2;
    }
    else
    {
        _ulFreeSects = 0;
    }

        msfChk(_pmsParent->SetSize());

    msfDebugOut((DEB_FAT,"Exiting CFat::setupnew()\n"));

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::Resize, private
//
//  Synposis:   Resize FAT, both in memory and in the file
//
//  Effects:    Modifies _cfsTable, _apfsTable, and all flags fields
//
//  Arguments:  [ulSize] -- New size (in # of tables) for FAT
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Allocate new array of new size.
//              Copy over all old pointers.
//              Allocate new tables for any necessary.
//
//  Notes:               This routine currently cannot reduce the size of a fat
                                                                     
//---------------------------------------------------------------------------

SCODE CFat::Resize(ULONG ulSize)
{
    msfDebugOut((DEB_FAT,"In CFat::Resize(%lu)\n",ulSize));
    SCODE sc;

    if (ulSize == _cfsTable)
    {
        return S_OK;
    }

    ULONG csect = _cfsTable;

    msfAssert(ulSize > _cfsTable &&
            aMsg("Attempted to shrink Fat"));


    ULONG ipfs;
    SECT sectNew;

    CFat *pfat = _pmsParent->GetFat();


    if (_sid == SIDFAT)
    {

        //Make sure we have enough space for all of the sectors
        //  to be allocated.

        ULONG csectFat = ulSize - _cfsTable;
        ULONG csectPerDif = (1 << _uFatShift) - 1;
        ULONG csectDif = (csectFat + csectPerDif - 1) / csectPerDif;


        //Assuming all the free sectors are at the end of the file,
        //   we need a file csectNew sectors long to hold them.

        ULONG csectOld, csectNew;

        msfChk(FindMaxSect(&csectOld));

        csectNew = csectOld + csectFat + csectDif;

        ULARGE_INTEGER cbSize;
        
        ULISet32(cbSize, ConvertSectOffset(
                csectNew,
                0,
                _pmsParent->GetSectorShift()));

        msfHChk(_pmsParent->GetILB()->SetSize(cbSize));

        //If we are the fat, we have enough space in the file for
        //  ourselves at this point.
    }
    else
    {
        if (_cfsTable == 0)
        {
            msfChk(pfat->Allocate(ulSize, &sectNew));
            _pmsParent->GetHeader()->SetMiniFatStart(sectNew);
        }
        else
        {
            sectNew = _pmsParent->GetHeader()->GetMiniFatStart();

            SECT sectLast;
            msfChk(pfat->GetESect(sectNew, ulSize - 1, &sectLast));

        }

        msfChk(_pmsParent->SetSize());


        msfChk(pfat->GetSect(sectNew, csect, &sectNew));

        //If we are the Minifat, we have enough space in the underlying
        //  file for ourselves at this point.
    }


    _fv.Resize(ulSize);


    for (ipfs = csect; ipfs < ulSize; ipfs++)
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));
        _cfsTable = ipfs + 1;
        _ulFreeSects += (1 << _uFatShift);

        if (_sid == SIDFAT)
        {
            msfChk(pfat->GetFree(1, &sectNew));

            msfChk(_pmsParent->GetDIFat()->SetFatSect(ipfs, sectNew));
            msfChk(pfat->SetNext(sectNew, FATSECT));
        }

        msfAssert(sectNew != ENDOFCHAIN &&
                aMsg("Bad sector returned for fatsect."));

        _fv.SetSect(ipfs, sectNew);
        _fv.ReleaseTable(ipfs);

        if (_sid == SIDMINIFAT)
        {
            msfChk(pfat->GetNext(sectNew, &sectNew));
        }
    }

    msfDebugOut((DEB_FAT,"CFat::Resize() - all new objects allocated\n"));

    if (SIDMINIFAT == _sid)
        _pmsParent->GetHeader()->SetMiniFatLength(_cfsTable);
    else
        _pmsParent->GetHeader()->SetFatLength(_cfsTable);


    //This setsize should only shrink the file.
#if DBG == 1
    STATSTG stat;

    msfHChk(_pmsParent->GetILB()->Stat(&stat, STATFLAG_NONAME));
#endif

        msfChk(_pmsParent->SetSize());

#if DBG == 1
    STATSTG statNew;

    msfHChk(_pmsParent->GetILB()->Stat(&statNew, STATFLAG_NONAME));

    msfAssert(ULIGetLow(statNew.cbSize) <= ULIGetLow(stat.cbSize));
#endif

    msfDebugOut((DEB_FAT,"Out CFat::Resize(%lu)\n",ulSize));

Err:
    return sc;
}






//+-------------------------------------------------------------------------
//
//  Member:     CFat::Extend, private
//
//  Synposis:   Increase the size of an existing chain
//
//  Effects:    Modifies ulSize sectors within the fat.  Causes one or
//              more sector writes.
//
//  Arguments:  [sect] -- Sector ID of last sector in chain to be extended
//              [ulSize] -- Number of sectors to add to chain
//
//  Requires:   sect must be at the end of a chain.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Use calls to GetFree to allocate chain.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::Extend(SECT sect, ULONG ulSize)
{
    SCODE sc;

    msfDebugOut((DEB_FAT,"In CFat::Extend(%lu,%lu)\n",sect,ulSize));
    SECT sectTemp;

    msfChk(GetFree(ulSize, &sectTemp));
    msfChk(SetNext(sect, sectTemp));

    msfDebugOut((DEB_FAT,"Out CFat::Extend()\n"));

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetNext, public
//
//  Synposis:   Returns the next sector in a chain, given a sector
//
//  Arguments:  [sect] -- Sector ID of any sector in a chain.
//
//  Returns:    Sector ID of next sector in chain, ENDOFCHAIN if at end
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetNext(const SECT sect, SECT * psRet)
{
    SCODE sc;

    FSINDEX ipfs;
    FSOFFSET isect;

    msfAssert(sect <= MAXREGSECT &&
            aMsg("Called GetNext() on invalid sector"));

    SectToPair(sect, &ipfs, &isect);
    CFatSect *pfs;
    msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

    *psRet = pfs->GetSect(isect);

    _fv.ReleaseTable(ipfs);

    msfAssert(sect != *psRet &&
            aMsg("Detected loop in fat chain."));
    return S_OK;

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::SetNext, private
//
//  Synposis:   Set the next sector in a chain
//
//  Effects:    Modifies a single entry within the fat.
//
//  Arguments:  [sectFirst] -- Sector ID of first sector
//              [sectNext] -- Sector ID of next sector
//
//  Returns:    void
//
//  Notes:
//
//---------------------------------------------------------------------------
SCODE CFat::SetNext(SECT sectFirst, SECT sectNext)
{
    FSINDEX ipfs;
    FSOFFSET isect;
    SCODE sc;


    //  creating infinite loops is a no-no
    msfAssert(sectFirst != sectNext &&
            aMsg("Attempted to create loop in Fat chain"));
    msfAssert(sectFirst <= MAXREGSECT &&
            aMsg("Called SetNext on invalid sector"));

    SectToPair(sectFirst, &ipfs, &isect);

    CFatSect *pfs;

    msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));

    pfs->SetSect(isect,sectNext);

    _fv.ReleaseTable(ipfs);

    if (sectNext == FREESECT)
    {
        CVectBits *pfb;
        pfb = _fv.GetBits(ipfs);

        if ((pfb != NULL) &&
            ((pfb->full == TRUE) || (isect < pfb->firstfree)))
        {
            pfb->full = FALSE;
            pfb->firstfree = isect;
        }

        if (sectFirst == _sectMax - 1)
        {
            _sectMax = ENDOFCHAIN;
        }
        if (sectFirst < _sectFirstFree)
        {
            _sectFirstFree = sectFirst;
        }

        if (_ulFreeSects != MAX_ULONG)
        {
                _ulFreeSects++;
        }
    }

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::CountFree, private
//
//  Synposis:   Count and return the number of free sectors in the Fat
//
//  Arguments:  void.
//
//  Returns:    void.
//
//  Algorithm:  Do a linear search of the Fat, counting free sectors.
//              If a FatSect has its full bit set, it is not necessary
//              to search that FatSect.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::CountFree(ULONG * pulRet)
{
    msfDebugOut((DEB_FAT,"In CFat::CountFree()\n"));
    SCODE sc = S_OK;

    FSINDEX ipfs;
    ULONG csectFree=0;
    FSOFFSET isectStart;
    FSINDEX ipfsStart;

    SectToPair(_sectFirstFree, &ipfsStart, &isectStart);

    for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
    {
        CVectBits *pfb = _fv.GetBits(ipfs);

        if ((pfb == NULL) || (!pfb->full))
        {
            msfDebugOut((DEB_FAT,"Checking table %lu\n",ipfs));
            CFatSect *pfs;
            msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

            if (pfb != NULL)
            {
                isectStart = pfb->firstfree;
            }

            FSOFFSET isect;
            for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
            {
                SECT sectCurrent = pfs->GetSect(isect);
                SECT sectNew = PairToSect(ipfs, isect);
                

                
                if (sectCurrent == FREESECT)
                {
                    csectFree++;
                }
            }
            _fv.ReleaseTable(ipfs);
        }
        isectStart = 0;
    }
    msfDebugOut((DEB_FAT,"Countfree returned %lu\n",csectFree));
    *pulRet = csectFree;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetSect, public
//
//  Synposis:   Return the nth sector in a chain
//
//  Arguments:  [sect] -- Sector ID of beginning of chain
//              [uNum] -- indicator of which sector is to be returned
//              [psectReturn] -- Pointer to storage for return value
//
//  Returns:    S_OK.
//
//  Algorithm:  Linearly traverse chain until numth sector
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetSect(SECT sect, ULONG ulNum, SECT * psectReturn)
{
    msfDebugOut((DEB_FAT,"In CFat::GetSect(%lu,%lu)\n",sect,ulNum));

    SCODE sc = S_OK;

    if (ulNum == 0)
    {
        msfDebugOut((DEB_FAT,"Out CFat::GetSect()=>%lu\n",sect));
    }
    else if ((SIDFAT == _sid) &&
             (_pmsParent->GetHeader()->GetFatStart() == sect))
    {
        msfChk(_pmsParent->GetDIFat()->GetFatSect(ulNum, &sect));
    }
    else for (ULONG i = 0; i < ulNum; i++)
    {
        msfChk(GetNext(sect, &sect));
        if (sect > MAXREGSECT)
        {
            //The stream isn't long enough, so stop.
            msfAssert(sect == ENDOFCHAIN &&
                    aMsg("Found invalid sector in fat chain."));
            break;
        }
    }

    *psectReturn = sect;
    msfDebugOut((DEB_FAT,"Out CFat::GetSect()=>%lu\n",sect));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetESect
//
//  Synposis:   Return the nth sector in a chain, extending the chain
//              if necessary.
//
//  Effects:    Modifies fat (via Extend) if necessary
//
//  Arguments:  [sect] -- Sector ID of beginning of chain
//              [ulNum] -- Indicates which sector is to be returned
//              [psectReturn] -- Pointer to storage for return value
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Linearly search chain until numth sector is found.  If
//              the chain terminates early, extend it as necessary.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::GetESect(SECT sect, ULONG ulNum, SECT *psectReturn)
{
    msfDebugOut((DEB_FAT,"In CFat::GetESect(%lu,%lu)\n",sect,ulNum));

    SCODE sc = S_OK;

    ULONG i = 0;
    while (i < ulNum)
    {
        SECT temp;
        msfChk(GetNext(sect, &temp));

        msfAssert(temp != FREESECT &&
                aMsg("FREESECT found in chain."));

        if (temp == ENDOFCHAIN)
        {

            //The stream isn't long enough, so extend it somehow.
            ULONG need = ulNum - i;

            msfAssert((SIDMINIFAT == _sid ||
                    sect != _pmsParent->GetHeader()->GetFatStart()) &&
                    aMsg("Called GetESect on Fat chain"));
            msfChk(Extend(sect,need));
        }
        else
        {
            sect = temp;
            i++;
        }
    }

    msfDebugOut((DEB_FAT,"Exiting GetESect with result %lu\n",sect));
    *psectReturn = sect;

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::SetChainLength, private
//
//  Synposis:   Set the length of a fat chain.  This is used to reduce
//              the length of the chain only.  To extend a chain, use
//              Extend or GetESect
//
//  Effects:    Modifies the fat
//
//  Arguments:  [sectStart] -- Sector to begin at (head of chain)
//              [uLength] -- New length for chain
//
//  Returns:    void.
//
//  Algorithm:  Traverse chain until uLength is reached or the chain
//              terminates.  If it terminates prematurely, return with
//              no other action.  Otherwise, deallocate all remaining
//              sectors in the chain.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::SetChainLength(SECT sectStart, ULONG ulLength)
{
    msfDebugOut((DEB_FAT,"In CFat::SetChainLength(%lu,%lu)\n",sectStart,ulLength));
    SCODE sc;

    if (sectStart == ENDOFCHAIN) return S_OK;

    for (ULONG ui = 0; ui < ulLength; ui++)
    {
        msfChk(GetNext(sectStart, &sectStart));
        if (sectStart == ENDOFCHAIN) return S_OK;
    }

    msfAssert(sectStart != ENDOFCHAIN &&
            aMsg("Called SetChainLength is ENDOFCHAIN start"));

    SECT sectEnd;
    sectEnd = sectStart;

    msfChk(GetNext(sectStart, &sectStart));
    if (ulLength != 0)
    {
        msfChk(SetNext(sectEnd, ENDOFCHAIN));
    }
    else
    {
        msfChk(SetNext(sectEnd, FREESECT));
    }

    while (sectStart != ENDOFCHAIN)
    {
        SECT sectTemp;
        msfChk(GetNext(sectStart, &sectTemp));
        msfChk(SetNext(sectStart, FREESECT));
        sectStart = sectTemp;
    }
    msfDebugOut((DEB_FAT,"Out CFat::SetChainLength()\n"));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFat::FindLast, private
//
//  Synopsis:   Find last used sector in a fat
//
//  Returns:    Location of last used sector
//
//  Algorithm:  Perform a backward linear search until a non-free
//              sector is found.
//
//  Notes:      Used for shadow fats only.
//
//--------------------------------------------------------------------------

SCODE CFat::FindLast(SECT * psectRet)
{
    SCODE sc = S_OK;
    FSINDEX ipfs = _cfsTable;
    SECT sect = 0;

    while (ipfs > 0)
    {
        ipfs--;

        FSOFFSET isect = _fv.GetSectTable();

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

        while (isect > 0)
        {
            isect--;

            SECT sectCurrent = pfs->GetSect(isect);

                
            if (sectCurrent != FREESECT)
            {
                msfDebugOut((DEB_FAT,"FindLast returns %lu\n",PairToSect(ipfs,isect)));
                sect = PairToSect(ipfs, (FSOFFSET) (isect + 1));
                break;
            }
        }

        _fv.ReleaseTable(ipfs);
        if (sect != 0)
            break;
    }

    *psectRet = sect;
Err:
    return sc;
}





//+-------------------------------------------------------------------------
//
//  Method:     CFat::FindMaxSect, private
//
//  Synopsis:   Return last used sector in current Fat.
//
//  Arguments:  None.
//
//  Returns:    Last used sector in current Fat
//
//--------------------------------------------------------------------------

SCODE CFat::FindMaxSect(SECT *psectRet)
{
    SCODE sc = S_OK;

    if (_sectMax == ENDOFCHAIN)
    {
        msfChk(FindLast(psectRet));
    }
    else
    {
#if DBG == 1
        SECT sectLast;
        msfChk(FindLast(&sectLast));
#endif
        *psectRet = _sectMax;
    }

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::Contig, public
//
//  Synposis:   Create contiguous sector table
//
//  Effects:    Creates new CSegment.
//
//  Arguments:  [sect] -- Starting sector for table to begin
//              [ulength] -- Runlength in sectors of table to produce
//
//  Returns:    Pointer to a Segment table
//
//  Algorithm:  Perform calls to CFat::GetNext().  Any call that is
//              1 higher than the previous represents contiguous blocks.
//              Construct the Segment table on that basis.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE  CFat::Contig(
        SSegment STACKBASED *aseg,
        SECT sect,
        ULONG ulLength)
{
    msfDebugOut((DEB_ITRACE,"In CFat::Contig(%lu,%lu)\n",sect,ulLength));
    SCODE sc = S_OK;
    SECT stemp = sect;
    ULONG ulCount = 1;
    USHORT iseg = 0;

    msfAssert(sect != ENDOFCHAIN &&
            aMsg("Called Contig with ENDOFCHAIN start"));

    aseg[iseg].sectStart = sect;
    aseg[iseg].cSect = 1;

    while ((ulLength > 1) && (iseg < CSEG))
    {
        msfAssert(sect != ENDOFCHAIN &&
                aMsg("Contig found premature ENDOFCHAIN"));

        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(sect, &ipfs, &isect);

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
        sect = pfs->GetSect(isect);
        _fv.ReleaseTable(ipfs);

        if (sect == ENDOFCHAIN)
        {
            //Allocate new sectors.

            SECT sectNew;
            msfChk(GetFree(ulLength - 1, &sectNew));
            msfChk(SetNext(stemp, sectNew));
            sect = sectNew;
        }

        if (sect != (stemp + 1))
        {
            aseg[iseg].cSect = ulCount;
            ulCount = 1;
            iseg++;
            aseg[iseg].sectStart = sect;
            stemp = sect;
        }
        else
        {
            ulCount++;
            stemp = sect;
        }
        ulLength--;
    }

    if (iseg < CSEG)
    {
        aseg[iseg].cSect = ulCount;
        aseg[iseg + 1].sectStart = ENDOFCHAIN;
    }
    else
    {
        aseg[iseg].sectStart = FREESECT;
    }

    msfDebugOut((DEB_ITRACE,"Exiting Contig()\n"));

Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\expiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       expiter.cxx
//
//  Contents:   CExposedIterator implementation
//
//---------------------------------------------------------------

#include "exphead.cxx"

#include "expiter.hxx"
#include "h/sstream.hxx"

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::CExposedIterator, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [ppdf] - Public Docfile
//              [pKey] - Initial cursor (doc file name)
//
//---------------------------------------------------------------

CExposedIterator::CExposedIterator(CExposedDocFile *ppdf, CDfName *pKey)
{
    olDebugOut((DEB_ITRACE, "In  CExposedIterator::CExposedIterator("
            "%p, %p)\n", ppdf, pKey));
    _dfnKey.Set(pKey);
    _ppdf = ppdf;
    // keep a ref, so that the pointer is valid throughout life time
    // of iterator
    _ppdf->AddRef();
    _cReferences = 1;
    _sig = CEXPOSEDITER_SIG;
    olDebugOut((DEB_ITRACE,
                "Out CExposedIterator::CExposedIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::~CExposedIterator, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------

CExposedIterator::~CExposedIterator(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedIterator::~CExposedIterator\n"));
    _sig = CEXPOSEDITER_SIGDEL;    
    olAssert(_cReferences == 0);    
    if (_ppdf) _ppdf->Release();    
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::~CExposedIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Next, public
//
//  Synopsis:   Gets N entries from an iterator
//
//  Arguments:  [celt] - Count of elements
//              [rgelt] - Array for element return
//              [pceltFetched] - If non-NULL, contains the number of
//                      elements fetched
//
//  Returns:    Appropriate status code
//
//  Modifies:   [rgelt]
//              [pceltFetched]
//
//---------------------------------------------------------------

SCODE CExposedIterator::Next(ULONG celt,
                             STATSTGW FAR *rgelt,
                             ULONG *pceltFetched)
{
    SCODE sc;
    STATSTGW stat, *pelt = rgelt;    
    ULONG celtDone;
    CDfName dfnInitial;

    olDebugOut((DEB_ITRACE, "In CExposedIterator::Next(%lu, %p, %p)\n", 
                celt, rgelt, pceltFetched));
    
    TRY
    {
        if (pceltFetched)
        {
            olChk(ValidateBuffer(pceltFetched, sizeof(ULONG)));
            *pceltFetched = 0;
        }
        else if (celt > 1)
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        olAssert(0xffffUL/sizeof(STATSTGW) >= celt);
        olChkTo(EH_RetSc, 
                ValidateOutBuffer(rgelt, sizeof(STATSTGW)*celt));
        memset(rgelt, 0, (size_t)(sizeof(STATSTGW)*celt));
        olChk(Validate());
        olChk(_ppdf->CheckReverted());
            
        dfnInitial.Set(&_dfnKey); // preserve initial key to reset on failure
        for (; pelt<rgelt+celt; pelt++)
        {
            sc = _ppdf->FindGreaterEntry(&_dfnKey, NULL, &stat);
            if (FAILED(sc))
            {
                if (sc == STG_E_NOMOREFILES)   sc = S_FALSE;
                break;
            }
            _dfnKey.Set(stat.pwcsName); // advance key
                
            stat.grfMode = 0;
            stat.grfLocksSupported = 0;
            stat.reserved = 0;
            *pelt = stat;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    // Can't move this down because dfnInitial isn't set for all EH_Err cases        
    if (FAILED(sc)) _dfnKey.Set(&dfnInitial);
            
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Next => %lX\n", sc));
EH_Err:
    celtDone = pelt-rgelt;
    if (FAILED(sc))
    {
        ULONG i;

        for (i = 0; i<celtDone; i++)
        delete[] rgelt[i].pwcsName;
        memset(rgelt, 0, (size_t)(sizeof(STATSTGW)*celt));
    }
    else if (pceltFetched)
        *pceltFetched = celtDone;
EH_RetSc:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Skip, public
//
//  Synopsis:   Skips N entries from an iterator
//
//  Arguments:  [celt] - Count of elements
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::Skip(ULONG celt)
{
    SCODE sc;
    CDfName dfnNext;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::Skip(%lu)\n", celt));
    TRY
    {
        olChk(Validate());
        olChk(_ppdf->CheckReverted());        
        for (; celt>0; celt--)
        {
            sc = _ppdf->FindGreaterEntry(&_dfnKey, &dfnNext, NULL);
            if (FAILED(sc))
            {
                if (sc == STG_E_NOMOREFILES)
                    sc = S_FALSE;
                break;
            }
            _dfnKey.Set(&dfnNext); // advance the cursor
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Skip\n"));
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Reset, public
//
//  Synopsis:   Rewinds the iterator
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::Reset(void)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::Reset()\n"));

    TRY
    {
        olChk(Validate());        
        _dfnKey.Set((WORD)0, (BYTE*)NULL);  // set to smallest key
        sc = _ppdf->CheckReverted();
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Reset\n"));
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Clone, public
//
//  Synopsis:   Clones this iterator
//
//  Arguments:  [ppenm] - Clone return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::Clone(IEnumSTATSTG **ppenm)
{
    SCODE sc;
    CExposedIterator *piExp;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::Clone(%p)\n", ppenm));
    TRY
    {
	olChk(ValidateOutPtrBuffer(ppenm));
	*ppenm = NULL;
	olChk(Validate());
        olChk(_ppdf->CheckReverted());
        olMem(piExp = new CExposedIterator(_ppdf, &_dfnKey));
	*ppenm = piExp;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Clone => %p\n",
                SAFE_DREF(ppenm)));
    // Fall through
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Release, public
//
//  Synopsis:   Releases resources for the iterator
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CExposedIterator::Release(void)
{
    ULONG lRet;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::Release()\n"));
    TRY
    {
        if (FAILED(Validate()))
            return 0;
        olAssert(_cReferences > 0);
        lRet = --(_cReferences);
        if (_cReferences <= 0)
            delete this;
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        lRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::Release\n"));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CExposedIterator::AddRef(void)
{
    ULONG ulRet;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::AddRef()\n"));
    TRY
    {
        if (FAILED(Validate())) return 0;
        ulRet = ++(_cReferences);
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        ulRet = 0;
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::AddRef\n"));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//---------------------------------------------------------------

STDMETHODIMP CExposedIterator::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedIterator::QueryInterface(?, %p)\n",
                ppvObj));
    TRY
    {
        olChk(Validate());
        olChk(ValidateOutPtrBuffer(ppvObj));
        *ppvObj = NULL;
        olChk(_ppdf->CheckReverted());
        olChk(ValidateIid(iid));
        if (IsEqualIID(iid, IID_IEnumSTATSTG) || IsEqualIID(iid, IID_IUnknown))
        {
            *ppvObj = this;
            AddRef();
            sc = S_OK;
        }
        else 
        {
            sc = E_NOINTERFACE;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::QueryInterface => %p\n",
                SAFE_DREF(ppvObj)));
EH_Err:
    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\iter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       iter.cxx
//
//  Contents:   CDocFileIterator implementation
//
//---------------------------------------------------------------

#include "dfhead.cxx"


#include "h/msfiter.hxx"
#include "iter.hxx"



//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::CDocFileIterator, public
//
//  Synopsis:   Empty object ctor
//
//---------------------------------------------------------------

CDocFileIterator::CDocFileIterator(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::CDocFileIterator()\n"));
    _pi = NULL;
    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::CDocFileIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::Init
//
//  Synopsis:   Constructor
//
//  Arguments:  [ph] - Multistream handle
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CDocFileIterator::Init(CStgHandle *ph)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::Init(%p)\n", ph));
    if (FAILED(sc = ph->GetIterator(&_pi)))
        _pi = NULL;
    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::Init\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::~CDocFileIterator
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------

CDocFileIterator::~CDocFileIterator(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::~CDocFileIterator\n"));
    if (_pi)
        _pi->Release();
    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::~CDocFileIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::GetNext
//
//  Synopsis:   Get the next entry
//
//  Arguments:  [pstatstg] - Buffer to return information in
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//---------------------------------------------------------------


SCODE CDocFileIterator::GetNext(STATSTGW *pstatstg)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::GetNext(%p)\n", pstatstg));

    if (FAILED(sc = _pi->GetNext(pstatstg)))
    {
#if DEVL == 1
        // Null the name to clean up some debug prints
        pstatstg->pwcsName = NULL;
#endif
    }

    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::GetNext => %ws, %ld\n",
                pstatstg->pwcsName, pstatstg->type));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::BufferGetNext, public
//
//  Synopsis:   Fast, fixed-space version of GetNext
//
//  Arguments:  [pib] - Buffer to fill in
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pib]
//
//---------------------------------------------------------------


SCODE CDocFileIterator::BufferGetNext(SIterBuffer *pib)
{
    return _pi->BufferGetNext(pib);
}


//+--------------------------------------------------------------
//
//  Member:     CDocFileIterator::Release, public
//
//  Synopsis:   Releases resources for an iterator
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

void CDocFileIterator::Release(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFileIterator::Release()\n"));
    delete this;
    olDebugOut((DEB_ITRACE, "Out CDocFileIterator::Release\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\funcs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       funcs.cxx
//
//  Contents:   Generic DocFile support functions
//
//  Functions:  ModeToTFlags
//              CheckName
//              wcsdup
//              VerifyPerms
//
//---------------------------------------------------------------

#include "dfhead.cxx"

//+--------------------------------------------------------------
//
//  Function:   ModeToDFlags, private
//
//  Synopsis:   Translates STGM flags to DF flags
//
//  Arguments:  [dwModeFlags]
//
//  Returns:    DF_*
//
//---------------------------------------------------------------

DFLAGS ModeToDFlags(DWORD const dwModeFlags)
{
    DFLAGS df;

    olDebugOut((DEB_ITRACE, "In  ModeToDFlags(%lX)\n", dwModeFlags));
    if ((dwModeFlags & STGM_TRANSACTED) == 0)
        df = DF_DIRECT;
    else
        df = DF_TRANSACTED;
    if ((dwModeFlags & STGM_TRANSACTED) &&
        (dwModeFlags & STGM_PRIORITY) == 0 &&
        (dwModeFlags & STGM_DENY) != STGM_SHARE_DENY_WRITE &&
        (dwModeFlags & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
        df |= DF_INDEPENDENT;
    switch(dwModeFlags & STGM_RDWR)
    {
    case STGM_READ:
        df |= DF_READ;
        break;
    case STGM_WRITE:
        df |= DF_WRITE;
        break;
    case STGM_READWRITE:
        df |= DF_READWRITE;
        break;
    default:
        olAssert(FALSE);
        break;
    }
    switch(dwModeFlags & STGM_DENY)
    {
    case STGM_SHARE_DENY_READ:
        df |= DF_DENYREAD;
        break;
    case STGM_SHARE_DENY_WRITE:
        df |= DF_DENYWRITE;
        break;
    case STGM_SHARE_EXCLUSIVE:
        df |= DF_DENYALL;
        break;
        // Default is deny none
    }
    if (dwModeFlags & STGM_PRIORITY)
        df |= DF_PRIORITY;
    olDebugOut((DEB_ITRACE, "Out ModeToDFlags => %lX\n", df));
    return df;
}

//+--------------------------------------------------------------
//
//  Function:   DFlagsToMode, private
//
//  Synopsis:   Converts the read/write/denials/transacted/priority
//              to STGM flags
//
//  Arguments:  [df] - DFlags
//
//  Returns:    STGM flags
//
//---------------------------------------------------------------

DWORD DFlagsToMode(DFLAGS const df)
{
    DWORD dwMode;

    olDebugOut((DEB_ITRACE, "In  DFlagsToMode(%X)\n", df));
    if (P_READ(df))
        if (P_WRITE(df))
            dwMode = STGM_READWRITE;
        else
            dwMode = STGM_READ;
    else if (P_WRITE(df))
        dwMode = STGM_WRITE;
    // Must have either read or write, so no else

    if (P_DENYREAD(df))
        if (P_DENYWRITE(df))
            dwMode |= STGM_SHARE_EXCLUSIVE;
        else
            dwMode |= STGM_SHARE_DENY_READ;
    else if (P_DENYWRITE(df))
        dwMode |= STGM_SHARE_DENY_WRITE;
    else
        dwMode |= STGM_SHARE_DENY_NONE;

    if (P_TRANSACTED(df))
        dwMode |= STGM_TRANSACTED;

    if (P_PRIORITY(df))
        dwMode |= STGM_PRIORITY;

    olDebugOut((DEB_ITRACE, "Out DFlagsToMode\n"));
    return dwMode;
}

//+--------------------------------------------------------------
//
//  Function:   VerifyPerms, private
//
//  Synopsis:   Checks flags to see if they are valid
//
//  Arguments:  [grfMode] - Permissions
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE VerifyPerms(DWORD grfMode)
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  VerifyPerms(%lX)\n", grfMode));

    // Check for valid flags
    if ((grfMode & STGM_RDWR) > STGM_READWRITE ||
        (grfMode & STGM_DENY) > STGM_SHARE_DENY_NONE ||
        (grfMode & ~(STGM_RDWR | STGM_DENY | STGM_DIRECT | STGM_TRANSACTED |
                     STGM_PRIORITY | STGM_CREATE | STGM_CONVERT |
                     STGM_FAILIFTHERE | STGM_DELETEONRELEASE)))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // We don't support these modes
    if (grfMode & (STGM_PRIORITY|STGM_TRANSACTED|STGM_SIMPLE))
    {
        olAssert( FALSE && 
            aMsg("Unsupported feature of reference implemention called"));
        return STG_E_INVALIDFUNCTION;
    }
    
    // Check to make sure only one existence flag is specified
    // FAILIFTHERE is zero so it can't be checked
    if ((grfMode & (STGM_CREATE | STGM_CONVERT)) ==
        (STGM_CREATE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // If not transacted and not priority, you can either be
    // read-only deny write or read-write deny all
    if ((grfMode & (STGM_TRANSACTED | STGM_PRIORITY)) == 0)
    {
        if ((grfMode & STGM_RDWR) == STGM_READ)
        {
            //  we're asking for read-only access

            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
                (grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE)
            {
                //  Can't allow others to have write access
                olErr(EH_Err, STG_E_INVALIDFLAG);
            }
        }
        else
        {
            //  we're asking for write access

            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
            {
                //  Can't allow others to have any access
                olErr(EH_Err, STG_E_INVALIDFLAG);
            }
        }
    }
    olDebugOut((DEB_ITRACE, "Out VerifyPerms\n"));
    // Fall through
EH_Err:
    return sc;
}



//+--------------------------------------------------------------
//
//  Function:   wcsdup, public
//
//  Synopsis:   Duplicates a WCHAR string
//
//  Arguments:  [pwcs] - String
//
//  Returns:    Pointer to new string or Appropriate status code
//
//---------------------------------------------------------------

WCHAR * __cdecl wcsdup(WCHAR const *pwcs)
{
    WCHAR *pwcsNew;

    olDebugOut((DEB_ITRACE, "In  wcsdup(%ws)\n", pwcs));
    pwcsNew = new WCHAR[wcslen(pwcs)+1];
    if (pwcsNew == NULL)
        return NULL;
    wcscpy(pwcsNew, pwcs);
    olDebugOut((DEB_ITRACE, "Out wcsdup => %p\n", pwcsNew));
    return pwcsNew;
}



//+--------------------------------------------------------------
//
//  Function:   ValidateSNBW
//
//  Synopsis:   Validates SNB memory
//
//  Arguments:  [snb] - SNB
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------
#ifdef _UNICODE
SCODE ValidateSNBW(SNBW snb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  ValidateSNB(%p)\n", snb));
    for (;;)
    {
        olChk(ValidatePtrBuffer(snb));
        if (*snb == NULL)
            break;
        olChk(ValidateNameW(*snb, CWCMAXPATHCOMPLEN));
        snb++;
    }
    olDebugOut((DEB_ITRACE, "Out ValidateSNB\n"));
    return S_OK;
EH_Err:
    return sc;
}
#endif // ifdef _UNICODE
//+--------------------------------------------------------------
//
//  Function:   CheckWName, public
//
//  Synopsis:   Checks name for illegal characters and length
//
//  Arguments:  [pwcsName] - Name
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

#ifdef _UNICODE
WCHAR wcsInvalid[] = { '\\', '/', ':', '!','\0' };

SCODE CheckWName(WCHAR const *pwcsName)
{
    SCODE sc;
    olDebugOut((DEB_ITRACE, "In  CheckWName(%s)\n", pwcsName));
    if (FAILED(sc = ValidateNameW(pwcsName, CBMAXPATHCOMPLEN)))
        return sc;
    // >= is used because the max len includes the null terminator
    if (wcslen(pwcsName) >= CWCMAXPATHCOMPLEN)
        return STG_E_INVALIDNAME;
    for (; *pwcsName; pwcsName++)
    {
        if ( wcschr(wcsInvalid, *pwcsName) )
            return STG_E_INVALIDNAME;
    }
    olDebugOut((DEB_ITRACE, "Out CheckWName\n"));
    return S_OK;
} 
#else  // validation done in ascii layer already

#define CheckWName(pwcsName) (S_OK)

#endif // ifdef _UNICODE

//+--------------------------------------------------------------
//
//  Function:   CopyDStreamToDStream
//
//  Synopsis:   Copies the contents of a stream to another stream
//
//  Arguments:  [pstFrom] - Stream to copy from
//              [pstTo] - Stream to copy to
//
//  Returns:    Appropriate status code
//
//  Notes:      This function may fail due to out of memory.  It
//              may not be used by callers who must not fail due
//              to out of memory.
//
//              This function does not check permissions
//              for write in the to streams.
//
//---------------------------------------------------------------

SCODE CopyStreamToStream(CDirectStream *pstFrom, 
                         CDirectStream *pstTo)
{
    BYTE *pbBuffer;
    SCODE sc;
    ULONG cbRead, cbWritten, cbSize, cbPos;

    // Set destination size for contiguity    
    pstFrom->GetSize(&cbSize);
    olChk(pstTo->SetSize(cbSize));

    // We're allowed to fail due to out of memory
    olMem(pbBuffer = new BYTE[STREAMBUFFERSIZE]);

    // Copy between streams
    cbPos = 0;
    for (;;)
    {
        olChkTo(EH_pbBuffer,
                pstFrom->ReadAt(cbPos, pbBuffer, STREAMBUFFERSIZE,
                                 (ULONG STACKBASED *)&cbRead));
        if (cbRead == 0) // EOF
            break;
        olChkTo(EH_pbBuffer,
                pstTo->WriteAt(cbPos, pbBuffer, cbRead,
                                (ULONG STACKBASED *)&cbWritten));
        if (cbRead != cbWritten)
            olErr(EH_Err, STG_E_WRITEFAULT);
        cbPos += cbWritten;
    }
    delete pbBuffer;
    return S_OK;

EH_pbBuffer:
    delete pbBuffer;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   NameInSNB, private
//
//  Synopsis:   Determines whether the given name is in the SNB
//
//  Arguments:  [dfn] - Name
//              [snb] - SNB
//
//  Returns:    S_OK or S_FALSE
//
//---------------------------------------------------------------

SCODE NameInSNB(CDfName const *dfn, SNBW snb)
{
    SCODE sc = S_FALSE;

    olDebugOut((DEB_ITRACE, "In  NameInSNB(%ws, %p)\n", dfn, snb));
    TRY
    {
        for (; *snb; snb++)
            if (dfwcsnicmp((WCHAR *)dfn->GetBuffer(), (WCHAR *)*snb,
                dfn->GetLength()) == 0)
            {
                sc = S_OK;
                break;
            }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out NameInSNB\n"));
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\header.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       header.cxx
//
//  Contents:   Code to manage MSF header
//
//  Classes:    Defined in header.hxx
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#include "h/dfver.h"

// Function set [uArg] to the byte order of the machine.
//
// it will return 0xFFFE on Little Endian (== the disk order)
// and 0xFEFF on Big Endian

const BYTE abDiskByteOrder[]= {0xFE, 0xFF};

inline void SetMachineByteOrder(USHORT *pUShort)
{
    memcpy(pUShort, abDiskByteOrder, sizeof(abDiskByteOrder));
}

CMSFHeader::CMSFHeader(USHORT uSectorShift)
{
    msfAssert((CSECTFATREAL != CSECTFAT) || (sizeof(CMSFHeader) == HEADERSIZE));
    _uSectorShift = uSectorShift;
    _uMiniSectorShift = MINISECTORSHIFT;
    _ulMiniSectorCutoff = MINISTREAMSIZE;

    _clid = IID_NULL;

    SetMachineByteOrder(&_uByteOrder);

    _uMinorVersion = rmm;
    _uDllVersion = rmj;

    for (SECT sect = 0; sect < CSECTFAT; sect ++)
    {
        _sectFat[sect] = FREESECT;
    }

    SetDifLength(0);
    SetDifStart(ENDOFCHAIN);

    SetFatLength(1);
    SetFatStart(SECTFAT);
    SetDirStart(SECTDIR);

    SetMiniFatLength(0);
    SetMiniFatStart(ENDOFCHAIN);

    _signature = 0;
    _usReserved = 0;
    _ulReserved1 = _ulReserved2 = 0;

    //  Write DocFile signature
    memcpy(abSig, SIGSTG, CBSIGSTG);
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckSignature, private
//
//  Synopsis:   Checks the given memory against known signatures
//
//  Arguments:  [pb] - Pointer to memory to check
//
//  Returns:    S_OK - Current signature
//              S_FALSE - Beta 2 signature, but still successful
//              Appropriate status code
//
//----------------------------------------------------------------------------

//Identifier for first bytes of Beta 2 Docfiles
const BYTE SIGSTG_B2[] = {0x0e, 0x11, 0xfc, 0x0d, 0xd0, 0xcf, 0x11, 0xe0};
const BYTE CBSIGSTG_B2 = sizeof(SIGSTG_B2);

SCODE CheckSignature(BYTE *pb)
{
    SCODE sc;

    msfDebugOut((DEB_ITRACE, "In  CheckSignature(%p)\n", pb));

    // Check for ship Docfile signature first
    if (memcmp(pb, SIGSTG, CBSIGSTG) == 0)
        sc = S_OK;

    // Check for Beta 2 Docfile signature
    else if (memcmp(pb, SIGSTG_B2, CBSIGSTG_B2) == 0)
        sc = S_FALSE;

    else
        sc = STG_E_INVALIDHEADER;

    msfDebugOut((DEB_ITRACE, "Out CheckSignature => %lX\n", sc));
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMSFHeader::Validate, public
//
//  Synopsis:   Validate a header.
//
//  Returns:    S_OK if header is valid.
//
//--------------------------------------------------------------------------

SCODE CMSFHeader::Validate(VOID) const
{
    SCODE sc;

    sc = CheckSignature((BYTE *)abSig);
    if (sc == S_OK)
    {
        // Check file format verson number
        if (GetDllVersion() > rmj)
            return STG_E_OLDDLL;

        // check for unreasonably large SectorShift
        if (GetSectorShift() > MAXSECTORSHIFT)
            return STG_E_DOCFILECORRUPT;

    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\mem.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       mem.cxx
//
//  Contents:   IMalloc interface implementations
//              Note that these functions do little more than
//              the normal delete and new. They are provided
//              so that existing code can be ported to the ref.
//              impl. easily.
//
//---------------------------------------------------------------

#ifndef __MEM__C__
#define __MEM__C__

#include "exphead.cxx"

#include "h/mem.hxx"
#include "memory.h"
#include "h/dfexcept.hxx"

static CAllocator theAllocator;  // global allocator

//+--------------------------------------------------------------
//
//  Function:   CoGetMalloc, public
//
//  Synopsis:   Retrieves a pointer to the default OLE task memory 
//              allocator (which supports the system implementation 
//              of the IMalloc interface) so applications can call 
//              its methods to manage memory.
//
//  Arguments:  [dwMemContext] - Indicates if memory is private or shared 
//              [ppMalloc] - Receives pointer to memory allocator on return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppMalloc]
//
//---------------------------------------------------------------

STDAPI 
CoGetMalloc( DWORD dwMemContext, LPMALLOC * ppMalloc )
{
    if (FAILED(ValidatePtrBuffer(ppMalloc))
         || dwMemContext != 1)
        return ResultFromScode(E_INVALIDARG);
    else 
    {
        *ppMalloc = &theAllocator;
        return S_OK;
    }
}

//+--------------------------------------------------------------
//
//  Function:   CoTaskMemAlloc, public
//
//  Synopsis:   Allocates a block of task memory in the same way 
//              that IMalloc::Alloc does. 
//
//  Arguments:  [cb] - Size in bytes of memory block to be allocated
//
//  Returns:    Allocated memory block
//                     Indicates memory block allocated successfully.
//              NULL
//                     Indicates insufficient memory available.
//
//  Modifies:   [ppMalloc]
//
//---------------------------------------------------------------
STDAPI_(LPVOID) 
CoTaskMemAlloc( ULONG cb )
{
    return theAllocator.Alloc(cb);
}

//+--------------------------------------------------------------
//
//  Function:   CoTaskMemFree, public
//
//  Synopsis:   Frees a block of task memory previously allocated 
//              through a call to the CoTaskMemAlloc or 
//              CoTaskMemRealloc function.
//
//  Arguments:  [pv] - Points to memory block to be freed
//
//  Modifies:   nothing
//
//---------------------------------------------------------------
STDAPI_(void) 
CoTaskMemFree( void* pv )
{
    theAllocator.Free(pv);
}


//+--------------------------------------------------------------
//
//  Function:   CoTaskMemRealloc, public
//
//  Synopsis:   Changes the size of a previously allocated block 
//              of task memory.
//
//  Arguments:  [pv] - Points to memory block to be reallocated
//              [cb] - Size in bytes of block to be reallocated
//
//  Returns:    Reallocated memory block
//                      Indicates memory block successfully reallocated.
//              NULL
//                      Indicates insufficient memory or cb is zero 
//                      and pv is not NULL.
//
//  Modifies:   nothing
//
//---------------------------------------------------------------

STDAPI_(LPVOID) 
CoTaskMemRealloc( LPVOID pv, ULONG cb )
{
    return theAllocator.Realloc(pv, cb);
}

//+---------------------------------------------------------------------------
//
//  Member: CAllocator::QueryInterface, public
//
//  Synopsis:   Standard QI
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//
//----------------------------------------------------------------------------

STDMETHODIMP CAllocator::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    if (IsEqualIID(iid, IID_IMalloc) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IMalloc *) this;
        //CAllocator::AddRef();
    }
    else
        sc = E_NOINTERFACE;

    return ResultFromScode(sc);
}


//+---------------------------------------------------------------------------
//
//  Member: CAllocator::AddRef, public
//
//  Synopsis:   Add reference
//
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAllocator::AddRef(void)
{
    //return ++_cRefs;
    return 1;  // return a dummy value
}


//+---------------------------------------------------------------------------
//
//  Member: CAllocator::Release, public
//
//  Synopsis:   Release
//
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAllocator::Release(void)
{
    return 0; // return a dummy value
}

//+---------------------------------------------------------------------------
//
//  Member: CAllocator::Alloc, public
//
//  Synopsis:   Allocate memory
//
//  Arguments:  [cb] -- Number of bytes to allocate
//
//  Returns:    Pointer to block, NULL if failure
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void *) CAllocator::Alloc ( ULONG cb )
{
    // make sure the retuned value is 8 byte aligned
    return (void *) new LONGLONG[ (cb+7)/sizeof(LONGLONG) ];
}

//+---------------------------------------------------------------------------
//
//  Member: CAllocator::Realloc, public
//
//  Synopsis:   Resize the block given
//
//  Arguments:  [pv] -- Pointer to block to realloc
//              [cb] -- New size for block
//
//  Returns:    Pointer to new block, NULL if failure
//
//  Note:       The current implementation will copy cb # of
//              bytes to the new block, even if the old block
//              has size smaller then cb.
//              ==> potential problems esp if pv is at a
//              memory boundary.
//----------------------------------------------------------------------------

STDMETHODIMP_(void *) 
CAllocator::Realloc( void *pv, ULONG cb )
{
    void* pvNew=NULL;
    if (!pv)                    
        pvNew = Alloc(cb);         
    else
    {
        // make sure the new pointer is 8-byte aligned
        pvNew = (void *) (new LONGLONG [(cb+7)/sizeof(LONGLONG)]);
        if (pvNew)
        {
            memcpy(pvNew, pv, cb);
            delete[] pv;
        }
    }
    return pvNew;
}

//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::Free, public
//
//  Synopsis:   Free a memory block
//
//  Arguments:  [pv] -- Pointer to block to free
//
//  Returns:    void
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CAllocator::Free(void *pv)
{
    delete[] pv;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAllocator::GetSize, public
//
//  Synopsis:	Return the size of the given block
//
//  Arguments:	[pv] -- Block to get size of
//
//  Returns:	(should) Size of block pointer to by 
//              (now) 0
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAllocator::GetSize(void * pv)
{
    UNREFERENCED_PARM(pv);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAllocator::DidAlloc, public
//
//  Synopsis:	Return '1' if this heap allocated pointer at pv
//
//  Arguments:	[pv] -- Pointer to block
//
//  Returns:	'1' == This heap allocated block.
//              '0' == This heap did not allocate block.
//              '-1' == Could not determine if this heap allocated block.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(int) CAllocator::DidAlloc(void FAR * pv)
{
    UNREFERENCED_PARM(pv);
    return -1;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAllocator::HeapMinimize, public
//
//  Synopsis:	Minimize the heap
//
//  Arguments:	None.
//
//  Returns:    void.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CAllocator::HeapMinimize(void)
{
    // do nothing;
    return;
}

#endif // __MEM__C__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\msf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       msf.cxx
//
//  Contents:   Entry points for MSF DLL
//
//  Classes:    None.
//
//  Functions:  DllMuliStreamFromStream
//              DllConvertStreamToMultiStream
//              DllReleaseMultiStream
//              DllGetScratchMultiStream
//              DllIsMultiStream
//
//--------------------------------------------------------------------------
#include "msfhead.cxx"
#include "h/handle.hxx"


//+-------------------------------------------------------------------------
//
//  Function:  DllMultiStreamFromStrea
//
//  Synopsis:   Create a new multistream instance from an existing stream.
//              This is used to reopen a stored multi-stream.
//
//  Effects:    Creates a new CMStream instance
//
//  Arguments:  [ppms] -- Pointer to storage for return of multistream
//              [pplstStream] -- Stream to be used by multi-stream for
//                           reads and writes
//		[dwFlags] - Startup flags
//
//  Returns:    STG_E_INVALIDHEADER if signature on pStream does not
//                  match.
//              STG_E_UNKNOWN if there was a problem in setup.
//              S_OK if call completed OK.
//
//  Algorithm:  Check the signature on the pStream and on the contents
//              of the pStream.  If either is a mismatch, return
//              STG_E_INVALIDHEADER.
//              Create a new CMStream instance and run the setup function.
//              If the setup function fails, return STG_E_UNKNOWN.
//              Otherwise, return S_OK.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllMultiStreamFromStream(CMStream **ppms,
			       ILockBytes **pplstStream,
			       DWORD dwFlags)
{
    SCODE sc;
    CMStream *temp;


    BOOL fConvert = ((dwFlags & RSF_CONVERT) != 0);
    BOOL fTruncate = ((dwFlags & RSF_TRUNCATE) != 0);
    BOOL fCreate = ((dwFlags & RSF_CREATE) != 0);


    msfDebugOut((DEB_ITRACE,"In DllMultiStreamFromStream\n"));

    msfMem(temp = new CMStream(pplstStream, SECTORSHIFT));

    STATSTG stat;
    (*pplstStream)->Stat(&stat, STATFLAG_NONAME);
    msfAssert(ULIGetHigh(stat.cbSize) == 0);
    msfDebugOut((DEB_ITRACE,"Size is: %lu\n",ULIGetLow(stat.cbSize)));

    do
    {
        if ((ULIGetLow(stat.cbSize) != 0) && (fConvert))
        {
            msfChk(temp->InitConvert());
            break;
        }

        if (((ULIGetLow(stat.cbSize) == 0) && fCreate) || (fTruncate))
        {
            msfChk(temp->InitNew());
            break;
        }
        msfChk(temp->Init());
    }
    while (FALSE);

    *ppms = temp;

    msfDebugOut((DEB_ITRACE,"Leaving DllMultiStreamFromStream\n"));

    if (fConvert && ULIGetLow(stat.cbSize))
    {
        return STG_S_CONVERTED;
    }

    return S_OK;

Err:
     delete temp;
     return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllReleaseMultiStream
//
//  Synopsis:   Release a CMStream instance
//
//  Effects:    Deletes a multi-stream instance
//
//  Arguments:  [pms] -- pointer to object to be deleted
//
//  Returns:    S_OK.
//
//  Modifies:   Deletes the object pointed to by pMultiStream
//
//  Algorithm:  Delete the passed in pointer.
//
//  Notes:
//
//--------------------------------------------------------------------------

void DllReleaseMultiStream(CMStream *pms)
{
    msfDebugOut((DEB_TRACE,"In DllReleaseMultiStream(%p)\n",pms));
    delete pms;
    msfDebugOut((DEB_TRACE,"Out DllReleaseMultiStream()\n"));
}





//+-------------------------------------------------------------------------
//
//  Function:   DllIsMultiStream
//
//  Synopsis:   Check a given Lstream to determine if it is a valid
//              multistream.
//
//  Arguments:  [plst] -- Pointer to lstream to check
//
//  Returns:    S_OK if lstream is a valid multistream
//              STG_E_UNKNOWN otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllIsMultiStream(ILockBytes *plst)
{
    SCODE sc;
    CMSFHeader *phdr;

    msfMem(phdr = new CMSFHeader(SECTORSHIFT));

    ULONG ulTemp;

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    msfHChk(plst->ReadAt(ulOffset, phdr, sizeof(CMSFHeader), &ulTemp));
    phdr->ByteSwap();  // swap to machine format if neccessary

    if (ulTemp != sizeof(CMSFHeader))
    {
        msfErr(Err, STG_E_UNKNOWN);
    }

    msfChk(phdr->Validate());

Err:
    delete phdr;
    return sc;
}

#if DEVL == 1

//The following is a private function so I can set the debug level easily.
VOID SetInfoLevel(ULONG x)
{
    msfInfoLevel=x;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\msfhead.cxx ===
//+-------------------------