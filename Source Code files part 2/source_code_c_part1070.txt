    57,27H                        ;; error character = standalone accent
CP850_AC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_AC_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_DI_LO_END-$             ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    ANY_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    CP850_DI_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    16,8BH                        ;; i DIARESIS
CP850_DI_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP850_DI_SP_END-$             ;; length of state section
;;   DB    DIARESIS_SPACE                ;; State ID
;;   DW    ANY_KB                   ;; Keyboard Type
;;   DB    249,0                         ;; error character = standalone accent
;;                                       ;;
;;   DW    CP850_DI_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,249                        ;; error character = standalone accent
;;CP850_DI_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;CP850_DI_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
                                       ;;
CP850_XLAT_END:                        ;; END OF CP850 SECTION
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 852 YUGOSLAV SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC YU_852_XLAT                    ;;
YU_852_XLAT:                           ;;
                                       ;;
    DW     CP852_XLAT_END-$            ;;
    DW     852                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AL_LO_END-$           ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_AL_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,0E7H                       ;; s CARON
   DB    27,0D0H                       ;; d STROKE
   DB    39,09FH                       ;; c CARON
   DB    40,086H                       ;; c ACUTE
   DB    43,0A7H                       ;; z CARON
CP852_AL_LO_T1_END:                  ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AL_LO_END:                     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AL_UP_END-$           ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_AL_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,0E6H                       ;; S CARON
   DB    27,0D1H                       ;; D STROKE
   DB    39,0ACH                       ;; C CARON
   DB    40,08FH                       ;; C ACUTE
   DB    43,0A6H                       ;; Z CARON
CP852_AL_UP_T1_END:                  ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AL_UP_END:                     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,09EH,13H                   ;;
   DB    22,0CFH,16H                   ;; CURRENCY SYMBOL
   DB    27,09EH,1BH                   ;;
   DB    37,088H,25H                   ;;
   DB    38,09DH,26H                   ;;
   DB    43,0CFH,2BH                   ;;
   DB    50,0F5H,32H                   ;;
CP852_THIRD_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
CP852_THIRD_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CA_LO_END-$             ;; length of state section
   DB    CARON_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CA_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0D8H                       ;; e CARON
   DB    19,0FDH                       ;; r CARON
   DB    20,09CH                       ;; t CARON
   DB    21,0A7H                       ;; z CARON
   DB    31,0E7H                       ;; s CARON
   DB    32,0D4H                       ;; d CARON
   DB    38,096H                       ;; l CARON
   DB    46,09FH                       ;; c CARON
   DB    49,0E5H                       ;; n CARON
CP852_CA_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CA_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CA_UP_END-$             ;; length of state section
   DB    CARON_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CA_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0B7H                       ;; E CARON
   DB    19,0FCH                       ;; R CARON
   DB    20,09BH                       ;; T CARON
   DB    21,0A6H                       ;; Z CARON
   DB    31,0E6H                       ;; S CARON
   DB    32,0D2H                       ;; D CARON
   DB    38,095H                       ;; L CARON
   DB    46,0ACH                       ;; C CARON
   DB    49,0D5H                       ;; N CARON
CP852_CA_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CA_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CA_SP_END-$             ;; length of state section
;;   DB    CARON_SPACE                   ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F3H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CA_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F3H                       ;; e CARON
;;CP852_CA_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CA_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CI_UP_END-$             ;; length of state section
   DB    CIRCUMFLEX_UPPER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    05EH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,0D7H                       ;; I CIRCUMFLEX
   DB    24,0E2H                       ;; O CIRCUMFLEX
   DB    30,0B6H                       ;; A CIRCUMFLEX
CP852_CI_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CI_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_BR_LO_END-$             ;; length of state section
   DB    BREVE_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_BR_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C7H                       ;; a BREVE
CP852_BR_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_BR_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_BR_UP_END-$             ;; length of state section
   DB    BREVE_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_BR_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C6H                       ;; A BREVE
CP852_BR_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_BR_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_BR_SP_END-$             ;; length of state section
;;   DB    BREVE_SPACE                   ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F4H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_BR_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F4H                       ;; BREVE SPACE
;;CP852_BR_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_BR_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcirle Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OC_LO_END-$             ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OC_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,085H                       ;; u OVERCIRCLE
CP852_OC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OC_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcircle Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OC_UP_END-$             ;; length of state section
   DB    OVERCIRCLE_UPPER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OC_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,0DEH                       ;; O OVERCIRCLE
CP852_OC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OC_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OG_LO_END-$             ;; length of state section
   DB    OGONEK_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OG_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A9H                       ;; e OGONEK
   DB    30,0A5H                       ;; a OGONEK
CP852_OG_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OG_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OG_UP_END-$             ;; length of state section
   DB    OGONEK_UPPER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OG_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A8H                       ;; E OGONEK
   DB    30,0A4H                       ;; A OGONEK
CP852_OG_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OG_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_OG_SP_END-$             ;; length of state section
;;   DB    OGONEK_SPACE                  ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F2H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_OG_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F2H                       ;; OGONEK SPACE
;;CP852_OG_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_OG_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OD_LO_END-$             ;; length of state section
   DB    OVERDOT_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OD_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BEH                       ;; z OVERDOT
CP852_OD_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OD_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OD_UP_END-$             ;; length of state section
   DB    OVERDOT_UPPER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OD_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BDH                       ;; Z OVERDOT
CP852_OD_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OD_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_LO_END-$             ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,0EAH                       ;; r ACUTE
   DB    21,0ABH                       ;; z ACUTE
   DB    31,098H                       ;; s ACUTE
   DB    38,092H                       ;; l ACUTE
   DB    44,0ECH                       ;; y ACUTE
   DB    46,086H                       ;; c ACUTE
   DB    49,0E4H                       ;; n ACUTE
CP852_AC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AC_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_UP_END-$             ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    11                            ;; number of entries
   DB    19,0E8H                       ;; R ACUTE
   DB    21,08DH                       ;; Z ACUTE
   DB    22,0E9H                       ;; U ACUTE
   DB    23,0D6H                       ;; I ACUTE
   DB    24,0E0H                       ;; O ACUTE
   DB    30,0B5H                       ;; A ACUTE
   DB    31,097H                       ;; S ACUTE
   DB    38,091H                       ;; L ACUTE
   DB    44,0EDH                       ;; Y ACUTE
   DB    46,08FH                       ;; C ACUTE
   DB    49,0E3H                       ;; N ACUTE
CP852_AC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AC_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0EFH                       ;; error character = standalone accent
CP852_AC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP852_AC_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DC_LO_END-$             ;; length of state section
   DB    DOUBLEACUTE_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_DC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0FBH                       ;; u DOUBLEACUTE
   DB    24,08BH                       ;; o DOUBLEACUTE
CP852_DC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DC_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DC_UP_END-$             ;; length of state section
   DB    DOUBLEACUTE_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_DC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0EBH                       ;; U DOUBLEACUTE
   DB    24,08AH                       ;; O DOUBLEACUTE
CP852_DC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DC_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_DC_SP_END-$             ;; length of state section
;;   DB    DOUBLEACUTE_SPACE                   ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F1H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_DC_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
;;CP852_DC_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_DC_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DI_UP_END-$             ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    CP852_DI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    18,0D3H                       ;;    E Diaeresis
CP852_DI_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DI_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CE_LO_END-$             ;; length of state section
   DB    CEDILLA_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CE_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0EEH                       ;; t CEDILLA
   DB    31,0ADH                       ;; s CEDILLA
CP852_CE_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CE_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CE_UP_END-$             ;; length of state section
   DB    CEDILLA_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CE_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0DDH                       ;; T CEDILLA
   DB    31,0B8H                       ;; S CEDILLA
CP852_CE_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CE_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CE_SP_END-$             ;; length of state section
;;   DB    CEDILLA_SPACE                   ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F7H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CE_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F7H                       ;; CEDILLA SPACE
;;CP852_CE_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CE_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    0                             ;; LAST STATE
                                       ;;
CP852_XLAT_END:                        ;;  END OF CP852 SECTION
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CODE     ENDS                          ;;  END OF PROGRAM
         END                           ;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\biosbop.inc ===
bop     MACRO   callid
        db      0c4h,0c4h,callid
        endm

BIOS_PRINTER_IO equ     17h
PRNIO_EXECUTE   equ     -1
PRNIO_FLUSH     equ     0
PRNIO_OPEN      equ     1
PRNIO_CLOSE     equ     2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ntfont\ntfont.asm ===
;
; Windows-NT MVDM Japanese DOS/V Font driver
;
	.286
	include struc.inc
	include ntfont.inc
	include vint.inc

NO_ERROR		equ	00h
IRREGAL_FONT_TYPE	equ	01h
IRREGAL_BL		equ	02h
IRREGAL_FONT_SIZE	equ	03h
IRREGAL_CODE_PAGE	equ	04h
IRREGAL_CODE_NUMBER	equ	05h
READ_ONLY_FONT		equ	06h

FONT_ENABLE		equ	0001h

FONT_CONF	STRUC
READ_WRITE	DB	?		; Read=0, Write=1
FONT_TYPE	DB	?		; SBCS=0, DBCS=1
FONT_SIZE	DW	?
FONT_ADDR	DW	?		; Font read/write routine
FONT_FLAG	DW	?		; Font flag(Now Enable bit only)
FONT_CONF	ENDS

FONTCNF_SIZE	equ	8

CACHE_SIZE	equ	260h

;----------------------------------------------------------------------------;
;                             Code Segment                                   
;----------------------------------------------------------------------------;
TEXT	segment byte public
	assume	cs:TEXT,ds:TEXT,es:TEXT

	org     0               ; drivers should start at address 0000h
	                        ; this will cause a linker warning - ignore it.

Header:                         ; device driver header
	DD	fNEXTLINK       ; link to next device driver
	DW	fCHARDEVICE+fOPENCLOSE  ; device attribute word: 
					; char.device+open/close
	DW	Strat           ; 'Strat' entry point
	DW	Intr            ; 'Intr' entry point
	DB	'NTFONT$$'      ; logical device name (needs to be 8 chars)


;----------------------------------------------------------------------------;
; data variables
;----------------------------------------------------------------------------;

null     	dw      0       ; dummy to do a quick erase of pAtomValue
pAtomVal 	dw offset null  ; pointer to value of result of atom search
MemEnd   	dw  ntfontList  ; end of used memory:      initially AtomList
MaxMem   	dw  ntfontList  ; end of available memory: initially AtomList
lpHeader	dd      0       ; far pointer to request header
org_int15_add	dd	0	; Original int15 vector

;----------------------------------------------------------------------------;
; Dispatch table for the interrupt routine command codes                     
;----------------------------------------------------------------------------;

Dispatch:                       
	DW     Init     ;  0 = init driver 
	DW     Error    ;  1 = Media Check         (block devices only) 
	DW     Error    ;  2 = build BPB           (block devices only)
	DW     Error    ;  3 = I/O control read         (not supported)
	DW     Error    ;  4 = read (input) from device  (int 21h, 3Fh)
	DW     Error    ;  5 = nondestructive read      (not supported)
	DW     Error    ;  6 = ret input status        (int 21h, 4406h)
	DW     Error    ;  7 = flush device input buffer (not supportd)
	DW     Error    ;  8 = write (output) to device  (int 21h, 40h)
	DW     Error    ;  9 = write with verify (== write)  (21h, 40h)
	DW     Error    ; 10 = ret output status       (int 21h, 4407h)
	DW     Error    ; 11 = flush output buffer      (not supported) 
	DW     Error    ; 12 = I/O control write        (not supported)
	DW     Success  ; 13 = device open               (int 21h, 3Dh)
	DW     Success  ; 14 = device close              (int 21h, 3Eh)
	DW     Error    ; 15 = removable media     (block devices only)
	DW     Error    ; 16 = Output until Busy   (mostly for spooler)
	DW     Error    ; 17 = not used
	DW     Error    ; 18 = not used
	DW     Error    ; 19 = generic IOCTL            (not supported)
	DW     Error    ; 20 = not used
	DW     Error    ; 21 = not used
	DW     Error    ; 22 = not used
	DW     Error    ; 23 = get logical device  (block devices only)
	DW     Error    ; 24 = set logical device  (block devices only)

font_read_write_table:
	FONT_CONF	<00h,00h,060ch,read_SBCS_06x12,0>
	FONT_CONF	<00h,00h,0810h,read_SBCS_08x16,0>
	FONT_CONF	<00h,00h,0813h,read_SBCS_08x19,0>
	FONT_CONF	<00h,00h,0c18h,read_SBCS_12x24,0>
	FONT_CONF	<00h,01h,0c0ch,read_DBCS_12x12,0>
	FONT_CONF	<00h,01h,1010h,read_DBCS_16x16,0>
	FONT_CONF	<00h,01h,1818h,read_DBCS_24x24,0>

	FONT_CONF	<01h,00h,060ch,write_SBCS_06x12,0>
	FONT_CONF	<01h,00h,0810h,write_SBCS_08x16,0>
	FONT_CONF	<01h,00h,0813h,write_SBCS_08x19,0>
	FONT_CONF	<01h,00h,0c18h,write_SBCS_12x24,0>
	FONT_CONF	<01h,01h,0c0ch,write_DBCS_12x12,0>
	FONT_CONF	<01h,01h,1010h,write_DBCS_16x16,0>
	FONT_CONF	<01h,01h,1818h,write_DBCS_24x24,0>
	DW		0FFFFh
;----------------------------------------------------------------------------;
; Strategy Routine
;----------------------------------------------------------------------------;
; device driver Strategy routine, called by MS-DOS kernel with
; ES:BX = address of request header
;----------------------------------------------------------------------------;

Strat   PROC FAR
	mov     word ptr cs:[lpHeader], bx      ; save the address of the 
	mov     word ptr cs:[lpHeader+2], es    ; request into 'lpHeader', and                  
	ret                                     ; back to MS-DOS kernel
Strat   ENDP


;----------------------------------------------------------------------------;
; Intr
;----------------------------------------------------------------------------;
; Device driver interrupt routine, called by MS-DOS kernel after call to     
; Strategy routine                                                           
; This routine basically calls the appropiate driver routine to handle the
; requested function. 
; Routines called by Intr expect:
;       ES:DI   will have the address of the request header
;       DS      will be set to cs
; These routines should only affect ax, saving es,di,ds at least
;
; Input: NONE   Output: NONE   -- data is transferred through request header
;
;----------------------------------------------------------------------------;

Intr    PROC FAR
	push	ds
	push	es
	pusha                   ; save registers
	pushf                   ; save flags
	cld                     ; direction flag: go from low to high address
				
	mov     si, cs          ; make local data addressable
	mov     ds, si          ; by setting ds = cs
			
	les     di, [lpHeader]  ; ES:DI = address of req.header

	xor     bx, bx        ; erase bx
	mov     bl,es:[di].ccode ; get BX = command code (from req.header)
	mov	si,bx
	shl	si,1
	add	si,offset dispatch
	
	.IF <bx gt MaxCmd>                ; check to make sure we have a valid
		call    Error             ; command code
	.ELSE                             ; else, call command-code routine,  
		call    [si]              ; indexed from Dispatch table
	.ENDIF                            ; (Ebx used to allow scaling factors)

	or      ax, fDONE       ; merge Done bit into status and
	mov     es:[di].stat,ax ; store status into request header
	
	popf                    ; restore registers
	popa                    ; restore flags
	pop	es
	pop	ds
	ret                     ; return to MS-DOS kernel
Intr    ENDP


;----------------------------------------------------------------------------;
; Success: When the only thing the program needs to do is set status to OK 
;----------------------------------------------------------------------------;

Success PROC NEAR
	xor     ax, ax          ; set status to OK
	ret
Success ENDP

;----------------------------------------------------------------------------;
; error: set the status word to error: unknown command                       
;----------------------------------------------------------------------------;
Error   PROC    NEAR            
	mov     ax, fERROR + fUNKNOWN_E  ; error bit + "Unknown command" code
	ret                     
Error   ENDP

;----------------------------------------------------------------------------;
; Int15_dispatch: 
;----------------------------------------------------------------------------;

Int15_dispatch PROC FAR
	.IF <ah ne 50h>
		jmp	go_org_int15
	.ENDIF
	.IF <al ne 00h> and
	.IF <al ne 01h>
		jmp	go_org_int15
	.ENDIF
	.IF <bh ne 00h> and
	.IF <bh ne 01h>
		mov	ah,IRREGAL_FONT_TYPE
		stc
		jmp	simulate_iret
	.ENDIF
	.IF <bl ne 00h>
		mov	ah,IRREGAL_BL
		stc
		jmp	simulate_iret
	.ENDIF
	.IF <bp ne 00h>
		mov	ah,IRREGAL_CODE_PAGE
		stc
		jmp	simulate_iret
	.ENDIF

	push	si
	mov	si,offset font_read_write_table
search_font_routine:
	.IF <cs:[si].READ_WRITE eq 0ffh>
		pop	si
		jmp	error_font_size
	.ENDIF
	.IF <cs:[si].READ_WRITE eq al> and
	.IF <cs:[si].FONT_TYPE  eq bh> and
	.IF <cs:[si].FONT_SIZE  eq dx> and
	.IF <cs:[si].FONT_FLAG  eq FONT_ENABLE>
		mov	ax,cs
		mov	es,ax
		mov	bx,cs:[si].FONT_ADDR
		pop	si
		mov	ah,NO_ERROR
		push	di
		mov	di,sp
		and	word ptr ss:[di+6],0fffeh ; #1075 9/7/94
		pop	di
		clc
		jmp	simulate_iret
	.ENDIF
	add	si,FONTCNF_SIZE
	jmp	search_font_routine
error_font_size:
	mov	ah,IRREGAL_FONT_SIZE
	stc
	jmp	 simulate_iret

go_org_int15:
	jmp	cs:org_int15_add		;go to original int10
Int15_dispatch ENDP


read_SBCS_06x12	PROC FAR			;SBCS font read routines
	push	bx
	mov	bx,060ch
	mov	ah,2
	BOP	43h
	pop	bx
	ret
read_SBCS_06x12	ENDP

read_SBCS_08x16	PROC FAR
	push	bx
	mov	bx,0810h
	mov	ah,2
	BOP	43h
	pop	bx
	ret
read_SBCS_08x16	ENDP

read_SBCS_08x19	PROC FAR
	push	bx
	mov	bx,0813h
	mov	ah,2
	BOP	43h
	pop	bx
	ret
read_SBCS_08x19	ENDP

read_SBCS_12x24	PROC FAR
	push	bx
	mov	bx,0c18h
	mov	ah,2
	BOP	43h
	pop	bx
	ret
read_SBCS_12x24	ENDP

read_DBCS_12x12	PROC FAR			; DBCS font read routines
	push	bx
	mov	bx,0c0ch
	mov	ah,2
	BOP	43h
	pop	bx
	ret
read_DBCS_12x12	ENDP

read_DBCS_16x16	PROC FAR
;	call	search_cache
;	.IF <ax eq 0>
;		call	get_from_cache
;		mov	al,0
;		clc
;		ret
;	.ENDIF
	push	bx
	mov	bx,1010h
	mov	ah,2
	BOP	43h
	pop	bx
	ret
read_DBCS_16x16	ENDP

read_DBCS_24x24	PROC FAR
	push	bx
	mov	bx,1818h
	mov	ah,2
	BOP	43h
	pop	bx
	ret
read_DBCS_24x24	ENDP

write_SBCS_06x12	PROC FAR		; Write routines are dummy
	mov	al,0				; Font write execute in
	ret					; "font_win.sys"
write_SBCS_06x12	ENDP

write_SBCS_08x16	PROC FAR
	mov	al,0
	ret
write_SBCS_08x16	ENDP

write_SBCS_08x19	PROC FAR
	mov	al,0
	ret
write_SBCS_08x19	ENDP

write_SBCS_12x24	PROC FAR
	mov	al,0
	ret
write_SBCS_12x24	ENDP

write_DBCS_12x12	PROC FAR
	mov	al,0
	ret
write_DBCS_12x12	ENDP

write_DBCS_16x16	PROC FAR
	mov	al,0
	ret
write_DBCS_16x16	ENDP

write_DBCS_24x24	PROC FAR
	mov	al,0
	ret
write_DBCS_24x24	ENDP

;search_cache	PROC	NEAR			; Cache test routine
;	.IF <cx nb 8140h> and
;	.IF <cx b  83a0h>
;		mov	ax,0
;	.ELSE
;		mov	ax,0ffffh
;	.ENDIF
;	ret
;search_cache	ENDP
;
;get_from_cache	PROC	NEAR
;	push	ax
;	push	cx
;	push	si
;	push	di
;	push	ds
;	mov	di,si
;	mov	si,cx
;	mov	ax,cs
;	mov	ds,ax
;	sub	si,8140h
;	shl	si,5
;	add	si,offset cache_area
;	mov	cx,32/4
;	rep	movsd
;	pop	ds
;	pop	di
;	pop	si
;	pop	cx
;	pop	ax
;	ret
;get_from_cache	ENDP
;
;cache_area	label	near
;	db	CACHE_SIZE*32 DUP(0)


;; DON'T EVER EVER CALL HERE!!!!!!!!!!!!!
simulate_iret:
	FIRET
;----------------------------------------------------------------------------;
;****************************************************************************;
;----------------------------------------------------------------------------;
;                                                                            ;
;       BEGINNING OF SPACE TO BE USED AS DRIVER MEMORY                       ;
;       ALL CODE AFTER ATOMLIST WILL BE ERASED BY THE DRIVER'S DATA          ; 
;       OR BY OTHER LOADED DRIVERS                                           ;
;                                                                            ;
;----------------------------------------------------------------------------;
;****************************************************************************;
;----------------------------------------------------------------------------;


;----------------------------------------------------------------------------;
;                    Initialization Data and Code               
; Only needed once, so after the driver is loaded and initialized it releases
; any memory that it won't use. The device allocates memory for its own use
; starting from 'ntfontList'.
;----------------------------------------------------------------------------;

ntfontList        label	NEAR
ini_msg	db "Windows-NT MVDM Font Driver Version 1.00"
	db lf,cr,eom

qbuf_size	equ	64
q_buf		dw	qbuf_size dup(0)


Init    PROC NEAR

	push	ds
	push	es
	pusha
	les     di, [lpHeader]          ; allow us to use the request values

	mov     ax, MemEnd              ; set ax to End of Memory relative to
					; previous end of memory.
	mov     MaxMem, ax              ; store the new value in MaxMem 
	mov     es:[di].xseg,cs         ; tell MS-DOS the end of our used 
	mov     es:[di].xfer,ax         ; memory (the break address)

	ShowStr ini_msg

	mov	cx,qbuf_size		; query support font size
	mov	ax,cs
	mov	es,ax
	mov	si,offset q_buf
	mov	ah,0
	BOP	43h
	.IF <cx ne 0>
		mov	di,offset q_buf	; Enable font read/write routine
check_font_size:
		mov	si,offset font_read_write_table

check_font_routine:
			.IF <[si].READ_WRITE eq 0ffh>
				jmp	check_font_next
			.ENDIF
			mov ax,[si].FONT_SIZE
			xchg	ah,al
			.IF <[di] eq ax>
				mov	[si].FONT_FLAG,FONT_ENABLE
			.ENDIF
			add	si,FONTCNF_SIZE
			jmp	check_font_routine
check_font_next:
		add	di,2
		loop	check_font_size
	.ENDIF

	mov	ah,1			; Load font in 32bit buffer
	mov	al,0
	BOP	43h

;	push	es			; Get local font cache data
;	mov	cx,8140h
;	mov	ax,cs
;	mov	es,ax
;	mov	si,offset cache_area
;	mov	ah,2
;	mov	bx,1010h
;get_font_cache:
;	BOP	43h
;	add	si,32
;	inc	cx
;	cmp	cx,83a0h
;	jb	get_font_cache
;	pop	es

	mov	ax,VECTOR_SEG		;Get original int15 vector
	mov	es,ax
	mov	ax,word ptr es:[4*15h+0]
	mov	word ptr cs:[org_int15_add+0],ax
	mov	ax,word ptr es:[4*15h+2]
	mov	word ptr cs:[org_int15_add+2],ax

	mov	ax,offset cs:Int15_dispatch	;Set my int15 vector
	mov	word ptr es:[4*15h+0],ax
	mov	ax,cs
	mov	word ptr es:[4*15h+2],ax

	popa
	pop	es
	pop	ds

	xor	ax,ax
	ret
Init    ENDP

TEXT	ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\bio2.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 BIO2.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: BIO2.ASM                                   *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;
;       CORRECTION HISTORY
;       84/11/14
;       84/11/18  MAKE PRINTER-I/O DEVICE-DRIVER
;       84/11/19  CORRECT INDIRECT CALLING
;       85/02/01  CORRECT FOR X2ROM(1/31)
;       85/02/27  MAKE KANJI DEVICE-DRIVER
;       85/03/05  BI-MEDIA DEVICE
;       85/03/28  ADDING B4670-CODE & STUDYING BUFFER FOR BUNSETSU DRIVER
;       85/04/11  2D MODE SUPPORT
;       85/05/15  B4670 BPB & VHD INFO. (DATA)
;       85/05/18  LINMOD ADDR FOR BUNSETSU
;       85/10/03  ENHANCE FOR DOS 3.XX
;       85/10/22  UPDATE REVISION
;       86/09/23
;       88/3 - 88/5 --  MS-DOS 3.30 --
;
;       90/11,12  MS-DOS 5.0 

BRANCH=0

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
                ASSUME  CS:DATAGRP,DS:datagrp
        EXTRN   INIT:NEAR
Bios_Data_Init  ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:datagrp

        EXTRN   KBIN:NEAR,KBSTAT:NEAR,KBFLUSH:NEAR,CRTOUT:NEAR,CRTRDY:NEAR
        EXTRN   SETDATE:near,SETTIME:near,GETDATE:near
        EXTRN   STOP_CHK:NEAR
        EXTRN   STOP_CHK_FAR:NEAR


        EXTRN   DSK_INIT_CODE:NEAR,MEDIA_CHK_CODE:NEAR,GET_BPB_CODE:NEAR
        EXTRN   DSK_READ_CODE:NEAR,DSK_WRIT_CODE:NEAR,DSK_WRTV_CODE:NEAR
;
        EXTRN   REINIT_CODE_RTN:NEAR
;
;       ENHANCE DOS 3.XX
;
        EXTRN   DSK_OPEN_CODE:NEAR,DSK_CLOSE_CODE:NEAR,DSK_REMOVABLE_CODE:NEAR
;
        EXTRN   BELRTN:NEAR,D_MCONV:NEAR,HEXCHK:NEAR

        EXTRN   Generic$IOCTL_CODE:NEAR
        EXTRN   IOCTL$GetOwn_CODE:NEAR
        EXTRN   IOCTL$SetOwn_CODE:NEAR
        EXTRN   IOCTL_SUPPORT_QUERY_CODE:NEAR

        EXTRN   KBIN_FAR:NEAR,KBSTAT_FAR:NEAR,KBFLUSH_FAR:NEAR
        EXTRN   CRTOUT_FAR:NEAR,CRTRDY_FAR:NEAR
        EXTRN   HEXCHK_FAR:NEAR
        EXTRN   D_MCONV_FAR:NEAR
        EXTRN   BELRTN_FAR:NEAR

        EXTRN   COPY_INT_CODE:NEAR
        EXTRN   INT_TRAP_CODE:NEAR
        EXTRN   STOP_INT_CODE:NEAR
        EXTRN   INT_29_CODE:NEAR
        EXTRN   EXTBIOS_CODE:NEAR

        EXTRN   HD_ENTI_CODE:NEAR
        EXTRN   EXFNC_START_CODE:NEAR
        EXTRN   CRTBIOS_START_CODE:NEAR
        EXTRN   NEW_1A_ENT_CODE:NEAR
        EXTRN   INT_1CH_CODE:NEAR
        EXTRN   TIM_INT_CODE:NEAR
        EXTRN   NEW_1B_INT_CODE:NEAR

Bios_Code       ends

SysInitSeg      segment word public 'system_init'
        assume  cs:sysinitseg
        extrn   FTryToMovDOSHi:far
        public  SI_start
SI_start:
SysInitSeg      ends

Bios_data       segment word public 'Bios_data'
                ASSUME  CS:DATAGRP,DS:DATAGRP

        PUBLIC  BIOS_SEG                                ;90/12/25

        PUBLIC  REVISION
        PUBLIC  VRAMSEG
        PUBLIC  EXMM_SIZE                               ;88/03/31

        PUBLIC  STRATEGY,DSK_INT
        PUBLIC  EXIT,BUS_EXIT,ERR_EXIT,EXITRF
        PUBLIC  EXITRTN
        PUBLIC  DRV_NUM,DEV_TBL,PTRSAV

        PUBLIC  BIOS_FLAG

        PUBLIC  MEM_SW1,MEM_SW2,MEM_SW3,MEM_SW4,MEM_SW5,MEM_SW6,MEM_SW7

        PUBLIC  LPTABLE,DSK5_TYP,CBIOS_FLAG
        PUBLIC  HD_CAP,INT1B_OFST,INT1B_SGMT

        PUBLIC  N8FD,N5FD,N5HD,N5,HD_NO,D_TYP
        PUBLIC  INT1E_OFST,INT1E_SGMT,INT1F_OFST,INT1F_SGMT

        PUBLIC  EXT_ROM,LD_ULD_PTR,PRN_INF

        PUBLIC  IDXR_FLG,SEG_DOS,TRG_DRV,DIC_NAME

        PUBLIC  SFTJISMOD,MODMARK1,MODMARK2

        PUBLIC  HDIO_FLG

        PUBLIC  CONOUT,LISTOUT,S_R8
        PUBLIC  CONOUT_FAR

        PUBLIC  SNG_DRV,SNGDRV_FLG

        PUBLIC  SYS_500,SYS_501


        PUBLIC  P_FLAG,FKYCNT,FKYPTR,LINMOD,CRTMOD,HEXMOD,HEXWRK,KBH_ADR

        PUBLIC  ESCBUF,ESCPTR,ESCSUBRTN,ESCPOSSAVE,ESCCNT,ESCPRM

        PUBLIC  SRMFLG,ESCATRSAVE,ESCCPRBUF,ESCCPRLIN,ESCCPRCOL

        PUBLIC  KANJICNT,K1STSAV,WRAPMOD,ROLSW,NULCHR,ENDLINE,CSRSW

        PUBLIC  FKYSW,CURLIN,CURCOL,DEFATTR,CURATTR,ROLTOP,WAITCNT

        PUBLIC  FKYD_KCNT,FKYD_K1SAV

        PUBLIC  X_PAGE_FLAG,KANJI_MODE,FKY_BUFFER,KBGLIN

        PUBLIC  DSK_BUF,KBKNJ_FLG,TEMPB1_CNT,KBINP_CNT

        PUBLIC  BIDTBL,BIDTBL5,PREDNST,PREDENS5

        PUBLIC  PUA,PWINF,FSW5,FSW8

        PUBLIC  KDRV_FLG,AIRST,OPMOD

        PUBLIC  SNRST1,SAVEAL,OPMOD5

        PUBLIC  VT_OFFSET,VT_LAST,VBPB
;--------------------------------------------------------- 88/05/19 --
;       PUBLIC  VOLTABLE                        
;---------------------------------------------------------------------
        PUBLIC  BUSY                            ;DOS 3.XX

        PUBLIC  REFCNT,MEDIABYT,BYTPSEC         ;DOS 3.XX

        PUBLIC  XPORT_FLAG                      ;DOS 3.XX
        PUBLIC  VSYS_FLAG

        PUBLIC  SVBPS,VOLWORK

        PUBLIC  CTRLCMD,PR_RATIO                ;86-08-21(PR)

        PUBLIC  COPY_FLAG,COPYSTOP,STOP_FLAG

        PUBLIC  STACK_TOP
        PUBLIC  DSK_BUF2
        PUBLIC  CMD_ERR
        PUBLIC  FBIGFAT
        PUBLIC  FBIGFATS
        PUBLIC  CURATTR2,DEFATTR2,ATRSAVE2

        PUBLIC  SEG_DOS,CONSOLE_TABLE,AUXILIARY_TABLE,JAPAN_TABLE
        PUBLIC  PRINTER_TABLE,OUT_NXT_PTR

        PUBLIC  COPY_INT,INT_TRAP,STOP_INT
        PUBLIC  INT_29,EXTBIOS,HD_ENTI,EXFNC_START
        PUBLIC  CRTBIOS_START,NEW_1A_ENT
        PUBLIC  INT_1CH,TIM_INT,NEW_1B_INT

        PUBLIC  RE_INIT

ESCBUFSIZ       EQU     20

BIOSSEG EQU     0060H                           ;BIOS SEGMENT

IODAT   STRUC
CMDLEN  DB      ?                               ;LENGTH OF COMMAND
UNIT    DB      ?                               ;SUB UNIT SPECIFIER
CMD     DB      ?                               ;COMMAND CODE
STATUS  DW      ?                               ;STATUS
        DB      8 DUP(?)
MEDIA   DB      ?                               ;MEDIA DESCRIPTOR
TRANS   DD      ?                               ;TRANSFER ADDRESS
COUNT   DW      ?                               ;COUNT OF BLOCKS OR CHARACTERS
START   DW      ?                               ;FIRST BLOCK TO TRANSFER
;------------------------------------------------DOS5 90/12/14-----------
VOLID   DD      ?
START_L DW      ?                               ;FIRST BLOCK TO TRANSFER
START_H DW      ?                               ;FIRST BLOCK TO TRANSFER
;------------------------------------------------------------------------
IODAT   ENDS

;------------------------------------------------DOS5 90/12/14-----------
BPB_SIZE        EQU     17
HDDSK_SIZE      EQU     BPB_SIZE*4
;------------------------------------------------------------------------

;------------------------------------------------DOS5 91/01/18-----------
;**     BIOS PARAMETER BLOCK DEFINITION
;
;       The BPB contains information about the disk structure.  It dates
;       back to the earliest FAT systems and so FAT information is
;       intermingled with physical driver information.
;
;       A boot sector contains a BPB for its device; for other disks
;       the driver creates a BPB.  DOS keeps copies of some of this
;       information in the DPB.
;
;       The BDS structure contains a BPB within it.
;

A_BPB                   STRUC
BPB_BYTESPERSECTOR      DW      ?
BPB_SECTORSPERCLUSTER   DB      ?
BPB_RESERVEDSECTORS     DW      ?
BPB_NUMBEROFFATS        DB      ?
BPB_ROOTENTRIES         DW      ?
BPB_TOTALSECTORS        DW      ?
BPB_MEDIADESCRIPTOR     DB      ?
BPB_SECTORSPERFAT       DW      ?
BPB_SECTORSPERTRACK     DW      ?
BPB_HEADS               DW      ?
BPB_HIDDENSECTORS       DW      ?
                        DW      ?
BPB_BIGTOTALSECTORS     DW      ?
                        DW      ?
                        DB      6 DUP(?)        ; NOTE:  many times these
;                                               ;        6 bytes are omitted
;                                               ;        when BPB manipulations
;                                               ;        are performed!
A_BPB                   ENDS




bds_struc       struc
bds_link        dd              0ffffh  ; link to next bds
bds_drivenum    db              80      ; int 13 drive number
bds_drivelet    db              3       ; dos drive number

;       We want to embed a BPB declaration here, but we can't initialize
;       it properly if we do, so we duplicate the byte/word/dword architecture
;       of the BPB declaration.

;BDS_BPB        db      size BPBSTRUC dup (?)   ; actual BPB
BDS_BPB         dw      512             ; BPB_BYTESPERSECTOR
                db      1               ; BPB_SECTORSPERCLUSTER
                dw      1               ; BPB_RESERVEDSECTORS
                db      2               ; BPB_NUMBEROFFATS
                dw      16              ; BPB_ROOTENTRIES
                dw      0               ; BPB_TOTALSECTORS
                db      0f8h            ; BPB_MEDIADESCRIPTOR
                dw      1               ; BPB_SECTORSPERFAT
                dw      0               ; BPB_SECTORSPERTRACK
                dw      0               ; BPB_HEADS
                dd      0               ; BPB_HIDDENSECTORS
                dd      0               ; BPB_BIGTOTALSECTORS

bds_fatsiz      db              0       ; flags...
bds_opcnt       dw              0       ; open ref. count
bds_formfactor  db              3       ; form factor index
bds_flags       dw              0020h   ; various flags
bds_ccyln       dw              40      ; max number of cylinders

BDS_RBPB        db size A_BPB dup (0)   ; recommended BPB

bds_track       db              -1      ; last track accessed on drive
bds_tim_lo      dw              1       ; time of last access. keep
bds_tim_hi      dw              0       ; these contiguous.
bds_volid       db "NO NAME    ",0      ; volume id of medium
bds_vol_serial  dd      0         ;current volume serial number from boot record
bds_filesys_id  db      "FAT12   ",0 ; current file system id from boot record
bds_struc       ends


; values for various flags in bds_flags.

fnon_removable      equ     01h         ;for non-removable media
fchangeline         equ     02h         ;if changeline supported on drive
return_fake_bpb     equ     04h         ; when set, don't do a build bpb
                                        ; just return the fake one
good_tracklayout    equ     08h         ; the track layout has no funny sectors
fi_am_mult          equ     10h         ;if more than one logical for this physical
fi_own_physical     equ     20h         ;signify logical owner of this physical
fchanged            equ     40h         ;indicates media changed
set_dasd_true       equ     80h         ; set dasd before next format
fchanged_by_format  equ    100h         ;media changed by format
unformatted_media   equ    200h         ;an001; fixed disk only
;------------------------------------------------------------------------


        PAGE
;************************************************************************
;*                                                                      *
;*                                                                      *
;*      START OF IO.SYS VARIABLE                                        *
;*                                                                      *
;*                                                                      *
;************************************************************************
BIO2_START:

        ORG     0

        JMP     INIT                    ;INITIALIZE

;
;NIPPON GO NYURYOKU ENTRANCE AND EXIT FOR AP
;
        JMP     KB_KANJI_ENT
        JMP     KB_KANJI_EXT

;
;       RESERVED        0009H --> 0019H
;
FREE_0          EQU     20H-($-BIO2_START)
                DB      FREE_0 DUP(0)
        ORG 14h
        public  ntvdmstate
ntvdmstate  dd  0
        ORG     20h
        public  IOSYS_REV, MINOR_REV
;IOSYS_REV      dw      0004h           ;3.3C IO.SYS revision
;<patch BIOS50-P01>
;IOSYS_REV      dw      0101h           ;5.0  IO.SYS revision
;<patch BIOS50-P12>
;IOSYS_REV      dw      0102h           ;5.0A IO.SYS revision  DOS5A 92/04/07
;<patch BIOS50-P33>
IOSYS_REV       dw      0104h           ;5.0A IO.SYS revision  DOS5A 93/02/02
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P12>
;MINOR_REV      db      01h             ;IO.SYS minor revision
;<patch BIOS50-P09>
;<patch BIOS50-P30>
;MINOR_REV      db      02h             ;IO.SYS minor revision
;<patch BIOS50-P11>
;<patch BIOS50-P31>
;MINOR_REV      db      03h             ;IO.SYS minor revision
;<patch BIOS50-P33>
MINOR_REV       db      04h             ;IO.SYS minor revision
;---------------------------------------------------------------------

;------------------------------------------------------ DOS5 91/05/08 -

        public  dosdatasg
dosdatasg       dw      0
bios_i2f        proc    far
        db      0eah
        dd      int_2f
bios_i2f        endp
romstartaddr    dw      0
altah           db      0       ;special key handling

        ORG     2EH
BIOS_SEG        DW      BIOS_CODE

        ORG     30H
AUTO_FLAG       DB      ?               ;Interface area for EMS maintainance
;------------------------------------------------------ 88/03/31 DOS3.3
        ORG     31H
EXMM_SIZE       DB      0               ;EXTENDED MEMORY SIZE SAVE
;------------------------------------------------------- 011 ---------
;       ORG     32H                                     ;88/03/31
VRAMSEG         DW      0A000H          ;VIDEO RAM SEGMENT
DEB_FLG         DB      0               ;FOR DEBUG (IO.SYS)
DRVFLG          DB      0               ;ASSIGN COMMAND USE
;---------------------------------------------------------------------
        ORG     36H

SYS_500         DB      0               ;COPY OF 0000:0500
SYS_501         DB      0               ;COPY OF 0000:0501

SNGDRV_FLG      DB      0
SNG_DRV         DB      0               ;LAST I/O ON SNGLE DRIVE 0:A 1:B

DIC_NAME        DB      'KNJDIC  SYS'   ;DICTIONARY NAME
TRG_DRV         DB      0               ;DEFAULT DRIVE

INT1E_OFST      DW      0
INT1E_SGMT      DW      0
INT1F_OFST      DW      0
INT1F_SGMT      DW      0

SEG_DOS         DW      0               ;MSDOS.SYS SEGMENT ADDRESS

LD_ULD_PTR      DW      0,0             ;POINTER FOR ADDDRV/DELDRV WORK
                                        ;FOR DYNAMIC INSTALL/DEINSTALL

;************************************************
;*                                              *
;*      DEVICE ASSIGN TABLE                     *
;*                                              *
;************************************************
;
ASS_CONIN       DB      0               ;DEFAULT KEYBOARD
ASS_READER      DB      1               ;        RS232C
ASS_CONOUT      DB      1,0,0,0,0,0     ;        CRT
ASS_LISTOUT     DB      1,1,0,0,0,0     ;        PRINTER
ASS_PUNCH       DB      1,2,0,0,0,0     ;        RS232C

;************************************************
;*                                              *
;*      COPY OF MEMORY SWITCH 1-4               *
;*                                              *
;************************************************
;
MEM_SW1         DB      0
MEM_SW2         DB      0
MEM_SW3         DB      0
MEM_SW4         DB      0

;************************************************
;*                                              *
;*      LOGICAL DRIVE --> DA/UA TABLE           *
;*                                              *
;************************************************
;
LPTABLE         LABEL   BYTE            ;LOGICAL/PHYSICAL DRIVE CONVERT
                DB      0,0,0,0,0,0,0,0 ;DRIVE "A:" - "P:"
                DB      0,0,0,0,0,0,0,0 ;

DSK5_TYP        DB      4,4,4,4         ;5"2DD DISK TYPE 
                                        ; 0:1D(8)
                                        ; 1:1D(9)
                                        ; 2:2D(8)
                                        ; 3:2D(9)
                                        ; 4:2DD(8)
                                        ; 5:2DD(9)

CBIOS_FLAG      DB      00011100B       ;DISK ACCESS FLAG
                ;          IIII+-------- 5"FD(8031) ACCESS  NOT USED
                ;          III+--------- 5"FD(8031) SEC/TRK READ
                ;          II+---------- 5"HD ACCESS
                ;          I+----------- 8"FD ACCESS
                ;          +------------ 5"FD(9831) ACCESS

;************************************************
;*                                              *
;*      REVISION CODE                           *
;*                                              *
;************************************************
;
REVISION        DB      11110000B        ;9800 3.10=0B0H
                ;       IIII   +-------- HARD MODE
                ;       IIII              1:HIRESOLUTION /0:NORMAL
                ;       III+------------ DRIVER INSTALLABLE
                ;       III               1:INSTALLABLE  /0:NOT
                ;       II+------------- OS VERSION(2)
                ;       II                1:3.10         /0:1.25,2.11
                ;       I+-------------- CTRL+FKEY
                ;       I                 1:USE          /0:NOT
                ;       +--------------- OS VERSION
                ;                         1:VER.2.11     /0:VER.1.25


HD_CAP          DB      0,0             ;5"HD CAPACITY (MS-DOS PART)

HD_INT_OFFSET   DW      OFFSET HD_ENTI  ;INT B1H (HD BIOS) ENTRY
TRP_OFFSET      DW      OFFSET INT_TRAP ;INTERRUPT TRAP ENTRY

PRN_INF         DB      0,66H           ;PRINTER INFO. (NOT USED)

;************************************************
;*                                              *
;*      CONSOLE CONTROL                         *
;*              ( TOP OF CONSOLE TABLE )        *
;*                                              *
;************************************************

CONSOLE_TABLE   LABEL   FAR

SFTJISMOD       DB      1               ;CHARACTER MODE
                                        ; 0:GRAPH      /1:KANJI
MODMARK1        DB      ' '             ;' ':KANJI     /'g':GRAPH
MODMARK2        DB      ' '             ;' ':FUNC      /'*':SFT-FUNC

;************************************************
;*                                              *
;*      COPY OF MEMORY SWITCH 5-7               *
;*                                              *
;************************************************
;
MEM_SW5         DB      0
MEM_SW6         DB      0
MEM_SW7         DB      0

;************************************************
;*                                              *
;*      DISK INFO.                              *
;*              ( TOP OF DISK TABLE )           *
;*                                              *
;************************************************

        PUBLIC  COMP_HDOFST_N,ALC_TYP

DISK_TABLE      LABEL   FAR

INT1B_OFST      DW      0               ;INT 1BH ADDRESS
INT1B_SGMT      DW      0               ; ( FOR N10 ONLY )
;
COMP_HDOFST_N   DW      0,0             ;HD PARTITION START
                DW      0,0             ; ( FOR COMPATIBLE )
LAST_SEC        DW      0,0             ;

                DW      0,0             ;RESERVED
;--------------------------------------------------------------------
STOP_FLAG       DB      0               ;STOP KEY INDICATE
COPY_FLAG       DB      0               ;HARD COPY INDICATE
COPYSTOP        DB      0               ;HARD COPY STOP FLAG
                DB      0               ;RESERVED
;--------------------------------------------------------------------
EXT_ROM         DW      0,0             ;EXTENDED ROM CALL
                                        ; ( FOR N10 ONLY )

N8FD            DB      0               ;NUMBER OF 1MB DISK
N5FD            DB      0               ;NUMBER OF 640KB DISK
N5HD            DB      0               ;NUMBER OF HARD DISK
N5              DB      0               ;NUMBER OF 160/320KB DISK

IDXR_FLG        DB      00000000B       ;DICTIONARY I/O CONTROL FLAGS
                ;       I     II
                ;       I     I+-------- FORCE TO READ INDEX
                ;       I     +--------- FORCE TO READ PAGE
                ;       +--------------- WRITE PAGE CONTROL

D_TYP           DB      0               ;BOOT DISK TYPE
                                        ;0:8"FD 1:5"2DD 2:5"HD

HDIO_FLG        DB      0               ;HD ACCESS FLAG
HD_NO           DB      0               ;?
BIOS_FLAG       DB      0               ;

ALC_TYP         DB      0               ;DRIVE ALLOCATION TYPE(always 0)

;************************************************
;*                                              *
;*      [KANJI] WORKING FIELD                   *
;*              (TOP OF KANJI TABLE )           *
;*                                              *
;************************************************

        ORG     0B6H

JAPAN_TABLE     LABEL   FAR

KBKNJ_FLG       DB      00000000B       ;KANJI INPUT MODE FLAG
                ;       IIIIIII+-------- 0:ZENKAKU     /1:HANKAKU
                ;       IIIIII+--------- 0:KATAKANA    /1:HIRAGANA
                ;       IIIII+---------- RFU 
                ;       IIII+----------- 0:            /1:XFER MODE
                ;       III+------------ RFU
                ;       II+------------- RFU
                ;       I+-------------- 0:DIRECT MODE /1:INDIRECT MODE
                ;       +--------------- 0:ANK MODE    /1:NIPPONGO MODE

KANJI_MODE      DB      0               ;0B7H
KBINP_CNT       DB      0               ;0B8H
KBGLIN          DB      0               ;0B9H

X_PAGE_FLAG     DB      00000000B       ;PAGE CONRTOL
                ;            III
                ;            II+-------- NEXT PAGE NOT FOUND
                ;            I+--------- PREVIOUS PAGE NOT FOUND
                ;            +---------- WORD NOT FOUND

TEMPB1_CNT      DB      0               ;0BBH

FREE_1          EQU     0C0H-($-BIO2_START)     ;mustn't use
                DB      FREE_1 DUP(0)           ;

        ORG     0C0H
FKY_BUFFER      DB      62 DUP(?)       ;STRING BUFF (SHORT)
                                        ; DEFINE BYTES
        ORG     0C0H
WFKY_BUFFER     DW      31 DUP(?)       ;STRING BUFF (SHORT)
                                        ; DEFINE WORD

FKY_BUF_ADR     EQU     OFFSET FKY_BUFFER

        ORG     0FEH
KNJ_FNC_NO      DW      0
KNJ_KBH_NO      DW      0

;************************************************
;*                                              *
;       [KEYBOARD] WORKING FIELD                *
;*                                              *
;************************************************
FREE_2          EQU     103H-($-BIO2_START)     ;mustn't use
                DB      FREE_2 DUP(0)           ;

        ORG     103H
FKYCNT          DB      0               ;FNC KEY COUNTER
FKYPTR          DW      FKYTBL          ;FNC KEY POINTER
HEXMOD          DB      0               ;HEX MODE
P_FLAG          DB      0               ;^P FLAG
CRTMOD          DB      0               ;CRT TYPE
HEXWRK          DB      0               ;HEX ROUTINE USE
KBH_ADR         DW      0               ;ADDR

        ORG     10CH
CTRLCMD         DB      00000000B       ;CTRL-FUNC FLAG
;                             I+-------- 1:CTRL-F.01-F.10 IS SOFT KEY
;                             +--------- 1:CTRL-XFER IS SOFT KEY

;************************************************
;*                                              *
;       [CONSOLE] WORKING FIELD                 *
;*                                              *
;************************************************
;
FREE_3          EQU     110H-($-BIO2_START)
                DB      FREE_3 DUP(0)
        ORG     110H
CURLIN          DB      0               ;CURRENT LINE
FKYSW           DB      1               ;FUNC_KEY SWITCH
                                        ; 0:NOT DISP /1:FUNC /2:SHIFT+FUNC
ENDLINE         DB      23              ;END LINE NUMBER (DEF=23)
LINMOD          DB      1               ;DISPLAY LINE MODE
                                        ; (H) 0:25LINE     /1:31LINE
                                        ; (N) 0:20LINE     /1:25LINE
DEFATTR         DB      81H             ;DEFAULT ATTRIBUTE

KANJICNT        DB      0               ;1: 0:          115H
K1STSAV         DB      0               ;KANJI FIRST DATA DAVE
WRAPMOD         DB      0               ;END OF LINE MODE
                                        ; 1:DISCARD        /0:WRAP
ROLSW           DB      0               ;ROLL UP SPEED,
NULCHR          DW      0020H           ;NULL CHARACER (SPACE)
CSRSW           DB      1               ;CURSOR SWITCH
                                        ; 0:OFF            /1:ON
CURCOL          DB      0               ;CURRENT COLUMN
CURATTR         DB      81H             ;CURRENT ATRIBUTE
ROLTOP          DB      0               ;TOP OF SCROLL LINE
WAITCNT         DW      1               ;WAIT COUNT FOR SCROLLUP

FKYD_KCNT       DB      0
FKYD_K1SAV      DB      0
                DB      0               ;FREE

                ORG     124H
ESCSUBRTN       DW      0               ;ESC SUBROUTINE ADDRESS
ESCPOSSAVE      DW      0
ESCCNT          DB      0               ;COUNTER
ESCPRM          DB      1               ;PARAMETER COUNT AREA
SRMFLG          DB      0               ;SET/RESET MODE FLAG (IN ESCVT)
ESCATRSAVE      DB      81H
ESCCPRBUF       DB      1BH,'['         ;CSI
ESCCPRLIN       DW      0               ;12EH
                DB      ';'
ESCCPRCOL       DW      0               ;COLUMN
                DB      'R'

        ORG     134H
ESCPTR  DW      ESCBUF                  ;POINTER
;---------------------------------------------------------------------------
;************************************************
;*                                              *
;*      COMPATIBILITY AREA                      *
;*                                              *
;************************************************

        PUBLIC  CURDRV,EXTSW
        PUBLIC  ERROR_FLG,AUT_LEX

CURDRV          DB      0               ;CURRENT DRIVE (FOR COMPATIBLITY)
                DB      0,0             ;RFU
ERROR_FLG       DB      0               ;?
AUT_LEX         DB      -1              ;SWITCH TO INDICATE AUTO LOG-EXTENT
EXTSW           DB      0               ;LOGICAL EXTENT FLAG (COMPATIBLITY)
;---------------------------------------------------------------------------

CURATTR2        DW      0081H
DEFATTR2        DW      0081H
ATRSAVE2        DW      0081H

;------------------------------------------------------ DOS5 90/  /   -
                public  MULTRK_FLAG,EC35_FLAG
                public  KEYSTS_FUNC,KEYRD_FUNC
MULTRK_FLAG     DW      0H
KEYSTS_FUNC     DB      0H
KEYRD_FUNC      DB      0H
EC35_FLAG       DB      0H

                public  FreeHMAPtr
                public  MoveDOSIntoHMA
FreeHMAPtr      dw      -1
MoveDOSIntoHMA  dd      sysinitseg:FTryToMovDOSHi


;SR;
; A communication block has been setup between the DOS and the BIOS. All
;the data starting from SysinitPresent will be part of the data block. 
;Right now, this is the only data being communicated. It can be expanded 
;later to add more stuff
;
                public  SysinitPresent
                public  DemInfoFlag
SysinitPresent  db      0
DemInfoFlag     db      0

        public  inHMA,xms
inHMA   db      0               ; flag indicates we're running from HMA
xms     dd      0               ; entry point to xms if above is true


;A20WasOff      db      0       ; M041
;HMAinprogress  db      0
;----------------------------------------------------------------------

;----------------------------------------------- DOS5 92/06/22 -------
;<patch BIOS50-P22>
        public  samedrv

samedrv db      0
;---------------------------------------------------------------------


FREE_4          EQU     160H-($-BIO2_START)
                DB      FREE_4 DUP(0)

;************************************************
;*                                              *
;*      [KNJLIO] WORKING FIELD                  *
;*                                              *
;************************************************


        ORG     160H
;--------------------------------------------------------- 90/03/20 --
;       PUBLIC  FAT_INF
;FAT_INF                DW      686 DUP(0)      ;FAT INFORMATION

;************************************************
;  MS-DOS 5.0                                   *
;    FAR CALL/FAR JUMP TABLE                    *
;************************************************
cdev:
KBIN_CODERTN    DW      OFFSET KBIN_FAR
                DW      BIOS_CODE
S0IN_CODERTN    DW      OFFSET S0IN_FAR
                DW      BIOS_CODE
S1IN_CODERTN    DW      OFFSET S1IN_FAR
                DW      BIOS_CODE
S2IN_CODERTN    DW      OFFSET S2IN_FAR
                DW      BIOS_CODE

KBSTAT_CODERTN  DW      OFFSET KBSTAT_FAR
                DW      BIOS_CODE
S0STAT_CODERTN  DW      OFFSET S0STAT_FAR
                DW      BIOS_CODE
S1STAT_CODERTN  DW      OFFSET S1STAT_FAR
                DW      BIOS_CODE
S2STAT_CODERTN  DW      OFFSET S2STAT_FAR
                DW      BIOS_CODE

KBFLUSH_CODERTN DW      OFFSET KBFLUSH_FAR
                DW      BIOS_CODE
S0FLUSH_CODERTN DW      OFFSET S0FLUSH_FAR
                DW      BIOS_CODE
S1FLUSH_CODERTN DW      OFFSET S1FLUSH_FAR
                DW      BIOS_CODE
S2FLUSH_CODERTN DW      OFFSET S2FLUSH_FAR
                DW      BIOS_CODE

CRTOUT_CODERTN  DW      OFFSET CRTOUT_FAR
                DW      BIOS_CODE
PRNOUT_CODERTN  DW      OFFSET PRNOUT_FAR
                DW      BIOS_CODE
S0OUT_CODERTN   DW      OFFSET S0OUT_FAR
                DW      BIOS_CODE
S1OUT_CODERTN   DW      OFFSET S1OUT_FAR
                DW      BIOS_CODE
S2OUT_CODERTN   DW      OFFSET S2OUT_FAR
                DW      BIOS_CODE

CRTRDY_CODERTN  DW      OFFSET CRTRDY_FAR
                DW      BIOS_CODE
PRNRDY_CODERTN  DW      OFFSET PRNRDY_FAR
                DW      BIOS_CODE
S0RDY_CODERTN   DW      OFFSET S0RDY_FAR
                DW      BIOS_CODE
S1RDY_CODERTN   DW      OFFSET S1RDY_FAR
                DW      BIOS_CODE
S2RDY_CODERTN   DW      OFFSET S2RDY_FAR
                DW      BIOS_CODE

CLK_READ_RTN    DW      OFFSET CLK_READ_CODERTN
                DW      BIOS_CODE
CLK_WRIT_RTN    DW      OFFSET CLK_WRIT_CODERTN
                DW      BIOS_CODE

STOP_CHK_RTN    DW      OFFSET STOP_CHK_FAR
                DW      BIOS_CODE

HEXCHK_RTN      DW      OFFSET HEXCHK_FAR
                DW      BIOS_CODE

D_MCONV_RTN     DW      OFFSET D_MCONV_FAR
                DW      BIOS_CODE

BELRTN_RTN      DW      OFFSET BELRTN_FAR
                DW      BIOS_CODE

DSK_INIT_DATARTN        DW      OFFSET DSK_INIT_CODE
                        DW      BIOS_CODE

MEDIA_CHK_DATARTN       DW      OFFSET MEDIA_CHK_CODE
                        DW      BIOS_CODE

GET_BPB_DATARTN         DW      OFFSET GET_BPB_CODE
                        DW      BIOS_CODE

DSK_READ_DATARTN        DW      OFFSET DSK_READ_CODE
                        DW      BIOS_CODE

DSK_WRIT_DATARTN        DW      OFFSET DSK_WRIT_CODE
                        DW      BIOS_CODE

DSK_WRTV_DATARTN        DW      OFFSET DSK_WRTV_CODE
                        DW      BIOS_CODE

DSK_OPEN_DATARTN        DW      OFFSET DSK_OPEN_CODE
                        DW      BIOS_CODE

DSK_CLOSE_DATARTN       DW      OFFSET DSK_CLOSE_CODE
                        DW      BIOS_CODE

DSK_REMOVABLE_DATARTN   DW      OFFSET DSK_REMOVABLE_CODE
                        DW      BIOS_CODE

Generic$IOCTL_DATARTN   DW      OFFSET Generic$IOCTL_CODE
                        DW      BIOS_CODE

IOCTL$GetOwn_DATARTN    DW      OFFSET IOCTL$GetOwn_CODE
                        DW      BIOS_CODE

IOCTL$SetOwn_DATARTN    DW      OFFSET IOCTL$SetOwn_CODE
                        DW      BIOS_CODE

IOCTL_SUPPORT_QUERY_DATARTN     DW      OFFSET IOCTL_SUPPORT_QUERY_CODE
                                DW      BIOS_CODE

INT_TRAP_DATA           DW      offset INT_TRAP_CODE
                        DW      BIOS_CODE

COPY_INT_DATA           DW      offset COPY_INT_CODE
                        DW      BIOS_CODE

STOP_INT_DATA           DW      offset STOP_INT_CODE
                        DW      BIOS_CODE

INT_29_DATA             DW      offset INT_29_CODE
                        DW      BIOS_CODE

EXTBIOS_DATA            DW      offset EXTBIOS_CODE
                        DW      BIOS_CODE

HD_ENTI_DATA            DW      offset HD_ENTI_CODE
                        DW      BIOS_CODE

EXFNC_START_DATA        DW      offset EXFNC_START_CODE
                        DW      BIOS_CODE

CRTBIOS_START_DATA      DW      offset CRTBIOS_START_CODE
                        DW      BIOS_CODE

NEW_1A_ENT_DATA         DW      offset NEW_1A_ENT_CODE
                        DW      BIOS_CODE

INT_1CH_DATA            DW      offset INT_1CH_CODE
                        DW      BIOS_CODE

TIM_INT_DATA            DW      offset TIM_INT_CODE
                        DW      BIOS_CODE

NEW_1B_INT_DATA         DW      offset NEW_1B_INT_CODE
                        DW      BIOS_CODE

REINIT_DATA_RTN         DW      OFFSET REINIT_CODE_RTN
                        DW      BIOS_CODE

end_BC_entries:

;----------------------------------------------- DOS5 91/01/09 -------
;
;  Data form MODISK.ASM
;
        PUBLIC  MO_HEAD, MO_SECTOR, MAX_PART, VOL_INF_LENGTH
        PUBLIC  B_COMMAND, B_FLAG, B_SCSIID, B_LUN, B_LBAVH, B_LBAH
        PUBLIC  B_LBAM, B_LBAL, B_DOFFSET, B_DSEGMENT, B_DLENGTH
        PUBLIC  B_ODC_STATUS, B_SCSI_STATUS, B_SENSE_KEY, B_SENSE_CODE
        PUBLIC  YUKO_UNIT, MO_LPFLG, SUB_UNIT, SUB_ID, MO_DEV_OFFSET
        PUBLIC  MO_SUB_OFFSET, READ_V_FLG, READ_LABEL, ERR_STATUS
        PUBLIC  LNG_TRNSMO, LNG_PTRNS, BLOCK_TRNS, SEC_PBLOCK, SCSI_FLG
        PUBLIC  NSMO, CALLADDR, MO_DEV_LENGTH, MO_DEVICE_TBL
        PUBLIC  MO_ADDR_LENGTH, MO_ADDR_TBL, ERR_CODE_TBL

        PUBLIC  PARAMETER, CDB, REMAIN_ADDR, REMAIN_LNG, BUFFER


;****************************************
;*  VOLUM INFORMATION                   *
;****************************************

;MO_CYLINDER    DW     4656             ; fBXNu
MO_HEAD         DB        1             ; zAhXl
MO_SECTOR       DB       64             ;

MAX_PART        DB       16             ; p[eBV\
VOL_INF_LENGTH  DW       32             ; {[ǗPe[u

;****************************************
;*  COMMAND PACKET FOR MO-BIOS          *
;****************************************
                EVEN
B_COMMAND       DB      00H     ; COMMAND
B_FLAG          DB      00H     ; COMMAND FLAG
B_SCSIID        DB      00H     ; SCSI ID
B_LUN           DB      00H     ; SCSI LUN      
B_LBAVH         DB      00H     ; Logical Block Address Very Hight
B_LBAH          DB      00H     ; Logical Block Address Hight
B_LBAM          DB      00H     ; Logical Block Address Middle 
B_LBAL          DB      00H     ; Logical Block Address Low 
B_DOFFSET       DW    0000H     ; Data Area Pointer Offset 
B_DSEGMENT      DW    0000H     ; Data Area Pointer Segment
B_DLENGTH       DW    0000H     ; Data Area Length
B_ODC_STATUS    DB      00H     ; ODC 141 Status
B_SCSI_STATUS   DB      00H     ; SCSI Status
B_SENSE_KEY     DB      00H     ; 
B_SENSE_CODE    DB      00H     ;
B_RESERVE       DW    0000H     ; RESERVE

;****************************************
;*  WORK DATA                           *
;****************************************
YUKO_UNIT       DB      04H     ; Pu̗Lp[eBV
MO_LPFLG        DB      00H     ; foCXڑ
SUB_UNIT        DB      00H     ; TujbgԍZ[uGA
SUB_ID          DB      00H     ; Tujbgrbrh-hcZ[uGA
MO_DEV_OFFSET   DW      0000H   ; YufoCXe[ugd`c|C^
MO_SUB_OFFSET   DB      00H     ; Yu΃hCuԍ
READ_V_FLG      DB      00H     ; VOLUM LABEL READ FLG
READ_LABEL      DB      00H     ; VOLUM LABEL READ END FLG
ERR_STATUS      DB      00H     ; ERR STATUS FOR MS-DOS

;****************************************
;* read write process use data          *
;****************************************
LNG_TRNSMO      DW    0000H     ; ]v_ZN^@
LNG_PTRNS       DW    0000H     ; ]vZN^
BLOCK_TRNS      DW    0000H     ; ]Jn_ZN^ԍ
SEC_PBLOCK      DW    0000H     ; _ZN^̕ZN^
SCSI_FLG        DB      00H     ;
NSMO            DB      00H     ;
CALLADDR        DW    0000H

PAGE
;****************************************
;*  DEVICE DRIVER SYSTEM INFORMATION    *
;****************************************

                EVEN
MO_DEV_LENGTH   DW      4           ; PfoCXǗe[u
MO_DEVICE_TBL   DB      32 DUP(00H) ; foCXǗe[u (4Byte*4Pt*2Drv)
                DB      32 DUP(00H) ; RFU(4Byte*4Pt*2Drv)

;   +-------+-------+-------+-------+
;   | SUB   | FLAG  | SCSI  | RFU   |
;   | UNIT# | (AI)  |    ID |       |
;   +-------+-------+-------+-------+
;              01 - aoaXVς
;              02 - aoaXV
;
;
                EVEN
MO_ADDR_LENGTH  DW      12          ; P{[AhXǗe[u

MO_ADDR_TBL     DB      96 DUP(00H) ; 12Byte*4Pt*2Drv
                DB      96 DUP(00H) ; 12Byte*4Pt*2Drv(RFU)
;   +-------+-------+-------+-------+-------+-------+-------+-------+
;   | IPL  SECTOR                   | _{[Jn SECTOR     |
;   |   L       M       H      VH   |   L       M       H      VH   |
;   +-------+-------+-------+-------+-------+-------+-------+-------+
;   +-------+-------+-------+-------+ 
;   | _{[I SECTOR     |   ZN^Őݒ肳
;   |   L       M       H      VH   |   
;   +-------+-------+-------+-------+
;

;****************************************
;*  ERR CODE TBL  (16 DATA / 1LINE)     *
;****************************************

ERR_CODE_TBL:   
;-----------------------------------------------------------------------+---
; low   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F   +   
;-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
 DB    0CH,0CH,0CH,0AH,02H,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 0
 DB    04H,0BH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 1
 DB    0CH,08H,0CH,0CH,0CH,01H,05H,00H,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 2
 DB    0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 3
 DB    0CH,0CH,0CH,0CH,0CH,0CH,0CH,04H,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 4

;****************************************
;*       For SCSI Parameter area        *
;****************************************

PARAMETER       DB      00H                     ; Target LUN
                DB      00H                     ; Data send vector
                DB      00H                     ; CDB Length
                DB      00H                     ; Reserve
CDB             DB      00H                     ; Command code  0
                DB      00H                     ; Bit7-5 LUN    1
                DB      00H                     ;               2
                DB      00H                     ;               3
                DB      00H                     ;               4
                DB      00H                     ;               5
                DB      00H                     ;               6
                DB      00H                     ;               7
                DB      00H                     ;               8
                DB      00H                     ;               9

;****************************************
;*            Work data area            *
;****************************************

REMAIN_ADDR     DW      0000H                   ; Next buffer address (offset)
                DW      0000H                   ;          "	      (segment)
REMAIN_LNG      DW      0000H                   ; Remain length

BUFFER          DB      23 DUP (0CCH)

;---------------------------------------------------------------------
;----------------------------------------------- DOS5 91/08/00 -------
        public  MO_LPFLG2, MOSW2, Lockcnt, time_buf, time_to_retry
MO_LPFLG2       DB      0               ; 3.5" MO disk equip flag
MOSW2           DB      0               ;
Lockcnt         db      8 dup (0)       ; Lock/Unlock cnt * 2+2 unit
time_buf        db      6 dup (0)       ; bufer for timer bios
time_to_retry   dw      4               ; wait time
;---------------------------------------------------------------------
;----------------------------------------------- DOS5 91/01/10 -------
;
;  Data form DSKIO.ASM
;
        PUBLIC  MYATN, MYFAT, FIRST, RETCODE, NO_NAME, MOSW
        PUBLIC  SNGDRV1_MSG, SNGDRV2_MSG, SNGDRV_CMN, SNG_MSG1
        PUBLIC  MASKB, F_SW, DB_TRNS, NBYTETBL, NBYTETBL5

        PUBLIC  CURSEC, CURHD, CURTRK, HDNUM
        PUBLIC  PATCH0, PATCH1, PATCH3, TrackTable
        PUBLIC  sectorsPerTrack, mediaType
        PUBLIC  fSetOwner, PART_NUM


MYATN           DW      ?
MYFAT           DB      ?
FIRST           DB      0
RETCODE         DB      0
NO_NAME         DB      'NO NAME    ',00H
MOSW            DB      0
;
;
;       MESSAGE DATA
;
SNGDRV1_MSG     DB      13,10,'hCu@'
SNGDRV1_FLD     DB      'A@ɃfBXN}ĉ',0
SNGDRV2_MSG     DB      13,10,'hCu@'
SNGDRV2_FR      DB      'B@ɑ}悤ƂfBXNhCu@'
SNGDRV2_LT      DB      'A  ɑ}ĉ',0
SNGDRV_CMN      DB      13,10,'}IAKȃL\ĉ'
SNG_MSG1        DB      0
;
MASKB           DB      1,2,4,8
F_SW            DB      0
DB_TRNS         DW      0
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>                             ;1.44MB support
NBYTETBL        DB      0,3,2,2,0,0,0,0,0       ;1MB FD DENSITY 871003
;---------------
;NBYTETBL       DB      0,3,0,2,0,0,0,0,0       ;1MB FD DENSITY 871003
;---------------------------------------------------------------------
NBYTETBL5       DB      0,0,0,0,0,0,3,2,0       ;640KFD DENSITY 871003


;
; The following two sets of variables are used to hold values for
; disk I/O operations

CURSEC  DB      0                       ; current sector
CURHD   DB      0                       ; current head
CURTRK  DW      0                       ; current track

;
; The following are used for IOCTL function calls
;

HDNUM           DB      0                   ; Head number

;--------------------------------------------------------- 89/08/08 --
PATCH0          DW      0
PATCH1          DW      0
PATCH3          DB      0
;---------------------------------------------------------------------

MAX_SECTORS_CURR_SUP    equ     40      ; current maximum sec/trk that
                                                ; we support
;
; TrackTable is an area for saving information passwd by the set device
; parameter function for laster use my Read/Write/Format/Verify.
;

TrackTable      db      160 DUP (?)
        ;MAX_SECTORS_CURR_SUP * size a_SectorTable


sectorsPerTrack dw      15

mediaType       db      0

fSetOwner       db      0

PART_NUM        DB      0

;
;  Data from INIT.ASM
;

        PUBLIC  INFVT, BOOT_PART, WSINGLE, READ_BUF
        PUBLIC  BOOT_DRIVE

INFVT           DB      00000000B       ;VIRTUAL DRIVE MUST BE 4

;---------------------------------------------------- 871001 ---------
BOOT_PART       DW      0               ;BOOT PARTITION ENTRY
BOOT_DRIVE      DB      0               ;BOOT DRIVE NUMBER 
;---------------------------------------------------------------------
WSINGLE         DB      0

READ_BUF        DB      24H DUP (0)

;---------------------------------------------------------------------

;----------------------------------------------- DOS5 91/01/11 -------
;
;  Data from READDOS.ASM
;
        PUBLIC  REQUEST, REQ_LEN, REQ_UNT, REQ_CMD
        PUBLIC  REQ_STS, REQ_RFU, REQ_MDA, REQ_TRNS
        PUBLIC  REQ_CNT, REQ_STRT, RD_UNIT, MDA_DSC
        PUBLIC  FATSEC, DIRSEC, DATASEC, FATLEN
        PUBLIC  FATLOC, FAT1ST, BPBPTR, DOSCNT
        PUBLIC  DOSLOC, RD_FBIGFAT, DIRLEN, FAT1CONF
        PUBLIC  CONFSIZE, SW_RCONF
;----------------------------------------------- DOS5 91/05/30 -------
        PUBLIC  REQ_STRTL, REQ_STRTH, MAXSEC
;---------------------------------------------------------------------

;
;       REQUEST PACKET
;
REQUEST LABEL   BYTE
REQ_LEN         DB      ?               ;LENGTH OF REQUEST
REQ_UNT         DB      ?               ;UNIT NUMBER
REQ_CMD         DB      ?               ;COMMAND CODE
REQ_STS         DW      ?               ;STATUS
REQ_RFU         DB      8 DUP(?)        ;RESERVE

REQ_MDA         DB      ?               ;MEDIA DESCRIPTOR
REQ_TRNS        DD      ?               ;TRANSFER ADDRESS
REQ_CNT         DW      ?               ;COUNT OF BLOCK
REQ_STRT        DW      ?               ;1ST BLOCK FOR TRANSFER

;----------------------------------------------- DOS5 91/05/30 -------
REQ_VOLID       DD      ?
REQ_STRTL       DW      ?               ;LOW WORD OF START SECTOR
REQ_STRTH       DW      ?               ;HIGH WORD OF START SECTOR
;---------------------------------------------------------------------



;       VARIABLES
;
RD_UNIT         DB      0               ;UNIT NUMBER
MDA_DSC         DB      0               ;MEDIA DESCRIPTOR SAVE
FATSEC          DW      0               ;FAT SECTOR
DIRSEC          DW      0               ;DIRECTORY SECTOR
DATASEC         DW      0               ;TOP OF DATA AREA
FATLEN          DW      0               ;FAT LENGTH (# OF SECTOR)
FATLOC          DW      0               ;PARAGRAPH OF FAT-BUFFER
FAT1ST          DW      0               ;1ST FAT NO.
BPBPTR          DW      0               ;BPB POINTER
DOSCNT          DW      0               ;READ SECTOR COUNT
DOSLOC          DW      0               ;PARAGRAPH OF MSDOS SEG
;--------------------------------------------------------- 88/04/07 --
RD_FBIGFAT      DB      0               ;12Bit FAT:0, 16Bit FAT:FFH
;-------------------------------------------------------------- 880520
DIRLEN          DW      0               ;SECTOR SIZE OF DIRECTORY
FAT1CONF        DW      0               ;1ST FAT OF 'CONFIG.SYS'
CONFSIZE        DW      0               ;SIZE 'CONFIG.SYS' (LOW WORD)
;---------------------------------------------------------------------
SW_RCONF        DB      0               ;0 :CONFIG.SYS NOT READ
                                        ;-1:CONFIG.SYS READ & CHECK LIM
;---------------------------------------------------------------------
MAXSEC          DW      0               ;SECTORS WITHIN 64Kb


        PUBLIC  ATTRF,CRTDOTF,BIOSF_3

ATTRF           DW      0001H           ;2BYTE ATTR FLAG
CRTDOTF         DW      0001H           ;480DOT MODE FLAG
BIOSF_3         DB      00H             ;BIOS_FLG(3)            89/08/21

;****************************************
;*                                      *
;*      SAVE AREA & LOCAL STACK         *
;*                                      *
;****************************************

        PUBLIC  EXT_SAVAX,EXT_SAVSS,EXT_SAVSP,EXT_SAVDS,EXT_SAVDX,EXT_SAVBX
        PUBLIC  EXT_STACK

EXT_SAVAX       DW      ?               ;AX SAVE
EXT_SAVSS       DW      ?               ;SS SAVE
EXT_SAVSP       DW      ?               ;SP SAVE
EXT_SAVDS       DW      ?               ;DS SAVE
EXT_SAVDX       DW      ?               ;DX SAVE                87/8/14
EXT_SAVBX       DW      ?               ;BX SAVE                88/03/31
;
                DW      192 DUP(0CCCCH) ;EXT_BIOS LOCAL STACK
                                        ;SIZE 192 WORD          91/01/20
EXT_STACK       EQU     $

        PUBLIC  STP_SAVAX,STP_SAVSS,STP_SAVSP
        PUBLIC  STOP_STACK

STP_SAVAX       DW      ?               ;AX SAVE
STP_SAVSS       DW      ?               ;SS SAVE
STP_SAVSP       DW      ?               ;SP SAVE

                DW      192 DUP(0CCCCH) ;STOP KEY LOCAL STACK
                                        ;SIZE 192 LEVEL         91/01/20
STOP_STACK      EQU     $

;
;  Data from HDSASI.ASM
;
        PUBLIC  save_ss, save_sp, save_ax, stack

save_ss dw      0
save_sp dw      0
save_ax dw      0
        dw      192     dup     (0cccch)
stack   equ     $

FREE_5          EQU     0ABCH-($-BIO2_START)
                DB      FREE_5 DUP(0)

;--------------------------------------------------------- 88/05/18 --
;DIC_BUG        DB      1024 DUP(0)     ;BUFFER FOR PAGE READ
;INDEX_BUFF     DB      2048 DUP(?)     ;BUFFER FOR PAGE INDEX
;---------------------------------------------------------------------
                ORG     0ABCH
;----------------------------------------------- DOS5A 92/05/21 --------
;<patch BIOS50-P19>
DSK_BUF2        DB      1024 DUP(?)
DSK_BUF         DB      2048 DUP(?)     ;2KB DISK BUFFER (DSK_BUF2+DSK_BUF)
;---------------
;DSK_BUF_RFU    DB      1024 DUP(?)     ;DISK BUFFER RESERVE
;               ORG     6BCH
;DSK_BUF_RFU    DB      2048 DUP(?)     ;DISK BUFFER RESERVE
STACK_TOP       LABEL   WORD
;DSK_BUF2       DB      1024 DUP(?)     ;2KB DISK BUFFER (DSK_BUF2+DSK_BUF)
;DSK_BUF                DB      1024 DUP(?)     ;1KB DISK BUFFER
;-----------------------------------------------------------------------
FREE_6          EQU     16C0H-($-BIO2_START)
                DB      FREE_6 DUP(0)

        ORG     16C0H
FKYTBLADR       DW      FKYTBL          ;FOR BUNSETSU
                                                
;************************************************
;*                                              *
;*      DISK BIOS PARAMETER BLOCK               *
;*                                              *
;************************************************

        PUBLIC  DSK8_SNG,DSK8_DBL,DSK_AT
        PUBLIC  DSK5_SNG8,DSK5_SNG9,DSK5_DBL8,DSK5_DBL9
        PUBLIC  DSK5_DBL8D,DSK5_DBL9D
        PUBLIC  COMP_HDDSK5_1,COMP_HDDSK5_2

                                ;256BFD (8"1S MEDIA ONLY)
DSK8_SNG        DW      128             ;SECTOR LENGTH
                DB      4               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      68              ;DIRECTORY ENTRY
                DW      77*26           ;VOLUME SIZE
                DB      0               ;MEDIA TYPE
                DW      6               ;SECTOR/FAT

                                ;1MBFD  (8"2D/5"(3.5")2HD MEDIA)
DSK8_DBL        DW      1024            ;SECTOR LENGTH
                DB      1               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      192             ;DIRECTORY ENTRY
                DW      77*8*2          ;VOLUME SIZE
                DB      1               ;MEDIA TYPE
                DW      2               ;SECTOR/FAT

                                ;1MBFD  (IBM AT FORMAT (15SECTOR/TRACK))
DSK_AT          DW      512             ;SECTOR LENGTH
                DB      1               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      224             ;DIRECTORY ENTRY
                DW      15*2*80         ;VOLUME SIZE
                DB      2               ;MEDIA TYPE
                DW      7               ;SECTOR/FAT

;DSK8_SNG4      DW      128             ;16DCH
;               DB      4
;               DW      4
;               DB      2
;               DW      68
;               DW      77*26
;               DB      2
;               DW      6

DSK5_SNG8       DW      512             ;SECTOR LENGTH
                DB      1               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      64              ;DIRECTORY ENTRY
                DW      40*8            ;VOLUME SIZE
                DB      -2              ;MEDIA TYPE
                DW      1               ;SECTOR/FAT

DSK5_SNG9       DW      512             ;SECTOR LENGTH
                DB      1               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      64              ;DIRECTORY ENTRY
                DW      40*9            ;VOLUME SIZE
                DB      -4              ;MEDIA TYPE
                DW      2               ;SECTOR/FAT

DSK5_DBL8       DW      512             ;SECTOR LENGTH
                DB      2               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      112             ;DIRECTORY ENTRY
                DW      40*8*2          ;VOLUME SIZE
                DB      -1              ;MEDIA TYPE
                DW      1               ;SECTOR/FAT

DSK5_DBL9       DW      512             ;SECTOR LENGTH
                DB      2               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      112             ;DIRECTORY ENTRY
                DW      40*9*2          ;VOLUME SIZE
                DB      -3              ;MEDIA TYPE
                DW      2               ;SECTOR/FAT

DSK5_DBL8D      DW      512             ;SECTOR LENGTH
                DB      2               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      112             ;DIRECTORY ENTRY
                DW      80*8*2          ;VOLUME SIZE
                DB      -5              ;MEDIA TYPE
                DW      2               ;SECTOR/FAT

DSK5_DBL9D      DW      512             ;SECTOR LENGTH
                DB      2               ;SECTOR/ALLOC UNIT
                DW      1               ;RESERVED SECTOR
                DB      2               ;FATS
                DW      112             ;DIRECTCORY ENTRY
                DW      80*9*2          ;VOLUME SIZE
                DB      -7              ;MEDIA TYPE
                DW      3               ;SECTOR/FAT

COMP_HDDSK5_1   DB      13 DUP(0)       ;1737H

COMP_HDDSK5_2   DB      13 DUP(0)       ;1744H

FREE_7          EQU     1760H-($-BIO2_START)
                DB      FREE_7 DUP(0)

        ORG     1760H
BIDTBL5         DB      70H,71H,72H,73H
BIDTBL          DB      90H,91H,92H,93H
PREDNST         DB      1,1,1,1
PREDENS5        DB      4,4,4,4
PUA             DB      0
PWINF           DB      0
FSW5            DB      0
FSW8            DB      0
AIRST           DB      0
OPMOD           DB      01FH
OPMOD5          DB      07FH
SAVEAL          DB      0

;************************************************
;*                                              *
;*      B4670 SOFT USE AREA                     *
;*                                              *
;************************************************

        PUBLIC  VT_OFFSET,VT_LAST
        PUBLIC  VBPB,VCPV,VBPS,VTPC,VSPT
        PUBLIC  X2_SW_VT
FREE_8          EQU     177EH-($-BIO2_START)
                DB      FREE_8 DUP(0)

                ORG     177EH
B4670_TABLE     LABEL   FAR
                DW      VSYS_FLAG       ;POINTER TO [VSYS_FLAG]

                ORG     1780H
VT_OFFSET       DW      0,0             ;1780H
                DW      0,0
                DW      0,0
                DW      0,0
                                        ;OFFSET OF VIRTUAL DISK START
                                        ;85/05/19
VT_LAST         DW      0,0             ;1790H
                DW      0,0
                DW      0,0
                DW      0,0
                                        ;LIMIT ADDR OF VIRTUAL DISK
                                        ;85/05/19
                                        ;17A0H
VBPB            DB      13 DUP (0)      ;VIRTUAL BPB ADDR OF #1
                DB      13 DUP (0)      ; "                #2
                DB      13 DUP (0)      ; "                #3
                DB      13 DUP (0)      ; "	             #4

VCPV            DW      0,0,0,0         ;85/05/15
VBPS            DW      0,0,0,0         ;85/05/15
VTPC            DB      0,0,0,0         ;85/05/15
VSPT            DB      0,0,0,0         ;85/05/15

X2_SW_VT        DB      0               ;??

                DB      0               ;FREE

;************************************************
;*                                              *
;       AUX I/O WORKING FIELD                   *
;*                                              *
;************************************************

        PUBLIC  AUX_HEADER,AUX1_HEADER,AUX2_HEADER
;------------------------------------------------------ 88/03/31 -----
        PUBLIC  CH1MSW1,CH1MSW2,CH2MSW1,CH2MSW2,CH3MSW1,CH3MSW2
        PUBLIC  AUX3_HEADER

        ORG     17EEH
CH1MSW1         DB      0               ;INIT INFO. FOR RS232C-1
CH1MSW2         DB      0
CH2MSW1         DB      0               ;INIT INFO. FOR RS232C-2
CH2MSW2         DB      0
CH3MSW1         DB      0               ;INIT INFO. FOR RS232C-3
CH3MSW2         DB      0

AUX3_HEADER     DW      0,0             ;AUX3 DRIVER ADDRESS
;---------------------------------------------------------------------
        ORG     17F8H                   ;870923
AUXILIARY_TABLE LABEL   FAR

AUX1_HEADER     DW      0,0             ;870923 AUX2 DRIVER ADDRESS
AUX2_HEADER     DW      0,0             ;870923 AUX3 DRIVER ADDRESS

        ORG     1800H
AUX_HEADER      DW      0,0             ;AUX DEVICE DRIVER ADDRESS
BIO2_AUX_READ:
                JMP     AUX_READ        ;READ COMMAND
BIO2_AUX_RDND:
                JMP     AUX_RDND        ;NON DESTRUCTIVE READ COMMAND
BIO2_AUX_FLSH:
                JMP     AUX_FLSH        ;FLUSH COMMAND
BIO2_AUX_WRIT:
                JMP     AUX_WRIT        ;WRITE COMMAND
BIO2_AUX_WRST:
                JMP     AUX_WRST        ;WRITE STATUS COMMAND
;--------------------------------------------------------- 90/03/20 --
                DB      0
        ORG     1814H

        PUBLIC  LINETBL
;************************************************
;*   LINE CONTROL TABLE                         *
;************************************************
        EVEN
LINETBL DW      0                       ;LINE 0
        DW      0A0H                    ;     1
        DW      140H                    ;     2
        DW      1E0H                    ;     3
        DW      280H                    ;     4
        DW      320H                    ;     5
        DW      3C0H                    ;     6
        DW      460H                    ;     7
        DW      500H                    ;     8
        DW      5A0H                    ;     9
        DW      640H                    ;     10
        DW      6E0H                    ;     11
        DW      780H                    ;     12
        DW      820H                    ;     13
        DW      8C0H                    ;     14
        DW      960H                    ;     15
        DW      0A00H                   ;     16
        DW      0AA0H                   ;     17
        DW      0B40H                   ;     18
        DW      0BE0H                   ;     19
        DW      0C80H                   ;     20
        DW      0D20H                   ;     21
        DW      0DC0H                   ;     22
        DW      0E60H                   ;     23
        DW      0F00H                   ;     24
        DW      0FA0H                   ;     25
        DW      1040H                   ;     26
        DW      10E0H                   ;     27
        DW      1180H                   ;     28
        DW      1220H                   ;     29
        DW      12C0H                   ;     30
        DW      0                       ;RFU

        PUBLIC  ESCATTRTBL,SGRFLG,ATTRTBL2
;************************************************
;*   ATTRIBUTE TABLE FOR (ESCVT_SGR)            *
;************************************************
ESCATTRTBL      EQU     $
        DB      0                       ;0  DEFAULT
        DB      0E0H                    ;1  HIGH INTENSITY (WHITE)
        DB      10H                     ;2  VL
        DB      0                       ;3  DEFAULT (RFU)
        DB      08H                     ;4  UL
        DB      02H                     ;5  BLINK
        DB      0                       ;6  DEFAULT (RFU)
        DB      04H                     ;7  REVERSE
        DB      0                       ;8  SECRET
        DB      0,0,0,0,0,0,0           ;9-15 RFU
        DB      0                       ;16 SECRET
        DB      40H                     ;17 COLOR : RED
        DB      20H                     ;18       : BLUE
        DB      60H                     ;19       : MASENDA
        DB      80H                     ;20       : GREEN(DEFAULT)
        DB      0C0H                    ;21       : YELLOW
        DB      0A0H                    ;22       : LIGHT BLUE
        DB      0E0H                    ;23       : WHITE
        DB      0,0,0,0,0,0             ;24-29  RFU
        DB      0                       ;30 COLOR : BLACK
        DB      40H                     ;31       : RED
        DB      80H                     ;32       : GREEN
        DB      0C0H                    ;33       : YELLOW
        DB      20H                     ;34       : BLUE
        DB      60H                     ;35       : MAGENDA
        DB      0A0H                    ;36       : CYAN
        DB      0E0H                    ;37       : WHITE
        DB      0,0                     ;38,39 RFU
        DB      04H                     ;40 REVERSE BLACK
        DB      44H                     ;41         RED
        DB      84H                     ;42         YELLOW
        DB      0C4H                    ;43         GREEN
        DB      24H                     ;44         BLUE
        DB      64H                     ;45         MAGENDA
        DB      0A4H                    ;46         CYAN
        DB      0E4H                    ;47         WHITE
;
SGRFLG  DB      0                       ;INDICATE FOR BLACK COLOR
;-----------------------------------------------------  89/08/16  ---

ATTRTBL2        EQU     $
        DB      40 DUP (0)
        DB      0H                      ; 40 BACK BLACK
        DB      40H                     ; 41      RED
        DB      20H                     ; 42      GREEN
        DB      60H                     ; 43      YELLOW
        DB      10H                     ; 44      BLUE
        DB      50H                     ; 45      MAGENDA
        DB      30H                     ; 46      CYAN
        DB      70H                     ; 47      WHITE
;--------------------------------------------------------------------
        PUBLIC  WAKU_TABLE,JPN_SCRD1H,JPN_SCRD1N,ROME_1STSAV
;************************************************
;*                                              *
;*      VIDEO CONTROL SUBROUTINES               *
;*                                              *
;************************************************
;       SHIFT STATE (GUIDE LINE) DATA 

WAKU_TABLE      DW      0020H,0020H
                DW      4C01H,4C81H,3109H,3609H,4A1FH,4A9FH,4D01H,4D81H

;       DATAT FOR SCROLL_COMMAND (GDC)

JPN_SCRD1H      DW      0000H,0018H,1F00H,0001H ;SAD1=0   SL=25
                DW      0000H,001EH,1F00H,0001H ;SAD1=0   SL=31
                DW      00A0H,0018H,1F00H,0001H ;SAD1=50H SL=25
                DW      00A0H,001EH,1F00H,0001H ;SAD1=50H SL=31
                DW      0000H,0018H,0F00H,0001H ;ERASE G-LINE SL=25
                DW      0000H,001EH,12C0H,0001H ;ERASE G-LINE SL=31

JPN_SCRD1N      DW      0000H,0013H,1F00H,0001H ;SAD1=0   SL=25
                DW      0000H,0018H,1F00H,0001H ;SAD1=0   SL=31
                DW      00A0H,0013H,1F00H,0001H ;SAD1=50H SL=25
                DW      00A0H,0018H,1F00H,0001H ;SAD1=50H SL=31
                DW      0000H,0019H,0F00H,0001H ;ERASE G-LINE SL=25
                DW      0000H,0019H,12C0H,0001H ;ERASE G-LINE SL=31

ROME_1STSAV     DB      0
;----------------------------------------------------------------------
;************************************************
;*                                              *
;*      TABLE WHICH DEFINE BPB'S(26 ENTRY)	*
;*                                              *
;************************************************
INIT_TBL        DW      0             ; A
                DW      0             ; B
                DW      0             ; C
                DW      0             ; D
                DW      0             ; E
                DW      0             ; F
                DW      0             ; G
                DW      0             ; H
                DW      0             ; I
                DW      0             ; J
                DW      0             ; K
                DW      0             ; L
                DW      0             ; M
                DW      0             ; N
                DW      0             ; O
                DW      0             ; P
                DW      0             ; Q
                DW      0             ; R
                DW      0             ; S
                DW      0             ; T
                DW      0             ; U
                DW      0             ; V
                DW      0             ; W
                DW      0             ; X
                DW      0             ; Y
                DW      0             ; Z

IF BRANCH ;----------------------------------------------- 90/03/16 --
;
;  VIRTUAL DISK BPB
;
VT_BPB  DW      1024                    ;BYTES / SECTOR
        DB      8                       ;# OF ALLOC UNITS
        DW      1                       ;RESERVED SECTOR
        DB      2                       ;# OF FATS
        DW      1504                    ;# OF DIRECTORIES
        DW      990*20                  ;TOTAL SECTORS
        DB      23H                     ;MEDIA DISCRIPTOR
        DW      4                       ;SECTORS / FAT
ENDIF ;----------------------------------------------------------------
;
;       CONSTANT DATA
;
;--------------------------------------------------------- 88/03/23 --
IF BRANCH ;----------------------------------------------- 90/03/16 --
        PUBLIC  VT_BPB
ENDIF ;---------------------------------------------------------------
        PUBLIC  INIT_TBL
        PUBLIC  CHR_VOL1,CHR_X2,HD_LBL,X2_SW_00,X2_SW_01
        PUBLIC  X2_SW_02,X2_SW_03
        PUBLIC  DD_FLG,SV_SELECT,SV_RDRV,SVHD1,SVHD2
;------------------------------------------------------ 870827 -------------
        PUBLIC  EXFNC_FLG
        PUBLIC  SVHD3,SVHD4
        PUBLIC  SVHDS1,SVHDS2
        PUBLIC  SVHDS3,SVHDS4
        PUBLIC  SVHDS5,SVHDS6
        PUBLIC  SVHDS7,SVHDS8

;---------------------------------------------------------------------
CHR_VOL1        DB      'VOL1'
CHR_X2          DB      55H,0AAH
HD_LBL          DB      'MS-DOS INF AREA'
X2_SW_00        DB      0
X2_SW_01        DB      0
X2_SW_02        DB      0
X2_SW_03        DB      0
DD_FLG          DB      0
SV_SELECT       DB      0               ; 84/11/12
SV_RDRV         DB      0               ; 84/11/12
EXFNC_FLG       DB      0               ; 88/02/25
SVHD1           DW      0               ; 84/11/19
SVHD2           DW      0               ; 84/11/19
SVHD3           DW      0               ; 88/03/23
SVHD4           DW      0               ; 88/03/23
SVHDS1          DW      0               ; 88/03/23
SVHDS2          DW      0               ; 88/03/23
SVHDS3          DW      0               ; 88/03/23
SVHDS4          DW      0               ; 88/03/23
SVHDS5          DW      0               ; 88/06/25
SVHDS6          DW      0               ; 88/06/25
SVHDS7          DW      0               ; 88/06/25
SVHDS8          DW      0               ; 88/06/25

;------------------------------------------------DOS5 91/01/20-----------
        PUBLIC  FAT12, FAT16
FAT12           DB      "FAT12   ",0
FAT16           DB      "FAT16   ",0
;------------------------------------------------------------------------

FREE_9          EQU     19FBH-($-BIO2_START)
                DB      FREE_9 DUP(0)

        ORG     19FBH                   ;85/09/24
VSYS_FLAG       DB      0               ;85/09/24
B4670_UCW_ADR   DD      0               ;85/09/24

;************************************************
;*                                              *
;*      KANJI DRIVER WORKING AREA               *
;*                                              *
;************************************************

        PUBLIC  KNJ_HEADER

        ORG     1A00H
KNJ_HEADER      DW      0,0             ;WITHOUT KEY-CODE ENTRY
                DW      0,0             ;WITH    KEY-CODE ENTRY
                DW      0,0             ;KB_KANJ1
                DW      0,0             ;TRANSFER
                DW      0,0             ;KBCODE_NIP
                DW      0,0             ;KANJI_HOME
                DW      0,0             ;KANJI_MOD_TABLE
                DW      0,0             ;RESERVED
                DW      0,0             ;RESERVED
                DW      0,0             ;RESERVED

        ORG     1A28H
JPN_BELL:                               ;BELL ENTRY
                CALL    BELRTN_DATARTN
JBELL           PROC    FAR
                RET
JBELL           ENDP

JPN_MCONV:                              ;CODE CONVERT ENTRY
                CALL    D_MCONV_DATARTN
JMCNV           PROC    FAR
                RET
JMCNV           ENDP

JPN_HEX:                                ;HEX INPUT ENTRY
                CALL    HEXCHK_DATARTN
JHEX            PROC    FAR
                RET
JHEX            ENDP

KB_KANJI_ENT:                           ;JAPAN MODE ENTRY
                DB      09AH
                DD      KNJENTP
KNJENTP         PROC    FAR
                RET
KNJENTP         ENDP

KB_KANJI_EXT:                           ;JAPAN MODE EXIT
                DB      09AH
                DD      KNJEXTP
KNJEXTP         PROC    FAR
                RET
KNJEXTP         ENDP

FREE_10         EQU     1A50H-($-BIO2_START)
                DB      FREE_10 DUP(0)

        ORG     1A50H
;--------------------------------------------------------- 88/05/18 --
;STUDY_BUFF     DB      1024 DUP(?)     ;GAKUSHU PAGE BUFFER
;---------------------------------------------------------------------

;************************************************
;*                                              *
;*      SCSI HD INFOMATION                      *
;*                                              *
;************************************************

        PUBLIC  HDS_OFFSET,HDS1_OFFSET
        PUBLIC  HDS2_OFFSET,HDS3_OFFSET
        PUBLIC  HDS4_OFFSET,HDS5_OFFSET
        PUBLIC  HDS6_OFFSET,HDS7_OFFSET
        PUBLIC  HDS_LAST,HDS1_LAST
        PUBLIC  HDS2_LAST,HDS3_LAST
        PUBLIC  HDS4_LAST,HDS5_LAST
        PUBLIC  HDS6_LAST,HDS7_LAST
        PUBLIC  HDS_NUM,HDS1_NUM
        PUBLIC  HDS2_NUM,HDS3_NUM
        PUBLIC  HDS4_NUM,HDS5_NUM
        PUBLIC  HDS6_NUM,HDS7_NUM
        PUBLIC  HDDSKS_1,HDDSKS_2
        PUBLIC  HDDSKS_3,HDDSKS_4
        PUBLIC  HDDSKS_5,HDDSKS_6
        PUBLIC  HDDSKS_7,HDDSKS_8
        PUBLIC  CPVS,CPVS1,BPSS,BPSS1,TPCS,TPCS1,SPTS,SPTS1
        PUBLIC  CPVS2,CPVS3,BPSS2,BPSS3,TPCS2,TPCS3,SPTS2,SPTS3
        PUBLIC  CPVS4,CPVS5,BPSS4,BPSS5,TPCS4,TPCS5,SPTS4,SPTS5
        PUBLIC  CPVS6,CPVS7,BPSS6,BPSS7,TPCS6,TPCS7,SPTS6,SPTS7


HDS_OFFSET      DW      0,0,0,0         ;SCSI #0
                DW      0,0,0,0
HDS1_OFFSET     DW      0,0,0,0         ;SCSI #1
                DW      0,0,0,0
HDS2_OFFSET     DW      0,0,0,0         ;SCSI #2
                DW      0,0,0,0
HDS3_OFFSET     DW      0,0,0,0         ;SCSI #3
                DW      0,0,0,0
HDS4_OFFSET     DW      0,0,0,0         ;SCSI #4
                DW      0,0,0,0
HDS5_OFFSET     DW      0,0,0,0         ;SCSI #5
                DW      0,0,0,0
HDS6_OFFSET     DW      0,0,0,0         ;SCSI #6
                DW      0,0,0,0
HDS7_OFFSET     DW      0,0,0,0         ;SCSI #7
                DW      0,0,0,0

                                        ;LAST SECTOR OF EACH DOS PART
HDS_LAST        DW      0,0,0,0         ;SCSI #0
                DW      0,0,0,0
HDS1_LAST       DW      0,0,0,0         ;SCSI #1
                DW      0,0,0,0
HDS2_LAST       DW      0,0,0,0         ;SCSI #2
                DW      0,0,0,0
HDS3_LAST       DW      0,0,0,0         ;SCSI #3
                DW      0,0,0,0
HDS4_LAST       DW      0,0,0,0         ;SCSI #4
                DW      0,0,0,0
HDS5_LAST       DW      0,0,0,0         ;SCSI #5
                DW      0,0,0,0
HDS6_LAST       DW      0,0,0,0         ;SCSI #6
                DW      0,0,0,0
HDS7_LAST       DW      0,0,0,0         ;SCSI #7
                DW      0,0,0,0

HDS_NUM         DB      0               ;NUMBER OF MS-DOS AREA IN SCSI #0
HDS1_NUM        DB      0               ;NUMBER OF MS-DOS AREA IN SCSI #1
HDS2_NUM        DB      0               ;NUMBER OF MS-DOS AREA IN SCSI #2
HDS3_NUM        DB      0               ;NUMBER OF MS-DOS AREA IN SCSI #3
HDS4_NUM        DB      0               ;NUMBER OF MS-DOS AREA IN SCSI #4
HDS5_NUM        DB      0               ;NUMBER OF MS-DOS AREA IN SCSI #5
HDS6_NUM        DB      0               ;NUMBER OF MS-DOS AREA IN SCSI #6
HDS7_NUM        DB      0               ;NUMBER OF MS-DOS AREA IN SCSI #7

HDDSKS_1        DB      HDDSK_SIZE DUP (0)      ;SCSI #0
HDDSKS_2        DB      HDDSK_SIZE DUP (0)      ;SCSI #1
HDDSKS_3        DB      HDDSK_SIZE DUP (0)      ;SCSI #2
HDDSKS_4        DB      HDDSK_SIZE DUP (0)      ;SCSI #3
HDDSKS_5        DB      HDDSK_SIZE DUP (0)      ;SCSI #4
HDDSKS_6        DB      HDDSK_SIZE DUP (0)      ;SCSI #5
HDDSKS_7        DB      HDDSK_SIZE DUP (0)      ;SCSI #6
HDDSKS_8        DB      HDDSK_SIZE DUP (0)      ;SCSI #7

CPVS            DW      0               ;CYLINDER PER VOLUME IN DEV SCSI #0
CPVS1           DW      0               ;CYLINDER PER VOLUME IN DEV SCSI #1
CPVS2           DW      0               ;CYLINDER PER VOLUME IN DEV SCSI #2
CPVS3           DW      0               ;CYLINDER PER VOLUME IN DEV SCSI #3
CPVS4           DW      0               ;CYLINDER PER VOLUME IN DEV SCSI #4
CPVS5           DW      0               ;CYLINDER PER VOLUME IN DEV SCSI #5
CPVS6           DW      0               ;CYLINDER PER VOLUME IN DEV SCSI #6
CPVS7           DW      0               ;CYLINDER PER VOLUME IN DEV SCSI #7

BPSS            DW      0               ;BYTE PER SECTOR IN DEV SCSI #0
BPSS1           DW      0               ;BYTE PER SECTOR IN DEV SCSI #1
BPSS2           DW      0               ;BYTE PER SECTOR IN DEV SCSI #2
BPSS3           DW      0               ;BYTE PER SECTOR IN DEV SCSI #3
BPSS4           DW      0               ;BYTE PER SECTOR IN DEV SCSI #4
BPSS5           DW      0               ;BYTE PER SECTOR IN DEV SCSI #5
BPSS6           DW      0               ;BYTE PER SECTOR IN DEV SCSI #6
BPSS7           DW      0               ;BYTE PER SECTOR IN DEV SCSI #7

TPCS            DB      0               ;TRACK PER CYLINDER IN DEV SCSI #0
TPCS1           DB      0               ;TRACK PER CYLINDER IN DEV SCSI #1
TPCS2           DB      0               ;TRACK PER CYLINDER IN DEV SCSI #2
TPCS3           DB      0               ;TRACK PER CYLINDER IN DEV SCSI #3
TPCS4           DB      0               ;TRACK PER CYLINDER IN DEV SCSI #4
TPCS5           DB      0               ;TRACK PER CYLINDER IN DEV SCSI #5
TPCS6           DB      0               ;TRACK PER CYLINDER IN DEV SCSI #6
TPCS7           DB      0               ;TRACK PER CYLINDER IN DEV SCSI #7

SPTS            DB      0               ;SECTOR PER TRACK IN DEV SCSI #0
SPTS1           DB      0               ;SECTOR PER TRACK IN DEV SCSI #1
SPTS2           DB      0               ;SECTOR PER TRACK IN DEV SCSI #2
SPTS3           DB      0               ;SECTOR PER TRACK IN DEV SCSI #3
SPTS4           DB      0               ;SECTOR PER TRACK IN DEV SCSI #4
SPTS5           DB      0               ;SECTOR PER TRACK IN DEV SCSI #5
SPTS6           DB      0               ;SECTOR PER TRACK IN DEV SCSI #6
SPTS7           DB      0               ;SECTOR PER TRACK IN DEV SCSI #7


                PUBLIC  INFSH
                PUBLIC  NSHD
                PUBLIC  DA
                PUBLIC  HD_CNT
                PUBLIC  SCSI_CNT
                PUBLIC  SCSI_EQUIP
                PUBLIC  MO_COUNT
                PUBLIC  SCSI55_FLG

INFSH           DB      0               ;EQUIP INF OF SCSI
NSHD            DB      0               ;SCSI HD UNIT
DA              DB      0
HD_CNT          DB      0
SCSI_CNT        DB      0
FBIGFAT         DB      0,0,0,0,0,0
FBIGFATS        DB      0,0,0,0,0,0,0,0

SCSI_EQUIP      DB      8 DUP(0FFH) ; MO DISK EQUIP DATA AREA (SET 84H)
                DB      00H             
MO_COUNT        DB      00H     ; foCXڑ䐔  (max 2 device)
SCSI55_FLG      DB      01H
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 90/12/14 -------
        PUBLIC  START_SEC_H,BLOCK_TRNS_H
        PUBLIC  OLD_AX,OLD_DX
        PUBLIC  BPBCOPY
        PUBLIC  SVPTR3

START_SEC_H     DW      0               ;HIGH WORD OF STARTIN' SECTOR
BLOCK_TRNS_H    DW      0               ;HIGH WORD OF STARTIN' SEC (MO)
OLD_AX          DW      0               ;WORK AREA FOR 32 BIT CALCULATION
OLD_DX          DW      0               ;WORK AREA FOR 32 BIT CALCULATION
BPBCOPY         DB      25 DUP (0)      ;BPB IS COPIED HERE FROM HDDSKx_x
                                        ;BUILD BPB RETURNS ADDRESS HERE
SVPTR3          DW      0               ;POINTER SAVE AREA FOR MEDIA IDS
;---------------------------------------------------------------------

FREE_11         EQU     1E50H-($-BIO2_START)
                DB      FREE_11 DUP(0)

        ORG     1E50H
KDRV_FLG        DB      0               ;NIPPONGO DRIVER FLAG
                                        ;0:NONE
                                        ;1:NECDIC/NECREN/NECTIK
                                        ;2:KNJDIC

                DB      00001010B       ;NO DELETE
                DB      00001010B       ;NO DELETE
SNRST1          DB      02H,02H,02H,02H ;85-04-23

PR_RATIO        DB      00000000B       ;PRINTER OUTPUT MODE
                ;       I     II
                ;       I     I+-------- RATIO OF ANK/KANJI
                ;       I     I           0:(2:1)       /1:(1.5:1)
                ;       I     +--------- KANJI-IN CODE
                ;       I                 0:(ESC K)     /1:(ESC T)
                ;       I
                ;       +--------------- ^P CONTROL FLAG
                ;                         0:(ECHO)      /1:(NOT)

FREE_12         EQU     1E60H-($-BIO2_START)
                DB      FREE_12 DUP(0)

        ORG     1E60H
NEC_WORK0       LABEL   BYTE
;--------------------------------------------------------- 88/05/18 --
;DIC_BUFF01     DB      1024 DUP(?)     ;NECDIC.DRV WORKING
;DIC_BUFF02     DB      1024 DUP(?)     ;
;---------------------------------------------------------------------
Public Start_BDS
Start_BDS       LABEL   DWORD
                dw      BDS1            ;Start of BDS linked list.
                dw      DATAGRP

BDS1            DW      BDS2            ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE1:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT1          DW      0               ;Open Ref. Count
;;;;;VOLID1             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS1          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB1         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK1          DB      -1              ;Last track accessed on this drive
TIM_LO1         DW      -1              ;Keep these two contiguous (?)
TIM_HI1 DW      -1
;------------------------------------------------------------------------------
VOLID1          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS2            DW      BDS3            ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE2:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT2          DW      0               ;Open Ref. Count
;;;;;VOLID2             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS2          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB2         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK2          DB      -1              ;Last track accessed on this drive
TIM_LO2         DW      -1              ;Keep these two contiguous (?)
TIM_HI2 DW      -1
;------------------------------------------------------------------------------
VOLID2          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS3            DW      BDS4            ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE3:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT3          DW      0               ;Open Ref. Count
;;;;;VOLID3             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS3          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB3         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK3          DB      -1              ;Last track accessed on this drive
TIM_LO3         DW      -1              ;Keep these two contiguous (?)
TIM_HI3 DW      -1
;------------------------------------------------------------------------------
VOLID3          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS4            DW      BDS5            ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE4:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT4          DW      0               ;Open Ref. Count
;;;;;VOLID4             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS4          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB4         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK4          DB      -1              ;Last track accessed on this drive
TIM_LO4         DW      -1              ;Keep these two contiguous (?)
TIM_HI4 DW      -1
;------------------------------------------------------------------------------
VOLID4          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS5            DW      BDS6            ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE5:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT5          DW      0               ;Open Ref. Count
;;;;;VOLID5             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS5          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB5         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK5          DB      -1              ;Last track accessed on this drive
TIM_LO5         DW      -1              ;Keep these two contiguous (?)
TIM_HI5 DW      -1
;------------------------------------------------------------------------------
VOLID5          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS6            DW      BDS7            ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE6:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT6          DW      0               ;Open Ref. Count
;;;;;VOLID6             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS6          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB6         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK6          DB      -1              ;Last track accessed on this drive
TIM_LO6         DW      -1              ;Keep these two contiguous (?)
TIM_HI6 DW      -1
;------------------------------------------------------------------------------
VOLID6          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS7            DW      BDS8            ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE7:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT7          DW      0               ;Open Ref. Count
;;;;;VOLID7             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS7          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB7         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK7          DB      -1              ;Last track accessed on this drive
TIM_LO7         DW      -1              ;Keep these two contiguous (?)
TIM_HI7 DW      -1
;------------------------------------------------------------------------------
VOLID7          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS8            DW      BDS9            ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE8:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT8          DW      0               ;Open Ref. Count
;;;;;VOLID8             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS8          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB8         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK8          DB      -1              ;Last track accessed on this drive
TIM_LO8         DW      -1              ;Keep these two contiguous (?)
TIM_HI8 DW      -1
;------------------------------------------------------------------------------
VOLID8          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS9            DW      BDS10           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE9:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT9          DW      0               ;Open Ref. Count
;;;;;VOLID9             DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS9          DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB9         DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK9          DB      -1              ;Last track accessed on this drive
TIM_LO9         DW      -1              ;Keep these two contiguous (?)
TIM_HI9 DW      -1
;------------------------------------------------------------------------------
VOLID9          db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS10           DW      BDS11           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE10:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT10         DW      0               ;Open Ref. Count
;;;;;VOLID10            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS10         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB10        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK10         DB      -1              ;Last track accessed on this drive
TIM_LO10        DW      -1              ;Keep these two contiguous (?)
TIM_HI10        DW      -1
;------------------------------------------------------------------------------
VOLID10         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS11           DW      BDS12           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE11:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT11         DW      0               ;Open Ref. Count
;;;;;VOLID11            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS11         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB11        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK11         DB      -1              ;Last track accessed on this drive
TIM_LO11        DW      -1              ;Keep these two contiguous (?)
TIM_HI11        DW      -1
;------------------------------------------------------------------------------
VOLID11         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS12           DW      BDS13           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE12:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT12         DW      0               ;Open Ref. Count
;;;;;VOLID12            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS12         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB12        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK12         DB      -1              ;Last track accessed on this drive
TIM_LO12        DW      -1              ;Keep these two contiguous (?)
TIM_HI12        DW      -1
;------------------------------------------------------------------------------
VOLID12         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS13           DW      BDS14           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE13:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT13         DW      0               ;Open Ref. Count
;;;;;VOLID13            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS13         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB13        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK13         DB      -1              ;Last track accessed on this drive
TIM_LO13        DW      -1              ;Keep these two contiguous (?)
TIM_HI13        DW      -1
;------------------------------------------------------------------------------
VOLID13         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS14           DW      BDS15           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE14:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT14         DW      0               ;Open Ref. Count
;;;;;VOLID14            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS14         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB14        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK14         DB      -1              ;Last track accessed on this drive
TIM_LO14        DW      -1              ;Keep these two contiguous (?)
TIM_HI14        DW      -1
;------------------------------------------------------------------------------
VOLID14         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS15           DW      BDS16           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE15:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT15         DW      0               ;Open Ref. Count
;;;;;VOLID15            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS15         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB15        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK15         DB      -1              ;Last track accessed on this drive
TIM_LO15        DW      -1              ;Keep these two contiguous (?)
TIM_HI15        DW      -1
;------------------------------------------------------------------------------
VOLID15         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS16           DW      BDS17           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE16:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT16         DW      0               ;Open Ref. Count
;;;;;VOLID16            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS16         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB16        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK16         DB      -1              ;Last track accessed on this drive
TIM_LO16        DW      -1              ;Keep these two contiguous (?)
TIM_HI16        DW      -1
;------------------------------------------------------------------------------
VOLID16         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS17           DW      BDS18           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE17:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT17         DW      0               ;Open Ref. Count
;;;;;VOLID17            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS17         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB17        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK17         DB      -1              ;Last track accessed on this drive
TIM_LO17        DW      -1              ;Keep these two contiguous (?)
TIM_HI17        DW      -1
;------------------------------------------------------------------------------
VOLID17         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS18           DW      BDS19           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE18:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT18         DW      0               ;Open Ref. Count
;;;;;VOLID18            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS18         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB18        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK18         DB      -1              ;Last track accessed on this drive
TIM_LO18        DW      -1              ;Keep these two contiguous (?)
TIM_HI18        DW      -1
;------------------------------------------------------------------------------
VOLID18         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS19           DW      BDS20           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE19:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT19         DW      0               ;Open Ref. Count
;;;;;VOLID19            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS19         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB19        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK19         DB      -1              ;Last track accessed on this drive
TIM_LO19        DW      -1              ;Keep these two contiguous (?)
TIM_HI19        DW      -1
;------------------------------------------------------------------------------
VOLID19         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

Public  bds20
BDS20           DW      BDS21           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE20:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT20         DW      0               ;Open Ref. Count
;;;;;VOLID20            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS20         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB20        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK20         DB      -1              ;Last track accessed on this drive
TIM_LO20        DW      -1              ;Keep these two contiguous (?)
TIM_HI20        DW      -1
;------------------------------------------------------------------------------
VOLID20         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

FREE_16         EQU     2660H-($-BIO2_START)
                DB      FREE_16 DUP(0)

        ORG     2660H
NETRFU          DB      0               ;10-07-85

;--------------------------------------------------------- 88/05/19 --
;************************************************
;*                                              *
;*      VOLUME NAME TABLE                       *
;*                                              *
;************************************************
;
;       EVEN
;VOLTABLE       DB      'NO NAME    ',0         ;0
;               DB      'NO NAME    ',0         ;1
;               DB      'NO NAME    ',0         ;2
;               DB      'NO NAME    ',0         ;3
;               DB      'NO NAME    ',0         ;4
;               DB      'NO NAME    ',0         ;5
;               DB      'NO NAME    ',0         ;6
;               DB      'NO NAME    ',0         ;7
;               DB      'NO NAME    ',0         ;8
;               DB      'NO NAME    ',0         ;9
;               DB      'NO NAME    ',0         ;10
;               DB      'NO NAME    ',0         ;11
;               DB      'NO NAME    ',0         ;12
;               DB      'NO NAME    ',0         ;13
;               DB      'NO NAME    ',0         ;14
;               DB      'NO NAME    ',0         ;15
;               DB      'NO NAME    ',0         ;16
;               DB      'NO NAME    ',0         ;17
;               DB      'NO NAME    ',0         ;18
;               DB      'NO NAME    ',0         ;19
;               DB      'NO NAME    ',0         ;20
;               DB      'NO NAME    ',0         ;21
;               DB      'NO NAME    ',0         ;22
;               DB      'NO NAME    ',0         ;23
;               DB      'NO NAME    ',0         ;24
;               DB      'NO NAME    ',0         ;25
;               DB      'NO NAME    ',0         ;26
;---------------------------------------------------------------------
INP_DEV_TBL     DW      KBIN_DATARTN    ;KEYBOARD INPUT 
                DW      S0IN_DATARTN    ;SERIAL-0 INPUT
                DW      S1IN_DATARTN    ;SERIAL-1 INPUT
                DW      S2IN_DATARTN    ;SERIAL-2 INPUT

INP_STS_TBL     DW      KBSTAT_DATARTN  ;KEYBOARD STATUS
                DW      S0STAT_DATARTN  ;SERIAL-0 STATUS
                DW      S1STAT_DATARTN  ;SERIAL-1 STATUS
                DW      S2STAT_DATARTN  ;SERIAL-2 STATUS

INP_FLS_TBL     DW      KBFLUSH_DATARTN ;KEYBOARD FLUSH
                DW      S0FLUSH_DATARTN ;SERIAL-0 FLUSH
                DW      S1FLUSH_DATARTN ;SERIAL-1 FLUSH
                DW      S2FLUSH_DATARTN ;SERIAL-2 FLUSH

OUT_DEV_TBL     DW      CRTOUT_DATARTN  ;CRT OUTPUT
                DW      PRNOUT_DATARTN  ;PRINTER OUTPUT
                DW      S0OUT_DATARTN   ;SERIAL-0 OUTPUT
                DW      DUMMOUT         ;DUMMY DEVICE OUTPUT
                DW      S1OUT_DATARTN   ;SERIAL-1 OUTPUT
                DW      S2OUT_DATARTN   ;SERIAL-2 OUTPUT

OUT_STS_TBL     DW      CRTRDY_DATARTN  ;CRT STATUS
                DW      PRNRDY_DATARTN  ;PRINTER STATUS
                DW      S0RDY_DATARTN   ;SERIAL-0 STATUS
                DW      DUMMRDY         ;DUMMY DEVICE STATUS
                DW      S1RDY_DATARTN   ;SERIAL-1 STATUS
                DW      S2RDY_DATARTN   ;SERIAL-2 STATUS

OUT_NXT_PTR     DW      0               
OUT_RTN_CNT     DB      0               ;DEVICE COUNTER
STS_SAVE        DW      0               ;STATUS SAVE AREA
S_R8            DB      0               ;SAVE REGISTER8

;----------------------------------------------- DOS5 91/09/09 -------
;SR; WIN386 support
; WIN386 instance data structure
;
;
; Here is a Win386 startup info structure which we set up and to which
; we return a pointer when Win386 initializes.
;

Win386_SI       label   byte            ; Startup Info for Win386
SI_Version      db      3, 0            ; for Win386 3.0
SI_Next         dd      ?               ; pointer to next info structure
                dd      0               ; a field we don't need
                dd      0               ; another field we don't need
SI_Instance     dw      Instance_Table, Bios_Data ; far pointer to instance table

;
; This table gives Win386 the instance data in the BIOS data areas.
;
Instance_Table  label   dword
        dw      00H,DATAGRP             ; IO.SYS work
        dw      0142h                   ; ...142h bytes
        dw      B4670_TABLE,DATAGRP     ; B4670_TABLE, AUXIRIARY_TBL
        dw      95h                     ; ...95H bytes
        dw      KNJ_HEADER,DATAGRP      ; FEP work...
        dw      50h                     ; ... 50h byte
        dw      OUT_NXT_PTR,DATAGRP     ; CON work...
        dw      04h                     ; ... 4 byte
        dw      ESCBUF,DATAGRP          ; ESCBUFFER, FKYBUFFER2
        dw      214h                    ; ... 214h byte
        dw      PRINTER_TABLE,DATAGRP   ; PRN work...
        dw      0Bh                     ; ... 0Bh byte
        dw      FKYTBL,DATAGRP          ; FUNKTION KEY TBL...
;<patch BIOS50-P23>
        dw      54ch                    ; ... 54ch byte DOS5A 92/07/21
;;      dw      348h                    ; ... 348h byte DOS5A 92/07/21
        dw      DSK_DEV,DATAGRP         ; BLOCK DEVICE HEADDFR...
        dw      04h                     ; ... 4 byte
;----------------------------------------------- DOS5 91/09/09 -------
;<patch BIOS50-P04>
        dw      EXT_SAVAX,DATAGRP
        dw      18ch
;----------------------------------------------- DOS5A 92/04/28 ------
;<patch BIOS50-P17>
        dw      KDRV_FLG,DATAGRP        ; NIPPONGO DRIVER FLAG
        dw      1
        dd      0                       ; terminate the instance table
        dw      3*3 dup (0)             ; patch area for instance table
;---------------
;       dd      0                       ; terminate the instance table
;       dw      4*3 dup (0)             ; patch area for instance table
;---------------
;       dd      0                       ; terminate the instance table
;       dw      5*3 dup (0)             ; patch area for instance table
;----------------------------------------------------------------------
;SR;
; Flag to indicate whether Win386 is running or not
;
        public  IsWin386
IsWin386                db      0


instance                struc
instancetype            db      0
reserve                 db      0
instanceoff             dw      ?
instanceseg             dw      ?
instancelength          dw      ?
instance                ends

fix                     struc
fix_datalength          dw      ?
fix_dataptr_l           dw      ?
fix_dataptr_h           dw      ?
fix                     ends

vector                  struc
vector_num              dw      ?
vector                  ends

system                  struc
system_addr             dw      ?
system_datalength       dw      ?
system                  ends

memsw                   struc
memsw_addr              dw      ?
memsw_datalength        dw      ?
memsw                   ends


        extrn   OLD_1A_OFFSET:word, OLD_1B_OFFSET:word, SAVE_INT1B:word

Instance_tbl    label   word
prev_data_off   dw        ?
prev_data_seg   dw        ?
version         db        3,0
Ins_VRAMSEG     instance <0,0,offset VRAMSEG,DATAGRP,2>
                fix      <2,offset Normal_VRAMSEG,DATAGRP>
Ins_SYS_500     instance <2,0,offset SYS_500,DATAGRP,2>
                system   <100h,1>
Ins_SYS_501     system   <101h,1>
Ins_INT1E       instance <1,0,offset INT1E_OFST,DATAGRP,4>
                vector   <1eh>
Ins_MEM_SW3     instance <3,0,offset MEM_SW3,DATAGRP,1>
                memsw    <2,1>
Ins_REVISION    instance <0,0,offset REVISION,DATAGRP,1>
                fix      <1,offset Normal_REVISION,DATAGRP>
Ins_MEM_SW5     instance <3,0,offset MEM_SW5,DATAGRP,3>
                memsw    <4,3>
Ins_LINMOD      instance <0,0,offset LINMOD,DATAGRP,1>
                fix      <1,offset Normal_LINMOD,DATAGRP>
Ins_OLD_1A      instance <1,0,offset BIOS_CODE:OLD_1A_OFFSET,BIOS_CODE,4>
                vector   <1ah>
Ins_OLD_1B      instance <1,0,offset BIOS_CODE:OLD_1B_OFFSET,BIOS_CODE,4>
                vector   <1bh>
end_tbl         dd        -1

                dw      15 dup (0)      ;patch area for instance_tbl


Normal_VRAMSEG          dw      0a000h
Normal_REVISION         db      0f0h
Normal_LINMOD           db      01h
;---------------------------------------------------------------------
FREE_13         EQU     27A6H-($-BIO2_START)
                DB      FREE_13 DUP(0)

        ORG     27A6H
REFCNT          DB      26 DUP (00H)            ;NOT USED 3.3-

MEDIABYT        DB      0
BUSY            DB      0
BYTPSEC         DW      0
SVBPS           DW      0
;
;----------------------------------------------- DOS5 91/01/11 -------
VOLWORK         DB      11 DUP (20H)
                DB      00
;---------------
;VOLWORK                DB      12 DUP (00H)
;---------------------------------------------------------------------
XPORT_FLAG      DB      00000000B       ;60:27D2H
                ;             II
                ;             I+-------- xport loaded
                ;             +--------- printer information
;--------------------------------------------------------- 89/08/08 --
                db      0
                ;for win/386 pointer table
                dw      0               ;reserve
                dw      0               ;reserve
                dw      0               ;reserve
                dw      out_dev_tbl
                dw      out_sts_tbl
                dw      out_nxt_ptr
;---------------------------------------------------------------------
;************************************************
;*                                              *
;*      POINTER FOR TABLES                      *
;*                                              *
;************************************************

FREE_14         EQU     2800H-($-BIO2_START)
                DB      FREE_14 DUP(0)

        ORG     2800H

PTR_CON         DD      CONSOLE_TABLE
PTR_DSK         DD      DISK_TABLE
PTR_CLK         DD      CLOCK_TABLE
PTR_PRN         DD      PRINTER_TABLE
PTR_AUX         DD      AUXILIARY_TABLE
PTR_JPN         DD      JAPAN_TABLE
PTR_BR          DD      B4670_TABLE
PTR_NET         DD      MSNET_TABLE
PTR_TBL         DD      EXLPTBL
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED
                DD      0               ;RESERVED

;************************************************
;*                                              *
;*      MS-NET TABLE                            *
;*                                              *
;************************************************

MSNET_TABLE     LABEL   FAR
                DW      XPORT_FLAG      ;POINTER TO [XPORT_FLAG]

;************************************************
;*                                              *
;*      BUFFERS                                 *
;*                                              *
;************************************************

        PUBLIC  FKY_BUFFER2

ESCBUF  DW      ESCBUFSIZ DUP(?)        ;ESC PARAMETER BUFFER

FKY_BUFFER2     DB      512 DUP(0)      ;FUNC KEY BUFFER (BIG)

;************************************************
;*                                              *
;*      PRINTER DRIVER WORKING AREA             *
;*                                              *
;************************************************

        PUBLIC  PR_HEADER,PR_KNJCNT

                EVEN
PRINTER_TABLE   LABEL   FAR

PR_HEADER       DW      0,0             ;PRINTER DRIVER ADDRESS
BIO2_PRN_WRIT:
                JMP     PRN_WRIT        ;
BIO2_PRN_WRST:
                JMP     PRN_WRST        ;

PR_KNJCNT       DB      0               ;SHIFT JIS COUNT

                DB      0,0,0           ;RESERVED

;************************************************
;*                                              *
;*      HARD DISK INFOMATION                    *
;*                                              *
;************************************************

        PUBLIC  HD_OFFSET,HD1_OFFSET
        PUBLIC  HD_LAST,HD1_LAST
        PUBLIC  HD_NUM,HD1_NUM
        PUBLIC  HDDSK5_1,HDDSK5_2
;--------------------------------------------------------- 88/03/23 --
        PUBLIC  HD2_OFFSET,HD3_OFFSET
        PUBLIC  HD2_LAST,HD3_LAST
        PUBLIC  HD2_NUM,HD3_NUM
        PUBLIC  HDDSK5_3,HDDSK5_4
;---------------------------------------------------------------------

HD_OFFSET       DW      0,0,0,0         ;SASI #0
                DW      0,0,0,0
HD1_OFFSET      DW      0,0,0,0         ;SASI #1
                DW      0,0,0,0
HD2_OFFSET      DW      0,0,0,0         ;SASI #2        88/03/23
                DW      0,0,0,0
HD3_OFFSET      DW      0,0,0,0         ;SASI #3        88/03/23
                DW      0,0,0,0
HD_OF_RFU       DW      0,0,0,0         ;RFU            88/03/23
                DW      0,0,0,0
                DW      0,0,0,0         ;RFU
                DW      0,0,0,0
                                        ;LAST SECTOR OF EACH DOS PART
HD_LAST         DW      0,0,0,0         ;SASI #0
                DW      0,0,0,0
HD1_LAST        DW      0,0,0,0         ;SASI #1
                DW      0,0,0,0
HD2_LAST        DW      0,0,0,0         ;SASI #2        88/03/23
                DW      0,0,0,0
HD3_LAST        DW      0,0,0,0         ;SASI #3        88/03/23
                DW      0,0,0,0
HD_LS_RFU       DW      0,0,0,0         ;RFU            88/03/23
                DW      0,0,0,0
                DW      0,0,0,0         ;RFU
                DW      0,0,0,0

HD_NUM          DB      0               ;NUMBER OF MS-DOS AREA IN SASI #0
HD1_NUM         DB      0               ;NUMBER OF MS-DOS AREA IN SASI #1
HD2_NUM         DB      0               ;NUMBER OF MS-DOS AREA IN SASI #2       88/03/23
HD3_NUM         DB      0               ;NUMBER OF MS-DOS AREA IN SASI #3       88/03/23
HD_NUM_RFU      DB      0               ;RFU            88/03/23
                DB      0               ;RFU

HDDSK5_1        DB      HDDSK_SIZE DUP (0)      ;SASI #0
HDDSK5_2        DB      HDDSK_SIZE DUP (0)      ;SASI #1
HDDSK5_3        DB      HDDSK_SIZE DUP (0)      ;SASI #2
HDDSK5_4        DB      HDDSK_SIZE DUP (0)      ;SASI #3
HDDSK5_RFU      DB      52*2-(HDDSK_SIZE-52)*4 DUP (0)  ;RFU

;************************************************
;*                                              *
;*      DISK DRIVER WORKING AREA                *
;*                                              *
;************************************************

        PUBLIC  EXLPTBL
        PUBLIC  CURUA,CURDA
        PUBLIC  CPV,CPV1,BPS,BPS1,TPC,TPC1,SPT,SPT1
        PUBLIC  DSK_TYP,COM,COM1,LNG_TRNS,CUR_TRNS
        PUBLIC  NO_TRNS,MAX_TRNS,PREFAT,PREFAT8
        PUBLIC  PRVDRV,S_SEC,LNG_SEC,VRFY_FLG
        PUBLIC  RTRY_CNT,RW_SW,SW_HD,SW_5,VOLNUM,CURDA2

;--------------------------------------------------------- 88/03/23 --
        PUBLIC  CPV2,CPV3,BPS2,BPS3,TPC2,TPC3,SPT2,SPT3
;---------------------------------------------------------------------


EXLPTBL         LABEL   FAR
                DW      26 DUP (0)      ;EXTEND LPTABLE

CURUA           DB      0               ;SAVING FIELD OF CURR. UNIT  ADDR
CURDA           DB      0               ;SAVING FIELD OF CURR. DEV.  ADDR

CPV             DW      0               ;CYLINDER PER VOLUME IN DEV SASI #0
CPV1            DW      0               ;CYLINDER PER VOLUME IN DEV SASI #1
CPV2            DW      0               ;CYLINDER PER VOLUME IN DEV SASI #2     88/03/23
CPV3            DW      0               ;CYLINDER PER VOLUME IN DEV SASI #3     88/03/23
                DW      0,0             ;RFU                                    88/03/23
BPS             DW      0               ;BYTE PER SECTOR IN DEV SASI #0
BPS1            DW      0               ;BYTE PER SECTOR IN DEV SASI #1
BPS2            DW      0               ;BYTE PER SECTOR IN DEV SASI #2         88/03/23
BPS3            DW      0               ;BYTE PER SECTOR IN DEV SASI #3         88/03/23
                DW      0,0             ;RFU                                    88/03/23
TPC             DB      0               ;TRACK PER CYLINDER IN DEV SASI #0
TPC1            DB      0               ;TRACK PER CYLINDER IN DEV SASI #1
TPC2            DB      0               ;TRACK PER CYLINDER IN DEV SASI #2      88/03/23
TPC3            DB      0               ;TRACK PER CYLINDER IN DEV SASI #3      88/03/23
                DB      0,0             ;RFU                                    88/03/23
SPT             DB      0               ;SECTOR PER TRACK IN DEV SASI #0
SPT1            DB      0               ;SECTOR PER TRACK IN DEV SASI #1
SPT2            DB      0               ;SECTOR PER TRACK IN DEV SASI #2        88/03/23
SPT3            DB      0               ;SECTOR PER TRACK IN DEV SASI #3        88/03/23
                DB      0,0             ;RFU                                    88/03/23

DSK_TYP         DB      0               ;0 :SINGLE SIDE/1:DOUBLE SIDE
COM             DB      0               ;COMMAND HIGH 4 BITS
COM1            DB      0               ;COMMAND LOW  4 BITS
LNG_TRNS        DW      0               ;NUMBER OF DEMANDING SECTOR FROM UP
CUR_TRNS        DW      0               ;NUMBER OF SECTOR WHICH JUST READ
                                        ;/WRITE.

NO_TRNS         DW      0               ;NUMBER OF NO TRANSFERD SECTOR
MAX_TRNS        DW      0               ;NUMBER OF MAX SECTOR ON TRACK
PREFAT          DB      -5,-5,-5,-5     ;SAVING FIELD OF PREVIOUS FAT ID OF 5"2DD
                                        ;DEF=5"2DD.(8)
PREFAT8         DB      -5,-5,-5,-5     ;SAVING FIELD OF PREVIOUS FAT ID?

PRVDRV          DB      0               ;SAVING FIELD OF PREVIOUS I/O DRIVE NUM
S_SEC           DW      0               ;SAVING FIELD OF SECTOR PER TRAK
                                        ;8"I-128 8"IID-1024 5"FD-512
                                        ;5"FD-8/9
LNG_SEC         DW      0               ;SAVING FIELD OF BYTE PRT SECTOR
                                        ;8"I-128 8"IID-1024
                                        ;5"FD-512
VRFY_FLG        DB      0               ;VERIFY FLAG
RTRY_CNT        DB      0               ;NUMER OF RETRY TIMES
RW_SW           DB      0               ;FLAG TO INDICATE READ/WRITE
SW_HD           DB      0               ;HARD INDICATE FLAG
SW_5            DB      0               ;5"FD INDICATE FLAG
VOLNUM          DB      0               ;SAVING FIELD OF ACCESS AOL NUMBER
CURDA2          DB      0               ;85/03/05

;************************************************
;*                                              *
;*      INIT MODULE WORK                        *
;*                                              *
;************************************************

        PUBLIC  BT_TYP,INF8F,INF5F,INF5H
        PUBLIC  UA,SVPTR,SVPTR1,SVPTR2
        PUBLIC  HD_SPT,HD_LNG,HD_HED

BT_TYP          DB      0               ;BOOT DRIVE SAVING FIELD
INF8F           DB      0               ;EQUIP INF OF 8"FD
INF5F           DB      0               ;EQUIP INF OF 5"FD
INF5H           DB      0               ;EQUIP INF OF 5"HD
UA              DB      0               ;UNIT ADDR SAVING FIELD
SVPTR           DW      0               ;POINTER SAVING FIELD
SVPTR1          DW      0               ;"
SVPTR2          DW      0               ;"
HD_SPT          DB      0               ;NUMBER OF SECTOR PER TRACK ON HD DISK
HD_LNG          DW      0               ;BYTE PER SECTOR ON HD DISK
HD_HED          DB      0               ;NUMBER OF HEAD PER CYLINDER

;************************************************
;*                                              *
;*      TIMER WORK AREA                         *
;*                                              *
;************************************************

        PUBLIC  CAL_TBL
        PUBLIC  T_YEAR,T_MONTH,T_DAY,T_HOUR,T_MIN,T_SEC
        PUBLIC  MONTH_TBL,YEAR,MONTH,DAY

CLOCK_TABLE     LABEL   FAR

CAL_TBL EQU     $
T_YEAR          DB      0
T_MONTH         DB      0
T_DAY           DB      0
T_HOUR          DB      0
T_MIN           DB      0
T_SEC           DB      0
MONTH_TBL       DB      31,28,31,30,31,30
                DB      31,31,30,31,30,31
YEAR            DW      0
MONTH           DW      0
DAY             DW      0
                DW      0,0,0,0                 ;RFU



        PUBLIC  FKYTBL,FKYTBL2,KBCODTBL
        PUBLIC  CTRLNFER,CTRLXFER,CTRLFKY
        PUBLIC  BUFSIZE,CHRTBL
;
;************************************************
;*      FUNCTION KEY TABLE                      *
;*                      ( DEFAULT VALUE )       *
;************************************************
;
FKYTBL  DB      8,0FEH,' C1  ',1BH,'S',0,0,0,0,0,0,0    ;FNC 1
        DB      8,0FEH,' CU  ',1BH,'T',0,0,0,0,0,0,0    ;FNC 2
        DB      8,0FEH,' CA  ',1BH,'U',0,0,0,0,0,0,0    ;FNC 3
        DB      8,0FEH,' S1  ',1BH,'V',0,0,0,0,0,0,0    ;FNC 4
        DB      8,0FEH,' SU  ',1BH,'W',0,0,0,0,0,0,0    ;FNC 5
        DB      8,0FEH,'VOID ',1BH,'E',0,0,0,0,0,0,0    ;FNC 6
        DB      8,0FEH,'NWL  ',1BH,'J',0,0,0,0,0,0,0    ;FNC 7
        DB      8,0FEH,'INS  ',1BH,'P',0,0,0,0,0,0,0    ;FNC 8
        DB      8,0FEH,'REP  ',1BH,'Q',0,0,0,0,0,0,0    ;FNC 9
        DB      8,0FEH,' ^Z  ',1BH,'Z',0,0,0,0,0,0,0    ;FNC 10
;
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;FNC 11
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;FNC 12
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;FNC 13
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;FNC 14
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;FNC 15
;
FKYTBL2 DB      7,'dir a:',13,0,0,0,0,0,0,0,0           ;SHFT F.1
        DB      7,'dir b:',13,0,0,0,0,0,0,0,0           ;SHFT F.2
        DB      5,'copy ',0,0,0,0,0,0,0,0,0,0           ;SHFT F.3
        DB      4,'del ',0,0,0,0,0,0,0,0,0,0,0          ;SHFT F.4
        DB      4,'ren ',0,0,0,0,0,0,0,0,0,0,0          ;SHFT F.5
        DB      10,'chkdsk a:',13,0,0,0,0,0             ;SHFT F.6
        DB      10,'chkdsk b:',13,0,0,0,0,0             ;SHFT F.7
        DB      5,'type ',0,0,0,0,0,0,0,0,0,0           ;SHFT F.8
        DB      5,'date',13,0,0,0,0,0,0,0,0,0,0         ;SHFT F.9
        DB      5,'time',13,0,0,0,0,0,0,0,0,0,0         ;SHFT F.10
;
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;SHFT F.11
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;SHFT F.12
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;SHFT F.13
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;SHFT F.14
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;SHFT F.15

KBCODTBL        EQU     $
        DB      0,0,0,0,0,0,0,0                 ;ROLL UP
        DB      0,0,0,0,0,0,0,0                 ;ROLL DOWN
        DB      2,1BH,'P',0,0,0,0,0             ;INS
        DB      2,1BH,'D',0,0,0,0,0             ;DEL
        DB      1,0BH,0,0,0,0,0,0               ;^
        DB      1,08H,0,0,0,0,0,0               ;<-
        DB      1,0CH,0,0,0,0,0,0               ;->
        DB      1,0AH,0,0,0,0,0,0               ;V
        DB      1,1AH,0,0,0,0,0,0               ;CLEAR
        DB      0,0,0,0,0,0,0,0                 ;HELP
        DB      1,1EH,0,0,0,0,0,0               ;HOME
;
CTRLNFER        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CTRLXFER        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
;
;       CONTROL + FUNCTION KEY TABLE
;
;
CTRLFKY DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.1
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.2
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.3
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.4
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.5
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.6
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.7
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.8
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.9
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.10
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.11
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.12
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.13
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.14
        DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0         ;CTRL + F.15

;************************************************
;*      KEYBOARD REASSIGNMENT TABLE             NEW
;************************************************
BUFSIZE DW      0                       ;BUFFER ENTRY SIZE FOR INT220
CHRTBL          DW      0               ;ENTRY COUNTER
                DB      512 DUP (0)     ;DATA KEY REASSIGN TABLE

;************************************************ 871015 NEW
;*                                              *
;*      SIGNON MESSAGE & COPYRIGHT              *
;*                                              *
;************************************************

        PUBLIC  TITLE_M

;----------------------------------------------- DOS5A 92/04/15 -------
;TITLE_M DB     'NEC PC-9800 ذ ߰ ߭',13,10,10
;       DB      'ϲۿ MS-DOS ްޮ 5.00  ',13,10
;       DB      'Copyright (C) 1981,1991 Microsoft Corp. '
;       DB      '/ NEC Corporation ',13,10
;---------------
;<patch BIOS50-P13>
;TITLE_M DB     'NEC PC-9800 ذ ߰ ߭',13,10,10
;       DB      'ϲۿ MS-DOS ްޮ 5.00A ',13,10
;       DB      'Copyright (C) 1981,1991 Microsoft Corp. '
;       DB      '/ NEC Corporation ',13,10
;---------------
;<patch BIOS50-P28>
TITLE_M DB      'NEC PC-9800 ذ ߰ ߭',13,10,10
        DB      'ϲۿ MS-DOS ްޮ 5.00A     ',13,10
        DB      'Copyright (C) 1981,1992 Microsoft Corp. '
        DB      '/ NEC Corporation ',13,10
;----------------------------------------------------------------------

DATA_END LABEL NEAR

        PAGE
;****************************************************************
;*                                                              *
;*      DISPATCH TABLE FOR DEVICE                               *
;*                                                              *
;****************************************************************
        ORG     3300h
        DB      0

CON_TBL:
        DB      16
        DW      EXIT                    ;0-INIT(NOT USED)
        DW      EXIT                    ;1-MEDIA CHECK(NOT USED)
        DW      EXIT                    ;2-GET BPB(NOT USED)
        DW      CMD_ERR                 ;3-IO CTRL INPUT
        DW      CON_READ                ;4-DESTRUCTIVE READ
        DW      CON_RDND                ;5-NON DESTRUCTIVE READ
        DW      EXIT                    ;6-INPUT STATUS
        DW      CON_FLSH                ;7-FLUSH INPUT BUFFER
        DW      CON_WRIT                ;8-WRITE
        DW      CON_WRIT                ;9-WRITE & VERIFY
        DW      CON_WRST                ;10-WRITE STATUS
        DW      EXIT                    ;11-OUTPUT STATUS
        DW      EXIT                    ;12-IO CTRL OUTPUT

        DW      EXIT                    ;13-DEVICE OPEN(NOT USED)
        DW      EXIT                    ;14-DEVICE CLOSE(NOT USED)
        DW      EXIT                    ;15-REMOVABLE MEDIA(NOT USED)
        DW      EXIT                    ;16-OUT TIL BUSY(NOT USED)

;----------------------------------------------------------870826----------
PRN_TBL:
        DB      16
        DW      EXIT                    ;0-INIT(NOT USED)
        DW      EXIT                    ;1-MEDIA CHECK(NOT USED)
        DW      EXIT                    ;2-GET BPB(NOT USED)
        DW      CMD_ERR                 ;3-IO CTRL INPUT
        DW      EXIT                    ;4-DESTRUCTIVE READ
        DW      BUS_EXIT                ;5-NON DESTRUCTIVE READ
        DW      EXIT                    ;6-INPUT STATUS
        DW      EXIT                    ;7-FLUSH INPUT BUFFER
        DW      PRN_WRIT_DUM            ;8-WRITE
        DW      PRN_WRIT_DUM            ;9-WRITE & VERIFY
        DW      PRN_WRST_DUM            ;10-WRITE STATUS
        DW      EXIT                    ;11-OUTPUT STATUS
        DW      EXIT                    ;12-IO CTRL OUTPUT

        DW      EXIT                    ;13-DEVICE OPEN(NOT USED)
        DW      EXIT                    ;14-DEVICE CLOSE(NOT USED)
        DW      EXIT                    ;15-REMOVABLE MEDIA(NOT USED)
        DW      EXIT                    ;16-OUT TIL BUSY(NOT USED)

AUX_TBL:
        DB      16
        DW      EXIT                    ;0-INIT(NOT USED)
        DW      EXIT                    ;1-MEDIA CHECK(NOT USED)
        DW      EXIT                    ;2-GET BPB(NOT USED)
        DW      CMD_ERR                 ;3-IO CTRL INPUT
        DW      AUX_READ_DUM            ;4-DESTRUCTIVE READ
        DW      AUX_RDND_DUM            ;5-NON DESTRUCTIVE READ
        DW      EXIT                    ;6-INPUT STATUS
        DW      AUX_FLSH_DUM            ;7-FLUSH INPUT BUFFER
        DW      AUX_WRIT_DUM            ;8-WRITE
        DW      AUX_WRIT_DUM            ;9-WRITE & VERIFY
        DW      AUX_WRST_DUM            ;10-WRITE STATUS
        DW      EXIT                    ;11-OUTPUT STATUS
        DW      EXIT                    ;12-IO CTRL OUTPUT

        DW      EXIT                    ;13-DEVICE OPEN(NOT USED)
        DW      EXIT                    ;14-DEVICE CLOSE(NOT USED)
        DW      EXIT                    ;15-REMOVABLE MEDIA(NOT USED)
        DW      EXIT                    ;16-OUT TIL BUSY(NOT USED)
;-------------------------------------------------------------------------

CLK_TBL:
        DB      16
        DW      EXIT
        DW      EXIT
        DW      EXIT
        DW      CMD_ERR
        DW      CLK_READ
        DW      BUS_EXIT
        DW      EXIT
        DW      EXIT
        DW      CLK_WRIT
        DW      CLK_WRIT
        DW      EXIT
        DW      EXIT
        DW      EXIT
 
        DW      EXIT
        DW      EXIT
        DW      EXIT
        DW      EXIT

DSK_TBL:
        DB      25
        DW      DSK_INIT        
        DW      MEDIA_CHK
        DW      GET_BPB
        DW      CMD_ERR
        DW      DSK_READ
        DW      BUS_EXIT
        DW      EXIT
        DW      EXIT
        DW      DSK_WRIT
        DW      DSK_WRTV
        DW      EXIT
        DW      EXIT
        DW      EXIT
        DW      DSK_OPEN        ;DEVICE OPEN
        DW      DSK_CLOSE       ;DEVICE CLOSE
        DW      DSK_REMOVABLE   ;REMOVABLE CHECK
        DW      EXIT

        DW      EXIT
        DW      EXIT
        DW      Generic$IOCTL
        DW      EXIT
        DW      EXIT
        DW      EXIT
        DW      IOCTL$GetOwn
        DW      IOCTL$SetOwn
        DW      IOCTL_SUPPORT_QUERY

FREE_15         EQU     3400H-($-BIO2_START)
                DB      FREE_15 DUP(0)

        PAGE
;****************************************************************
;*                                                              *
;*      DEVICE TABLES                                           *
;*                                                              *
;****************************************************************

        ORG     3400H
DEV_TBL LABEL   WORD

CON_DEV:
        DW      PRN_DEV,BIOSSEG                 ;LINK TO NEXT DEVICE
        DW      8013H                           ;ATTRIBUTE (CHR.I/O)
;              +-------------------------------INT 29H SUPPORT
        DW      STRATEGY                        ;STRATEGY ENTRY POINT
        DW      CON_INT                         ;INTERRUPT ENTRY POINT
        DB      'CON     '                      ;DEVICE NAME

;------------------------------------------------ 870826 DUMMY DEV ---------
PRN_DEV:
        DW      AUX_DEV,BIOSSEG                 ;LINK TO NEXT DEVICE
        DW      8000H                           ;ATTRIBUTE (CHR.I/O)
        DW      STRATEGY                        ;STRATEGY ENTRY POINT
        DW      PRN_INT                         ;INTERRUPT ENTRY POINT
        DB      'PRN     '                      ;DEVICE NAME

AUX_DEV:
        DW      CLK_DEV,BIOSSEG                 ;LINK TO NEXT DEVICE
        DW      8000H                           ;ATTRIBUTE (CHR.I/O)
        DW      STRATEGY                        ;STRATEGY ENTRY POINT
        DW      AUX_INT                         ;INTERRUPT ENTRY POINT
        DB      'AUX     '                      ;DEVICE NAME
;-----------------------------------------------------------------------

CLK_DEV:
        DW      DSK_DEV,BIOSSEG
        DW      8008H
        DW      STRATEGY
        DW      CLK_INT
        DB      'CLOCK$  '

DSK_DEV:
        DD      -1
;-------------------------------------------------------DOS5 90/12/14----
;       DW      4840H                   ;OPEN/CLOSE/RM BIT ON
                                        ;13-NON IBM, 11-OPEN/CLOSE/RM
                                        ;14-IOCTL 
                                        ;6 -VER3.3
;------------------
        DW      48C2H                   ;1 32 BIT SECTOR SUPPORT
                                        ;7 IOCTL SUPPORT QUERY
;------------------------------------------------------------------------
        DW      STRATEGY
        DW      DSK_INT
DRV_NUM DB      1

        PAGE
;************************************************
;*                                              *
;*      VARIABLE & DEVICE ASSIGN TABLE          *
;*                                              *
;************************************************
        EVEN

PTRSAV  DD      0               ;STRATEGY POINTER SAVE AREA

;****************************************************************
;*                                                              *
;*      STRATEGY ROUTINE                                        *
;*                                                              *
;****************************************************************
;
STRTUP          PROC    FAR
STRATEGY:
        MOV     WORD PTR CS:[PTRSAV],BX
        MOV     WORD PTR CS:[PTRSAV+2],ES
        RET
STRTUP          ENDP

;
;       OUTER DRIVER PROCESS
;
PRNOUT_DATARTN  PROC NEAR
        CALL    DWORD PTR CS:[PRNOUT_CODERTN]
        RET
PRNOUT_DATARTN  ENDP

PRNRDY_DATARTN  PROC NEAR
        CALL    DWORD PTR CS:[PRNRDY_CODERTN]
        RET
PRNRDY_DATARTN  ENDP

;
;       INTERRUPT ROUTINE
;
CON_INT:
        PUSH    SI
        MOV     SI,OFFSET CON_TBL
        JMP     SHORT ENTRY

;---------------------------------------------------------870826----------
PRN_INT:
        PUSH    SI
        MOV     SI,OFFSET PRN_TBL       ;SET DISPATCH TABLE ADDR.
        JMP     SHORT ENTRY             ;JUMP TO COMMON ROUTINE

AUX_INT:
        PUSH    SI
        MOV     SI,OFFSET AUX_TBL       ;SET DISPATCH TABLE ADDR.
        JMP     SHORT ENTRY
;-------------------------------------------------------------------------

CLK_INT:
        PUSH    SI
        MOV     SI,OFFSET CLK_TBL
        JMP     SHORT ENTRY

DSK_INT:
        PUSH    SI
        MOV     SI,OFFSET DSK_TBL

;************************************************
;*                                              *
;*      COMMON ROUTINE FOR INTERRUPT            *
;*                                              *
;************************************************

ENTRY:
        PUSH    AX
        PUSH    CX
        PUSH    DX
        PUSH    DI
        PUSH    BP
        PUSH    DS
        PUSH    ES
        PUSH    BX              ;SAVE ALL REGISTER
        LDS     BX,CS:[PTRSAV]  ;RETRIEVE POINTER(DS:BX)
        MOV     AL,[BX.UNIT]    ;GET UNIT
        MOV     AH,[BX.MEDIA]   ;GET MEDIA
        MOV     CX,[BX.COUNT]   ;GET BYTE/SECTOR COUNT
        MOV     DX,[BX.START]   ;GET LOGICAL SECTOR
;----------------------------------------------- DOS5 90/12/14 -------
        CMP     SI,OFFSET DSK_TBL       ;COMMAND TO DISK?
        JNE     NOT_LARGE_SECTOR
        MOV     CS:START_SEC_H,0
        CMP     [BX.START],-1           ;LARGE PARTITION?
        JNE     NOT_LARGE_SECTOR
        MOV     DX,[BX.START_H]
        MOV     CS:START_SEC_H,DX
        MOV     DX,[BX.START_L]
NOT_LARGE_SECTOR:
;---------------------------------------------------------------------
        XCHG    AX,DI           ;SAVE AX
        MOV     AL,[BX.CMD]     ;GET COMMAND
;--------------------------------------------------------- 88/05/31 --
        CMP     AL,CS:[SI]
        JA      CMD_ERR
;---------------------------------------------------------------------
        XOR     AH,AH
        ADD     SI,AX
        ADD     SI,AX
;--------------------------------------------------------- 88/05/31 --
;       CMP     AL,16           ;DOS 3.XX (0-16)
;       JA      CMD_ERR
;---------------------------------------------------------------------

        XCHG    AX,DI           ;RESTORE AX
        LES     DI,[BX.TRANS]   ;GET I/O BUFFER ADDR(ES:DI)
        PUSH    CS
        POP     DS
        JMP     [SI+1]          ;PERFORM I/O PACKET COMMAND

        PAGE

;
;       BUSY EXIT
;
BUS_EXIT:
        MOV     AH,00000011B            ;SET BUSY& DONE BITS
        JMP     SHORT EXIT1

;
;       COMMAND ERROR
;
CMD_ERR:
        MOV     AL,3                    ;SET UNKNOWM COMMAND ERROR
;
;       EREROR EXIT
;
ERR_EXIT:
        MOV     AH,10000001B            ;SET ERROR & DONE BITS
        JMP     SHORT EXIT1

;
;       NORMAL EXIT
;
EXITRTN PROC    FAR
EXIT:
        MOV     AH,00000001B            ;SET DONE BIT
EXIT1:
EXITRF:
        LDS     BX,CS:[PTRSAV]
        MOV     [BX.STATUS],AX
        POP     BX
        POP     ES
        POP     DS
        POP     BP
        POP     DI
        POP     DX
        POP     CX
        POP     AX
        POP     SI
        RET                             ;FAR RETURN

EXITRTN ENDP


        PAGE

;********************************************************
; MS-DOS 5.0                                            *
;   CODE SEGMENT JUMP ROUTINE                           *
;********************************************************
;
;       KEYBOARD ROUTINE
;
KBIN_DATARTN    PROC NEAR
        CALL    DWORD PTR CS:[KBIN_CODERTN]
        RET
KBIN_DATARTN    ENDP

KBSTAT_DATARTN  PROC NEAR
        CALL    DWORD PTR CS:[KBSTAT_CODERTN]
        RET
KBSTAT_DATARTN  ENDP

KBFLUSH_DATARTN PROC NEAR
        CALL    DWORD PTR CS:[KBFLUSH_CODERTN]
        RET
KBFLUSH_DATARTN ENDP

;
;       CONSOLE ROUTINE
;

CRTOUT_DATARTN  PROC NEAR
        CALL    DWORD PTR CS:[CRTOUT_CODERTN]
        RET
CRTOUT_DATARTN  ENDP

CRTRDY_DATARTN  PROC NEAR
        CALL    DWORD PTR CS:[CRTRDY_CODERTN]
        RET
CRTRDY_DATARTN  ENDP

;
;       S0 ROUTINE
;

S0IN_DATARTN    PROC NEAR
        CALL    DWORD PTR CS:[S0IN_CODERTN]
        RET
S0IN_DATARTN    ENDP

S0STAT_DATARTN  PROC NEAR
        CALL    DWORD PTR CS:[S0STAT_CODERTN]
        RET
S0STAT_DATARTN  ENDP

S0FLUSH_DATARTN PROC NEAR
        CALL    DWORD PTR CS:[S0FLUSH_CODERTN]
        RET
S0FLUSH_DATARTN ENDP

S0OUT_DATARTN   PROC NEAR
        CALL    DWORD PTR CS:[S0OUT_CODERTN]
        RET
S0OUT_DATARTN   ENDP

S0RDY_DATARTN   PROC NEAR
        CALL    DWORD PTR CS:[S0RDY_CODERTN]
        RET
S0RDY_DATARTN   ENDP

;
;       S1 ROUTINE
;

S1IN_DATARTN    PROC NEAR
        CALL    DWORD PTR CS:[S1IN_CODERTN]
        RET
S1IN_DATARTN    ENDP

S1STAT_DATARTN  PROC NEAR
        CALL    DWORD PTR CS:[S1STAT_CODERTN]
        RET
S1STAT_DATARTN  ENDP

S1FLUSH_DATARTN PROC NEAR
        CALL    DWORD PTR CS:[S1FLUSH_CODERTN]
        RET
S1FLUSH_DATARTN ENDP

S1OUT_DATARTN   PROC NEAR
        CALL    DWORD PTR CS:[S1OUT_CODERTN]
        RET
S1OUT_DATARTN   ENDP

S1RDY_DATARTN   PROC NEAR
        CALL    DWORD PTR CS:[S1RDY_CODERTN]
        RET
S1RDY_DATARTN   ENDP

;
;       S2 ROUTINE
;

S2IN_DATARTN    PROC NEAR
        CALL    DWORD PTR CS:[S2IN_CODERTN]
        RET
S2IN_DATARTN    ENDP

S2STAT_DATARTN  PROC NEAR
        CALL    DWORD PTR CS:[S2STAT_CODERTN]
        RET
S2STAT_DATARTN  ENDP

S2FLUSH_DATARTN PROC NEAR
        CALL    DWORD PTR CS:[S2FLUSH_CODERTN]
        RET
S2FLUSH_DATARTN ENDP

S2OUT_DATARTN   PROC NEAR
        CALL    DWORD PTR CS:[S2OUT_CODERTN]
        RET
S2OUT_DATARTN   ENDP

S2RDY_DATARTN   PROC NEAR
        CALL    DWORD PTR CS:[S2RDY_CODERTN]
        RET
S2RDY_DATARTN   ENDP

HEXCHK_DATARTN  PROC NEAR
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    DWORD PTR CS:[HEXCHK_RTN]
        RET
HEXCHK_DATARTN  ENDP

D_MCONV_DATARTN PROC NEAR
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    DWORD PTR CS:[D_MCONV_RTN]
        RET
D_MCONV_DATARTN ENDP

BELRTN_DATARTN  PROC NEAR
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    DWORD PTR CS:[BELRTN_RTN]
        RET
BELRTN_DATARTN  ENDP

DSK_INIT:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[DSK_INIT_DATARTN]

MEDIA_CHK:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[MEDIA_CHK_DATARTN]

GET_BPB:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[GET_BPB_DATARTN]

DSK_READ:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[DSK_READ_DATARTN]

DSK_WRIT:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[DSK_WRIT_DATARTN]

DSK_WRTV:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[DSK_WRTV_DATARTN]

DSK_OPEN:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[DSK_OPEN_DATARTN]

DSK_CLOSE:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[DSK_CLOSE_DATARTN]

DSK_REMOVABLE:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[DSK_REMOVABLE_DATARTN]

Generic$IOCTL:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[Generic$IOCTL_DATARTN]

IOCTL$GetOwn:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[IOCTL$GetOwn_DATARTN]

IOCTL$SetOwn:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[IOCTL$SetOwn_DATARTN]

;--------------------------------------------------------- DOS5 91/02/22 --
IOCTL_SUPPORT_QUERY:
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
        JMP     DWORD PTR CS:[IOCTL_SUPPORT_QUERY_DATARTN]
;--------------------------------------------------------------------------

INT_TRAP:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[INT_TRAP_DATA]

COPY_INT:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[COPY_INT_DATA]

STOP_INT:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[STOP_INT_DATA]

INT_29:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[INT_29_DATA]

EXTBIOS:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[EXTBIOS_DATA]

HD_ENTI:
        TEST    AL,10H          ;TARGET 5"HD ?
        JNZ     SKIP_FD         ;                               89/07/28
        TEST    AL,60H          ;                               89/07/28
        JZ      TRG_5HD         ;JUMP IF 5"HD
SKIP_FD:                        ;                               89/07/28
        JMP     DWORD PTR CS:[INT1B_OFST]
TRG_5HD:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[HD_ENTI_DATA]

EXFNC_START:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[EXFNC_START_DATA]

CRTBIOS_START:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[CRTBIOS_START_DATA]

NEW_1A_ENT:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[NEW_1A_ENT_DATA]

INT_1CH:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[INT_1CH_DATA]

TIM_INT:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[TIM_INT_DATA]

NEW_1B_INT:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR CS:[NEW_1B_INT_DATA]

RE_INIT         PROC    FAR
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     CS:inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    DWORD PTR CS:[REINIT_DATA_RTN]
        RETF
RE_INIT         ENDP

;
;This routine was originally in BIOS_CODE but this causes a lot of problems
;when we call it including checking of A20. The code being only about 
;30 bytes, we might as well put it in BIOS_DATA
;
PUBLIC  V86_Crit_SetFocus

V86_Crit_SetFocus       PROC    FAR

                        push    di
                        push    es
                        push    bx
                        push    ax

                        xor     di,di
                        mov     es,di
                        mov     bx,0015h        ;Device ID of DOSMGR device
                        mov     ax,1684h        ;Get API entry point
                        int     2fh
                        mov     ax,es
                        or      ax,di           
                        jz      Skip
;
;Here, es:di is address of API routine. Set up stack frame to simulate a call
;
                        push    cs              ;push return segment
                        mov     ax,OFFSET Skip
                        push    ax              ;push return offset
                        push    es
                        push    di              ;API far call address
                        mov     ax,1            ;SetFocus function number
                        retf                    ;do the call
Skip:
                        pop     ax
                        pop     bx
                        pop     es
                        pop     di
                        ret
V86_Crit_SetFocus       ENDP

;
;End WIN386 support
;

;
; int 2f handler for external block drivers to communicate with the internal
; block driver in msdisk. the multiplex number chosen is 8. the handler
; sets up the pointer to the request packet in [ptrsav] and then jumps to
; dsk_entry, the entry point for all disk requests.
;
; on exit from this driver, we will return to the external driver
; that issued this int 2f, and can then remove the flags from the stack.
; this scheme allows us to have a small external device driver, and makes
; the maintainance of the various drivers (driver and msbio) much easier,
; since we only need to make changes in one place (most of the time).
;
;   ax=800h - check for installed handler - reserved
;   ax=801h - install the bds into the linked list
;   ax=802h - dos request
;   ax=803h - return bds table starting pointer in ds:di
;          (ems device driver hooks int 13h to handle 16kb dma overrun
;           problem.  bds table is going to be used to get head/sector
;           informations without calling generic ioctl get device parm call.)

;
;   ax=167fh - win3.0a support
;
;   ax=4b05h - DOSSHELL support
;

MULTWIN386              equ     16h
Win386_Init             equ     05h
Win386_Exit             equ     06h
Win386_NH               equ     7fh
multMULT                equ     4ah
multMULTGETHMAPTR       equ     1
multMULTALLOCHMA        equ     2

i2f_handler PROC        FAR

int_2f:
        cmp     ah,8
;93/03/25 MVDM DOS5.0A---------------------------
        jz      i2f_iret
;------------------------------------------------

;
;Check for WIN386 startup and return the BIOS instance data
;
        cmp     ah,MULTWIN386
        jz      win386call

        cmp     ah, multMULT
;----------------------------------------------- DOS5A 92/04/08 ------
;<patch BIOS50-P15>
        jmp     i2f_patch
        db      90h,90h
;---------------
;       jne     i2f_iret
;       jmp     handle_multmult
;---------------------------------------------------------------------
i2f_iret:
        iret


mine:
        assume  ds:nothing
        cmp     al,0f8h                 ; iret on reserved functions
        jae     i2f_iret
        or      al,al                   ; a get installed state request?
        jnz     disp_func
        mov     al,0ffh
        jmp     i2f_iret

disp_func:
        cmp     al,1                    ; request for installing bds?
        jz      do_subfun_01
        cmp     al,3                    ; get bds vector?
        jz      do_get_bds_vector

; set up pointer to request packet

        push    ds
        PUSH    CS
        POP     DS                      ; ds: -> Bios_Data
        assume  ds:Bios_Data

        mov     word ptr [ptrsav],bx    ;otherwise dos function.
        mov     word ptr [ptrsav+2],es
        pop     ds
        assume  ds:nothing
        jmp     DSK_INT                 ; NOTE:  jump to a function, not an
;                                       ;  IRET type function.  Callers of
;                                       ;  this int2f subfunction will have
;                                       ;  to be careful to do a popf

do_subfun_01:
        assume  ds:nothing
        push    es                      ; save caller's ds, es
        push    ds

        push    ds                      ; put his argument into es
        pop     es

        PUSH    CS
        POP     DS                      ; point ds: -> Bios_Data
        assume  ds:Bios_Data

        call    install_bds

        pop     ds                      ; restore caller's registers
        assume  ds:nothing
        pop     es
        jmp     i2f_iret


do_get_bds_vector:                      ; al=3
        assume  ds:nothing
        PUSH    CS
        POP     DS                      ;we are in bios_data
        assume  ds:Bios_Data

        lds     di,[start_bds]
        assume  ds:nothing
ii2f_iret:
        jmp     i2f_iret

;------------------------------------------------------ DOS5 91/09/09 -
;
;WIN386 startup stuff is done here. If starting up we set our WIN386 present
;flag and return instance data. If exiting, we reset the WIN386 present flag
;NOTE: We assume that the BIOS int 2fh is at the bottom of the chain.

win386call:
        push    ds
        push    cs
        pop     ds
        assume  ds:Bios_Data

        cmp     al, Win386_Init         ; is it win386 initializing?
        je      Win386Init
        cmp     al, Win386_Exit         ; is it win386 exiting?
        je      win386Exit              ; if not, continue int2f chain

        cmp     al,Win386_NH            ;NEC
        jne     win_iret                ;NEC
        cmp     dx,0                    ;NEC
        jne     win_iret                ;NEC
        jmp     short set_instance      ;NEC

Win386Exit:
        test    dx, 1                   ; is it win386 or win286 dos extender?
        jnz     win_iret                ; if not win386, then continue
        and     [IsWin386], 0           ; indicate that win386 is not present
        jmp     short win_iret

Win386Init:
        test    dx, 1                   ; is it win386 or win286 dos extender?
        jnz     win_iret                ; if not win386, then continue

        or      [IsWin386], 1           ; Indicate WIN386 present
        mov     word ptr [SI_Next], bx  ; Hook our structure into chain
        mov     word ptr [SI_Next + 2], es
        mov     bx, offset Win386_SI    ; point ES:BX to Win386_SI
        push    ds
        pop     es

win_iret:
        pop     ds
        assume  ds:nothing
        jmp     short i2f_iret          ;return back up the chain
;
; NEC Win386 suppurt
;
        assume  ds:Bios_Data
set_instance:
        mov     prev_data_off,bx
        mov     bx,es
        mov     prev_data_seg,bx
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P07>
        jmp     short not_27board
        db      3 dup (90h)
;---------------
;       test    EXFNC_FLG,02h
;---------------------------------------------------------------------
        jz      not_27board
        mov     word ptr Ins_OLD_1B.instanceoff,offset BIOS_CODE:SAVE_INT1B
not_27board:
        mov     bx,BIOS_SEG
        mov     word ptr Ins_OLD_1B.instanceseg,bx
        mov     word ptr Ins_OLD_1A.instanceseg,bx
        push    cs
        pop     es
        mov     bx,offset instance_tbl
;------------------------------------------------------------------------------
;<patch BIOS50-P03>
        jmp     win_iret
        db      90h
;       jmp     i2f_iret
;------------------------------------------------------------------------------

handle_multmult:
        cmp     al, multMULTGETHMAPTR
        jne     try_2

        push    ds
        call    HMAPtr                  ; get offset of free HMA
        mov     bx, 0ffffh
        mov     es, bx                  ; seg of HMA
        mov     bx, di
        not     bx
        or      bx, bx
        jz      @f
        inc     bx
@@:
        pop     ds
        jmp     ii2f_iret
try_2:
        cmp     al, multMULTALLOCHMA
        jne     try_3

        push    ds
        mov     di, 0ffffh              ; assume not enough space
        mov     es, di
        call    HMAPtr                  ; get offset of free HMA
        assume  ds:Bios_Data
        cmp     di, 0ffffh
        je      InsuffHMA               
        neg     di                      ; free space in HMA
        cmp     bx, di
        jbe     @f
        mov     di, 0ffffh
        jmp     short InsuffHMA
@@:
        mov     di, FreeHMAPtr
        add     bx, 15
        and     bx, 0fff0h
        add     FreeHMAPtr, bx          ; update the free pointer
        jnz     InsuffHMA
        mov     FreeHMAPtr, 0ffffh      ; no more HMA if we have wrapped
InsuffHMA:
        pop     ds
        assume  ds:nothing
        jmp     ii2f_iret
try_3:
        jmp     ii2f_iret


i2f_handler endp


; install_bes installs a bds at location ds:di into the current linked list of
; bds maintained by this device driver. it places the bds at the end of the
; list.  Trashes (at least) ax, bx, di, si

install_bds     proc    near
        assume  ds:Bios_Data,es:nothing

        push    ds                      ; save Bios_Data segment
        mov     si,offset start_bds     ; beginning of chain

;       ds:si now points to link to first bds
;         assume bds list is non-empty

loop_next_bds:
        lds     si,[si].bds_link        ; fetch next bds
        mov     al,es:[di].bds_drivenum ; does this one share a physical
        cmp     [si].bds_drivenum,al    ;  drive with new one?
        jnz     next_bds

        mov     bl,fi_am_mult           ; set both of them to i_am_mult if so
        or      byte ptr es:[di].bds_flags,bl
        or      byte ptr [si].bds_flags,bl
        and     byte ptr es:[di].bds_flags,not fi_own_physical ; we don't own it

        mov     bl,byte ptr [si].bds_flags      ; determine if changeline available
        and     bl,fchangeline
        or      byte ptr es:[di].bds_flags,bl

next_bds:
        cmp     word ptr [si].bds_link,-1       ; are we at end of list?
        jnz     loop_next_bds

        mov     word ptr [si].bds_link+2,es ; install bds
        mov     word ptr [si].bds_link,di
        mov     word ptr es:[di].bds_link,-1    ; set next pointer to null
        pop     ds                      ; restore Bios_Data
        ret

install_bds endp

;
;--------------------------------------------------------------------------
;
; procedure : HMAPtr
;
;               Gets the offset of the free HMA area ( with respect to
;                                                       seg ffff )
;               If DOS has not moved high, tries to move DOS high.
;               In the course of doing this, it will allocate all the HMA
;               and set the FreeHMAPtr to past the end of the BIOS and 
;               DOS code.  The call to MoveDOSIntoHMA (which is a pointer)
;               enters the routine in sysinit1 called FTryToMoveDOSHi.
;
;       RETURNS : offset of free HMA in DI
;                 BIOS_DATA, seg in DS
;
;--------------------------------------------------------------------------
;
HMAPtr  proc    near
        push    cs
        pop     ds
        assume  ds:Bios_Data
        mov     di, FreeHMAPtr
        cmp     di, 0ffffh
        jne     @f
        cmp     SysinitPresent, 0
        je      @f
        call    dword ptr MoveDOSIntoHMA
        mov     di, FreeHMAPtr
@@:
        ret
HMAPtr  endp


;********************************************************
;*                                                      *
;*      CONSOLE ROUTINE                                 *
;*                                                      *
;********************************************************
CON_READ:
        PUSH    CS
        POP     DS
        PUSH    CX
        PUSH    DI
        CLD
        MOV     BIOS_FLAG,1
        MOV     BL,ASS_CONIN            ;GET DEV-NO
        XOR     BH,BH
        SHL     BX,1                    ;WORD POINTER
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    INP_DEV_TBL[BX]         ;CALL FLUSH SUBROUTINE
        POP     DI
        POP     CX
        STOSB
        LOOP    CON_READ
        JMP     EXIT

;
;       NON-DESTRUCTIVE READ
;
CON_RDND:
        PUSH    CS
        POP     DS
        CLD
        MOV     BIOS_FLAG,1
        MOV     BL,ASS_CONIN            ;GET DEV_NO
        XOR     BH,BH
        SHL     BX,1
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    INP_STS_TBL[BX]         ;CALL I/O SUBROUTINE
        JZ      CON_RDND_BUS
        LDS     DI,[PTRSAV]
        MOV     [DI.MEDIA],AL
        JMP     EXIT
CON_RDND_BUS:
        JMP     BUS_EXIT

;
;       FLUSH INPUT BUFFER
;
CON_FLSH:
        PUSH    CS
        POP     DS
        CLD
        MOV     BIOS_FLAG,1
        MOV     BL,ASS_CONIN
        XOR     BH,BH
        SHL     BX,1                    ;WORD POINTER
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    INP_FLS_TBL[BX]         ;CALL FLUSH SUBROUTINE
        JMP     EXIT

;
;       WRITRE
;
CON_WRIT:
        PUSH    CS
        POP     DS
        MOV     SI,DI
CON_WRIT1:
        LODS    BYTE PTR ES:[SI]
        CALL    CONOUT
        LOOP    CON_WRIT1
        JMP     EXIT

CONOUT_FAR      PROC    FAR
        CALL    CONOUT
        RET
CONOUT_FAR      ENDP


CONOUT:
        PUSH    CS
        POP     DS
        PUSH    CX
        PUSH    SI
        CLD
        MOV     BIOS_FLAG,1
        XCHG    AL,CL
        MOV     BL,ASS_CONOUT           ;GET DEV_NO
        MOV     OUT_RTN_CNT,BL
        MOV     BX,OFFSET ASS_CONOUT+1
        MOV     OUT_NXT_PTR,BX          ;SAVE POINTER
        CALL    OUT_ASSIGN
        CALL    DWORD PTR CS:[STOP_CHK_RTN]
        POP     SI
        POP     CX
        RET

;
;       WRITE STATUS
;
CON_WRST:
        PUSH    CS
        POP     DS
        CLD
        MOV     BIOS_FLAG,1
        MOV     BL,ASS_CONOUT
        MOV     OUT_RTN_CNT,BL          ;GET DEV_NO
        MOV     BX,OFFSET ASS_CONOUT+1
        MOV     OUT_NXT_PTR,BX          ;SAVE POINTER
        MOV     STS_SAVE,0
        CALL    STS_ASSIGN
        CALL    DWORD PTR CS:[STOP_CHK_RTN]
        MOV     AX,STS_SAVE
        JMP     EXIT1

        PAGE

;********************************************************
;*                                                      *
;*      AUXILIARY ROUTINE                               *
;*                                                      *
;********************************************************
;
;       DESTRUCTIVE READ
;
AUX_READ_P      PROC    FAR
AUX_READ:
        PUSH    CS
        POP     DS
        PUSH    CX
        PUSH    DI
        CLD
        MOV     BIOS_FLAG,1
        MOV     BL,ASS_READER           ;GET DEV_NO
        XOR     BH,BH
        SHL     BX,1                    ;WORD POINTER
        CALL    INP_DEV_TBL[BX]         ;CALL FLUSH SUBROUTINE
        POP     DI
        POP     CX
        STOSB
        LOOP    AUX_READ
        RET
AUX_READ_P      ENDP

;
;       NON-DESTRUCTIVE READ
;
AUX_RDND_P      PROC    FAR
AUX_RDND:
        PUSH    CS
        POP     DS
        CLD
        MOV     BIOS_FLAG,1
        MOV     BL,ASS_READER
        XOR     BH,BH
        SHL     BX,1
        CALL    INP_STS_TBL[BX]         ;CALL I/O SUBROUTINE
        RET
AUX_RDND_P      ENDP

;
;       FLUSH INPUT BUFFER
;
AUX_FLSH_P      PROC    FAR
AUX_FLSH:
        PUSH    CS
        POP     DS
        CLD
        MOV     BIOS_FLAG,1
        MOV     BL,ASS_READER           ;GET DEV-NO
        XOR     BH,BH
        SHL     BX,1
        CALL    INP_FLS_TBL[BX]         ;CALL FLUSH SUBROUTINE
        RET
AUX_FLSH_P      ENDP

;
;       WRITE
;
;----------------------------------------------- DUMMY DEVICE 870826 ------
AUX_WRIT_DUM:
AUX_WRST_DUM:
AUX_FLSH_DUM:
AUX_READ_DUM:
AUX_RDND_DUM:
        MOV     AL,02H                  ;NOT READY
        JMP     ERR_EXIT                ;ERROR RETURN
;--------------------------------------------------------------------------

AUX_WRIT_P      PROC    FAR
AUX_WRIT:
        PUSH    CS
        POP     DS
        MOV     SI,DI
AUX_WRIT1:
        LODS    BYTE PTR ES:[SI]
        CALL    AUXOUT
        LOOP    AUX_WRIT1
        RET
AUX_WRIT_P      ENDP

AUXOUT:
        PUSH    CS
        POP     DS
        PUSH    CX
        PUSH    SI
        MOV     BIOS_FLAG,1
        XCHG    AL,CL
        MOV     BL,ASS_PUNCH            ;GET DEV-NO
        MOV     OUT_RTN_CNT,BL
        MOV     BX,OFFSET ASS_PUNCH+1
        MOV     OUT_NXT_PTR,BX
        CALL    OUT_ASSIGN
        CALL    DWORD PTR CS:[STOP_CHK_RTN]
        POP     SI
        POP     CX
        RET

;
;       WRITE STATUS
;
AUX_WRST_P      PROC    FAR
AUX_WRST:
        CLD
        PUSH    CS
        POP     DS
        MOV     BIOS_FLAG,1
        MOV     BL,ASS_PUNCH            ;GET DEV-NO
        MOV     OUT_RTN_CNT,BL
        MOV     BX,OFFSET ASS_PUNCH+1
        MOV     OUT_NXT_PTR,BX
        MOV     STS_SAVE,0
        CALL    STS_ASSIGN
        CALL    DWORD PTR CS:[STOP_CHK_RTN]
        MOV     AX,STS_SAVE
        RET
AUX_WRST_P      ENDP

        PAGE
;********************************************************
;*                                                      *
;*      PRINTER ROUTINE                                 *
;*                                                      *
;********************************************************

;
;       WRITE
;
;-------------------------------------------------- DUMMY DEVICE 870826 --
PRN_WRIT_DUM:
PRN_WRST_DUM:
        MOV     AL,02H                  ;NOT READY
        JMP     ERR_EXIT                ;ERROR RETURN
;-------------------------------------------------------------------------

PRNWRITP PROC   FAR
PRN_WRIT:
        PUSH    CS
        POP     DS
        MOV     SI,DI
PRN_WRIT1:
        LODS    BYTE PTR ES:[SI]
        CALL    NEAR PTR LISTOUT
        LOOP    PRN_WRIT1
        RET
PRNWRITP ENDP

LISTOUTP  PROC  NEAR
LISTOUT:
        PUSH    CS
        POP     DS
        PUSH    CX
        PUSH    SI
        CLD
        MOV     BIOS_FLAG,1
        XCHG    AL,CL
        MOV     BL,ASS_LISTOUT          ;GET DEV-NO
        MOV     OUT_RTN_CNT,BL
        MOV     BX,OFFSET ASS_LISTOUT+1
        MOV     OUT_NXT_PTR,BX          ;SAVE POINTER
        CALL    OUT_ASSIGN
        CALL    dword ptr CS:[STOP_CHK_rtn]
        POP     SI
        POP     CX
        RET
LISTOUTP ENDP

;       WRITE STATUS
;
PRNWRSTP PROC   FAR
PRN_WRST:
        CLD
        PUSH    CS
        POP     DS

        MOV     BIOS_FLAG,1
        MOV     BL,ASS_LISTOUT          ;GET DEV-NO.
        MOV     OUT_RTN_CNT,BL
        MOV     BX,OFFSET ASS_LISTOUT +1
        MOV     OUT_NXT_PTR,BX          ;SAVE POINTER
        MOV     STS_SAVE,0
        CALL    NEAR PTR STS_ASSIGN
        CALL    DWORD PTR CS:[STOP_CHK_RTN]
        MOV     AX,STS_SAVE
        RET
PRNWRSTP ENDP

        PAGE

;********************************************************
;*                                                      *
;*      CLOCK ROUTINE                                   *
;*                                                      *
;********************************************************
;
CLK_READ:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR cs:[CLK_READ_RTN]

CLK_WRIT:
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        JMP     DWORD PTR cs:[CLK_WRIT_RTN]

        PAGE
;********************************************************
;*                                                      *
;*      SUBROUTINES                                     *
;*                                                      *
;********************************************************
;
OUT_ASSIGN:
        PUSH    CS
        POP     DS
        MOV     BL,[BX]
        XOR     BH,BH
        SHL     BX,1
        PUSH    CX
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    OUT_DEV_TBL[BX]
        POP     CX
        SUB     OUT_RTN_CNT,1
        JZ      OUT_ASS_DONE
        INC     OUT_NXT_PTR
        MOV     BX,OUT_NXT_PTR
        JMP     SHORT OUT_ASSIGN
OUT_ASS_DONE:
        RET


STS_ASSIGN:
        PUSH    CS
        POP     DS
        MOV     BL,[BX]
        XOR     BH,BH
        SHL     BX,1
;--------------------------------------------------------- DOS5 90/12/17 --
        cmp     inHMA,0
        jz      @f
        call    EnsureA20On     ; assure a20 enabled            ;M001
@@:
;--------------------------------------------------------------------------
        CALL    OUT_STS_TBL[BX]
        OR      STS_SAVE,AX
        SUB     OUT_RTN_CNT,1
        JZ      STS_ASS_DONE
        INC     OUT_NXT_PTR
        MOV     BX,OUT_NXT_PTR
        JMP     SHORT STS_ASSIGN
STS_ASS_DONE:
        RET

;********************************************************
;*                                                      *
;*      DUMMY DEVICE                                    *
;*                                                      *
;********************************************************
;
DUMMRDY:
        MOV     AX,0100H
DUMMOUT:
        RET

; M001 - BEGIN

;************************************************************************
;*                                                                      *
;*      EnsureA20On - ensure that a20 is enabled if we're running	*
;*        in the HMA before interrupt entry points into Bios_Code       *
;*                                                                      *
;************************************************************************

HiMem   label   dword
        dw      90h
        dw      0ffffh

LoMem   label   dword
        dw      80h
        dw      0h

EnsureA20On     proc near
        assume  ds:nothing,es:nothing
;----------------------------------------------- DOS5 91/02/22 -------
        push    ds
        push    es
        push    cx
        push    si
        push    di
        lds     si, HiMem
        les     di, LoMem
        mov     cx, 8
        rep     cmpsw
        pop     di
        pop     si
        pop     cx
        pop     es
        pop     ds
        jz      ea_enable
        ret
;---------------------------------------------------------------------
;       call    IsA20Off
;       jz      ea_enable
;       ret
;
;EnableA20      proc    near    ; M041
;---------------------------------------------------------------------
ea_enable:
        push    ax
        push    bx
        mov     ah,5            ; localenablea20
        call    xms
        pop     bx
        pop     ax
bie_done:
        ret

EnsureA20On     endp
;
; M001 - END
;----------------------------------------------- DOS5 91/02/22 ------
;; M041 : BEGIN 
;;
;
;BEFORE_HMA     proc    near
;       cmp     inHMA, 0                ; M041
;       jz      skipa20                 ; M041
;       cmp     HMAinprogress,0
;       jne     @f
;       mov     A20WasOff, 0            ; M041 Assume A20 ON
;       call    IsA20off                ; M041 A20 Off?
;       jnz     @f                      ; M041
;       mov     A20WasOff, 0ffh         ; M041 Yes
;       call    EnableA20               ; assure a20 enabled    ;M001
;@@:
;       inc     HMAinprogress
;skipa20:
;       ret
;BEFORE_HMA     endp
;
;
;AFTER_HMA      proc    near
;       pushf                           ; M041
;       cmp     inHMA, 0
;       jz      @f
;       dec     HMAinprogress
;       jnz     @f
;       cmp     A20WasOff, 0            ; M041
;       jz      @f                      ; M041
;       call    DisableA20              ; M041
;@@:                                    ; M041
;       popf                            ; M041
;       ret
;AFTER_HMA      endp
;
;;----------------------------------------------------------------------------
;;
;; procedure : IsA20Off
;;
;;----------------------------------------------------------------------------
;;
;IsA20Off       proc    near
;               push    ds
;               push    es
;               push    cx
;               push    si
;               push    di
;               lds     si, HiMem
;               les     di, LoMem
;               mov     cx, 8
;               rep     cmpsw
;               pop     di
;               pop     si
;               pop     cx
;               pop     es
;               pop     ds
;               ret
;IsA20Off       endp
;
;;
;;----------------------------------------------------------------------------
;;
;; procedure : DisableA20
;;
;;----------------------------------------------------------------------------
;;
;DisableA20     proc    near
;               push    ax
;               push    bx
;               mov     ah,6            ; localdisable a20
;               call    xms
;               pop     bx
;               pop     ax
;               ret
;DisableA20     endp
;
;; M041 : END
;-----------------------------------------------------------------------

;*********************************************************************
;*
;*      PATCH AREA
;*
;*********************************************************************
PATCH_AREA_START:

;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        extrn   FILESEMM386EXE:byte
        public  patch03

remchar         db      "REM "
noems           db      "NOEMS"
noems_flg       db      0

patch03:                                ;called from readdos
        push    di
        rep     cmpsb
        jnz     reduce_mm

        pop     di
        push    di
        mov     cx,di
        mov     al,0dh
        std
        repnz   scasb
        cld
        jcxz    xxx
        inc     di
@@:     inc     di
xxx:    cmp     byte ptr es:[di],0ah
        je      @b
        cmp     byte ptr es:[di]," "
        je      @b
        push    si
        mov     si,offset remchar
        mov     cx,4
        repz    cmpsb
        pop     si
        jz      dont_reduce_mm                  ;it's a REM

        cmp     si,offset FILESEMM386EXE
        db      90h,90h
;       jae     @f
        xor     cx,cx
        jmp     short reduce_mm

@@:     pop     di
        push    di
@@:     cmp     byte ptr es:[di],"/"
        je      chk_noems
        cmp     byte ptr es:[di],0dh
        je      reduce_mm
        cmp     byte ptr es:[di],1ah
        je      reduce_mm
        inc     di
        jmp     @b
chk_noems:
        mov     [noems_flg],1                   ;assume /NOEMS
        inc     di
        mov     si,offset noems
        mov     cx,5
        repz    cmpsb
        jz      dont_reduce_mm                  ;has a /NOEMS option
        mov     [noems_flg],0                   ;clear /NOEMS
        jmp     @b


dont_reduce_mm:
        add     cx,1                            ;nonzero

reduce_mm:
        pop     di
        ret

;patch04:                                       ; called from sysconf
;       jb      got_mm
;       cmp     byte ptr cs:[noems_flg],1
;       je      got_mm
;       sub     ax,64
;got_mm:
;       retf
;---------------------------------------------------------------------

;----------------------------------------------- DOS5A 92/04/08 ------
;<patch BIOS50-P15>
Win386_Info     equ     0fe2h           ;addr of MSDOS.SYS Win386_Info

i2f_patch:
        jne     @f
        jmp     handle_multmult
@@:
        cmp     ax,4b05h
        je      switcher_func
        jmp     i2f_iret

switcher_func:
        push    ds
        push    cs
        pop     ds
        assume  ds:Bios_Data

        mov     word ptr [SI_Next], bx  ; Hook our structure into chain
        mov     word ptr [SI_Next + 2], es
        mov     bx, offset Win386_SI    ; point ES:BX to Win386_SI
        push    ds                      ;
        pop     es                      ;

        mov     word ptr [Sw_Next], bx  ; Hook our structure into chain
        mov     word ptr [Sw_Next + 2], es
        mov     bx, offset Switcher_SI  ; point ES:BX to Switcher_SI

        mov     es,[SEG_DOS]            ;MSDOS.SYS data segment
        mov     word ptr es:[Win386_Info+2],bx
        mov     word ptr es:[Win386_Info+4],ds
        mov     bx,Win386_Info

        pop     ds
        jmp     i2f_iret
        assume  ds:nothing

Switcher_SI     label   byte            ; Startup Info for Switcher
Sw_Version      db      3, 0            ; for Win386 3.0
Sw_Next         dd      ?               ; pointer to next info structure
                dd      0               ; a field we don't need
                dd      0               ; another field we don't need
Sw_Instance     dw      Instance_Table2, Bios_Data ; far pointer to instance table

;
; This table gives Switcher the instance data
;
Instance_Table2 label   dword
        dw      00H,00H                 ; INTERRUPT VECTOR
        dw      0400h                   ; ...400h bytes
        dd      0                       ; terminate the instance table
        dw      9*3 dup (0)             ; patch area for instance table
;---------------------------------------------------------------------

;----------------------------------------------- DOS5A 92/04/17 ------
;<patch BIOS50-P16>
        public  patch2k_2

patch2k_2:
        mov     cx,[HD_LNG]
@@:     cmp     cx,256
        je      @f
        shl     ax,1
        rcl     dx,1
        shr     cx,1
        jmp     @b
@@:
        ret
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 92/07/08 -------
;<patch BIOS50-P21>
        assume  ds:Bios_Data
        public  patch05

patch05 proc    far
        mov     ds,word ptr [PR_HEADER+2]
        call    dword ptr cs:[PR_HEADER]
        ret
patch05 endp
;---------------------------------------------------------------------

        public  DSK_144, mode3_fd, thisdrv_3mode

;1.44MBFD  (IBM PS/2 FORMAT (18SECTOR/TRACK))
DSK_144         dw      512             ;SECTOR LENGTH
                db      1               ;SECTOR/ALLOC UNIT
                dw      1               ;RESERVED SECTOR
                db      2               ;FATS
                dw      0e0h            ;DIRECTORY ENTRY
                dw      0b40h           ;total sec
                db      0f0h            ;MEDIA TYPE
                dw      9               ;SECTOR/FAT
                dw      12h             ;sec/trk
                dw      2               ;heads
                dd      0               ;hidden sec
                dd      0               ;large total sec

mode3_fd        db      0
thisdrv_3mode   db      0

;---------------
        extrn   patch144_d2_ret:near, SKIP_SBT:near

        public  patch144_d2

patch144_d2:
        jne     @f                      ;not 640kb media on 1MB I/F
        pop     ax
        jmp     patch144_d2_ret
@@:
        cmp     al,30h                  ;1.44MB media on 1MB I/F?
        pop     ax
        jne     @f
        xor     al,0a0h                 ;yes, treat as 9xh
@@:
        jmp     SKIP_SBT
;---------------------------------------------------------------------

PATCH_AREA:
        DB      512 - (PATCH_AREA - PATCH_AREA_START ) DUP (0)
;*********************************************************************
;*
;*      DISPOSABLE BDS AREA
;*
;*********************************************************************
        PUBLIC  BDS21
BDS21           DW      BDS22           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE21:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT21         DW      0               ;Open Ref. Count
;;;;;VOLID21            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS21         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB21        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK21         DB      -1              ;Last track accessed on this drive
TIM_LO21        DW      -1              ;Keep these two contiguous (?)
TIM_HI21        DW      -1
;------------------------------------------------------------------------------
VOLID21         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS22           DW      BDS23           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE22:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT22         DW      0               ;Open Ref. Count
;;;;;VOLID22            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS22         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB22        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK22         DB      -1              ;Last track accessed on this drive
TIM_LO22        DW      -1              ;Keep these two contiguous (?)
TIM_HI22        DW      -1
;------------------------------------------------------------------------------
VOLID22         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS23           DW      BDS24           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE23:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT23         DW      0               ;Open Ref. Count
;;;;;VOLID23            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS23         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB23        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK23         DB      -1              ;Last track accessed on this drive
TIM_LO23        DW      -1              ;Keep these two contiguous (?)
TIM_HI23        DW      -1
;------------------------------------------------------------------------------
VOLID23         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS24           DW      BDS25           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE24:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT24         DW      0               ;Open Ref. Count
;;;;;VOLID24            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS24         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB24        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK24         DB      -1              ;Last track accessed on this drive
TIM_LO24        DW      -1              ;Keep these two contiguous (?)
TIM_HI24        DW      -1
;------------------------------------------------------------------------------
VOLID24         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS25           DW      BDS26           ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE25:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT25         DW      0               ;Open Ref. Count
;;;;;VOLID25            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS25         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB25        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK25         DB      -1              ;Last track accessed on this drive
TIM_LO25        DW      -1              ;Keep these two contiguous (?)
TIM_HI25        DW      -1
;------------------------------------------------------------------------------
VOLID25         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

BDS26           DW      -1              ;Link to next structure
                DW      DATAGRP
                DB      25              ;ROM DISK INT Drive Number
                DB      0               ;Logical Drive Letter
FDRIVE26:
                DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors 
                DB      0FEH            ;Media descriptor       89/07/24
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
                DB      0               ; TRUE => Large fats
OPCNT26         DW      0               ;Open Ref. Count
;;;;;VOLID26            DB      "NO NAME    ",0 ;Volume ID for this disk
                DB      4               ;Form Factor            89/07/24
FLAGS26         DW      0022H           ;Various Flags          89/07/24
;               DB      9 dup (0)       ;Reserved for future use
                dw      77              ; number of cylinders
RecBPB26        DW      1024            ;Physical sector size in bytes
                DB      1               ;Sectors/allocation unit
                DW      1               ;Reserved sectors for DOS
                DB      2               ;No. allocation tables
                DW      192             ;Number directory entries
                DW      77*8*2          ;Number sectors (at 512 bytes ea.)
                DB      0FEh            ;Media descriptor, initially 00H.
                DW      2               ;Number of FAT sectors
                DW      8               ;Sector limit
                DW      2               ;Head limit             89/07/24
                DW      0               ;Hidden sector count
;------------------------------------------------------------------------------
                dw      0               ; hidden sector (high)
                dw      0               ; number sectors (low)
                dw      0               ; number sectors (high)
;------------------------------------------------------------------------------
;;;;;           DB      0               ; TRUE => Large fats
;;;;;           db      11 dup (?)      ; filler for balance
                db      6 dup (?)       ; filler for balance
TRACK26         DB      -1              ;Last track accessed on this drive
TIM_LO26        DW      -1              ;Keep these two contiguous (?)
TIM_HI26        DW      -1
;------------------------------------------------------------------------------
VOLID26         db      "NO NAME    ",0 ; volume id for this disk
                dd      0               ; current volume serial from boot record
                db      "FAT12   ",0    ; current file system id from boot record
;------------------------------------------------------------------------------

;----------------------------------------------- DOS5 91/02/20 -------
;*
;*      These are disposable data used only in initial time
;*
        public  B_DATA_END, HD_MEDIA, HDS_MEDIA
        
B_DATA_END      LABEL   WORD
HD_MEDIA        DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HD_MEDIA1       DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HD_MEDIA2       DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HD_MEDIA3       DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HDS_MEDIA       DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HDS_MEDIA1      DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HDS_MEDIA2      DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HDS_MEDIA3      DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HDS_MEDIA4      DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HDS_MEDIA5      DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HDS_MEDIA6      DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
HDS_MEDIA7      DB      (4+11+8)*4 DUP (0)      ; room for serial num
                                                ;  volume label, file sys id
;---------------------------------------------------------------------
;************************************************************************
;*                                                                      *
;*      END OF BIO2 MODULE                                              *
;*                                                                      *
;************************************************************************
Bios_data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:datagrp


                PUBLIC  BCode_start
                PUBLIC  BDATA_SEG

                org     30h                     ;dos5 vdisk header dummy
BCode_start :

BDATA_SEG       DW      0060H


;************************************************************************
;*                                                                      *
;*      seg_reinit is called with ax = our new code segment value,      *
;*        trashes di, cx, es                                            *
;*                                                                      *
;*      cas -- should be made disposable!                               *
;*                                                                      *
;************************************************************************

        public  seg_reinit
seg_reinit      proc    far
        assume  ds:nothing,es:nothing

;----------------------------------------------- DOS5 90/02/19 -------
        PUSH    DS
        MOV     DS,BDATA_SEG
        assume  ds:Bios_Data
        TEST    DS:[EXFNC_FLG],03H
        JZ      NOT_SUPPORT_ROM
        XOR     CX,CX
        MOV     ES,CX
        MOV     CX,WORD PTR ES:[05EAH]
        CMP     WORD PTR DS:[BIOS_SEG],CX
        JNE     SEG_REINIT10
        MOV     DI,05EAH
        STOSW                           ;OUR SEGMENT -> DISK_PRM0+2
SEG_REINIT10:
        MOV     CX,WORD PTR ES:[05EEH]
        CMP     WORD PTR DS:[BIOS_SEG],CX
        JNE     NOT_SUPPORT_ROM
        MOV     DI,05EEH
        STOSW                           ;OUR SEGMENT -> DISK_PRM1+2
NOT_SUPPORT_ROM:
        POP     DS
        assume  ds:nothing
;---------------------------------------------------------------------
        mov     es,bdata_seg
        assume  es:Bios_Data
;----------------------------------------------- DOS5 90/12/25 -------
        MOV     ES:[BIOS_SEG],AX
;---------------------------------------------------------------------
        mov     di,2+offset cdev
        mov     cx,((offset end_BC_entries) - (offset cdev))/4

seg_reinit_1:
        stosw                           ; modify Bios_Code entry points
        inc     di
        inc     di
        loop    seg_reinit_1
        ret
seg_reinit      endp


;
;       OUTER DRIVER PROCESS
;
PRNOUT_FAR      PROC    FAR
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     AX,0065H                ;DUMMY STATE
        CMP     ES:PR_HEADER+2,0
        JE      PRNOUT10
        MOV     DS,ES:PR_HEADER+2
        MOV     ES:WORD PTR PR_HEADER,15H    ;SET OFFSET TO PROUT
        CALL    ES:DWORD PTR PR_HEADER
PRNOUT10:
        POP     ES
        POP     DS
        RET
PRNOUT_FAR      ENDP

PRNRDY_FAR      PROC    FAR
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     AX,6500H                 ;DUMMY STATE
        CMP     ES:PR_HEADER+2,0
        JE      PRNRDY10
        MOV     DS,ES:PR_HEADER+2
        MOV     ES:WORD PTR PR_HEADER,12H    ;SET OFFSET TO PRRDY
        CALL    ES:DWORD PTR PR_HEADER
PRNRDY10:
        POP     ES
        POP     DS
        RET
PRNRDY_FAR      ENDP

;*******86/09/23********
;
;       DRIVER CALL ROUTINE
;

;
;       AUX (CH NO.0) DEVICE DRIVER ENTRY TABLE
;

;----------------------------------------------------- 871019 --------
;S0IN_ADDR      EQU     50H
S0IN_ADDR       EQU     12H
;---------------------------------------------------------------------
S0STAT_ADDR     EQU     S0IN_ADDR + 3
S0FLUSH_ADDR    EQU     S0STAT_ADDR + 3
S0OUT_ADDR      EQU     S0FLUSH_ADDR + 3
S0RDY_ADDR      EQU     S0OUT_ADDR  + 3

S0IN_FAR        PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S0IN_10                 ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX_HEADER+2      ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX_HEADER,S0IN_ADDR        ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX_HEADER ;CALL AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S0IN_10:
        RET
S0IN_FAR        ENDP


S0STAT_FAR      PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S0STAT_20               ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX_HEADER+2      ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX_HEADER,S0STAT_ADDR      ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX_HEADER ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        JZ      S0STAT_10               ;BUSY ?
        MOV     AH,01H                  ;NO , SET DON
        JMP     SHORT S0STAT_20
S0STAT_10:
        MOV     AH,03H                  ;SET BUSY
S0STAT_20:
        RET
S0STAT_FAR      ENDP

S0FLUSH_FAR     PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S0FLUSH_10              ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX_HEADER+2      ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX_HEADER,S0FLUSH_ADDR     ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX_HEADER ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S0FLUSH_10:
        RET
S0FLUSH_FAR     ENDP

S0OUT_FAR       PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S0OUT_10                ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX_HEADER+2      ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX_HEADER,S0OUT_ADDR       ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX_HEADER ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S0OUT_10:
        RET
S0OUT_FAR       ENDP

S0RDY_FAR       PROC    FAR
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     AX,0300H                ;SET DUMMY STATUS (BUSY)
        CMP     ES:WORD PTR AUX_HEADER+2,0      ;DOES AUX DEVICE DRIVER EXIST ?
        JE      S0RDY_10                ;NO
        MOV     DS,ES:AUX_HEADER+2      ;RDYT SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX_HEADER,S0RDY_ADDR       ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX_HEADER ;CALL   AUX DEVICE DRIVER
S0RDY_10:
        POP     ES
        POP     DS
        RET
S0RDY_FAR       ENDP

;
;AUX (CH NO.1) DEVICE DRIVER ENTRY TABLE
;

S1IN_ADDR       EQU     60H
S1STAT_ADDR     EQU     S1IN_ADDR + 3
S1FLUSH_ADDR    EQU     S1STAT_ADDR + 3
S1OUT_ADDR      EQU     S1FLUSH_ADDR + 3
S1RDY_ADDR      EQU     S1OUT_ADDR  + 3

S1IN_FAR        PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S1IN_10                 ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX1_HEADER+2     ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX1_HEADER,S1IN_ADDR       ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX1_HEADER        ;CALL AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S1IN_10:
        RET
S1IN_FAR        ENDP

S1STAT_FAR      PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S1STAT_20               ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX1_HEADER+2     ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX1_HEADER,S1STAT_ADDR     ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX1_HEADER        ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        JZ      S1STAT_10               ;BUSY ?
        MOV     AH,01H                  ;NO , SET DON
        JMP     SHORT S1STAT_20
S1STAT_10:
        MOV     AH,03H                  ;SET BUSY
S1STAT_20:
        RET
S1STAT_FAR      ENDP

S1FLUSH_FAR     PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S1FLUSH_10              ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX1_HEADER+2     ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX1_HEADER,S1FLUSH_ADDR    ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX1_HEADER        ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S1FLUSH_10:
        RET
S1FLUSH_FAR     ENDP

S1OUT_FAR       PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S1OUT_10                ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX1_HEADER+2     ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX1_HEADER,S1OUT_ADDR      ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX1_HEADER        ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S1OUT_10:
        RET
S1OUT_FAR       ENDP

S1RDY_FAR       PROC    FAR
        PUSH    DS
        PUSH    ES
        MOV     ES,cs:[bdata_seg]
        MOV     AX,0300H                ;SET DUMMY STATUS (BUSY)
        CMP     ES:WORD PTR AUX1_HEADER+2,0     ;DOES AUX DEVICE DRIVER EXIST ?
        JE      S1RDY_10                ;NO
        MOV     DS,ES:AUX1_HEADER+2     ;RDYT SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX1_HEADER,S1RDY_ADDR      ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX1_HEADER        ;CALL   AUX DEVICE DRIVER
S1RDY_10:
        POP     ES
        POP     DS
        RET
S1RDY_FAR       ENDP

;AUX (CH NO.2) DEVICE DRIVER ENTRY TABLE

S2IN_ADDR       EQU     70H
S2STAT_ADDR     EQU     S2IN_ADDR + 3
S2FLUSH_ADDR    EQU     S2STAT_ADDR + 3
S2OUT_ADDR      EQU     S2FLUSH_ADDR + 3
S2RDY_ADDR      EQU     S2OUT_ADDR  + 3

S2IN_FAR        PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S2IN_10                 ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX2_HEADER+2     ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX2_HEADER,S2IN_ADDR       ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX2_HEADER        ;CALL AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S2IN_10:
        RET
S2IN_FAR        ENDP

S2STAT_FAR      PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S2STAT_20               ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX2_HEADER+2     ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX2_HEADER,S2STAT_ADDR     ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX2_HEADER        ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        JZ      S2STAT_10               ;BUSY ?
        MOV     AH,01H                  ;NO , SET DON
        JMP     SHORT S2STAT_20
S2STAT_10:
        MOV     AH,03H                  ;SET BUSY
S2STAT_20:
        RET
S2STAT_FAR      ENDP

S2FLUSH_FAR     PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S2FLUSH_10              ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX2_HEADER+2     ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX2_HEADER,S2FLUSH_ADDR    ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX2_HEADER        ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S2FLUSH_10:
        RET
S2FLUSH_FAR     ENDP

S2OUT_FAR       PROC    FAR
        CALL    CHK_AUX_DRV             ;CHECK AUX DEVICE DRIVER
        JZ      S2OUT_10                ;NO DRIVER
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:AUX2_HEADER+2     ;SET SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX2_HEADER,S2OUT_ADDR      ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX2_HEADER        ;CALL   AUX DEVICE DRIVER
        POP     ES
        POP     DS
        MOV     AH,01H                  ;SET DON
S2OUT_10:
        RET
S2OUT_FAR       ENDP

S2RDY_FAR       PROC    FAR
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     AX,0300H                ;SET DUMMY STATUS (BUSY)
        CMP     ES:WORD PTR AUX2_HEADER+2,0     ;DOES AUX DEVICE DRIVER EXIST ?
        JE      S2RDY_10                ;NO
        MOV     DS,ES:AUX2_HEADER+2     ;RDYT SEGMENT ADDRESS
        MOV     ES:WORD PTR AUX2_HEADER,S2RDY_ADDR      ;SET ENTRY OFFSET ADDRESS
        CALL    ES:DWORD PTR AUX2_HEADER        ;CALL   AUX DEVICE DRIVER
S2RDY_10:
        POP     ES
        POP     DS
        RET
S2RDY_FAR       ENDP

CHK_AUX_DRV:
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        CMP     ES:WORD PTR AUX_HEADER+2,0      ;DOES AUX DEVICE DRIVER EXIST ?
        POP     ES
        JE      CHK_AUX_DRV_10          ;NO
        RET                             ;EXIT CONDITION ZF = 0
CHK_AUX_DRV_10:
        MOV     AX,8103H                ;SET DUMMY STATUS (NOT READY)
        RET                             ;EXIT CONDITION ZF = 1
;*******86/09/23********

;********************************************************
;*                                                      *
;*      CLOCK ROUTINE                                   *
;*                                                      *
;********************************************************
;
CLK_READ_CODERTN:
        CALL    GETDATE
        STOSW
        MOV     AX,CX
        STOSW
        MOV     AX,DX
        STOSW
        JMP     EXITRTN

CLK_WRIT_CODERTN:
        MOV     SI,DI
        LODS    WORD PTR ES:[SI]
        CALL    SETDATE
        LODS    WORD PTR ES:[SI]
        MOV     CX,AX
        LODS    WORD PTR ES:[SI]
        MOV     DX,AX
        CALL    SETTIME
        JMP     EXITRTN

Bios_Code       ends

        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\console.asm ===
PAGE    109,132
        TITLE   MS-DOS 5.0 CONSOLE.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE: CONSOLE.ASM                                     *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;************************************************************************
;*                                                                      *
;*                                                                      *
;*                                                                      *
;*      MS-DOS V2.00/V3.10 CONSOLE(VIDEO) OUTPUT ROUTINE                *
;*                                                                      *
;*                                                                      *
;*                                                                      *
;************************************************************************
;
;       85/03/15  DSPCSR CORRECTION FOR ROM
;       85/04/29
;       86/09/23  FOR SOURCE CLEAN

;       87/08 --  HIRESO/NORMAL
;       87/10/01  BUG FIX (DIPLAY FUNCTION-KEY ROUTINE)
;
;       90/11,12  MS-DOS 5.0 
;
;

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends


Bios_Data       segment word public 'Bios_Data'
                ASSUME CS:DATAGRP

        EXTRN   FKYCNT:BYTE,SFTJISMOD:BYTE
        EXTRN   MODMARK1:BYTE,MODMARK2:BYTE,MEM_SW5:BYTE

        EXTRN   FKYPTR:WORD
        EXTRN   ESCBUF:WORD,ESCPTR:WORD,ESCSUBRTN:WORD,ESCPOSSAVE:WORD
        EXTRN   ESCCNT:BYTE,ESCPRM:BYTE,SRMFLG:BYTE,ESCATRSAVE:BYTE
        EXTRN   ESCCPRBUF:BYTE,ESCCPRLIN:WORD,ESCCPRCOL:WORD,KANJICNT:BYTE
        EXTRN   K1STSAV:BYTE,WRAPMOD:BYTE,ROLSW:BYTE,NULCHR:WORD,ENDLINE:BYTE
        EXTRN   CSRSW:BYTE,FKYSW:BYTE,CURLIN:BYTE,CURCOL:BYTE,DEFATTR:BYTE
        EXTRN   CURATTR:BYTE,ROLTOP:BYTE,WAITCNT:WORD,FKYD_KCNT:BYTE
        EXTRN   FKYD_K1SAV:BYTE
        EXTRN   LINMOD:BYTE

        EXTRN   VRAMSEG:WORD                    ;                       870811
        EXTRN   SYS_501:BYTE                    ;                       870815
;-----------------------------------------------------  89/08/16  ---
        EXTRN   CRTDOTF:WORD

        EXTRN   CURATTR2:WORD,DEFATTR2:WORD
        EXTRN   ATRSAVE2:WORD,BIOSF_3:byte              ;       89/08/21
        EXTRN   FKYTBL:NEAR,FKYTBL2:NEAR
        EXTRN   ESCATTRTBL:NEAR,SGRFLG:BYTE,ATTRTBL2:NEAR
        EXTRN   LINETBL:NEAR
;--------------------------------------------------------------------

        EXTRN   ATTRF:WORD

Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE

        EXTRN   FKYDSP:NEAR
        EXTRN   CHGLIN:NEAR
        EXTRN   CRTMD2AT:NEAR,CRTMD1AT:NEAR
        EXTRN   CRTMD480:NEAR,CRTMD400:NEAR
        extrn   bdata_seg:word

Bios_Code       ends


Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        PUBLIC  CONSOLE_CODE_START

        PUBLIC  CRTOUT,CRTRDY
        PUBLIC  CRTOUT_FAR,CRTRDY_FAR
        PUBLIC  LOOKUP,CLRRTN,HOMERTN
        PUBLIC  HOMERTN_FAR
        PUBLIC  CLRRTN_FAR
        PUBLIC  BELRTN,CRTCLR
        PUBLIC  BELRTN_FAR
        PUBLIC  LINECLR,ROLLUP,DSPCSR,DSPFKY,D_MCONV
        PUBLIC  D_MCONV_FAR
        PUBLIC  CODECHK
        PUBLIC  ESCADM,ESCIND,ESCRI,ESCVT_CUU,ESCVT_CUD
        PUBLIC  ESCVT_CUF,ESCVT_CUB,ESCVT_ED,ESCVT_EL
        PUBLIC  ESCVT_IL,ESCVT_DL,ESCKNJ

;       PUBLIC  KBCODTBL
;       PUBLIC  CTRLXFER,CTRLNFER,CTRLFKY               ;
;       PUBLIC  BUFSIZE,CHRTBL                          ;               870825

CONSOLE_CODE_START:

;****************************************************************
;*                                                              *
;*      SCREEN DRIVER DATA                                      *
;*                                                              *
;****************************************************************

;************************************************
;*                                              *
;*      EQU                                     *
;*                                              *
;************************************************

ESCBUFSIZ       EQU     20
FKYBUFSIZ       EQU     80              ;FUNC KEY BUFFER SIZE
;VRAMSEG        EQU     0E000H          ;VIDEO RAM SEGMENT ADDR
ATTROFST        EQU     2000H           ;ATTR MEM(IN VRAM) OFFSET
LINEEND         EQU     79
LINESIZE        EQU     80
CRTSIZE         EQU     LINESIZE*31     ;SCREEN CHARACTER LENGTH

        PAGE
;************************************************
;*                                              *
;*      TABLES                                  *
;*                                              *
;************************************************
        EVEN
;************************************************
;*   CONTROL DATA SUBROUTINE TABLE              *
;************************************************
CTLRTNTBL DB    07H                     ;BEEP
        DW      BELRTN
        DB      08H                     ;BACK SPACE
        DW      BSRTN
        DB      09H                     ;HORIZONTAL TAB
        DW      TABRTN
        DB      0AH                     ;LINE FEED
        DW      LFRTN
        DB      0BH                     ;VERTICAL UP
        DW      UPRTN
        DB      0CH                     ;FORE SPACE
        DW      FSRTN
        DB      0DH                     ;CARRIAGE RETURN
        DW      CRRTN
        DB      1AH                     ;CLEAR & HOME
        DW      CLRRTN
        DB      1BH                     ;ESCAPE
        DW      ESCRTN
        DB      1EH                     ;HOME
        DW      HOMERTN
        DB      0                       ;OTHER
        DW      DATARTN

;************************************************
;*   ESC ROUTINE TABLE                          *
;************************************************
ESCCSITBL       EQU     $
        DB      '['                     ;VT100 LIKE ESC
        DW      ESCVT
        DB      '='                     ;ADM-3A MODE ESC
        DW      ESCADM
        DB      '*'                     ;CLEAR SCREEN
        DW      ESCHMCLR
        DB      '('                     ;NOP
        DW      ESCNOP
        DB      'D'                     ;INDEX
        DW      ESCIND
        DB      'E'                     ;NEXT LINE
        DW      ESCNEL
        DB      'M'                     ;REVERSE INDEX
        DW      ESCRI
        DB      ')'                     ;KANJI / ANK MODE
        DW      ESCKNJ
        DB      0
        DW      ESC_NOP2 

;************************************************
;*   VT100 LIKE ESC SUBROUTINE TABLE            *
;************************************************
VTRTNTBL        EQU     $
        DB      'A'                     ;CURSOR UP
        DW      ESCVT_CUU
        DB      'B'                     ;CURSOR DOWN
        DW      ESCVT_CUD
        DB      'C'                     ;CURSOR FORWARD
        DW      ESCVT_CUF
        DB      'D'                     ;CURSOR BACKWARD
        DW      ESCVT_CUB
        DB      'H'                     ;CURSOR POSITION
        DW      ESCVT_CUP
        DB      'J'                     ;ERASE IN DISPLAY
        DW      ESCVT_ED
        DB      'K'                     ;ERASE IN LINE
        DW      ESCVT_EL
        DB      'L'                     ;INSERT LINE
        DW      ESCVT_IL
        DB      'M'                     ;DELETE LINE
        DW      ESCVT_DL
        DB      'm'                     ;SELECT GRAPHIC RENDITION
        DW      ESCVT_SGR
        DB      'f'                     ;HORIZONTAL & VERTICAL POSITION
        DW      ESCVT_CUP
        DB      'h'                     ;SET MODE
        DW      ESCVT_SM
        DB      'l'                     ;RESET MODE
        DW      ESCVT_RM
        DB      'n'                     ;DEVICE STATUS REPORT
        DW      ESCVT_DSR
        DB      's'                     ;SAVE CURSOR POSITION
        DW      ESCVT_PSCP
;-------------------------------------------------------------- 880504
        DB      'p'                     ;KEYBOARD REASSIGNMENT
        DW      ESCVT_KASS
;---------------------------------------------------------------------
        DB      'u'                     ;SET CURSOR POSITION
        DW      ESCVT_PRCP
        DB      '>'                     ;INTERMEDIATE CHAR 1
        DW      ESCVT_IMC1
        DB      '?'                     ;INTERMEDIATE CHAR 2
        DW      ESCVT_IMC2
        DB      '='                     ;INTERMEDIATE CHAR 3
        DW      ESCVT_IMC3
        DB      0                       ;STOPPER(ILLEGAL FINAL CHAR)
        DW      ESCVT_NOP               ;NOP

        EVEN
;************************************************
;*  SUBROUTINE FOR DATARTN                      *
;************************************************
DD_RTNTBL  DW   W1CHR                   ;W, ANK TO ANK-ANK
        DW      W2CHR                   ;W, KNJ TO ANK-ANK
        DW      W1CHR                   ;W, ANK TO ANK-KNJ
        DW      DD_KNJ_AL               ;W, KNJ TO ANK-KNJ
        DW      DD_ANK_L                ;W, ANK TO KNJ(L)
        DW      W2CHR                   ;W, KNJ TO KNJ
        DW      DD_ANK_R                ;W, ANK TO KNJ(R)
        DW      DD_KNJ_RA               ;W, KNJ TO KNJ(R)-ANK
        DW      DD_ANK_R                ;W, ANK TO KNJ(R)
        DW      DD_KNJ_RL               ;W, KNJ TO KNJ(R)-KNJ


        PAGE
;****************************************************************
;*   CONSOLE OUTPUT                                             *
;*                                                              *
;*      ENTRY: (CL)=ASCII CODE                                  *
;*                                                              *
;****************************************************************

CRTRDY_FAR      PROC    FAR
        CALL    CRTRDY
        RET
CRTRDY_FAR      ENDP

CRTRDY:
        MOV     AX,0100H
        RET

;
; VIDEO DRIVER
;

CRTOUT_FAR      PROC    FAR
        CALL    CRTOUT
        RET
CRTOUT_FAR      ENDP

CRTOUT:
        CMP     [ESCCNT],0              ;ESCAPE MODE ?
        JNE     CRTOUTESC               ;YES
;  NOT ESC_MODE
        CMP     CL,' '                  ;CONTROL DATA ?
        JB      CRTOUT1                 ;Y
        CALL    DATARTN
        RET
CRTOUT1:
        MOV     BX,OFFSET CTLRTNTBL
        CALL    LOOKUP                  ;TABLE LOOKUP
        CALL    BX                      ;SUBROUTINE                     @DOS5
        RET
;
;  IN ESCAPE MODE
CRTOUTESC:
        INC     [ESCCNT]
        CMP     [ESCCNT],2
        JNE     CRTOUTESC1
        MOV     BX,OFFSET ESCCSITBL
        CALL    LOOKUP                  ;TABLE  SEARCH
        MOV     [ESCSUBRTN],BX          ;SAVE SUBRTN ADDRESS
CRTOUTESC1:
        CALL    [ESCSUBRTN]
        RET

;********************************
;*   TABLE LOOKUP               *
;********************************
LOOKUP:
        CMP     BYTE PTR CS:[BX],0              ;TABLE END ?
        JE      LOOKUPRET               ;YES
        CMP     CS:[BX],CL
        JE      LOOKUPRET               ;FOUND
        ADD     BX,3
        JMP     LOOKUP

LOOKUPRET:
        MOV     BX,CS:1[BX]             ;GET SUBROUTINE ADDRESS
        RET

        PAGE
;****************************************************************
;*                                                              *
;*      ESCAPE SEQUENCE ROUTINES                                *
;*                                                              *
;****************************************************************

;****************************************
;*   ADM-3A MODE ESC                    *
;*      (ESC = L C )                    *
;****************************************
ESCADM:
        MOV     BX,[ESCPTR]
        MOV     [BX],CL                 ;SET DATA TO BUFFER
        INC     [ESCPTR]
        CMP     [ESCCNT],4              ;DATA END ?
        JB      ESCADMRET               ;NO

ESCADM1:
        MOV     BX,OFFSET ESCBUF+1
        MOV     CX,[BX]                 ;GET PARAMETER (L,C)
        MOV     AL,CL                   ;
        MOV     AH,[ENDLINE]
        CALL    CHKPOS                  ;CHECK  LINE
        MOV     [CURLIN],AL
        MOV     AL,CH                   ;
        MOV     AH,LINEEND
        CALL    CHKPOS                  ;CHECK  COLUMN
        MOV     [CURCOL],AL
        CALL    DSPCSR                  ;DISPLAY CURSOR
        MOV     [ESCCNT],0              ;EXIT ESC
ESCADMRET:
        RET

;************************
;*   CHECK LINE/COLUMN  *
;************************
CHKPOS:
        SUB     AL,20H
        JNB     CHKPOS1                 ;IF AL < 20H
        MOV     AL,0                    ;   THEN AL:=00H
CHKPOS1:
        CMP     AL,AH                   ;IF AL  > LIMIT
        JBE     CHKPOSRET               ;   THEN AL:=LIMIT VALUE
        MOV     AL,AH
CHKPOSRET:
        RET

;****************************************
;*   KANJI(SHFT JIS) MODE               *
;*      ANK (JIS) MODE                  *
;****************************************
ESCKNJ:
        CMP     [ESCCNT],3
        JNE     ESCKNJRET
        CMP     CL,'3'                  ;ANK ?
        JE      ESCKNJ1                 ;Y
        CMP     CL,'0'                  ;KANJI ?
        JNE     ESCKNJ2                 ;N
        MOV     [SFTJISMOD],1
        MOV     [MODMARK1],' '
        JMP     short ESCKNJ2
ESCKNJ1:
        MOV     [MODMARK1],'g'
        MOV     [SFTJISMOD],0
ESCKNJ2:
        CMP     [FKYSW],0               ;
        JE      ESCKNJ3                 ;
        PUSH    ES                      ;
        MOV     AX,[VRAMSEG]            ;
        MOV     ES,AX                   ;
        MOV     DH,[ENDLINE]            ;
        INC     DH                      ;
        XOR     DL,DL                   ;
        CALL    LCCONV                  ;
        ADD     BX,2                    ;
        MOV     AL,[MODMARK1]           ;
        XOR     AH,AH                   ;
        MOV     ES:[BX],AX              ;
        POP     ES                      ;
ESCKNJ3:
        MOV     [ESCCNT],0              ;EXIT ESC MODE
ESCKNJRET:
        RET

;****************************************
;*   NO OPERATION ESCAPE                *
;*      ESC ( N                         *
;****************************************
ESCNOP:
        CMP     [ESCCNT],3
        JB      ESCNOPRET
        MOV     [ESCCNT],0              ;EXIT ESC
ESCNOPRET:
        RET

;****************************************
;*   SOROC MODE ESCAPE                  *
;*      ESC *  ( CLEAR SCREEN )         *
;****************************************
ESCHMCLR:
        CALL    CLRRTN                  ;CLEAR SCREEN
        MOV     [ESCCNT],0              ;EXIT ESC
        RET

;****************************************
;*   NEXT LINE (ANSI COMPATIBLE)        *
;*      ESC E                           *
;*   INDEX (ANSI COMPATIBLE)            *
;*      ESC D                           *
;****************************************
ESCNEL:
        CALL    CRRTN
ESCIND: CALL    LFRTN
ESC_NOP2:
        MOV     [ESCCNT],0
        RET

;****************************************
;*   REVERSE INDEX (ANSI COMPATIBLE)    *
;*      ESC M                           *
;****************************************
ESCRI:
        CMP     [CURLIN],0              ;TOP MARJIN ?
        JE      ESCRI1                  ;YES
        DEC     [CURLIN]
        CALL    DSPCSR
        JMP     SHORT   ESCRI2
ESCRI1:
        CALL    ROLDOWN                 ;SCROLL DOWN 1 LINE
ESCRI2:
        MOV     [ESCCNT],0
        RET

        PAGE
;************************************************
;*   ESCVT: ANSI MODE ESC SEQUENCE              *
;*      ESC [ ...                               *
;*                                              *
;************************************************
;
ESCVT:
        CMP     [ESCCNT],2
        JE      ESCVTRET

        CMP     CL,';'                  ;SEPARATER ?
        JE      ESCVT_SP                ;YES
;-------------------------------------------------------------- 880504
        CMP     CL,"'"
        JE      ESCVT_QUAT              ;QUATATION (FOR KB-REASS)
        CMP     CL,'"'
        JE      ESCVT_QUAT              ;QUATATION (FOR KB-REASS)
        CMP     [SRMFLG],-1             ;CHAR MODE?
        JE      ESCVT_CHAR              ;YES
;---------------------------------------------------------------------
        CMP     CL,3AH                  ;NUMERIC ?
        JNB     ESCVT_EX                ;NO, TREAT FINAL CHAR
        AND     CL,0FH                  
        CMP     CL,09H                  ;CL >= 09H ?
        JBE     ESCVT_NUM               ;NO
ESCVT_EX:
        MOV     BX,OFFSET VTRTNTBL      ;TABLE ADDR
        CALL    LOOKUP
        MOV     SI,OFFSET ESCBUF        ;SET BUFFER OFFSET
        CALL    BX                      ;SUBROUTINE
        CMP     [SRMFLG],0              ;CONTINUE ?
        JNE     ESCVTRET                ;JUMP IF 'ESC [ >'
        MOV     [ESCCNT],0              ;EXIT ESC
ESCVTRET:
        RET

;  NUMERIC PARAMETER
ESCVT_NUM:
        MOV     BX,[ESCPTR]
        MOV     AX,10
        MUL     WORD PTR[BX]
        AND     CX,0FH
        ADD     AX,CX
        MOV     [BX],AX
        RET

;  SEPARATER PROC
ESCVT_SP:
        ADD     [ESCPTR],2
        INC     [ESCPRM]                ;PARAM COUNT
        CMP     [ESCPRM],ESCBUFSIZ      ;BUFFER FULL ?
        JBE     ESCVT_SP1               ;NO
        MOV     [ESCCNT],0              ;EXIT ESC
ESCVT_SP1:
        RET

;-------------------------------------------------------------- 880504
ESCVT_QUAT:
        XOR     [SRMFLG],-1             ;FLIP QUATATION FLAG
        JZ      ESCVT_QUATRET
        SUB     [ESCPTR],2              ;ADJUST POINTER
        DEC     [ESCPRM]                ;ADJUST COUNTER
ESCVT_QUATRET:
        RET

ESCVT_CHAR:
        ADD     [ESCPTR],2
        INC     [ESCPRM]                ;PARAM COUNT
        CMP     [ESCPRM],ESCBUFSIZ      ;BUFFER FULL ?
        JBE     ESCVT_CHR1              ;NO
        MOV     [ESCCNT],0              ;EXIT ESC
        RET
ESCVT_CHR1:
        MOV     BX,[ESCPTR]             ;GET POINTER
        MOV     [BX],CL
        RET

;---------------------------------------------------------------------
        PAGE
;****************************************
;*   CURSOR UP                          *
;*      ESC [ PN  A                     *
;****************************************
ESCVT_CUU:
        CMP     [ESCPRM],1
        JNE     ESCVT_CUURET
        MOV     CX,[SI]                 ;GET PRM
        MOV     AL,[CURLIN]
        XOR     AH,AH
        AND     CX,CX                   ;PARAM = 0 ?
        JNZ     ESCVT_CUU1
        MOV     CX,1                    ;TREAT CX=1
ESCVT_CUU1:
        CMP     AX,CX
        JNB     ESCVT_CUU2
        MOV     CX,AX
ESCVT_CUU2:
        SUB     [CURLIN],CL
        CALL    DSPCSR
ESCVT_CUURET:
        RET

;****************************************
;*   CURSOR DOWN                        *
;*      ESC [ PN  B                     *
;****************************************
ESCVT_CUD:
        CMP     [ESCPRM],1
        JNE     ESCVT_CUDRET
        MOV     CX,[SI]                 ;GET PARAM
        MOV     AL,[ENDLINE]
        SUB     AL,[CURLIN]
        XOR     AH,AH
        AND     CX,CX                   ;PARAM = 0 ?
        JNZ     ESCVT_CUD1
        MOV     CX,1                    ;TREAT CX = 1
ESCVT_CUD1:
        CMP     AX,CX
        JNB     ESCVT_CUD2
        MOV     CX,AX
ESCVT_CUD2:
        ADD     [CURLIN],CL
        CALL    DSPCSR
ESCVT_CUDRET:
        RET

;****************************************
;*   CURSOR FOREWARD                    *
;*      ESC [ PN  C                     *
;****************************************
ESCVT_CUF:
        CMP     [ESCPRM],1
        JNE     ESCVT_CUFRET
        MOV     CX,[SI]                 ;GET PARAM
        MOV     AX,LINEEND
        SUB     AL,[CURCOL]
;----------------------------------------------- DOS5 91/02/19 -------
;PATCH FIX
        JC      ESCVT_CUF3
;---------------------------------------------------------------------
        AND     CX,CX                   ;PARAM = 0 ?
        JNZ     ESCVT_CUF1
        MOV     CX,1
ESCVT_CUF1:
        CMP     AX,CX
        JNB     ESCVT_CUF2
        MOV     CX,AX
ESCVT_CUF2:
        ADD     [CURCOL],CL
;----------------------------------------------- DOS5 91/02/19 -------
;PATCH FIX
ESCVT_CUF3:
;---------------------------------------------------------------------
        CALL    DSPCSR
ESCVT_CUFRET:
        RET

;****************************************
;*   CURSOR BACKWARD                    *
;*      ESC [ PN  D                     *
;****************************************
ESCVT_CUB:
        CMP     [ESCPRM],1
        JNE     ESCVT_CUBRET
        MOV     CX,[SI]                 ;GET PARAM
        MOV     AL,[CURCOL]
        XOR     AH,AH
        AND     CX,CX                   ;PARAM = 0 ?
        JNZ     ESCVT_CUB1
        MOV     CX,1
ESCVT_CUB1:
        CMP     AX,CX
        JNB     ESCVT_CUB2
        MOV     CX,AX
ESCVT_CUB2:
        SUB     [CURCOL],CL
        CALL    DSPCSR
ESCVT_CUBRET:
        RET

        PAGE
;****************************************
;*   CURSOR POSITION                    *
;*      ESC [ PL ;PC H                  *
;*      ESC [ PL ;PC F                  *
;****************************************
ESCVT_CUP:
        CMP     [SRMFLG],0              ;SET/RESET MODE ?
        JNE     ESCVT_CUPRET            ;Y (ILLEGAL ESC)
        CMP     [ESCPRM],2
        JB      ESCVT_CUPHOM            ;NO OPERATION
        MOV     AX,[SI]                 ;GET PARAM (LINE)
        MOV     CL,[ENDLINE]
        CALL    CHKPOS_VT
        MOV     [CURLIN],AL             ;SET LINE
        MOV     AX,2[SI]                ;GET PARAM (COLUMN)
        MOV     CL,LINEEND
        CALL    CHKPOS_VT
        MOV     [CURCOL],AL             ;SET COLUMN
        CALL    DSPCSR                  ;DISPLAY CURSOR
        RET
;       CURSOR HOME
ESCVT_CUPHOM:
        XOR     AX,AX
        CMP     AX,[SI]                 ;PARAM = 00H ?
        JNE     ESCVT_CUPRET
        CALL    HOMERTN                 ;CURSOR HOME
ESCVT_CUPRET:
        MOV     [SRMFLG],0
        RET

;********************************
;*   CHECK LINE/COLUMN          *
;********************************
CHKPOS_VT:
        AND     AX,AX
        JZ      CKPSVT_RET
        DEC     AX                      ;PARAM - 1
        JZ      CKPSVT_RET
        XOR     CH,CH
        CMP     CX,AX
        JNB     CKPSVT_RET
        MOV     AL,CL
CKPSVT_RET:
        RET

        PAGE
;****************************************
;*   ERASE IN DISPLAY                   *
;*      ESC [ PS 'J'                    *
;****************************************
ESCVT_ED:
        CMP     [ESCPRM],1
        JNE     ESCVT_EDRET             ;NO OPERATION
        MOV     AX,[SI]                 ;GET PARAM
        AND     AX,AX                   ;TEST FOR AX=0
        JZ      ESCVT_ED0
        DEC     AX                      ;TEST FOR AX=1
        JZ      ESCVT_ED1
        DEC     AX                      ;TEST FOR AX=2
        JNZ     ESCVT_EDRET             ;ILLEGAL PARAM (NO OPERATION)
;  PARAM = 2 (ERASE ALL OF THE DISPLAY (CURSOR DOES NOT MOVE))
        CALL    CLRRTN
        JMP     short ESCVT_EDRET       ;

;  PARAM = 1 (ERASE FROM THE START OF SCREEN TO THE ACTIVE POSITION)
ESCVT_ED1:
        CALL    PATNCHK                 ;VRAM PATTERN CHECK
        SHR     BX,1
        INC     BX
        MOV     CX,BX                   ;SIZE
        XOR     DI,DI                   ;START ADDR
        CMP     AL,2                    ;IF ACTIVE POS. = KANJI(L)
        JNE     ESCVT_ED000             ; THEN ..
        INC     CX
        JMP     short ESCVT_ED000       ;

;  PARAM = 0 ( ERASE FROM THE ACTIVE POSITION TO THE END OF SCREEN)
ESCVT_ED0:
        CALL    PATNCHK
        MOV     DI,BX                   ;START ADDR
        SHR     BX,1
        MOV     CX,CRTSIZE              
        SUB     CX,BX                   ;SIZE
        CMP     AL,3
        JB      ESCVT_ED000
        SUB     DI,2
        INC     CX
ESCVT_ED000:
        CALL    CRTCLR
        CALL    DSPFKY                  ;IF FKYSW=1 
ESCVT_EDRET:                            ;
        RET
        

;****************************************
;*   ERASE IN LINE                      *
;*      ESC [ PS 'K'                    *
;****************************************
ESCVT_EL:
        CMP     [ESCPRM],1
        JNE     ESCVT_ELRET
        MOV     AX,[SI]                 ;GET PARAM
        AND     AX,AX                   ;TEST FOR AX=0
        JZ      ESCVT_EL0
        DEC     AX                      ;TEST FOR AX=1
        JZ      ESCVT_EL1
        DEC     AX                      ;TEST FOR AX=2
        JNZ     ESCVT_ELRET             ;ILLEGAL PARAM (NO OPERATION)

;  PARAM = 2 (ERASE ALL OF THE LINE)
        MOV     DH,[CURLIN]
        CALL    LINECLR                 ;ERASE ALL OF THE LINE
        JMP     short ESCVT_ELRET       ;

;  PARAM = 1 (ERASE FROM THE START OF THE LINE TO THE ACTIVE POS.)
ESCVT_EL1:
        CALL    PATNCHK
        MOV     DH,[CURLIN]
        MOV     DL,0
        CALL    LCCONV
        MOV     DI,BX                   ;START ADDR
        MOV     CL,[CURCOL]             ;SIZE
        XOR     CH,CH
        INC     CX
        CMP     AL,2
        JNE     ESCVT_EL01              ;
        INC     CX
        JMP     short ESCVT_EL01        ;

;  PARAM = 0 (ERASE FROM THE ACTIVE POSITION TO THE END OF LINE)
ESCVT_EL0:
        CALL    PATNCHK
        MOV     DI,BX                   ;START ADDR
        MOV     BL,[CURCOL]
        XOR     BH,BH
        MOV     CX,LINESIZE
        SUB     CX,BX                   ;SIZE
        CMP     AL,3
        JB      ESCVT_EL01
        SUB     DI,2
        INC     CX
ESCVT_EL01:
        CALL    CRTCLR
ESCVT_ELRET:
        RET

;****************************************
;*   SELECT GRAPHIC RENDITION           *
;*      ESC [ PN ;... ;PN 'M'           *
;****************************************
ESCVT_SGR:
        MOV     DH,00H                  ;                       89/08/21
        MOV     AH,01H                  ;WORK INITIALIZE
        MOV     [SGRFLG],0FFH
        MOV     SI,OFFSET ESCBUF
        MOV     CL,[ESCPRM]             ;NUMBER OF PARAMETER
        XOR     CH,CH
ESCVT_SGR1:
        MOV     BX,[SI]                 ;GET PARAM
        ADD     SI,2
        CMP     BX,48                   ;CHECK PARAM
        JNB     ESCVT_SGR3              ;ILLEGAL PARAM
        CMP     BX,8                    ;SECRET ?
        JE      ESCVT_SGR21             ;Y
        CMP     BX,16                   ;SECRET ?
        JNE     ESCVT_SGR22
ESCVT_SGR21:
        AND     AH,0FEH                 ;SET SECRET
        JMP     short ESCVT_SGR24
ESCVT_SGR22:
        CMP     BX,30                   ;BLACK ?
        JE      ESCVT_SGR23             ;Y
;-----------------------------------------------------  89/08/16  ---
        CMP     BX,40
        JB      VT_SGR210
VT2AT010:
        TEST    ATTRF,0001H
        JNZ     VT_SGR210
        AND     DH,8FH
        ADD     BX,OFFSET ATTRTBL2
        MOV     DL,[BX]
        OR      DH,DL
        JMP     short ESCVT_SGR3
VT_SGR210:
;--------------------------------------------------------------------
        CMP     BX,40                   ;REVERSE BLACK ?
        JNE     ESCVT_SGR24
ESCVT_SGR23:
        MOV     [SGRFLG],1FH            ;SET BLACK STATE
ESCVT_SGR24:
        CMP     BX,17
        JB      ESCVT_SGR25
        AND     AH,1FH
ESCVT_SGR25:
        ADD     BX,OFFSET ESCATTRTBL
        MOV     AL,[BX]                 ;GET ATTRIBUTE
        OR      AH,AL
ESCVT_SGR3:
        LOOP    ESCVT_SGR1

        TEST    AH,0E0H
        JNZ     ESCVT_SGR4
        MOV     AL,[DEFATTR]            ;DEFAULT ATTRIBUTE
        AND     AL,0FEH                 ;RESET SECRET FLAG
        OR      AH,AL
        AND     AH,[SGRFLG]
ESCVT_SGR4:
        MOV     [CURATTR],AH            ;SET ATTRIBUTE
        MOV     DL,AH                   ;                       89/08/16
        MOV     [CURATTR2],DX           ;SET 2BYTE ATTRIBUTE    89/08/16
        RET

;****************************************
;*   INSERT LINE                        *
;*      ESC [ PN  L                     *
;****************************************
ESCVT_IL:
        CMP     [SRMFLG],0              ;SET/RESET MODE ?
        JNE     ESCVT_ILRET             ;Y (ILLEGAL ESC)
        CMP     [ESCPRM],1
        JNE     ESCVT_ILRET
        MOV     CX,[SI]                 ;GET PARAM
        AND     CX,CX                   ;PARAM = 0 ?
        JNZ     ESCVT_IL1
        MOV     CX,1                    ;TREAT CX = 1
ESCVT_IL1:
        PUSH    CX
        MOV     AH,[CURLIN]             ;CURRENT LINE #
        CALL    MLINEDWN                ;ROLL DOWN
        POP     CX
        LOOP    ESCVT_IL1
        CALL    CRRTN                   ;CARRIAGE RETURN
ESCVT_ILRET:
        MOV     [SRMFLG],0
        RET

;****************************************
;*   DELETE LINE                        *
;*      ESC [ PN  M                     *
;****************************************
ESCVT_DL:
        CMP     [ESCPRM],1
        JNE     ESCVT_DLRET
        MOV     CX,[SI]                 ;GET PARAM
        AND     CX,CX                   ;PARAM = 0 ?
        JNZ     ESCVT_DL1
        MOV     CX,1                    ;TREAT CX =1
ESCVT_DL1:
        PUSH    CX
        MOV     AH,[CURLIN]             ;CURRENT LINE #
        CALL    MLINEUP                 ;ROLL UP
        POP     CX
        LOOP    ESCVT_DL1
        CALL    CRRTN                   ;CARRIAGE RETURN
ESCVT_DLRET:
        RET

;****************************************
;*   INTERMEDIATE CHARACTER             *
;*      ESC [ >  OR  ESC [ ?            *
;****************************************
ESCVT_IMC1:                             ;'>'
        MOV     [SRMFLG],1
        RET

ESCVT_IMC2:                             ;'?'
        MOV     [SRMFLG],2
        RET

ESCVT_IMC3:                             ;'='
        MOV     [SRMFLG],3
        RET

;****************************************
;*   RESET MODE                         *
;*      ESC [ XX L                      *
;****************************************
ESCVT_RM:
        CMP     [ESCPRM],1
        JE      ESCVT_01
        JMP     ESCVT_RMRET
ESCVT_01:
        MOV     AX,[SI]                 ;GET PARAM
        CMP     [SRMFLG],1
        JA      ESCVT_DEL
        JB      ESCVT_0
        CMP     AX,1
        JNE     ESCVT_1
        MOV     [FKYSW],0
        CALL    FKYDSP                  ;DISABLE BOTTOM LINE
ESCVT_0:
        JMP     short ESCVT_RMRET
 ESCVT_1:
        CMP     AX,3
        JNE     ESCVT_CON
;-----------------------------------------------------870825--------------
;       MOV     LINMOD,1
;----------------
        MOV     CL,1                    ;
        TEST    [SYS_501],00001000B     ;HW MODE ?
        JNZ     ESCVT_1HN               ;IF H-MODE
        MOV     CL,0                    ;  THEN LINMOD = 1
ESCVT_1HN:                              ;  ELSE LINMOD = 0
        MOV     [LINMOD],CL             ;SET FLAG
;-------------------------------------------------------------------------
        CALL    CHGLIN
        JMP     short ESCVT_RMRET
 ESCVT_CON:
        CMP     AX,5                    ;PARAM = 5 ?
        JNE     ESCVT_RMRET             ;NO
        MOV     [CSRSW],1               ;CURSOR ON
        MOV     AH,11H                  ;85.02.01
        INT     18H                     ;85.02.01
        CALL    DSPCSR
        JMP     short ESCVT_RMRET
 ESCVT_DEL:
        CMP     [SRMFLG],2
        JA      ESCVT_RMRET             ;SRMFLG > 2 , IGNORE
        CMP     AX,7                    ;PARAM = 7 ?
;-----------------------------------------------------  89/08/16  ---
        JNE     VT_RM010                ;NO
        MOV     [WRAPMOD],1             ;"DISCARD AT END OF LINE"
        JMP     short ESCVT_RMRET
VT_RM010:
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   patch10:near

        call    patch10
        db      2 dup (90h)
;---------------
;       TEST    byte PTR [BIOSF_3],80H  ;NPC CHECK      89/08/21
;---------------------------------------------------------------------
        JZ      ESCVT_RMRET                     ;NO JMP         89/08/21
        CMP     AX,5                    ;1BYTE ATTRIBUTE
        JNE     VT_RM020
        TEST    ATTRF,0001H
        JNZ     ESCVT_RMRET
        MOV     AX,0001H
        CALL    CRTMD1AT                ;1BYTE ATTR SET
        JMP     SHORT ESCVT_RMRET
VT_RM020:
        CMP     AX,3                    ;400 DOT MODE
        JNE     ESCVT_RMRET
        TEST    CRTDOTF,0001H
        JNZ     ESCVT_RMRET
        MOV     AX,0011H
        CALL    CRTMD400
;--------------------------------------------------------------------
ESCVT_RMRET:
        MOV     [SRMFLG],0
        RET
 
;****************************************
;*   SET MODE                           *
;*      ESC [ XX H                      *
;****************************************
ESCVT_SM:
        CMP     [ESCPRM],1
        JE      ESCVT_SM10
        JMP     ESCVT_SMRET
ESCVT_SM10:
        MOV     AX,[SI]                 ;GET PARAM
        CMP     [SRMFLG],1
        JA      ESCVT_WEL
        JB      ESCVT_SM15
        CMP     AX,1
        JNE     ESCVT_L25               ;------------- H/N DOS --------
        MOV     [FKYSW],2
        CALL    FKYDSP                  ;ENABLE BOTTOM LINE
ESCVT_SM15:
        JMP     short ESCVT_SMRET
;----------------------------- SELECT 20LINE (NORMAL MODE) ------------
ESCVT_L25:
        CMP     AX,3                    ;PARAM = 3 ?
        JNE     ESCVT_COF               ;NO, NEXT
        TEST    [SYS_501],00001000B     ;NORMAL MODE ?
        JNZ     ESCVT_SMRET             ;NO, IGNORE
;--------------------------------------------------------- 90/03/19 --
        CMP     CRTDOTF,0000H           ;480 DOT                89/08/16
        JZ      ESCVT_SMRET             ;THEN JMP               89/08/16
;---------------------------------------------------------------------
        MOV     [LINMOD],1              ;
        CALL    CHGLIN                  ;CHG LINMOD 0 -> 1
        JMP     short ESCVT_SMRET
;----------------------------------------------------------------------
 ESCVT_COF:
        CMP     AX,5                    ;PARAM = 5 ?
        JNE     ESCVT_SMRET
        MOV     [CSRSW],0               ;CURSOR OFF
        MOV     AH,12H                  ;
        INT     18H                     ;BIOS
        JMP     short ESCVT_SMRET
 ESCVT_WEL:
        CMP     [SRMFLG],2
        JA      ESCVT_SMRET             ;SRMFLG > 2 , IGNORE
        CMP     AX,7
;-----------------------------------------------------  89/08/16  ---
        JNE     VT_SM010
        MOV     [WRAPMOD],0             ;"WRAP AROUND AT END OF LINE"
        JMP     short ESCVT_SMRET
VT_SM010:
;
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   patch10:near

        call    patch10
        db      2 dup (90h)
;---------------
;       TEST    byte PTR [BIOSF_3],80H  ;NPC CHECK      89/08/21
;---------------------------------------------------------------------
        JZ      ESCVT_SMRET             ;NO JMP         89/08/21
        CMP     AX,5                    ; 2BYTE ATTR
        JNE     VT_SM020
        TEST    WORD PTR ATTRF,0001H
        JE      ESCVT_SMRET
        MOV     AX,0000H
        CALL    CRTMD2AT                ; 2BYTE ATTR SET
        JMP     SHORT ESCVT_SMRET
VT_SM020:
        CMP     AX,3                    ;480 MODE
        JNE     ESCVT_SMRET
        TEST    WORD PTR CRTDOTF,0001H
        JE      ESCVT_SMRET
        MOV     AX,0010H
        CALL    CRTMD480                ;480DOT SET
;--------------------------------------------------------------------
ESCVT_SMRET:
        MOV     [SRMFLG],0
        RET

;****************************************
;*   DEVICE STATUS REPORT               *
;*        --> CURSOR POSITION REPORT    *
;*      ESC [ 6 N --> ESC [ PL ;PC  R   *
;****************************************
ESCVT_DSR:
        CMP     [ESCPRM],1
        JNE     ESCVT_DSRRET
        MOV     AX,[SI]
        CMP     [SRMFLG],1
        JNE     ESCVT_DSR10
        CMP     AX,3
        JNE     ESCVT_DSR10
;--------------------------------------- ADD H/W MODE CHECK ------------
        TEST    [SYS_501],00001000B     ;HIRESO MODE ?
        JZ      ESCVT_SMRET             ;NO, IGNORE
;-----------------------------------------------------------------------
        MOV     [LINMOD],0
        CALL    CHGLIN
        JMP     ESCVT_SMRET             ;
ESCVT_DSR10:
        CMP     AX,6                    ;PARAM = 6 ?
        JNE     ESCVT_DSRRET            ;NO, ILLEGAL
        MOV     AL,[CURLIN]
        MOV     AH,[CURCOL]
        CALL    BINDEC
        MOV     [ESCCPRLIN],AX          ;SET LINE
        MOV     AL,[CURCOL]
        CALL    BINDEC
        MOV     [ESCCPRCOL],AX          ;SET COLUMN
        MOV     [FKYCNT],8
        MOV     [FKYPTR],OFFSET ESCCPRBUF
ESCVT_DSRRET:
        RET
;
;*** SUBROUTINE
BINDEC:                                 ;BINARY TO DECIMAL(ASCII)
        INC     AL
        XOR     AH,AH
        MOV     CL,10
        DIV     CL
        OR      AX,3030H
        RET

;****************************************
;*   SAVE CURSOR POSITION (WITH ATTR)   *
;*      ESC [ S                         *
;****************************************
ESCVT_PSCP:
        CMP     [ESCPRM],1
        JNE     ESCVT_PSCPRET
        MOV     AX,[SI]                 ;GET PARAM
        AND     AX,AX
        JNZ     ESCVT_PSCPRET
        MOV     AL,[CURLIN]
        MOV     AH,[CURCOL]
        MOV     [ESCPOSSAVE],AX         ;SAVE
        MOV     AX,[CURATTR2]           ;                       89/08/16
        MOV     [ATRSAVE2],AX           ;                       89/08/16
        MOV     AL,[CURATTR]            ;GET CURR. ATTRIBUTE
        MOV     [ESCATRSAVE],AL
ESCVT_PSCPRET:
        RET

;****************************************
;*   SET CURSOR POSITION (WITH ATTR)    *
;*      ESC [ U                         *
;****************************************
ESCVT_PRCP:
        CMP     [ESCPRM],1
        JNE     ESCVT_PRCPRET
        MOV     AX,[SI]                 ;GET PARAM
        AND     AX,AX
        JNZ     ESCVT_PRCPRET
        MOV     AX,[ESCPOSSAVE]         ;GET SAVED LINE/COLUMN
        MOV     [CURLIN],AL
        MOV     [CURCOL],AH
        MOV     AX,[ATRSAVE2]           ;                       89/08/16
        MOV     [CURATTR2],AX           ;                       89/08/16
        MOV     AL,[ESCATRSAVE]         ;GET SAVED ATTRIBUTE
        MOV     [CURATTR],AL
        CALL    DSPCSR
ESCVT_PRCPRET:
        RET

;-------------------------------------------------------------- 880504
;****************************************
;*   KEYBOARD REASSIGNMENT              *
;*      ESC [ xxxxxxxxxx p              *
;****************************************
ESCVT_KASS:
;;;;    CMP     [ESCPRM],1                      ;COMMENT ------ 880520
;;;;    JE      ESCVT_KASSRET                   ;COMMENT ------ 880520

        PUSH    ES
        mov     ES,cs:[bdata_seg]               ;               @dos5

        MOV     SI,OFFSET ESCBUF
        MOV     DI,SI                   ;DI := ESCBUF ADDR
        MOV     CX,0001
        ADD     SI,2
ESCVT_KA00:
        LODSW                           ;GET CHAR LENGTH
        OR      AX,AX
        JZ      ESCVT_KA05
        INC     CX
        JMP     ESCVT_KA00
ESCVT_KA05:
        MOV     SI,DI
        PUSH    CX
ESCVT_KA10:
        MOVSB                           ;PACK PARAMETER (WORD TO BYTE)
        INC     SI                      ;WORD
        LOOP    ESCVT_KA10
        POP     CX

        MOV     SI,DI
        DEC     SI                      ;SI = LAST CHAR
        INC     DI                      ;DI = LAST CHAR + 2
        XOR     AX,AX
        MOV     AH,BYTE PTR [ESCBUF]    ;GET FIRST CHAR
        OR      AH,AH
        JNZ     ESCVT_KA20              ;NOT SPECIAL KEY
        DEC     CL
        DEC     DI                      ;DI = LAST CHAR + 1
        MOV     AL,BYTE PTR [ESCBUF+1]
ESCVT_KA20:
        PUSH    CX
        STD
        REP     MOVSB                   ;PARAM SHIFT TO RIGHT
        CLD
        POP     CX
        ADD     CX,2                    ;ADJUST ENTRY SIZE
        MOV     BYTE PTR [ESCBUF],CL    ;SET LENGTH OF ENTRY
        MOV     WORD PTR [ESCBUF+1],AX  ;SET CHAR

        MOV     CL,13                   ;SET SOFT KEY FUNCTION
        MOV     DX,OFFSET ESCBUF
        MOV     AX,0101H                ;ADD DATA KEY
        INT     220

        POP     ES
ESCVT_KASSRET:
        RET
;---------------------------------------------------------------------

;********************************
;*  NO OPERATION                *
;********************************
ESCVT_NOP:
        RET

        PAGE
;********************************************************
;*                                                      *
;*   ASCII CONTROL CODE                                 *
;*                                                      *
;********************************************************

;************************************************
;*                                              *
;*      ESCAPE                          1B(^[)  *
;*                                              *
;************************************************
ESCRTN:
        PUSH    ES                      ;
        MOV     [ESCPTR],OFFSET ESCBUF
        MOV     [ESCCNT],1              ;ENTER  ESC_MODE
        MOV     [ESCPRM],1
        MOV     DI,OFFSET ESCBUF
        MOV     AX,0
        MOV     CX,ESCBUFSIZ
        MOV     DX,DS
        MOV     ES,DX                   ;DEST. SEGMENT
        REP     STOSW                   ;
        POP     ES                      ;
        RET

;************************************************
;*                                              *
;*      BELL                            07(^G)  *
;*                                              *
;************************************************
BELRTN_FAR      PROC    FAR
        CALL    BELRTN
        RET
BELRTN_FAR      ENDP

BELRTN:
        MOV     AH,17H                  ;
        INT     18H                     ;BUZZER ON
        MOV     CX,05A64H+1428H         ;SET COUNTER
BEL1:
BEL2:
        PUSH    AX
        NOP
        POP     AX
        LOOP    BEL2                    ;ABOUT 0.5 SEC

        MOV     AH,18H                  ;
        INT     18H                     ;BUZZER OFF
        RET

;************************************************
;*                                              *
;*      HORIZONTAL TAB                  09(^I)  *
;*                                              *
;************************************************
TABRTN:
        MOV     AL,[CURCOL]
        ADD     AL,8                    ;
        MOV     CL,3                    ;   AX  = (AL+8) / 8 * 8
        SHR     AL,CL                   ;
        MOV     CL,8                    ;
        MUL     CL                      ;
        MOV     [CURCOL],AL
        CMP     AL,LINEEND
        JB      TAB1
        MOV     [CURCOL],LINEEND
        CALL    FSRTN                   ;NEXT LINE
        RET

TAB1:   CALL    DSPCSR
        RET

;************************************************
;*                                              *
;*      CURSOR BACKWARD                 0B(^H)  *
;*                                              *
;************************************************
BSRTN:
        CMP     [CURCOL],0
        JE      BS1
        DEC     [CURCOL]                ;COLUMN - 1
        JMP     SHORT   BS2

BS1:    CMP     [CURLIN],0              ;CURSOR = HOME  POSITION ?
        JE      BSRTNRET                ;YES (NOP)
        DEC     [CURLIN]                ;LINE - 1
        MOV     [CURCOL],LINEEND
BS2:    CALL    DSPCSR                  ;DISPLAY CURSOR
BSRTNRET:
        RET

;************************************************
;*                                              *
;*      CURSOR UP                       0B(^K)  *
;*                                              *
;************************************************
UPRTN:
        CMP     [CURLIN],0              ;LINE = 0 ?
        JE      UPRTNRET                ;YES. (NOP)
        DEC     [CURLIN]                ;LINE - 1
        CALL    DSPCSR                  ;CURSOR DISPLAY 83/2/14
UPRTNRET:
        RET

;************************************************
;*                                              *
;*      LINE FEED                       0A(^J)  *
;*                                              *
;************************************************
LFRTN:
        MOV     AL,[CURLIN]             ;
        CMP     AL,[ENDLINE]            ;CURRENT LINE = ENDLINE ?
        JE      LF1                     ;YES.
        INC     [CURLIN]                ;LINE + 1
        CALL    DSPCSR                  ;DISPLAY CURSOR
        RET

LF1:    CALL    ROLLUP                  ;SCROLL UP
        RET

;************************************************
;*                                              *
;*      CARRIAGE RETURN                 0D(^M)  *
;*                                              *
;************************************************
CRRTN:
        MOV     [CURCOL],0
        CALL    DSPCSR                  ;DISPLAY CURSOR
        RET

;************************************************
;*                                              *
;*      CURSOR HOME                     1E(^^)  *
;*                                              *
;************************************************
HOMERTN_FAR     PROC    FAR
        CALL    HOMERTN
        RET
HOMERTN_FAR     ENDP

HOMERTN:
        MOV     [CURLIN],0              ;HOME POSITION
        MOV     [CURCOL],0              ; LINE  = 0  COLUMN = 0
        CALL    DSPCSR                  ;DISPLAY CURSOR
        RET

;************************************************
;*                                              *
;*      CLEAR SCREEN                    1A(^Z)  *
;*                                              *
;*      NOTE: CURSOR DOES NOT MOVE              *
;*                                              *
;************************************************
CLRRTN_FAR      PROC    FAR
        CALL    CLRRTN
        RET
CLRRTN_FAR ENDP


CLRRTN:
        XOR     DI,DI                   ;POS.
        MOV     CX,CRTSIZE
        CALL    CRTCLR                  ;ERASE ALL OF THE DISPLAY
        CALL    DSPFKY                  ;DISPLAY FUNCTION KEYS
        CALL    HOMERTN                 ;CURSOR MOVES TO HOME POS.
        RET

;************************************************
;*                                              *
;*      CURSOR FOREWARD                 0C(^L)  *
;*                                              *
;************************************************

FSRTN:
        INC     [CURCOL]                ;COLUMN + 1
        CMP     [CURCOL],LINEEND        ;END OF LINE ?
        JBE     FSRTNRET
        MOV     [CURCOL],0              ;COLUMN = LEFT MARJIN
        MOV     AL,[CURLIN]             ;GET CURRENT LINE
        INC     [CURLIN]                ;
        CMP     AL,[ENDLINE]            ;Q. LINE = ENDLINE ?
        JNE     FSRTNRET                ;NO.
        MOV     [CURLIN],AL             ;
        CALL    ROLLUP                  ;SCROLL UP
FSRTNRET:
        CALL    DSPCSR                  ;CURSOR DISP
        RET                             ;

        PAGE
;********************************************************
;*                                                      *
;*      DISPLAY ASCII CHARACTER                         *
;*                      WITH CURRENT ATTRIBUTE          *
;*                                                      *
;********************************************************

DATARTN:
        CMP     [CURCOL],LINESIZE
        JB      DATARTN1                ;DISPLAY DATA
        CMP     [WRAPMOD],0             ;WRAP AROUND MODE ?
        JE      DATARTN0                ;YES
        RET                             ;DISCARD AT EOL
DATARTN0:
        PUSH    CX                      ;SAVE DATA
        CALL    FSRTN                   ;NEXT LINE
        POP     CX                      ;
DATARTN1:
        CMP     [SFTJISMOD],0           ;SHFTJIS(KANJI) MODE ?
        JE      DATADSP                 ;NO,
        CMP     [KANJICNT],0            ;SHIFT JIS 2ND BYTE ?
        JNE     DATACNV                 ;YES,
        CMP     CL,81H                  ;
        JB      DATADSP
        CMP     CL,0A0H
        JB      DATARTN2
        CMP     CL,0E0H
        JB      DATADSP
        CMP     CL,0FDH
        JNB     DATADSP
;
; SHIFT JIS FIRST BYTE
DATARTN2:
        MOV     [K1STSAV],CL            ;SAVE 1ST BYTE
        MOV     [KANJICNT],1
        RET
;
; SHIFT JIS -> JIS C6226
DATACNV:
        MOV     CH,[K1STSAV]            ;GET 1ST BYTE
        CALL    D_MCONV                 ;CONVERT
        XCHG    CH,CL
        SUB     CL,20H
        JMP     short DATADSP1
;
; DATA DISPLAY
DATADSP:
        MOV     CH,0                    ;ANK (CODE_H = 00H)
DATADSP1:
        CALL    PATNCHK                 ;CHECK VRAM DATA
        CALL    CODECHK
        SHL     AX,1
        ADD     AL,DL
        SHL     AX,1
        MOV     DI,BX
        MOV     BX,AX
        ADD     BX,OFFSET DD_RTNTBL
        MOV     BX,CS:[BX]                      ;GET SUBROUTINE ADDR
        PUSH    ES
        MOV     AX,[VRAMSEG]
        MOV     ES,AX
        MOV     AX,CX                   ;DATA
        CALL    BX
        POP     ES
        MOV     [KANJICNT],0

        ADD     [CURCOL],AL             ;CURCOL + 1 (2)
        CALL    DSPCSR                  ;DISPLAY CURSOR
DATARTNRET:
        RET

;************************************************
;*                                              *
;*      CONVERT SHIFT JIS TO JIS                *
;*                                              *
;*      INPUT : CX = SHIFT JIS                  *
;*      OUTPUT: CX = JIS C6226                  *
;*                                              *
;************************************************

D_MCONV_FAR     PROC    FAR
        CALL    D_MCONV
        RET
D_MCONV_FAR     ENDP


D_MCONV:
        CMP     CH,80H                  ;IF CH=80H
        JE      D_MCONV4                ; THEN RETURN
        CMP     CH,0A0H                 ; ELSE IF CH < A0H
        JNB     D_MCONV0                ;       THEN CH := CH-70H
        SUB     CH,70H
        JMP     short D_MCONV1
D_MCONV0:
        SUB     CH,0B0H                 ;
D_MCONV1:
        OR      CL,CL                   ;IF CL <= 80H
        JNS     D_MCONV2                ; THEN CL := CL-1
        DEC     CL
D_MCONV2:
        ADD     CH,CH                   ;CH := CH * 2
        CMP     CL,9EH                  ;IF CL >= 9EH
        JB      D_MCONV25               ; THEN CL := CL-5EH
        SUB     CL,5EH
        JMP     short D_MCONV3
D_MCONV25:
        DEC     CH                      ; ELSE CH := CH-1
D_MCONV3:
        SUB     CL,1FH                  ;CL := CL-1FH
D_MCONV4:
        RET

;************************************************
;*                                              *
;*      VRAM DATA GET & CHECK                   *
;*                                              *
;************************************************
PATNCHK:
        PUSH    ES
        PUSH    CX
        MOV     AX,[VRAMSEG]
        MOV     ES,AX                   ;ES = VRAM SEG
        MOV     DH,[CURLIN]
        MOV     DL,[CURCOL]
        CALL    LCCONV
        MOV     CX,ES:[BX]              ;GET DATA IN CURR. POS.
        CALL    CODECHK
        MOV     AX,2
        CMP     DL,1                    ;DATA = KANJI(L) ?
        JE      PTNCHKRET               ;Y
        MOV     DH,DL                   ;SAVE RTNCODE
        MOV     CX,ES:2[BX]
        CALL    CODECHK
        MOV     AX,0                    ;RETURN CODE (AX)
        CMP     DH,2
        JNE     PTNCHK1                 ;0: ANK-ANK
        MOV     AX,3                    ;1: ANK-KNJ
PTNCHK1:                                ;2: KNJ
        CMP     DL,0                    ;3: KNJ(R)-ANK
        JE      PTNCHKRET               ;4: KNJ(R)-KNJ
        INC     AX
PTNCHKRET:
        POP     CX
        POP     ES
        RET

;************************************************
;*                                              *
;*      CODE CHECK                              *
;*              ENTRY: CX = CODE (H,L)          *
;*              EXIT : DL = RTNCODE             *
;*                                              *
;************************************************
CODECHK:
        MOV     DL,0
        CMP     CH,0                    ;ANK ?
        JE      CODCHKRET               ;Y
        CMP     CH,0FFH                 ;ANK ?
        JE      CODCHKRET               ;Y
        CMP     CL,09H                  ;KANJI(HANKAKU) ?
        JB      CODCHK1
        CMP     CL,0CH
        JB      CODCHKRET               ;Y
CODCHK1:
        MOV     DL,1
        OR      CL,CL                   ;KANJI(LEFT) ?
        JNS     CODCHKRET               ;Y
        MOV     DL,2                    ;KANJI(RIGHT)
CODCHKRET:
        RET

;************************************************
;*                                              *
;*      DSP DATA SUBROUTINES                    *
;*                                              *
;************************************************

DD_ANK_L:                               ;WRITE ANK TO KANJI(L) FIELD
        CALL    NXTCLR
        CALL    W1CHR
        RET

DD_ANK_R:                               ;WRITE ANK TO KANJI(R) FIELD
        CALL    PRECLR
        CALL    W1CHR
        RET
;
DD_KNJ_AL:                              ;WRITE KANJI
        CALL    NXTCLR2                 ;       ANK-KANJI(L) FIELD
        CALL    W2CHR
        RET
;
DD_KNJ_RA:                              ;WRITE KANJI
        CALL    PRECLR                  ;       KANJI(R)-ANK FIELD
        CALL    W2CHR
        RET
;
DD_KNJ_RL:                              ;WRITE KANJI
        CALL    PRECLR                  ;       KANJI(R)-KANJI FIELD
        CALL    NXTCLR2
        CALL    W2CHR
        RET
;
W1CHR:                                  ;WRITE ANK(HANKAKU) CHAR
        MOV     ES:[DI],AX              ;WRITE CODE
        ADD     DI,ATTROFST
        MOV     AX,[CURATTR2]           ;CURR. ATTRIBUTE        89/08/16
        MOV     ES:[DI],AX              ;WRITE ATTRIBUTE
        MOV     AL,1
        RET
;
W2CHR:                                  ;WRITE KANJI CHAR
        CMP     [CURCOL],LINEEND        ;CURR POS = END OF LINE ?
        JB      W2CHR1                  ;N
        PUSH    AX                      ;
        MOV     CX,0020H                ;SPACE
        MOV     ES:[DI],CX              ;
        CALL    FSRTN                   ;SCROLL UP
        MOV     DH,[CURLIN]             ;GET LINE & COLUMN
        MOV     DL,[CURCOL]             ;
        CALL    LCCONV                  ;L,C TO VRAM ADDR
        MOV     DI,BX                   ;VRAM ADDR
        POP     AX
W2CHR1:
        STOSW                           ;WRITE FIRST WORD
        OR      AL,80H
        STOSW                           ;WRITE SCOND WORD(RIGHT)
        SUB     DI,4
        ADD     DI,ATTROFST
        MOV     AX,[CURATTR2]           ;CURR. ATTRIBUTE        89/08/16
        STOSW                           ;WRITE ATTRIBUTE
        STOSW                           ;WRITE ATTRIBUTE
        MOV     AL,2
        RET
;
PRECLR:                                 ;PRECEDING CHAR CLEAR
        PUSH    DI
        SUB     DI,2
        MOV     CX,0020H                ;SPACE
        MOV     ES:[DI],CX
        POP     DI
        RET
;
NXTCLR:                                 ;NEXT CHAR CLEAR
        PUSH    DI
        ADD     DI,2
        MOV     CX,0020H                ;SPACE
        MOV     ES:[DI],CX
        POP     DI
        RET
;
NXTCLR2:                                ;
        PUSH    DI
        ADD     DI,4
        MOV     CX,0020H                ;SPACE
        MOV     ES:[DI],CX
        POP     DI
        RET

        PAGE
;************************************************
;*                                              *
;*      SCROLL UP                               *
;*                                              *
;************************************************
ROLLUP:
        MOV     AH,[ROLTOP]
        MOV     [WAITCNT],1
        OR      [ROLSW],0
        JZ      ROLLUP1
        MOV     [WAITCNT],0A000H+4000H
ROLLUP1:
MLINEUP:
        MOV     CL,[ENDLINE]
        XOR     CH,CH
        SUB     CL,AH
        JZ      MLINUP2                 ;START_L = END_L
        CLD
        PUSH    ES
        PUSH    DS
        MOV     DH,AH                   ;START LINE NO.         @dos5
        XOR     DL,DL
        CALL    LCCONV                  ;VRAM RELATIVE ADDR
        MOV     DX,[VRAMSEG]
        MOV     ES,DX
        MOV     DS,DX                   ;SET VRAM SEGMENT ADDR
        MOV     DX,BX
        ADD     DX,LINESIZE*2
MLINUP1:
        PUSH    CX
        MOV     SI,DX                   ;SRCE PTR
        MOV     DI,BX                   ;DEST PTR
        MOV     CX,LINESIZE
        REP     MOVSW                   ;CODE MOVE
        XCHG    SI,DX
        XCHG    DI,BX
        ADD     SI,ATTROFST
        ADD     DI,ATTROFST
        MOV     CX,LINESIZE
        REP     MOVSW                   ;ATTR MOVE
;
        POP     CX
        LOOP    MLINUP1
        POP     DS
        POP     ES
MLINUP2:
        MOV     DH,[ENDLINE]
        CALL    LINECLR
        MOV     CX,[WAITCNT]
MLINUP3:
        NOP
        LOOP    MLINUP3
        RET
;
;************************************************
;*                                              *
;*      SCROLL DOWN                             *
;*                                              *
;************************************************
ROLDOWN:
        MOV     AH,[ROLTOP]

MLINEDWN:
        MOV     CL,[ENDLINE]
        XOR     CH,CH
        SUB     CL,AH
        JZ      MLINDN2                 ;START_L = END_L
        STD
        PUSH    ES
        PUSH    DS
        MOV     DH,[ENDLINE]            ;START LINE NO.
        MOV     DL,LINEEND
        CALL    LCCONV
        MOV     DX,[VRAMSEG]
        MOV     ES,DX
        MOV     DS,DX                   ;SET VRAM SEGMENT
        MOV     DX,BX
        SUB     DX,LINESIZE*2
MLINDN1:
        PUSH    CX
        MOV     SI,DX
        MOV     DI,BX
        MOV     CX,LINESIZE
        REP     MOVSW                   ;CODE MOVE
        XCHG    SI,DX
        XCHG    DI,BX
        ADD     SI,ATTROFST
        ADD     DI,ATTROFST
        MOV     CX,LINESIZE
        REP     MOVSW                   ;ATTR MOVE
        POP     CX
        LOOP    MLINDN1                 ;PRECEDING LINE
        POP     DS
        POP     ES
MLINDN2:
        CLD
        MOV     DH,AH                   ;CLEAR
        CALL    LINECLR
        RET

        PAGE
;************************************************
;*                                              *
;*      DISPLAY FUNCTION KEYS                   *
;*                                              *
;*      INPUT:  NONE                            *
;*      OUTPUT: NONE                            *
;*                                              *
;************************************************
DSPFKY:
        CMP     [FKYSW],0               ;NO DISP MODE ?
        JNE     DSPFKY00                ;N
        RET
DSPFKY00:
        PUSH    ES
        MOV     AX,[VRAMSEG]
        MOV     ES,AX
        MOV     DH,[ENDLINE]
        INC     DH
        XOR     DL,DL
        CALL    LCCONV
        MOV     DI,BX
        MOV     CX,FKYBUFSIZ
        MOV     AX,[NULCHR]
        REP     STOSW
 ;
        MOV     SI,OFFSET FKYTBL+1      ;
        CMP     [FKYSW],2               ;SHIFT_FUNC ?
        JB      DSPFKY0                 ;NO,
        MOV     SI,OFFSET FKYTBL2+1     ;
;
;  DISPLAY FUNCTION KEY _ LIST
;
DSPFKY0:
        MOV     DI,BX
        ADD     DI,2
        MOV     AX,WORD PTR [MODMARK1]
        PUSH    AX                      ;SET ' 'G'	
        CALL    FKYDSP_S                ;
        POP     AX                      ;
        MOV     AL,AH
        CALL    FKYDSP_S                ;SET '*' OR ' '
        ADD     DI,2
;
        MOV     CX,2                    ;SET COUNTER 1
DSPFKY1:
        PUSH    CX                      ;
        MOV     CX,5                    ;SET COUNTER 2  
DSPFKY2:
        PUSH    CX                      ;
        MOV     [FKYD_KCNT],0
        LODSB
        CALL    FKYDSP_S
        LODSB
        CALL    FKYDSP_S
        LODSB
        CALL    FKYDSP_S
        LODSB
        CALL    FKYDSP_S
        LODSB
        CALL    FKYDSP_S
        LODSB
        CALL    FKYDSP_S
        CMP     [FKYD_KCNT],0           ;LAST CHAR = KANJI 1ST ? 871001
        JE      DSPFKY3                 ;NO,                    871001
        ADD     DI,2                    ;INCREMENT DI           871001
DSPFKY3:                                ;                       871001
        POP     CX                      ;
        ADD     SI,10                   ;NEXT   TABLE
        ADD     DI,2
        LOOP    DSPFKY2
        POP     CX                      ;
        ADD     DI,6
        LOOP    DSPFKY1                 ;
;
;  SET ATTRIBUTE
;
        MOV     DI,BX                   ;
        ADD     DI,ATTROFST             ;ATTR MEM OFFSET
        MOV     CX,4                    ;
        MOV     AX,[DEFATTR2]           ;                       89/08/22
;       XOR     AH,AH                   ;                       89/08/22
        REP     STOSW                   ;FIRST 4 BYTE

        MOV     CX,2                    ;
DSPFKY4:
        PUSH    CX                      ;
        MOV     CX,5                    ;
DSPFKY5:
        PUSH    CX                      ;
        MOV     AX,[DEFATTR2]           ;                       89/08/22
        OR      AL,04H                  ;REVERSE ATTRIBUTE
        MOV     CX,6                    ;
        REP     STOSW                   ;
        MOV     AX,[DEFATTR2]           ;DEFAULT ATTRIB         89/08/22
        STOSW                           ;
        POP     CX                      ;
        LOOP    DSPFKY5                 ;REPEAT 5 TIMES
        MOV     CX,3                    ;DEFAULT ATTRIB
        REP     STOSW                   ;
        POP     CX                      ;
        LOOP    DSPFKY4                 ;REPEAT 2 TIMES
        POP     ES
        RET                             ;RETURN TO CALLER

;
;SUBROUTINE

FKYDSP_S:
        CMP     [SFTJISMOD],0
        JE      FKYDSP_S_1B
        CMP     [FKYD_KCNT],0
        JNE     FKYDSP_S_2B
        CMP     AL,81H
        JB      FKYDSP_S_1B
        CMP     AL,0A0H
        JB      FKYDSP_S1
        CMP     AL,0E0H
        JB      FKYDSP_S_1B
        CMP     AL,0FCH
        JA      FKYDSP_S_1B
FKYDSP_S1:
        MOV     [FKYD_K1SAV],AL
        MOV     [FKYD_KCNT],1
        RET
FKYDSP_S_2B:
        MOV     CH,[FKYD_K1SAV]
        MOV     CL,AL
        CALL    D_MCONV
        XCHG    CH,CL
        MOV     AX,CX
        SUB     AL,20H
        STOSW
        STOSW
        MOV     [FKYD_KCNT],0
        RET
FKYDSP_S_1B:
        XOR     AH,AH
        STOSW
        RET
;
;************************************************
;*                                              *
;*      CONVERT LINE,COLUMN TO                  *
;*                      VRAM ADDRESS            *
;*                                              *
;*      INPUT:  (DH)=LINE                       *
;*              (DL)=COLUMN                     *
;*      OUTPUT: (BX)=VRAM ADDRESS               *
;*                                              *
;************************************************
LCCONV:
        XOR     BX,BX
        MOV     BL,DH
        SHL     BX,1
        ADD     BX,OFFSET LINETBL
        MOV     BX,DS:[BX]              ;GET TABLE CONTENT
        XOR     DH,DH                   ;
        SHL     DL,1                    ;(DL)*2
        ADD     BX,DX                   ;
        RET                             ;ON EXIT: (BX)=VRAM ADDRESS
;
;************************************************
;*                                              *
;*      LINE CLEAR                              *
;*                                              *
;************************************************
;
LINECLR:
        MOV     DL,0                    ;COLUMN = 0
        CALL    LCCONV                  ;CONVERT
        MOV     DI,BX                   ;SET POINTER
        MOV     CX,LINESIZE             ;SET COUNTER
        CALL    CRTCLR
        RET
;
;************************************************
;*                                              *
;*      SCREEN CLEAR                            *
;*                                              *
;************************************************
;
CRTCLR:
        CLD
        PUSH    ES
        MOV     AX,[VRAMSEG]            ;VRAM SEGMENT
        MOV     ES,AX
        MOV     DX,CX                   ;COUNTER
        MOV     BX,DI                   ;SAVE POINTER
        MOV     AX,[NULCHR]
        REP     STOSW                   ;STORE STRING (NULL CHAR)
        MOV     AX,[DEFATTR2]           ;SET DEFAULT ATTRIBUTE  89/08/22
        MOV     CX,DX
        MOV     DI,BX
        ADD     DI,ATTROFST
        REP     STOSW                   ;STORE STRING (ATTR)
        POP     ES
;----------------------------------------------- DOS5A 93/01/18 ------
;<patch BIOS50-P32>

DSPCSRRET:                              ;only change label location
;---------------------------------------------------------------------
        RET
;
;************************************************
;*                                              *
;*      DISPLAY CURSOR                          *
;*                                              *
;************************************************
;
DSPCSR:
        CMP     [CSRSW],0               ;CURSOR SWITCH  = 0 ?
        JE      DSPCSRRET               ;YES.
        MOV     DH,[CURLIN]             ;GET CURRENT LINE
        MOV     DL,[CURCOL]             ;GET CURRENT COLUMN
        CMP     DL,LINESIZE             ;DUMMY POSITION ?
        JB      DSPCSR0                 ;NO
        DEC     DL                      ;
DSPCSR0:
        CALL    LCCONV                  ;CONVERT
        MOV     AH,13H                  ;SET CURSOR
        MOV     DX,BX
;----------------------------------------------- DOS5A 93/01/18 ------
;<patch BIOS50-P32>

        extrn   patch_p32:near

        jmp     patch_p32
;---------------
;       INT     18H                     ;
;DSPCSRRET:
;       RET
;---------------------------------------------------------------------
;
;******************** END CONSOLE ************************************
;
CONSOLE_CODE_END:
CONSOLE_END:
        PUBLIC  CONSOLE_CODE_END
        PUBLIC  CONSOLE_END

Bios_Code       ends
        END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\biostruc.inc ===
; rom bios call packet structures

;*******************************
;system service call ( int 15h )
;*******************************
;function ah = 0c0h, return system configuration
;for pc and pcjr on return:
;	(ah)	= 80h
;	(cy)	= 1
;for pcxt, pc portable and pcat on return:
;	(ah)	= 86h
;	(cy)	= 1
;for all others:
;	(ah)	= 0
;	(cy)	= 0
;	(es:bx) = pointer to system descriptor vector in ros
; system descriptor :
;	dw	xxxx		length of descriptor in bytes,
;				minimum length = 8
;	db	xx		model byte
;				0ffh	= pc
;				0feh	= pc/xt, portable
;				0fdh	= pc/jr
;				0fch	= pc/at, 6mhz pc/at,
;					  6mhz pc/at running coprocessor(?),
;					  ps/2 model 50, 50 z
;				0fah	= ps/2 model 25, 30
;				0f9h	= pc convertible
;				0f8h	= ps/2 model 80
;				0f7h	= nova
;				0e0 thru 0efh = reserved
;
;	db	xx		secondary model byte
;				000h	= pc1
;				000h	= pc/xt, portable
;				000h	= pc/jr
;				000h	= pc/at
;				001h	= 6mhz pc/at
;				003h	= 6mhz pc/at running coprocessor(?)
;				004h	= ps/2 model 50, 50z
;				001h	= ps/2 model 25
;				000h	= pc convertible
;				000h	= ps/2 model 80
;				000h	= nova
;
;	db	xx		bios revision level
;				00 for first release, subsequent release
;				of code with same model byte and
;				secondary model byte require revison level
;				to increase by one.
;
;	db	xx		feature information byte 1
;				x0000000 = 1, bios use dma channel 3
;					 = 0, dma channel 3 not used
;
;				0x000000 = 1, 2nd interrupt chip present
;					 = 0, 2nd interrupt chip not present
;
;				00x00000 = 1, real time clock present
;					 = 0, real time clock not present
;
;				000x0000 = 1, keyboard escape sequence(int15h)
;						called in keyboard interrupt
;						(int 09h).
;					 = 0, keyboard escape sequence not
;						called.
;				0000xxxx reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;

bios_system_descriptor	struc
bios_sd_leng		dw	?
bios_sd_modelbyte	db	?
bios_sd_scnd_modelbyte	db	?
			db	?
bios_sd_featurebyte1	db	?
			db   4 dup (?)
bios_system_descriptor ends

;featurebyte1	bit map equates
dmachannel3		equ 10000000b
scndintcontroller	equ 01000000b
realtimeclock		equ 00100000b
keyescapeseq		equ 00010000b
;
;model byte
mdl_pc1 	equ	0ffh
mdl_xt		equ	0feh
mdl_jr		equ	0fdh
mdl_at		equ	0fch
mdl_convert	equ	0f9h

mdl_ps2_30	equ	0fah
mdl_ps2_80	equ	0f8h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\devmark.inc ===
;structure, equtes for devmark for mem command.

devmark struc
devmark_id	  db	  0
devmark_seg	  dw	  0
devmark_size	  dw	  0
devmark_dum	  db	  3 dup (?)
devmark_filename  db	  8 dup (' ')
devmark ends

devmark_stk	equ	'S'
devmark_device	equ	'D'
devmark_ifs	equ	'I'
devmark_buf	equ	'B'
devmark_cds	equ	'L' ;lastdrive
devmark_files	equ	'F'
devmark_fcbs	equ	'X'
devmark_inst    equ     'T' ;used for sysinit base for install= command.

devmark_spc     equ     'Q' ;used for spckbd,spcmse

setbrkdone	equ	00000001b
for_devmark	equ	00000010b
not_for_devmark equ	11111101b
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\dskio.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 DSKIO.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: DSKIO                                      *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************
;
;       CORRECTION HISTORY
;       84/11/16  SURE TO BEHAVE AS SINGLE DRIVE
;       85/03/01  AI RESULT
;       85/03/05  BI-MEDIA DRIVE
;       85/04/01  ADDING B4670-CODE
;       85/04/11  2D MEDIA SUPPORT
;       85/05/05  B4670 ( VIRTUAL VOLUME ACCESS )
;       85/05/06  ABOUT 640/1M MEDIA WITH ERROR  ( & B4670 )
;       85/05/07 - 10   B4670 ( ABOUT VIRTUAL HD & 5" 8/9 SECTORS )
;       85/05/12  ENABLE 256KB MEDIA ACCESS
;       85/05/14  l-bps(xa-hd) is 1024b(old is 512b)
;       85/05/15  B4670 DATA to "BIO2" MODULE
;       85/05/17  B4670 ( DIC I/O SUPPORT )
;       85/10/02  ENHANCEMENT FOR DOS 3.XX
;       85/10/25  40 MB BUG-FIX
;       86/10/31 X21 B4670 VHDSK BY QNES

;---------------------------------------------------------------------
;       87/10/06  BUG FIXED (PC-1424 & PATCH#242) & (PC-1160)
;       88/03 - 88/05 MS-DOS 3.3
;
;       90/11,12  MS-DOS 5.0 
;
;
        PAGE
;****************************************************************
;
;       WE DEFINED PRE-DENSITY TABLE AS FOLLOWS.
;
;       <PREDENST> FOR 1MB INTERFACE
;
;               0 : 256KB
;               1 : 1MB   ( '2HD' 8  SECTORS/TRACK )
;               2 : -----
;               3 : 1MB   ( '2HC' 15 SECTORS/TRACK - IBM PC/AT FORMAT )
;               4 : 160KB ( '1D'  8 SECTORS/TRACK )
;               5 : 180KB ( '1D'  9 SECTORS/TRACK )
;               6 : 320KB ( '2D'  8 SECTORS/TRACK )
;               7 : 360KB ( '2D'  9 SECTORS/TRACK )
;               8 : 640KB ( '2DD' 8 SECTORS/TRACK )
;               9 : 720KB ( '2DD' 9 SECTORS/TRACK )
;
;       <PREDENS5> FOR 640B INTERFACE
;
;               0 : 160KB ( '1D'  8 SECTORS/TRACK )
;               1 : 180KB ( '1D'  9 SECTORS/TRACK )
;               2 : 320KB ( '2D'  8 SECTORS/TRACK )
;               3 : 360KB ( '2D'  9 SECTORS/TRACK )
;               4 : 640KB ( '2DD' 8 SECTORS/TRACK )
;               5 : 720KB ( '2DD' 9 SECTORS/TRACK )
;               6 : 1MB   ( '2HD' 8  SECTORS/TRACK )
;               7 : 1MB   ( '2HC' 15 SECTORS/TRACK - IBM PC/AT FORMAT )
;               8 : 256KB
;               9 : -----
;
;***************************************************************

BRANCH = 0                              ;ASSEMBLE SWITCH        871002
HDSASI = 0                              ;                       88/03/25
HDSCSI = 0                              ;                       88/03/25

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Data       segment word public 'Bios_Data'
                ASSUME  CS:BIOS_DATA,DS:DATAGRP

        EXTRN   BIOS_FLAG:BYTE,EXLPTBL:WORD
        EXTRN   S_R8:BYTE
        EXTRN   HD_OFFSET:WORD,HD1_OFFSET:WORD
        EXTRN   HD_LAST:WORD,HD1_LAST:WORD
        EXTRN   DSK_BUF:NEAR

        EXTRN   DRV_NUM:BYTE
        EXTRN   EXIT:FAR,ERR_EXIT:FAR,BUS_EXIT:FAR
        EXTRN   PTRSAV:DWORD
        EXTRN   DSK8_SNG:NEAR,DSK8_DBL:NEAR
        EXTRN   DSK5_SNG8:NEAR,DSK5_DBL8:NEAR,DSK5_SNG9:NEAR,DSK5_DBL9:NEAR
        EXTRN   DSK5_DBL8D:NEAR,DSK5_DBL9D:NEAR,DSK_AT:NEAR

        EXTRN   HDDSK5_1:NEAR,HDDSK5_2:NEAR
;       EXTRN   HDIO_FLG:BYTE
        EXTRN   HD_LNG:WORD

        EXTRN   DSK_TYP:BYTE,COM:BYTE,COM1:BYTE
        EXTRN   LNG_TRNS:WORD,CUR_TRNS:WORD,NO_TRNS:WORD,MAX_TRNS:WORD
        EXTRN   PREFAT:BYTE,PREDNST:BYTE,PRVDRV:BYTE
        EXTRN   S_SEC:WORD,LNG_SEC:WORD,VRFY_FLG:BYTE,RTRY_CNT:BYTE
        EXTRN   RW_SW:BYTE
        EXTRN   SW_HD:BYTE,SW_5:BYTE,EXTSW:BYTE,VOLNUM:BYTE
        EXTRN   CURUA:BYTE,CURDA:BYTE,CURDRV:BYTE
        EXTRN   BPS:WORD,BPS1:WORD,BIDTBL:BYTE,CURDA2:BYTE


IF BRANCH       ;--------------------------------------- 871002 ------
;
;       B4670-CODE DATA
;
        EXTRN   VDSK_AI:BYTE,VDSK_TYP:BYTE
        EXTRN   FSTDRV:BYTE                                     ;850517
        EXTRN   X2_SW_VT:BYTE,VT_OFFSET:WORD,VT_LAST:WORD       ;850515
        EXTRN   VBPB:NEAR,VCPV:WORD,VBPS:WORD,VTPC:BYTE         ;850515
        EXTRN   VSPT:BYTE                                       ;850515
ENDIF   ;-------------------------------------------------------------
        EXTRN   HD_CAP:BYTE,HD_SPT:BYTE,HD_HED:BYTE
        EXTRN   CHR_X2:BYTE,HD_LBL:BYTE                 ;DEL(VT_BPB) 850505

        EXTRN   BT_TYP:BYTE
        EXTRN   SVPTR2:WORD,SVPTR1:WORD
        EXTRN   SVPTR:WORD,HD_NUM:BYTE,HD1_NUM:BYTE
        EXTRN   PREFAT8:BYTE                            ;850610

;
;       DOS 3.XX ONLY
;
;       EXTRN   VOLTABLE:BYTE                   ;BDS USED

        EXTRN   REFCNT:BYTE,BYTPSEC:WORD

;-------------------------------------------------- H/N DOS 870827--------

        EXTRN   PUA:BYTE,PWINF:BYTE,SNRST1:BYTE
        EXTRN   PREDENS5:BYTE,BIDTBL5:BYTE,SAVEAL:BYTE
        EXTRN   OPMOD:BYTE,OPMOD5:BYTE,FSW5:BYTE
        EXTRN   SNGDRV_FLG:BYTE

;---------------------------------------------------------------------
        EXTRN   SYS_500:BYTE,SYS_501:BYTE,N5FD:BYTE
;---------------------------------------------------------------------

        EXTRN   START_BDS:NEAR
        EXTRN   DSK_BUF2:NEAR
        EXTRN   HDS_OFFSET:NEAR
;--------------------------------------------------------- 88/03/25 --
;---------------------------------------------------------------------
        EXTRN   CMD_ERR:FAR
;---------------------------------------------------------------------

        EXTRN   CHR_VOL1:BYTE,SV_SELECT:BYTE
        EXTRN   SV_RDRV:BYTE,DD_FLG:BYTE

        EXTRN   X2_SW_00:BYTE,X2_SW_01:BYTE             ;850505
        EXTRN   INIT_TBL:NEAR

;----------------------------------------------- DOS5 91/01/10 -------
        EXTRN   MYATN:WORD, MYFAT:BYTE, FIRST:BYTE, VOLWORK:BYTE
        EXTRN   RETCODE:BYTE, NO_NAME:BYTE, MOSW:BYTE
        EXTRN   SNGDRV1_MSG:BYTE, SNGDRV2_MSG:BYTE, SNGDRV_CMN:BYTE
        EXTRN   SNG_MSG1:BYTE
        EXTRN   MASKB:BYTE, F_SW:BYTE, DB_TRNS:WORD
        EXTRN   NBYTETBL:BYTE, NBYTETBL5:BYTE

        EXTRN   CURSEC:BYTE, CURHD:BYTE, CURTRK:WORD, HDNUM:BYTE
        EXTRN   PATCH0:WORD, PATCH1:WORD, PATCH3:WORD
        EXTRN   TrackTable:BYTE, sectorsPerTrack:WORD, mediaType:BYTE
        EXTRN   fSetOwner:BYTE, PART_NUM:BYTE
;---------------------------------------------------------------------

        EXTRN   START_SEC_H:WORD
        EXTRN   BPBCOPY:BYTE

        EXTRN   MOSW2:BYTE, SCSI_EQUIP:BYTE

Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   STOP_CHK:NEAR

        EXTRN   FLUSH:NEAR,KBSTAT:NEAR,KBIN:NEAR,MSGLOOP:NEAR,MSGL:NEAR


IF BRANCH ;----------------------------------------------- 90/03/16 --
        EXTRN   MEDIA_VIRTUAL:NEAR
        EXTRN   GET_VTBPB:NEAR
ENDIF ;---------------------------------------------------------------
        EXTRN   MEDIA_HD:NEAR

;       EXTRN   MEDIA_5HD:NEAR
;       EXTRN   MEDIA_SHD:NEAR

        EXTRN   GET_HD:NEAR

;       EXTRN   GET_5HD:NEAR
;       EXTRN   GET_SHD:NEAR

        EXTRN   CMN_RW_HD:NEAR

;       EXTRN   CMN_RW_SASI:NEAR
;       EXTRN   CMN_RW_SCSI:NEAR
        EXTRN   MEDIA_MO:NEAR
        EXTRN   OPEN_MO:NEAR
        EXTRN   CLOSE_MO:NEAR
        EXTRN   GET_MO:NEAR
        EXTRN   CMN_RW_MO:NEAR
        EXTRN   BDATA_SEG:WORD

Bios_Code       ends

INTVEC  SEGMENT AT      0000H

        ORG     500H
BIO_FLAG        LABEL   BYTE
BIO_FLAG1       LABEL   BYTE
        ORG     564H
DISK_RESULT     LABEL   BYTE
        ORG     5D8H
F2DD_RESULT     LABEL   BYTE

INTVEC  ENDS


Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        PUBLIC  DSKIO_CODE_START
        PUBLIC  DSKIO_CODE_END
        PUBLIC  DSKIO_END

        PUBLIC  DSK_INIT_CODE,MEDIA_CHK_CODE,GET_BPB_CODE
        PUBLIC  DSK_READ_CODE,DSK_WRIT_CODE,DSK_WRTV_CODE
IF BRANCH ;----------------------------------------------- 90/03/16 --
        PUBLIC  HARDBPB,SET_VBPB
ENDIF ;---------------------------------------------------------------
;
;       DOS 3.XX
;
        PUBLIC  DSK_OPEN_CODE,DSK_CLOSE_CODE,DSK_REMOVABLE_CODE

;--------------------------------------------------------- 88/03/25 --
;----------------------------------------------- DOS5 91/01/10 -------
;       PUBLIC  DB_TRNS
;---------------------------------------------------------------------
        PUBLIC  Generic$IOCTL_CODE
        PUBLIC  IOCTL$GetOwn_CODE
        PUBLIC  IOCTL$SetOwn_CODE
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 91/01/10 -------
;       PUBLIC  MOSW
;---------------------------------------------------------------------


DSKIO_CODE_START:

IODAT   STRUC
CMDLEN  DB      ?
UNIT    DB      ?
CMD     DB      ?
STATUS  DW      ?
        DB      8 DUP(?)
MEDIA   DB      ?
TRANS   DD      ?
COUNT   DW      ?
START   DW      ?
IODAT   ENDS

;
;       DEFINE EQU LABEL
;
BPB_BPS  EQU    0               ;BYTE PER SECTOR
BPB_SPA  EQU    2               ;NUMBER OF SECTORS PER ALLOC UNIT
BPB_RSVN EQU    3               ;NUMBER OF RESERVED SECTOR
BPB_FATN EQU    5               ;NUMBER OF COPY OF FAT
BPB_DRMX EQU    6               ;NUMBER OF DIRECTORY ENTRY
BPB_SPV  EQU    8               ;NUMBER OF SECTOR PER VOLUME
BPB_MDA  EQU    10              ;MEDIA DISCRIPTOR
BPB_FATS EQU    11              ;NUMBER OF OCCUPIED SECTOR BY FAT

;----------------------------------------------- DOS5 91/01/10 -------
;********************************************************
;*
;*      DEFINE LOCAL DATA
;*
;********************************************************
;CARRY          DB      0       ;10-25-85
;MYATN          DW      ?
;MYFAT          DB      ?
;FIRST          DB      0
;VOLWORK                DB      11 DUP (20H)
;               DB      00
;
;RETCODE                DB      0
;ERROR_FLG      DB      0               
;NO_NAME                DB      'NO NAME    ',00H
;MOSW           DB      0
;
;
;       MESSAGE DATA
;
;SNGDRV1_MSG    DB      13,10,'hCu@'
;SNGDRV1_FLD    DB      'A@ɃfBXN}ĉ',0
;SNGDRV2_MSG    DB      13,10,'hCu@'
;SNGDRV2_FR     DB      'B@ɑ}悤ƂfBXNhCu@'
;SNGDRV2_LT     DB      'A  ɑ}ĉ',0
;SNGDRV_CMN     DB      13,10,'}IAKȃL\ĉ'
;SNG_MSG1       DB      0
;
;--------------------------------------------- 011 PRODUCT ------
;MASKB          DB      1,2,4,8
;F_SW           DB      0
;DB_TRNS                DW      0
;NBYTETBL       DB      0,3,0,2,0,0,0,0,0       ;1MB FD DENSITY 871003
;NBYTETBL5      DB      0,0,0,0,0,0,3,2,0       ;640KFD DENSITY 871003
;------------------------------------------------------ BY MAMA -
        PAGE
;********************************************************
;*                                                      *
;*      < DSK_INIT >                                    *
;*                                                      *
;*      INITIALIZE DISK DRIVE                           *
;*                                                      *
;*      INPUT:  NONE                                    *
;*      OUTPUT: NUMBER OF UNIT                          *
;*              INITIAL BPB POINTER                     *
;*                                                      *
;********************************************************

DSK_INIT_CODE   PROC    FAR
DSK_INIT_CODE   ENDP
DSK_INIT_DONE:
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P31>

        extrn   patch144_9:near

        call    patch144_9
;---------------
;       MOV     AL,DRV_NUM              ;GET NUMBER OF UNITS IN SYSTEM
;---------------------------------------------------------------------
        MOV     SI,OFFSET INIT_TBL      ;SET OFFSET TO BPB POINTER
        LDS     BX,[PTRSAV]             ;LOAD DWORD POINTER
        MOV     [BX.MEDIA],AL           ;SET NUMBER OF UNITS IN SYSTEM
        MOV     [BX.COUNT],SI           ;SET OFFSET
        MOV     [BX.COUNT+2],0060h      ;SET SEGMENT
        MOV     BYTE PTR [BX.COUNT+3],0 ;SET START DRIVE IN DRIVER
        JMP     EXIT

;********************************************************
;*                                                      *
;*      < MEDIA_CHK >                   FUNCTION 1      *
;*                                                      *
;*      WHICH MEDIA WAS EXCHANGED OR NOT ?              *
;*                                                      *
;*      INPUT:  UNIT NUMBER                             *
;*      OUTPUT: RETUEN BYTE                             *
;*              1:UNKOWN  0:NOT CHANGED  -1:CHANGED     *
;*                                                      *
;********************************************************
MEDIA_CHK_CODE  PROC    FAR
MEDIA_CHK_CODE  ENDP
        CALL    CNVDRV          ;CONVERT LOGICAL TO DA/UA
IF BRANCH ;----------------------------------------------- 90/03/16 --
        TEST    CURUA,08H       ;VIRTUAL DISK ?
        JZ      MEDIA010
        JMP     MEDIA_VIRTUAL   ;SKIP IF SO
ENDIF ;---------------------------------------------------------------
;------------------------------------------- FOR N-MODE 640KBFD 870906 ---
;       CMP     AL,90H          ;CURRENT 8"FD ?
;       JE      MEDIA_8FD       ;SKIP IF SO
;-------------------------------------------------------------------------
MEDIA010:
        CMP     AL,80H          ;CURRENT SASI HD ?
        JNZ     MEDIA020
        JMP     MEDIA_HD        ;SKIP IF SO
;       JMP     MEDIA_5HD       ;SKIP IF SO
;--------------------------------------------------------- 88/03/25 --
MEDIA020:
        CMP     AL,0A0H         ;CURRENT SCSI HD OR MODISK?
        JNZ     MEDIA030
;--------------------------------------------------------- 89/08/18 --
        CMP     [MOSW],00H      ;MO DISK ?
        JNZ     MEDIA025
        JMP     MEDIA_HD        ;SCSI HD
;       JMP     MEDIA_SHD       ;SCSI HD
MEDIA025:
        JMP     MEDIA_MO        ;MO DISK
;---------------------------------------------------------------------
MEDIA030:
;---------------------------------------------------------------------
        CMP     AL,70H          ;CURRENT 5"FD(2DD) ?
        JE      MEDIA_5FD       ;SKIP IF SO
;------------------------------------------- FOR N-MODE 640KB 870906 -----
        CMP     AL,90H          ;CURRENT 8"FD ?
        JNE     MEDIA_UNKNOWN   ;NO,
        JMP     MEDIA_8FD       ;SKIP IF SO
MEDIA_UNKNOWN:
;-------------------------------------------------------------------------
;
;       UNKNOWN UNIT ERROR
;
        MOV     AX,1            ;SET ERROR CODE
        JMP     DSK_ERR_EXIT
IF HDSASI ;---------------------------------------------- 88/02/25 --
;****************************************
;*                                      *
;*      HERE, UNIT VIRTUAL              *
;*                                      *
;****************************************
MEDIA_VIRTUAL:
;IF BRANCH ;-------------------------------------------- 871002 -------
        MOV     AL,VDSK_AI      ;GET CONTROL INFORMATION
        MOV     CL,CURUA        ;GET UNIT ADDRESS
        AND     CL,07H
        MOV     AH,01H
        SHL     AH,CL
        TEST    AL,AH           ;CURRENT READY ?
        JNE     MEDIA_VT10
;       NOT READY !!
        MOV     AX,2
        JMP     DSK_ERR_EXIT    ;NOT CHANGED
MEDIA_VT10:
        MOV     AH,10H
        SHL     AH,CL           ;MAKE ATTENTION BIT
        TEST    AL,AH           ;ATTENTION HAPPENED ?
        JNE     MEDIA_VT20
;       NOT ATTENTION !!
;ENDIF  ;-------------------------------------------------------------
        MOV     AH,1                    ;850507 (AX -> AH) "NOT CHANGED"
        JMP     DSKCHG_OK
;
;       READY AND ATTENTION !!
;
;IF BRANCH      ;-------------------------------------- 871002 -------
MEDIA_VT20:
        CALL    MV_GET_TYP              ;850510 GET VOLUME TYPE **
        CMP     AL,5                    ;HARD DISK
        JB      MEDIA_VT30
;
;-----LOAD CURRENT HARD BPB IMAGE
;
        CALL    HARDBPB
        JC      MEDIA_VT40
MEDIA_VT30:
        MOV     AH,-1                   ;850506 SET CHANGED CODE
        JMP     DSKCHG_OK
MEDIA_VT40:
        MOV     AX,2
        JMP     DSK_ERR_EXIT

MV_GET_TYP:     MOV     SI,OFFSET VDSK_TYP      ;SET VIRTUAL DISK TYPE OFFSET
                MOV     AL,[CURUA]              ;
                AND     AX,0007H                ;
                ADD     SI,AX                   ;
                CLD                             ;
                LODSB                           ;
                RET                             ;
;ENDIF  ;-------------------------------------------------------------

;****************************************
;*                                      *
;*      HERE, UNIT IS SASI HD           *
;*                                      *
;****************************************
MEDIA_5HD:
        MOV     AH,01H          ;SET RETURN BYTE, NOT CHANGED
        JMP     DSKCHG_OK
ENDIF ;---------------------------------------------------------------

IF HDSCSI ;----------------------------------------------- 88/03/25 --
;****************************************
;*                                      *
;*      HERE, UNIT IS SCSI HD           *
;*                                      *
;****************************************
MEDIA_SHD:
        MOV     AH,01H          ;SET RETURN BYTE, NOT CHANGED
        JMP     DSKCHG_OK
ENDIF ;---------------------------------------------------------------

;****************************************
;*                                      *
;*      HERE, UNIT IS 5"FD		*
;*                                      *
;****************************************
;
MEDIA_5FD:
;--------------------------------------------- FOR N-MODE 640KBFD 870906 ---
        TEST    [SYS_501],00001000B     ;HIRESO MODE ?
        JZ      MED5_NORM               ;NO,
        MOV     AH,00H                  ;YES, SET RETURN BYTE, DON'T KNOW
        JMP     DSKCHG_OK

MED5_NORM:
        CALL    EXCMSG                  ;PROMOTE EXCHANGE MEDIA
        MOV     [BIOS_FLAG],1           ;INDICATE DURING DISK I/O
        PUSH    ES
        XOR     AX,AX
        MOV     ES,AX                   ;CLEAR ES
        MOV     AL,[CURUA]              ;GET CURRENT UNIT ADDR
        XOR     AH,AH
        MOV     [PUA],AL
        SHL     AX,1
        ADD     AX,OFFSET F2DD_RESULT   ;ADDING OFFSET
        MOV     BX,AX
        MOV     AL,ES:[BX]              ;GET AI-RESULT
        AND     AL,0C0H
        MOV     [RETCODE],AL            ;SAVE IT
        MOV     AL,[PUA]
        OR      AL,70H
        MOV     [PWINF],AL
;
        MOV     BL,[PUA]
        XOR     BH,BH
        TEST    SNRST1[BX],02H
        JNE     AIPRC                   ;SKIP IF NO ATTENTION !!
        MOV     AL,RETCODE
        CMP     AL,0C0H                 ;AI OCCURRED ?
        JE      AIPRC                   ;SKIP IF SO
        MOV     AH,1                    ;NOT CHANGED !!
        POP     ES
        JMP     DSKCHG_OK
;
AIPRC:
        MOV     AL,PUA
        MOV     BX,OFFSET MASKB
        XLAT    [BX]
        MOV     AH,ES:[055DH]
        POP     ES
        MOV     CL,4
        SHR     AH,CL
        AND     AH,AL                   ;DA/UA=0FXH ?
        MOV     AL,PUA
        JNE     AIPRC10                 ;SKIP IF NO
        OR      AL,0F0H
        MOV     PWINF,AL                ;DA/UA O.K.
        JMP     AIPRC60
;
AIPRC10:
        MOV     AL,PWINF
AIPRC30:
        MOV     BL,PUA
        XOR     BH,BH
        TEST    SNRST1[BX],08H          ;BI-DRIVE UNIT ?
        JE      AIPRC40                 ;SKIP IF NO
        JMP     AIPRC50                 ;SKIP IF SO
;
AIPRC40:
;
;       HANDLE 640 KB MEDIA ON 640 KB INTERFACE
;
        MOV     PWINF,AL
        PUSH    ES
        PUSH    AX
        XOR     BX,BX
        MOV     ES,BX
        AND     AX,000FH
        SHL     AX,1
        ADD     AX,OFFSET F2DD_RESULT
        MOV     BX,AX
        AND     ES:BYTE PTR [BX],3FH
        POP     AX
;
        MOV     ES,CS:[BDATA_SEG]       ;ES <- Data segment     @DOS5
        MOV     BP,OFFSET DSK_BUF       ;SET I/O BUFFER
        MOV     CX,0200H                ;SET SECTOR LENGTH & CYLINDER #
        MOV     DX,0002H                ;SET HEAD # & SECTOR #
        MOV     BX,512                  ;SET TRANSFER LENGTH
NXT_FAT_READ:
FAT_RD_OK:
        POP     ES                      ;RESTORE ES
        XOR     AH,AH
        MOV     BX,OFFSET PREDENS5
        MOV     DI,OFFSET BIDTBL5
        TEST    PWINF,20H               ;1 MB INTERFACE ?
        JNE     FAT_RD_OK01             ;SKIP IF NO
        MOV     BX,OFFSET PREDNST
        MOV     DI,OFFSET BIDTBL
FAT_RD_OK01:
        MOV     AL,[CURUA]
        ADD     BX,AX                   ;MAKE PROPER ADDER
        ADD     DI,AX                   ;SAME DO
        MOV     AL,PWINF
        MOV     BYTE PTR [DI],AL
;---------------------------------------
        MOV     DL,[BX]                 ;GET PREVIOUS TYPE
        MOV     CL,DS:[BP]              ;GET FAT ID
        MOV     AL,0
        CMP     CL,0FEH                 ;5"1D8 ?
        JE      J_5FDCHG
        INC     AL
        CMP     CL,0FCH                 ;5"1D9 ?
        JE      J_5FDCHG
        INC     AL
        CMP     CL,0FFH                 ;5"2D8 ?
        JE      J_5FDCHG
        INC     AL
        CMP     CL,0FDH                 ;5"2D9 ?
        JE      J_5FDCHG
        INC     AL
        CMP     CL,0FBH                 ;5"2DD8 ?
        JE      J_5FDCHG
        INC     AL
        CMP     CL,0F9H                 ;5"2DD9 ?
        JE      J_5FDCHG
UNKNOWN_DSK:
;------------------------------------------------- PATCH FIX PC-2111 -
        MOV     AL,[PWINF]              ;SET DA/UA
        CALL    ERR_SUB                 ;SET AI FLAG
;---------------------------------------------------------------------
        MOV     AL,7                    ;SET ERROR CODE - UNKNOWN DISK
        JMP     DSK_ERR_EXIT
J_5FDCHG:
        MOV     AH,0                    ;UNKNOWN DISK CHANGED
        TEST    PWINF,20H
        JNE     J_5FDCHG10
        ADD     AL,4                    ;85/03/21
J_5FDCHG10:
        CMP     AL,DL                   ;SAME TYPE ?
        JE      D_CHG_RET
        NOT     AH                      ;DISK CHANGED
        MOV     [BX],AL                 ;SET CURRENT TYPE
        TEST    PWINF,20H
        JE      NEW_SETMOD              ;85/04/11
        CALL    S_2DDM                  ;85/05/17
D_CHG_RET:
        JMP     DSKCHG_OK

NEW_SETMOD:
        PUSH    AX
        CMP     AL,3
        JBE     NOT_NEWSET              ;SKIP IF 1MB
        MOV     SAVEAL,AL
NEW_SETEXEC:
        MOV     BX,OFFSET MASKB
        MOV     AL,PUA
        XLAT    [BX]                    ;GET MASK BIT
        MOV     AH,OPMOD                ;GET OPERATION MODE
        CMP     SAVEAL,8
        JAE     SET_DDMOD
        NOT     AL
        AND     AH,AL
        JMP     SHORT SET_COMMOD
SET_DDMOD:
        OR      AH,AL                   ;85/05/17
SET_COMMOD:                             ;85/05/17
        MOV     OPMOD,AH                ;85/05/17
        MOV     AL,AH                   ;85/05/19
        AND     AL,0FH                  ;85/05/17
        OR      AL,10H                  ;85/05/17
        MOV     AH,8EH
NOT_NEWSET:
        POP     AX
        JMP     SHORT D_CHG_RET 

;
;       7XH AND FXH MAY BE APPEARED !!
;
AIPRC50:
        MOV     AL,[CURUA]
        MOV     BX,OFFSET MASKB
        XLAT    [BX]
        MOV     BX,OFFSET BIDTBL5
        TEST    FSW5,AL
        JNE     AIPRC55         ;NOT FIRST
        OR      FSW5,AL
        MOV     AL,[CURDA]
        OR      AL,PUA
        JMP     SHORT AIPRC60
AIPRC55:
        MOV     AL,[CURUA]
        XLAT    [BX]
AIPRC60:
AIPRC100:
        TEST    AL,80H                  ;1 MB ?
        JNE     AIPRC110                ;SKIP IF SO
        JMP     AIPRC40                 ;640 KB
;
;       HANDLE 1 MB MEDIA ON 640 KB INTERFACE
;
AIPRC110:
        MOV     CL,6
        CMP     CH,3                    ;1024
        JE      AIPRC120                ;SKIP IF SO
        MOV     CL,7                    ;PC-AT
        CMP     CH,2
        JE      AIPRC120                ;SKIP IF SO
        JMP     UNKNOWN_DSK
;
AIPRC120:
        MOV     CH,AL                   ;SAVE DA
        MOV     PWINF,AL
        MOV     SI,OFFSET BIDTBL5
        MOV     DI,OFFSET PREDENS5
        MOV     AL,[CURUA]
        XOR     AH,AH
        ADD     SI,AX
        ADD     DI,AX
        MOV     BYTE PTR [SI],CH        ;SAVE DA/UA
        MOV     AH,0                    ;UNKNOWN CHANGED !!
        CMP     BYTE PTR [DI],CL
        JE      AIPRC130                ;SKIP IF ??
        NOT     AH                      ;CHANGED !!
        MOV     BYTE PTR [DI],CL
AIPRC130:
        JMP     D_CHG_RET

;****************************************
;*                                      *
;*      SET 5"2DD OPERATION MODE	*
;*              HIRESO MODE ONLY        *
;*                                      *
;****************************************
S_2DDM:
        RET
;---------------------------------------------------------------- 870906 ---
;****************************************
;*                                      *
;*      1 MB INTERFACE                  *
;*                                      *
;****************************************
MEDIA_8FD:
SENS_DSK8:
        CALL    EXCMSG                  ;PROMOTE EXCHANGE MEDIA
        MOV     [BIOS_FLAG],1           ;INDICATE DURING DISK I/O
        XOR     AX,AX
        MOV     AL,[CURUA]
        MOV     PUA,AL
        MOV     CL,3
        SHL     AX,CL                   ;*8
        MOV     DI,OFFSET DISK_RESULT   ;SET TOP OF DISK RESULT(0:)
        ADD     DI,AX                   ;SET TARGET DISK RESULT
        MOV     CL,[CURUA]
        MOV     AL,01H
        SHL     AL,CL
        MOV     S_R8,AL                 ;SAVE AL
        PUSH    ES
        TEST    AL,F_SW                 ;FIRST ACTIVATE ?
        JZ      SENS_EXE                ;JUMP IF SO
;----------------------------------------------- DOS5 92/06/22 -------
;<patch BIOS50-P22>
        extrn   patch06a:near

        call    patch06a
        db      90h,90h
;---------------
;       CMP     SNGDRV_FLG,0
;---------------------------------------------------------------------
        JNE     SENS_EXE
        XOR     BX,BX
        MOV     ES,BX                   ;ES <-- 0000H
        MOV     AL,ES:[DI]              ;GET AI INF.
        AND     AL,0C0H
        MOV     RETCODE,AL
        CMP     AL,0C0H                 ;AI ?
        JE      SENS_EXE                ;YES
        MOV     AH,1                    ;DISK NOT CHANGED
        POP     ES
        JMP     D_CHG_RET
;
SENS_EXE:

BI_GOOD:
        MOV     PWINF,AL
        MOV     BL,S_R8
        OR      F_SW,BL
        TEST    AL,80H                  ;640 MB ?
        JE      MB_640                  ;SKIP IF SO
;
;       HANDLE 1 MB MEDIA ON 1 MB INTERFACE
;
;----------------------------------- 870913 ----- MAMA ---------------
        MOV     AL,0                    ;85/5/12
        OR      CH,CH
        JE      SKIP_128                ;128B/SEC
        MOV     AL,3                    ;512B/SEC
        SUB     CH,2
        JE      SKP_RFAT8
        MOV     AL,1                    ;1024/SEC
;       JMP     SKP_RFAT8
;---------------------------------------------------------------------
SKIP_128:
SKP_RFAT8:
        XOR     CH,CH
        MOV     CL,[CURUA]              ;CURRENT UA
        MOV     SI,CX
        MOV     DI,CX
        ADD     SI,OFFSET PREDNST
        ADD     DI,OFFSET BIDTBL
        MOV     AH,0                    ;UNKNOWN DISK CHANGED
        MOV     BL,PWINF
        MOV     BYTE PTR [DI],BL        ;UPDATE IT
        CMP     AL,[SI]                 ;COMPARE PREVIOUS DENSITY
        JE      SKP_SCUR8
        MOV     [SI],AL                 ;SET CURRENT TYPE
        NOT     AH                      ;DISK CHANGED
SKP_SCUR8:
        JMP     D_CHG_RET

;
;       HANDLE 640 KB MEDIA ON 1 MB INTERFACE
;
MB_640:
;------------------------------------------------ PATCH FIX 88/02/25 -
        TEST    BYTE PTR [SYS_501],08
        JNZ     SKIP_128
;---------------------------------------------------------------------
        JMP     AIPRC40         

;----------------------------------------------------------------
;****************************************
;*                                      *
;*      END OF MEDIA CHECK              *
;*                                      *
;****************************************
DSKCHG_OK:
        CMP     AH,1                    ;MEDIA CHANGED ?
        JZ      DSKCHG_OK10             ; CHANGED/DON'T KNOW
        PUSH    AX
        CALL    SET_IDPTR               ;SET VOLUME ID POINTER
        POP     AX
        JMP     SHORT DSKCHG_OK20
DSKCHG_OK10:
        LDS     BX,[PTRSAV]
DSKCHG_OK20:
        MOV     BYTE PTR [BX.TRANS],AH  ;SET RETURN BYTE
        JMP     EXIT

;****************************************
;*                                      *
;*      SET VOLUME ID                   *
;*      (DOS 3.XX ENHANCEMENT)          *
;*                                      *
;****************************************
SET_IDPTR:
;--------------------------------------------------------- 88/05/28 --
;       MOV     AL,CURDRV       ;GET CURRENT DRIVE NUMBER
;       MOV     AH,12
;       MUL     AH              ;CAL 12*CURDRV
;       MOV     DI,OFFSET VOLTABLE
;       ADD     DI,AX
;---------------------------------------------------------------------

        MOV     AL,CURDRV
        CALL    SetDrive
        LEA     DI,[DI].BDS_VOLID
        LDS     BX,[PTRSAV]
        MOV     WORD PTR [BX.TRANS+1],DI ;SET OFFSET
        MOV     AX,CS:[BDATA_SEG]
        MOV     WORD PTR [BX.TRANS+3],AX ;SET SEGMENT
;       MOV     WORD PTR [BX.TRANS+3],CS ;SET SEGMENT
        RET

;********************************************************
;*                                                      *
;*      DEVICE OPEN FUNCTION                            *
;*                                                      *
;********************************************************
DSK_OPEN_CODE   PROC    FAR
DSK_OPEN_CODE   ENDP
;--------------------------------------------------------- 88/05/28 --
;       MOV     BX,OFFSET REFCNT        ;SET REFER COUNTER TABLE ADDR
;       XOR     AH,AH
;       ADD     BX,AX
;       INC     BYTE PTR [BX]           ;1 INCREMENT ,EVRY OPEN
;---------------------------------------------------------------------
;--------------------------------------------------------- 89/08/18 --
        CALL    CNVDRV
        MOV     AL,CURDRV
;---------------------------------------------------------------------
        CALL    SetDrive
        INC     [DI].BDS_OPCNT
;--------------------------------------------------------- 89/08/18 --
        CMP     [MOSW],00H
        JZ      DSKOPEN010
        JMP     OPEN_MO
DSKOPEN010:
;---------------------------------------------------------------------
        JMP     EXIT

;********************************************************
;*                                                      *
;*      DEVICE CLOSE FUNCTION                           *
;*                                                      *
;********************************************************
DSK_CLOSE_CODE  PROC    FAR
DSK_CLOSE_CODE  ENDP
;--------------------------------------------------------- 88/05/28 --
;       MOV     BX,OFFSET REFCNT        ;SET REFER COUNTER TABLE ADDR
;       XOR     AH,AH
;       ADD     BX,AX
;       cmp     byte ptr [bx],0
;       jbe     dsk_close10
;       DEC     BYTE PTR [BX]           ;1 DECREMENT, EVRY CLOSE
;---------------------------------------------------------------------
;--------------------------------------------------------- 89/08/18 --
        CALL    CNVDRV
        MOV     AL,CURDRV
;---------------------------------------------------------------------
        CALL    SetDrive
        CMP     [DI].BDS_OPCNT,0
        JBE     DSK_CLOSE10
        DEC     [DI].BDS_OPCNT
;--------------------------------------------------------- 89/08/18 --
        CMP     [MOSW],00H
        JZ      dsk_close10
        JMP     CLOSE_MO
;---------------------------------------------------------------------
dsk_close10:
        JMP     EXIT

;********************************************************
;*                                                      *
;*      REMOVABLE DISK FUNCTION                         *
;*                                                      *
;********************************************************
DSK_REMOVABLE_CODE      PROC    FAR
DSK_REMOVABLE_CODE      ENDP
        MOV     BX,OFFSET EXLPTBL+1
;----------------------------------------------- DOS5 91/04/01 -------
;PATCH FIX
        XOR     AH,AH
        SHL     AL,1
        ADD     BX,AX
        MOV     AL,BYTE PTR [BX]        ;CURRENT DA/UA
;---------------------
;       SHL     AL,1
;       XLAT    BYTE PTR [BX]           ;GET CURRENT DA/UA
;---------------------------------------------------------------------
        AND     AL,0F0H                 ;STRRIP LOW
;--------------------------------------------------------- 88/03/25 --
        CMP     AL,80H                  ;SASI HD ?
        JE      DSK_REME10              ;NON-REMOVABLE
        CMP     AL,0A0H                 ;NOT SCSI HD OR MO DISK?
        JNE     DSK_REMEXIT             ;REMOVABZLE
        TEST    BYTE PTR [BX-1],01H     ;MO DISK ?
        JZ      DSK_REME10              ;SCSI HD
        JMP     short DSK_REMEXIT       ;MO DISK
DSK_REME10:
        JMP     BUS_EXIT                ;NON-REMOVABLE
DSK_REMEXIT:
        JMP     EXIT                    ;REMOVABLE
;---------------------------------------------------------------------
;****************************************
;*                                      *
;*      CONVERT LOGICAL TO DA/UA        *
;*       INPUT : UNIT NUMBER IN AL      *
;*       OUTPUT: DA          IN AL      *
;*             : SET FOLLOWING          *
;*               (CURDRV/CURDA/CURUA,   *
;*                              EXTSW)  *
;*                                      *
;****************************************
CNVDRV:
        MOV     [CURDRV],AL
        MOV     BX,OFFSET EXLPTBL       ;SET CONVERT TABLE ADDR
        MOV     CL,AH                   ;SAVE MEDIA DISCRIPTOR
        SHL     AL,1                    ;AL=AL*2
        XOR     AH,AH
        ADD     BX,AX
        MOV     AX,[BX]                 ;GET TABLE CONTENTS
        MOV     [EXTSW],0
        TEST    AL,80H                  ;CHECK LOGICAL EXTENT BIT ?
        JZ      CNVDRV_10               ;SKIP IF OFF
        MOV     [EXTSW],0FFH            ;TURN ON
CNVDRV_10:
;--------------------------------------------------------- 89/08/18 --
        MOV     [MOSW],0
        TEST    AL,01H
        JZ      CNVDRV_20
        MOV     [MOSW],0FFH
;----------------------------------------------- DOS5 91/08/00 -------
        mov     [mosw2],0
        mov     bl,ah
        and     bl,0fh
        xor     bh,bh
        cmp     byte ptr SCSI_EQUIP.[bx],07h    ;if 3.5" MO
        jne     CNVDRV_20
        mov     [mosw2],0ffh
;---------------------------------------------------------------------
CNVDRV_20:
;---------------------------------------------------------------------
        XCHG    AH,AL
        MOV     [CURUA],AL
        AND     [CURUA],0FH
        AND     AL,0F0H
        MOV     [CURDA],AL
        MOV     AH,CL                   ;RESTORE MEDIA DISCRIPTOR
        RET

;****************************************
;                                       *
;       POINT CURRENT AI FIELD          *
;        INPUT  : NOTHING               *
;        OUTPUT : CURRENT AI ADDR IN DI *
;                                       *
;****************************************
AIPOINT:
        XOR     AX,AX                   ;MAKE ABSOLUTE ZERO
        MOV     ES,AX                   
        MOV     AL,CURUA
        SHL     AL,1
        SHL     AL,1
        SHL     AL,1                    ;AL=AL*8 (85/03/01)
        MOV     DI,OFFSET DISK_RESULT   ;SET BASE ADDR
        ADD     DI,AX
        RET

;****************************************
;*                                      *
;*      IF CURRENT IS SINGLE SYSTEM,    *
;*      DISPLAY MEDIA EXCHANGING        *
;*      MESSAGE                         *
;*                                      *
;****************************************
EXCMSG:
        PUSH    ES
        PUSH    BP
        PUSH    DX
        PUSH    CX
        CMP     EXTSW,0                 ;SINGLE DRIVE ?
        JE      SKP_KBIN                ;SKIP IF NOT
        MOV     AL,CURDRV               ;SET CURRENT DRIVE
;----------------------------------------------- DOS5 92/06/22 -------
;<patch BIOS50-P22>
        extrn   patch06c:near

        call    patch06c
        db      90h
;---------------
;       CMP     AL,PRVDRV               ;CURRNT = PREVIOUS ?
;---------------------------------------------------------------------
        JE      SKP_KBIN                ;SKIP IF SO
        MOV     BX,OFFSET SNGDRV1_MSG
        CMP     AL,PRVDRV
        JBE     EXCMSG_30
EXCMSG_20:
        MOV     BX,OFFSET SNGDRV2_MSG
EXCMSG_30:
        MOV     PRVDRV,AL               ;UPDATE IT
        CALL    MSGL                    ;PUT STRING
        MOV     BX,OFFSET SNGDRV_CMN
        CALL    MSGL
L_KBIN:
        CALL    KBSTAT                  ;WAIT KEY INPUT
        JZ      L_KBIN
        CMP     AL,'C'-'@'              ;CTRL-C ?
        JE      SKP_KBIN
        CALL    KBIN
        MOV     BX,OFFSET SNG_MSG1
        CALL    MSGLOOP
SKP_KBIN:
        POP     CX
        POP     DX
        POP     BP
        POP     ES
        RET

dosetsub:                               ;
SET_BPB:
        CMP     CURDA,90H
        JNE     SET_BPB20
SET_BPB10:
        TEST    FIRST,-1
        MOV     FIRST,-1
        JE      SET_BPB20               ;
;--------------------------------------------------------- 88/05/28 --
;       MOV     BX,OFFSET REFCNT        ;
;       PUSH    AX
;       MOV     AL,CURDRV               ;
;       XLAT    [BX]                    ;
;       OR      AL,AL                   ;
;       POP     AX
;---------------------------------------------------------------------
        PUSH    AX
        MOV     AL,CURDRV
        CALL    SetDrive
        CMP     [DI].BDS_OPCNT,0
        POP     AX
;---------------------------------------------------------------------
        JNE     SET_BPB20               ;
;----------------------------------------------- DOS5 91/02/20 -------
        PUSH    AX
        PUSH    SI
        MOV     AL,CURDRV
        MOV     RW_SW,0
        CALL    BOOTIO
        JC      SET_BPB15
        CALL    MOV_MEDIA_IDS
        JNC     SET_BPB15
        MOV     WORD PTR [DI].BDS_VOL_SERIAL,0
        MOV     WORD PTR [DI].BDS_VOL_SERIAL+2,0
        POP     SI
        POP     AX
;---------------------------------------------------------------------
        PUSH    AX
        PUSH    SI
        CALL    READLABEL               ;DOS 3.XX ENHANCEMENT
                                        ;READ VOLUME LABEL
        POP     SI
        POP     AX
        JB      SET_BPB20               ;SKIP IF READ ERROR
        PUSH    AX
        PUSH    SI
        CALL    SETLABEL                ;SET LABEL POINTER
;----------------------------------------------- DOS5 91/02/20 -------
SET_BPB15:
;---------------------------------------------------------------------
        POP     SI
        POP     AX
;
SET_BPB20:
        LDS     BX,[PTRSAV]
        MOV     [BX.MEDIA],AL
        MOV     [BX.COUNT],SI
        MOV     CX,CS:[BDATA_SEG]
        MOV     [BX.COUNT+2],CX
        ret                             ;
;
;       READ VOLUME LABEL
;
;       AL : CURRENT DRIVE NUMBER (0-25)
;       AH : MEDIA DISCRIPTER BYTE
;
READLABEL:
        MOV     AX,06H[SI]              ;GET NUMBER OF MAX
        MOV     AH,32                   ;LENGTH(DIR) IS 12 BYTE
        MUL     AH                      ;BYTE/TOTAL(DIR)
        XOR     DX,DX
        MOV     BX,00H[SI]              ;GET BYTE/SECTOR
        MOV     BYTPSEC,BX
        DIV     BX                      ;GET SECTOR/TOTAL(DIR)
        MOV     BX,AX
        MOV     DX,0BH[SI]              ;GET SECTOR/FAT
        SHL     DX,1                    ;DX INDICATE NUMBER OF START-SEC
        INC     DX                      ;ADDING IPL SECTOR
        PUSH    DS
        POP     ES
        MOV     DI,OFFSET DSK_BUF       ;READ BUFFER
        mov     al,curdrv
        mov     ah,0ah[si]
        MOV     CX,1
READLB10:
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    ES
        PUSH    DI
        CALL    READ                  ;USE READ IN IO.SYS
        JB      READLB_ERROR          ;SKIP IF ERROR
        CALL    IDSEARCH              ;SEARCH IN IT
READLB_ERROR:
        POP     DI
        POP     ES
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        JNB     READLB_FOUND
;--------------------------------------------------------- 88/06/07 --
;       DEC     BX                      ;COUNTER DOWN
        SUB     BX,1
;---------------------------------------------------------------------
        JZ      READLB_NFOUND           ;SKIP IF NOT FOUND
        INC     DX                      ;START SEC 1 UP
        JMP     SHORT READLB10          ;GO NEXT
READLB_NFOUND:
        MOV     SI,OFFSET NO_NAME
READLB_FOUND:
        MOV     CX,11
        MOV     DI,OFFSET VOLWORK
        CLD
        REP     MOVSB
        RET

IDSEARCH:
        MOV     CX,BYTPSEC              ;GET BYTE/SEC
IDSEARCH10:
        CMP     ES:BYTE PTR [DI],00H
        JE      IDSEARCH30
        CMP     ES:BYTE PTR [DI],0E5H
        JE      IDSEARCH20
        TEST    BYTE PTR ES:[DI+11],08H ;VOL LABEL ?
        JZ      IDSEARCH20              ;SKIP IF NO
        MOV     SI,DI
        CLC                          ;RETURN WITH FOUND
        RET

IDSEARCH20:
        SUB     CX,32
        JZ      IDSEARCH30              ;SKIP IF NO REMAIN
        ADD     DI,32
        JMP     SHORT IDSEARCH10

IDSEARCH30:
        STC                          ;RETURN WITH NOT-FOUND
        RET

SETLABEL:
        MOV     SI,OFFSET VOLWORK
;--------------------------------------------------------- 88/05/28 --
;       MOV     DI,OFFSET VOLTABLE
;       MOV     AL,CURDRV
;       MOV     AH,12
;       MUL     AH
;       ADD     DI,AX
;---------------------------------------------------------------------
        MOV     AL,CURDRV
        CALL    SetDrive
        LEA     DI,[DI].BDS_VOLID
;---------------------------------------------------------------------
        MOV     CX,11
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        CLD
        REP     MOVSB
        POP     ES
        XOR     AL,AL
        STOSB
        RET

        PAGE

;********************************************************
;                                                       *
;       GET APROPRIATE BPB ADDR                         *
;        INPUT  : DRIVE NUMBER                          *
;              : POINT TO BUFFET WHICH READ FAT-ID      *
;        OUTPUT : POINT TO TRUE BPB                     *
;                                                       *
;********************************************************
GET_BPB_CODE            PROC    FAR
GET_BPB_CODE            ENDP
        call    pointbpb        ;
        call    dosetsub        ;
        jmp     exit            ;
;
;
pointbpb:
        CALL    CNVDRV          ;CONVERT DRIVE NUMBER TO DA/UA
        PUSH    DS              ;SAVE CURRENT DS
        LDS     BX,[PTRSAV]     ;DS:BX <-
        LES     DI,[BX.TRANS]   ;ES:DI <-
        MOV     AH,ES:[DI]      ;GET FAT ID FROM BUFFER
                                ;WE ASSUME IBM FORMATTED MEDIA
        POP     DS              ;RESTORE  DS
POINTBPB10:
IF BRANCH ;----------------------------------------------- 90/03/16 --
        TEST    CURUA,08H       ;VIRTUAL DRIVE ?
        JZ      POINTBPB20
        JMP     GET_VTBPB       ;SKIP IF SO
ENDIF ;---------------------------------------------------------------
POINTBPB20:
        CMP     AL,90H          ;DA = 8"FD ?
        JE      GET_8FD         ;SKIP IF SO
        CMP     AL,80H          ;DA = SASI HD ?
        JNZ     POINTBPB30
        JMP     GET_HD          ;SKIP IF SO
;       JMP     GET_5HD         ;SKIP IF SO
POINTBPB30:
        CMP     AL,0A0H         ;DA = SCSI HD ?
        JNZ     POINTBPB40
;--------------------------------------------------------- 89/08/18 --
        CMP     [MOSW],00H      ;MO DISK OR SCSI HD
        JNZ     POINTBPB35
        JMP     GET_HD          ;SCSI HD
;       JMP     GET_SHD         ;SCSI HD
POINTBPB35:
        JMP     GET_MO          ;MO DISK
;---------------------------------------------------------------------
POINTBPB40:
        CMP     AL,70H          ;DA = 5"FD(2DD) ?
        JE      GET_5FD         ;SKIP IF SO

        pop     bx              ;
        MOV     AX,1            ;SET ERROR CODE, UNKNOWN UNIT
        JMP     DSK_ERR_EXIT

IF HDSASI ;----------------------------------------------- 88/03/25 --
GET_VTBPB:
;
;       SET APROPRIATE ADDR OF VIRTUAL
;
;IF BRANCH      ;------------------------------------ 871002 ---------
        CALL    SUBVTB
        MOV     BL,[CURUA]              ;850516(I)
        AND     BL,03H                  ;850516(I)
        MOV     CL,BL                   ;850516(I)
        MOV     BL,10H                  ;850516(I)
        SHL     BL,CL                   ;850516(I)
        XOR     [VDSK_AI],BL            ;850516(I) STRIP AI FALG
        MOV     AL,[SI+BPB_MDA]         ;850507 GET (NEW)MEDIA DISCRIPTOR
;ENDIF  ;-------------------------------------------------------------
        ret                             ;
;
;       SET APROPRIATE ADDR OF SASI HD
;
GET_5HD:
        CALL    CALLOG
        XOR     AL,AL
        ret                             ;
ENDIF ;---------------------------------------------------------------
IF HDSCSI ;----------------------------------------------- 88/03/25 --
;
;       SET APROPRIATE ADDR OF SCSI HD
;
GET_SHD:
        CALL    CALLOG
        XOR     AL,AL
        ret                             ;
ENDIF ;---------------------------------------------------------------
;
;       SET APROPRIATE ADDR OF 8"FD
;
GET_8FD:
;-------85/03/05---------------
        MOV     SI,OFFSET BIDTBL
        MOV     AL,CURUA
        PUSH    AX
        XOR     AH,AH
        ADD     SI,AX
        POP     AX
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        extrn   patch144_3:near
        public  GET_8FD05, GET_5FD_UPS
        public  DSK_ERR_EXIT, GET_SET_EXBPB

        jmp     patch144_3
        db      2 dup (90h)
;---------------
;       TEST    BYTE PTR [SI],80H
;       JE      GET_5FD_UPS     ;850610
;---------------------------------------------------------------------
;-------85/03/05--------------- 
;----------------------------------------------------- 870913 MAMA ---
GET_8FD05:
;---------------------------------------------------------------------
        CMP     AH,-2           ;CHECK FAT-ID
        JE      GET_8FD10
        CMP     AH,-7           ;IBM-AT MEDIA
        JE      GET_8FD10
        MOV     AL,7
        pop     bx              ;
        JMP     DSK_ERR_EXIT    ;UNKNOWN RETURN
;
GET_8FD10:
        MOV     SI,OFFSET DSK8_SNG
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        extrn   patch144_7:near

        public  patch144_7_ret, GET_SET_EXBPB

        jmp     patch144_7
patch144_7_ret:
;---------------
;       MOV     BX,OFFSET PREDNST
;---------------------------------------------------------------------
        MOV     AL,CURUA
        XLAT                            ;GET MEDIA ID
        OR      AL,AL                   ; 0 : 256KBFD
        JE      GET_8FD20               ; 1 : 1MBFD(98-FORM)
        SUB     AL,2                    ; 2 : NONE
        MOV     SI,OFFSET DSK_AT        ; 3 : 1MBFD(AT-FORM)
;---------------------------------------------------- 871004 ---------
        JNC     GET_8FD20
;---------------------------------------------------------------------
        MOV     SI,OFFSET DSK8_DBL
GET_8FD20:
;------------------------------------------------DOS5 90/01/19-----------
        JMP     SHORT GET_SET_EXBPB
;------------------------------------------------------------------------
;       MOV     AL,0
;       clc
;       ret                             ;
;------------------------------------------------------------------------
;
;       SET APROPRIATE ADDR OF 5"FD
;
GET_5FD_UPS:                            ;850610
        PUSH    AX                      ;850610
        MOV     SI,OFFSET PREFAT8       ;850610
        JMP     SHORT GET_5FD_UPS10     ;850610

GET_5FD:
;----------------------------------------------- 870913 --- MAMA -----
        MOV     SI,OFFSET BIDTBL5
        MOV     AL,[CURUA]
        PUSH    AX
        XOR     AH,AH
        ADD     SI,AX
        POP     AX
        TEST    BYTE PTR [SI],80H       ;1MB MEDIA (ON 640 I/F) ?
        JNZ     GET_8FD05
;---------------------------------------------------------------------
        PUSH    AX
        MOV     SI,OFFSET PREFAT        ;850610
GET_5FD_UPS10:                          ;850610
        CALL    EXCMOD
        POP     AX
        MOV     CX,6                    ;SET NUMBER OF MEDIA TYPE
        MOV     SI,OFFSET DSK5_SNG8-13+BPB_MDA
GET_5FD_10:
        ADD     SI,13
        CMP     [SI],AH                 ;CHECK FAT ID
        JE      GET_5FD_20
        LOOP    GET_5FD_10
;
;       ERROR, UNKNOWN DISK
;
        MOV     AL,7            ;SET ERROR CODE
        pop     bx              ;
        JMP     DSK_ERR_EXIT

GET_5FD_20:
;------------------------------------------------DOS5 90/01/19-----------
;       XOR     AL,AL
;       SUB     SI,BPB_MDA
;       ret                     ;
;------------------------------------------------------------------------
        SUB     SI,BPB_MDA
GET_SET_EXBPB:
        PUSH    ES
        PUSH    DI
        MOV     ES,CS:[BDATA_SEG]
        MOV     DI,OFFSET BPBCOPY
        PUSH    DI

        MOV     CX,13
        REP     MOVSB

        CMP     BYTE PTR [SI-3],00H
        JNE     GET_SET_EXBPB10
        MOV     AX,26
        JMP     SHORT GET_SET_EXBPB40
GET_SET_EXBPB10:
        CMP     BYTE PTR [SI-3],01H
        JNE     GET_SET_EXBPB20
        MOV     AX,8
        JMP     SHORT GET_SET_EXBPB40
GET_SET_EXBPB20:
        CMP     BYTE PTR [SI-3],02H
        JNE     GET_SET_EXBPB30
        MOV     AX,15
        JMP     SHORT GET_SET_EXBPB40
GET_SET_EXBPB30:
        MOV     AX,8
        TEST    BYTE PTR [SI-3],02H
        JNZ     GET_SET_EXBPB40
        MOV     AX,9
GET_SET_EXBPB40:
        STOSW                                   ;SET SECTORS/TRACK

        MOV     AX,2
        CMP     BYTE PTR [SI-3],02H
        JE      GET_SET_EXBPB50
        TEST    BYTE PTR [SI-3],01H
        JNZ     GET_SET_EXBPB50
        MOV     AX,1
GET_SET_EXBPB50:
        STOSW                                   ;SET HEADS/CYLINDER

        XOR     AX,AX
        MOV     CX,4
        REP     STOSW                           ;SET HIDDEN SECTORS, BIG TOTAL SECTORS

        MOV     AL,CURDRV
        CALL    SETDRIVE
        LEA     DI,[DI].BDS_BPB
        MOV     SI,OFFSET BPBCOPY
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        public  GET_SET_EXBPB60

GET_SET_EXBPB60:
;---------------------------------------------------------------------
        MOV     CX,25
        REP     MOVSB

        POP     SI                              ;OFFSET ADDDR OF BPBCOPY
        POP     DI
        POP     ES
        XOR     AL,AL
        CLC
        RET
;-----------------------------------------------------------------------
;
;       AH INCLUDS CURRENT FAT-ID
;
EXCMOD:
;------------------------------------------- 870913 MAMA -------------
        TEST    [SYS_501],08H           ;HW MODE IS HIRESO ?
        JZ      EXCEXIT                 ;NO, SKIP THIS OP.
;---------------------------------------------------------------------
                                  ;850610
        MOV     CL,CURUA          ;SET CURRENT UA
        XOR     CH,CH
        ADD     SI,CX
        CMP     AH,[SI]                 
        JE      EXCEXIT                 ;SKIP IF CURRENT = PREVIOUS
        MOV     AL,[SI]                 ;GET PRE FAT-ID TO AL
        MOV     [SI],AH                 ;UPDATE IT
        CMP     AH,-5                   ;CURRENT MEDIA IS 2DD ?
        JG      EXC_CUR_D               ;SKIP IF CURRENT IS 2D, ID
        CMP     AL,-5                   ;PREVIOUS MEDIA IS 1D, 2D ?
        JLE     EXCEXIT                 ;SKIP IF PREVIOUS 2DD
;
;       HERE..(CURRENT IS 2DD) AND (PREVIOUS IS 1D, 2D)
;        ISSUE MODE COMMAND
;
EXECHG:
        CALL    EXCMSG
        CALL    SETMOD
EXCEXIT:
        RET

EXC_CUR_D:
        CMP     AL,-5                   ;PREVIOUS MEDIA IS 2DD ?
        JG      EXCEXIT                 ;SKIP IF PREVIOUS IS 1D, 2D
;
;       HERE..(CURRENT IS 1D, 2D) AND (PREVIOUS IS 2DD)
;        ISSUE MODE COMMAND
;
        JMP     EXECHG
;-----------------------------------------------;
;                                               ;
;       ISSUE MODE COMMAND                      ;
;                                               ;
;-----------------------------------------------;
SETMOD:
        xor     ah,ah
        clc
        RET

        PAGE
;********************************************************
;*                                                      *
;*      READ                                            *
;*       INPUT : UNIT NUMBER IN AL                      *
;*             : MEDIA DISCRIPTER IN AH                 *
;*       OUTPUT: READ SPECIFIED SECTOR                  *
;*                                                      *
;********************************************************
DSK_READ_CODE   PROC    FAR
DSK_READ_CODE   ENDP
;----------------------------------------------- DOS5 91/01/22 -------
        PUSH    DI
        CALL    SETDRIVE
        TEST    WORD PTR [DI].BDS_FLAGS,UNFORMATTED_MEDIA
        POP     DI
        JZ      DSK_READ_FORMATTED
        MOV     AL,7
        PUSH    CX
        STC
        JMP     SHORT DSK_RW_EXIT

DSK_READ_FORMATTED:
;---------------------------------------------------------------------
        MOV     BYTE PTR VRFY_FLG,0     ;CLEAR VERIFY FLAG
        PUSH    CX                      ;SAVE REQUESTED DATA LENGTH
;----------------------------------------------- DOS5 92/06/22 -------
;<patch BIOS50-P20>
        extrn   PATCH04:near
        public  REMCHECK

        call    patch04
;---------------
;       CALL    REMCHECK                ;
;---------------------------------------------------------------------
        JB      DSK_RW_EXIT             ;
        CALL    READ                    ;EXECUTION
DSK_RW_EXIT:
        POP     DX                      ;RESTORE DATA LENGTH
        JNC     DSK_EXIT
        SUB     DX,CX
        LDS     BX,[PTRSAV]             
        MOV     [BX.COUNT],DX           ;SET TRANSFED DATA LENGTH
        CMP     AX,000FH
        JNZ     DSK_ERR_EXIT
        MOV     [BX.COUNT+4],DI         ;850822
;----------------------------------------------- DOS5 90/12/14 -------
        PUSH    AX
        MOV     AX,CS:[BDATA_SEG]
        MOV     [BX.COUNT+6],AX
        POP     AX
;----------------------------
;       MOV     [BX.COUNT+6],CS         ;850822
;---------------------------------------------------------------------
DSK_ERR_EXIT:
        JMP     ERR_EXIT

DSK_EXIT:
        JMP     EXIT

;********************************************************
;*                                                      *
;*      WRITE                                           *
;*       INPUT : UNIT NUMBER IN AL                      *
;*             : MEDIA DISCRIPTER IN AH                 *
;*       OUTPUT: READ SPECIFIED SECTOR                  *
;*                                                      *
;********************************************************
DSK_WRIT_CODE   PROC    FAR
DSK_WRIT_CODE   ENDP
;----------------------------------------------- DOS5 91/01/22 -------
        PUSH    DI
        CALL    SETDRIVE
        TEST    WORD PTR [DI].BDS_FLAGS,UNFORMATTED_MEDIA
        POP     DI
        JZ      DSK_WRITE_FORMATTED
        MOV     AL,7
        PUSH    CX
        STC
        JMP     DSK_RW_EXIT
        
DSK_WRITE_FORMATTED:
;---------------------------------------------------------------------
        MOV     BYTE PTR VRFY_FLG,0     ;CLEAR VERIFY FLAG
        PUSH    CX                      ;SAVE REQUESTED DATA LENGTH
;----------------------------------------------- DOS5 92/06/26 -------
;<patch BIOS50-P20>

        call    patch04
;---------------
;       CALL    REMCHECK                ;
;---------------------------------------------------------------------
        JB      DSK_RW_EXIT             ;
DSK_WRT_EXE:
        CALL    WRITE                   ;EXECUTION
        JMP     DSK_RW_EXIT
;
;       WRITE WITH VERIFY
;
DSK_WRTV_CODE   PROC    FAR
DSK_WRTV_CODE   ENDP
        MOV     BYTE PTR VRFY_FLG,1     ;SET VERIFY FLAG
        PUSH    CX
        JMP     DSK_WRT_EXE

        PAGE
;****************************************
;*                                      *
;*      CHECK REMAIN SECTOR             *
;*                                      *
;****************************************
REMCHECK:                               ;
        MOV     MYFAT,AH
        PUSH    AX                      ;
        PUSH    CX                      ;
        PUSH    DX                      ;
        PUSH    DI                      ;
        PUSH    ES                      ;
        CALL    CNVDRV                  ;
        CMP     CURDA,90H               ;
;----------------------------------------------- DOS5 90/12/22 -------
;PATCH
        JE      REM_1020
        JMP     SHORT REMEXIT
REM_1020:
;------------------
;       JNE     REMEXIT                 ;
;---------------------------------------------------------------------
        CMP     RETCODE,0C0H            ;
        JE      REM_1026                ;
        XOR     AX,AX                   ;
        MOV     ES,AX                   ;
        MOV     BX,OFFSET DISK_RESULT   ;
        XOR     AH,AH                   ;
        MOV     AL,CURUA                ;
        MOV     CL,3                    ;
        SHL     AL,CL                   ;
        ADD     BX,AX                   ;
        MOV     AL,ES:[BX]              ;
        MOV     MYATN,BX                ;
        AND     AL,0C0H                 ;
        CMP     AL,0C0H                 ;
        JNE     REMEXIT                 ;
;
REM_1026:                               ;
;--------------------------------------------------------- 88/05/28 --
;       MOV     BX,OFFSET REFCNT        ;
;       MOV     AL,CURDRV               ;
;       XLAT    [BX]                    ;
;       OR      AL,AL                   ;
;---------------------------------------------------------------------
        MOV     AL,CURDRV
        CALL    SetDrive
        CMP     [DI].BDS_OPCNT,0
        JE      REMEXIT                 ;
;
REM_1030:                               ;
        MOV     AL,CURDRV               ;
        MOV     AH,MYfat
        mov     cx,1
        mov     dx,1
        mov     di,offset dsk_buf
        push    ds
        pop     es
        call    read
;----------------------------------------------- DOS5 90/12/22 -------
;PATCH
        JNB     REM_1040
        MOV     AL,CURDRV
        CALL    SETDRIVE
        LEA     SI,[DI.BDS_VOLID]
        JMP     SHORT REM_ERROR
REM_1040:
;---------------------------------------------------------------------
        mov     ah,es:[di]              ;set fat-id byte
        mov     al,curda
        CALL    POINTBPB10              ;
        CALL    VOLCHECK                ;
        JNB     REMEXIT                 ;
REM_ERROR:
        XOR     AX,AX                   ;
        MOV     ES,AX                   ;
        MOV     BX,MYATN                ;
        OR      ES:BYTE PTR [BX],0C0H   ;
        POP     ES                      ;
        POP     DI                      ;
        POP     DX                      ;
        POP     CX                      ;
        POP     AX                      ;
        MOV     DI,SI                   ;
        MOV     AX,000FH                ;
        STC                             ;
        RET
;
REMEXIT:
        POP     ES                      ;
        POP     DI                      ;
        POP     DX                      ;
        POP     CX                      ;
        POP     AX                      ;
        MOV     RETCODE,00H             ;
        CLC                             ;
        RET                             ;
;
VOLCHECK:
        CALL    READLABEL               ;
        JB      VOLEXIT                 ;
;--------------------------------------------------------- 88/05/28 --
;       MOV     AL,CURDRV               ;
;       MOV     AH,12                   ;
;       MUL     AH                      ;
;---------------------------------------------------------------------
        MOV     DI,OFFSET VOLWORK       ;
;---------------------------------------------------------- 88/05/28 -
;       MOV     SI,OFFSET VOLTABLE      ;
;       ADD     SI,AX                   ;
;---------------------------------------------------------------------
        PUSH    DI
        MOV     AL,CURDRV
        CALL    SetDrive
        LEA     SI,[DI].BDS_VOLID
        POP     DI
;---------------------------------------------------------------------
        MOV     CX,11                   ;
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        PUSH    SI                      ;
        REPE    CMPSB                   ;
        POP     SI                      ;
        POP     ES
        JE      VOLEXIT                 ;
        STC                             ;
VOLEXIT:
        RET

        PAGE
;****************************************
;*                                      *
;*      DISK READ SUBROUTINE            *
;*                                      *
;****************************************

READ:
        MOV     BYTE PTR RW_SW,0        ;SET READ FUNCTION
        MOV     BYTE PTR COM1,06H       ;SET READ COMMAND
        JMP     short COMMON_PHASE              

;****************************************
;*                                      *
;*      DISK WRITE SUBROUTINE           *
;*                                      *
;****************************************

WRITE:
        MOV     BYTE PTR RW_SW,1        ;SET WRITE FUNCTION
        MOV     BYTE PTR COM1,05H       ;SET WRITE COMMAND

;****************************************
;*                                      *
;*      READ/WRITE COMMON ROUTINE       *
;*                                      *
;****************************************
COMMON_PHASE:
        MOV     BIOS_FLAG,1             ;INDICATE BIO BUSY STATE
        MOV     BP,DI                   ;SET DMA ADDRESS
        MOV     LNG_TRNS,CX             ;SAVE TRANSFER LENGTH
        MOV     CUR_TRNS,0              ;CLEAR TRANSFERED LENGTH
        MOV     NO_TRNS,0               ;CLEAR NON-TRANSFED LENGTH
        CALL    CNVDRV                  ;CONVRTED LOG TO DA/UA
        MOV     SW_5,0                  ;CLEAR 5"FD SWITCH
;       MOV     SW_HD,0                 ;CLEAR 5"HD SWITCH 	88/03/25
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        MOV     BL,-16                  ;-16 MEANS 'F0'
;---------------
;       MOV     BL,-7                   ;-7 MEANS 'F9'
;---------------------------------------------------------------------
        CMP     AL,90H                  
        JE      CMN_RW                  ;SKIP IF 8"FD
;--------------------------------------------------------- 88/03/25 --
        CMP     AL,80H                  ;SASI HD?
        JNZ     CMNPHASE10
        JMP     CMN_RW_HD               ;SKIP IF SASI HD
;       JMP     CMN_RW_SASI             ;SKIP IF SASI HD
CMNPHASE10:
        CMP     AL,0A0H                 ;SCSI HD OR MO DISK?
        JNZ     CMNPHASE20
;--------------------------------------------------------- 89/08/18 --
        CMP     [MOSW],00H
        JNZ     CMNPHASE15
        JMP     CMN_RW_HD               ;SKIP IF SCSI HD
;       JMP     CMN_RW_SCSI             ;SKIP IF SCSI HD
CMNPHASE15:
        JMP     CMN_RW_MO               ;SKIP IF MO DISK
;---------------------------------------------------------------------
CMNPHASE20:
;---------------------------------------------------------------------
        MOV     BL,-7                   ;-7 MEANS 'F9'
        NOT     SW_5
        CMP     AL,70H
        JE      CMN_RW          ;SKIP IF 5"FD
        CMP     AL,50H  ;****
        JE      CMN_RW  ;****   SKIP IF 5"320/160KB
        MOV     AL,1                    ;SET ERROR-UNKNOWN UNIT
ERR_RETG1:
        JMP     ERR_RET1
;
;
;       CHECK MEDIA DISCREIPTER
;
CMN_RW:
        CMP     AH,BL                   
        JGE     CMN_RW_20
        MOV     AL,7                    ;SET ERROR-UNKNOWN DISK
        JMP     ERR_RETG1

;
CMN_RW_15:
;       NOT     SW_HD                   ;SET UP HD ACCESS       88/03/25
CMN_RW_20:
        CMP     LNG_TRNS,0              ;TRANSFER LENGTH = 0 ?
        JE      RW_RET                  ;SKIP IF SO(NOT DONE)
        MOV     RTRY_CNT,AH             ;SAVE IT
        CALL    CONV_REC
        MOV     AH,RTRY_CNT             ;RESET IT
;--------------------------------------------------------- 88/03/25 --
;       CMP     BYTE PTR SW_HD,0                
;       JE      FD_RW                   
;       JMP     HD_RW                   ;JMP IF HARD DISK ACCESS
;---------------------------------------------------------------------

;****************************************
;*                                      *
;*      FLOPPY DISK READ/WRITE          *
;*                                      *
;****************************************

FD_RW:
        TEST    CURUA,08H               ;CHECK BRANCH-SPECIAL
        JNZ     FD_RW001                ;SKIP IF SO !!

;-----HERE,LOCAL MEDIA ONLY----
        TEST    AL,80H
        JNE     FD_RW001                ;SKIP IF 1MB ACESS MODE
        CMP     AH,-5
        JLE     FD_RW001
        CMP     BYTE PTR RW_SW,1
        JNE     FD_RW001
;       WRITE PROTECT ERROR
        MOV     AL,10
        JMP     ERR_RETG1
;
FD_RW001:
        PUSH    AX
        MOV     AX,S_SEC                ;SAVE NUMBER OF SECTORS ON TRACK
        INC     AX
        SUB     AL,DL
        MOV     MAX_TRNS,AX             ;SAVE IT
        CALL    EXCMSG
        POP     AX
RW_LOOP:
        CALL    SET_LENGTH
        MOV     BYTE PTR RTRY_CNT,5     ;SET RETRY  TIMES
RW_LOOPE:
        CALL    S_CMD                   ;SET BIO PARAMETERS
        JC      RTRY_RW
        CALL    VERIFY                  ;CHECK VERIFY AND EXECUTE
RW_LOOPDB:
        CMP     LNG_TRNS,0              ;READ/WRITE END ?
        JNE     RW_CONT                 ;SKIP IF NOT COMPLETE
RW_RET:
        CALL    STOP_CHK
        XOR     CX,CX
        RET

RW_CONT:
        CALL    S_REC1
RW_CONT1:
        PUSH    AX
        MOV     AX,S_SEC
        MOV     MAX_TRNS,AX
        POP     AX
        JMP     RW_LOOP

RTRY_RW:
        AND     AH,0F0H                 ;MASK HIGH BITS
;
;       (NOT READY),(WRITE  FAULT) DON'T NEED RECALIBLATE AND RETRY
;
;----------------------------------------- CHECK DB ERROR -----------
        CMP     AH,20H
        JE      DB_ERR
;------------------------------------------------------- BY MAMA ----
        CMP     AH,60H                  ;NOT READY
        JE      ERR_G1                  ;SKIP IF SO
        CMP     AH,70H                  ;WRITE PROTECT
        JE      ERR_G1                  ;SKIP IF SO
        DEC     BYTE PTR RTRY_CNT
        JNZ     SKP_RW
ERR_G1:
        JMP     ERROR

SKP_RW:
        CALL    RCBL                    ;RECALIBLATE HERE
        JMP     RW_LOOPE

;********************************
;*                              *
;*      DMA BOUNDARY            *
;*       ERROR HANDLE ROUTINE   *
;*                              *
;********************************
DB_ERR:
        CALL    COMP_DB
        OR      BX,BX                   ;TRANSFER BYTE = 0 ?
        JZ      DB_ERR1                 ;JUMP IF SO
        MOV     BYTE PTR RTRY_CNT,10
R_RW_DB:
        CALL    S_CMD
        JNC     SKP_RW1                 ;JUMP IF NO ERROR
        DEC     BYTE PTR RTRY_CNT
        JNZ     SKP_ERR1
        JMP     ERROR
SKP_ERR1:
        CALL    RCBL                    ;RECABLIRATE
        JMP     SHORT   R_RW_DB
SKP_RW1:
        CALL    VERIFY
        PUSH    AX
        MOV     AX,DB_TRNS
        SUB     CUR_TRNS,AX
        ADD     DL,AL                   ;SET SECTOR #
        POP     AX
        ADD     BP,BX
DB_ERR1:
        MOV     BX,LNG_SEC
        CALL    DB_ERR_DB               ;DB ERROR OPERATION
        CALL    VERIFY
        INC     DL
        DEC     CUR_TRNS
        JZ      RW_LOOPDB
SKP_RWDB:
        ADD     BP,BX
        PUSH    AX
        PUSH    DX
        MOV     AX,BX
        MUL     CUR_TRNS
        MOV     BX,AX
        POP     DX
        POP     AX
        MOV     BYTE PTR RTRY_CNT,10
R_RW_DB1:
        CALL    S_CMD
        JNC     SKP_RW2
        DEC     BYTE PTR RTRY_CNT
        JZ      ERROR
        CALL    RCBL                    ;RECABLIRATE
        JMP     SHORT R_RW_DB1
SKP_RW2:
        CALL    VERIFY
        JMP     RW_LOOPDB
DB_ERR_DB:
        CLD
        CMP     BYTE PTR RW_SW,0        ;READ ?
        JNE     DB_W                    ;JUMP IF NOT
        PUSH    ES
        PUSH    BP
        PUSH    DS
        POP     ES                      ;ES <= DS                       @DOS5
        MOV     BP,OFFSET DSK_BUF
        CALL    DB_RW
        POP     BP
        POP     ES
        JC      ERROR1
        MOV     SI,OFFSET DSK_BUF
        MOV     DI,BP
        PUSH    CX
        MOV     CX,BX                   ;SET TRANSFER LENGTH
        CLD
        REP     MOVSB
        POP     CX
        RET
DB_W:
        PUSH    ES
        PUSH    DS

        PUSH    AX
        MOV     AX,DS
        PUSH    ES
        POP     DS                      ;DS <= ES
        MOV     ES,AX                   ;ES <= DS
        POP     AX

        MOV     SI,BP
        MOV     DI,OFFSET DSK_BUF
        PUSH    CX
        MOV     CX,BX                   ;SET TRANSFER LENGTH
        REP     MOVSB
        POP     CX
        POP     DS
        PUSH    BP
        MOV     BP,OFFSET DSK_BUF
        CALL    DB_RW
        POP     BP
        POP     ES
        JC      ERROR1
        RET
ERROR1:
        POP     CX                      ;DUMMY POP
;------------------------------------------------------- BY MAMA ---

;****************************************
;*                                      *
;*      MAKE ERROR CODE                 *
;*      WHICH MS-DOS REQUESTS           *
;*                                      *
;****************************************

ERROR:
;----------------------------------------------- 871010 --------------
        CALL    ERR_SUB                 ;SET AI FLAG
;---------------------------------------------------------------------
        AND     AH,0F0H                 ;MASK HIGH BITS
        XOR     AL,AL                   ;CLEAR AL
        CMP     AH,70H                  ;NOT WRITABLE ?
        JE      ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=1
        CMP     AH,60H                  ;NOT READY ?
        JE      ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=2
        CMP     AH,0A0H                 ;DATA ERROR ?
        JE      ERR_RET                 ;SKIP IF SO
        CMP     AH,0B0H                 ;DATA ERROR ?
        JE      ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=3
        CMP     AH,0C0H                 ;SEEK ERROR  ?
        JE      ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=4
        CMP     AH,0D0H                 ;SECTOR NOT FOUND ?
        JAE     ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=5
        CMP     RW_SW,0                 ;READ ?
        JE      SKP_WRT_FLT             ;SKIP IF SO
        CMP     AH,40H                  ;WRITE  FAULT ?
        JE      ERR_RET                 ;SKIP IF SO
SKP_WRT_FLT:
        INC     AL                      ;AL=6
ERR_RET:
        SHL     AL,1                    ;SET ERROR CODE
ERR_RET1:
        MOV     CX,LNG_TRNS
        ADD     CX,CUR_TRNS
        ADD     CX,NO_TRNS
        CALL    STOP_CHK
        STC
        RET

;------------------------------------------------ 871010 -------------
;****************************************
;*                                      *
;*      SET AI FLAG                     *
;*                                      *
;****************************************
ERR_SUB:
        PUSH    AX
;------------------------------------------------ PATCH FIX 88/02/25 -
        AND     AL,70H
        CMP     AL,70H
        POP     AX
        PUSH    AX
;
;       TEST    AL,80H                  ;MEDIA ?
;----------------------------------------------------------------------
        JNZ     ERR8                    ;JUMP IF 1MB MEDIA
ERR5:                   ;SET 640KB MEDIA'S AI FLAG
        MOV     BX,OFFSET F2DD_RESULT   ;2DD RESULT AREA OFFSET
        MOV     CL,1                    ;SHIFT COUNT
        JMP     SHORT ERR_COMMON

ERR8:                   ;SET 1.2MB MEDIA'S AI FLAG
        MOV     BX,OFFSET DISK_RESULT   ;2HD RESULT AREA OFFSET
        MOV     CL,3                    ;SHIFT COUNT
ERR_COMMON:
        AND     AL,0FH                  ;ONLY UA
        SHL     AL,CL                   ;WORD(2DD) OR QWORD(3HD)
        MOV     CL,AL
        XOR     CH,CH
        ADD     BX,CX

        PUSH    ES
;------------------------------------------------ PATCH FIX 88/02/25 -
        XOR     CX,CX
        MOV     ES,CX                   ;SEGMENT 0
;       MOV     ES,CX                   ;SEGMENT 0
;       XOR     CX,CX
;---------------------------------------------------------------------
        OR      BYTE PTR ES:[BX],0C0H   ;SET 'AI' FLAG
        POP     ES
        POP     AX
        RET
;---------------------------------------------------------------------

;****************************************
;*                                      *
;*      SET BIOS INTERFACE PARAMETER    *
;*                                      *
;****************************************

CONV_REC:
        MOV     [DSK_TYP],0             ;SINGLE SIDED
        MOV     [COM],0D0H              ;8"2D, 5"2DD
        MOV     [LNG_SEC],1024          ;8"2D, 5"HD
        MOV     [S_SEC],8               ;8"2D, 5"2D(8), 5"2DD(8)
;--------------------------------------------------------- 88/03/25 --
;       CMP     [SW_HD],0               ;FD ACCESS ?
;       JE      SKP_HDSET               ;SKIP IF SO
;       MOV     [COM],00H               ;COMMAND OF HARD
;       JMP     CMN_PASS
;---------------------------------------------------------------------
SKP_HDSET:
        CMP     [SW_5],0                ;8"FD ACCESS ?
        JNE     SKP_8FDSET              ;SKIP IF NO
;
;       8"FD...
;
        TEST    [CURUA],08H
        JE      SKIP_VTB
        MOV     CH,3
        NOT     [DSK_TYP]               ;V-1MFD IS ONLY 2-SIDED. 850510 **
        JMP     CMN_PASSFD
;
SKIP_VTB:
        MOV     BX,OFFSET BIDTBL
        MOV     AL,CURUA
        XLAT
;--------------------------------------------------- 870913 MAMA -----
;       MOV     CURDA2,AL
;       AND     CURDA2,0F0H
;----------------
        MOV     [PWINF],AL
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        extrn   patch144_41:near
        public  SKP_8FDSETX, patch144_41_ret, CMN_PASSFD

        jmp     patch144_41
        db      90h
patch144_41_ret:
;;;---------------------------------------------------------------------
;;;     TEST    AL,80H                  ;1MB ?
;;;--------------------------------------------------- 870913 MAMA -----
;;;     JE      SKP_8FDSETX             ;SKIP IF 640KB
;;;---------------------------------------------------------------------
;
;-------ONLY 1 MB MEDIA AND 256KB HERE-------
;
        MOV     BX,OFFSET PREDNST
        MOV     AL,[CURUA]
        XLAT                            ;GET MEDIA TYPE BYTE
;------------------------------------------------------ 871003 -------
        MOV     BX,OFFSET NBYTETBL      ;DENSITY TABLE ADDR.
        XLAT    [BX]                    ;GET DENSITY
;---------------------------------------------------------------------
        OR      AL,AL
        MOV     CH,AL                   ;SET DENSITY
        JE      S_81                    ;SKIP IF SINGLE MEDIA

        NOT     [DSK_TYP]               ;DOUBLE SIDED
        CMP     CH,3
        JE      CMN_PASSFD              ;SKIP IF 1024B
        MOV     [LNG_SEC],512             ;IBM-AT
        MOV     [S_SEC],15
        JMP     short CMN_PASSFD
;
;       8"FD SIGLE SIDE, SIGLE DENSITY
;
S_81:
        MOV     [COM],10H               
        MOV     [LNG_SEC],128           ;SET BYTES/SECTOR
        MOV     CH,0                    ;SECTOR LENGTH 128
        MOV     [S_SEC],26              ;SET NUMBER OF SECTORS ON TRACK
        JMP     short CMN_PASSFD
;
;       5"FD...
;
SKP_8FDSET:
;-------------------------------------------------- 870912 -----------
        MOV     BX,OFFSET BIDTBL5
        MOV     AL,[CURUA]
        XLAT
        MOV     [PWINF],AL
        TEST    AL,80H                  ;1MB ?
        JZ      SKP_8FDSETX             ;SKIP IF 640KB
        MOV     BX,OFFSET PREDENS5
        MOV     AL,[CURUA]
        XLAT
        MOV     BX,OFFSET NBYTETBL5     ;DENSITY TABLE ADDR.
        XLAT    [BX]                    ;GET DENSITY
        MOV     CH,AL                   ;SET DENSITY
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        extrn   patch144_42:near

        jmp     patch144_42
        db      3 dup (90h)
;---------------
;       NOT     [DSK_TYP]
;       JMP     SHORT CMN_PASSFD
;---------------------------------------------------------------------

SKP_8FDSETX:
;---------------------------------------------------------------------
        MOV     CH,2                    ;SECTOR LENGTH 512
        CMP     AH,-1                   ;5"2D(8)
        JE      SKP_5FD9                ;SKIP IF SO
        CMP     AH,-2                   ;5"1D(8)
        JE      SKP_5FD9                ;SKIP IF SO
        CMP     AH,-5                   ;5"2DD(8)
        JE      SKP_5FD9                ;SKIP IF SO
        MOV     [S_SEC],9
SKP_5FD9:
        MOV     [LNG_SEC],512
        CMP     AH,-2                   ;5"1D(8)
        JE      CMN_PASSFD              ;SKIP IF SO
        CMP     AH,-4                   ;5"1D(9)
        JE      CMN_PASSFD              ;SKIP IF SO
        NOT     [DSK_TYP]
CMN_PASSFD:
        MOV     BX,[S_SEC]              ;SET NUMBER OF SECTOR ON TRACK
        MOV     AX,DX
        DIV     BL
        MOV     CL,AL                   ;SET CYLINDER #
        INC     AH
        MOV     DL,AH                   ;SET SECTOR #
        XOR     DH,DH                   ;SET HEAD #0
        CMP     [DSK_TYP],0     ;SINGLE SIDE ?
        JE      SKP_DSSET
        SHR     AL,1                    ;/2
        RCL     DH,1                    ;SET CYLINDER #
        MOV     CL,AL
SKP_DSSET:
CMN_PASS:
;------------------------------------------------------ 870913 MAMA --
;       MOV     AL,CURDA
;       TEST    CURUA,08H
;       JNE     CMN_BINSKIP
;       CMP     AL,90H
;       JNE     CMN_BINSKIP
;       MOV     AL,CURDA2               ;SET BI-DRIVE
CMN_BINSKIP:
;       OR      AL,CURUA
;----------------
        MOV     AL,[PWINF]              ;SET DA/UA
;---------------------------------------------------------------------
        RET

SET_LENGTH:
        PUSH    AX
        PUSH    DX
        MOV     AX,MAX_TRNS
        CMP     AX,LNG_TRNS
        JBE     SKP_X
        MOV     AX,LNG_TRNS
SKP_X:
        SUB     LNG_TRNS,AX
        MOV     CUR_TRNS,AX
        MUL     WORD PTR LNG_SEC
        MOV     BX,AX
        POP     DX
        POP     AX
        RET

S_REC1:
        MOV     DL,1                    ;SET SECTOR #
        CMP     BYTE PTR DSK_TYP,0      ;SINGLE SIDE
        JE      SNG_SIDE                ;SKIP IF SO
        XOR     DH,01H
        JNZ     S_REC_RET
SNG_SIDE:
        INC     CL                      ;INCREMENT CYLINDER #
S_REC_RET:
        PUSH    AX
        MOV     AX,ES
        CLC
        ADD     BP,BX                   ;SET I/O BUFFER
        JNB     S_REC2
        ADD     AX,1000H
        MOV     ES,AX
S_REC2:
        POP     AX
        RET

VERIFY:
        CMP     BYTE PTR VRFY_FLG,0     ;VERIFY FLG ON ?
        JE      V_RET                   ;SKIP IF NO
        MOV     BYTE PTR RTRY_CNT,10    ;SET RETRY TIMES
;--------------------------------------------------------- 88/03/25 --
;       CMP     BYTE PTR SW_HD,0        ;FD ACCESS ?
;       JE      VRFY_ENT                ;SKIP IF SO
;       MOV     BYTE PTR RTRY_CNT,3     ;SET RETRY TIMES
;---------------------------------------------------------------------
VRFY_ENT:
        PUSH    BP
        PUSH    ES
        XOR     BP,BP
        MOV     ES,BP
        MOV     AH,01H
        OR      AH,COM                  ;FORCE TO READ
        CALL    ROMBIO
        POP     ES
        POP     BP
        JC      VRFY_ERR
V_RET:
        RET
VRFY_ERR:
        DEC     BYTE PTR RTRY_CNT       ;DECREMENT RETRY COUNTER
        JZ      VRFY_ERR1
        CALL    RCBL                    ;EXECUTE RECALIBLATE
        JMP     VRFY_ENT
VRFY_ERR1:
        POP     CX
        JMP     ERROR

;
;       SET  COMMAND
;
S_HCMD:
;--------------------------------------------------------- 88/03/25 --
;       MOV     AL,CURUA
;       JMP     SHORT S_CMD10
;---------------------------------------------------------------------
S_CMD:
;-------------------------------------------------- 870913 MAMA ------
;       MOV     AL,CURDA
;       TEST    CURUA,08H
;       JNE     S_CMD05
;       CMP     AL,90H
;       JNE     S_CMD05
;       MOV     AL,CURDA2
S_CMD05:
;       OR      AL,CURUA
;----------------
        MOV     AL,[PWINF]
;---------------------------------------------------------------------
S_CMD10:
        MOV     AH,COM
        OR      AH,COM1
        CALL    ROMBIO
        RET

;------------------------------------------------ DB ERROR PROC ----
DB_RW:
        MOV     BYTE PTR RTRY_CNT,10
;--------------------------------------------------------- 88/03/25 --
;       CMP     BYTE PTR SW_HD,0        ;HD MODE ?
;       JE      SKP_DB_HD               ;JUMP IF NOT
;       MOV     BYTE PTR RTRY_CNT,3
DB_LOOP_HD:                             ;---------------------- BY MAMA -
;       CALL    S_HCMD                  ;HD I/O --------------- BY MAMA -
;       JNC     DB_RET                  ;NO ERROR ------------- BY MAMA -
;       DEC     [RTRY_CNT]              ;---------------------- BY MAMA -
;       JZ      DB_ERET                 ;RETRY IS OVER -------- BY MAMA -
;       CALL    RCBL                    ;RECALIBRATE ---------- BY MAMA -
;       JMP SHORT DB_LOOP_HD            ;RETRY ! -------------- BY MAMA -
;---------------------------------------------------------------------
SKP_DB_HD:
DB_LOOP:
        CALL    S_CMD                   ;SET COMMAND AND CALL FD BIO
        JNC     DB_RET                  ;JUMP IF NOT ERROR
        DEC     BYTE PTR RTRY_CNT
        JZ      DB_ERET
        CALL    RCBL
        JMP     SHORT   DB_LOOP
DB_ERET:
        STC
DB_RET:
        RET

COMP_DB:
        PUSH    AX
        PUSH    CX
        PUSH    DX
        MOV     DX,ES                   ;GET I/O BUFFER SEGMENT
        MOV     CL,4
        SHL     DX,CL
        ADD     DX,BP
        MOV     AX,0FFFFH
        SUB     AX,DX                   ;REST BYTES UNTIL DB ERROR
        XOR     DX,DX
        DIV     WORD PTR LNG_SEC        ;GET TRANSFER LENGTH IN AX
        MOV     DB_TRNS,AX              ;SAVE IT
        MUL     WORD PTR LNG_SEC
        MOV     BX,AX
        POP     DX
        POP     CX
        POP     AX
        RET

;-------------------------------------------------------- BY MAMA --

        PAGE
IF HDSASI ;-----------------------------------------------------------
;****************************************
;*                                      *
;*      HARD DISK READ/WRITE            *
;*                                      *
;****************************************

HD_RW:
        MOV     NO_TRNS,0               ;CLEAR NON-TRANSFED LENGTH FIELD
        XOR     BX,BX                   ;CLEAR BX
        MOV     AL,CURUA                ;SET CURRENT UA
        OR      AL,CURDA                ;MAKE DA/UA
        MOV     BX,OFFSET EXLPTBL+1     ;SET CONVERTING TABLE
        XOR     CX,CX
HD_RW10:
        CMP     BYTE PTR[BX],AL         ;FIND FIRST SAME DA/UA
        JE      HD_RW20                 ;SKIP IF HIT
        INC     BX
        INC     BX                      ;POINT NEXT ENTRY
        INC     CX                      ;INCREMENT COUNTER
        JMP     HD_RW10
HD_RW20:
        MOV     AL,CURDRV
        SUB     AL,CL                   ;GET RELATIVE VOLUME NUMBER IN DEV
        MOV     VOLNUM,AL               ;SAVE IT
        MOV     SI,OFFSET VT_LAST       ;850505
        CALL    GET_VT                  ;850505
        TEST    CURUA,08H
        JNE     HD_RW30
        MOV     BX,OFFSET HD_LAST       ;SET VOL SIZE TABLE ADDR
        TEST    CURUA,01H               ;#1 ?
        JZ      HD_RW30                 ;SKIP IF DEV=#0
        MOV     BX,OFFSET HD1_LAST      
HD_RW30:
        MOV     CX,LNG_TRNS
        SHL     AL,1                    ;DWORD POINTER
        SHL     AL,1
        XOR     AH,AH                   ;CLEAR AH
        ADD     BX,AX
        CMP     DX,[BX]                 ;REQUESTED START SECTOR IN THIS VOL ?
        JMP     SHORT   STRT_SEC_OK             ;1024.          
;
;       FAIL TO I/O...
;
        MOV     NO_TRNS,CX
        MOV     LNG_TRNS,0
        JMP     HD_RW_RET               ;ERROR RETURN (NO DONE)
;
STRT_SEC_OK:
        ADD     CX,DX
        SUB     CX,[BX]                 ;REQUESTED LAST SECTOR IN THIS VOL ?
        JMP     SHORT  SEC_OK                  ;        
        MOV     NO_TRNS,CX
        SUB     LNG_TRNS,CX             ;SET TRANSING DATA LENGTH
;
;       FINISH TO CHECK REQUESTED SECTOR NUMBER
;
SEC_OK:
        MOV     CX,LNG_TRNS             ;GET TRANSFERING DATA LENGTH
        MOV     CUR_TRNS,CX
        MOV     CL,VOLNUM
        XOR     CH,CH
        SHL     CL,1                    ; CL=CL*4, ENTRY HAS 4 BYTE
        SHL     CL,1
        MOV     SI,OFFSET VT_OFFSET     ;850505
        CALL    GET_VT                  ;850505
        CALL    GET_VBPS                ;850505 GET B.P.S INTO (SI)
        TEST    CURUA,08H
        JNE     SEC_OK10
        MOV     SI,BPS                  ;850507 SET BYTE/SECTOR IN DEV #0
        MOV     BX,OFFSET HD_OFFSET
        TEST    CURUA,01H               ;#0 DEV
        JZ      SEC_OK10                ;SKIP IF DEV=#0
        MOV     SI,BPS1                 ;SET BYTE PER SECTOR IN DEV #1
        MOV     BX,OFFSET HD1_OFFSET
SEC_OK10:
        ADD     BX,CX                   ;POINT CURRENT OFFSET TABLE
        MOV     CX,4
        MOV     AX,DX                   ;SET START SECTOR
        XOR     DX,DX
        MUL     CX                      ;1024. -> 256.
        ADD     AX,[BX]
        ADC     DX,[BX+2]               ;REP BY 256 BPS
SEC_OK15:
        MOV     CX,AX                   ;(DX.CX) IS NUMBER OF SECTOR

HD_LOOP:
        CMP     CUR_TRNS,64             
        JBE     L_OK                    ;SKIP IF CUR_TRNS < 64K
        MOV     CUR_TRNS,64             
L_OK:
        PUSH    CX
        MOV     CL,10
        MOV     AX,CUR_TRNS
        MOV     BX,AX
        SHL     BX,CL
        SUB     LNG_TRNS,AX
        POP     CX
        MOV     BYTE PTR RTRY_CNT,3     ;SET RETRY TIMES
RW_LOOP_HD:
        CALL    S_HCMD                  ;SET BIO PARAMETER
        JC      RTRY_RW_HD
        CALL    VERIFY
HD_RW_ENT:
        CMP     WORD PTR LNG_TRNS,0
        JE      HD_RW_RET
        MOV     AX,CUR_TRNS
HD_RW_SKIP:
        SHL     AX,1
        SHL     AX,1
        ADD     CX,AX
        ADC     DX,0                    ;10-25-85
        MOV     AX,LNG_TRNS
        MOV     CUR_TRNS,AX
        CLC
        ADD     BP,BX
        PUSH    AX
        MOV     AX,ES
        JNB     HD_BOUN
        ADD     AX,1000H
        MOV     ES,AX
HD_BOUN:
        POP     AX
        JMP     HD_LOOP

HD_RW_RET:
        CMP     NO_TRNS,0
        JE      NO_ERR_HD
        MOV     CUR_TRNS,0
        MOV     AH,0C0H
        JMP     ERROR
NO_ERR_HD:
        JMP     RW_RET
RTRY_RW_HD:
;------------------------------------------ DB ERR CHECK ---------
        AND     AH,0F0H
        CMP     AH,20H                  ;DB ERROR ?
        JE      DB_ERR_HD               ;YES,
;-----------------------------------------------------------------
        DEC     BYTE PTR RTRY_CNT       ;DECREMENT RETRY COUNTER
        JE      HD_ERROR
        CALL    RCBL
        JMP     RW_LOOP_HD

;------------------------------------------ DB ERROR PROC --------
DB_ERR_HD:
        CALL    COMP_DB
        OR      BX,BX
        JZ      SKP_PRER_HD
        MOV     [RTRY_CNT],3
RTRY_PRER:
        CALL    S_HCMD                  ;CHG "S_CMD" >> "S_HCMD" --BY MAMA--
        JNC     PRER_OK
        DEC     [RTRY_CNT]
        JZ      HD_ERROR
        CALL    RCBL
        JMP     SHORT   RTRY_PRER
HD_ERROR:
        JMP     ERROR
PRER_OK:
        CALL    VERIFY
        MOV     AX,[DB_TRNS]
        SUB     [CUR_TRNS],AX
        SHL     AX,1
        SHL     AX,1
PRER_OK05:
        CLC
        ADD     CX,AX
        ADC     DX,0                    ;10-23-85
        ADD     BP,BX
SKP_PRER_HD:
        MOV     BX,1024
        CALL    DB_ERR_DB
        CALL    VERIFY
        ADD     CX,4                    ;86-08-20
        ADC     DX,0                    ;10-23-85
        DEC     [CUR_TRNS]
        JNZ     SKP_RWDB_HD
        JMP     HD_RW_ENT
SKP_RWDB_HD:
        ADD     BP,BX
        PUSH    CX
        MOV     CL,10
        MOV     BX,[CUR_TRNS]
        SHL     BX,CL
        POP     CX
        MOV     [RTRY_CNT],3
REAR_HD:
        CALL    S_HCMD                  ;CHG "S_CMD" >> "S_HCMD" --BY MAMA--
        JNC     SKP_RW2_HD
        DEC     [RTRY_CNT]
        JZ      HD_ERROR
        CALL    RCBL
        JMP     SHORT   REAR_HD
SKP_RW2_HD:
        CALL    VERIFY
        JMP     HD_RW_ENT
ENDIF ;---------------------------------------------------------------
IF HDSASI ;-----------------------------------------------------------
;------------------------------------------------ BY MAMA ----------

CALLOG:
        MOV     AL,CURUA                ;SET CURRENY UA
        OR      AL,CURDA                ;MSKE DA/UA
        MOV     BX,OFFSET EXLPTBL+1     ;SET CONVERTING TABLE
        XOR     CX,CX                   ;CLEAR CX
CALLOG10:
        CMP     BYTE PTR[BX],AL         ;FIND FIRST SAME DA/UA
        JE      CALLOG20                ;SKIP IF MATCH
        INC     BX
        INC     BX
        INC     CX
        JMP     CALLOG10
CALLOG20:
        MOV     AL,CURDRV
        SUB     AL,CL                   ;GET RELATIVE VOLUME NUMBER IN DEV
        TEST    [CURUA],08H             ;850505 VIRTUAL ?
        JZ      CALLOG30X               ;850505 NO,
        MOV     BX,OFFSET VBPB          ;850505
        MOV     AL,[CURUA]              ;850505
        AND     AL,07H                  ;850505
        JMP     CALLOG30                ;850505
CALLOG30X:                              ;850505
        MOV     BX,OFFSET HDDSK5_1
        TEST    CURUA,01H
        JZ      CALLOG30                ;SKIP IF DEV=#0
        MOV     BX,OFFSET HDDSK5_2
CALLOG30:
        XOR     AH,AH
        MOV     CL,13
        XOR     CH,CH
        MUL     CX
        ADD     BX,AX
        MOV     SI,BX
CALLOG35:
        CALL    GET_SW                  ;850505
        MOV     BYTE PTR [DI],0         ;850505 CLEAR SWITCH
        CMP     WORD PTR [SI],1024      ;850505 CHECK B.P.S.
        JE      CALLOG40                ;850505
        MOV     BYTE PTR[DI],-1         ;850505 SET X2-ID.
CALLOG40:
        RET
ENDIF ;---------------------------------------------------------------
IF HDSASI ;-----------------------------------------------------------
;850505.850505.850505.850505.850505......
;                                       .
;       FOR VIRTUAL DRIVE               .
;                                       .
;......850505.850505.850505.850505.850505

GET_VT:
;......
        MOV     BL,[CURUA]
        AND     BX,0007H
        SHL     BX,1
        SHL     BX,1
        ADD     BX,SI
        RET

GET_VBPS:
;........
        PUSH    BX
        MOV     BL,[CURUA]
        AND     BX,0007H
        SHL     BX,1
        MOV     SI,[BX.VBPS]
        POP     BX
        RET

CHECK_X2SW:
;..........
        PUSH    BX
        PUSH    SI
        MOV     BL,[CURUA]
        TEST    BL,08H
        JZ      CHK_SW1
        AND     BX,0007H
        LEA     SI,[BX.X2_SW_VT]
        JMP     SHORT CHK_SW2
CHK_SW1:
        MOV     SI,OFFSET X2_SW_00
        TEST    BL,01H
        JZ      CHK_SW2
        MOV     SI,OFFSET X2_SW_01
CHK_SW2:
        TEST    BYTE PTR [SI],-1
        POP     SI
        POP     BX
        RET

GET_SW:
;......
        TEST    [CURUA],08H
        JZ      GET_SW350
        MOV     BL,[CURUA]
        AND     BX,0007H
        LEA     DI,[BX.X2_SW_VT]
        JMP     SHORT GET_SW351
GET_SW350:
        MOV     DI,OFFSET X2_SW_00
        TEST    [CURUA],01H
        JZ      GET_SW351
        MOV     DI,OFFSET X2_SW_01
GET_SW351:
        RET
ENDIF ;---------------------------------------------------------------

;------------------------------------------------------------;
;                                                            ;
;       RECALIBRATE HERE                                     ;
;                                                            ;
;------------------------------------------------------------;
RCBL:
        MOV     AH,07H          ;SET RECALIBLATE COMMAND
        CALL    ROMBIO          ;CALL ROM BIO ROUTINE
        RET

;------------------------------------------------------------;
;                                                            ;
;       CALL DISK BIO ROM                                    ;
;                                                            ;
;------------------------------------------------------------;
ROMBIO:
        XOR     AH,AH
        CLC
        RET

        PAGE

;
; Static Request Header:
;

SRHEAD  STRUC
REQLEN  DB      ?               ; Length in bytes of request block
REQUNIT DB      ?               ; Device unit number
REQFUNC DB      ?               ; Type of request
REQSTAT DW      ?               ; Status Word
        DB      8 DUP(?)        ; Reserved for queue links
SRHEAD  ENDS

;
; Generic IOCTL Request structure

IOCTL_Req Struc

                                DB      (size SRHEAD) DUP(?)
        MajorFunction           DB      ?       ; Function Code
        MinorFunction           DB      ?       ; Function Category     
        Reg_SI                  DW      ?
        Reg_DI                  DW      ?
        GenericIOCTL_Packet     DD      ?       ; Pointer to Data Buffer
IOCTL_Req ENDS

;
; Definitions for IOCTL_Req.MinorFunction:
;

GEN_IOCTL_WRT_TRK       EQU     40h
GEN_IOCTL_RD_TRK        EQU     60h
GEN_IOCTL_FN_TST        EQU     20h             ; Used to diff. bet reads and wrts
;
; These are all the important structures and equates for ioctl
;

;**     BIOS PARAMETER BLOCK DEFINITION
;
;       The BPB contains information about the disk structure.  It dates
;       back to the earliest FAT systems and so FAT information is
;       intermingled with physical driver information.
;
;       A boot sector contains a BPB for its device; for other disks
;       the driver creates a BPB.  DOS keeps copies of some of this
;       information in the DPB.
;
;       The BDS structure contains a BPB within it.
;



A_BPB                   STRUC
BPB_BYTESPERSECTOR      DW      ?
BPB_SECTORSPERCLUSTER   DB      ?
BPB_RESERVEDSECTORS     DW      ?
BPB_NUMBEROFFATS        DB      ?
BPB_ROOTENTRIES         DW      ?
BPB_TOTALSECTORS        DW      ?
BPB_MEDIADESCRIPTOR     DB      ?
BPB_SECTORSPERFAT       DW      ?
BPB_SECTORSPERTRACK     DW      ?
BPB_HEADS               DW      ?
BPB_HIDDENSECTORS       DW      ?
                        DW      ?
BPB_BIGTOTALSECTORS     DW      ?
                        DW      ?
                        DB      6 DUP(?)        ; NOTE:  many times these
;                                               ;        6 bytes are omitted
;                                               ;        when BPB manipulations
;                                               ;        are performed!
A_BPB                   ENDS

;*****************************;*
; BLOCK DRIVERS               ;*
;*****************************;*

; IOCTL SUB-FUNCTIONS
IOCTL_GET_DEVICE_INFO   EQU     0
IOCTL_SET_DEVICE_INFO   EQU     1
IOCTL_READ_HANDLE       EQU     2
IOCTL_WRITE_HANDLE      EQU     3
IOCTL_READ_DRIVE        EQU     4
IOCTL_WRITE_DRIVE       EQU     5
IOCTL_GET_INPUT_STATUS  EQU     6
IOCTL_GET_OUTPUT_STATUS EQU     7
IOCTL_CHANGEABLE?       EQU     8
IOCTL_DeviceLocOrRem?   EQU     9
IOCTL_HandleLocOrRem?   EQU     0Ah   ;10
IOCTL_SHARING_RETRY     EQU     0Bh   ;11
GENERIC_IOCTL_HANDLE    EQU     0Ch   ;12
GENERIC_IOCTL           EQU     0Dh   ;13
IOCTL_GET_DRIVE_MAP     EQU     0Eh   ;14
IOCTL_SET_DRIVE_MAP     EQU     0Fh   ;15
IOCTL_QUERY_HANDLE      EQU     10h   ;16
IOCTL_QUERY_BLOCK       EQU     11h   ;17


; GENERIC IOCTL CATEGORY CODES
IOC_OTHER               EQU     0       ; Other device control J.K. 4/29/86
IOC_SE                  EQU     1       ; SERIAL DEVICE CONTROL
IOC_TC                  EQU     2       ; TERMINAL CONTROL
IOC_SC                  EQU     3       ; SCREEN CONTROL
IOC_KC                  EQU     4       ; KEYBOARD CONTROL
IOC_PC                  EQU     5       ; PRINTER CONTROL
IOC_DC                  EQU     8       ; DISK CONTROL (SAME AS RAWIO)

; GENERIC IOCTL SUB-FUNCTIONS
RAWIO                   EQU     8

; RAWIO SUB-FUNCTIONS
GET_DEVICE_PARAMETERS   EQU     60H
SET_DEVICE_PARAMETERS   EQU     40H
READ_TRACK              EQU     61H
WRITE_TRACK             EQU     41H
VERIFY_TRACK            EQU     62H
FORMAT_TRACK            EQU     42H
GET_MEDIA_ID            EQU     66h             ;AN000;AN003;changed from 63h
SET_MEDIA_ID            EQU     46h             ;AN000;AN003;changed from 43h
GET_ACCESS_FLAG         EQU     67h             ;AN002;AN003;Unpublished function.Changed from 64h
SET_ACCESS_FLAG         EQU     47h             ;AN002;AN003;Unpublished function.Changed from 44h
SENSE_MEDIA_TYPE        EQU     68H             ;Added for 5.00


; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
BUILD_DEVICE_BPB        EQU     000000001B

; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
INSTALL_FAKE_BPB        EQU     000000001B
ONLY_SET_TRACKLAYOUT    EQU     000000010B
TRACKLAYOUT_IS_GOOD     EQU     000000100B

; SPECIAL FUNCTION FOR FORMAT TRACK
STATUS_FOR_FORMAT               EQU     000000001B
DO_FAST_FORMAT                  equ     000000010B      ;AN001;
; CODES RETURNED FROM FORMAT STATUS CALL
FORMAT_NO_ROM_SUPPORT           EQU     000000001B
FORMAT_COMB_NOT_SUPPORTED       EQU     000000010B

; DEVICETYPE VALUES
MAX_SECTORS_IN_TRACK    EQU     63      ; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
DEV_5INCH               EQU     0
DEV_5INCH96TPI          EQU     1
DEV_3INCH720KB          EQU     2
DEV_8INCHSS             EQU     3
DEV_8INCHDS             EQU     4
DEV_HARDDISK            EQU     5
DEV_OTHER               EQU     7
DEV_3INCH1440KB         EQU     7
DEV_3INCH2880KB         EQU     9

MAX_DEV_TYPE            EQU     9       ; MAXIMUM DEVICE TYPE THAT WE
                                        ; CURRENTLY SUPPORT.

A_SECTORTABLE       STRUC
ST_SECTORNUMBER         DW      ?
ST_SECTORSIZE           DW      ?
A_SECTORTABLE       ENDS

A_DEVICEPARAMETERS  STRUC
DP_SPECIALFUNCTIONS     DB      ?
DP_DEVICETYPE           DB      ?
DP_DEVICEATTRIBUTES     DW      ?
DP_CYLINDERS            DW      ?
DP_MEDIATYPE            DB      ?
DP_BPB                  DB      SIZE A_BPB DUP (?)
DP_TRACKTABLEENTRIES    DW      ?
DP_SECTORTABLE          DB MAX_SECTORS_IN_TRACK * SIZE A_SECTORTABLE DUP (?)
A_DEVICEPARAMETERS  ENDS

A_TRACKREADWRITEPACKET STRUC
TRWP_SPECIALFUNCTIONS   DB      ?
TRWP_HEAD               DW      ?
TRWP_CYLINDER           DW      ?
TRWP_FIRSTSECTOR        DW      ?
TRWP_SECTORSTOREADWRITE DW      ?
TRWP_TRANSFERADDRESS    DD      ?
A_TRACKREADWRITEPACKET ENDS

;AN001; - FP_TRACKCOUNT is only meaningful when FP_SPECIALFUNCTIONS bit 1 = 1.
A_FORMATPACKET      STRUC
FP_SPECIALFUNCTIONS     DB      ?
FP_HEAD                 DW      ?
FP_CYLINDER             DW      ?
FP_TRACKCOUNT           DW      1
A_FORMATPACKET      ENDS

A_VERIFYPACKET      STRUC
VP_SPECIALFUNCTIONS     DB      ?
VP_HEAD                 DW      ?
VP_CYLINDER             DW      ?
A_VERIFYPACKET      ENDS

A_MEDIA_ID_INFO     STRUC
MI_LEVEL                DW      0               ;J.K. 87 Info. level
MI_SERIAL               DD      ?               ;J.K. 87 Serial #
MI_LABEL                DB     11 DUP (' ')     ;J.K. 87 volume label
MI_SYSTEM               DB      8 DUP (' ')     ;J.K. 87 File system type
A_MEDIA_ID_INFO     ENDS

A_DISKACCESS_CONTROL    STRUC                   ;AN002; Unpublished function. Only for Hard file.
DAC_SPECIALFUNCTIONS    DB      0               ;AN002; Always 0
DAC_ACCESS_FLAG         DB      0               ;AN002; Non Zero - allow disk I/O to unformatted hard file
A_DISKACCESS_CONTROL    ENDS                    ;AN002; 0 - Disallow disk I/O to unformatted hard file


A_MEDIA_SENSE   STRUC                   ; Media sense structure added 5.00
MS_ISDEFAULT            DB      ?       ; If 1 type returned is drv default
MS_DEVICETYPE           DB      ?       ; Drive type 
MS_RESERVED1            DB      ?       ; RESERVED
MS_RESERVED2            DB      ?       ; RESERVED 
A_MEDIA_SENSE   ENDS



EXT_BOOT_SIGNATURE       EQU     41             ;Extended boot signature
;
EXT_BPB_INFO            STRUC
EBPB_BYTESPERSECTOR      DW      ?
EBPB_SECTORSPERCLUSTER   DB      ?
EBPB_RESERVEDSECTORS     DW      ?
EBPB_NUMBEROFFATS        DB      ?
EBPB_ROOTENTRIES         DW      ?
EBPB_TOTALSECTORS        DW      ?
EBPB_MEDIADESCRIPTOR     DB      ?
EBPB_SECTORSPERFAT       DW      ?
EBPB_SECTORSPERTRACK     DW      ?
EBPB_HEADS               DW      ?
EBPB_HIDDENSECTOR        DD      ?
EBPB_BIGTOTALSECTORS     DD      ?
EXT_BPB_INFO            ENDS
;
;AN001; EXT_PHYDRV, EXT_CURHD included in the header for OS2.
EXT_IBMBOOT_HEADER      STRUC
EXT_BOOT_JUMP           DB      3 DUP (?)
EXT_BOOT_OEM            DB      8 DUP (?)
EXT_BOOT_BPB            DB      size EXT_BPB_INFO dup (?)
EXT_PHYDRV              DB      80h
EXT_CURHD               DB      0
EXT_BOOT_SIG            DB      EXT_BOOT_SIGNATURE
EXT_BOOT_SERIAL         DD      ?
EXT_BOOT_VOL_LABEL      DB      11 DUP (?)
EXT_SYSTEM_ID           DB      8  DUP (?)
EXT_IBMBOOT_HEADER      ENDS


; The following structure defines the disk parameter table

DISK_PARMS      STRUC
DISK_SPECIFY_1  DB      ?
DISK_SPECIFY_2  DB      ?
DISK_MOTOR_WAIT DB      ?       ; Wait till motor off
DISK_SECTOR_SIZ DB      ?       ; Bytes/Sector (2 = 512)
DISK_EOT        DB      ?       ; Sectors per track (MAX)
DISK_RW_GAP     DB      ?       ; Read Write Gap
DISK_DTL        DB      ?
DISK_FORMT_GAP  DB      ?       ; Format Gap Length
DISK_FILL       DB      ?       ; Format Fill Byte
DISK_HEAD_STTL  DB      ?       ; Head Settle Time (MSec)
DISK_MOTOR_STRT DB      ?       ; Motor start delay
DISK_PARMS      ENDS

ROMRead         equ     6
ROMWrite        equ     5
ROMVerify       equ     1
ROMFormat       equ     0DH


; values for various flags in bds_flags.

fnon_removable      equ     01h         ;for non-removable media
fchangeline         equ     02h         ;if changeline supported on drive
return_fake_bpb     equ     04h         ; when set, don't do a build bpb
                                        ; just return the fake one
good_tracklayout    equ     08h         ; the track layout has no funny sectors
fi_am_mult          equ     10h         ;if more than one logical for this physical
fi_own_physical     equ     20h         ;signify logical owner of this physical
fchanged            equ     40h         ;indicates media changed
set_dasd_true       equ     80h         ; set dasd before next format
fchanged_by_format  equ    100h         ;media changed by format
unformatted_media   equ    200h         ;an001; fixed disk only

MAXERR  =            5


;
; various form factors to describe media
;
ff48tpi             equ     0
ff96tpi             equ     1
ffsmall             equ     2
ffhardfile          equ     5
ffother             equ     7
ff288               equ     9           ; 2.88 MB drive


bds_struc       struc
bds_link        dd              0ffffh  ; link to next bds
bds_drivenum    db              80      ; int 13 drive number
bds_drivelet    db              3       ; dos drive number

;       We want to embed a BPB declaration here, but we can't initialize
;       it properly if we do, so we duplicate the byte/word/dword architecture
;       of the BPB declaration.

;BDS_BPB        db      size BPBSTRUC dup (?)   ; actual BPB
BDS_BPB         dw      512             ; BPB_BYTESPERSECTOR
                db      1               ; BPB_SECTORSPERCLUSTER
                dw      1               ; BPB_RESERVEDSECTORS
                db      2               ; BPB_NUMBEROFFATS
                dw      16              ; BPB_ROOTENTRIES
                dw      0               ; BPB_TOTALSECTORS
                db      0f8h            ; BPB_MEDIADESCRIPTOR
                dw      1               ; BPB_SECTORSPERFAT
                dw      0               ; BPB_SECTORSPERTRACK
                dw      0               ; BPB_HEADS
                dd      0               ; BPB_HIDDENSECTORS
                dd      0               ; BPB_BIGTOTALSECTORS

bds_fatsiz      db              0       ; flags...
bds_opcnt       dw              0       ; open ref. count
bds_formfactor  db              3       ; form factor index
bds_flags       dw              0020h   ; various flags
bds_ccyln       dw              40      ; max number of cylinders

BDS_RBPB        db size A_BPB dup (0)   ; recommended BPB

bds_track       db              -1      ; last track accessed on drive
bds_tim_lo      dw              1       ; time of last access. keep
bds_tim_hi      dw              0       ; these contiguous.
bds_volid       db "NO NAME    ",0      ; volume id of medium
bds_vol_serial  dd      0         ;current volume serial number from boot record
bds_filesys_id  db      "FAT12   ",0 ; current file system id from boot record
bds_struc       ends

;       The assembler will generate bad data for "size bds_volid", so we'll
;         define an equate here.

VOLID_SIZ       equ     12

bdsm_ismini     equ     bds_tim_lo      ; overlapping bds_tim_lo
bdsm_hidden_trks equ    bds_tim_hi      ; overlapping bds_tim_hi

max_mini_dsk_num = 23         ; max # of mini disk ibmbio can support


BPB_Type struc
    secsize dw      ?
    secall  db      ?
    resnum  dw      ?
    fatnum  db      ?
    dirnum  dw      ?
    secnum  dw      ?
    fatid   db      ?
    fatsize dw      ?
    slim    dw      ?
    hlim    dw      ?
    hidden  dw      ?
BPB_Type ends


; Bios Parameter Block definition

BPBLOCK STRUC
BPSECSZ DW      ?                       ; Size in bytes of physical sector
BPCLUS  DB      ?                       ; Sectors/Alloc unit
BPRES   DW      ?                       ; Number of reserved sectors
BPFTCNT DB      ?                       ; Number of FATs
BPDRCNT DW      ?                       ; Number of directory entries
BPSCCNT DW      ?                       ; Total number of sectors
BPMEDIA DB      ?                       ; Media descriptor byte
BPFTSEC DW      ?                       ; Number of sectors taken up by one FAT
BPBLOCK ENDS


;----------------------------------------------- DOS5 91/01/10 -------
;
; The following two sets of variables are used to hold values for
; disk I/O operations

;CURSEC DB      0                       ; current sector
;CURHD  DB      0                       ; current head
;CURTRK DW      0                       ; current track
;
;
; The following are used for IOCTL function calls
;
;
;HDNUM          DB      0                   ; Head number
;TRKNUM         DW      0                   ; Track being manipulated
;GAP_PATCH      DB      50h                 ; Format gap patched into DPT
;FORMT_EOT      DB      8                   ; EOT used for format
;
;--------------------------------------------------------- 89/08/08 --
;PATCH0         DW      0
;PATCH1         DW      0
;PATCH3         DB      0
;---------------------------------------------------------------------
;----------------------------------------------- DOS5 91/01/10 -------
;MAX_SECTORS_CURR_SUP   equ     40      ; current maximum sec/trk that
;                                               ; we support
;
;
;
; TrackTable is an area for saving information passwd by the set device
; parameter function for laster use my Read/Write/Format/Verify.
;

;TrackTable     db      MAX_SECTORS_CURR_SUP * size a_SectorTable dup (?)
;
;
;sectorsPerTrack dw     15
;
;mediaType      db      0
;
;Media_Set_For_Format   db      0       ; 1 if we have done an Int 13 Set Media
;                                       ; Type for Format call
;
;fSetOwner      db      0
;
;PART_NUM       DB      0
;---------------------------------------------------------------------
; ==========================================================================
;
; NOTE: GetAccessFlag/SetAccessFlag is unpublished function.
;
;      This function is intended to give the user to control the
;      bds table flags of unformatted_media bit.
;      GetAccessFlag will show the status -
;        a_DiskAccess_Control.dac_access_flag = 0 disk i/o not allowed
;                                               1 disk i/o allowed
;      SetAccessFlag will set/reset the unformatted_media bit in flags -
;        a_DiskAccess_Control.dac_access_flag = 0 allow disk i/o
;                                               1 disallow disk i/o
; ==========================================================================

                        ; generic ioctl dispatch tables

IoReadJumpTable db      8                       ;maximum number (zero based)
                dw      GetDeviceParameters     ;60h
                dw      ReadTrack               ;61h
                dw      VerifyTrack             ;62h
                dw      Cmd_Error_Proc          ;overlapped with os2 subfunction
                dw      Cmd_Error_Proc
                dw      Cmd_Error_Proc
                dw      GetMediaId              ;66h
                dw      GetAccessFlag           ;67h unpublished function
                dw      SenseMediaType          ;68

IoWriteJumpTable db     7
                dw      SetDeviceParameters     ;40h
                dw      WriteTrack              ;41h
                dw      FormatTrack             ;42h
                dw      Cmd_Error_Proc
                dw      Cmd_Error_Proc
                dw      Cmd_Error_Proc
                dw      SetMediaId              ;46h
                dw      SetAccessFlag           ;47h unpublished function

; ==========================================================================
; IOC_DC_Table
;
; This table contains all of the valid generic IOCtl Minor codes for
; major function 08 to be used by the Ioctl_Support_Query function.
; Added for 5.00
; ==========================================================================

IOC_DC_Table  LABEL BYTE

        db      GET_DEVICE_PARAMETERS   ; 60H
        db      SET_DEVICE_PARAMETERS   ; 40H
        db      READ_TRACK              ; 61H
        db      WRITE_TRACK             ; 41H
        db      VERIFY_TRACK            ; 62H
        db      FORMAT_TRACK            ; 42H
        db      GET_MEDIA_ID            ; 66h changed from 63h
        db      SET_MEDIA_ID            ; 46h changed from 43h
        db      GET_ACCESS_FLAG         ; 67h Unpublished func changed frm 64h
        db      SET_ACCESS_FLAG         ; 47h Unpublished func changed frm 44h
        db      SENSE_MEDIA_TYPE        ; 68 Added in 5.00

IOC_DC_TABLE_LEN EQU $ - OFFSET IOC_DC_Table


;
;Generic$IOCTL:
;    Perform Generic IOCTL request
;    Input:
;       al      - unit number
;    Output:
;       if carry set then al contains error code
;
Generic$IOCTL_CODE      PROC    FAR
Generic$IOCTL_CODE      ENDP
        CALL    CNVDRV                  ;CONVERT DA/UA
        MOV     AL,CURDRV               ;
        les     bx,ds:[PTRSAV]          ; es:bx points to request header.@DOS5
        call    SetDrive                ; ds:di points to BDS for drive.
;
; At this point:
;    es:bx - points to the Request Header
;    ds:di points to the BDS for the drive
;
        cmp     es:[bx].MajorFunction, RAWIO
        jne     IOCTL_Func_Err
        mov     al, es:[bx].MinorFunction
        mov     si, offset IOReadJumpTable
        test    al, GEN_IOCTL_FN_TST                    ; Test of req. function
        jnz     NotGenericIoctlWrite                    ;   function is a Read.
        mov     si, offset IOWriteJumpTable
NotGenericIoctlWrite:
        and     al, 0fH
        cmp     al, cs:[si]
        ja      IOCTL_Func_Err
        cbw
        shl     ax, 1
        inc     si
        add     si,ax
        les     bx, es:[bx].GenericIOCTL_Packet
        call    cs:[si]
        jc      FailGeneric$IOCTL
        jmp     exit

FailGeneric$IOCTL:
        jmp     ERR_EXIT

IOCTL_Func_Err:
        jmp CMD_ERR

;------------------------------------------------DOS5 90/12/14-----------
Cmd_Error_Proc:
        MOV     AL,3
        STC
        RET
;------------------------------------------------------------------------


        PAGE
;
; GetDeviceParameters:
;
; Input: DS:DI points to BDS for drive
;        ES:BX points to device parameter packet
;

GetDeviceParameters proc near
        mov     al, byte ptr ds:[di].BDS_FormFactor
        mov     byte ptr es:[bx].DP_DeviceType, al
        mov     ax, word ptr ds:[di].BDS_Flags
        and     ax,fNon_Removable+fChangeline   ; mask off other bits
        mov     word ptr es:[bx].DP_DeviceAttributes, ax
        mov     ax, word ptr ds:[di].BDS_cCyln
        mov     word ptr es:[bx].DP_Cylinders, ax

        xor     al, al
        mov     byte ptr es:[bx].DP_MediaType, al

        lea     si, byte ptr [di].BDS_RBPB.BPB_BYTESPERSECTOR
        mov     cx, size A_BPB - 6              ; for now use 'small' BPB

        test    byte ptr es:[bx].DP_SpecialFunctions, BUILD_DEVICE_BPB
        jz      use_BPB_present
        call    CheckSingle
;--------------------------------------------------------- 88/05/28 --
;-----------------------------------------------------  89/07/27  ---
        TEST    BYTE PTR [CURDA],10H
        JZ      GET_PARA_10
        JMP     GET_PARA_FD
GET_PARA_10:
        PUSH    DS
        PUSH    BX
;-----------------------------------------------------  89/07/27  ---
        push    es
        CALL    READ_FAT
        JC      GET_ERR
        MOV     AL,CURDA
        MOV     AH,ES:BYTE PTR [DI]
        call    POINTBPB10              ;POINT SI BPB
;---------------------------------------------------------------------
        JC      GET_ERR
        pop     es
        POP     BX
        POP     DS
        MOV     CX,SIZE A_BPB - 6                       ;SMALL BPB
use_BPB_present:
        lea     di, byte ptr [bx].DP_BPB
        PUSH    DI
        rep     movsb
        POP     DI
;----------------------------------------------- DOS5 91/04/01 -------
        JMP     Get_Parm_OK
;---------------
;       test    byte ptr es:[bx].DP_SpecialFunctions, BUILD_DEVICE_BPB
;       jz      Get_Parm_OK
;       TEST    CURDA,10H
;       JNZ     GET_PARA_FD
;       CMP     MOSW,0FFH
;       JNZ     GET_PARA_025
;       MOV     BYTE PTR ES:[DI].BPB_SECTORSPERTRACK,40H
;       MOV     BYTE PTR ES:[DI].BPB_HEADS,1
;       JMP short       GET_PARA_028
;GET_PARA_025:
;       CALL    SENSE_HD
;       JC      Get_Parm_Ret
;       MOV     BYTE PTR ES:[DI].BPB_SECTORSPERTRACK,DL
;       MOV     BYTE PTR ES:[DI].BPB_HEADS,DH
;GET_PARA_028:
;       TEST    CURDA, 20H
;       JNZ     GET_PARA_030
;       MOV     SI,OFFSET HD_OFFSET
;       JMP     short GET_PARA_040
;GET_PARA_030:
;       MOV     SI,OFFSET HDS_OFFSET
;GET_PARA_040:
;       XOR     AH,AH
;       MOV     AL,CURUA
;       MOV     CL,4
;       SHL     AX,CL
;       ADD     SI,AX
;       CALL    CHECK_PART
;       XOR     AH,AH
;       MOV     AL,PART_NUM
;       SHL     AX,1
;       SHL     AX,1
;       ADD     SI,AX
;       MOV     AX,WORD PTR [SI]
;       MOV     ES:[DI].BPB_HIDDENSECTORS,AX
;       JMP     short Get_Parm_OK
;--------------------------------------------------------------------
GET_ERR:
        JMP     short GET_PARM_ERR


GET_PARA_FD:
;----------------------------------------------------   89/07/24  ---
PAT0010:
        PUSH    DS
        PUSH    BX
        PUSH    ES
        MOV     DX,0000H
        CALL    READ_DISK
        JNB     PAT0030
PAT0020:
        JMP     short GET_PARM_ERR
PAT0030:
        POP     ES
        POP     BX
        POP     DS
        MOV     SI,BP
        ADD     SI,0BH
        MOV     CX,0013H
        LEA     DI,[BX.DP_BPB]
        REPZ    MOVSB
;----------------------------------------------- DOS5 91/04/01 -------
        XOR     AX,AX
        MOV     CX,3
        REP     STOSW
;---------------------------------------------------------------------
;---------------------------------------------------    89/07/24  ---

Get_Parm_OK:
        clc
Get_Parm_Ret:
        ret
Get_Parm_ERR:
        pop     es
        POP     BX
        POP     DS
        JMP     Get_Parm_Ret
GetDeviceParameters endp

CHECK_PART:
        PUSH    CX
        PUSH    BX
        PUSH    AX
        XOR     CH,CH
        MOV     CL,CURDRV
        MOV     BX,OFFSET EXLPTBL+1
CHECK_LOOP:
        MOV     AL,BYTE PTR [BX-2]
        CMP     BYTE PTR [BX],AL        ;CHECK DA/UA
        JZ      CHECK010
        MOV     PART_NUM,0
        JMP     short CHECK020

CHECK010:
        INC     PART_NUM
CHECK020:
        LOOP    CHECK_LOOP
        POP     AX
        POP     BX
        POP     CX
        RET


READ_FAT:
        MOV     DX,1            ;FAT
READ_DISK:                                      ;               89/07/24

        PUSH    ds
        POP     ES
        MOV     DI,OFFSET DSK_BUF2
        MOV     AL,CURDRV
        MOV     CX,1
;----------------------------------------------- DOS5 91/01/22 -------
        MOV     [START_SEC_H],0
;---------------------------------------------------------------------
        CALL    READ
        RET

READ_ID:
        CLC
        RET

;----------------------------------------------- DOS5 91/04/01 -------
;;************************************************870815NEW
;;*                                             *
;;*     HARD DISK SENSE                         *
;;*                                             *
;;*     INPUT : NONE                            *
;;*     OUTPUT: CF=0:NORMAL                     *
;;*              AH     HD CAPACITY             *
;;*              BX     BYTES / SECTOR          *
;;*              DH     TRACKS / CYLINDER       *
;;*              DL     SECTORS / TRACK         *
;;*             CF=1:ERROR                      *
;;*                                             *
;;************************************************
;SENSE_HD:
;       MOV     CX,5                    ;RETRY COUNT
;SNSHD00:
;       XOR     BX,BX
;       MOV     AH,84H                  ;SET SENSE COMMAND
;       MOV     AL,CURDA                ;SET DA/UA
;       OR      AL,CURUA
;       INT     1BH                     ;EXECUTE SENSE COMMAND
;       JNC     SNSHD01                 ;SKIP IF SENSE GOOD
;       LOOP    SNSHD00
;       STC                             ;SET CARRY
;       RET
;
;SNSHD01:
;       OR      BX,BX                   ;BYTE/SEC = 0 (OLD BIOS) ?
;       JNZ     SNSHD01?SKIP?N          ;NO,
;       MOV     BX,256                  ;BYTES/SECTOR
;       MOV     DL,33                   ;SECTORS/TRACK
;       MOV     DH,4                    ;IF CAPACITY >= 20(MB)
;       CMP     AH,3                    ;   THEN TRACKS/CYLINDER = 8
;       JB      SNSHD01?SKIP?N          ;   ELSE TRACKS/CYLINDER = 4
;       MOV     DH,8                    ;
;SNSHD01?SKIP?N:
;       CLC
;       RET
;--------------------------------------------------------------------

        PAGE
;
; SetDeviceParameters:
;
; Input: DS:DI points to BDS for drive
;        ES:BX points to device parameter packet
;
SetDeviceParameters proc near
        or      word ptr ds:[di].BDS_Flags, fChanged_By_Format or fChanged
        test    byte ptr es:[bx].DP_SpecialFunctions, ONLY_SET_TRACKLAYOUT
        jz      short SetDevParm_1
        jmp     short SetTrackTable             ; Originally TrackLayout
SetDevParm_1:
        mov     al, byte ptr es:[bx].DP_DeviceType
        mov     byte ptr ds:[di].BDS_FormFactor, al
        mov     ax, word ptr es:[bx].DP_Cylinders
        mov     word ptr ds:[di].BDS_cCyln, ax
        mov     ax, word ptr es:[bx].DP_DeviceAttributes
;----------------------------------------------- DOS5A 92/10/07 ------
;<patch BIOS50-P24>
        db      3 dup (90h)
;---------------
;       and     ax,not fChangeline
;---------------------------------------------------------------------
Have_Change:
        and     ax,fNon_Removable or fChangeline
        mov     cx, word ptr ds:[di].BDS_Flags
        and     cx, not (fNon_Removable or fChangeline or GOOD_TRACKLAYOUT)
        or      ax, cx
        mov     word ptr ds:[di].BDS_Flags, ax

        mov     al, byte ptr es:[bx].DP_MediaType
        mov     mediaType, al
        or      word ptr ds:[di].BDS_Flags, SET_DASD_true

        PUSH    DS
        PUSH    DI
        PUSH    ES
        PUSH    BX

        test    byte ptr es:[bx].DP_SpecialFunctions, INSTALL_FAKE_BPB
        jnz     short InstallFakeBPB

        test    word ptr ds:[di].BDS_Flags, RETURN_FAKE_BPB
        jz      short InstallRecommendedBPB

        and     word ptr ds:[di].BDS_Flags, not RETURN_FAKE_BPB
        jmp     short DoneWithBPBstuff

InstallRecommendedBPB:
        mov     cx, size a_BPB
        lea     di, byte ptr [di].BDS_RBPB.BPB_BYTESPERSECTOR
        jmp     short CopyTheBPB

InstallFakeBPB:
        mov     cx, size A_BPB - 6    ; move 'smaller' BPB
        lea     di, byte ptr [di].BDS_BPB.BPB_BYTESPERSECTOR
CopyTheBPB:
        lea     si, byte ptr [bx].DP_BPB
        push    es
        push    ds
        pop     es
        pop     ds

        rep     movsb

DoneWithBPBstuff:
        POP     BX
        POP     ES
        POP     DI
        POP     DS

SetTrackTable:
        mov     cx, word ptr es:[bx].26H        ;               89/07/24
        mov     sectorsPerTrack, cx
        and     word ptr ds:[di].BDS_Flags, not GOOD_TRACKLAYOUT
        test    byte ptr es:[bx].DP_SpecialFunctions, TRACKLAYOUT_IS_GOOD
        jz      UglyTrackLayout
        or      word ptr ds:[di].BDS_Flags, GOOD_TRACKLAYOUT

UglyTrackLayout:
;----------------------------------------------- DOS5A 92/08/14 ------
;<patch BIOS50-P29>
;       cmp     cx, MAX_SECTORS_CURR_SUP        ; current maximum sec/trk
        cmp     cx, 40                          ; current maximum sec/trk
;;;;;-----------------------------------------------------------------
;;;;;   cmp     cx, MAX_SECTORS_IN_TRACK
;---------------------------------------------------------------------
        ja      TooManySectorsPerTrack
        jcxz    SectorInfoSaved                 ; if no value don't copy table

        push    BX                              ; get ES:BX to point to sector
        add     BX,28H          ;table in Device param. struct  89/07/24

        push    DI
        mov     DI, offset TrackTable + 2       ; DS:DI now points to sector id
                                                ; of the first track table entry
        push    AX                              ; preserve AX value

                                                ; For MAX_SECTORS_IN_TRACK
TrackLoop:                                      ;   DO:
        mov     AX, word ptr ES:[BX]            ;   get sector number
        mov     byte ptr [DI], AL               ;   save in track table

        mov     AX, word ptr ES:[BX]+2          ;   get sector size
        call    SectorSizeToSectorIndex         ;   convert size to index number
        mov     byte ptr [DI]+1, AL             ;   save size in track table

        add     BX, size a_sectorTable          ;   advance pointers to next
        add     DI, size a_sectorTable          ;   entries
        loopnz  TrackLoop                       ; End FOR

        pop     AX                              ; restore the saved values
        pop     DI
        pop     BX

SectorInfoSaved:
        clc
        ret

TooManySectorsPerTrack:
        mov     al, 0cH
        stc
        ret

SetDeviceParameters endp

        PAGE
;
; FormatTrack:
;
; Input: DS:DI points to BDS for drive
;        ES:BX points to format packet
;
; Output:
;       For status call:
;       SpecialFunction byte set to:
;               0 - ROM support + legal combination
;               1 - No ROM support
;               2 - Illegal Combination
;       Carry cleared.
;
;       For format track:
;               Carry set if error
;
FormatTrack proc near
        cmp     byte ptr ds:[di].BDS_FormFactor, DEV_HARDDISK
        JB      FORMATTRACK00
        JMP     SHORT DoVerifyTrack                     ;               89/07/24
FORMATTRACK00:
        PUSH    DS
        PUSH    DI
        PUSH    ES
        PUSH    BX
; Check to ensure correct disk is in drive
        MOV     CX,WORD PTR DS:[DI].BDS_BPB.BPB_SECTORSPERTRACK ;       89/07/24
        MOV     WORD PTR [PATCH1],CX                    ;               89/07/24
        call    CheckSingle                             ;               89/07/24

        mov     ax, word ptr es:[bx].FP_Cylinder
        mov     word ptr [CURTRK],ax
        mov     cx, word ptr es:[bx].FP_Head
        mov     byte ptr [CURHD],cl
        mov     ah,cl
                        ; this next piece of code copies the correct head
                        ; and cylinder numbers to the tracktable
        push    di                              ; preserve DI
;-----------------------------------------------------  89/07/24  ---
        MOV     BL,DS:[DI].BDS_FORMFACTOR
        MOV     BH,03H
        CMP     BL,04H
        JZ      TRACKFORMAT10
        DEC     BH
        CMP     BL,02H
        JBE     TRACKFORMAT10
        DEC     BH
        DEC     BH
TRACKFORMAT10:
;----------------------------------------------------  89/07/24  ---
        mov     di, offset TrackTable
        mov     CX, SectorsPerTrack             ; get number of sectors
        jcxz    EndSetUpTrackTable              ; in nothing to do skip down
SetUpLoop:
;----------------------------------------------------  89/07/24  ---
        MOV     BL,01H
SetUpLoop10:
        mov     [di], AX                        ; set head and track value
        MOV     [DI+02H],BX
        INC     BL
        add     di, 4                           ; move to next entry
        loopnz  SetUpLoop10                             ; loop if not done yet
;----------------------------------------------------  89/07/24  ---
EndSetUpTrackTable:
        pop     di                              ; restore DI (BDS pointer)
        mov     cx, MAXERR                      ; Set up retry count
FormatRetry:
        push    cx
                                ; set up registers for format call to TO_ROM
        mov     AX, word ptr SectorsPerTrack    ; set number of sectors
        mov     COM1, ROMFormat
        push    ds                              ; set ES:BX to point to
        pop     es                              ;    the track table
        mov     BP,OFFSET TRACKTABLE            ;               89/07/24
        mov     [cursec],0
        mov     ax,ds:[di].BDS_BPB.BPB_BYTESPERSECTOR
                                                ; don't need to set CL on format
        call    to_rom
        jnc     FormatOk
        call    ResetDisk
        pop     cx
        loop    FormatRetry

; Format failed
        CALL    ERROR
        POP     BX
        POP     ES
        POP     DI
        POP     DS
        ret

FormatOk:
        pop     cx                      ; clean up stack after bailing out
                                        ; of FormatRetry loop early
        POP     BX
        POP     ES
        POP     DI
        POP     DS

DoVerifyTrack:
        call    VerifyTrack             ; Will reset DPT entries.
        ret
FormatTrack endp

        PAGE

;
; VerifyTrack:
;
; Input: DS:DI points to BDS for drive
;        ES:BX points to verify packet
;
VerifyTrack proc near
        mov     COM1,ROMVERIFY
        mov     AX, word ptr es:[bx].VP_Cylinder
        mov     [curtrk], ax
        mov     AX, word ptr es:[bx].VP_Head
        mov     [curhd], al
;----------------------------------------------- DOS5 91/09/28 -------
        xor     ax,ax
;---------------
;       MOV     AX,1
;---------------------------------------------------------------------
        MOV     CX,DS:[DI].BDS_BPB.BPB_SECTORSPERTRACK
        XOR     BP,BP
        MOV     ES,BP
        call    TRACKIO
        ret
VerifyTrack endp

;
; ReadTrack:
;
; Input: DS:DI points to BDS for drive
;        ES:BX points to read packet
;
ReadTrack:
        mov     COM1,Romread
        jmp     short ReadWriteTrack

;
; WriteTrack:
;
; Input: DS:DI points to BDS for drive
;        ES:BX points to write packet
;
WriteTrack:
        mov     COM1, ROMwrite
        jmp     short ReadWriteTrack
;
; ReadWriteTrack:
;
; Input:
;    DS:DI points to BDS for drive
;    ES:BX points to write packet
;
ReadWriteTrack proc near
        mov     ax, word ptr es:[bx].TRWP_Cylinder
        mov     [curtrk], ax
        mov     ax, word ptr es:[bx].TRWP_Head

        mov     [curhd], al
        mov     ax, word ptr es:[bx].TRWP_FirstSector
        mov     cx, word ptr es:[bx].TRWP_SectorsToReadWrite
        les     bx, es:[bx].TRWP_TransferAddress
        MOV     BP,BX
        call    TrackIO
        ret
ReadWriteTrack endp


;
; TrackIO:
;    Performs Track Read/Write/Verify
;
;   Input:
;      COM1     - 6 = Read
;                 5 = Write
;      ax       - Index into track table of first sector to IO
;      cx       - number of sectors to IO
;      es:BP    - Transfer address
;      ds:di    - pointer to BDS
;      curtrk   - current cylinder
;      curhd    - current head
;
public trackio
TrackIO proc near
        MOV     WORD PTR [PATCH1],CX                    ;               89/07/24
        Call    CheckSingle
;
        mov     si, offset trackTable
        shl     ax, 1
        shl     ax, 1
        add     si, ax
        mov     dx, 1
        test    word ptr ds:[di].BDS_Flags, GOOD_TRACKLAYOUT
        jz      IOnextSector

        xchg    dx, cx

IOnextSector:
        push    cx
        push    dx
        inc     si
        inc     si
        mov     AL, byte ptr [si]       ; get current sector value
        mov     [cursec], AL            ; save cursec value
        mov     AL, byte ptr [si]+1     ; get sector size index

        call    SectorSizeIndexToSectorSize
        push    AX                      ; save number of bytes in sector

DoTheIO:
        call    To_ROM
                                ; advance buffer pointer by adding sector size
        JC      IO_ERR
        pop     AX                      ; get number of bytes transfered
        add     BP, AX                  ; advance buffer pointer
        pop     dx
        pop     cx
        loop    IOnextSector
        clc                             ; entries in DPT.
        ret

IO_ERR:
;-----------------------------------------------------  89/07/28  ---
        POP     AX
        MOV     AH,BYTE PTR [PATCH3]
        AND     AH,0FH
        CMP     AH,05H
        JZ      PAT0050
        MOV     AH,0BH
        JMP     short PAT0060
PAT0050:
        MOV     AH,0AH
PAT0060:
;----------------------------------------------- DOS5 92/08/13 -------
;<patch BIOS50-P25>
        extrn   patch07a:near

        jmp     patch07a
;;;;;-----------------------------------------------------------------
;;;;;   POP     DX
;;;;;   POP     CX
;;;;;------------------------------------------------  89/07/28  ---
;;;;;   RET
;;;;;-----------------------------------------------------------------
TrackIO endp
;
;
public SectorSizeToSectorIndex
SectorSizeToSectorIndex proc near
        and     AH, 07h                         ; very simple error correction
        mov     AL, AH                          ; shift left 8 bits
        cmp     AL, 4                           ; size 1024?
        jnz     SecToIndexRet                   ; no, then we are done
        sub     AL, 1                           ; if 1024, adjust index to 3
SecToIndexRet:
        ret
SectorSizeToSectorIndex endp

SectorSizeIndexToSectorSize proc near
; value in AH on entry is not important
        push    CX                      ; save CX value
        mov     CL, AL                  ; use index number as shift size
        mov     AX, 0080h               ; set AX to 128
        shl     AX, CL                  ; shift by index to get proper value
        pop     CX                      ; restore CX value
        ret
SectorSizeIndexToSectorSize endp

AGAIN:
        call    ResetDisk
        dec     bp                      ; decrement retry count
        RET

ResetDisk:
        CLC
        ret

;
; On Entry  -   DS:DI - points to BDS for the drive
;               ES:BX - points to TRKBUF
;               AL    - number of sectors
;               CL    - Sector number for verify
; On Exit   -   DS,DI,ES,BX remain unchanged.
;               ax and flags are the results of the int 13
;
Public To_ROM
To_ROM:
        PUSH    DS
        PUSH    DI
        PUSH    ES
        PUSH    SI
        MOV     BX,AX
        MOV     AH,COM1
        TEST    CURDA,10H
        JZ      ROM005
        OR      AH,0D0H
ROM005:
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        extrn   patch144_8:near

        call    patch144_8
;---------------
;       mov     AL,CURDA                ; set drive number
;---------------------------------------------------------------------
        OR      AL,CURUA
        mov     DH, [CURHD]             ; set head number
        mov     CX, [CURTRK]            ; set track number
        MOV     DL, [CURSEC]            ; SET SECTOR NUMBER
        PUSH    AX
        TEST    CURDA,10H
        JZ      ROM020
        MOV     AX,WORD PTR DS:[DI].BDS_BPB.BPB_BYTESPERSECTOR
        CMP     AH,04H
        JNZ     ROM010
        DEC     AH
ROM010:
        MOV     CH,AH
        JMP     INTCALL
ROM020:
        xor     dx,dx
        mov     ax,cx
        mul     word ptr ds:[di].BDS_BPB.BPB_HEADS
        xor     cx,cx
        mov     cl,[hdnum]
        add     ax,cx
        adc     dx,0
        mul     ds:[di].BDS_BPB.BPB_SECTORSPERTRACK
        xor     cx,cx
        mov     cl,[cursec]
        add     ax,cx
        adc     dx,0
        mov     cx,ax

        push    cx
        TEST    CURDA, 20H
        JNZ     rom030
        MOV     SI,OFFSET HD_OFFSET
        JMP     short rom040
rom030:
        MOV     SI,OFFSET HDS_OFFSET
rom040:
        XOR     AH,AH
        MOV     AL,CURUA
        MOV     CL,4
        SHL     AX,CL
        ADD     SI,AX
        CALL    CHECK_PART
        XOR     AH,AH
        MOV     AL,PART_NUM
        SHL     AX,1
        SHL     AX,1
        ADD     SI,AX
        pop     cx
        add     cx,WORD PTR [SI]
;-----------------------------------------------------  89/07/28  ---
        adc     dx,0
        PUSH    AX
        PUSH    CX
        PUSH    DX
        PUSH    BX
        CALL    READ_ID
        MOV     AX,WORD PTR [DI].BDS_BPB.BPB_BYTESPERSECTOR
        XOR     DX,DX
        DIV     BX
        MOV     CX,AX
        POP     BX
        MOV     AX,BX
        XOR     DX,DX
        MUL     CX
        MOV     BX,AX
        MOV     AX,CX
        POP     DX
        POP     CX
        PUSH    BX
        MOV     BX,AX
;----------------------------------------------- DOS5 91/09/28 -------
        mov     ax,dx
        mul     bx
        push    ax                      ; save high word of sector#
;---------------------------------------------------------------------
        MOV     AX,CX
        MUL     BX
        MOV     CX,AX
;----------------------------------------------- DOS5 91/09/28 -------
        pop     bx                      ; restore high word of sector#
        add     dx,bx                   ; DX:CX has sector num
;---------------------------------------------------------------------
        POP     BX
        POP     AX
;-----------------------------------------------------  89/07/28  ---
        
INTCALL:
        POP     AX
        TEST    CURDA,10H
        JnZ     ROM050
;----------------------------------------------- DOS5 91/09/28 -------
        and     al,7fh
;---------------
;       and     ah,7fh
;---------------------------------------------------------------------
rom050:
;-----------------------------------------------------  89/07/28  ---
        MOV     WORD PTR[PATCH0],BX
        MOV     BYTE PTR[PATCH3],AH
        PUSH    AX
        PUSH    DX
        MOV     AX,BX
        MUL     WORD PTR [PATCH1]
        MOV     BX,AX
        POP     DX
        POP     AX
        JB      PAT0070
ROM55:
        POP     SI
ROM60:
        POP     ES
        POP     DI
        POP     DS
        ret
;
PAT0070:
        CMP     AH,20H
;----------------------------------------------- DOS5 92/08/13 -------
;<patch BIOS50-P25>
        public  PAT0080, ROM55
        extrn   patch07b:near

        jmp     patch07b
        db      90h
;;;;;-----------
;;;;;   JZ      PAT0080
;;;;;   JMP     ROM55
;---------------------------------------------------------------------
PAT0080:
        MOV     AH,BYTE PTR [PATCH3]
        AND     AH,0FH
        CMP     AH,05H
        JZ      PAT0090
        JMP     short WRITE_DMA
PAT0090:
READ_DMA:
        PUSH    DS
        PUSH    ES
        PUSH    SI
        PUSH    DI
        PUSH    CX
        MOV     CX,WORD PTR [PATCH0]
        PUSH    ES
        POP     DS
        PUSH    AX
        MOV     AX,0060H                        ;bios_data segment
        MOV     ES,AX
        POP     AX
        MOV     SI,BP
        MOV     DI,OFFSET DSK_BUF2
        CLD
        REPZ    MOVSB
        POP     CX
        POP     DI
        POP     SI
        POP     ES
        POP     DS
        MOV     BX,WORD PTR [PATCH0]
        PUSH    ES
        PUSH    BP
        PUSH    DS
        POP     ES
        MOV     BP,OFFSET DSK_BUF2
        MOV     AH,BYTE PTR [PATCH3]
        clc
        POP     BP
        POP     ES
        JNB     PAT0100
PAT0110:
        POP     SI
        JMP     ROM60
PAT0100:
        DEC     WORD PTR [PATCH1]
        JZ      PAT0110
        CALL    DMA_CALL
        JMP     READ_DMA
;
WRITE_DMA:
        MOV     BX,WORD PTR [PATCH0]
        PUSH    ES
        PUSH    BP
        PUSH    DS
        POP     ES
        MOV     BP,OFFSET DSK_BUF2
        MOV     AH,BYTE PTR [PATCH3]
        clc
        POP     BP
        POP     ES
        JNB     PAT0120
        JMP     ROM55
PAT0120:
        PUSH    SI
        PUSH    DI
        PUSH    CX
        MOV     CX,WORD PTR [PATCH0]
        MOV     SI,OFFSET DSK_BUF2
        MOV     DI,BP
        CLD
        REPZ    MOVSB
        POP     CX
        POP     DI
        POP     SI
        DEC     WORD PTR [PATCH1]
        JNZ     PAT0130
        JMP     ROM55
PAT0130:
        CALL    DMA_CALL
        JMP     WRITE_DMA
;
DMA_CALL:
        MOV     BX,[PATCH0]
        SHR     BX,1
        SHR     BX,1
        SHR     BX,1
        SHR     BX,1
        MOV     SI,ES
        ADD     BX,SI
        MOV     ES,BX
        INC     DL
        RET
;-----------------------------------------------------  89/07/28  ---


;
PUBLIC  IOCTL$GETOWN_CODE
IOCTL$GETOWN_CODE       PROC    FAR
IOCTL$GETOWN_CODE       ENDP
        CALL    CNVDRV
        MOV     AL,CURDRV
        call    SetDrive
        mov     al,byte ptr [di].BDS_DriveNum   ; Get physical drive number
        push    ax
        mov     ax,0060h                        ;bios_code segment 
        mov     ds,ax
        pop     ax
        mov     di,word ptr Start_BDS
Own_Loop:
        cmp     byte ptr [di].BDS_DriveNum,al
        jne     GetNextBDS
        test    word ptr [di].BDS_flags,fI_Own_Physical
        jnz     Done_GetOwn
GetNextBDS:
        mov     bx,word ptr [di].BDS_link+2
        mov     di,word ptr [di].BDS_link
        mov     ds,bx
        CMP     DI,-1
        JZ      ERR_GETOWN
        jmp     short Own_Loop
Done_GetOwn:
        JMP     SHORT EXIT_OWN

ERR_GETOWN:
        JMP     ERR_EXIT
;
;
PUBLIC IOCTL$SETOWN_CODE
IOCTL$SETOWN_CODE       PROC    FAR
IOCTL$SETOWN_CODE       ENDP
        call    CNVDRV
        MOV     AL,CURDRV
        call    SetDrive
        mov     byte ptr [fSetOwner],1          ; set flag for CheckSingle to
                                                ; look at.
        call    CheckSingle                     ; Set ownership of drive

        mov     byte ptr [fSetOwner],0          ; reset flag
EXIT_OWN:
        xor     cl,cl
        test    word ptr [di].BDS_flags,fI_Am_Mult
        jz      EXIT_NO_MULT
        mov     cl,byte ptr [di].BDS_DriveLet   ; Get logical drive number
        inc     cl                              ; get it 1-based
EXIT_NO_MULT:
        LDS     BX,ds:[PtrSav]
        mov     byte ptr [BX].UNIT,CL
        jmp     EXIT

;       Input:
;          DS:DI pints to the BDS for the drive being checked.
;
;       If there is a error the carry flag is set on return
;
;  All registers are preserved.
CheckSingle:
        push    AX                      ; save affected registers
        push    BX
        mov     BX,word ptr ds:[di].BDS_flags
        test    bl,fNon_Removable       ; if hard drive, cannot change disk
        jnz     SingleRet               ;     so return
                                        ; is there a drive sharing this
        test    bx,fI_Am_Mult           ;   physical drive?
        jz      SingleRet               ; if not, then return
        test    bx,fI_Own_Physical      ; does it own this physical drive?
        jnz     SingleRet               ; if yes then return

        mov     al,ds:[di].BDS_DriveNum ; get physical drive number
        push    ds                      ; preserve pointer to current BDS
        push    di
;----------------------------------------------- DOS5 91/02/23 -------
        mov     ds,cs:[BDATA_SEG]       ; Point to start of BDS linked list
;       push    cs
;       pop     ds                      ; Point to start of BDS linked list
;---------------------------------------------------------------------
        mov     di,offset Start_BDS
Scan_List:
        mov     bx,word ptr [di].BDS_link+2         ; go to next BDS
        mov     di,word ptr [di].BDS_link
        mov     ds,bx
        cmp     di,-1                   ; end of list?
        jz      single_err_ret          ;  if so there must be an error
                                        ; same physical drive?
        cmp     byte ptr [di].BDS_DriveNum,al
        jnz     Scan_List               ; no, keep looking

Check_Own:                              ; yes, check to see if owner
        mov     bx,word ptr [di].BDS_flags
        test    bl,fI_Own_Physical
        jz      Scan_List               ; not owner, keep looking
        xor     bl,fI_Own_Physical      ; yes owner  reset ownership flag
        mov     word ptr ds:[di].BDS_flags,bx
        pop     di                      ; Restore pointer to current BDS
        pop     ds
        xor     bx,bx
        or      bl,fI_Own_Physical      ; establish current BDS as owner
        or      word ptr [di].BDS_flags,bx

        cmp     byte ptr [fSetOwner], 1
        jz      SingleRet

Ignore_SDSB:
        call    EXCMSG          ; ask user for correct disk

SingleRet:
        pop     BX                      ; restore registers
        pop     ax
        ret                             ; return

Single_Err_Ret:
        stc                             ; set carry flage to indicate error
        pop     di                      ; restore current BDS
        pop     ds
        jmp     short SingleRet

;       Input:
;         AL contains the logical drive number
;       Output:
;         DS:DI points to correct BDS if Carry is clear.
;
;        All register execpt DS and DI are preserved
Public SetDrive
SetDrive:
        push    bx
        push    ax
        mov     ax,0060h                ;bios_code segment
        mov     ds,ax
        pop     ax
                                        ; assume first BDS is in this segment
        mov     di,word ptr Start_BDS
Scan_Loop:
        cmp     byte ptr [di].BDS_DriveLet,al   ; is this correct BDS?
        je      SetDrv                          ; yes, get out
        mov     bx,word ptr [di].BDS_link+2             ; no, go to next BDS
        mov     di,word ptr [di].BDS_link
        mov     ds,bx
        cmp     di,-1                           ; at end of list?
        jnz     Scan_Loop                       ; no, keep looking
        stc                                     ; yes, indicate error set carry
SetDrv:
        pop     bx                              ; restore bx
        ret                                     ; return
;----------------------------------------------- DOS5 91/01/18 -------
; ==========================================================================
;       get media id
; ==========================================================================
;
; FUNCTION: get the volume label,the system id and the serial number from
;           the media that has the extended boot record.
;           for the conventional media,this routine will return "unknown
;           media type" error to dos.
;
; INPUT :   DS:di -> bds table for this drive.
;           ES:BX -> packet
;
; OUTPUT:   the request packet filled with the information,if not carry.
;           if carry set,then al contains the device driver error number
;           that will be returned to dos.
;           register DS,DX,AX,CX,DI,SI destroyed.
;
; SUBROUTINES TO BE CALLED:
;       BootIo:NEAR
;
; LOGIC:
;       to recognize the extended boot record,this logic will actually
;       access the boot sector even if it is a hard disk.
;       note:the valid extended bpb is recognized by looking at the mediabyte
;       field of bpb and the extended boot signature.
;
; {
;       get logical drive number from bds table;
;       RW_SW = read operation;
;       BootIo;          /*get the media boot record into the buffer
;       if (no error) then
;            if (extended boot record) then
;               { set volume label,volume serial number and system id
;                 of the request packet to those of the boot record;
;               };
;            else                 /*not an extended bpb */
;               { set register al to "unknown media.." error code;
;                 set carry bit;
;               };
;       else
;            ret;               /*already error code is set in the register al
;
; ==========================================================================

GetMediaId      PROC    NEAR

        ASSUME  DS:Bios_Data,ES:NOTHING

;       call    ChangeLineChk

        mov     AL,[DI].BDS_DriveLet    ; Logical drive number
        mov     RW_SW,0                 ; Read operation
        call    BootIo                  ; Read boot sector into DSK_BUF2
        jc      IOCtl_If1

        cmp     DSK_BUF2.EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR,0f0h
        jb      IOCtl_If2               ; brif not valid (0f0h - 0ffh)

        cmp     DSK_BUF2.EXT_BOOT_SIG,ext_boot_signature ; =29h
        jnz     IOCtl_If2               ; Extended boot record

        les     DI,[PtrSav]             ; ES:di points to request header.
        les     DI,ES:[DI].GenericIOCtl_Packet
        mov     SI,OFFSET DSK_BUF2.EXT_BOOT_SERIAL
        add     DI,mi_serial
        mov     CX,SIZE EXT_BOOT_SERIAL+SIZE EXT_BOOT_VOL_LABEL+SIZE EXT_SYSTEM_ID
        rep     movsb                   ; Move frm Bios_Data into request packet
        clc
        ret

IOCtl_If2:
        mov     AL,7                    ;Error_UnKnown_Media
        stc
IOCtl_If1:
        ret
GetMediaId      ENDP

; ==========================================================================
;  set media id
; ==========================================================================

; function: set the volume label, the system id and the serial number of
;           the media that has the extended boot record.
;           for the conventional media, this routine will return "unknown
;           media.." error to dos.
;           this routine will also set the corresponding informations in
;           the bds table.
;
; input :   DS:di -> bds table for this drive.
;           ES:BX -> packet
;
; output:   the extended boot record in the media will be set according to
;           the request packet.
;           if carry set, then al contains the device driver error number
;           that will be returned to dos.
;
; subroutines to be called:
;       BootIo:NEAR
;
; logic:
;
;
; {
;       get drive_number from bds;
;       RW_SW = "read operation";
;       BootIo;
;       if (no error) then
;            if (extended boot record) then
;               { set volume label,volume serial number and system id
;                 of the boot record to those of the request packet;
;                 RW_SW = "write operation";
;                 get drive number from bds;
;                 BootIo;         /*write it back*/
;               };
;            else                 /*not an extended bpb */
;               { set register al to "unknown media.." error code;
;                 set carry bit;
;                 ret;   /*return back to caller */
;               };
;       else
;            ret;                /*already error code is set */
;
; ==========================================================================

SetMediaId      PROC    NEAR

        ASSUME  DS:Bios_Data,ES:NOTHING

;       call    ChangeLineChk
        mov     AL,[DI].BDS_DriveLet    ; Logical drive number
        mov     DL,AL                   ; Save it for the time being.
        mov     RW_SW,0                 ; Read operation
        push    DX                      ; Save drive number
        call    BootIo                  ; Read boot sec to Bios_Data:DSK_BUF2
        pop     DX                      ; Restore drive number
        jc      IOCtl_If6

                                        ; Valid? (0f0h-0ffh?)
        cmp     DSK_BUF2.EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR,0f0h
        jb      IOCtl_If7               ; Brif not

        cmp     DSK_BUF2.EXT_BOOT_SIG,ext_boot_signature ; =41 (=29h)
        jnz     IOCtl_If7               ; Extended boot record

        push    DI                      ; Save BDS pointer
        push    ES
        push    DS                      ; Point ES To boot record
        pop     ES

        mov     DI,OFFSET DSK_BUF2.EXT_BOOT_SERIAL
        lds     SI,[PtrSav]             ; DS:si points to request header.
        ASSUME  DS:NOTHING
        lds     SI,DS:[SI].GenericIOCtl_Packet
        add     SI,mi_serial
        mov     CX,SIZE EXT_BOOT_SERIAL+SIZE EXT_BOOT_VOL_LABEL+SIZE EXT_SYSTEM_ID
        rep     movsb

        push    ES                      ; point ds back to Bios_Data
        pop     DS

                ;       if      dhigh ; cas - only disable for binary compare

        ASSUME  DS:Bios_Data

                ;       endif

        pop     ES
        pop     DI                      ;restore bds pointer
        call    Mov_Media_Ids           ; update the bds media id info.
        mov     AL,DL                   ; set drive number for BootIo
        mov     RW_SW,1                 ; Write operation
        call    BootIo                  ; write it back.
;       mov     [Tim_Drv],-1            ; make sure chk_media check the driver
        ret                             ; return with error code from BootIo

IOCtl_If7:
        mov     AL,7                    ;Error_UnKnown_Media
        stc

IOCtl_If6:
        ret

SetMediaId      ENDP

; ==========================================================================
;       BootIo
; ==========================================================================
;
; function: read/write the boot record into boot sector.
;
; input :
;           al=logical drive number
;           RW_SW = operation (read/write)
;
; output:   for read operation,the boot record of the drive specified in bds
;           be read into the DSK_BUF2 buffer.
;           for write operation,the DSK_BUF2 buffer image will be written
;           to the drive specified in bds.
;           if carry set,then al contains the device driver error number
;           that will be returned to dos.
;           AX,CX,DX register destroyed.
;           if carry set,then al will contain the error code from READ/WRITE.
;
; subroutines to be called:
;       READ/WRITE:NEAR
;
; logic:
;
; {
;       first_sector = 0;        /*logical sector 0 is the boot sector */
;       sectorcount = 1;         /*read 1 sector only */
;       buffer = DSK_BUF2;       /*read it into the DSK_BUF2 buffer */
;       call READ/WRITE (drive_number,first_sector,sectorcount,buffer);
; }
; ==========================================================================

BootIo  PROC    NEAR

        ASSUME  DS:Bios_Data

        push    ES
        push    DI
        push    BX
        push    DS
        pop     ES                      ; Point ES: to Bios_Data

                ; Call DiskIO to read/write the boot sec. The parameters which
                ; need to be initialized for this subroutine out here are
                ; - Transfer address to Bios_Data:DSK_BUF2
                ; - Low sector needs to be initalized to 0. this is a reg. param
                ; - Hi sector in [Start_Sec_H] needs to be initialised to 0.
                ; - Number of sectors <-- 1

        mov     DI,OFFSET DSK_BUF2      ; ES:di -> transfer address
        xor     DX,DX                   ; First sector (h) -> 0
        mov     [Start_Sec_H],DX        ; Start sector (h) -> 0
        mov     CX,1                    ; One sector

        cmp     RW_SW,1
        je      BootIoWrite
        call    READ
        jmp     SHORT BootIoEnd
BootIoWrite:
        call    WRITE

BootIoend:
        pop     BX
        pop     DI
        pop     ES
        ret
BootIo  ENDP

; ==========================================================================
;       Move Media Ids
; ==========================================================================
;
; function: copy the boot_serial number, volume id, and filesystem id from
;           the ***extended boot record*** in ds:DSK_BUF2 to the bds table
;           pointed by es:di.
;
; input:    ds:di -> bds
;           ds:DSK_BUF2 = valid extended boot record.
;
; output:   vol_serial, bds_volid and bds_system_id in bds are set according
;           to the boot record information.
;           carry flag set if not an extended bpb.
;           all registers saved except the flag.
; ==========================================================================
        PUBLIC  MOV_MEDIA_IDS
mov_media_ids   proc    near
        assume  ds:Bios_Data,es:nothing

        cmp     DSK_BUF2.EXT_BOOT_SIG,ext_boot_signature ; = 41
        jne     mmi_not_ext
        push    cx
        mov     cx,word ptr DSK_BUF2.EXT_BOOT_SERIAL
        mov     word ptr [di].bds_vol_serial,cx
        mov     cx,word ptr DSK_BUF2.EXT_BOOT_SERIAL+2
        mov     word ptr [di].bds_vol_serial+2,cx

        push    di
        push    si

        PUSH    ES
        PUSH    DS
        POP     ES

        mov     cx,size EXT_BOOT_VOL_LABEL
        mov     si,offset DSK_BUF2.EXT_BOOT_VOL_LABEL
        add     di,bds_volid
        rep     movsb
        mov     cx,size EXT_SYSTEM_ID   ;  =8
        mov     si,offset DSK_BUF2.EXT_SYSTEM_ID
        add     di,bds_filesys_id-bds_volid-size EXT_BOOT_VOL_LABEL
        rep     movsb

        POP     ES

        pop     si
        pop     di
        pop     cx
        clc
        ret
mmi_not_ext:
        stc
        ret
mov_media_ids   endp

; ==========================================================================
;       GetAccessFlag
; ==========================================================================
;
; FUNCTION: get the status of UNFORMATTED_MEDIA bit of flags in bds table
;
; INPUT :
;           DS:di -> bds table
;           ES:BX -> packet
;
; OUTPUT:   a_DiskAccess_Control.dac_access_flag = 0 if disk i/o not allowed.
;                                                = 1 if disk i/o allowed.
; ==========================================================================

GetAccessFlag   PROC

        ASSUME  DS:Bios_Data,ES:NOTHING

        mov     AL,0                    ; Assume result is unformatted
        test    [DI].BDS_Flags,UNFORMATTED_MEDIA ; Is it unformtted media?
        jnz     GafDone                 ; Done if unformatted
        inc     al                      ; Return true for formatted

GafDone:
        mov     ES:[BX].dac_access_flag,AL
        clc
        ret

GetAccessFlag   ENDP

; ==========================================================================
;       SetAccessFlag
; ==========================================================================
;
; function: set/reset the UNFORMATTED_MEDIA bit of flags in bds table
;
; input :
;           DS:di -> bds table
;           ES:BX -> packet
;
; output:   unformtted_media bit modified according to the user request
; ==========================================================================

SetAccessFlag   PROC

        and     [DI].BDS_Flags,NOT UNFORMATTED_MEDIA
        cmp     ES:[BX].DAC_Access_Flag,0
        jne     saf_Done
        or      [DI].BDS_Flags,UNFORMATTED_MEDIA

saf_Done:
        clc
        ret

SetAccessFlag   ENDP

; ==========================================================================
; Ioctl_Support_Query
; ==========================================================================
;
; New device command which was added in DOS 5.00 to allow a query of a 
; specific specific GENERIC IOCtl to see if it is supported. Bit 7 in the
; device attributes specifies if this function is supported.
;
; ==========================================================================

        PUBLIC IOCTL_SUPPORT_QUERY_CODE
IOCTL_SUPPORT_QUERY_CODE        PROC    FAR
IOCTL_SUPPORT_QUERY_CODE        ENDP

        ASSUME  DS:Bios_Data,ES:NOTHING

        push    ES
        les     BX,[PtrSav]             ; ES:BX Points to request header.
        mov     AX,WORD PTR ES:[BX].MajorFunction ; AL == Major, AH == Minor

        cmp     AL,IOC_DC               ; See if major code is 8
        jne     NoSupport

        push    CS                      ; ES == Code segment
        pop     ES

        ASSUME  ES:Bios_Code

        mov     CX,IOC_DC_TABLE_LEN
        mov     DI,OFFSET IOC_DC_Table  ; ES:DI -> Major table
        xchg    AL,AH                   ; Put minor code in AL
        repne   scasb                   ; Scan for minor code in AL
        jne     NoSupport               ; Was it found

        mov     AX,100h                 ; Signal ioctl is supported
        jmp     SHORT IoctlSupExit

IoctlSupExit:
        pop     ES
        JMP     EXIT

NoSupport:
        pop     ES
        jmp     CMD_ERR

; ==========================================================================
;       GetMediaSenseStatus
; ==========================================================================
;
; FUNCTION: Will return the type of diskette media in the specified DOS
;           diskette drive and whether the media is the default type
;           for that drive. (default type means the max size for that
;           drive)
;
; INPUT :   DS:DI -> BDS table
;           ES:BX -> packet
;
; OUTPUT:   If carry clear
;           DS:BX -> Updated IOCtlPacket
;
;                        Special Function at offset 0:
;                               0       - Media detected is not default type
;                               1       - Media detected is default type
;
;                        Device Type at offset 1:
;                               0       - 320 / 360K
;                               1       - 2HD(15)
;                               2       - 640 / 720K 
;                               3       - 256K
;                               4       - 1M
;                               8       - 3.5" MO
;
; Error Codes returned in AX if carry set:
;
; 8102 - Drive not ready        - No disk is in the drive.
; 8107 - Unknown media type     - Drive doesn't support this function or
;                                 the media is really unkown, any error
;                                 other than "media not present"
; 
; ==========================================================================

SenseMediaType PROC

        ASSUME  DS:Bios_Data,ES:NOTHING

        mov     WORD PTR ES:[BX],00     ; Initialize the 2 packet bytes

;----------------------------------------------- DOS5 91/01/10 -------
        MOV     AL,3
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,00H
        JE      GOTMEDIATYPE
        MOV     AL,4
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,01H
        JE      GOTMEDIATYPE
        MOV     AL,1
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,02H
        JE      GOTMEDIATYPE
        MOV     AL,0
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0FEH
        JE      GOTMEDIATYPE
        MOV     AL,0
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0FCH
        JE      GOTMEDIATYPE
        MOV     AL,0
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0FFH
        JE      GOTMEDIATYPE
        MOV     AL,0
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0FDH
        JE      GOTMEDIATYPE
        MOV     AL,2
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0FBH
        JE      GOTMEDIATYPE
        MOV     AL,2
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0F9H
        JE      GOTMEDIATYPE
;----------------------------------------------- DOS5 91/08/00 -------
        MOV     AL,8
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0F0H
;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        extrn   patch144_5:near
        public  GOTMEDIATYPE,UNKNOWNMEDIATYPE

        jmp     patch144_5
        db      90h
;---------------
;       JE      GOTMEDIATYPE
;---------------------------------------------------------------------
;       JMP     SHORT UNKNOWNMEDIATYPE
;-----------------------------------------------------------------------
;---------------
;       mov     DL,ES:[DI].BDS_DriveNum ; Get int 13h drive number from BDS
;       xor     DH,DH                   ; DX == physical drive number
;       mov     AH,20h                  ; Get Media Type function
;       int     13h                     ; If no carry media type in AL
;       jc      MediaSenseErr           ; ELSE error code in AH
;
;       inc     BYTE PTR DS:[BX]        ; Signal media type is default (bit 1)
;
;DetermineMediaType:    
;       dec     AL
;       cmp     AL,2                    ; Chk for 720K ie: (3-1) = 2
;       je      GotMediaType
;
;       add     AL,4
;       cmp     AL,7                    ; Chk for 1.44M  ie: (4-1+4) = 7
;       je      GotMediaType
;
;       cmp     AL,9                    ; Chk for 2.88M  ie: (6-1+4) =  9
;       jne     UnknownMediaType        ; Just didn't recognize media type
;----------------------------------------------------------------------

GotMediaType:
        mov     ES:[BX+1],AL            ; Save the return value
        clc                             ; Signal success
        ret

;               ; We come here if carry was set after the int 13h call.
;               ; Before we process the error we need to see if it was
;               ; a real error or just that the media type is not the
;               ; default for the type of drive but was readily identified.
;
;MediaSenseErr:
;       cmp     AH,32h                  ; See if not default media erro
;       je      DetermineMediaType      ; Not really an error
;
;       mov     AL,2                    ; Now assume drive not ready
;       cmp     AH,31h                  ; See if media was present
;       je      SenseErrExit            ; Return drive not ready

UnknownMediaType:
        mov     AL,7                    ; Just don't know the media type

SenseErrExit:
        mov     AH,81h                  ; Signal error return
        stc
        ret

SenseMediaType ENDP

;---------------------------------------------------------------------
IF BRANCH ;----------------------------------------------------------
        PAGE
;************************************************ 850507
;*                                              *
;*      B4670 SUBROUTINES                       *
;*                                              *
;************************************************

HARDBPB:
;-------

        PUSH    ES                      ;850516
        PUSH    DS                      ;850516
        MOV     AX,CS                   ;850516
        MOV     DS,AX                   ;850516
        MOV     ES,AX                   ;850516
;
;       HERE, MAKE BPB IMAGE FOR CURRENT DRIVE
;
        CALL    SYS_READ        ;LOAD SYSTEM COMMON AREA
        JC      HARDEXT                 ;SKIP IF IO-ERROR
;
;       READING OF COMMON AREA IS GOOD
;
        MOV     AL,[CURUA]
        OR      AL,80H
        CALL    FINDDRV         ;ONLY X2 FORMATTED

        MOV     BL,[CURUA]              ;850505
        AND     BX,0007H                ;850505
        PUSH    BX                      ;850505
        SHL     BX,1                    ;850505
        SHL     BX,1                    ;850505
        PUSH    BX                      ;850505
        ADD     BX,OFFSET VT_OFFSET     ;850505
        MOV     [SVPTR1],BX             ;850505
        POP     BX                      ;850505
        ADD     BX,OFFSET VT_LAST       ;850505
        MOV     [SVPTR2],BX             ;850505
        POP     BX                      ;850505
        MOV     AX,13                   ;850505
        MUL     BL                      ;850505
        ADD     AX,OFFSET VBPB          ;850505
        MOV     [SVPTR],AX              ;850505
;
;       ARRANGE THOSE INFORMATION
;
        CALL    SYS_ARRY
;
        CALL    CHECK_X2SW              ;850505
        JZ      HBPB_X2ADJ              ;850505
        CALL    SYS_ARRY_ADJ
HBPB_X2ADJ:                             ;850505
;-------86/09/10------------------------;
        PUSH    DX
        PUSH    AX
        PUSH    CX
        PUSH    BX
        MOV     BX,OFFSET VT_LAST
        MOV     CX,4
        MOV     AX,[BX]
        MOV     DX,2[BX]
        DIV     CX
        MOV     [BX],AX
        MOV     2[BX],DX
        POP     BX
        POP     CX
        POP     AX
        POP     DX
;-------86/09/10------------------------;
        MOV     AH,84H                  ;850505
        MOV     AL,[CURUA]              ;850505
        INT     1BH                     ;850505 (SENSE COM'D)
        MOV     SI,AX                   ;850505
        AND     SI,0007H                ;850505
        MOV     [SI.VTPC],DH            ;850505
        MOV     [SI.VSPT],DL            ;850505
        SHL     SI,1                    ;850505
        MOV     [SI.VBPS],BX            ;850505
        MOV     [SI.VCPV],CX            ;850505
        CLC
HARDEXT:
        POP     DS                      ;850516
        POP     ES                      ;850516
        MOV     AL,-1
        RET

;
;       HERE, READ SYSTEM COMMON AREA HARD DISK
;
;       CF:0-NORMAL READ/CF:1-FAIL TO READ
;
SYS_READ:
        MOV     CX,10
SYS_READ001:
        MOV     AX,8400H                ;SET SENSE COMMAND AND DA/UA
        OR      AL,[CURUA]              ;MAKE UA
        INT     1BH                     ;EXECUTE SENSE COMMAND
        JNC     SYS_READ01              ;SKIP IF SENSE GOOD
        LOOP    SYS_READ001
        JMP     SYS_READ20              ;SKIP IF SENSE ERROR

SYS_READ01:
        INC     AH
        AND     AH,07H
        MOV     CL,AH
        SHL     AH,1
        SHL     AH,1                    ;(AH+1)*4
        ADD     AH,CL                   ;(AH+1)*5
        MOV     HD_CAP,AH               ;SAVE IT FOR X1-FORMATTED
        MOV     HD_SPT,DL               ;SET NUMBER OF SECTOR PER TRACK
        MOV     HD_HED,DH               ;SET NUMBER OF HAED PER CYLINDER
        MOV     HD_LNG,BX               ;SET BYTE PER SECTOR
        MOV     BP,OFFSET HARD_WORK     ;SET BUFFER ADDR
        PUSH    DS
        POP     ES
        XOR     CX,CX
        XOR     DX,DX                   ;ID_SEC=(00,00)
        MOV     RTRY_CNT,3              ;SET RETRY TIMES
        MOV     AL,[CURUA]              ;
SYS_READ02:
        MOV     AH,06H                  ;SET READ COMMAND
        INT     1BH
        JNC     SYS_READ04              ;SKIP IF GOOD
        DEC     RTRY_CNT
        JZ      SYS_READX1              ;CAN'T READ IT
        CALL    RCBL
        JMP     SHORT SYS_READ02        ;GO TO RETRY
;
;       FIRST CHECK IF X2-FORMATTED
;
SYS_READ04:
        MOV     CX,2                    ;SET COMPARE LENGTH
        MOV     SI,OFFSET HARD_WORK-2
        ADD     SI,HD_LNG
        MOV     DI,OFFSET CHR_X2
        CLD
        REPE    CMPSB                   ;ID=55AAH ?
        JNE     SYS_READX1              ;SKIP IF  NOT FOUND X2-ID
        PUSH    DI                      ;850505
        CALL    GET_SW                  ;850505 GET SW ADDRESS
        MOV     BYTE PTR [DI],-1        ;850505
        POP     DI                      ;850505
SYS_READ08:

        MOV     CX,1                    ;MNGSEC=(00,01)
        MOV     RTRY_CNT,3              ;SET RETRY COUNTER
        MOV     AL,[CURUA]              ;
;
;       AX..READ/(DA.UA)
;       BX..BYTE PER SECTOR
;       DX/CX..NUMBER OF SECTOR(AT MANAGEMENT ZONE)
;       ES/BP..BUFFER OF MANAGEMENT
;
SYS_READ10:
        MOV     AH,06H                  ;SET READ COMAND
        INT     1BH
        JNC     SYS_REXIT               ;EXIT IF GOOD
        DEC     RTRY_CNT
        JZ      SYS_READ20              ;HARD #0 DOWN
        CALL    RCBL                    ;RECALIBLATE COMMAND
        JMP     SYS_READ10
SYS_READ20:
        STC                             ;SET ERROR CARRY
SYS_REXIT:
        RET

;
;       AX..READ/(DA.UA)
;       BX..BYTE PER SECTOR
;       DX/CX..NUMBER OF SECTOR(AT X1-MANAGEMENT ZONE)
;       ES/BP..BUFFER OF MANAGENEBT
;
SYS_READX1:
        MOV     CX,2                    ;SET NUMBER OF SECTOR(AT X1-MNG)
        MOV     RTRY_CNT,3              ;SET RETRY COUNTER
        MOV     AL,[CURUA]              ;
SYS_READX1_10:
        MOV     AH,06H                  ;SET READ COMMAND
        INT     1BH
        JNC     SYS_READX1_20
        DEC     RTRY_CNT
        JZ      SYS_READX1_15
        CALL    RCBL
        JMP     SHORT SYS_READX1_10     ;GO TO RETRY

SYS_READX1_15:
        CMP     CX,3
        JAE     SYS_READ20              ;NO HOPE ..TREAT AS NOT-CONNECTTED
        INC     CX
        MOV     RTRY_CNT,3
        JMP     SHORT SYS_READX1_10     ;READ RESERVED SECTOR

;
;       CHECK IF IT IS X1-FORMATTED
;
SYS_READX1_20:
        PUSH    CX
        MOV     CX,4
        MOV     SI,OFFSET HARD_WORK
        MOV     DI,OFFSET CHR_VOL1      ;CHECK X1-ID
        CLD
        REPE    CMPSB           
        POP     CX
        JE      SYS_REXIT               ;TREAT AS X1-FORMATTED

        CMP     CX,3
        JAE     SYS_READ20
        JMP     SHORT SYS_READX1_15

        RET

BOOT_ID EQU     0               ;BOOT IDENTIFICATION
SYS_ID  EQU     1               ;SYSTEM IDENTIFICATION
IPL_ADR EQU     4               ;ADDR OF IPL
LV_STA  EQU     8               ;START ADDR OF LOGICAL VOLUME
LV_ENA  EQU     12              ;END ADDR OF LOGICAL VOLUME

;
;       FIND SELF NUMBER
;
FINDDRV:
        CMP     BT_TYP,AL
        JNE     FINDEXT
        CALL    CHECK_X2SW              ;850505
        JZ      FINDEXT
        MOV     AL,SV_SELECT
        AND     AL,0FH
        OR      AL,80H
        PUSH    BP
        PUSH    BX
        MOV     CX,-1
        XOR     BX,BX
FIND10:
        CMP     BX,HD_LNG
        JAE     FIND40
        CMP     ES:BYTE PTR SYS_ID[BP],0        ;END OF AREA
        JE      FIND40
        CMP     ES:BYTE PTR SYS_ID[BP],81H      ;MSDOS ?
        JNE     FIND20
        INC     CX
        CMP     ES:BYTE PTR BOOT_ID[BP],AL      ;FIND ITSELF ?
        JE      FIND40
FIND20:
        ADD     BP,32
        ADD     BX,32
        JMP     SHORT FIND10
FIND40:
        MOV     SV_RDRV,CL                      ;SAVE IT
        POP     BX
        POP     BP
FINDEXT:
        RET
        RET
;
;       HERE, ARRANGE THOSE INFORMATION
;
SYS_ARRY:
        CALL    CHECK_X2SW              ;850505
        JNZ     SYS_ARRY_02                     ;SKIP IF X2-FORMATTED
        JMP     SYS_ARRY_X1
;
;       ARRANGE MNG-INF  FOR X2-FORMATTED
;
SYS_ARRY_02:
        PUSH    BX
        XOR     BX,BX                           ;CLEAR OFFSET
SYS_ARRY_10:
        CMP     BX,HD_LNG                       ;END OF SECTOR
        JAE     SYS_ARRY_EXIT                   ;SKIP IF SO
        CMP     ES:BYTE PTR SYS_ID[BP],0        ;END OF AREA
        JE      SYS_ARRY_EXIT                   ;EXIT IF NO USING FIELD
        CMP     ES:BYTE PTR SYS_ID[BP],81H      ;MS_DOS FIELD
        JNE     SYS_ARRY_POP                    ;SKIP IF NO MSDOS

        PUSH    BX
        CALL    SYS_NUC
        POP     BX
SYS_ARRY_POP:
        ADD     BX,32
        ADD     BP,32
        JMP     SHORT SYS_ARRY_10

SYS_ARRY_EXIT:
        POP     BX
        RET


;
;       ARRANGE MNG-INF FOR X1-FORMATTED
;
SYS_ARRY_X1:
        MOV     SI,OFFSET HARD_WORK+31
        LODSB                                   ;GET UOA
        MOV     SI,OFFSET HARD_WORK+40
        CMP     AL,-1                           ;SINGLE OS MODE ?
        JNE     SRCH_P                          ;SEARCH PARTITION
        LODSB                                   ;GET PARTITION ID
        CMP     AL,0DDH                         ;MSDOS AREA ?
        JNE     BAD_VOL                         ;SKIP IF BAD-VOLUME
        MOV     DL,HD_CAP                       ;SET VOLUME CAPACITY
        MOV     DH,1                            ;SET FIRST PARTITION NUM
        JMP     SHORT ALL_DOS

BAD_VOL:
        RET

SRCH_P:
        MOV     DD_FLG,0
        MOV     DL,0                            ;CLEAR CAPACITY REG
        MOV     CL,1                            ;SET FIRST PARTITION NUM
NXT_SRCH:
        LODSB                                   ;GET PARTITION ID
        CMP     AL,0DDH                         ;MSDOS AREA
        JNE     G_NXT_P
        OR      DL,DL                           ;FIRST AREA
        JNZ     NOT_FST
        NOT     DD_FLG
        MOV     DH,CL                           ;SAVE FIRST PARTITION NUM
NOT_FST:
        INC     DL
G_NXT_P:
        ADD     SI,7                            ;NEXT PARTITION AREA
        INC     CL                              ;NEXT PARTITION ID
        CMP     CL,HD_CAP
        JBE     NXT_SRCH
        MOV     HD_CAP,DL                       ;UPDATE CAPACITY
        OR      DL,DL                           ;NO MSDOS-AREA ?
        JZ      BAD_VOL                         ;SKIP IF SO
ALL_DOS:
        MOV     SI,SVPTR2                       ;GET LAST POINTER ADDR
        MOV     CX,DX
        PUSH    CX
        XOR     AX,AX
        MOV     AL,DL
        MOV     CX,990
        MUL     CX
        SHL     AX,1
        RCL     DX,1                    ;CONVERT 1024(BPS) TO 512(BPS)
        SHL     AX,1
        RCL     DX,1                    ;512 => 256
;
;       HD_LAST
;
        MOV     [SI],AX                 ;SAVE LOWER
        MOV     [SI+2],DX               ;SAVE HIGER
        POP     CX
        XOR     AX,AX
        MOV     AL,CH
        DEC     AL
        MOV     CX,120*33               ;MB=120*33 SECTOR
        MUL     CX                      
        ADD     AX,33
        ADC     DX,0
        MOV     SI,SVPTR1
;
;       HD_OFFSET
;
        MOV     [SI],AX                 ;SAVE LOWER
        MOV     [SI+2],DX               ;SAVE HIGER
;
;       COPY BPB IMAGE
;
        MOV     BP,OFFSET HARD_WORK     ;SET BUFFER ADDR
        MOV     BX,HD_LNG
        XOR     DX,DX
        MOV     CX,4                    ;SET START WORKING SECTOR
        MOV     RTRY_CNT,3
        MOV     AL,[CURUA]              ;
R_WORK:
        MOV     AH,06H                  ;SET READ COMMAND
        INT     1BH
        JNC     CHK_SUB_L
        DEC     RTRY_CNT
        JZ      NXT_R_WORK
        CALL    RCBL
        JMP     SHORT R_WORK

CHK_SUB_L:
        MOV     SI,BP                   ;SET SOURCE ADDR
        MOV     DI,OFFSET HD_LBL
        PUSH    CX
        MOV     CX,15
        CLD
        REPE    CMPSB
        POP     CX
        JE      SUC_HD
NXT_R_WORK:
        INC     CX
        MOV     RTRY_CNT,3
        CMP     CX,33
        JB      R_WORK
        RET
;
;       FOUND BPB INCLUDING SECTOR
;
SUC_HD:
        MOV     SI,OFFSET HARD_WORK+10H
        MOV     DI,SVPTR
        MOV     CX,13
        PUSH    DI
        REP     MOVSB
        POP     DI
        MOV     AL,HD_CAP               ;GET CURRENT DRIVE CAPACITY
        MOV     WORD PTR [DI+11],1      ;1 SPF
        CMP     AL,6
        JB      SUC_HD_END
        INC     WORD PTR [DI+11]        ;2 SPF
        CMP     AL,12
        JB      SUC_HD_END
        INC     WORD PTR [DI+11]        ;3 SPF
        CMP     AL,17
        JB      SUC_HD_END
        INC     WORD PTR [DI+11]        ;4 SPF
SUC_HD_END:
;---------------------------------- 850507
        ADD     AL,16                   ;
        MOV     [DI+BPB_MDA],AL         ;SET MEDIA-DISCRIPTOR
;---------------------------------- 850507
        MOV     AX,[DI+3]               ;GET RESERVED SECTOR
        MOV     WORD PTR [DI+3],1       ;SET 1 TO FAKE AS IBM
        DEC     AX
        SHL     AX,1
        SHL     AX,1                    ;CONVERT 1024 TO 256
        MOV     SI,SVPTR1
        ADD     [SI],AX
        ADC     WORD PTR [SI+2],0
        RET
        RET
        
SYS_ARRY_ADJ:
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    SI
        PUSH    DI
SYS_ARRY_ADJ10:
        MOV     BP,SVPTR1               ;GET CURRENT OFFSET
        MOV     SI,CS:[BP]              ;GET LOWER DATA
        MOV     DI,CS:2[BP]             ;GET HIGH DATA
        MOV     BP,SVPTR2               ;GET CURRENT LAST
        MOV     AX,CS:[BP]              ;GET LOWER DATA
        MOV     BX,CS:2[BP]             ;GET HIGH DATA
;
;       [BX.AX] =[BX.AX]-[DI.SI]
;       32 BITS SUBTRACT
;
        NOT     DI                      
        NOT     SI
        INC     SI
        ADC     DI,0
        ADD     BX,DI                   ;ADD HIGH
        ADD     AX,SI                   ;ADD LOWER
        ADC     BX,0
        MOV     CS:[BP],AX              ;SAVE LOWER RESULT
        MOV     CS:2[BP],BX             ;SAVE HIGH RESULT
        POP     DI
        POP     SI
        POP     CX
        POP     BX
        POP     AX
        RET
        RET
;
;       HERE, NUCRIOUS THIS PROCESS
;
SYS_NUC:
        MOV     CX,IPL_ADR+2[BP]                ;SET IPL CYLNDER
        MOV     DH,IPL_ADR+1[BP]                ;SET IPL HAED
        MOV     DL,IPL_ADR[BP]                  ;SET IPL SECTOR
        PUSH    BP                              ;SAVE BUFFER ADDR
        MOV     BP,OFFSET IPL_BUF               ;SET WORK BUUFER ADDR OF IPL
        MOV     BX,HD_LNG                       ;256/512
        MOV     RTRY_CNT,10                     ;SET RETRY TIMES
        MOV     ERROR_FLG,00
SYS_NUC10:
        MOV     AX,0680H                        ;SET COMMAND AND DA/UA
        OR      AL,[CURUA]                      ;
        INT     1BH
        JNC     SYS_NUC30                       ;SKIP IF GOOD
        DEC     RTRY_CNT
        JZ      SYS_NUC20
        CALL    RCBL                            ;EXECUTE RECALIBLATE
        JMP     SYS_NUC10
;
SYS_NUC20:
;
;       CAN'T READ IPL CODE AND BPB IMAGE..
;
        POP     BP
        RET


SYS_NUC30:
        MOV     SI,BP                           ;SET BUFFER ADDR
        ADD     SI,11                           ;POINT BPB IMAGE
        MOV     DI,SVPTR                        ;GET SETTING ADDR OF BPB
        PUSH    DS
        POP     ES                              ;ES <- DS
        MOV     CX,13                           ;SET BPB LENGTH
        REP     MOVSB

SYS_NUC50:
        POP     BP                              ;RESTORE MANAGEMENT BUFFER
;
;       IPL-ADR[BP]+HD_SPT*{(IPL_ADR+1[BP]) + (IPL_ADR[BP]*HD_HED)}
;
;       MEANS RELATIVE SECTOR OF IPL ADDR
;
        MOV     CL,HD_HED               ;SET NUMBER OF HEAD PER CYLINDER
        XOR     CH,CH                   ;CLEAR CH
        MOV     AX,IPL_ADR+2[BP]        ;GET IPL CYLINDER NUMBER
        MUL     CX                      ;[DX.AX]=AX*CX

        MOV     CL,IPL_ADR+1[BP]        ;GET IPL HEAD NUMBER
        XOR     CH,CH                   ;CLEAR CH

        ADD     AX,CX
        MOV     CL,HD_SPT               ;SET NUMBER OF SECTOR PER TRACK
        XOR     CH,CH
        MUL     CX

        MOV     CL,IPL_ADR[BP]          ;GET IPL SECTOR NUMBER
        XOR     CH,CH
        ADD     AX,CX
        ADC     DX,0

        MOV     SI,SVPTR1               ;GET STORE FIELD ADDR
        CMP     HD_LNG,256              
        JE      SKIP_256                ;SKIP IF BPS=256
;
;       CONVERT 512 TO 256
;
        SHL     AX,1
        RCL     DX,1
SKIP_256:
        MOV     [SI],AX
        MOV     [SI+2],DX               ;SAVE OFFSET
;
;       LV_ENA[BP] + HD_SPT*{(LV_ENA+1[BP]) + (LV_ENA+2[BP]*HD_HED)}
;
;       MEANS RELATIVE SECTOR OF LAST AREA
;
        MOV     CL,HD_HED               
        XOR     CH,CH
        MOV     AX,LV_ENA+2[BP]         ;GET LAST SECTOR NUMBER
        MUL     CX
        MOV     CL,LV_ENA+1[BP]         ;GET LAST HEAD NUMBER
        XOR     CH,CH
        ADD     AX,CX

        MOV     CL,HD_SPT
        XOR     CH,CH
        MUL     CX
        MOV     CL,LV_ENA[BP]
        XOR     CH,CH
        ADD     AX,CX
        ADC     DX,0
;
        CMP     HD_LNG,256
        JE      SKIP1_256
        SHL     AX,1
        RCL     DX,1                    ;CONVERT 512 TO 256
SKIP1_256:
SYS_NUC60:
        MOV     SI,SVPTR2
        MOV     [SI],AX
        MOV     [SI+2],DX
        RET
        RET

SET_VBPB:
;--------
;  CALLED FROM (GET_BPB)                        85/05/17
        PUSH    DS
        PUSH    ES
        MOV     BX,CS
        MOV     DS,BX
        MOV     ES,BX

        MOV     BL,[FSTDRV]             ;FIRST V-DRIVE NO.
        XOR     BH,BH
        MOV     AL,[CURUA]              ;UNIT
        AND     AL,03H
        ADD     BL,AL
        SHL     BX,1
        MOV     AL,BYTE PTR [BX.EXLPTBL+1]      ;GET DA/UA
        PUSH    AX
        AND     AL,0F0H
        MOV     CH,3
        CMP     AL,90H                  ;8" TYPE ?
        JE      SET_VBPB10              ;YES,
        MOV     CH,2
        CMP     AL,80H
        JB      SET_VBPB10              ;JUMP IF 5" TYPE
        POP     AX
        JMP     SET_VBPB_DONE           ;HD TYPE
SET_VBPB10:
        POP     AX
        XOR     CL,CL                   ;CYL=0
        XOR     DH,DH                   ;HED=0
        MOV     DL,2                    ;SEC=2 (FAT SEC)
        MOV     BP,OFFSET HARD_WORK
        MOV     [RTRY_CNT],3
SETVB_LOOP:
        MOV     AH,0D6H                 ;"READ" COMMAND
        INT     1BH                     ;READ FAT SECTOR
        JNC     SETVB_OK                ;JUMP IF NO-ERROR
        DEC     [RTRY_CNT]
        JNZ     SETVB_LOOP              ;RETRY
        MOV     AL,-1
        JMP     SET_VBPB_DON0
SETVB_OK:
        MOV     AH,BYTE PTR [HARD_WORK] ;GET FAT-ID
        CALL    SUBVTB
SET_VBPB_DONE:
        MOV     AL,0
SET_VBPB_DON0:
        POP     ES
        POP     DS
        RET

SUBVTB:
;       ON EXIT (SI)=TARGET BPB ADDRESS

        MOV     BL,[CURUA]              ;
        AND     BX,0003H
        PUSH    BX
        ADD     BX,OFFSET VDSK_TYP
        MOV     AL,[BX]         ;GET CURRENT DISK TYPE
        CMP     AL,5
        POP     BX                      ;850516
        JB      SUBVTB_FD
        MOV     SI,OFFSET VBPB          ;850505
        MOV     AX,BX                   ;850516
        MOV     CL,13                   ;850505
        MUL     CL                      ;850505
        ADD     SI,AX                   ;850505 TARGET BPB ADDR.
        RET                             ;850516

SUBVTB_FD:
        DEC     AL              ;160KB/180KB
        JNE     SUBVTB_FD10
        MOV     SI,OFFSET DSK5_SNG8
        CMP     AH,-2
        JE      SUBVTB_FD05
        MOV     SI,OFFSET DSK5_SNG9
SUBVTB_FD05:
        JMP     SUBVTB_COPY             ;850506

SUBVTB_FD10:
        DEC     AL              ;320KB/360KB
        JNE     SUBVTB_FD20
        MOV     SI,OFFSET DSK5_DBL8
        CMP     AH,-1
        JE      SUBVTB_FD15
        MOV     SI,OFFSET DSK5_DBL9
SUBVTB_FD15:
        JMP     SUBVTB_COPY

SUBVTB_FD20:
        DEC     AL              ;640KB/720KB
        JNE     SUBVTB_FD30
        MOV     SI,OFFSET DSK5_DBL8D
        CMP     AH,-5
        JE      SUBVTB_FD25
        MOV     SI,OFFSET DSK5_DBL9D
SUBVTB_FD25:
        JMP     SUBVTB_COPY             ;850506

SUBVTB_FD30:
        MOV     SI,OFFSET DSK8_DBL
SUBVTB_COPY:                            ;850506
        PUSH    ES                      ;850506
        PUSH    CS                      ;850506
        POP     ES                      ;850506
        MOV     DI,OFFSET VBPB          ;850506
        MOV     AX,BX                   ;850516**
        MOV     CL,13                   ;850506
        MUL     CL                      ;850506
        ADD     DI,AX                   ;850506
        PUSH    DI                      ;850506
        CLD                             ;850506
        MOV     CX,13                   ;850506
        REP     MOVSB                   ;850506 COPY BPB IMAGE
        POP     SI                      ;850506 SI := BPB ADDR
        POP     ES                      ;850506
        RET


        PAGE

;****************************************
;*                                      *
;*      WORK BUFFER                     *
;*                                      *
;****************************************

HARD_WORK  DB   512 DUP (?)

IPL_BUF    DB   512 DUP (?)

ENDIF   ;------------------------------------------------------------------

DSKIO_CODE_END:
DSKIO_END:

BIOS_CODE       ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\biosseg.inc ===
; BIOSSEG.INC
;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.


datagrp	group	Bios_Data,Bios_Data_Init


Bios_Data	segment	word public 'Bios_Data'
Bios_Data	ends

Bios_Data_Init	segment word public 'Bios_Data_Init'
Bios_Data_Init	ends

Filler		segment para public 'Filler'
Filler		ends

Bios_Code	segment word public 'Bios_Code'
Bios_Code	ends

Filler2		segment para public 'Filler2'
Filler2         ends

sysinitgrp group sysinitseg, SpcKbdSeg, SpcMseSeg, SpcEmmSeg

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

SpcKbdSeg       segment para public 'SoftpcKeyboard'
SpcKbdSeg       ends

SpcMseSeg       segment para public 'SoftpcMouse'
SpcMseSeg       ends

SpcEmmSeg       segment para public 'SoftpcEmm'
SpcEmmSeg       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\exfnc.asm ===
PAGE    109,132
                TITLE  EXFNC

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME:    EXFNC                                   *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1988                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;********************************************************
;*      5" HARD DISK BIOS 				*
;*              SENSE                                   *
;*              SET OPRATION MODE                       *
;*                                                      *
;********************************************************
;****************************************
;*                                      *
;*      HD BIOS ROM                     *
;*      PC-9800-27K                     *
;*                                      *
;****************************************

;****************************************
;*                                      *
;*      BIOS ITEM DESIGN                *
;*                                      *
;*                                      *
;****************************************

INTVEC          SEGMENT AT 0000H
                ORG     480H
BIOS_FLAG1      DB      ?
HDSK_MODE       DB      ?
                ORG     500H
BIOS_FLAG       DW      ?
                ORG     55FH
DISK_INTF       DB      ?
                ORG     585H
DISK_STUS       DB      ?
DISK_SSB0       DB      ?
DISK_SSB1       DB      ?
DISK_SSB2       DB      ?
DISK_SSB3       DB      ?
                ORG     5E8H
DISK_PRM0       DW      2 DUP(?)
DISK_PRM1       DW      2 DUP(?)

INTVEC          ENDS

                PAGE

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

                PUBLIC  SAVE_INT1B
                PUBLIC  EXFNC_CODE_START,EXFNC_CODE_END
                PUBLIC  EXFNC_END
                PUBLIC  EXFNC_START_CODE
;               PUBLIC  DISK_PRM0,DISK_PRM1
                PUBLIC  H5_DPM
                PUBLIC  H5_STUS
;               PUBLIC  INTVEC


;****************************************
;*                                      *
;*      EQU TABLE                       *
;*                                      *
;*                                      *
;****************************************

DMA_SMR         EQU     15H
;
DSK_IDR         EQU     80H             ; INPUT DATA REGISTER
DSK_ODR         EQU     80H             ; OUTPUT DATA REGISTER
DSK_CSR         EQU     82H             ; CHANNEL STATUS REGISTER
DSK_CCR         EQU     82H             ; CHANNEL CONTROL REGISTER
;
S_INT           EQU     01H             ; INTERRUPT
S_PER           EQU     02H             ; PARITY ERROR
S_IXO           EQU     04H             ; INPUT/OUTPUT
S_CXD           EQU     08H             ; COMMAND/DATA
S_MSG           EQU     10H             ; MESSAGE
S_BSY           EQU     20H             ; BUSY
S_ACK           EQU     40H             ; ACKNOWLEDGE
S_REQ           EQU     80H             ; REQUEST
;
C_SWC           EQU     00H             ; SWITCH
C_INT           EQU     01H             ; INTERRUPT ENABLE
C_DMA           EQU     02H             ; DIRECT MEMORY ACCESS ENABLE
C_RST           EQU     08H             ; RESET
C_SEL           EQU     20H             ; SELECT
C_CTL           EQU     40H             ; CONTROL
C_CHN           EQU     80H             ; CHANNEL ENABLE

BIO_BLK         EQU     BYTE PTR 3[BP]
BIO_CYW         EQU     WORD PTR 4[BP]

BIO_UNT         EQU     BYTE PTR 0[BP]  ; UNIT
BIO_CMD         EQU     BYTE PTR 1[BP]  ; COMMAND
BIO_DTL         EQU     WORD PTR 2[BP]  ; DATA LENGTH
BIO_CYL         EQU     BYTE PTR 4[BP]  ; CYLINDER #
BIO_NUM         EQU     BYTE PTR 5[BP]  ; SECTER LENGTH
BIO_SEC         EQU     BYTE PTR 6[BP]  ; SECTER #
BIO_HED         EQU     BYTE PTR 7[BP]  ; HEAD #
BIO_DTA         EQU     WORD PTR 8[BP]  ; DATA OFFSET
BIO_DTS         EQU     WORD PTR 10[BP] ; DATA SEGMENT
BIO_FLG         EQU     BYTE PTR 22[BP] ; FLAG

;               ORG     100H

;****************************************
;*                                      *
;*      CODE START                      *
;*                                      *
;*                                      *
;****************************************
EXFNC_CODE_START:
EXFNC_START_CODE:

                CMP     AL,80H          ; HD #0 ?
                JZ      INT1B000
                CMP     AL,00H          ; HD #0 ?
                JZ      INT1B000
                CMP     AL,81H          ; HD #1 ?
                JZ      INT1B000
                CMP     AL,01H          ; HD #1 ?
                JZ      INT1B000
                JMP     short OLD_INT1B
INT1B000:
                CMP     AH,84H          ; SENSE ?
                JZ      INT1B001
                CMP     AH,0EH          ; SET OPERATION PC-9801
                JZ      INT1B001
                CMP     AH,8EH          ; SET OPERATION PC-98XA
                JZ      INT1B001
OLD_INT1B:
                JMP     CS:DWORD PTR [SAVE_INT1B]       ;OLD INT1B VECTER

INT1B001:
                STI
                CLD
                PUSH    DS
                PUSH    SI
                PUSH    DI
                PUSH    ES
                PUSH    BP
                PUSH    DX
                PUSH    CX
                PUSH    BX
                PUSH    AX

                ASSUME  DS:INTVEC

                MOV     BP,SP
                XOR     BX,BX
                MOV     DS,BX
                MOV     BL,BIO_CMD
                SAL     BL,1
                AND     BX,001EH
                CMP     AH,84H          ; SENSE ?
                JZ      INT1B002
                JMP     short INT1B003

INT1B002:
                CALL    H5_SENS
                JMP     short INT1B004
INT1B003:
                CALL    H5_MODE
INT1B004:
                MOV     BIO_CMD,AH
                AND     BIO_FLG,0FEH
                CMP     AH,20H
                JB      H5_EXTC
                OR      BIO_FLG,01H
H5_EXTC:
                MOV     AL,04H
                OUT     DMA_SMR,AL

                POP     AX
                POP     BX
                POP     CX
                POP     DX
                POP     BP
                POP     ES
                POP     DI
                POP     SI
                POP     DS
                IRET

;****************************************
;*                                      *
;*      NO OPERATION                    *
;*                                      *
;*                                      *
;****************************************

H5_NOP:
                MOV     AH,00H
                RET

;****************************************
;*                                      *
;*                                      *
;*                                      *
;*                                      *
;****************************************

H5_RSET:
                AND     DISK_INTF,0FCH
                CALL    H5_BRST                 ;BUS RESET
                JNZ     H5_NOP
                CALL    DS_WSEC
                XOR     AH,AH
                PUSH    BP
                PUSH    AX
                MOV     BP,SP
                MOV     BIO_UNT,00H
                CALL    H5_ARRS
                MOV     BIO_UNT,01H
                CALL    H5_ARRS
                POP     AX
                POP     BP
                MOV     AH,00H
                RET
H5_ARRS:
                CALL    H5_ADPR
                CALL    H5_RCAL
                CALL    H5_RTRT
                RET

;****************************************
;*                                      *
;*                                      *
;*                                      *
;*                                      *
;****************************************

H5_IOCM:
                OUT     DSK_CSR,AL
                CALL    H5_6BYT
                CALL    H5_RSLT
                RET

;****************************************
;*                                      *
;*                                      *
;*                                      *
;*                                      *
;****************************************

H5_6BYT:
                CALL    H5_COMD
                MOV     AH,DISK_SSB1
                CALL    H5_COMD
                MOV     AH,DISK_SSB2
                CALL    H5_COMD
                MOV     AH,DISK_SSB3
                CALL    H5_COMD
                MOV     AH,DISK_SSB0
                CALL    H5_COMD
                MOV     AH,00H
                TEST    BIO_CMD,20H
                JZ      H5_6BYX
                MOV     AH,0C0H
H5_6BYX:
                CALL    H5_COMD
                RET

;****************************************
;*                                      *
;*      BUS RESET SUBROUTINE            *
;*                                      *
;*                                      *
;****************************************

H5_BRST:
                MOV     AL,C_RST
                OUT     DSK_CCR,AL              ;RESET
                XOR     CX,CX
                LOOP    $
                MOV     AL,0
                OUT     DSK_CCR,AL              ;RESET
                MOV     AL,C_CTL
                JMP     SHORT   $+2
                OUT     DSK_CCR,AL
                JMP     SHORT   $+2
                IN      AL,DSK_CSR
                TEST    AL,S_BSY
                RET

;****************************************
;*                                      *
;*      SENSE                           *
;*                                      *
;*                                      *
;****************************************

H5_SENS:
                CALL    H5_SLCT                 ;SELECTION
                MOV     AX,0000H+C_CHN+C_CTL+C_INT
                OUT     DSK_CCR,AL
                CALL    H5_COMD
                MOV     AH,BIO_UNT
                MOV     CL,5
                SAL     AH,CL
                CALL    H5_COMD
                MOV     AH,0
                MOV     CX,4
H5_SEN0:
                CALL    H5_COMD
                LOOP    H5_SEN0
                CALL    H5_RSLT
                TEST    AH,0F0H
                JNZ     H5_SEN1         ; ERROR
                CALL    H5_PRMH
                OR      AH,CS:20[BX]            ;ES --> CS      88/04/11
                TEST    BIO_CMD,80H
                JZ      H5_SEN1
                AND     AH,0F0H
                OR      AH,CS:28[BX]            ;ES --> CS      88/04/11
                PUSH    AX
                MOV     BIO_DTL,0100H
                MOV     BIO_SEC,33
                CALL    H5_RDSW
                JZ      H5_SEN2
                MOV     BIO_DTL,0200H
                MOV     BIO_SEC,17
H5_SEN2:
                POP     AX
                MOV     DL,CS:3[BX]             ;ES --> CS      88/04/11
                                                ;#              860829
                INC     DL                      ;<              860829
                MOV     BIO_HED,DL
                MOV     DX,CS:4[BX]             ;ES --> CS      88/04/11
                XCHG    DH,DL
                MOV     BIO_CYW,DX
H5_SEN1:
                RET

;****************************************
;*                                      *
;*      RECALIBRATE                     *
;*                                      *
;*                                      *
;****************************************

H5_RCAL:
                CALL    H5_ADPR
                CALL    H5_SLCT
                CALL    H5_PRMH                 ;SETUP PARAMETOR ADDRESS
                MOV     AX,5
                CALL    H5_CYAD                 ;SETUP CYLINDER ADDRESS
                CALL    H5_LUNS                 ;SETUP LOGICAL UNIT NUMBER
                MOV     AX,0B00H+C_CHN+C_CTL+C_INT
                CALL    H5_IOCM                 ;SEEK TO CYLINDER 0
                CALL    H5_SLCT
                XOR     AX,AX
                MOV     WORD PTR DISK_SSB0,AX
                MOV     WORD PTR DISK_SSB2,AX
                CALL    H5_LUNS
                MOV     AX,0100H+C_CHN+C_CTL+C_INT
                CALL    H5_IOCM
                PUSH    AX
                CALL    H5_ADPM
                POP     AX
                RET

;****************************************
;*                                      *
;*      MODE SET                        *
;*                                      *
;*                                      *
;****************************************

H5_MODE:
                CALL    H5_RDSW
                TEST    BIO_CMD,80H
                MOV     BL,AL
                MOV     AL,00H
                JZ      H5_MOD0
                OR      BL,08H
                JMP     short H5_MODX
H5_MOD0:
                TEST    AH,80H
                JZ      H5_MODX
                MOV     AL,01H
H5_MODX:
                XOR     BH,BH
                SAL     BL,1
                MOV     BX,CS:H5_DPM[BX]
                TEST    BIO_UNT,01H
                JNZ     H5_MOD1
                MOV     DISK_PRM0+2,CS
                MOV     DISK_PRM0,BX
                MOV     AH,0FEH
                JMP     short H5_MOD2
H5_MOD1:
                MOV     DISK_PRM1+2,CS
                MOV     DISK_PRM1,BX
                SAL     AL,1
                MOV     AH,0FDH
H5_MOD2:
                AND     HDSK_MODE,AH    
                OR      HDSK_MODE,AL
                MOV     AH,00H
                RET

;****************************************
;*                                      *
;*      RETRACT                         *
;*                                      *
;*                                      *
;****************************************

H5_RTRT:
                CALL    H5_ADPR
                CALL    H5_SLCT
                CALL    H5_PRMH                 ;SETUP PARAMETOR ADDRESS
                MOV     AX,CS:14[BX]            ;ES --> CS      88/04/11
                                                ;GET RETRACT CYLINDER ADDRESS
                XCHG    AL,AH
                CALL    H5_CYAD                 ;SETUP CYLINDER ADDRESS
                CALL    H5_LUNS
                MOV     AX,0B00H+C_CHN+C_CTL+C_INT
                CALL    H5_IOCM

;****************************************
;*                                      *
;*      ASSIGN DISK PARAMETER           *
;*                                      *
;*                                      *
;****************************************

H5_ADPM:
                CALL    H5_PRMH
                MOV     SI,BX
                JMP     short H5_ADP0
H5_ADPR:
                CALL    H5_PRMH
                LEA     SI,10[BX]
H5_ADP0:
                CALL    H5_SLCT                 ;SELECT
                MOV     AH,0C2H
                CALL    H5_COMD
                MOV     AH,BIO_UNT
                MOV     CL,5
                SAL     AH,CL
                CALL    H5_COMD
                MOV     AH,0
                MOV     CX,4
H5_ADP1:
                CALL    H5_COMD
                LOOP    H5_ADP1
                MOV     CX,8
H5_ADP2:
                LODSB
                MOV     AH,AL
                CALL    H5_ODAT
                LOOP    H5_ADP2
                CALL    H5_RDSW
                ROL     AH,1
                AND     AH,01H
                MOV     AL,C_CHN+C_CTL
                OUT     DSK_CCR,AL
                CALL    H5_ODAT
                MOV     AH,00H
                CALL    H5_ODAT
                JMP     H5_NINT                 ;RESULT

;****************************************
;*                                      *
;*      REQUEST SENSE                   *
;*                                      *
;*                                      *
;****************************************

H5_RSEN:
                CALL    H5_SLCT
                MOV     AX,0300H+C_CHN+C_CTL
                OUT     DSK_CSR,AL
                CALL    H5_COMD
                MOV     AH,BIO_UNT              ;UNIT #
                MOV     CL,5
                SAL     AH,CL
                CALL    H5_COMD
                MOV     AH,0
                MOV     CX,4
H5_RSE1:
                CALL    H5_COMD
                LOOP    H5_RSE1
                PUSH    WORD PTR DISK_SSB0
                PUSH    WORD PTR DISK_SSB2
                XOR     DI,DI
                MOV     ES,DI
                MOV     DI,OFFSET DISK_SSB0
                MOV     CX,4
H5_RSE2:
                CALL    H5_IDAT                 ;READ 4 BYTES
                LOOP    H5_RSE2
                CALL    H5_PRMH
                POP     CX
                XCHG    CH,CL
                MOV     DX,WORD PTR DISK_SSB2
                XCHG    DH,DL
                CMP     DX,CX
                POP     CX
                ADC     CH,0
                MOV     DISK_SSB1,CH
                CALL    H5_NINT
                MOV     BX,OFFSET H5_STUS
                MOV     AL,DISK_SSB0
                AND     AL,3FH
                MOV     AH,40H
                CMP     AL,24H
                JNB     H5_RSE3
                XLAT    AL
                MOV     AH,AL
H5_RSE3:
                RET

;****************************************
;*                                      *
;*      GET POINTER                     *
;*                                      *
;*                                      *
;****************************************

H5_PRMH:
;--------------------------------------------------------- 88/04/12 --
;               TEST    BIO_UNT,01H
;               JZ      H5_PRM0
;               LES     BX,DWORD PTR DISK_PRM1
;               RET
;H5_PRM0:
;               LES     BX,DWORD PTR DISK_PRM0
;---------------------------------------------------------------------
                PUSH    AX
                XOR     BX,BX
                CALL    H5_RDSW
                JZ      H5_PRM1
                OR      BL,08H
H5_PRM1:
                OR      BL,AL
                SAL     BL,1
                MOV     BX,CS:H5_DPM[BX]
                POP     AX
                RET
;---------------------------------------------------------------------

;****************************************
;*                                      *
;*      READ SWITCH                     *
;*                                      *
;*                                      *
;****************************************

H5_RDSW:
                MOV     AL,C_SWC
                OUT     DSK_CCR,AL
                JMP     SHORT   $+2
                IN      AL,DSK_CSR              ;READ SWITCH
                MOV     AH,AL
                TEST    BIO_UNT,01H             ;UNIT# ?
                JZ      H5_RDS0                 ;JMP IF UNIT#1
                AND     AX,4007H
                SHL     AH,1
                JMP     short H5_RDS1
H5_RDS0:
                AND     AX,8038H
                SHR     AL,1
                SHR     AL,1
                SHR     AL,1
H5_RDS1:
                OR      AL,AH
                TEST    AL,80H
                RET

;****************************************
;*                                      *
;*                                      *
;*                                      *
;*                                      *
;****************************************

H5_CYAD:
                MOV     CX,CS:12[BX]            ;ES --> CS      88/04/11
                XCHG    CL,CH
                INC     CX                      ;PHSICAL HEAD COUNT
                MUL     CX
                MOV     DX,AX
                MOV     CX,33
                CALL    H5_RDSW
                JZ      H5_CYA0
                MOV     CX,17
H5_CYA0:
                MOV     AX,DX
                MUL     CX
                XCHG    DL,DH
                MOV     WORD PTR DISK_SSB0,DX
                XCHG    AL,AH
                MOV     WORD PTR DISK_SSB2,AX
                RET

;****************************************
;*                                      *
;*      SELECTION                       *
;*                                      *
;*                                      *
;****************************************

H5_SLCT:
                PUSH    AX
                MOV     AL,C_CTL
                OUT     DSK_CCR,AL
                MOV     DX,S_BSY*0100H
                CALL    H5_STAT
                JNZ     H5_TOUT
                MOV     AL,01H                  ;CONTROLER#1
                OUT     DSK_ODR,AL
                MOV     AL,C_SEL+C_CTL
                JMP     SHORT   $+2
                OUT     DSK_CCR,AL
                MOV     DX,S_BSY*0100H+S_BSY
                CALL    H5_STAT
                JNZ     H5_TOUT
                MOV     AL,C_CHN+C_CTL
                OUT     DSK_CCR,AL
                POP     AX
                RET

;****************************************
;*                                      *
;*      INPUT DATA                      *
;*                                      *
;*                                      *
;****************************************

H5_IDAT:
                MOV     DX,0FCA4H
                CALL    H5_STAT
                JNE     H5_TOUT
                IN      AL,DSK_IDR
                STOSB   
                JMP     short H5_SACK

;****************************************
;*                                      *
;*      OUTPUT DATA                     *
;*                                      *
;*                                      *
;****************************************

H5_ODAT:
                MOV     DX,0FCA0H
                CALL    H5_STAT
                JNE     H5_TOUT
                MOV     AL,AH
                OUT     DSK_ODR,AL
                JMP     short H5_SACK

;****************************************
;*                                      *
;*      OUTPUT COMMAND                  *
;*                                      *
;*                                      *
;****************************************

H5_COMD:
                MOV     DX,0FC00H+S_REQ+S_BSY+S_CXD
                CALL    H5_STAT
                JNE     H5_TOUT
                MOV     AL,AH
                OUT     DSK_ODR,AL
                JMP     SHORT   $+2
H5_SACK:
                MOV     DX,S_ACK*0100H
                CALL    H5_STAT
                JNZ     H5_TOUT
                RET

;****************************************
;*                                      *
;*      TIME OUT                        *
;*                                      *
;*                                      *
;****************************************

H5_TOUT:
                LEA     SP,-2[BP]
                TEST    BIO_CMD,0FH
                JZ      H5_TOU0
                CALL    H5_RSET
H5_TOU0:
                MOV     AH,90H
                RET

;****************************************
;*                                      *
;*      RESULT                          *
;*                                      *
;*                                      *
;****************************************

H5_RSLT:
                TEST    DISK_INTF,01H
                JZ      H5_RSLT
                XOR     DISK_INTF,01H
H5_NINT:                                ;NON INTERRUPT
                MOV     DX,0FC00H+S_REQ+S_BSY+S_CXD+S_IXO
                CALL    H5_STAT
                JNE     H5_TOUT
                IN      AL,DSK_IDR
                MOV     DISK_STUS,AL
                CALL    H5_SACK
                MOV     DX,0FCBCH
                CALL    H5_STAT
                JNE     H5_TOUT
                IN      AL,DSK_IDR
                CALL    H5_SACK
                MOV     DX,0FC00H
                CALL    H5_STAT
                JNZ     H5_TOUT
                MOV     AL,C_CTL
                OUT     DSK_CCR,AL
                MOV     AH,00H
                TEST    DISK_STUS,03H
                JZ      H5_BSF0
                MOV     AH,40H
                TEST    DISK_STUS,01H
                JNZ     H5_BSF0
                CALL    H5_RSEN
H5_BSF0:
                RET

;****************************************
;*                                      *
;*      STATUS CHECK                    *
;*                                      *
;*                                      *
;****************************************

H5_STAT:
                PUSH    CX
                XOR     CX,CX
H5_STAE:
                IN      AL,DSK_CSR
                AND     AL,DH   
                CMP     AL,DL
                LOOPNE  H5_STAE
                POP     CX
                RET


H5_LUNS:
                MOV     CH,BIO_UNT
                MOV     CL,5
                SAL     CH,CL
                OR      DISK_SSB1,CH
                RET

;****************************************
;*                                      *
;*      DISK PARAMETER                  *
;*                                      *
;*                                      *
;****************************************

H5_DPM          DW      H5_05M,H5_10M,H5_15M,H5_20M
                DW      H5_20H,H5_30H,H5_40H,H5_10H
;
                DW      H5_05M,H5_10M,H5_15M,H5_20M
                DW      H5_20X,H5_30H,H5_40H,H5_10H
;
H5_05M          DB      001H,001H,000H,003H,000H,098H,040H,000H,000H,000H
                DB      001H,001H,000H,003H,001H,054H,040H,000H,000H,000H
                DB      000H
                DB      000H,0AFH,050H
                DB      004H
                DB      000H,002H,094H
                DB      000H,000H
H5_10M          DB      001H,001H,000H,003H,001H,035H,080H,000H,000H,000H
                DB      001H,001H,000H,003H,001H,054H,080H,000H,000H,000H
                DB      001H
                DB      000H,0AFH,050H
                DB      004H
                DB      000H,002H,094H
                DB      001H,000H
H5_15M          DB      001H,001H,000H,005H,001H,035H,080H,000H,000H,000H
                DB      001H,001H,000H,005H,001H,054H,080H,000H,000H,000H
                DB      002H
                DB      001H,006H,0F8H
                DB      006H
                DB      000H,003H,0DEH
                DB      002H,000H
H5_20M          DB      001H,001H,000H,007H,001H,035H,080H,000H,000H,000H
                DB      001H,001H,000H,007H,001H,054H,080H,000H,000H,000H
                DB      003H
                DB      001H,05EH,0A0H
                DB      008H
                DB      000H,005H,028H
                DB      003H,000H
H5_20H          DB      001H,001H,000H,003H,002H,066H,000H,000H,000H,000H
                DB      001H,001H,000H,003H,002H,0A0H,000H,000H,000H,000H
                DB      003H
                DB      001H,05AH,080H
                DB      008H
                DB      000H,002H,094H
                DB      003H,000H
H5_30H          DB      001H,001H,000H,005H,002H,066H,000H,000H,000H,000H
                DB      001H,001H,000H,005H,002H,0A0H,000H,000H,000H,000H
                DB      004H
                DB      002H,007H,0C0H
                DB      006H
                DB      000H,003H,0DEH
                DB      005H,000H
H5_40H          DB      001H,001H,000H,007H,002H,066H,000H,000H,000H,000H
                DB      001H,001H,000H,007H,002H,0A0H,000H,000H,000H,000H
                DB      005H
                DB      002H,0B5H,000H
                DB      008H
                DB      000H,005H,028H
                DB      007H,000H
H5_10H          DB      001H,001H,000H,003H,001H,035H,080H,000H,000H,000H
                DB      001H,001H,000H,003H,001H,04CH,080H,000H,000H,000H
                DB      001H
                DB      000H,0ABH,030H
                DB      004H
                DB      000H,002H,094H
                DB      001H,000H
;
;       XA MODE 20MB HARD DISK PARAMETOR
;
H5_20X          DB      001H,001H,000H,003H,002H,066H,000H,000H,000H,000H
                DB      001H,001H,000H,003H,002H,0A0H,000H,000H,000H,000H
                DB      003H
                DB      001H,05AH,080H
                DB      004H
                DB      000H,002H,094H
                DB      003H,000H

;****************************************
;*                                      *
;*      ERROR TYPE/CODE                 *
;*                                      *
;*                                      *
;****************************************

H5_STUS         DB       040H   ; NO STATUS
                DB       040H   ; NO INDEX SIGNAL
                DB       040H   ; NO SEEK COMPLETE
                DB       040H   ; WRITE FAULT
                DB       060H   ; DRIVE NOT READY
                DB       040H   ; DRIVE NOT SELECTED
                DB       040H   ; NO TRACK 0
                DB       040H   ; MULTIPLE DRIVES SELECTED
                DB       040H
                DB       040H
                DB       040H
                DB       040H
                DB       040H
                DB       040H   ; SEEK IN       PROGRESS
                DB       040H
                DB       040H
                DB       0A0H   ; ID READ ERROR
                DB       0B0H   ; UNCORRECTABLE DATA ERROR DURING READ
                DB       0E0H   ; ID ADDRESS MARK NOT FOUND
                DB       0F0H   ; DATA ADDRESS MARK NOT FOUND
                DB       0C0H   ; RECORD NOT FOUND
                DB       0C8H   ; SEEK ERROR
                DB       040H
                DB       070H   ; WRITE PROTECTED
                DB       008H   ; CORRECTABLE DATA FIELD ERROR
                DB       0D0H   ; BAD BLOCK FOUND
                DB       040H   ; FORMAT ERROR
                DB       040H
                DB       0B8H   ; UNABLE TO READ THE ALTERNATE TRACK
                DB       040H
                DB       088H   ; ATTEMPTED TO DIRECTRY ACCESS AN ALTERNATE TRACK
                DB       050H   ; SEQUENCER TIME-OUT ERROR DURING A DISK OR A HOST TRANSFER
                DB       040H   ; INVALID COMMAND RECEIVED FROM THE HOST
                DB       038H   ; ILLEGAL DISK ADDRESS
                DB       040H
                DB       030H   ; VOLUME OVERFLOW

;****************************************
;*                                      *
;*      WAIT LOOP 1 SECOND SUBROUTINE   *
;*                                      *
;*                                      *
;****************************************

DS_WSEC:
                XOR     CX,CX
                LOOP    $
                LOOP    $
                LOOP    $
                LOOP    $
                LOOP    $
                TEST    BYTE PTR BIOS_FLAG1,01H ;80286 ?
                JNZ     DS_W286
                TEST    BYTE PTR BIOS_FLAG+1,0C0H
                JZ      DS_WSEX                 ;8086-5M
DS_W286:
                LOOP    $
                LOOP    $
                LOOP    $
                TEST    BYTE PTR BIOS_FLAG1,01H ;80286 ?
                JZ      DS_WSEX                 ;NO,
                LOOP    $
                LOOP    $
DS_WSEX:
                RET


SAVE_INT1B      DW      2 DUP(?)

EXFNC_CODE_END:
EXFNC_END:

BIOS_CODE               ENDS

                END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\init.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 INIT.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: INIT.ASM                                   *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;--------------------------------------------------------
;       CORRECTION HISTORY
;--------------------------------------------------------
;       84/11/12  INF5H <- INF5F
;       84/11/12  SET HARD_LAST
;       84/11/16  SURE TO BEHAVE SINGLE DRIVE
;       84/11/18  SORE TO SET HD BPB IMAGE
;       84/11/22  8"1 MEDIA DSC  -> FEH
;       84/11/23  REMV NEEDS DIFFER MEDIA DSC(256KB  1MB)
;       85/02/07  CORRECT FOR X2ROM(85/1/31)
;       85/03/01  KANJI DRIVER & AI RESULST
;       85/03/30  ADDING B4670-CODE
;       85/05/05 - 05/10  FOR B4670 SIGNON MESSAGE
;       85/05/14  LENGTH(IO.SYS) IS 0E000H(56KB)
;       85/05/15,17  VIRTUAL BOOT,STACK SIZE = 128 WORD
;       85/05/19  SIGNON FOR BRANCH
;       85/05/20  INT FF VECTOR <>
;       85/08/06  ENHANCEMENT FOR DOS 3.XX
;       85/08/06 LENGTH(IO.SYS) IS 0A000H(40K)
;       85/10/02  command load drive is current
;       85/10/09  IO.SYS 48KB
;       86/10/31  FOR X21 B4670 INT 1B SAVE BY QNES
;       86/11/12  RETURN START INE VECTOR SAVE
;--------------------------------------------------------
;       87/8 -87/9 HIRESO/NORMAL MS-DOS
;--------------------------------------------------------
;       88/2 -88/3 MS-DOS 3.3
;                       SCSI HD, X4x HD, EXFNC, 
;--------------------------------------------------------
;       90/11 -91/7 MS-DOS 5.0
;------------------------------------------------------- 870820 ----------
BRANCH = 0                              ;0 IF NOT B4670 SYSTEM
;-------------------------------------------------------------------------
        include dossvc.inc
;************************************************
;*                                              *
;*      OTHER SEGMENT                           *
;*              0000 SEG : INTERRUPT VEC        *
;*              FD80 SEG : NORMAL MODE ROM      *
;*                                              *
;************************************************

HCI     EQU     5
SPI     EQU     6
WBT1    EQU     30
HD_BIOS EQU     0B1H
EXB     EQU     220

INT_VEC SEGMENT AT 0000H
        ORG     4*HCI
HCOPY_OFFSET    DW      ?
HSCOPY_SEGMENT  DW      ?
        ORG     4*SPI
STPKY_OFFSET    DW      ?
STPKY_SEGMENT   DW      ?
        ORG     4*08H                   ;TIMER H/W INT VECTOR 
INT08_OFFSET    DW      ?
INT08_SEGMENT   DW      ?
;------------------------------------------------ 88/02/25 ----------
        ORG     4*18H
INT18_OFFSET    DW      ?
INT18_SEGMENT   DW      ?
;--------------------------------------------------------------------
        ORG     4*1AH
PRDRV_OFFSET    DW      ?
PRDRV_SEGMENT   DW      ?
        ORG     4*1BH
INT1B_OFFSET    DW      ?
INT1B_SEGMENT   DW      ?
        ORG     4*1CH                   ;TIMER VECTOR 
INT1C_OFFSET    DW      ?
INT1C_SEGMENT   DW      ?
        ORG     4*WBT1
WBOOT1_OFFSET   DW      ?
WBOOT1_SEGMENT  DW      ?
WBOOT2_OFFSET   DW      ?
WBOOT2_SEGMENT  DW      ?
        ORG     4*32
INT32_OFFSET    DW      ?
INT32_SEGMENT   DW      ?
        ORG     4*29H
INT29_OFFSET    DW      ?
INT29_SEGMENT   DW      ?
        ORG     4*HD_BIOS
HD_BIOS_OFFSET  DW      ?
HD_BIOS_SEGMENT DW      ?
        ORG     4*EXB
EXBIOS_OFFSET   DW      ?
EXBIOS_SEGMENT  DW      ?
        ORG     4*255
INTFF_OFFSET    DW      ?
INTFF_SEGMENT   DW      ?

        ORG     402H
DISK_SELECT     DB      ?               ;SELECT INF(85/02/02)
;--------------------------------------------------------- 89/08/18 --
        ORG     460H
DISK_INF        DB      ?
;------------------------------------------------ 88/02/25 ----------
        ORG     480H
CPU_TYPE        DB      ?
;--------------------------------------------------------------------
;--------------------------------------------------------- 88/03/22 --
        ORG     482H
SCSIHD_EQUIP    DB      ?               ;SCSI HD EQUIPMENT FLAGS
;---------------------------------------------------------------------
        ORG     494H
DISK_EQUIP2     DB      ?               ;BI-MEIDA DRIVE INFO. (NORMAL)
;---------------------------------------------------- 871020 ---------
        ORG     500H
BIO_FLG0        DB      ?               ;BIOS USE FLAGS
;---------------------------------------------------------------------
BIO_FLAG        DB      ?               ;BIOS USE FLAGS
        ORG     55CH
DISK_EQUIP      DW      ?               ;640KB/1MB/HD EQUIPMENT FLAGS
        ORG     560H
DISK_TYPE       DB      ?               ;5"FD TYPE     
        ORG     584H
DISK_BOOT       DB      ?               ;BOOT DISK DA/UA
        ORG     5E6H
OMNI_SERVER     DB      ?               ;85/03/28
OMNI_STATION    DB      ?               ;85/03/28

INT_VEC ENDS


NORM_ROM SEGMENT        AT 0FD80H
        ORG     091EH
WBOOT_ROM       LABEL   FAR
NORM_ROM ENDS

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends


;************************************************
;*                                              *
;*      OUR SGMENT                              *
;*                                              *
;************************************************
Bios_Data       segment word public 'Bios_Data'
                ASSUME  CS:DATAGRP,DS:DATAGRP
;--------------------------------------------------------- 88/03/22 --
        EXTRN   HD2_NUM:BYTE,HD3_NUM:BYTE
        EXTRN   HDS_NUM:BYTE,HDS1_NUM:BYTE
        EXTRN   HDS2_NUM:BYTE,HDS3_NUM:BYTE
        EXTRN   HDS4_NUM:BYTE,HDS5_NUM:BYTE
        EXTRN   HDS6_NUM:BYTE,HDS7_NUM:BYTE

        EXTRN   HD2_OFFSET:WORD,HD3_OFFSET:WORD
        EXTRN   HD2_LAST:WORD,HD3_LAST:WORD
        EXTRN   HDS_OFFSET:WORD,HDS1_OFFSET:WORD
        EXTRN   HDS2_OFFSET:WORD,HDS3_OFFSET:WORD
        EXTRN   HDS4_OFFSET:WORD,HDS5_OFFSET:WORD
        EXTRN   HDS6_OFFSET:WORD,HDS7_OFFSET:WORD
        EXTRN   HDS_LAST:WORD,HDS1_LAST:WORD
        EXTRN   HDS2_LAST:WORD,HDS3_LAST:WORD
        EXTRN   HDS4_LAST:WORD,HDS5_LAST:WORD
        EXTRN   HDS6_LAST:WORD,HDS7_LAST:WORD

        EXTRN   CPV2:WORD,CPV3:WORD,BPS2:WORD,BPS3:WORD
        EXTRN   TPC2:BYTE,TPC3:BYTE,SPT2:BYTE,SPT3:BYTE
        EXTRN   CPVS:WORD,CPVS1:WORD,BPSS:WORD,BPSS1:WORD
        EXTRN   TPCS:BYTE,TPCS1:BYTE,SPTS:BYTE,SPTS1:BYTE
        EXTRN   CPVS2:WORD,CPVS3:WORD,BPSS2:WORD,BPSS3:WORD
        EXTRN   TPCS2:BYTE,TPCS3:BYTE,SPTS2:BYTE,SPTS3:BYTE
        EXTRN   CPVS4:WORD,CPVS5:WORD,BPSS4:WORD,BPSS5:WORD
        EXTRN   TPCS4:BYTE,TPCS5:BYTE,SPTS4:BYTE,SPTS5:BYTE
        EXTRN   CPVS6:WORD,CPVS7:WORD,BPSS6:WORD,BPSS7:WORD
        EXTRN   TPCS6:BYTE,TPCS7:BYTE,SPTS6:BYTE,SPTS7:BYTE

        EXTRN   HDDSK5_3:NEAR,HDDSK5_4:NEAR
        EXTRN   HDDSKS_1:NEAR,HDDSKS_2:NEAR
        EXTRN   HDDSKS_3:NEAR,HDDSKS_4:NEAR
        EXTRN   HDDSKS_5:NEAR,HDDSKS_6:NEAR
        EXTRN   HDDSKS_7:NEAR,HDDSKS_8:NEAR

        EXTRN   SVHD3:WORD,SVHD4:WORD
        EXTRN   SVHDS1:WORD,SVHDS2:WORD
        EXTRN   SVHDS3:WORD,SVHDS4:WORD
        EXTRN   SVHDS5:WORD,SVHDS6:WORD
        EXTRN   SVHDS7:WORD,SVHDS8:WORD

        EXTRN   INFSH:BYTE
        EXTRN   DA:BYTE
        EXTRN   HD_CNT:BYTE
        EXTRN   SCSI_CNT:BYTE

        EXTRN   NSHD:BYTE

        EXTRN   CURATTR:BYTE,DEFATTR:BYTE
        EXTRN   CURATTR2:WORD,DEFATTR2:WORD     ;               89/08/22
        EXTRN   ESCATRSAVE:BYTE,RTRY_CNT:BYTE
        EXTRN   ATRSAVE2:WORD           ;                       89/08/22
        EXTRN   MEM_SW1:BYTE,MEM_SW2:BYTE,MEM_SW3:BYTE
        EXTRN   MEM_SW4:BYTE,HD_CAP:BYTE
        EXTRN   MEM_SW5:BYTE
        EXTRN   CPV:WORD,CPV1:WORD,BPS:WORD,BPS1:WORD
        EXTRN   TPC:BYTE,TPC1:BYTE,SPT:BYTE,SPT1:BYTE

        EXTRN   DSK_BUF:NEAR
        EXTRN   DSK_BUF2:NEAR                   ;90/03/27

        EXTRN   SYS_500:BYTE,SYS_501:BYTE

        EXTRN   DRV_NUM:BYTE,DEV_TBL:NEAR
        EXTRN   N8FD:BYTE,N5FD:BYTE,N5HD:BYTE
        EXTRN   SEG_DOS:WORD

        EXTRN   DSK8_SNG:NEAR,DSK8_DBL:NEAR
        EXTRN   DSK5_SNG8:NEAR,DSK5_DBL8:NEAR,DSK5_SNG9:NEAR,DSK5_DBL9:NEAR
        EXTRN   DSK5_DBL8D:NEAR,DSK5_DBL9D:NEAR
        EXTRN   HDDSK5_1:NEAR,HDDSK5_2:NEAR
        EXTRN   ALC_TYP:BYTE,AUT_LEX:BYTE,BT_TYP:BYTE
        EXTRN   HD_NUM:BYTE,HD1_NUM:BYTE
        EXTRN   UA:BYTE,LPTABLE:BYTE
        EXTRN   SVPTR:WORD,SVPTR1:WORD,SVPTR2:WORD
        EXTRN   HD_SPT:BYTE,HD_LNG:WORD,HD_HED:BYTE
        EXTRN   HD_OFFSET:WORD,HD1_OFFSET:WORD,HD_LAST:WORD,HD1_LAST:WORD
        EXTRN   EXLPTBL:WORD
        EXTRN   ERROR_FLG:BYTE
        EXTRN   INF8F:BYTE,INF5F:BYTE,INF5H:BYTE
        EXTRN   COPY_INT:NEAR,STOP_INT:NEAR,EXTBIOS:NEAR

        EXTRN   INT_29:NEAR
        EXTRN   INT_TRAP:NEAR
        EXTRN   REINIT_END:NEAR
        EXTRN   INT_FF:NEAR

        EXTRN   INIT_TBL:WORD
        EXTRN   CHR_VOL1:BYTE,CHR_X2:BYTE
        EXTRN   HD_LBL:BYTE
        EXTRN   X2_SW_00:BYTE,X2_SW_01:BYTE,DD_FLG:BYTE
        EXTRN   X2_SW_02:BYTE,X2_SW_03:BYTE
        EXTRN   SV_SELECT:BYTE,SV_RDRV:BYTE
        EXTRN   SVHD1:WORD,SVHD2:WORD

;       B4670 FIELD
;
        EXTRN   VSYS_FLAG:BYTE
IF BRANCH       ;-------------------------------------- 871002 -------
        EXTRN   VT_BPB:BYTE
        EXTRN   B4670ENT:NEAR,INTD3_ENTRY:NEAR,B4670_INT1F:NEAR
        EXTRN   ROM_INT1B:DWORD,ROM_INT1A:DWORD,NXT_INT1F:DWORD
        EXTRN   VDISK_BIO:NEAR,PRT_BIO:NEAR
        EXTRN   SENS_DRV:NEAR,VS_MOUNT:NEAR,FSTDRV:BYTE
;
;***********************86/10/31 BY QNES ************************
        EXTRN   X21_DSKBIO:WORD,X21_TIMBIO:WORD,X21_TIMINT:WORD 
        EXTRN   VEC_SAVE:WORD                   ;86/11/12
;****************************************************************
ENDIF   ;-------------------------------------------------------------
        EXTRN   NOT_BSYS_ENT:NEAR               ;85/05/19 (ENTRY INT78

;------------------------------------ 870811- 87XXXX  * H/N DOS -----------
        EXTRN   REVISION:BYTE           ;BIO2
        EXTRN   INT1E_OFST:WORD         ;BIO2
        EXTRN   INT1E_SGMT:WORD         ;BIO2
        EXTRN   VRAMSEG:WORD            ;BIO2
        EXTRN   LINMOD:BYTE             ;BIO2
        EXTRN   SNGDRV_FLG:BYTE         ;BIO2
        EXTRN   COMP_HDDSK5_1:BYTE      ;BIO2
        EXTRN   COMP_HDOFST_N:WORD      ;BIO2
        EXTRN   VSYS_FLAG:BYTE          ;BIO2
        EXTRN   XPORT_FLAG:BYTE         ;BIO2
        EXTRN   INT1B_OFST:WORD         ;BIO2
        EXTRN   INT1B_SGMT:WORD         ;BIO2
        EXTRN   EXT_ROM:WORD            ;BIO2
;--------------------------------------------------------------------------
        EXTRN   TITLE_M:BYTE            ;BIO2 (SIGNON MESSAGE)
;-------------------------------------------------------- 88/02/28 --
;       EXTRN   SAVE_INT1B:WORD
        EXTRN   EXFNC_START:NEAR,EXFNC_END:NEAR
;       EXTRN   DISK_PRM0:WORD,DISK_PRM1:WORD
;       EXTRN   H5_DPM:WORD
        EXTRN   HDINT_END:NEAR
        EXTRN   EXFNC_FLG:BYTE
        EXTRN   STACK_TOP:NEAR
        EXTRN   CRTBIOS_START:NEAR
        EXTRN   CH1MSW1:BYTE
        EXTRN   EXMM_SIZE:BYTE
;---------------------------------------------------------------------
        EXTRN   FBIGFAT:BYTE,FBIGFATS:BYTE
        EXTRN   START_BDS:NEAR

        EXTRN   MO_LPFLG:BYTE
        EXTRN   MOSW:BYTE,SCSI_FLG:BYTE
        EXTRN   YUKO_UNIT:BYTE
        EXTRN   MO_COUNT:BYTE
        EXTRN   SCSI_EQUIP:NEAR
        EXTRN   NSMO:BYTE
        EXTRN   MO_DEVICE_TBL:NEAR
        EXTRN   BIOSF_3:byte            ;                       89/08/21

        EXTRN   B_COMMAND:BYTE,B_SCSIID:BYTE
        EXTRN   B_DOFFSET:WORD,B_DSEGMENT:WORD,B_DLENGTH:WORD
        EXTRN   B_SCSI_STATUS:BYTE
        EXTRN   SCSI55_FLG:BYTE

        EXTRN   MO_LPFLG2:BYTE
;------------------------------------------------------ 88/03/31 -----
        EXTRN   READDOS:NEAR            ;READDOS
;---------------------------------------------------------------------


;       extrn   BDATA_END:near
        extrn   dosdatasg:word

;----------------------------------------------- DOS5 90/12/14 -------
        EXTRN   BPBCOPY:WORD
;----------------------------------------------- DOS5 90/12/25 -------
        EXTRN   BIOS_SEG:WORD
;----------------------------------------------- DOS5 91/01/10 -------
        EXTRN   INFVT:BYTE, BOOT_PART:WORD
        EXTRN   WSINGLE:BYTE, READ_BUF:BYTE
        EXTRN   BOOT_DRIVE:BYTE
        EXTRN   FAT16:BYTE
        EXTRN   BDS20:WORD
        EXTRN   BDS21:WORD
;----------------------------------------------- DOS5 91/02/20 -------
        extrn   B_DATA_END:NEAR
        extrn   SVPTR3:WORD, HD_MEDIA:BYTE, HDS_MEDIA:BYTE
;---------------------------------------------------------------------
Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP
;---------------------------------------------------------------------
        EXTRN   HDSASI_END:NEAR         ;HD_SASI
;       EXTRN   HDSCSI_END:NEAR
        EXTRN   MODISK_END:NEAR         ;MODISK
        EXTRN   MO_BIOS_far:far         ;MODISK
        EXTRN   CMD_CLEAR_FAR:far       ;MODISK
        EXTRN   HD_ENTI:NEAR            ;HDINT
        EXTRN   WARM_START:NEAR         ;REINIT
        EXTRN   CLRRTN_FAR:FAR          ;CONSOLE
        EXTRN   MSGLOOP_FAR:FAR         ;REINIT
        EXTRN   LEAP_OUT:FAR            ;REINIT ;    FOR NOT B4670)

        EXTRN   SAVE_INT1B:WORD         ;EXFNC
        EXTRN   SAVE_INT18:WORD         ;REINIT

Bios_Code       ends

SysInitSeg      segment word public 'system_init'
                ASSUME  CS:SYSINITSEG,DS:SYSINITSEG
        EXTRN   CURRENT_DOS_LOCATION:WORD

;       EXTRN   FINAL_DOS_LOCATION:WORD

        EXTRN   DEVICE_LIST:DWORD
        EXTRN   MEMORY_SIZE:WORD
        EXTRN   DEFAULT_DRIVE:BYTE
        EXTRN   BUFFERS:WORD                    ;88/03/17 BYTE -> WORD
;       EXTRN   FILES:BYTE
        EXTRN   DEFAULT_DRIVE:BYTE

;       EXTRN   SYSSIZE:FAR

        EXTRN   SYSINIT:FAR
SysInitSeg      ends


Bios_Data_Init  segment word public 'Bios_Data_Init'
                ASSUME  CS:DATAGRP,DS:DATAGRP

INIT_DATA_INIT_START:
        PUBLIC  INIT_DATA_INIT_START

        PUBLIC  INIT_A

        PUBLIC  INIT,LEAP_IN

INIT_A:

DEF_DRV         EQU     2E4H            ;DEFAULT DRIVE IN DOS
;                                       ;KANJI = 02E4H FOR 3.XX
                                                      

CMOS_SEG        EQU     0E3FEH          ;FOR RS232C INTERFACE
CR              EQU     0DH             ;CARRIAGE RETURN
LF              EQU     0AH             ;LINE FEED

;--------------------------------------------------------- 88/03/22 --
HDOFF_SIZE      EQU     2*8
HDLST_SIZE      EQU     2*8
HDNUM_SIZE      EQU     1*1
HDMEDIA_SIZE    EQU     23*4
FBIGFAT_SIZE    EQU     1
;----------------------------------------------- DOS5 90/12/14 -------
BPB_SIZE        EQU     17
HDDSK_SIZE      EQU     BPB_SIZE*4
;---------------------------------------------------------------------
;HDDSK_SIZE     EQU     1*52
;---------------------------------------------------------------------
CPV_SIZE        EQU     2*1
BPS_SIZE        EQU     2*1
TPC_SIZE        EQU     1*1
SPT_SIZE        EQU     1*1
FBIGFAT_SIZE    EQU     1*1


_INQUIRY        =       12H     ; Inquiry

        PAGE
;**     BIOS PARAMETER BLOCK DEFINITION
;
;       The BPB contains information about the disk structure.  It dates
;       back to the earliest FAT systems and so FAT information is
;       intermingled with physical driver information.
;
;       A boot sector contains a BPB for its device; for other disks
;       the driver creates a BPB.  DOS keeps copies of some of this
;       information in the DPB.
;
;       The BDS structure contains a BPB within it.
;

A_BPB                   STRUC
BPB_BYTESPERSECTOR      DW      ?
BPB_SECTORSPERCLUSTER   DB      ?
BPB_RESERVEDSECTORS     DW      ?
BPB_NUMBEROFFATS        DB      ?
BPB_ROOTENTRIES         DW      ?
BPB_TOTALSECTORS        DW      ?
BPB_MEDIADESCRIPTOR     DB      ?
BPB_SECTORSPERFAT       DW      ?
BPB_SECTORSPERTRACK     DW      ?
BPB_HEADS               DW      ?
BPB_HIDDENSECTORS       DW      ?
                        DW      ?
BPB_BIGTOTALSECTORS     DW      ?
                        DW      ?
                        DB      6 DUP(?)        ; NOTE:  many times these
;                                               ;        6 bytes are omitted
;                                               ;        when BPB manipulations
;                                               ;        are performed!
A_BPB                   ENDS


EXT_BOOT_SIGNATURE       EQU     41             ;Extended boot signature
;
EXT_BPB_INFO            STRUC
EBPB_BYTESPERSECTOR      DW      ?
EBPB_SECTORSPERCLUSTER   DB      ?
EBPB_RESERVEDSECTORS     DW      ?
EBPB_NUMBEROFFATS        DB      ?
EBPB_ROOTENTRIES         DW      ?
EBPB_TOTALSECTORS        DW      ?
EBPB_MEDIADESCRIPTOR     DB      ?
EBPB_SECTORSPERFAT       DW      ?
EBPB_SECTORSPERTRACK     DW      ?
EBPB_HEADS               DW      ?
EBPB_HIDDENSECTOR        DD      ?
EBPB_BIGTOTALSECTORS     DD      ?
EXT_BPB_INFO            ENDS
;
;AN001; EXT_PHYDRV, EXT_CURHD included in the header for OS2.
EXT_IBMBOOT_HEADER      STRUC
EXT_BOOT_JUMP           DB      3 DUP (?)
EXT_BOOT_OEM            DB      8 DUP (?)
EXT_BOOT_BPB            DB      size EXT_BPB_INFO dup (?)
EXT_PHYDRV              DB      80h
EXT_CURHD               DB      0
EXT_BOOT_SIG            DB      EXT_BOOT_SIGNATURE
EXT_BOOT_SERIAL         DD      ?
EXT_BOOT_VOL_LABEL      DB      11 DUP (?)
EXT_SYSTEM_ID           DB      8  DUP (?)
EXT_IBMBOOT_HEADER      ENDS


bds_struc       struc
bds_link        dd              0ffffh  ; link to next bds
bds_drivenum    db              80      ; int 13 drive number
bds_drivelet    db              3       ; dos drive number

;       We want to embed a BPB declaration here, but we can't initialize
;       it properly if we do, so we duplicate the byte/word/dword architecture
;       of the BPB declaration.

;BDS_BPB        db      size BPBSTRUC dup (?)   ; actual BPB
BDS_BPB         dw      512             ; BPB_BYTESPERSECTOR
                db      1               ; BPB_SECTORSPERCLUSTER
                dw      1               ; BPB_RESERVEDSECTORS
                db      2               ; BPB_NUMBEROFFATS
                dw      16              ; BPB_ROOTENTRIES
                dw      0               ; BPB_TOTALSECTORS
                db      0f8h            ; BPB_MEDIADESCRIPTOR
                dw      1               ; BPB_SECTORSPERFAT
                dw      0               ; BPB_SECTORSPERTRACK
                dw      0               ; BPB_HEADS
                dd      0               ; BPB_HIDDENSECTORS
                dd      0               ; BPB_BIGTOTALSECTORS

bds_fatsiz      db              0       ; flags...
bds_opcnt       dw              0       ; open ref. count
bds_formfactor  db              3       ; form factor index
bds_flags       dw              0020h   ; various flags
bds_ccyln       dw              40      ; max number of cylinders

BDS_RBPB        db size A_BPB dup (0)   ; recommended BPB

bds_track       db              -1      ; last track accessed on drive
bds_tim_lo      dw              1       ; time of last access. keep
bds_tim_hi      dw              0       ; these contiguous.
bds_volid       db "NO NAME    ",0      ; volume id of medium
bds_vol_serial  dd      0         ;current volume serial number from boot record
bds_filesys_id  db      "FAT12   ",0 ; current file system id from boot record
bds_struc       ends


; values for various flags in bds_flags.

fnon_removable      equ     01h         ;for non-removable media
fchangeline         equ     02h         ;if changeline supported on drive
return_fake_bpb     equ     04h         ; when set, don't do a build bpb
                                        ; just return the fake one
good_tracklayout    equ     08h         ; the track layout has no funny sectors
fi_am_mult          equ     10h         ;if more than one logical for this physical
fi_own_physical     equ     20h         ;signify logical owner of this physical
fchanged            equ     40h         ;indicates media changed
set_dasd_true       equ     80h         ; set dasd before next format
fchanged_by_format  equ    100h         ;media changed by format
unformatted_media   equ    200h         ;an001; fixed disk only



        PAGE
;
;       DRIVE ALLOCATE REFER TABLE
;
;       MEDIA TYPE ARE 4. 1 MEDIA HAS 3 BYTE.
;       1 TYPE HAS 3*4 BYTE.  TABLE IS 3*4*12 BYTE.
;
ALC_TBL         DB      70H             ;TYPE 1
                DW      INF5F
                DB      90H
                DW      INF8F
                DB      80H
                DW      INF5H
                DB      68H
                DW      INFVT
;
                DB      70H             ;TYPE 2
                DW      INF5F
                DB      80H
                DW      INF5H
                DB      90H
                DW      INF8F
                DB      68H
                DW      INFVT
;
                DB      90H             ;TYPE 3
                DW      INF8F
                DB      70H
                DW      INF5F
                DB      80H
                DW      INF5H
                DB      68H
                DW      INFVT
;
                DB      90H             ;TYPE 4
                DW      INF8F
                DB      80H
                DW      INF5H
                DB      70H
                DW      INF5F
                DB      68H
                DW      INFVT
;               
                DB      80H              ;TYPE 5
                DW      INF5H
                DB      70H
                DW      INF5F
                DB      90H
                DW      INF8F
                DB      68H
                DW      INFVT
;
                DB      80H             ;TYPE 6
                DW      INF5H
                DB      90H
                DW      INF8F
                DB      70H
                DW      INF5F
                DB      68H
                DW      INFVT
;
                DB      68H             ;TYPE 7
                DW      INFVT
                DB      70H
                DW      INF5F
                DB      90H
                DW      INF8F
                DB      80H
                DW      INF5H
;
                DB      68H             ;TYPE 8
                DW      INFVT
                DB      70H
                DW      INF5F
                DB      80H
                DW      INF5H
                DB      90H
                DW      INF8F
;
                DB      68H             ;TYPE 9
                DW      INFVT
                DB      90H
                DW      INF8F
                DB      70H
                DW      INF5F
                DB      80H
                DW      INF5H
;
                DB      68H             ;TYPE 10
                DW      INFVT
                DB      90H
                DW      INF8F
                DB      80H
                DW      INF5H
                DB      70H
                DW      INF5F
;
                DB      68H             ;TYPE 11
                DW      INFVT
                DB      80H
                DW      INF5H
                DB      70H
                DW      INF5F
                DB      90H
                DW      INF8F
;
                DB      68H             ;TYPE 12
                DW      INFVT
                DB      80H
                DW      INF5H
                DB      90H
                DW      INF8F
                DB      70H
                DW      INF5F
;
;INFVT          DB      00000000B       ;VIRTUAL DRIVE MUST BE 4

;---------------------------------------------------- 871001 -------------
;BOOT_PART      DW      0               ;BOOT PARTITION ENTRY
;-------------------------------------------------------------------------
;WSINGLE                DB      0

MODISK_BPB      DW      2048    ; BYTE / SECTOR 
                DB      16      ; SECTOR / CLUSTER
                DW      2       ; RESERVE SECTOR
                DB      2       ; FAT AREA 
                DW      3072    ; ROOT DIRECTORY ENTRY
                DW      65432   ; SECTOR / MEDIA
                DB      0F8H    ; MEDIA DESCRIPTER
                DW      8       ; SECTOR / FAT AREA
;----------------------------------------------- DOS5 90/12/14 -------
                DD      0       ; DUMMY 
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 91/08/00 -------
MODISK_BPB2     DW      200h    ; BYTE / SECTOR 
                DB      4       ; SECTOR / CLUSTER
                DW      1       ; RESERVE SECTOR
                DB      2       ; FAT AREA 
                DW      200h    ; ROOT DIRECTORY ENTRY
                DW      0       ; SECTOR / MEDIA
                DB      0f0h    ; MEDIA DESCRIPTER
                DW      0f3h    ; SECTOR / FAT AREA
                DD      3cbe0h  ; total sectors
;---------------------------------------------------------------------

;READ_BUF       DB      24H DUP (0)

;----------------------------------------------- DOS5 91/05/17 -------
MSG_INVALIDpt   DB      13,10,07,'Tڈȍ~̃ANeBuȗ͖̈ł'
                DB      'Nł܂',0
;---------------------------------------------------------------------

        PAGE
        EVEN
;****************************************************************
;*                                                              *
;*      INIT ENTRY POINT                                        *
;*                                                              *
;*      INPUT: (SI) BOOT PARTITION ENTRY ADDR (HD ONLY)         *
;*                                                              *
;****************************************************************

DOSSPOT LABEL   WORD

INIT:                   ;PRINT  SIGN ON MESSAGE AND INITIALIZE
        CLI                             ;INTERRUPT DISABLE
;------ added @12/03/1992 for NEC emulation dos debugging
;       int     3
;------ end of midification @12/03/1992 NEC
        MOV     AX,CS                   ;WE ENTERED WITH A JMPF SO USE
        MOV     SS,AX                   ;CS: AS THE INITIAL VALUE OF SS:,
        MOV     DS,AX                   ;   DS:
        MOV     ES,AX                   ;   AND ES:
;      USE LOCAL STACK DURING   INITIALIZATION
;93/03/26 MVDM DOS5.0A-------------------------- DOS5A 92/05/21 --------
;<patch BIOS50-P19>
        MOV     SP,0ffffh
;---------------
;;;;;   MOV     SP,OFFSET STACK_TOP
;-----------------------------------------------------------------------
;------------------------------------------------- 871001 ------------
;93/03/26 MVDM DOS5.0A-------------------------- DOS5A 92/04/17 --------
        db      4 dup (90h)
;---------------
;       SUB     SI,0100H
;-----------------------------------------------------------------------
        MOV     [BOOT_PART],SI          ;PARTITION (NORMAL ONLY)
;---------------------------------------------------------------------
;
;       SETUP ALL INTERRUPT VECTOR IN LOW MEMORY EXCEPT 0 - 1FH
;
        PUSH    DS                      ;SAVE THE DS REGISTER
        PUSH    ES                      ;SAVE ES
        XOR     AX,AX                   ;CLEAR AX
        MOV     DS,AX
        MOV     ES,AX                   ;SET ES AND DS ZERO
;       SETUP INTERRUPT
        ASSUME  DS:INT_VEC
        MOV     INT32_OFFSET,OFFSET INT_TRAP
        MOV     INT32_SEGMENT,CS
        MOV     SI,OFFSET INT32_OFFSET
        MOV     DI,SI
        ADD     DI,4
        MOV     CX,446
        CLD
        REP     MOVSW

        CALL    B4670VEC                ;VECTOR SAVE ROUTINE FOR B4670          870827
;------ deleted following instruction for debugging @12/03/1992 NEC
        JMP     LEAP_OUT                ;ROM BUG FIX ROUTINE (REINIT)
;------ end of modification @12/03/1992

LEAP_IN PROC FAR

LEAP_IN ENDP

;
;       WARM START VECTOR ALREADY HAS BEEN  SETTED UP (AT ITF)
;
        MOV     INT29_OFFSET,OFFSET INT_29   ;(41)
        MOV     INT29_SEGMENT,CS
        MOV     EXBIOS_OFFSET,OFFSET EXTBIOS ;(220)
        MOV     EXBIOS_SEGMENT,CS               ;(220);NEC NT PROT
;********************************************************
;*                                                      *
;*      << NORMAL MODE ONLY >>          870827          *
;*                                                      *
;*      SETUP WARM INT VECTOR                           *
;*      & CHECK 5"2DD EXT ROM ( N10 ONLY )		*
;*      & CHECK 5"HD  EXT ROM ( N10 ONLY )		*
;*                                                      *
;********************************************************

        CALL    CHK_CRTBIOS             ;CHECK HIRESO XA,XL

        ASSUME  DS:DATAGRP
        POP     ES
        POP     DS
;
;********************************************************
;*                                                      *
;*      INITIALIZE SCREEN/KEYBORAD                      *
;*              & SET INIT VALUE TO IO.SYS VARIABLE     *
;*                                                      *
;********************************************************

        CALL    SETVRAM                 ;CHECK H/W MODE & SET VRAM SEGMENT
        CALL    SETCMOS                 ;GET/SET MEMORY SW CONTENTS
        CALL    SAV_FLAG                ;SAVE 0:500/501 VALUE
        CALL    DEFULT                  ;SET DEFULT VALUE
        CALL    SETVAL                  ;SET IO.SYS VARIABLE -------870826--
        CALL    KBINIT                  ;KB  BIO INITIALIZE
        STI                             ;ENABLE INTERRUPT

;********************************************************
;*                                                      *
;*      GENERATE HARD DISK MANAGEMENT INFORMATION       *
;*                                                      *
;********************************************************
HARD_INF:
        PUSH    DS                      ;SAVE DS
        XOR     AX,AX                   ;CLEAR AX
        MOV     DS,AX                   ;SET ZERO TO DS
        MOV     BX,564H                 ;SET S0 ADDR  (85/03/01)
        MOV     CX,4                    ;SET LOOP TIMES
SET_AI:
        OR      DS:BYTE PTR[BX],0C0H    ;SET AI FLAG
        ADD     BX,8                    ;NEXT ADDR (85/03/01)
        LOOP    SET_AI
;
        ASSUME DS:INT_VEC
        MOV     AL,0A0H                 ;NEC NT PROT
        MOV     CS:[BT_TYP],AL          ;SAVE IT
        MOV     AL,0                    ;NEC NT PROT
        MOV     CS:[SV_SELECT],AL       ;SAVE IT
        MOV     AX,[DISK_EQUIP]         ;GET DISK EQUIPMENT INFORMATION
;---------------------------------------------------------- 88/03/21 --
        AND     AH,0FH                  ;ONLY SASI EQUIP
        MOV     CS:[INF5H],AH           ;SAVE IT
        MOV     AH,1                    ;NEC NT PROT
        ASSUME  DS:DATAGRP
        POP     DS
        MOV     [INFSH],AH              ;SAVE IT
;
        CMP     [INF5H],00H             ;SASI UNIT ?
        JE      SASI_EXIT               ;NO SASI
        MOV     DA,00H
        MOV     HD_CNT,0                ;SASI HD TABLE #0
        TEST    INF5H,01H               ;SASI #0?
        JZ      SASI010                 ;NO
        MOV     UA,00H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SASI010:
        MOV     HD_CNT,1                ;SASI HD TABLE #1
        TEST    INF5H,02H               ;SASI #1
        JZ      SASI020                 ;NO
        MOV     UA,01H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SASI020:
        MOV     HD_CNT,2                ;SASI HD TABLE #2
        TEST    INF5H,04H               ;SASI #2?
        JZ      SASI030                 ;NO
        MOV     UA,02H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SASI030:
        MOV     HD_CNT,3                ;SASI HD TABLE #3
        TEST    INF5H,08H               ;SASI #3 ?
        JZ      SASI040                 ;NO
        MOV     UA,03H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SASI040:
SASI_EXIT:
        CMP     INFSH,00H               ;SCSI UNIT ?
        JNZ     SCSI005
        JMP     SCSI_EXIT               ;
SCSI005:
        MOV     DA,20H
        MOV     HD_CNT,0                ;SCSIHD TABLE #0
        TEST    INFSH,01H               ;SCSI #0?
        JZ      SCSI010                 ;NO
        INC     SCSI_CNT
        MOV     UA,00H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SCSI010:
        MOV     HD_CNT,1                ;SCSIHD TABLE #1
        TEST    INFSH,02H               ;SCSI #1?
        JZ      SCSI020                 ;NO
        INC     SCSI_CNT
        MOV     UA,01H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SCSI020:
        MOV     HD_CNT,2                ;SCSIHD TABLE #2
        TEST    INFSH,04H               ;SCSI #2?
        JZ      SCSI030                 ;NO
        INC     SCSI_CNT
        MOV     UA,02H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SCSI030:
        MOV     HD_CNT,3                ;SCSIHD TABLE #3
        TEST    INFSH,08H               ;SCSI #3?
        JZ      SCSI040                 ;NO
        INC     SCSI_CNT
        MOV     UA,03H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SCSI040:
        MOV     HD_CNT,4                ;SCSIHD TABLE #4
        TEST    INFSH,10H               ;SCSI #4?
        JZ      SCSI050                 ;NO
        INC     SCSI_CNT
        CMP     SCSI_CNT,4
        JA      SCSI_EXIT
        MOV     UA,04H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SCSI050:
        MOV     HD_CNT,5                ;SCSIHD TABLE #5
        TEST    INFSH,20H               ;SCSI #5?
        JZ      SCSI060                 ;NO
        INC     SCSI_CNT
        CMP     SCSI_CNT,4
        JA      SCSI_EXIT
        MOV     UA,05H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SCSI060:
        MOV     HD_CNT,6                ;SCSIHD TABLE #6
        TEST    INFSH,40H               ;SCSI #6?
        JZ      SCSI070                 ;NO
        INC     SCSI_CNT
        CMP     SCSI_CNT,4
        JA      SCSI_EXIT
        MOV     UA,06H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SCSI070:
        MOV     HD_CNT,7                ;SCSIHD TABLE #7
        TEST    INFSH,80H               ;SCSI #7?
        JZ      SCSI080                 ;NO
        INC     SCSI_CNT
        CMP     SCSI_CNT,4
        JA      SCSI_EXIT
        MOV     UA,07H
        CALL    HARDINIT                ;HARD DISK INITIARIZE
SCSI080:
SCSI_EXIT:
;----------------------------------------------------------------------
HARD_EXIT:
MO_DISK:
        JMP     MKTBL           ;NEC NT PROT
;------------------------------------------------ DOS5 91/08/00 --------
        mov     al,MO_LPFLG
        push    ax
        call    CNV_MO_LPFLG
;-----------------------------------------------------------------------
        CMP     BYTE PTR MO_LPFLG,00H
        JZ      MODISK_EXIT
        MOV     DA,20H
        MOV     HD_CNT,0
        MOV     SCSI_CNT,0
        MOV     UA,0
MOINIT010:
        CMP     UA,8
        JAE     MODISK_EXIT
        MOV     AL,01H
        MOV     CL,HD_CNT
        SHL     AL,CL
        TEST    BYTE PTR MO_LPFLG,AL
        JZ      MOINIT020
        INC     SCSI_CNT
;       CMP     SCSI_CNT,2
        CMP     SCSI_CNT,4              ;DOS5  5"MO*2 + 3.5"MO*2
        JA      MODISK_EXIT
        CALL    MODISK_INIT
MOINIT020:
        INC     HD_CNT
        INC     UA
        JMP     MOINIT010
MODISK_EXIT:
;------------------------------------------------ DOS5 91/08/00 --------
        pop     ax
        mov     MO_LPFLG,al
;-----------------------------------------------------------------------
;********************************************************
;*                                                      *
;*      MAKE LOGICAL-PHYSICAL CONVERTING TABLE          *
;*                                                      *
;********************************************************
MKTBL:
;********************************************************
;*                                                      *
;*      SET BDS TABLE                                   *
;*                                                      *
;********************************************************
        CALL    SET_BDS

;------------------------------------------------DOS5 91/02/20-----------
;********************************************************
;*                                                      *
;*      REASSIGN PROPER BPB ACCORDING TO BDS            *
;*                                                      *
;********************************************************
        CALL    REASS_INITTBL
;------------------------------------------------------------------------

;********************************************************
;*                                                      *
;*      DISPLAY FUNCTION KEY & PRINT TITLE MESSAGE      *
;*                                                      *
;********************************************************
        CALL    CSRON                   ;DISPLAY CURSOR

;********************************************************
;*                                                      *
;*      GET & SET MAIN MEMORY SIZE                      *
;*                                                      *
;********************************************************
        PUSH    DS                      ;SAVE DS
     ASSUME DS:INT_VEC
        XOR     AX,AX
        MOV     DS,AX                   ;DS <- 0000H
        MOV     AL,[BIO_FLAG]
     ASSUME DS:DATAGRP
        POP     DS                      ;RESTORE DS
        MOV     DX,2000H                ;SET 128K
        AND     AL,07H                  ;GET MEMORY BITS
        JZ      MEM_END
COMP_MEM:
        ADD     DX,2000H                ;PLUS 128K
        DEC     AL
        JNZ     COMP_MEM
MEM_END:
;********************************************************
;*                                                      *
;*      SET DEFAULT DRIVE                               *
;*                                                      *
;********************************************************
;------------------------------------------------DOS5 91/05/14----------
        CMP     [SV_RDRV],4             ; boot from 5th or later partition
        JB      DO_SETDRVNUM
        MOV     BX,OFFSET DATAGRP:MSG_INVALIDpt ;Invalid partition mesage
        CALL    MSGLOOP_FAR
HLTLOOP:
        JMP     HLTLOOP                 ;  error!!!!

DO_SETDRVNUM:
;-----------------------------------------------------------------------
        CALL    SETDRVNUM               ;84/11/18
        MOV     AL,[BT_TYP]

IF BRANCH       ;-----------------------------------------------------
        PUSH    AX                      ;
        AND     AL,0F0H                 ;ONLY DA
        CMP     AL,60H                  ;BOOT FROM B4670 ?
        POP     AX                      ;
        JNE     SKIP_VBT                ;NO,
        MOV     BL,[FSTDRV]             ;1ST VDRIVE NO.
        AND     AL,03H                  ;
        ADD     BL,AL                   ;
        JMP     SET_DEFAULT             ;
SKIP_VBT:                               ;
ENDIF   ;-------------------------------------------------------------

        PUSH    AX
        AND     AL,0F0H
;--------------------------------------------------- 871011 ----------
        CMP     AL,0F0H                 ;1MBFD ON 640KB-INF ?
        POP     AX
        JNE     SKIP_SBT0               ; NO,
;------------------------------------------------ MSDOS 3.3B BUG ------
        AND     AL,07FH                 ; YES, TREAT TO 7x   90/03/16
;----------------------------------------------------------------------
        JMP     SHORT SKIP_SBT
SKIP_SBT0:
        PUSH    AX
        AND     AL,0F0H
        CMP     AL,10H                  ;640KBFD ON 1MB-INF ?
;93/03/26 MVDM DOS5.0A------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        extrn   patch144_d2:near
        public  patch144_d2_ret, SKIP_SBT

        jmp     patch144_d2

patch144_d2_ret:
;---------------
;       POP     AX
;       JNE     SKIP_SBT                ; NO,
;---------------------------------------------------------------------
        OR      AL,80H                  ; YES, ADJUST TO 9x
SKIP_SBT:
        MOV     CX,26
        MOV     BX,OFFSET EXLPTBL+1     ;SET DA/UA TABLE ADDR
;------------------------------------------------------- 871001 ------
;       TEST    SV_SELECT,40H           ;BOOT FROM HARD DISK ?
;       JZ      SEARCHBT                ;SKIP IF NO
;----------------
        PUSH    AX                      ;
        AND     AL,0F0H                 ;DA ONLY

        CMP     AL,80H                  ;BOOT FROM SASI ?
        JZ      SKIP_SASI
        CMP     AL,0A0H                 ;BOOT FROM SCSI ?
        POP     AX
        JZ      X_DRCNT
        JMP     short SEARCHBT

;       POP     AX                      ;
;       JNE     SEARCHBT                ;NO,
SKIP_SASI:
        POP     AX
;--------------------------------------------------------- 90/03/20 --
        PUSH    BX
        MOV     BX,OFFSET X2_SW_00
        PUSH    AX
        AND     AX,000FH
        ADD     BX,AX
        POP     AX
        TEST    BYTE PTR [BX],-1
        POP     BX
        JNZ     X_DRCNT                 ;850610
        JMP     short SEARCHBT          ;88/03/22

;       CMP     AL,82H                  ;SASI #2
;       JAE     X_DRCNT
;------------------------------------------------------- 871011 ------
;       TEST    AL,01H                  ;UNIT#1 ?
;       JNZ     SKPUNT0                 ;YES,
;---------------------------------------------------------------------
;       TEST    [X2_SW_00],-1           ;850610
;       JNZ     X_DRCNT                 ;850610
;       JMP     SEARCHBT                ;88/03/22
;SKPUNT0:
;       TEST    [X2_SW_01],-1           ;850610
;       JNZ     X_DRCNT                 ;88/03/22
;       JMP     SEARCHBT                ;88/03/22
;---------------------------------------------------------------------
X_DRCNT:                                ;850610
;**     MOV     AH,[BT_TYP]             ;COMMENT                       871001
ADDDRV:
        CMP     [BX],AL                 ;HIT?                   DL->AL 871001
        JE      SKIP_ADD                ;YES,
        INC     [SV_RDRV]               ;NO, NEXT
ADDDRV10:
        ADD     BX,2
        LOOP    ADDDRV                  ; JMP ADDDRV --> LOOP ADDDRV   88/05/19

SKIP_ADD:
        MOV     BL,[SV_RDRV]            ;GET RELATIVE DRIVE
        JMP     SHORT SET_DEFAULT

SEARCHBT:
        CMP     [BX],AL                 ;HIT ?
        JE      SEARCHBT_10             ;SKIP IF SO
        INC     BX
        INC     BX
        LOOP    SEARCHBT
SEARCHBT_10:
        SUB     BX,OFFSET EXLPTBL+1
        SHR     BX,1

;****************************************870827 NEW
;*                                      *
;*      SET IO.SYS VARIABLE -2          *
;*                                      *
;****************************************
        CALL    SETVAL2
;********************************************************
;*                                                      *
;*      SET MM SIZE & BUFFERS INITIAL VALUE             *
;*                                                      *
;********************************************************
SET_DEFAULT:
        MOV     AX,SEG SYSINITSEG
        MOV     DS,AX
        ASSUME  DS:SYSINITSEG
        MOV     [MEMORY_SIZE],DX
;------------------------------------------------ 870825 - BUFFERS ---
        MOV     AX,0002H        ;       
        CMP     DX,6000H        ;  MM       BUFFERS
        JB      SET_BUFFERS     ; ----------------------
        MOV     AX,0005H        ; 128KB         2 
        JE      SET_BUFFERS     ; 256KB         2 
        MOV     AX,000AH        ; 384KB         5 
        CMP     DX,8000H        ; 512KB        10  
        JE      SET_BUFFERS     ; 640KB        20  
        MOV     AX,0014H        ; 768KB        20
SET_BUFFERS:                    ;
        MOV     [BUFFERS],AX    ;   768KB IS HIRESO ONLY
                                ; 88/03/17 AL -> AX
;---------------------------------------------------------------------
;********************************************************
;*                                                      *
;*      SYSINIT CALL                                    *
;*                                                      *
;********************************************************
;       
;       IO.SYS FILE SIZE MUST BE FIXED
;       L(IO.SYS)...64K
;
BIOSSIZ EQU     1000H                   ;BIOS SIZE (PARAGRAH) 46KB(871001)

        MOV     AX,CS
        ADD     AX,BIOSSIZ
        PUSH    DS
        MOV     DS,AX
;----------------------------------------- LOAD MSDOS.SYS 871002 -----
        PUSH    AX                      ;SAVE DOS LOCATION
        PUSH    BX                      ;SAVE DEFAULT DRIVE
        CALL    READDOS                 ;LOAD MS-DOS
        POP     BX                      ;
        POP     AX
;---------------------------------------------------------------------
;       MOV     DS:[DEF_DRV],BL
        POP     DS
        push    ax
        SVC     SVC_DEMGETBOOTDRIVE
        dec     al
        MOV     CS:[BOOT_DRIVE],AL
        MOV     [DEFAULT_DRIVE],AL              ;1 ORIGIN DRIVE NUMBER
        pop     ax
        MOV     [CURRENT_DOS_LOCATION],AX
;
        MOV     AX,CS
        MOV     WORD PTR [DEVICE_LIST+2],AX
        MOV     WORD PTR [DEVICE_LIST],OFFSET DEV_TBL
;
        MOV     AX,OFFSET REINIT_END
;--------------------------------------------------------- 88/03/23 --
        CMP     CS:[INFSH],00H
        JZ      FINAL_08
        MOV     AX,OFFSET HDSASI_END
FINAL_08:
;---------------------------------------------------------------------
;--------------------------------------------------------- 88/03/23 --
        TEST    CS:[SYS_501],01110000B
        JZ      FINAL_05
        CMP     CS:[INF5H],00H
        JZ      FINAL_06
        MOV     AX,OFFSET HDSASI_END
;------------------------------------------------------ 88/02/25 -----
        CMP     CS:EXFNC_FLG,0
        JZ      FINAL_06
        MOV     AX,OFFSET EXFNC_END
        JMP     short FINAL_06
FINAL_05:
        MOV     AX,OFFSET HDINT_END
FINAL_06:
;---------------------------------------------------------------------
;--------------------------------------------------------- 88/03/23 --
        CMP     BYTE PTR CS:MO_LPFLG,00H
        JZ      FINAL_09
        MOV     AX,OFFSET MODISK_END
FINAL_09:
;---------------------------------------------------------------------
IF BRANCH       ;--------------------------------------- 871002 ------
        TEST    CS:MEM_SW4,10H
        JZ      FINAL_10
        MOV     AX,OFFSET DOSSPOT
        CALL    BRNCINIT                ;85/04/11
ENDIF   ;-------------------------------------------------------------
FINAL_10:
;------------------------------------------------ DOS5 91/01/20 --------
        MOV     SI,WORD PTR CS:START_BDS
        MOV     CX,1
SEARCH_BDS:
        CMP     WORD PTR CS:[SI].BDS_LINK,-1
        JE      GOT_BDS_END
        INC     CX
        MOV     SI,WORD PTR CS:[SI].BDS_LINK
        JMP     SEARCH_BDS
GOT_BDS_END:
        MOV     AX,OFFSET DATAGRP:BDS21         ;END ADDR (#DRIVE=<20)
        CMP     CX,20
        JBE     SET_END_ADDR
        MOV     AX,OFFSET DATAGRP:B_DATA_END    ;END ADDR (#DRIVE>20)
SET_END_ADDR:
;-----------------------------------------------------------------------

        ADD     AX,000FH
        MOV     CL,4
        SHR     AX,CL
        ADD     AX,60H                  ;85/03/05
        mov     cs:[dosdatasg],ax

;       MOV     [FINAL_DOS_LOCATION],AX
;
        MOV     CS:[SEG_DOS],AX
;
        JMP     SYSINIT

        PAGE
;****************************************************************
;*                                                              *
;*      SUBROUTINES                                             *
;*                                                              *
;****************************************************************
        ASSUME  DS:DATAGRP

;************************************************
;*                                              *
;*      B4670 SUBROUTINES                       *
;*                                              *
;************************************************

B4670VEC:
IF BRANCH       ;-----------------------------------------------------
        MOV     AX,[INT1B_OFFSET]       ;SAVE VECTOR FOR RETURN,START 
        MOV     CS:[X21_DSKBIO],AX      ;
        MOV     AX,[INT1B_SEGMENT]
        MOV     CS:[X21_DSKBIO+2],AX

        MOV     AX,[INT1C_OFFSET]       ;SAVE VECTOR FOR RETURN,START 
        MOV     CS:[X21_TIMBIO],AX      ;TIMER 
        MOV     AX,[INT1C_SEGMENT]
        MOV     CS:[X21_TIMBIO+2],AX

        MOV     AX,[INT08_OFFSET]       ;SAVE VECTOR FOR RETURN,START 
        MOV     CS:[X21_TIMINT],AX      ;TIMER 
        MOV     AX,[INT08_SEGMENT]
        MOV     CS:[X21_TIMINT+2],AX
ENDIF   ;-------------------------------------------------------------
        RET

BRNCINIT:
IF BRANCH       ;-----------------------------------------------------
        PUSH    AX
        PUSH    ES
        PUSH    CS
        POP     ES
        MOV     DI,OFFSET DATAGRP:INIT_TBL
        MOV     AX,OFFSET DATAGRP:VT_BPB
        MOV     CX,26
        CLD
        REP     STOSW
        POP     ES
        POP     AX
ENDIF   ;-------------------------------------------------------------
        RET

SETDRVNUM:
        MOV     AL,90H
        CALL    CNTDRV
        MOV     N8FD,CL
        MOV     AL,70H
        CALL    CNTDRV
        MOV     N5FD,CL
        MOV     AL,80H                  ;DA=SASI HD
        CALL    CNTDRV
        MOV     N5HD,CL
;--------------------------------------------------------- 88/03/22 --
        MOV     [MOSW],00H
        MOV     AL,0A0H                 ;DA=SCSI HD
        CALL    CNTDRV
        MOV     NSHD,CL
        MOV     [MOSW],01H
        MOV     AL,0A0H
        CALL    CNTDRV
        MOV     NSMO,CL
;---------------------------------------------------------------------
        RET

CNTDRV:
        MOV     BX,OFFSET EXLPTBL+1
        XOR     CL,CL
CNTDRV10:
        CMP     BYTE PTR[BX],0
        JE      CNTDRV30
        MOV     AH,[BX]
        AND     AH,0F0H                 ;ONLY DA
        CMP     AH,AL
        JNZ     CNTDRV20
;--------------------------------------------------------- 89/08/19 --
        CMP     AL,0A0H
        JNZ     CNTDRV18
        CMP     [MOSW],0
        JNZ     CNTDRV16
;------------------------------------------------DOS5 91/08/00-----------
        test    BYTE PTR [BX-1],01H
;---------------
;       CMP     BYTE PTR [BX-1],00H
;------------------------------------------------------------------------
        JZ      CNTDRV18
        JMP     short CNTDRV20
CNTDRV16:
;------------------------------------------------DOS5 91/08/00-----------
        test    BYTE PTR [BX-1],01H
        jnz     CNTDRV18
;---------------
;       CMP     BYTE PTR [BX-1],01H
;       JZ      CNTDRV18
;------------------------------------------------------------------------
        JMP     short CNTDRV20
CNTDRV18:
;---------------------------------------------------------------------
        INC     CL
CNTDRV20:
        ADD     BX,2
        JMP     SHORT CNTDRV10
CNTDRV30:
        RET

B4670_CNT:
IF BRANCH       ;-----------------------------------------------------
        MOV     [FSTDRV],0              ;CLEAR
        PUSH    AX
        PUSH    BX
B4670_CNT_LOOP:
        MOV     AL,[BX]                 ;GET DA/UA
        OR      AL,AL
        JZ      B4670_CNT_EXIT          ;SKIP IF NULL
        AND     AL,0F0H                 ;ONLY DA
        CMP     AL,60H                  ;VIRTUAL DISK
        JE      B4670_CNT_EXIT
        INC     [FSTDRV]  
        ADD     BX,2
        JMP     SHORT B4670_CNT_LOOP    ;SEARCH NEXT
B4670_CNT_EXIT:
        POP     BX
        POP     AX
ENDIF   ;-------------------------------------------------------------
        RET

;************************************************
;*                                              *
;*      << NORMAL MODE ONLY >>  870827          *
;*                                              *
;*      SETUP WARM INT VECTOR                   *
;*      & CHECK 5"2DD EXT ROM ( N10 ONLY )	*
;*      & CHECK 5"HD  EXT ROM ( N10 ONLY )	*
;*                                              *
;************************************************
        ASSUME DS:INT_VEC

;************************************************
;*                                              *
;*      CHKECK CRT BIOS                         *
;*              XA,XL(H) INT 18 SAVE            *
;************************************************
CHK_CRTBIOS:
        TEST    BYTE PTR [BIO_FLAG],08H
        JZ      CRTBIOS_10
        TEST    BYTE PTR [CPU_TYPE],02H
        JNZ     CRTBIOS_10
        PUSH    AX
        PUSH    ES
        MOV     ES,CS:BIOS_SEG                  ;BIOS CODE SEGMENT
        MOV     AX,[INT18_OFFSET]
        MOV     ES:SAVE_INT18,AX
        MOV     AX,[INT18_SEGMENT]
        MOV     ES:SAVE_INT18+2,AX
        MOV     WORD PTR [INT18_OFFSET],OFFSET CRTBIOS_START
        MOV     WORD PTR [INT18_SEGMENT],CS
        POP     ES
        POP     AX
CRTBIOS_10:
        RET

        ASSUME  DS:DATAGRP

;************************************************
;*                                              *
;*      GET & SET MEMORY SWITCH CONTENT         *
;*                                              *
;************************************************
SETVRAM:
        PUSH    DS
        XOR     AX,AX
        MOV     DS,AX
        MOV     CS:[VRAMSEG],0A000H
        TEST    BYTE PTR DS:[0501H],08H ;HW-MODE ?
        JZ      SETVRAM10               ;NORMAL
        MOV     CS:[VRAMSEG],0E000H     ;HIRESO
SETVRAM10:
        POP     DS
        RET
;************************************************
;*                                              *
;*      GET & SET MEMORY SWITCH CONTENT         *
;*                                              *
;************************************************
SETCMOS:
        PUSH    DS
;---------------------------------------------------------------------
;       MOV     AX,CMOS_SEG             ;SET CMOS SEG ADDR
;--------
        MOV     AX,CS:[VRAMSEG]
        ADD     AX,03FEH
;---------------------------------------------------------------------
        MOV     DS,AX
        MOV     SI,2
        MOV     DI,OFFSET MEM_SW1
        MOV     CX,4
L_MEMSW1:
        MOVSB                           ;GET MEMORY SWITCH 1-4
        ADD     SI,3
        LOOP    L_MEMSW1
        MOV     DI,OFFSET MEM_SW5
        MOV     CX,3
L_MEMSW5:
        MOVSB                           ;GET MEMORY SWITCH 5-7
        ADD     SI,3
        LOOP    L_MEMSW5
;------------------------------------------------------ 88/03/31 -----
        XOR     AX,AX
        MOV     DS,AX                   ;DS = SEGMENT 0
        MOV     AL,DS:[458H]            ;GET BIOSF_3            89/08/21
        MOV     CS:BYTE PTR [BIOSF_3],AL;SET BIOSF_3            89/08/21
        MOV     AL,DS:[0401H]           ;GET EXTENDED MM SIZE
        POP     DS
        MOV     [EXMM_SIZE],AL          ;SAVE IT
;    < COPY MEM_SW1-2 TO CH?MSW1-2 >
        MOV     DI,OFFSET CH1MSW1
        MOV     SI,DI
        MOV     AL,[MEM_SW1]            ;GET MM SW1
        STOSB                           ;COPY TO C#1
        MOV     AL,[MEM_SW2]
        AND     AL,0FH                  ;GET MM SW2 (BAUD RATE ONLY)
        STOSB                           ;COPY TO C#1
        MOV     CX,4                    ;COPY 4 TIMES
        REP     MOVSB
;---------------------------------------------------------------------
        RET
;************************************************
;*                                              *
;*      SAVE BIOS FLAG CONTENT                  *
;*                                              *
;************************************************
SAV_FLAG:
        PUSH    DS
        XOR     AX,AX
        MOV     DS,AX                   ;DS <- 0000H
        MOV     SI,500H
        MOV     DI,OFFSET SYS_500
        MOVSW                           ;0:500H - 501H GET
        POP     DS
        RET
;------------------------------------------------------------------
;************************************************
;*                                              *
;*      CURSOR DISPLAY ON                       *
;*                                              *
;************************************************
CSRON:
        MOV     AH,11H
        INT     18H
        RET

;************************************************
;*                                              *
;*      INITIALIZE THE KEYBOARD                 *
;*                                              *
;************************************************
KBINIT:
        MOV     AX,0300H
        INT     18H
        RET

;************************************************
;*                                              *
;*      MAKE EXLPTBL EXCEPT ALC_TYP = 0.        *
;*                                              *
;************************************************
AUTO_TBL:
        MOV     AL,ALC_TYP              ;SET DRIVE ALLOCATION TYPE
        DEC     AL
        MOV     AH,3*4                  ;1 TYPE HAS 12 BYTE
        MUL     AH
        MOV     BP,OFFSET DATAGRP:ALC_TBL       ;SET ALLOCATION TABLE ADDR
        ADD     BP,AX                   ;SET PROPER ENTRY
        MOV     BX,OFFSET EXLPTBL+1 
        MOV     CX,4
AUTO_TBL10:
        PUSH    CX
        MOV     AH,[BP]                 ;FIRST DA/UA
        MOV     DI,1[BP]
        MOV     AL,[DI]                 ;GET EQUIP INF
        CMP     AH,80H
        JE      AUTO_TBL10H
        CALL    M_COMMON
        JMP     short AUTO_TBL20
AUTO_TBL10H:
        CALL    HARD_COMMON
AUTO_TBL20:
        ADD     BP,3
        POP     CX
        DEC     CX
        JNE     AUTO_TBL10
        RET

HARD_COMMON:
        MOV     SCSI_FLG,00H                    ;89/08/19 
        MOV     AL,HD_NUM
        MOV     AH,80H
        CALL    MH_COMMON
        MOV     AL,HD1_NUM
        MOV     AH,81H
        CALL    MH_COMMON
        RET

;********************************************************
;*                                                      *
;*      ASSIGN INIT TABLE                               *
;*                                                      *
;********************************************************
ASS_INITTBL:
        MOV     SVHD1,OFFSET datagrp:HDDSK5_1 - BPB_SIZE
        MOV     SVHD2,OFFSET datagrp:HDDSK5_2 - BPB_SIZE
        MOV     SVHD3,OFFSET datagrp:HDDSK5_3 - BPB_SIZE
        MOV     SVHD4,OFFSET datagrp:HDDSK5_4 - BPB_SIZE
        MOV     SVHDS1,OFFSET datagrp:HDDSKS_1 - BPB_SIZE
        MOV     SVHDS2,OFFSET datagrp:HDDSKS_2 - BPB_SIZE
        MOV     SVHDS3,OFFSET datagrp:HDDSKS_3 - BPB_SIZE
        MOV     SVHDS4,OFFSET datagrp:HDDSKS_4 - BPB_SIZE
        MOV     SVHDS5,OFFSET datagrp:HDDSKS_5 - BPB_SIZE
        MOV     SVHDS6,OFFSET datagrp:HDDSKS_6 - BPB_SIZE
        MOV     SVHDS7,OFFSET datagrp:HDDSKS_7 - BPB_SIZE
        MOV     SVHDS8,OFFSET datagrp:HDDSKS_8 - BPB_SIZE
        MOV     BX,OFFSET datagrp:EXLPTBL+1     ;SET EXLPTBL ADDR
        MOV     DI,OFFSET datagrp:INIT_TBL      ;SET TARGET TABLE ADDR
        MOV     BP,OFFSET datagrp:LPTABLE       ;SET LPTABLE ADDR
        XOR     CX,CX
ASS_INIT10:
        MOV     AL,[BX]                 ;GET UA/DA
;--------------------------------------------------------- 88/03/22 --
        CMP     AL,0
        JNZ     ASS_INIT12
        JMP     ASS_EXIT
;       OR      AL,AL                   ;END OF TABLE ?
;       JE      ASS_EXIT
ASS_INIT12:
;---------------------------------------------------------------------
        CMP     CX,16
        JAE     ASS_INIT15
        MOV     [BP],AL         ;SET IT
ASS_INIT15:
        AND     AL,0F0H                 ;STRRIP DA
        CMP     AL,80H
        JE      ASS_INIT30              ;SKIP IF SASI
        CMP     AL,0A0H
        JE      ASS_INIT70              ;SKIP IF SCSI
        MOV     SI,OFFSET datagrp:DSK8_DBL      ;SET 8"FD DOUBLE BPB 
        CMP     AL,90H                  ;8"FD 
        JE      ASS_INIT20              ;SKIP IF SO
;-------------------------------- CORRECT FIRST BPB 720K -> 1MB --- 870911 --
        MOV     SI,OFFSET datagrp:DSK8_DBL      ;
;----------------------------------------------------------------------------
IF BRANCH ;----------------------------------------------- 90/03/16 --
        CMP     AL,70H
        JE      ASS_INIT20              ;SKIP IF SO
        MOV     SI,OFFSET datagrp:VT_BPB
ENDIF ;---------------------------------------------------------------
ASS_INIT20:
        MOV     [DI],SI
ASS_INIT25:
        INC     CX
        INC     BP
        INC     DI
        INC     DI
        INC     BX
        INC     BX
        JMP     ASS_INIT10
;--------------------------------------------------------- 88/03/22 --
ASS_INIT30: 
        CMP     BYTE PTR [BX],80H
        JNE     ASS_INIT40              ;SKIP IF NOT SASI #0
        ADD     SVHD1,BPB_SIZE
        MOV     SI,SVHD1                ;GET HARD DPB
        JMP     short ASS_INIT60
ASS_INIT40:
        CMP     BYTE PTR [BX],81H
        JNE     ASS_INIT50              ;SKIP IF NOT SASI #1
        ADD     SVHD2,BPB_SIZE
        MOV     SI,SVHD2                ;GET HARD DPB
        JMP     short ASS_INIT60
ASS_INIT50:
        CMP     BYTE PTR [BX],82H
        JNE     ASS_INIT55              ;SKIP IF NOT SASI #2
        ADD     SVHD3,BPB_SIZE
        MOV     SI,SVHD3                ;GET HARD DPB
        JMP     short ASS_INIT60
ASS_INIT55:
        ADD     SVHD4,BPB_SIZE
        MOV     SI,SVHD4                ;GET HARD DPB
ASS_INIT60:
        MOV     [DI],SI
        JMP     SHORT ASS_INIT25

ASS_INIT70: 
        CMP     BYTE PTR [BX],0A0H
        JNE     ASS_INIT80              ;SKIP IF NOT SCSI #0
        ADD     SVHDS1,BPB_SIZE
        MOV     SI,SVHDS1               ;GET HARD DPB
        JMP     short ASS_INIT200
ASS_INIT80:
        CMP     BYTE PTR [BX],0A1H
        JNE     ASS_INIT90              ;SKIP IF NOT SCSI #1
        ADD     SVHDS2,BPB_SIZE
        MOV     SI,SVHDS2               ;GET HARD DPB
        JMP     short ASS_INIT200
ASS_INIT90:
        CMP     BYTE PTR [BX],0A2H
        JNE     ASS_INIT100             ;SKIP IF NOT SCSI #2
        ADD     SVHDS3,BPB_SIZE
        MOV     SI,SVHDS3                ;GET HARD DPB
        JMP     short ASS_INIT200
ASS_INIT100:
        CMP     BYTE PTR [BX],0A3H
        JNE     ASS_INIT110             ;SKIP IF NOT SCSI #3
        ADD     SVHDS4,BPB_SIZE
        MOV     SI,SVHDS4                ;GET HARD DPB
        JMP     short ASS_INIT200
ASS_INIT110:
        CMP     BYTE PTR [BX],0A4H
        JNE     ASS_INIT120             ;SKIP IF NOT SCSI #4
        ADD     SVHDS5,BPB_SIZE
        MOV     SI,SVHDS5                ;GET HARD DPB
        JMP     short ASS_INIT200
ASS_INIT120:
        CMP     BYTE PTR [BX],0A5H
        JNE     ASS_INIT130             ;SKIP IF NOT SCSI #5
        ADD     SVHDS6,BPB_SIZE
        MOV     SI,SVHDS6                ;GET HARD DPB
        JMP     short ASS_INIT200
ASS_INIT130:
        CMP     BYTE PTR [BX],0A6H
        JNE     ASS_INIT140             ;SKIP IF NOT SCSI #6
        ADD     SVHDS7,BPB_SIZE
        MOV     SI,SVHDS7                ;GET HARD DPB
        JMP     short ASS_INIT200
ASS_INIT140:
        ADD     SVHDS8,BPB_SIZE
        MOV     SI,SVHDS8                ;GET HARD DPB
ASS_INIT200:
        JMP     ASS_INIT60

;---------------------------------------------------------------------
ASS_EXIT:
        SUB     BX,OFFSET datagrp:EXLPTBL+1
        SHR     BX,1                    ;GET NUMBER OF DRIVE
        MOV     DRV_NUM,BL              ;SET IT(REF DSK_INIT)
        RET

;************************************************
;*                                              *
;*      SET BDS TABLE                           *
;*                                              *
;************************************************

SET_BDS:
        MOV     AX,CS
        MOV     DS,AX
        MOV     ES,AX
        MOV     DI,WORD PTR START_BDS   ;SET BDS #1
        MOV     SI,OFFSET datagrp:INIT_TBL      ;SET BPB POINTER TABLE
        MOV     BX,OFFSET datagrp:EXLPTBL+1
        XOR     CX,CX
NEXT_BDS:
        MOV     AL,BYTE PTR [BX-2]
        CMP     BYTE PTR [BX],AL        ;CHECK DA/UA
        JZ      SETBDS010
        XOR     DX,DX
        JMP     short SETBDS020
SETBDS010:
        INC     DX
SETBDS020:
        CMP     WORD PTR [SI],0000H     ;END BPB POINTER TABLE
        JNZ     SETBDS025
        JMP     END_BDS
SETBDS025:
        MOV     AL,BYTE PTR [BX]
        MOV     [DI].BDS_DRIVENUM,AL
        MOV     [DI].BDS_DRIVELET,CL
;--------------------------------------------------------- 89/08/08 --
        TEST    BYTE PTR [BX-01],80H
        JZ      SETBDS025_3
        OR      WORD PTR [DI].BDS_FLAGS,fi_am_mult
        CMP     BYTE PTR [WSINGLE],0FFH
        JZ      SETBDS025_1
        MOV     BYTE PTR [WSINGLE],0FFH
        JMP     short SETBDS025_3
SETBDS025_1:
        XOR     WORD PTR [DI].BDS_FLAGS,fi_own_physical
SETBDS025_3:
;---------------------------------------------------------------------
        PUSH    CX
        MOV     CX,13
        PUSH    DI
        PUSH    SI
        LEA     DI,[DI].BDS_BPB
        MOV     SI,WORD PTR [SI]
        REP MOVSB                       ;COPY BPB --> BDS
        POP     SI
        POP     DI
;-----------------------------------------------------  89/07/28  ---
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,01H
        JA      SETBDS025_4
        MOV     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0FEH
        JMP     short SETBDS025_6
SETBDS025_4:
        CMP     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,02H
        JNB     SETBDS025_6
        MOV     BYTE PTR [DI].BDS_BPB.BPB_MEDIADESCRIPTOR,0FBH
SETBDS025_6:
        TEST    BYTE PTR [BX],10H       ;CHECK FD OR HD
;-----------------------------------------------------  89/07/28  ---
        JZ      SETBDS27
;----------------------------------------------- DOS5 91/06/12 -------
        TEST    BYTE PTR [BX],80H       ;if DA/UA = 9xh
        JNZ     SKIP_FDJ                ; then skip
        MOV     BYTE PTR [DI].BDS_FORMFACTOR,02H
SKIP_FDJ:
;---------------------------------------------------------------------
        JMP     SKIP_FD
SETBDS27:
        TEST    BYTE PTR [BX-1],01H     ;CHECK HD OR MODISK
        JZ      SETBDS28                ; skip if HD
        MOV     BYTE PTR [DI].BDS_BPB.BPB_SECTORSPERTRACK,40H
        MOV     BYTE PTR [DI].BDS_FORMFACTOR,05H
;----------------------------------------------- DOS5 91/08/00 -------
        push    bx
        mov     bl,byte ptr [bx]
        and     bl,0fh
        xor     bh,bh
        cmp     byte ptr SCSI_EQUIP.[bx],07h
        pop     bx
        jne     NOT_35MO
        mov     byte ptr [di].BDS_BPB.BPB_SECTORSPERTRACK,19h
        mov     byte ptr [di].BDS_FORMFACTOR,08h
NOT_35MO:
;---------------------------------------------------------------------
        MOV     BYTE PTR [DI].BDS_BPB.BPB_HEADS,1
        MOV     WORD PTR [DI].BDS_FLAGS,fi_own_physical ;DOS5 91/05/10
        PUSH    BX
        PUSH    DX
        JMP     SHORT SKIP_MODISK
SETBDS28:
        PUSH    BX
        PUSH    DX
;----------------------------------------------- DOS5 91/02/20 -------
        PUSH    SI
        MOV     SI,OFFSET HD_MEDIA
        TEST    BYTE PTR [BX],20H
        JZ      SETBDS28_SASI
        MOV     SI,OFFSET HDS_MEDIA
SETBDS28_SASI:
        XOR     AH,AH
        MOV     AL,BYTE PTR [BX]
        AND     AX,0FH
        MOV     CX,92
        PUSH    DX
        MUL     CX
        ADD     SI,AX
        POP     DX
        MOV     AX,DX                           ; # of partition
        MOV     CX,23
        PUSH    DX
        MUL     CX
        ADD     SI,AX                           ; SI points media Ids
        POP     DX

        CMP     BYTE PTR [SI+15],0              ; 1st byte of FILE_SYS_ID
        JE      SETBDS28_NOTEXT                 ; not ext bpb then skip
        MOV     CX,WORD PTR [SI]
        MOV     WORD PTR [DI].BDS_VOL_SERIAL,CX
        MOV     CX,WORD PTR [SI+2]
        MOV     WORD PTR [DI].BDS_VOL_SERIAL+2,CX; set serial number
        ADD     SI,4
        PUSH    DI
        LEA     DI,[DI].BDS_VOLID
        MOV     CX,11
        REP     MOVSB                           ; set volume label
        ADD     DI,5
        MOV     CX,8
        REP     MOVSB                           ; set fat id
        POP     DI
SETBDS28_NOTEXT:
        POP     SI
;---------------------------------------------------------------------
        XOR     AH,AH
        MOV     AL,BYTE PTR [BX]
        PUSH    AX
        AND     AL,0F0H
        MOV     DA,AL                   ;SET DA
        POP     AX
        AND     AL,0FH
        MOV     UA,AL                   ;SET UA
        CALL    SENSE_HD                ;SENSE HD
        MOV     BYTE PTR [DI].BDS_BPB.BPB_SECTORSPERTRACK,DL
        MOV     BYTE PTR [DI].BDS_BPB.BPB_HEADS,DH
        MOV     BYTE PTR [DI].BDS_FORMFACTOR,05H
;-----------------------------------------------------  89/07/28  ---
        MOV     WORD PTR [DI].BDS_FLAGS,fi_own_physical+fnon_removable  ;DOS5 91/05/10
SKIP_MODISK:
;------------------------------------------------DOS5 91/01/20-----------
        PUSH    SI
        MOV     SI,WORD PTR [SI]
        ADD     SI,13
        MOV     AX,WORD PTR [SI]
        MOV     WORD PTR [DI].BDS_BPB.BPB_BIGTOTALSECTORS,AX
        MOV     AX,WORD PTR [SI+2]
        MOV     WORD PTR [DI+2].BDS_BPB.BPB_BIGTOTALSECTORS,AX
        POP     SI
;------------------------------------------------------------------------
;;;     MOV     BYTE PTR [DI].BDS_FLAGS,21H     ;DOS5 91/05/10
        MOV     AX,WORD PTR [DI].BDS_BPB.BPB_TOTALSECTORS
;----------------------------------------------- DOS5 91/08/00 -------
        xor     dx,dx
        or      ax,ax                   ;ax=0 if large partition
        jnz     SETBDS027
        mov     ax,word ptr [di].BDS_BPB.BPB_BIGTOTALSECTORS
        mov     dx,word ptr [di].BDS_BPB.BPB_BIGTOTALSECTORS+2
SETBDS027:
        push    dx
;---------------------------------------------------------------------
        PUSH    AX
        MOV     AX,WORD PTR [DI].BDS_BPB.BPB_HEADS
        MUL     WORD PTR [DI].BDS_BPB.BPB_SECTORSPERTRACK
        MOV     CX,AX
        POP     AX
;----------------------------------------------- DOS5 91/08/00 -------
        pop     dx
;---------------
;       XOR     DX,DX
;---------------------------------------------------------------------
        DIV     CX
        OR      DX,DX
        JZ      SETBDS028
        INC     AX
SETBDS028:
        MOV     WORD PTR [DI].BDS_CCYLN,AX

        POP     DX
        POP     BX

        PUSH    SI

        TEST    BYTE PTR [BX],20H
        JNZ     SETBDS030
        MOV     SI,OFFSET HD_OFFSET
        JMP     short SETBDS040
SETBDS030:
        MOV     SI,OFFSET HDS_OFFSET
SETBDS040:
        XOR     AH,AH
        MOV     AL,BYTE PTR [BX]
        AND     AL,0FH
        MOV     CL,4
        SHL     AX,CL
        ADD     SI,AX
        
        MOV     AX,DX
        SHL     AX,1
        SHL     AX,1
        ADD     SI,AX
        MOV     AX,WORD PTR [SI]
        MOV     [DI].BDS_BPB.BPB_HIDDENSECTORS,AX
;------------------------------------------------DOS5 91/01/20-----------
        MOV     AX,WORD PTR [SI+2]
        MOV     WORD PTR [DI+2].BDS_BPB.BPB_HIDDENSECTORS,AX
;------------------------------------------------------------------------

        TEST    BYTE PTR [BX],20H
        JNZ     SETBDS050
        MOV     SI,OFFSET FBIGFAT
        JMP     short SETBDS060
SETBDS050:
        MOV     SI,OFFSET FBIGFATS
SETBDS060:
        XOR     AH,AH
        MOV     AL,BYTE PTR [BX]
        AND     AL,0FH
;----------------------------------------------- DOS5 91/02/20 -------
        ADD     SI,AX
        MOV     AX,1
        MOV     CX,DX
        SHL     AX,CL
        TEST    BYTE PTR [SI],AL
        JZ      SETBDS070
        MOV     [DI].BDS_FATSIZ,40H

SETBDS070:
;---------------------
;       MOV     CL,2
;       SHL     AX,CL
;       ADD     SI,AX
;       ADD     SI,DX
;       MOV     AL,BYTE PTR [SI]
;       MOV     [DI].BDS_FATSIZ,AL
;---------------------------------------------------------------------

        POP     SI
SKIP_FD:
        PUSH    SI
        PUSH    DI
        MOV     CX,25
        LEA     SI,[DI].BDS_BPB
        LEA     DI,[DI].BDS_RBPB
        REP     MOVSB                   ;COPY BDS(BPB) --> BDS(RBPB)
        POP     DI
        POP     SI
        POP     CX
        MOV     DI,WORD PTR [DI].BDS_LINK
        INC     CX
        ADD     SI,2
        ADD     BX,2
;-----------------------------------------------------  89/07/28  ---
        CMP     DI,-1
        JZ      END_MAX
;-----------------------------------------------------  89/07/28  ---
        JMP     NEXT_BDS
        
END_BDS:
        CMP     DI,OFFSET DATAGRP:BDS21
        JNE     NOT20
        MOV     DI,OFFSET DATAGRP:BDS20
        MOV     WORD PTR [DI],-1
        JMP     SHORT END_MAX
NOT20:
        SUB     DI,SIZE BDS_STRUC
        MOV     WORD PTR [DI],-1
END_MAX:                                ;                       89/07/28
        RET

;------------------------------------------------DOS5 91/02/15-----------
;
;Reassign init table
;
;       ENTRY:
;
;       EXIT:   init table set
;
;       USES:   di, si, bx, flags
;

REASS_INITTBL:

        MOV     BX, OFFSET INIT_TBL
        MOV     DI, WORD PTR START_BDS
REASS_10:
        LEA     SI, [DI].BDS_RBPB
        MOV     WORD PTR [BX], SI
        ADD     BX, 2
        MOV     DI, WORD PTR [DI.BDS_LINK]
        CMP     DI, -1                  ;Is that the last drive?
        JNE     REASS_10
        RET
;------------------------------------------------------------------------

;--------------------------------------------------------- 89/08/18 --

;************************************************
;       MODISK INITIARIZE ROUTINE               *
;                                               *
;************************************************
MODISK_INIT:
        XOR     AX , AX                       ; AL <- UNIT COUNTER
                                              ; AH <- SCSI ID COUNTER
        MOV     BX , OFFSET MO_DEVICE_TBL     ; BX <- DEV MANAGEMENT TBL PTR SET


        MOV     DL , BYTE PTR MO_LPFLG        ; DEVICE INFORMATION 
        MOV     CX , 8                        ; SHIFT COUNTER

SET_LOOP:
        CLC                                   ; CF = 0
        SHR     DL , 1                        ; SHIFT
        JC      MO_DEV_SET                    ; JMP IF BIT ON CONNECTION 
        JMP     short CHK_NEXT                ; NEXT BIT CHECK 

MO_DEV_SET:
        PUSH    CX                            ;
        XOR     CX , CX                       ;
        MOV     CL , YUKO_UNIT                ; MANEGEMENT PART / MEDIA
MO_DEV_LOOP:
        MOV     [BX] , AL                     ; UNIT# SET
        INC     AL                            ; UNIT# COUNT UP
        INC     BX                            ; SET PTR DEV_TBL FLAG
        MOV     BYTE PTR [BX] , 02H           ; SET BPB UPDATE FLAG = 02
        INC     BX                            ; SET PTR DEV_TBL SCSI ID 
        MOV     [BX] , AH                     ; SCSI ID SET
        INC     BX                            ;
        INC     BX                            ; NEXT TBL PTR
        LOOP    MO_DEV_LOOP                   ; CREATE TBL NUMBER OF MAGEMENT 
        POP     CX                            ;

CHK_NEXT:
        INC     AH                            ; SCSI ID COUNTER UP
        LOOP    SET_LOOP                      ; 


        MOV     AL,UA
        OR      AL,0A0H
        CMP     AL,[BT_TYP]
        JNZ     MOINIT100
;----------------------------------------------- DOS5 91/08/00 -------
        mov     bl,UA
        xor     bh,bh
        cmp     byte ptr SCSI_EQUIP.[bx],07h    ;if 3.5" MO
        je      MOINIT100                       ; don't call HARDINIT
;---------------------------------------------------------------------
MODISK_BOOT:
        CALL    HARDINIT
MOINIT100:
        MOV     DL , BYTE PTR MO_LPFLG        ; DEVICE INFORMATION 
;----------------------------------------------- DOS5 91/08/00 -------
        mov     dh, byte ptr MO_LPFLG2        ; device information ( 3.5"MO)
;---------------------------------------------------------------------
        MOV     CX , 0                        ; SHIFT COUNTER
        MOV     BX,OFFSET HDDSKS_1
MOINIT110:
        CMP     CX,8
        JZ      MOINIT250
        CLC                                   ; CF = 0
        SHR     DL , 1                        ; SHIFT
        JC      MOINIT150                     ; JMP IF BIT ON CONNECTION 
        JMP     short MOINIT200               ; NEXT BIT CHECK 
MOINIT150:
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     UA,cl
        jne     short MOINIT200

        mov     YUKO_UNIT,4                   ;4 drive/unit
        test    dh, 1
        jz      MOINIT160
        mov     YUKO_UNIT,1                   ;1 drive/unit
MOINIT160:
;---------------------------------------------------------------------
        PUSH    BX
        MOV     BX, OFFSET HDS_NUM
        ADD     BX, CX
;----------------------------------------------- DOS5 91/08/00 -------
        mov     al,YUKO_UNIT
        MOV     BYTE PTR [BX],al
;---------------
;       MOV     BYTE PTR [BX],4
;---------------------------------------------------------------------
        POP     BX

        PUSH    CX
        MOV     DI,BX
;----------------------------------------------- DOS5 91/08/00 -------
        mov     cl,YUKO_UNIT
        xor     ch,ch
;---------------
;       MOV     CX,4
;---------------------------------------------------------------------
MOINIT180:
        PUSH    CX
        MOV     SI,OFFSET DATAGRP:MODISK_BPB
;----------------------------------------------- DOS5 91/08/00 -------
        test    dh, 1
        jz      MOINIT190
        mov     si, offset DATAGRP:MODISK_BPB2
MOINIT190:
;---------------------------------------------------------------------
        MOV     CX,BPB_SIZE
        REP MOVSB
        POP     CX
        LOOP    MOINIT180
        POP     CX
MOINIT200:
        INC     CX
        ADD     BX,HDDSK_SIZE
;----------------------------------------------- DOS5 91/08/00 -------
        shr     dh,1
;---------------------------------------------------------------------
        JMP     MOINIT110
MOINIT250:
;----------------------------------------------- DOS5 91/08/00 -------
        mov     YUKO_UNIT,4                   ;reset to 4 drive/unit
;---------------------------------------------------------------------
        RET

;---------------------------------------------------------------------
;------------------------------------------------ DOS5 91/08/00 --------
;
; CNV_MO_LPFLG
;
; FUNCTION: merge MO_LPFLG and MO_LPFLG2
;
; INPUT :   MO_LPFLG
;           MO_LPFLG2
;
; OUTPUT:   MO_LPFLG  updated
;           MO_LPFLG2 updated
;
;           MO_LPFLG  01001001  00001001  00001111
;           MO_LPFLG2 00110110  00000110  00000110
;
;

CNV_MO_LPFLG    proc    near

        xor     dl,dl
        mov     al,MO_LPFLG
        mov     cx,8
CNV_Loop1:
        shr     al,1
        jnc     CNV_Next1
        inc     dl
        cmp     dl,2
        jb      CNV_Next1
        mov     dl,8
        xchg    dl,cl
        sub     cl,dl
        inc     cl
        shl     al,cl
        xor     MO_LPFLG,al
        jmp     short CNV_10
CNV_Next1:
        loop    CNV_Loop1

CNV_10:
        xor     dl,dl
        mov     al,MO_LPFLG2
        mov     cx,8
CNV_Loop2:
        shr     al,1
        jnc     CNV_Next2
        inc     dl
        cmp     dl,2
        jb      CNV_Next2
        mov     dl,8
        xchg    dl,cl
        sub     cl,dl
        inc     cl
        shl     al,cl
        xor     MO_LPFLG2,al
        jmp     short CNV_EXIT
CNV_Next2:
        loop    CNV_Loop2

CNV_EXIT:
        mov     al,MO_LPFLG2
        or      MO_LPFLG,al
        ret

CNV_MO_LPFLG    endp
;-----------------------------------------------------------------------

;************************************************
;*                                              *
;*      FD MAKING COMMON                        *
;*                                              *
;************************************************

M_COMMON:
        MOV     CX,4                    ;SET LOOPING TIMES
        PUSH    BX                      ;SAVE CURRENT POINTER
        CLC                             ;CLERA CARRY
M_COM10:
        SHR     AL,1                    ;CHECK CONNECTING
        JNC     M_COM20                 ;SKIP IF NOT CONNECT
;--------------------------------------------------------- 88/05/19 --
        CMP     HD_CNT,26               ;MAX 26 DRIVE ?
        JAE     M_COM20
        MOV     [BX],AH                 ;PUT IT
        ADD     BX,2                    ;GET NEXT ENTRY
        INC     HD_CNT                  ;DRIVE NUM ++
;---------------------------------------------------------------------
M_COM20:
        INC     AH
        LOOP    M_COM10
        POP     CX
        MOV     DX,BX
        SUB     DX,CX
        CMP     DX,2                    ;SKIP IF SINGLE
        JNE     M_COM30
        CMP     AUT_LEX,0
        JE      M_COM30                 ;DON'T NEED LOGICAL EXTEND
        CMP     INF5H,0                 ;84/11/18
        JNE     M_COM30
;----------------------------------------------- DOS5 91/04/01 -------
; PATCH FIX
        CMP     INFSH,0
        JNE     M_COM30
        CMP     MO_LPFLG,0
        JNE     M_COM30
;---------------------------------------------------------------------
;----------------------------------------------- DOS5 91/08/00 -------
        CMP     MO_LPFLG2,0
        JNE     M_COM30
;---------------------------------------------------------------------
;--------------------------------
        MOV     CL,INF8F
        ADD     CL,INF5F
        CMP     CL,1
        JA      M_COM30
;--------------------------------
;--------------------------------------------------------- 88/05/19 --
        CMP     HD_CNT,26               ;MAX 26 DRIVE ?
        JAE     M_COM30
        MOV     AUT_LEX,0               ;ONLY ONE TIME
        MOV     CL,-2[BX]
        MOV     [BX],CL
        OR      BYTE PTR[BX-3],80H      ;SET LOGICAL EXTENT FLAG
        OR      BYTE PTR[BX-1],80H      ;SET LOGICAL EXTENT FLAG
        ADD     BX,2
        INC     HD_CNT                  ;DRIVE NUM ++
;---------------------------------------------------------------------
M_COM30:
        RET

;************************************************
;*                                              *
;*      HARD DISK ALL MAKING                    *
;*                                              *
;************************************************
MK_HDCOMMON:
        MOV     SCSI_FLG,00H            ;               89/08/19 
        MOV     AL,HD_NUM               ;SASI HD #0
        MOV     AH,80H
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     BP,OFFSET HDDSK5_1
;---------------------------------------------------------------------
        CALL    MH_COMMON
        MOV     AL,HD1_NUM              ;SASI HD #1
        MOV     AH,81H
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     BP,OFFSET HDDSK5_2
;---------------------------------------------------------------------
        CALL    MH_COMMON
        MOV     AL,HD2_NUM              ;SASI HD #2
        MOV     AH,82H
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     BP,OFFSET HDDSK5_3
;---------------------------------------------------------------------
        CALL    MH_COMMON
        MOV     AL,HD3_NUM              ;SASI HD #3
        MOV     AH,83H
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     BP,OFFSET HDDSK5_4
;---------------------------------------------------------------------
        CALL    MH_COMMON
;--------------------------------------------------------- 89/08/19 --
;       MOV     AL,HDS_NUM              ;SCSI HD #0
;       MOV     AH,0A0H
;       CALL    MH_COMMON
;       MOV     AL,HDS1_NUM             ;SCSI HD #1
;       MOV     AH,0A1H
;       CALL    MH_COMMON
;       MOV     AL,HDS2_NUM             ;SCSI HD #2
;       MOV     AH,0A2H
;       CALL    MH_COMMON
;       MOV     AL,HDS3_NUM             ;SCSI HD #3
;       MOV     AH,0A3H
;       CALL    MH_COMMON
;       MOV     AL,HDS4_NUM             ;SCSI HD #4
;       MOV     AH,0A4H
;       CALL    MH_COMMON
;       MOV     AL,HDS5_NUM             ;SCSI HD #5
;       MOV     AH,0A5H
;       CALL    MH_COMMON
;       MOV     AL,HDS6_NUM             ;SCSI HD #6
;       MOV     AH,0A6H
;       CALL    MH_COMMON
;       MOV     AL,HDS7_NUM             ;SCSI HD #7
;       MOV     AH,0A7H
;       CALL    MH_COMMON

        MOV     AL,INFSH
        MOV     SCSI_FLG,00H
        CALL    MK_SCSI_COMMON
;---------------------------------------------------------------------
        RET

MK_MOCOMMON:
        MOV     AL,BYTE PTR MO_LPFLG
MK_MOCOMMON_10:
        MOV     SCSI_FLG,01H
        CALL    MK_SCSI_COMMON
        RET

;----------------------------------------------- DOS5 91/08/00 -------
MK_MOCOMMON2:
        mov     al,byte ptr MO_LPFLG2
        jmp     MK_MOCOMMON_10
;---------------------------------------------------------------------

;************************************************
;                                               *
;       MAKE SCSI I/F DEVICE LPTABLE/EXLPTBL    *
;                                               *
; IN    al = device equip                       *
;       SCSI_FLG = 00h if hard disk             *
;                  01h if MO disk               *
;************************************************
MK_SCSI_COMMON:
        MOV     AH,0A0H
        MOV     SI,OFFSET HDS_NUM
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     BP,OFFSET HDDSKS_1
;---------------------------------------------------------------------
MKSCSI010:
;----------------------------------------------- DOS5 90/12/17 -------
        PUSH    BP
;---------------------------------------------------------------------
        CMP     AH,0A8H
        JZ      MKSCSIEXIT
        SHR     AL,1
        JNC     MKSCSI020
        PUSH    AX
        MOV     AL,[SI]
        CALL    MH_COMMON
        POP     AX
MKSCSI020:
        INC     AH
        INC     SI
;----------------------------------------------- DOS5 90/12/14 -------
        POP     BP
        ADD     BP,HDDSK_SIZE
;---------------------------------------------------------------------
        JMP     MKSCSI010
MKSCSIEXIT:
;----------------------------------------------- DOS5 90/12/17 -------
        POP     BP
;---------------------------------------------------------------------
        RET

;************************************************
;*                                              *
;*      HARD DISK MAKING COMMON                 *
;*                                              *
;* ENTRY        AL : NUMBER OF PARTITION        *
;*              AH : DA/UA                      *
;*              BX : POINTS EXLPTBL             *
;*              BP : POINTS HDDSKx_x            *
;*              SCSI_FLG : 01 IF MO             *
;*                                              *
;* EXIT         EXLPTBL SET                     *
;*                                              *
;************************************************

MH_COMMON:
        PUSH    CX
        OR      AL,AL
        JE      MH_COMMON20
        MOV     CL,AL
        XOR     CH,CH
MH_COMMON10:
;--------------------------------------------------------- 88/05/19 --
        CMP     HD_CNT,26                       ;MAX 26 DRIVE ?
        JAE     MH_COMMON15
        MOV     [BX],AH                         ;MAKE EXLPTBL
;--------------------------------------------------------- 89/08/19 --
        PUSH    AX
        MOV     AH,SCSI_FLG
;----------------------------------------------- DOS5 90/12/14 -------
        CMP     WORD PTR DS:[BP+8],0
        JNE     NOT_LARGE
        OR      AH,02                           ;SET LARGE PATITION BIT
NOT_LARGE:
;---------------------------------------------------------------------
        MOV     [BX-1],AH
        POP     AX
;---------------------------------------------------------------------
        ADD     BX,2
;----------------------------------------------- DOS5 90/12/17 -------
        ADD     BP,BPB_SIZE
;---------------------------------------------------------------------
        INC     HD_CNT                          ;DRIVE NUM ++
MH_COMMON15:
;---------------------------------------------------------------------
        LOOP    MH_COMMON10 
MH_COMMON20:
        POP     CX
        RET

;************************************************
;*                                              *
;*      HARD DISK INITIARIZE ROUTINE            *
;*                                              *
;************************************************               88/03/21

HARDINIT:
        RET

;************************************************870815NEW
;*                                              *
;*      HARD DISK SENSE                         *
;*                                              *
;*      INPUT : NONE                            *
;*      OUTPUT: CF=0:NORMAL                     *
;*               AH     HD CAPACITY             *
;*               BX     BYTES / SECTOR          *
;*               DH     TRACKS / CYLINDER       *
;*               DL     SECTORS / TRACK         *
;*              CF=1:ERROR                      *
;*                                              *
;************************************************
SENSE_HD:
        MOV     CX,5                    ;RETRY COUNT
SNSHD00:
        XOR     BX,BX
;       MOV     AX,8400H                ;SET SENSE COMMAND AND DA/UA
;       OR      AL,[UA]                 ;MAKE UA
        MOV     AH,84H                  ;SET SENSE COMMAND
        MOV     AL,DA                   ;SET DA/UA
        OR      AL,UA
        INT     1BH                     ;EXECUTE SENSE COMMAND
        JNC     SNSHD01                 ;SKIP IF SENSE GOOD 
        LOOP    SNSHD00
        STC                             ;SET CARRY
        RET

SNSHD01:
        OR      BX,BX                   ;BYTE/SEC = 0 (OLD BIOS) ?
        JNZ     SNSHD01?SKIP?N          ;NO,
        MOV     BX,256                  ;BYTES/SECTOR
        MOV     DL,33                   ;SECTORS/TRACK 
        MOV     DH,4                    ;IF CAPACITY >= 20(MB)
        CMP     AH,3                    ;   THEN TRACKS/CYLINDER = 8
        JB      SNSHD01?SKIP?N          ;   ELSE TRACKS/CYLINDER = 4
        MOV     DH,8                    ;
SNSHD01?SKIP?N:
        CLC
        RET

;************************************************
;*                                              *
;*      FIND SELF NUMBER                        *
;*                                              *
;************************************************
BOOT_ID EQU     0                       ;BOOT IDENTIFICATION 
SYS_ID  EQU     1                       ;SYSTEM IDENTIFICATION
IPL_ADR EQU     4                       ;ADDR OF IPL
LV_STA  EQU     8                       ;START ADDR OF LOGICAL VOLUME
LV_ENA  EQU     12                      ;END ADDR OF LOGICAL VOLUME

;************************************************
;*                                              *
;*      RECALIBLATE                             *
;*                                              *
;************************************************
RCBL:
        RET

        PAGE

;************************************************
;*                                              *
;*      SET DEFAULT ATTRIBUTE                   *
;*                                              *
;************************************************
DEFULT:
        MOV     AL,[MEM_SW3]            ;GET CONTENTS OF MEM_SW3
        AND     AL,40H                  ;ONLY 2**6 BIT
        JNZ     DEF30                   ;SKIP IF NOT 0
        MOV     [CURATTR],0E1H
        MOV     [DEFATTR],0E1H
        MOV     [ESCATRSAVE],0E1H
        MOV     [CURATTR2],00E1H
        MOV     [DEFATTR2],00E1H
        MOV     [ATRSAVE2],00E1H
DEF30:
        RET

;************************************************870826 NEW
;*                                              *
;*      SET H/W MODE & DEFAULT VALUE            *
;*                                              *
;************************************************
MODE_HIRESO = 00000001B
SETVAL  PROC
        TEST    [SYS_501],00001000B     ;CHECK H/W MODE
        JNZ     SETV_HIRESO             ;NZ IF HIRESO MODE

        AND     [REVISION],NOT MODE_HIRESO      ;HW-MODE FLAG
        MOV     [LINMOD],1                      ;DEFAULT LINE-MODE IS 25 (1)
        RET

SETV_HIRESO:
        OR      [REVISION],MODE_HIRESO  ;HW-MODE FLAG
        MOV     [LINMOD],0              ;DEFAULT LINE-MODE IS 25 (0)
        RET
SETVAL  ENDP

;************************************************
;*                                              *
;*      SET H/W MODE & DEFAULT VALUE (2)        *
;*                                              *
;************************************************
SETVAL2 PROC
        PUSH    DX
        PUSH    DS
        PUSH    ES
        MOV     DX,CS
        MOV     DS,DX
        MOV     ES,DX

        MOV     SI,OFFSET EXLPTBL       ;EX-LPTABLE OFFSET
        MOV     CX,26                   ;NUMBER OF ENTRY
        XOR     DL,DL
        CLD
STVAL2_LOOP:
        LODSW
        TEST    AX,0080H                ;LOGICAL EXTENT ?
        JZ      STVAL2_SKP              ;NO,
        MOV     DL,-1
STVAL2_SKP:
        LOOP    STVAL2_LOOP             ;NEXT
        MOV     [SNGDRV_FLG],DL         ;SET SINGLE DRIVE FLAG

;\\\\\\ TEST    [SYS_501],00001000B     ;H/W MODE ?
;\\\\\\ JNZ     STVAL2_NORM_SKP         ;HIRESO
        MOV     SI,OFFSET HD_OFFSET     ;COPY HD_OFFSET CONTENT
        MOV     DI,OFFSET COMP_HDOFST_N
        MOVSW                           ;COPY #0 INFO.
        MOVSW
        MOV     SI,OFFSET HD1_OFFSET
        MOVSW                           ;COPY #1 INFO.
        MOVSW

STVAL2_NORM_SKP:
        MOV     SI,OFFSET HDDSK5_1      ;COPY HD BPB#1
        MOV     DI,OFFSET COMP_HDDSK5_1
        MOV     CX,13
        REP     MOVSB
        MOV     SI,OFFSET HDDSK5_2      ;COPY HD BPB#2
        MOV     CX,13
        REP     MOVSB

        POP     ES
        POP     DS
        POP     DX
        RET
SETVAL2 ENDP

;************************************************
;*                                              *
;*      B4670 INITIALIZE PROCEDURE              *
;*                                              *
;************************************************
;       85/03/28
;
B4670_PRC:
IF BRANCH       ;-----------------------------------------------------
        XOR     AX,AX                   ;V (850517)
        PUSH    ES
        MOV     ES,AX                   ;ES POINTS ZERO-SEGMENT
        MOV     ES:WORD PTR [0078H*4],OFFSET B4670ENT
        MOV     ES:WORD PTR [0078H*4+2],CS

        TEST    MEM_SW4,10H             ;B4670 SUPPORT ?
        JE      B4670_ABORT0            ;SKIP IF NO
;
B4670_PRC10:
        MOV     ES:WORD PTR [00D3H*4],OFFSET INTD3_ENTRY
        MOV     ES:WORD PTR [00D3H*4+2],CS
;
;-----INTIALIZE OMNI-BIO
;
        MOV     AL,6
        MOV     DI,0080H
        INT     0D3H                    ;INITIALIZE IT
        CMP     AL,3FH                  ;CHECK CORRECT ZONE ?
        JA      B4670_ABORT0
        CMP     AL,00H                  ;SAME CHECK
        JAE     B4670_GOOD
B4670_ABORT0:
        MOV     ES:WORD PTR [0078H*4],OFFSET NOT_BSYS_ENT       ;85/05/19(I)
        MOV     ES:WORD PTR [0078H*4+2],CS                      ;85/05/19(I)
        POP     ES
        RET
;
;       BOARD IS GOOD !!
;
B4670_GOOD:
        MOV     ES:[OMNI_STATION],AL    ;SAVE SA
        MOV     DI,OFFSET SA_NO         ;85/05/18
        CALL    CUL_SA                  ;85/05/18
;---------------------------- 85/05/15 ---------;
        MOV     AL,[MEM_SW5+2]                  ;GET MEMORY SW(7) CONTENT
        TEST    AL,01000000B                    ;NODE SPECIFIED ?
        JNZ     B4670_SKP21                     ;Y
        XOR     AL,AL                           ;DEFAULT IS 00H
B4670_SKP21:                                    ;
        AND     AL,00111111B                    ;
        MOV     ES:BYTE PTR [OMNI_SERVER],AL    ;SAVE SERVER-SA
        MOV     DI,OFFSET SV_NO                 ;
        CALL    CUL_SA                          ;SET TO MESSAGE SATA
;-----------------------------------------------;
        MOV     VSYS_FLAG,01H
;
;       SAVE ROM-VECTOR IMAGE
;
;*******************************  86/11/12 B4670 BY QNES FOR X21 ************
        MOV     DI,OFFSET VEC_SAVE
        MOV     SI,00
        MOV     CX,03EH
        CLD
        PUSH    ES
        PUSH    DS
        PUSH    ES
        POP     DS
        PUSH    CS
        POP     ES
        REP     MOVSW
        POP     DS
        POP     ES
;*****************************************************************************
        MOV     AX,ES:WORD PTR [001BH*4]        ;SAVE 1B VECTOR
        MOV     WORD PTR ROM_INT1B,AX
        MOV     AX,ES:WORD PTR [001BH*4+2]
        MOV     WORD PTR ROM_INT1B+2,AX
        MOV     AX,ES:WORD PTR [001AH*4]        ;SAVE 1A VECTOR
        MOV     WORD PTR ROM_INT1A,AX
        MOV     AX,ES:WORD PTR [001AH*4+2]
        MOV     WORD PTR ROM_INT1A+2,AX
        MOV     AX,ES:WORD PTR [001FH*4]        ;SAVE 1F VECTOR
        MOV     WORD PTR [NXT_INT1F],AX
        MOV     AX,ES:WORD PTR [001FH*4+2]
        MOV     WORD PTR [NXT_INT1F+2],AX
;
;       SET NEW-VECTOR IMAGE
;
        MOV     ES:WORD PTR [001BH*4],OFFSET VDISK_BIO
        MOV     ES:WORD PTR [001BH*4+2],CS
        MOV     ES:WORD PTR [001AH*4],OFFSET PRT_BIO
        MOV     ES:WORD PTR [001AH*4+2],CS
        MOV     ES:WORD PTR [001FH*4],OFFSET B4670_INT1F
        MOV     ES:WORD PTR [001FH*4+2],CS

        MOV     INFVT,00001111B
        POP     ES
ENDIF   ;-------------------------------------------------------------
        RET

;
;       CONVERT HEX TO DECIMAL
;
CUL_SA:
IF BRANCH       ;-----------------------------------------------------
        CMP     AL,10
        JA      CULSA_SKP10
        OR      AL,30H
        MOV     CS:[DI+1],AL
        JMP     SHORT CULSA_SKP20
CULSA_SKP10:
        XOR     AH,AH
        MOV     CL,10
        DIV     CL
        OR      AX,3030H
        MOV     WORD PTR CS:[DI],AX
CULSA_SKP20:
ENDIF   ;-------------------------------------------------------------
        RET

;
;       INITIALIZE INTERNAL-FLAG FIELD
;                               & MAKE LPTABLE.
B4670_MK:
IF BRANCH       ;-----------------------------------------------------
        CMP     [VSYS_FLAG],1
        JNE     B4670_MK_RET
        MOV     DX,0                    ;SET COUNTER
B4670_IN:
        PUSH    DX                      ;SAVE UNIT#             850517
        CALL    SENS_DRV
        JC      B4670_IN10
        CALL    VS_MOUNT
B4670_IN10:
        POP     DX                      ;RESUME UNIT#           850517
        INC     DX
        CMP     DX,4
        JNE     B4670_IN
B4670_MK_RET:
ENDIF   ;-------------------------------------------------------------
        RET


;
;       MESSAGE (B4670)
;
B4670MSG:
IF BRANCH       ;-----------------------------------------------------
        TEST    [MEM_SW4],10H
        JZ      B4670MSG_DONE

        MOV     BX,OFFSET B4670_MSG_OK
        CMP     [VSYS_FLAG],0
        JE      B4670MSG_DONE
        CALL    MSGLOOP_FAR                     ;DISPLAY SIGN ON (B4670)
B4670MSG_DONE:
ENDIF   ;-------------------------------------------------------------
        RET

        ASSUME  DS:DATAGRP

        PAGE

;
;       SIGN ON MESSAGE
;

;--------------------------------------------------------MAMA------
;       INCLUDE SIGNON.INC              ;DELETE 871015
;--------------------------------------------------------MAMA------


IF BRANCH       ;-------------------------------------- 871002 -------
B4670_MSG_OK DB '@BRANCH4670 foCXT[oQǋ@\'
             DB 'gp\ł',CR,LF
             DB '  Xe[Vԍ '
SA_NO        DB '00'
             DB ' CT[oAhX '
SV_NO        DB '00'
             DB ' ł',CR,LF,0
ENDIF   ;-------------------------------------------------------------
;--------------------------------------------------------- 88/05/06 --
;
;       WORK BUFFERS
;
;HARD_WORK      DB      512 DUP(?)
;IPL_BUF        DB      512 DUP(?)
;---------------------------------------------------------------------
;------------------------------------------------ CUT 88/02/25 -----
;
;       STACK
;
;       DW      128 DUP(0CCCCH)
;STACKTOP       LABEL   WORD
;--------------------------------------------------------------------
IO_LAST LABEL   BYTE

INIT_CODE_END:

BIOS_DATA_INIT  ENDS

        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\extbios.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 EXTBIOS.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME:    EXTBIOS.ASM                             *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;
;       84/11/20  ABOUT HARD COPY
;       84/11/22  ABOUT CTRL-FKY SUPPORT
;       84/11/23  ABOUT CTRL-FKY FLAG
;       85/02/01  ABOUT RS232 BIO
;       85/02/04        "
;       85/02/08        "
;       85/02/22        "
;       85/03/28  RECOVER A BUG
;       85/04/07  ABOUT PRINT-OUT MODE
;       85/10/24  ABOUT RS-232C BUG (AT V2.11)
;       86/09/23
;       86/10/20  MAKE BIG STACK
;       86/11/19  FOR RS-232C
;
;       < 87/08 .. 87/10 -- H/N MODE MS-DOS 3.1 >
;                 NEW INT220 FUNC (#18,#19,#128)
;                 ADD SUB-FUNC    (#10,#12,#13,#14,#17)
;
;       < 88/03 .. 88/07  -- DOS 3.3 R.01 >
;                 NEW INT220 FUNC (#129)
;                 ADD SUB-FUNC    (??)
;                 (STOP) SCSI RETRACT SUPPORT
;
;       90/11,12  MS-DOS 5.0 
;
;       91/08/00  3.5" MO support
;

;********************************************************
;*                                                      *
;*      EXTERNAL SYMBOLS                                *
;*                                                      *
;********************************************************
;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_DATA       segment word public 'Bios_DATA'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   FKYTBL:NEAR,KBCODTBL:NEAR
        EXTRN   EXLPTBL:NEAR
        EXTRN   INF5H:BYTE,HDIO_FLG:BYTE
        EXTRN   WRAPMOD:BYTE

        EXTRN   BIOS_FLAG:BYTE,FKYSW:BYTE,CURATTR:BYTE
        EXTRN   CSRSW:BYTE,HEXMOD:BYTE,ESCCNT:BYTE
        EXTRN   SRMFLG:BYTE,KANJICNT:BYTE
        EXTRN   PR_KNJCNT:BYTE,SFTJISMOD:BYTE,MODMARK1:BYTE
        EXTRN   DEFATTR:BYTE,FKYPTR:WORD,FKY_BUFFER:BYTE
        EXTRN   FKYCNT:BYTE,PR_HEADER:DWORD

        EXTRN   CTRLFKY:BYTE
        EXTRN   CTRLCMD:BYTE
        EXTRN   PR_RATIO:BYTE

        EXTRN   CHRTBL:NEAR                                     ;87/8/25
        EXTRN   AUX_HEADER:WORD                                 ;87/8/25
        EXTRN   AUX1_HEADER:WORD                                ;88/05/06
        EXTRN   BUFSIZE:WORD                                    ;87/8/25

        EXTRN   MEM_SW1:BYTE,MEM_SW2:BYTE                       ;87/8/28
        EXTRN   SYS_501:BYTE                                    ;87/8/25

        EXTRN   LPTABLE:NEAR,EXLPTBL:NEAR                       ;870927
        EXTRN   SNGDRV_FLG:BYTE,EXTSW:BYTE,CURDRV:BYTE          ;870927
        EXTRN   HD_NUM:BYTE,N8FD:BYTE,N5FD:BYTE,N5HD:BYTE       ;870927
        EXTRN   HD_OFFSET:NEAR                                  ;870927
        EXTRN   VSYS_FLAG:BYTE,XPORT_FLAG:BYTE,KDRV_FLG:BYTE    ;870927
;------------------------------------------------------ 88/03/31 -----
        EXTRN   EXMM_SIZE:BYTE
        EXTRN   CH1MSW1:BYTE
        EXTRN   HDS_NUM:BYTE,NSHD:BYTE,HDS_OFFSET:WORD
;-------------------------------------------------------------- 880526
        EXTRN   INFSH:BYTE
;---------------------------------------------------------------------
        EXTRN   STOP_FLAG:BYTE,COPY_FLAG:BYTE
        EXTRN   COPYSTOP:BYTE
;-----------------------------------------------------  89/08/16  ---
        EXTRN   SCSI_EQUIP:NEAR,MO_DEVICE_TBL:NEAR,DRV_NUM:BYTE
        EXTRN   MO_DEV_LENGTH:WORD,CURATTR2:WORD,DEFATTR2:WORD
        EXTRN   MO_COUNT:BYTE
;       EXTRN   CLRRTN:NEAR
;--------------------------------------------------------------------
        EXTRN   ATTRF:WORD,CRTDOTF:WORD,BIOSF_3:BYTE

        EXTRN   EXT_SAVAX:WORD,EXT_SAVSS:WORD,EXT_SAVSP:WORD
        EXTRN   EXT_SAVDS:WORD,EXT_SAVDX:WORD,EXT_SAVBX:WORD
        EXTRN   EXT_STACK:NEAR
        EXTRN   STP_SAVAX:WORD,STP_SAVSS:WORD,STP_SAVSP:WORD
        EXTRN   STOP_STACK:NEAR

;----------------------------------------------- DOS5 91/08/00 -------
        EXTRN   Start_BDS:word, Lockcnt:byte, ERR_STATUS:byte
;---------------------------------------------------------------------
;----------------------------------------------- DOS5 91/09/00 -------
        EXTRN   IOSYS_REV:word, MINOR_REV:byte
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 92/07/08 -------
;<patch BIOS50-P08>
        extrn   patch05:near
;---------------------------------------------------------------------

Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   ESCADM:NEAR,ESCIND:NEAR,ESCRI:NEAR
        EXTRN   ESCVT_CUU:NEAR,ESCVT_CUD:NEAR,ESCVT_CUF:NEAR
        EXTRN   ESCVT_CUB:NEAR,ESCVT_ED:NEAR,ESCVT_EL:NEAR
        EXTRN   ESCVT_IL:NEAR,ESCVT_DL:NEAR,ESCKNJ:NEAR
        EXTRN   DSPFKY:NEAR,CRTOUT:NEAR
        EXTRN   DSPCSR:NEAR,FLUSH:NEAR

;       EXTRN   MO_DEVICE_TBL:NEAR
;       EXTRN   MO_DEV_LENGTH:WORD
        EXTRN   CLRRTN:NEAR
        EXTRN   BDATA_SEG:WORD

;----------------------------------------------- DOS5 91/08/00 -------
        EXTRN   LockMO:near, UnlockMO:near
;---------------------------------------------------------------------

Bios_Code       ends


Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        PUBLIC  EXTBIOS_CODE_START
        PUBLIC  EXTBIOS_CODE_END
        PUBLIC  EXTBIOS_END
        PUBLIC  EXTBIOS_CODE
        PUBLIC  STOP_CHK,COPY_INT_CODE,STOP_INT_CODE
        PUBLIC  STOP_CHK_FAR

;       PUBLIC  ATTRF,BIOSF_3                                   ;       89/08/21
        PUBLIC  CRTMDDOT
;       PUBLIC  CRTDOTF
        PUBLIC  CRTMD2AT,CRTMD1AT
        PUBLIC  CRTMD480,CRTMD400
        PUBLIC  CRTMDATR
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        public  EX_CRTMD, CRTMD_DEF
;---------------------------------------------------------------------

EXTBIOS_CODE_START:

RATIOAK         EQU     01H     ;RATIO OF ANK AND KANJI         ;87/8/25
KICODE          EQU     02H     ;KANJI IN CODE                  ;87/8/25
CRLFP           EQU     80H     ;CR/LF OUTPUT                   ;87/8/25
        

        PAGE
;****************************************************************
;*                                                              *
;*   EXTENDED FUNCTIONS                                         *
;*      INT 220                                                 *
;*      ENTRY: (CL) = FUNCTION NUMBER                           *
;*                                                              *
;****************************************************************
;
EXTBIOS_CODE:
        PUSH    DS
        PUSH    DS
        MOV     DS,cs:[bdata_seg]
        POP     [EXT_SAVDS]     ;SAVE DS
        MOV     [EXT_SAVAX],AX  ;SAVE AX
        MOV     [EXT_SAVSS],SS  ;SAVE SS
        MOV     [EXT_SAVSP],SP  ;SAVE SP
        MOV     [EXT_SAVDX],DX  ;SAVE DX                87/8/14
        MOV     [EXT_SAVBX],BX  ;SAVE BX                88/03/31
;--------------------------------------------------------- 91/01/20 --
;       MOV     AX,CS

        MOV     SS,CS:[BDATA_SEG]
;---------------------------------------------------------------------
        MOV     SP,OFFSET EXT_STACK     ;SET LOCAL STACK ADDR
        STI                             ;ENABLE INTERRUPT
        CLD                             ;
        PUSH    ES
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    SI
        PUSH    DI

        MOV     [BIOS_FLAG],1

;*** EXTENDED BIOS MAIN ***

        SUB     CL,09H                  ;                       89/08/16
        JB      EXT_BIOS_RET            ;CL<10 ... NOP
;------------------------------------------------------ DOS5 91/09/09 -
        cmp     cl,0dh          ;CHECK FUNCTION #
;-------
;       CMP     CL,0CH          ;CHECK FUNCTION #       89/08/16
;---------------------------------------------------------------------
        JB      EXT_B1                  ;                       87/8/14
;------------------------------------------------------ 88/03/31 -----
;       CMP     CL,76H                  ;80H - 0AH = 76H        87/8/14
;       MOV     CL,10                   ;                       87/8/15
;       JNE     EXT_BIOS_RET            ;                       87/8/14
;----------------------------------------
        CMP     CL,77H                  ;                       89/08/16
        JB      EXT_BIOS_RET            ;                       89/08/16
        CMP     CL,79H                  ;130 - 10 = 120(78H)    89/08/16
        JA      EXT_BIOS_RET            ;INVALID FUNC#
        SUB     CL,77H                  ;                       89/09/01
;------------------------------------------------------ DOS5 91/09/09 -
        add     cl,0dh
;-------
;       ADD     CL,0CH                  ;                       89/09/01
;---------------------------------------------------------------------
EXT_B1:                                 ;                       87/8/14
        XOR     CH,CH
        MOV     SI,CX
        SHL     SI,1
        ADD     SI,OFFSET EXT_RTNTBL
        CALL    WORD PTR CS:[SI]                ;CALL SUBROUTINE

;*** RETURN FROM EXTENDED BIOS ***

EXT_BIOS_RET:
        CALL    STOP_CHK                ;CHECK STOP/COPY INT
        POP     DI
        POP     SI
        POP     DX
        POP     CX
        POP     BX
        POP     ES
        CLI                             ;DISABLE INTERRUPT
        MOV     DS,cs:[bdata_seg]
        MOV     AX,[EXT_SAVAX]
        MOV     SS,[EXT_SAVSS]
        MOV     SP,[EXT_SAVSP]
        MOV     DX,[EXT_SAVDX]  ;                       87/8/14
        MOV     BX,[EXT_SAVBX]  ;                       88/03/31
        POP     DS
        IRET                            ;RETURN



EX_NOP:         ;NO OPERATION
        RET

        PAGE
;************************************************
;*                                              *
;*      FUNC #12                                *
;*      READ SOFTKEY TABLE                      *
;*                                              *
;*      INPUT:  (DS:DX) BUFFER ADDR.            *
;*              (AX)    FUNC.                   *
;*                0000      :ALL N-MODE KEY     *
;*                0001-000A :F01-F10          *
;*                000B-0014 :F01-F10 (+SHIFT) *
;*                0015-001F :CURSOR KEY         *
;*                0020-0024 :F11-F15          *
;*                0025-0029 :F11-F15 (+SHIFT) *
;*                002A-0033 :F01-F10 (+CTRL)  *
;*                0034-0038 :F11-F15 (+CTRL)  *
;*                0039      :CTRL-XFER          *
;*                003A      :CTRL-XFER/         *
;*                            F01-F10(+CTRL)  *
;*                003B-00FE :(RESERVED)         *
;*                00FF      :ALL H-MODE KEY     *
;*                0100      :ALL DATA KEY       *
;*                0101      :REMAIN DATA KEY    *
;*                0102-FFFF :(RESERVED)         *
;*                                              *
;*      OUTPUT: AX=0101 CALL ONLY               *
;*              (AX) DATA KEY BUFFER REMAIN     *
;*                                              *
;*      BREAK:  AX                              *
;*                                              *
;************************************************

EX_RFKY:
        CLD
        MOV     ES,[EXT_SAVDS]          ;DESTINATION SEG.
        MOV     DI,DX                   ;DESTINATION PTR
        MOV     AX,[EXT_SAVAX]          ;PARAM
        CMP     AX,00FFH                ;ALL KEY ?
        JA      EXRF_F0                 ;                       87/8/25
        JNZ     EXRF_FF                 ;                       87/8/25
        JMP     short EXRF_A0   

EXRF_F0:                                ;                       87/8/25
        CMP     AX,0101H                ;                       87/8/25
        JB      EXRF_100                ;                       87/8/25
        JE      EXRF_101                ;                       87/8/25
        RET
EXRF_100:                               ;                       87/8/25
        CALL    EXRF_F1                 ;                       87/8/25
        RET                             ;                       87/8/25
EXRF_101:                               ;                       87/8/25
        CALL    EXRF_S1                 ;                       87/8/25
        RET                             ;                       87/8/25

EXRF_FF:
        SUB     AX,1
        JNB     EXRF_C
EXRF_P0:
        MOV     SI,OFFSET FKYTBL+1
        MOV     DL,10
        MOV     AL,0
EXRF_P1:
        MOV     CX,15
        REP     MOVSB
        STOSB
        INC     SI
        DEC     DL
        JNZ     EXRF_P1
;
        ADD     SI,80                   ;SKIP F.11 - F.15
        MOV     DL,10
EXRF_P2:
        MOV     CX,15
        REP     MOVSB
        STOSB
        INC     SI
        DEC     DL
        JNZ     EXRF_P2
;
        ADD     SI,80                   ;SKIP SHIFT F.11 - SHIFT F.15
        MOV     DL,11
EXRF_P3:
        MOV     CX,5
        REP     MOVSB
        STOSB
        ADD     SI,3
        DEC     DL
        JNZ     EXRF_P3
        RET

EXRF_A0:
;READ ALL SOFTKEYS
        MOV     SI,OFFSET FKYTBL+1      ;SRCE PTR
        MOV     DL,30                   ;LOOP CNT 1
        MOV     AL,0
EXRF_A1:
        MOV     CX,15                   ;
        REP     MOVSB                   ;
        STOSB
        INC     SI
        DEC     DL
        JNZ     EXRF_A1
        MOV     DL,11                   ;LOOP CNT 1
EXRF_A2:
        MOV     CX,5
        REP     MOVSB
        STOSB
        ADD     SI,3
        DEC     DL
        JNZ     EXRF_A2
;
        MOV     SI,OFFSET CTRLFKY+1
        MOV     DL,15
EXRF_A3:                                ;CTRL-FKY (84/11/22)
        MOV     CX,15
        REP     MOVSB
        STOSB
        INC     SI
        DEC     DL
        JNZ     EXRF_A3
        RET
;
EXRF_C:
        CMP     AX,28H                  ;                       87/9/24
        JA      EXRF_SKIP
        push    ds
        push    cs
        pop     ds
        MOV     BX,OFFSET FC_TABLE
        XLAT    BX
        DEC     AX
        pop     ds
EXRF_SKIP:
        CMP     AX,38H                  ;ILLEGAL PARAM ?
        JNB     EXRF_C2                 ;Y
        CMP     AX,1EH                  ;FNC_KEY ?
        JNB     EXRF_CC                 ;NO, KEY CODE
;  FUNCTION KEY
        MOV     CL,4
        SHL     AX,CL
        MOV     SI,AX
        ADD     SI,OFFSET FKYTBL+1      ;SRCE PTR
        MOV     CX,15
        JMP     SHORT   EXRF_C1
;  KEY CODE
EXRF_CC:
        CMP     AX,29H                  ;
        JNB     EXRF_CT
        SUB     AX,1EH
        MOV     CL,3
        SHL     AX,CL
        MOV     SI,AX
        ADD     SI,OFFSET KBCODTBL+1
        MOV     CX,5
        JMP     SHORT   EXRF_C1
;  CTRL-FKY
EXRF_CT:
        SUB     AX,29H                  ;87/9/22
        MOV     CL,4
        SHL     AX,CL
        MOV     SI,AX
        ADD     SI,OFFSET CTRLFKY+1
        MOV     CX,15
EXRF_C1:
        REP     MOVSB
        MOV     AL,0
        STOSB
EXRF_C3:
        RET
        
;****   CTRL + XFER  INFO.  GET   87/9/22   ****
EXRF_C2:
        CMP     AX,41
        JB      EXRF_C3
        CMP     AX,57                   ;CASE (AX : 39H)
        JA      EXRF_C3                 ;      AX > 39H
        JZ      EXRF_CTA                ;      AX = 39H
EXRF_CT0:                               ;CTRL-FKY
        CMP     AX,50
        JNA     EXRF_CT1
        CMP     AX,56                   ;AX = 38H ?
        JNZ     EXRF_C3
        MOV     AX,40
EXRF_CT1:
        SUB     AX,41
        MOV     CL,4
        SHL     AX,CL
        MOV     SI,AX
        ADD     SI,OFFSET CTRLFKY+1
        MOV     CX,15
        JMP     SHORT   EXRF_C1

;****   CTRL + XFER & CTRL + f.x INFO. GET  ***
;****                              87/9/22  ***
EXRF_CTA:
        MOV     AX,56
        CALL    EXRF_CT0                ;CTRL + XFER INFO. GET
        MOV     CX,10
EXRF_CTA1:                              ;CTRL + f.x  INFO. GET
        PUSH    CX
        MOV     AX,51
        SUB     AX,CX
        CALL    EXRF_CT0
        POP     CX
        LOOP    EXRF_CTA1
        RET

;  ALL DATA         87/8/25

EXRF_F1:
        MOV     SI,OFFSET CHRTBL
        MOV     CX,514
        REP     MOVSB
        RET

;  BUFFER SIZE      87/8/25

EXRF_S1:
        MOV     BX,[BUFSIZE]
        MOV     AX,512
        SUB     AX,BX
        MOV     [EXT_SAVAX],AX
        RET

        PAGE
;************************************************
;*                                              *
;*      FUNC #13                                *
;*      SET SOFTKEY TABLE                       *
;*                                              *
;*      INPUT:  (DS:DX) BUFFER ADDR.            *
;*              (AX)    FUNC.                   *
;*                0000      :ALL N-MODE KEY     *
;*                0001-000A :F01-F10          *
;*                000B-0014 :F01-F10 (+SHIFT) *
;*                0015-001F :CURSOR KEY         *
;*                0020-0024 :F11-F15          *
;*                0025-0029 :F11-F15 (+SHIFT) *
;*                002A-0033 :F01-F10 (+CTRL)  *
;*                0034-0038 :F11-F15 (+CTRL)  *
;*                0039      :CTRL-XFER          *
;*                003A      :CTRL-XFER/         *
;*                            F01-F10(+CTRL)  *
;*                003B-00FE :(RESERVED)         *
;*                00FF      :ALL H-MODE KEY     *
;*                0100      :ALL DATA KEY       *
;*                0101      :ONE DATA KEY       *
;*                0102      :CLEAR DATA KEY ALL *
;*                0103-FFFF :(RESERVED)         *
;*                                              *
;*      OUTPUT: AX=0101 CALL ONLY               *
;*              (AX) 0000   :SUCCESS            *
;*                   FFFF   :ERROR(OVERFLOW)    *
;*                                              *
;*      BREAK:  AX                              *
;*                                              *
;************************************************

EX_SFKY:
        MOV     ES,cs:[bdata_seg]               ;SET OUR SEG (DEST)
        CLD
        MOV     AX,[EXT_SAVAX]          ;PARAM
        MOV     DS,[EXT_SAVDS]          ;SRCE SEG.
        MOV     SI,DX                   ;SRCE PTR
        CMP     AX,0FFH
        JA      EXSF_F0                 ;                       87/8/25
        JNZ     EXSF_FF                 ;                       87/8/25
        JMP     short EXSF_A0                   
EXSF_F0:                                ;                       87/8/25
        CMP     AX,0101H                ;                       87/8/25
        JB      EXSF_100                ;                       87/8/25
        JE      EXSF_101                ;                       87/8/25
        CMP     AX,0102H                ;                       87/09/10
        JE      EXSF_102                ;                       87/09/10
        RET
EXSF_100:                               ;                       87/8/25
        CALL    EXSF_F1                 ;SET ENTIRE TABLE       87/8/25
        RET                             ;                       87/8/25
EXSF_101:                               ;                       87/8/25
        CALL    EXSF_S1                 ;SET 1 ENTRY            87/8/25
        RET                             ;                       87/8/25
EXSF_102:                               ;                       87/09/10
        CALL    EXSF_D1                 ;DELETE ALL DATA-KEY    87/09/10
        RET                             ;                       87/09/10

EXSF_FF:
        SUB     AX,1
        JNB     EXSF_C
EXSF_P0:
        MOV     DI,OFFSET FKYTBL
        MOV     DL,10
EXSF_P1:
        MOV     CX,15
        CALL    EXS_CNTCHK
        REP     MOVSB
        INC     SI
        DEC     DL
        JNZ     EXSF_P1
;
        ADD     DI,80                   ;SKIP   F.11 - F.15
        MOV     DL,10
EXSF_P2:
        MOV     CX,15
        CALL    EXS_CNTCHK
        REP     MOVSB
        INC     SI
        DEC     DL
        JNZ     EXSF_P2
;
        ADD     DI,80                   ;SKIP SHIFT F.11 - SHIFT F.15
        MOV     DL,11
EXSF_P3:
        MOV     CX,5
        CALL    EXS_CNTCHK
        REP     MOVSB
        INC     SI
        ADD     DI,2
        DEC     DL
        JNZ     EXSF_P3
        JMP     short EXSF_A4
EXSF_A0:
;SET ALL SOFT KEYS
        MOV     DI,OFFSET FKYTBL
        MOV     DL,30                   ;LOOP CNT 1
EXSF_A1:
        MOV     CX,15
        CALL    EXS_CNTCHK
        REP     MOVSB
        INC     SI
        DEC     DL
        JNZ     EXSF_A1
        MOV     DL,11                   ;LOOP CNT 1
EXSF_A2:
        MOV     CX,5
        CALL    EXS_CNTCHK
        REP     MOVSB
        INC     SI
        ADD     DI,2
        DEC     DL
        JNZ     EXSF_A2
        MOV     DI,OFFSET CTRLFKY
        MOV     DL,15
EXSF_A3:
        MOV     CX,15
        CALL    EXS_CNTCHK
        REP     MOVSB
        INC     SI
        DEC     DL
        JNZ     EXSF_A3
EXSF_A4:
        CMP     es:[FKYSW],0
        JE      EXSF_C2
        JMP     SHORT   EXSF_C2
;
EXSF_C:
        CMP     AX,28H
        JA      EXSF_SKIP
        PUSH    DS
        PUSH    CS
        POP     DS
        MOV     BX,OFFSET FC_TABLE
        XLAT    BX
        DEC     AX
        POP     DS
EXSF_SKIP:
        CMP     AX,38H                  ;ILLEGAL PARAM ?
        JNB     EXSF_C2                 ;Y
        CMP     AX,1EH                  ;FNC KEY ?
        JNB     EXSF_CC
;  FUNCTION KEY
        MOV     CL,4
        SHL     AX,CL
        MOV     DI,AX
        ADD     DI,OFFSET FKYTBL
        MOV     CX,15
        JMP     SHORT   EXSF_C1
;  KEY CODE
EXSF_CC:
        CMP     AX,29H                  ;87/9/22
        JNB     EXSF_CT
        SUB     AX,1EH
        MOV     CL,3
        SHL     AX,CL
        MOV     DI,AX
        ADD     DI,OFFSET KBCODTBL
        MOV     CX,5
        JMP     SHORT   EXSF_C1
EXSF_CT:
        SUB     AX,29H                  ;87/9/22
        MOV     CL,4
        SHL     AX,CL
        MOV     DI,AX
        ADD     DI,OFFSET CTRLFKY
        MOV     CX,15
EXSF_C1:
        CALL    EXS_CNTCHK
        REP     MOVSB
EXSF_C3:
        MOV     DS,CS:[BDATA_SEG]
        CALL    DSPFKY                  ;DISPLAY SOFTKEY
        RET
        
;****   CTRL + XFER  INFO.  SET   87/9/22   ****
EXSF_C2:
        CMP     AX,41
        JB      EXSF_C3
        CMP     AX,57                   ;CASE (AX : 39H) 
        JA      EXSF_C3                 ;      AX > 39H
        JZ      EXSF_CTA                ;       AX = 39H
EXSF_CT0:
        CMP     AX,50
        JNA     EXSF_CT1
        CMP     AX,56                   ;AX = 38H ?
        JNZ     EXSF_C3
        MOV     AX,40
EXSF_CT1:
        SUB     AX,41
        MOV     CL,4
        SHL     AX,CL
        MOV     DI,AX
        ADD     DI,OFFSET CTRLFKY
        MOV     CX,15
        JMP     SHORT   EXSF_C1

;****   CTRL + XFER & CTRL + f.x INFO. SET  ***
;****                              87/9/22  ***
EXSF_CTA:
        MOV     AX,56
        PUSH    DS
        PUSH    SI
        PUSH    DI
        CALL    EXSF_CT0                        ;CTRL + XFER INFO. SET
        POP     DI
        POP     SI
        POP     DS
        ADD     SI,16
        ADD     DI,16
        MOV     CX,10
EXSF_CTA1:                              ;CTRL + f.x INFO. SET
        PUSH    CX
        PUSH    DS
        PUSH    SI
        PUSH    DI
        MOV     AX,51
        SUB     AX,CX
        CALL    EXSF_CT0
        POP     DI
        POP     SI
        ADD     DI,16
        ADD     SI,16
        POP     DS
        POP     CX
        LOOP    EXSF_CTA1
        RET

;  ALL ENTRY SET (512 BYTE)  87/8/25

EXSF_F1:
        MOV     DI,OFFSET CHRTBL+2
        ADD     SI,2
        XOR     BX,BX                   ;                       880520
        XOR     AX,AX                   ;                       880520
        MOV     CX,0512
        REP     MOVSB
        MOV     DI,OFFSET CHRTBL+2
        MOV     CX,DI                   ;               87/9/14
        ADD     CX,512                  ;               87/9/14

EXSF_F2:
        CMP     DI,CX                   ;               87/9/15
        JAE     EXSF_F3                 ;               87/9/14
        CMP     BYTE PTR ES:[DI],00H
        JE      EXSF_F3
        MOV     AL,ES:[DI]
        ADD     DI,AX                   ;BUFFER SIZE
        INC     BX                      ;ENTRY COUNTER
        JMP     EXSF_F2

EXSF_F3:
        SUB     DI,OFFSET CHRTBL+2
        MOV     ES:[BUFSIZE],DI
        MOV     DI,OFFSET CHRTBL
        MOV     ES:[DI],BX
        
;  NULL PADDING

        CMP     ES:[BUFSIZE],512        ;               87/9/14
        JAE     EXSF_F4                 ;               87/9/14
        MOV     CX,512
        SUB     CX,ES:[BUFSIZE]
        ADD     DI,2
        ADD     DI,ES:[BUFSIZE]
        MOV     AL,00H
        REP     STOSB

EXSF_F4:                                ;               87/9/14
        RET

;  1 ENTRY SET      87/8/25

EXSF_S1:
        MOV     DI,OFFSET CHRTBL+2      ;                       880520
;;;;    ADD     DI,ES:[BUFSIZE]                 ;COMMENT ------ 880520
;;;;    ADD     DI,2                            ;COMMENT ------ 880520
;;;;    ADD     SI,2                            ;COMMENT ------ 880504
        CMP     BYTE PTR DS:[SI],3      ;CHECK ENTRY SIZE       880520
        JAE     EXSF_S11                ;VALID SIZE             880520
        XOR     AX,AX                   ;                       880520
        JMP     EXSF_S3
        
EXSF_S11:
;-------------------------------------------------------------- 880520
        MOV     AX,[SI+1]               ;AX := KEY CODE
        MOV     CX,ES:WORD PTR [CHRTBL] ;CX := # OF ENTRIES
        JCXZ    EXSF_S1_ADD             ;NO OLD ENTRY
        XOR     BX,BX
EXSF_S1_LOOP:
        CMP     AX,ES:[DI+1]            ;SAME CODE ?
        JE      EXSF_S1_FND             ;FOUND SAME CODE
        MOV     BL,ES:[DI]
        ADD     DI,BX                   ;NEXT ENTRY
        LOOP    EXSF_S1_LOOP
        JMP     short EXSF_S1_ADD       ;NOT FOUND, ADD ENTRY
EXSF_S1_FND:
        PUSH    SI
        MOV     SI,DI
        MOV     BL,ES:[DI]              ;ENTRY SIZE
        DEC     ES:WORD PTR [CHRTBL]    ;DECREMENT ENTRY COUNT
        SUB     ES:[BUFSIZE],BX         ;MINUS OLD ENTRY SIZE
        ADD     SI,BX                   ;POINT TO NEXT ENTRY
        MOV     BX,SI
        MOV     CX,OFFSET CHRTBL+2+512
        SUB     CX,BX                   ;SHIFT LENGTH
        CLD
;----------------------------------------------- DOS5 91/06/06 ------
        PUSH    DS
        PUSH    ES
        POP     DS                      ;DS <- BIOSDATA Seg
;--------------------------------------------------------------------
        REP     MOVSB                   ;DELETE OLD ENTRY
;----------------------------------------------- DOS5 91/06/06 ------
        POP     DS                      ;DS <- User Buffer Seg
;--------------------------------------------------------------------
        POP     SI
        CMP     BYTE PTR DS:[SI],3      ;CHECK NEW ENTRY SIZE
        JA      EXSF_S1_ADD             ;ADD ENTRY
        XOR     AX,AX                   ;DELETE ONLY (SIZE = 3)
        JMP     short EXSF_S3           ;RETURN
EXSF_S1_ADD:
        MOV     DI,OFFSET CHRTBL+2      ;                       880520
        ADD     DI,ES:[BUFSIZE]         ;POINT LAST ENTRY       880520
;---------------------------------------------------------------------
        XOR     AX,AX                   ;                       880520
        MOV     AL,DS:[SI]
        ADD     AX,ES:[BUFSIZE]
        CMP     AX,512
        JNA     EXSF_S2
        MOV     AX,-1                   ;ERROR (BUFFER OVER)
        JMP     short EXSF_S3

EXSF_S2:
        PUSH    DI
        MOV     DI,OFFSET CHRTBL
;;;;    MOV     BX,0001H                ;       COMMENT ------- 880520
        ADD     ES:WORD PTR [DI],1      ;ENTRY COUNT 1UP        880520
        MOV     ES:[BUFSIZE],AX         ;SET NEW VALUE
        XOR     CX,CX                   ;                       880520
        MOV     CL,DS:[SI]
        POP     DI
        REP     MOVSB                   ;COPY NEW ENTRY

;  NULL PADDING

        XOR     AX,AX                   ;                       880520
        CMP     ES:[BUFSIZE],512        ;               87/9/14
        JE      EXSF_S3                 ;               87/9/14
        MOV     CX,512
        SUB     CX,ES:[BUFSIZE]
        MOV     AL,00H
        REP     STOSB                   ;CLEAR REMAIN OF BUFF
EXSF_S3:
        MOV     ES:[EXT_SAVAX],AX
        RET

;       DELETE ALL DATA-KEY ASSIGN              1987.09.10 BY ITO

EXSF_D1:
        MOV     WORD PTR ES:[CHRTBL],0  ;CLEAR EXTRY_COUNT FIELD
        MOV     ES:[BUFSIZE],0          ;CLEAR BUFFER SIZE FIELD
        RET

;
;*** SUBROUTINE ***
;
EXS_CNTCHK:
        MOV     BX,SI                   ;TABLE ADDR
        MOV     AL,0                    ;DATA COUNTER
EXS_CNT1:
        CMP     BYTE PTR[BX],00H
        JE      EXS_CNTRET
        CMP     AL,CL
        JNB     EXS_CNTRET
        INC     AL
        INC     BX
        JMP     SHORT   EXS_CNT1
EXS_CNTRET:
        STOSB
        RET

        PAGE
;************************************************
;*                                              *
;*      FUNC #10                                *
;*      INITIALIZE THE RS232C PORT              *
;*                                              *
;*      INPUT(HIRESO):                          *
;*              (DH) INITIALIZE INFO.           *
;*              (DL B7-B4) CHANNEL NO.          *
;*              (DL B3-B0) TRANSFER RATE        *
;*      INPUT(NORMAL):                          *
;*              (0060:0068-0069)                *
;*                   INITIALIZE INFO.           *
;*                                              *
;*      OUTPUT(HIRESO):                         *
;*              (AX) 0000 SUCCESS               *
;*                   FFFF ERROR (NO BOARD)      *
;*      OUTPUT(NORMAL):                         *
;*              NONE                            *
;*                                              *
;************************************************

EX_RSINIT:
        CMP     DS:WORD PTR [AUX_HEADER+2],0    ;CHECK DRIVER INSTALLED ?
        JNE     EX_RSINIT05             ;OK
        RET

;*******87/08/28********
EX_RSINIT05:
        TEST    [SYS_501],08H           ;HIRESO MODE?
        JNZ     EX_RSINIT06             ;YES,
        MOV     AH,0
        INT     19H

        MOV     CX,0                    ;RETURN DATA CHECK
        CMP     AH,00H                  ;AH NOT = 00H -- ERROR
        JE      EX_RSINIT051
        MOV     CX,-1
EX_RSINIT051:
        MOV     [EXT_SAVAX],CX
        RET
        
EX_RSINIT06:
;------------------------------- 870830 BY ITO -------------------
        TEST    AH,11110000B            ;CH#0 ?
        JNZ     EX_RSI06_NOT_C0         ;NO,
        MOV     [MEM_SW1],DH            ;SET MEM SW1
        PUSH    DX                      ;               87/9/10
        AND     DL,0FH                  ;               87/9/10
        AND     [MEM_SW2],0F0H          ;               87/9/10
        OR      [MEM_SW2],DL            ;SET MEM SW2    87/9/10
        POP     DX                      ;               87/9/10
;------------------------------------------------------ 88/05/06 -
        JMP     short EX_RSINIT07       ;
EX_RSI06_NOT_C0:
        CMP     AH,20H                  ;CHECK CHANNEL NUMBER
        JA      EX_RSINIT061            ;CHANNEL OK
        CMP     DS:WORD PTR [AUX1_HEADER+2],0   ;DRIVER INSTALLED ?
        JNE     EX_RSINIT07                     ;YES,
EX_RSINIT061:
        RET

EX_RSINIT07:
;-----------------------------------------------------------------
        XOR     BH,BH                   ;
        MOV     AH,DL
        AND     AH,30H
        MOV     BL,AH
        MOV     CL,03H                  ;
        SHR     BL,CL                   ;
        MOV     BH,00H                  ;
        MOV     ES,DS:[AUX_HEADER+2]    ;SET RS-232C DRIVER SEGMENT ADDRESS
        MOV     DI,ES:[BX+40H]          ;SET BUFFER OFFSET ADDRESS
        OR      AH,07H                  ;SET COMMAND (INITIALIZE_EX)
        MOV     BX,0                    ;85/02/08
        TEST    DH,01
        JZ      EX_RSINIT10
        OR      BH,30H                  ;SET XON/OFF ENABLE BIT
EX_RSINIT10:
        MOV     AL,DL
        AND     AL,0FH
        INC     AL
        AND     DH,0FEH                 ;SET X16
        OR      DH,02H                  ;
        TEST    AH,30H                  ;
        JNZ     EX_RSINIT20             ;
        TEST    AL,08H                  ;
        JNZ     EX_RSINIT20             ;
        OR      DH,001H                 ;IF >=4800BPS X16
EX_RSINIT20:
        MOV     CH,DH                   ;SET MODE
        MOV     CL,37H                  ;SET COMMAND FOR 8251
        DEC     AL
        DEC     AL
        TEST    CH,04H
        JNZ     EX_RSINIT30
        OR      BH,40H                  ;SET SI/SO ENABLE
EX_RSINIT30:
        PUSH    DS
        PUSH    BX
        MOV     BX,0F800H
        MOV     DS,BX
        CMP     WORD PTR DS:[7FFCH],00H
        POP     BX
        POP     DS
        MOV     DX,256                  ;
        JNZ     POINT_11                ;
        INC     DX                      ;
POINT_11:                               ;
        PUSH    AX                      ;SAVE CH NO.
        INT     19H
        OR      AH,AH
        POP     AX                      ;
        JZ      EX_RSINIT50             ;
EX_RSINIT40:
        MOV     [EXT_SAVAX],-1
        RET

EX_RSINIT50:
        MOV     [EXT_SAVAX],0
;
;=====  SET VECT ADDRESS ================       ;DELETE THIS CODE
;                                               ;88/05/06
        RET

        PAGE
;************************************************
;*                                              *
;*      FUNC #14                                *
;*      RS232C FUNCTION                         *
;*                                              *
;*      INPUT:  (DL B7-B4) CHANNEL NO.          *
;*              (DL B3-B0) COMMAND              *
;*                0000  GET DATA LENGTH         *
;*                0001  INITIALIZE              *
;*                      (BX) INITIALIZE INFO.   *
;*                0110  <<NEW>>DOS3.3           *
;*                      GET INITIALIZE PARA.    *
;*                0111  <<NEW>>DOS3.3           *
;*                      INSTALL CHECK           *
;*                                              *
;*      OUTPUT:                                 *
;*              COMMAND=0000:                   *
;*               (AX) DATA LENGTH               *
;*              COMMAND=0001:                   *
;*               (AX) 0000 SUCCESS              *
;*                    FFFF ERROR ( NO BOARD )   *
;*              COMMAND=0110:                   *
;*               (BX) INITIALIZE PARA.          *
;*              COMMAND=0111:                   *
;*               (AX) 0000 BOARD INSTALLED      *
;*                    FFFF NOT                  *
;*                                              *
;************************************************

EX_RSFNC:
;-------------------------------------------------------- 88/05/06 ---
;       CMP     CS:WORD PTR [AUX_HEADER+2],0    ;CHECK DRIVER INSTALLED
;       JNE     EX_RSFNC_10             ;OK
;       RET
;---------------------------------------------------------------------
;*******87/09/10********
EX_RSFNC_10:
        XOR     CX,CX
        MOV     AH,DL
        AND     AH,0F0H                 ;CHANNEL NUMBER ONLY
;-------------------------------------------------------- 88/05/06 ---
;       CMP     AH,20H                  ;CH NO. CHECK 
;       JNA     EX_RSFNC_100
;       RET
;----------------
        MOV     SI,OFFSET AUX_HEADER+2  ;DRIVER ADDRESS FOR CH#0
        CMP     AH,00H                  ;CH #0 ?
        JE      EX_RSFNC_100            ;YES
        MOV     SI,OFFSET AUX1_HEADER+2 ;DRIVER ADDRESS FOR CH#1 & 2
        CMP     AH,20H                  ;CH#1 OR 2 ?
        JA      EX_RSFNC_104            ;NO, ERROR RETURN
        CMP     DS:WORD PTR [SI],0      ;INSTALL CHECK          89/07/28
        JNZ     EX_RSFNC_100            ;NOT INSTALL, ERROR RETURN 89/07/28
        JMP     EX_RSFNC_1052_1         ;                       89/07/28
;---------------------------------------------------------------------
EX_RSFNC_100:
;------------------------------------------------------ 88/03/31 -----
        MOV     AH,DL
        AND     AH,0FH                  ;COMMAND ONLY
        CMP     AH,00H                  ;COMMAND = 0 
        JNE     EX_RSFNC_101            ;NO,
        JMP     short EX_RSFNC_DATA     ;  DATA LENGTH GET
EX_RSFNC_101:
        CMP     AH,01H                  ;COMMAND = 1
        JNE     EX_RSFNC_102            ;NO,
        JMP     short EX_RSFNC_INIT     ;  INITIALIZE
EX_RSFNC_102:
        CMP     AH,06H                  ;COMMAND = 6
        JNE     EX_RSFNC_103            ;NO,
        JMP     EX_RSFNC_GETP           ;  GET INITIALIZE PARA.
EX_RSFNC_103:
        CMP     AH,07H                  ;COMMAND = 7
        JNE     EX_RSFNC_104            ;NO,
        JMP     EX_RSFNC_INST           ;  INSTALL CHECK
EX_RSFNC_104:
        RET                             ;NO OPERATION RETURN
;---------------------------------------------------------------------

;****************************************
;*                                      *
;*      GET DATA LENGTH                 *
;*                                      *
;****************************************
EX_RSFNC_DATA:
        MOV     AH,DL
        AND     AH,0F0H
        TEST    [SYS_501],08H           ;H / N MODE ?
        JZ      EXRSF_GETN              ;N MODE
        
;  HIRESO MODE
EXRSF_GETH:
        OR      AH,02H                  ;H MODE : DATA LENGTH GET
        INT     19H
        JMP     short EX_RSFNCSET
        
;  NORMAL MODE
EXRSF_GETN:
        CMP     AH,00H                  ;CH#0
        JNE     EXRSF_GN10
        MOV     AH,04H
        INT     19H                     ;CALL BIOS
        JMP     short EX_RSFNCSET       ;                       88/07/28 D

EXRSF_GN10:
        CMP     AH,10H                  ;CH#1
        JNE     EXRSF_GN20
        MOV     AH,04H
        INT     0D4H                    ;CALL (EX) BIOS
        JMP     short EX_RSFNCSET       ;                       88/07/28 D

EXRSF_GN20:
        MOV     AH,04H                  ;CH#2
        INT     0D5H                    ;CALL (EX) BIOS
EX_RSFNCSET:
        MOV     [EXT_SAVAX],CX  ;DATA LENGTH SET
        RET                             ;                       88/03/31
;       JMP     EX_RSFNCRET             ;                       88/03/31 D

;****************************************
;*                                      *
;*      INITIALIZE THE RS_232C          *
;*                                      *
;****************************************
EX_RSFNC_INIT:
        MOV     AH,DL
        AND     AH,0F0H                 ;CH# ONLY

        AND     DL,0F0H                 ;               87/9/4
        AND     BL,0FH                  ;               87/9/4
        OR      DL,BL                   ;               87/9/4
        MOV     DH,BH                   ;               87/9/4
;------------------------------------------------------ 88/03/31 -----
        CMP     AH,00H
        JNE     EXRSF0E_00
        MOV     [MEM_SW1],DH            ;SET MEM SW1 
        PUSH    DX
        AND     DL,0FH
        AND     [MEM_SW2],0F0H
        OR      [MEM_SW2],DL            ;SET MEM SW2
        POP     DX
        JMP     short EXRSF0E_INIT
EXRSF0E_00:
        PUSH    BX
        MOV     DI,OFFSET CH1MSW1       ;PARAM AREA ADDRESS
        XOR     BX,BX
        MOV     BL,AH                   ;CHANNEL NUMBER
        MOV     CL,4
        SHR     BX,CL
        DEC     BX
        SHL     BX,1                    ;WORD OFFSET
        PUSH    DX
        AND     DL,0FH
        MOV     [BX+DI],DH              ;SET INIT INFO -1
        MOV     [BX+DI+1],DL            ;SET INIT INFO -2
        POP     DX
        POP     BX
EXRSF0E_INIT:
;---------------------------------------------------------------------
        TEST    [SYS_501],08H           ;H / N MODE ?
        JNZ     EX_RSFNC_11             ;H MODE

;  NORMAL MODE
        CMP     AH,00H                  ;CH#0
        JNE     EX_RSFNC_105
;------------------------------------------------------ 88/03/31 -----
;       MOV     [MEM_SW1],DH            ;SET MEM SW1 
;       PUSH    DX
;       AND     DL,0FH
;       AND     [MEM_SW2],0F0H
;       OR      [MEM_SW2],DL            ;SET MEM SW2
;       POP     DX
;       JMP     EX_RSFNC_11
;----------------------------------------
        MOV     AH,00H
        INT     19H                     ;CALL BIOS (INITIALIZE)
        JMP     short EX_RSFNC_1052     ;CHECK RESULT
;---------------------------------------------------------------------

EX_RSFNC_105:
        MOV     CH,BH
        CMP     AH,10H                  ;CH#1
        JNE     EX_RSFNC_1051
        MOV     AH,00H
        INT     0D4H
        JMP     short EX_RSFNC_1052

EX_RSFNC_1051:
        MOV     AH,00                   ;CH#2
        INT     0D5H
EX_RSFNC_1052:
        MOV     CX,0                    ;RETURN DATA CHECK
        CMP     AH,00H                  ;AH NOT = 00H -- ERROR
        JE      EX_RSFNC_1053
EX_RSFNC_1052_1:                        ;                       89/07/28
        MOV     CX,-1
EX_RSFNC_1053:
        MOV     [EXT_SAVAX],CX
        RET
;       JMP     EX_RSFNCRET             ;               88/05/06

;  HIRESO MODE
EX_RSFNC_11:
        CALL    EX_RSINIT
EX_RSFNCRET:
        RET
;*******87/09/10********
;------------------------------------------------------ 88/03/31 -----
;****************************************
;*                                      *
;*      GET INITIALIZE INFO.            *
;*                                      *
;****************************************
EX_RSFNC_GETP:
        MOV     AH,DL                   ;CHANNEL NUMBER
        AND     AH,0F0H
        CMP     AH,00H                  ;CH#0 ?
        JNE     EXRSF0E06_0             ;NO,
        MOV     AH,[MEM_SW1]            ;GET MEM SW1 
        MOV     AL,[MEM_SW2]            ;GET MEM SW2
        AND     AL,0FH                  ;BAUD RATE ONLY
        JMP     short EXRSF0E06_DONE
EXRSF0E06_0:
        MOV     DI,OFFSET CH1MSW1       ;PARAM AREA ADDRESS
        XOR     BX,BX
        MOV     BL,AH                   ;CHANNEL NUMBER
        MOV     CL,4
        SHR     BX,CL
        DEC     BX
        SHL     BX,1                    ;WORD OFFSET
        MOV     AH,[BX+DI]              ;GET INIT INFO -1
        MOV     AL,[BX+DI+1]            ;GET INIT INFO -2
EXRSF0E06_DONE:
        MOV     [EXT_SAVBX],AX          ;SET TO (BX) REG.
        RET

;****************************************
;*                                      *
;*      BOARD INSTALL CHECK             *
;*                                      *
;****************************************

EX_RSFNC_INST:
        IN      AL,0B3H                 ;READ BOARD STATUS
        CMP     AL,-1
        MOV     AX,0000H                ;INSTALLED
        JNE     EXRSF0E07_DONE
        NOT     AX                      ;NOT INSTALLED
EXRSF0E07_DONE:
        MOV     [EXT_SAVAX],AX          ;SET RESULT
        RET
;---------------------------------------------------------------------
        PAGE
;************************************************
;*                                              *
;*      FUNC #15                                *
;*      SET/RESET 3270SE/ETOS52G MODE           *
;*                                              *
;*      INPUT:                                  *
;*                                              *
;*      OUTPUT:                                 *
;*                                              *
;************************************************

EX_CTRLFLG:
        MOV     AX,[EXT_SAVAX]
        OR      AX,AX
        JS      EX_GET_FLAG             ;JUMP IF AX >= 8000h    88/03/31
        JZ      EX_SET_FLAG
        DEC     AX
        JZ      EX_RESET_FLAG
        DEC     AX
        JZ      EX_SET_FLAG2
        DEC     AX
        JZ      EX_RESET_FLAG2
        RET                             ;               88/05/06
;       JMP     EX_CTRLDONE             ;               88/05/06
EX_SET_FLAG:
        OR      [CTRLCMD],01H           ;               88/03/31
        RET                             ;               88/05/06
;       JMP     EX_CTRLDONE             ;               88/05/06
EX_SET_FLAG2:
        OR      [CTRLCMD],02H           ;               88/03/31
        RET                             ;               88/05/06
;       JMP     EX_CTRLDONE             ;               88/05/06
EX_RESET_FLAG:
        AND     [CTRLCMD],0FEH          ;               88/03/31
        RET                             ;               88/05/06
;       JMP     EX_CTRLDONE             ;               88/05/06
EX_RESET_FLAG2:
        AND     [CTRLCMD],0FDH          ;               88/03/31
EX_CTRLDONE:
        RET
;------------------------------------------------------ 88/03/31 -----
EX_GET_FLAG:
        MOV     CL,[CTRLCMD]            ;GET FLAGS
        NOT     CX                      ;REVERSE FLAGS
        AND     AX,NOT 8000H            ;STRIP SIGN BIT
        JNZ     EX_GET_FLAG2
        AND     CX,0001H                ;CX=0 CTRL-FX IF SOFT KEY
        JMP     short EX_GET_FLAGD      ;CX=1 NOT (SYSTEM KEY)
EX_GET_FLAG2:
        SUB     AX,2
        JNZ     EX_CTRLDONE             ;INVALID PARAM
        AND     CX,0002H                ;CX=0 CTRL-XFER IF SOFT KEY
        SHR     CX,1                    ;CX=1 NOT (SYSTEM KEY)
EX_GET_FLAGD:
        MOV     [EXT_SAVAX],CX
        RET
;---------------------------------------------------------------------
        PAGE
;************************************************
;*                                              *
;*      FUNC #16                                *
;*      DIRECT CONSOLE OUTPUT                   *
;*                                              *
;*      INPUT:                                  *
;*                                              *
;*      OUTPUT:                                 *
;*                                              *
;************************************************
;****************************************
;*                                      *
;*      MAIN                            *
;*                                      *
;****************************************

EXB_16:
        MOV     BX,[EXT_SAVAX]
        XCHG    BH,BL
        XOR     BH,BH
        SHL     BX,1
        SHL     BX,1
        MOV     SI,OFFSET EX16TBL
        MOV     AX,CS:[BX+SI]           ;ROUTINE 1
        MOV     BX,CS:2[BX+SI]          ;ROUTINE 2
        CALL    AX
        RET

;****************************************
;*                                      *
;*      DISPLAY 1 CHAR                  *
;*                                      *
;****************************************

EX16_DSP:
        MOV     CL,DL
        CALL    BX
        RET

;****************************************
;*                                      *
;*      STRING DATA DISPLAY             *
;*                                      *
;****************************************

EX16_STR:
        MOV     ES,[EXT_SAVDS]          ;USER SEGMENT
        MOV     BX,DX                   ;BUFFER OFFSET
EX16_STR_1:
        MOV     CL,ES:[BX]              ;GET
        CMP     CL,'$'                  ;END OF STRING ?
        JE      EX16_STR_2              ;Y
        PUSH    BX
        CALL    CRTOUT                  ;DISPLAY
        POP     BX
        INC     BX                      ;NEXT DATA
        JMP     SHORT   EX16_STR_1
EX16_STR_2:
        RET

;****************************************
;*                                      *
;*      SET ATTRIBUTE                   *
;*                                      *
;****************************************
EX16_ATTR:
        MOV     [CURATTR],DL
        MOV     [CURATTR2],DX           ;                       89/08/16
EX16_ATTR10:
        RET

;****************************************
;*                                      *
;*      DIRECT CURSOR ADRESSING         *
;*                                      *
;****************************************
EX16_CUP:
        ADD     DX,2020H
        XCHG    DH,DL
        MOV     CX,DX                   ;CL:LINE CH:COLUMN
        CALL    BX
        RET

;****************************************
;*                                      *
;*      INDEX / REVERSE INDEX           *
;*                                      *
;****************************************
EX16_UPDN:
        CALL    BX                      ;ESCIND OR ESCRI
        RET

;****************************************
;*                                      *
;*      CUU,CUD,CUF,CUB ,IL OR DL       *
;*                                      *
;****************************************
EX16_ANSI1:
        XOR     DH,DH
        MOV     CX,DX
        CALL    BX
        RET

;****************************************
;*                                      *
;*      ED / EL                         *
;*                                      *
;****************************************
EX16_ANSI2:
        XOR     DH,DH
        MOV     AX,DX
        CALL    BX
        RET

;****************************************
;*                                      *
;*      CHANGE CHARACTER MODE           *
;*                                      *
;****************************************
EX16_CHR:
        OR      DL,30H
        MOV     CL,DL
        CALL    BX                      ;MODE SELECT
        RET

        PAGE
;************************************************
;*                                              *
;*      FUNC #17                                *
;*      SET/RESET & GET PRINTER OUTPUT MODE     *
;*                                              *
;*      INPUT:                                  *
;*                                              *
;*      OUTPUT:                                 *
;*                                              *
;************************************************
;****************************************
;*                                      *
;*      SET / RESET FUNCTION            *
;*                                      *
;****************************************

EX_PRFLG:
        MOV     AX,[EXT_SAVAX]  ;PARAM
        TEST    AX,8000H                ;GET PRINTER MODE      87/8/25
        JNZ     EX_PRG                  ;                       87/8/25
        TEST    AX,0020H                ;CR/LF OUTPUT           87/8/25
        JNZ     EX_PR3                  ;                       87/8/25
        OR      AX,AX
        JZ      EX_PR1_5
        DEC     AX
        JZ      EX_PR2
        SUB     AX,0FH
        JZ      EX_PRVAT
        DEC     AX
        JNZ     EX_PRRET
        AND     [PR_RATIO],NOT KICODE   ;SET KI=ESC+K MODE
        JMP     SHORT   EX_PRRET
EX_PR1_5:
        OR      [PR_RATIO],RATIOAK      ;SET 1:1.5 MODE
        JMP     SHORT   EX_PRRET
EX_PRVAT:
        OR      [PR_RATIO],KICODE       ;SET KI=ESC+t MODE
        JMP     SHORT   EX_PRRET
EX_PR2:
        AND     [PR_RATIO],NOT RATIOAK  ;SET 1:2  MODE
        JMP     SHORT   EX_PRRET
        
;*******87/8/25*********
EX_PR3:
        CMP     AX,0021H
        JB      EX_PR5
        JE      EX_PR4
        JMP     SHORT   EX_PRRET
EX_PR4:
        AND     [PR_RATIO],NOT CRLFP    ;SET CR/LF OUT
        JMP     SHORT   EX_PRRET
EX_PR5:
        OR      [PR_RATIO],CRLFP        ;SET CR/LF NOT OUT

;***********************
EX_PRRET:
        RET
        
;****************************************
;*                                      *
;*      GET FUNCTION                    *
;*                                      *
;****************************************

EX_PRG:
        CMP     AX,8000H
        JNE     EX_PRG1
        MOV     DX,0001H
        JMP     short EX_PRG3
        
EX_PRG1:
        CMP     AX,8010H
        JNE     EX_PRG2
        MOV     DX,0002H
        JMP     short EX_PRG3
        
EX_PRG2:
        CMP     AX,8020H
        JNE     SHORT  EX_PRG_RET
        MOV     DX,0080H
        
EX_PRG3:
        MOV     AX,0000H
        MOV     AL,[PR_RATIO]
        TEST    AX,DX
        MOV     AX,0000H
        JNZ     EX_PRG_RET
        MOV     AX,0001H
        
EX_PRG_RET:
        MOV     [EXT_SAVAX],AX
        RET


        PAGE
;************************************************
;*                                              *
;*      FUNC #18                                *
;*      SET IO.SYS VERSION & H/W MODE           *
;*                              NEW 87/8/14     *
;*                                              *
;*      INPUT:                                  *
;*                                              *
;*      OUTPUT:                                 *
;*                                              *
;************************************************
;------------------------------------------------------ 88/03/31 ALL -
EX_VER:
;-----------------------------------------------------  90/01/19  ---
        mov     ax,[IOSYS_REV]
        mov     [EXT_SAVAX],ax
;       MOV     [EXT_SAVAX],0004H       ; AX=0004H  FOR MS-DOS 5.0
;-----------------------------------------------------  90/01/09  ---
        XOR     BX,BX
        MOV     ES,BX
        MOV     AH,ES:[0501H]           ;GET BIOS_FLAG1
        MOV     AL,ES:[0458H]           ;GET BIOS_FLAG?
        TEST    AL,80H                  ;NEW ARCHTECHTURE ??
        JNZ     EXVER_P0
        MOV     DH,00H                  ;PC SERIES
        CALL    EXVER_OLDARC            ;
        JMP     short EXVER_P1

EXVER_P0:
        MOV     DH,10H                  ;NPC SERIES
        CALL    EXVER_NEWARC

EXVER_P1:
        MOV     [EXT_SAVDX],DX          ;SAVE DX
        RET

;****************************************
;*                                      *
;*  NEW ARC. ROUTINE                    *
;*                      DATE. 88/3/31   *
;****************************************
EXVER_NEWARC:
        AND     AL,00000111B            ;CHECK MACHINE TYPE
        MOV     DL,4                    ;                       90/03/16
;       CMP     AL,01H                  ;X42/44 ?
;       JE      EXVERN_00               ;YES (DL)=00
;       INC     DL
;       CMP     AL,02H                  ;X43/45 ?
;       JE      EXVERN_00               ;YES (DL)=01
;       INC     DL
;       CMP     AL,04H                  ;X46 ?
;       JNE     EXVERN_10               ;NO
EXVERN_00:
        TEST    AH,00001000B            ;HIRESO MODE ?
        JZ      EXVERN_10               ;NO, (DH)=10
        INC     DH                      ;YES (DH)=11
        MOV     DL,01H                  ;                       90/03/16
EXVERN_10:
        MOV     AL,ES:[487H]            ;CPU TYPE CHECK
        CMP     AL,04H                  ;CPU=486?
        JNZ     EXVERN_20
        INC     DL
EXVERN_20:
        RET

;****************************************
;*                                      *
;*      OLD ARC. ROUTINE                *
;*                      DATE. 88/3/31   *
;****************************************
EXVER_OLDARC:
        MOV     DL,AH                   ;SAVE AH
;------------------------------------------------DOS5 91/06/06-----------
        MOV     AL,ES:[481h]            ;BIOS_FLAG3
;------------------------------------------------------------------------
        AND     AL,01000000B            ;ONLY 106KEY BIT
        AND     AH,00110000B            ;ONLY SYSTEM-TYPE BITS
        OR      AL,AH                   ;MERGE
        MOV     AH,ES:[0500H]           ;GET BIOS_FLAG INFO.
        AND     AH,00000001B            ;ONLY EX-SYSTEM-TYPE BIT
        OR      AL,AH                   ;MERGE
        TEST    DL,00001000B            ;HIRESO MODE ?
        MOV     DL,0
        JZ      EXVERO_00               ;NO,

        INC     DH                      ;SET HIRESO MODE BIT
        CMP     AL,00H                  ;98XA ?
        JE      EXVERO_DONE             ;YES (DL)=00
        INC     DL
        CMP     AL,20H                  ;98XL/98XL^2 ?
        JE      EXVERO_DONE             ;YES (DL)=01
        JMP     short EXVERO_DONE0      ;INVALID

EXVERO_00:
        CMP     AL,00H                  ;9801 ?
        JE      EXVERO_DONE             ;YES (DL)=00
        INC     DL
        CMP     AL,20H                  ;E/F/M ?
        JE      EXVERO_DONE             ;YES (DL)=01
        INC     DL
        CMP     AL,31H                  ;U2 ?
        JE      EXVERO_DONE             ;YES (DL)=02
        INC     DL
        CMP     AL,21H                  ;VM/VF/VX/UV/XLn/XL^2n/UX/LV/CV ?
        JE      EXVERO_DONE             ;YES (DL)=03
        INC     DL
        CMP     AL,61H                  ;V22/V23 (NEW) ?
        JNE     EXVERO_DONE0            ;NO, INVALID
                                        ;YES (DL)=04
EXVERO_DONE:
EXVERO_DONE0:
        RET
;---------------------------------------------------------------------
        PAGE
;************************************************
;*                                              *
;*      FUNC #19                                *
;*      GET LPTABLE & SINGLE DRIVE INFO.        *
;*                              NEW 87/8/14     *
;*                                              *
;*      INPUT:                                  *
;*                                              *
;*      OUTPUT:                                 *
;*                                              *
;************************************************

EX_LPTABLE:
        CLD
        MOV     ES,[EXT_SAVDS]
        MOV     DI,DX

;       < 96 BYTE BUFFER CLEAR >
        PUSH    DI
        MOV     CX,96/2
        XOR     AX,AX
        REP     STOSW
        POP     DI

;       < LPTABLE >
        MOV     SI,OFFSET LPTABLE       ;LPTABLE OFFSET
        MOV     CX,16
        REP     MOVSB                   ;COPY [LPTABLE] CONTENT
        
        ADD     DI,0AH                  ;SKIP RFU FIELD

;       < EXLPTBL >
        MOV     SI,OFFSET EXLPTBL       ;EXLPTBL POINTER
        MOV     CX,26
        REP     MOVSW                   ;COPY [EXLPTBL] CONTENT

;       < SINGLE DRIVE >
        MOV     AL,[SNGDRV_FLG]         ;SINGLE DRIVE INFO.
        STOSB                           ;STORE IT.

;       < LOGICAL EXTENT >
        MOV     AL,[EXTSW]              ;LOGICAL EXTENT SWITCH
        STOSB                           ;STORE IT.

;       < CURRENT DRIVE >
        MOV     AL,[CURDRV]             ;CURRENT DRIVE NUMBER
        STOSB                           ;STORE IT.

        RET

        PAGE
;************************************************
;*                                              *
;*      FUNC #128                               *
;*      GET IO.SYS VARIABLE                     *
;*                              NEW 87/8/14     *
;*                                              *
;*      INPUT:                                  *
;*                                              *
;*      OUTPUT:                                 *
;*                                              *
;************************************************

EX_VARIABLE:
        CLD
        MOV     ES,[EXT_SAVDS]
        MOV     DI,DX

        MOV     AX,[EXT_SAVAX]          ;GET PARAMETER
        CMP     AX,8000H                ;CMD>8000(FLAGS)?
        JB      EXT_VAR00               ;NO,
        CALL    MOD_FLAG                ;GET FLAG INFO.
        RET

EXT_VAR00:
;       < 256 BYTE BUFFER CLEAR >
        PUSH    AX
        PUSH    DI
        MOV     CX,256/2
        XOR     AX,AX
        REP     STOSW
        POP     DI
        POP     AX

        CMP     AX,0000H                ;CMD=0(DSK INFO.)?
        JNE     EXT_VAR10               ;NO,
        CALL    DSK_PART                ;DISK INFO.
        JMP     short EXT_VAR_RET
        
EXT_VAR10:
        CMP     AX,0001H                ;CMD=1(CON INFO.)?
        JNE     EXT_VAR_RET             ;NO,
        CALL    CON_PART                ;COSOLE INFO

EXT_VAR_RET:
        RET


;****************************************
;*                                      *
;*  GET DISK INFO ROUTINE               *
;*                      DATE. 87/8/14   *
;****************************************
DSK_PART:
;       < # OF PARTITION INF >
        MOV     SI,OFFSET HD_NUM
        MOV     CX,4                    ;SET ACTIVE PT/UNIT     88/03/31
        REP     MOVSB                   ;(SASI-HD & NPC-HD)
;------------------------------------------------------ 88/03/31 -----
        MOV     SI,OFFSET HDS_NUM
        MOV     CX,7                    ;SET ACTIVE PT/UNIT
        REP     MOVSB                   ;(SCSI HD)

        INC     DI                      ;SKIP RFU FIELD
;----------------------------------------
;       ADD     DI,6                    ;SKIP RFU FIEL
;---------------------------------------------------------------------
        MOV     AL,[N8FD]               ;1MB FDD INFO.
        STOSB
        MOV     AL,[N5FD]               ;640KB FDD INFO.
        STOSB
        MOV     AL,[N5HD]               ;SASI HD INFO.
        STOSB
;------------------------------------------------------ 88/03/31 -----
;       INC     DI                      ;SKIP RFU FIELD
;----------------------------------------
        MOV     AL,[NSHD]               ;SCSI HD INFO.
        STOSB
;---------------------------------------------------------------------
        MOV     SI,OFFSET HD_OFFSET     ;PARTITION START SECTOR
        MOV     CX,4*4*4                ;4BYTES*4PTS*4UNITS     88/06/18
        REP     MOVSB                   ;SASI & NPC-HD          88/03/31
;------------------------------------------------------ 88/03/31 -----
        MOV     SI,OFFSET HDS_OFFSET    ;PARTITION START SECTOR
        MOV     CX,0080H                ;4BYTES*4PTS*8UNITS     89/07/28
        REP     MOVSB                   ;SCSI HD
;---------------------------------------------------------------------
        RET

;****************************************
;*                                      *
;*  GET CONSOLE INFO ROUTINE            *
;*                      DATE. 87/8/14   *
;****************************************
CON_PART:
        MOV     SI,OFFSET HEXMOD        ;CONSOLE TALE TOP
        MOV     CX,26
        REP     MOVSB                   ;COPY CONSOLE VAR.
        RET

;****************************************
;*                                      *
;*  GET FLAG INFO. INTO (AX) REG.       *
;*                      DATE. 87/9/27   *
;****************************************
MOD_FLAG:
;       < VSYS_FLAG >
        CMP     AX,8000H                ;VSYS ?
        JNE     MODF01                  ;NO,
        MOV     AL,[VSYS_FLAG]          ;GET FLAG CONTENT
        JMP     SHORT MODF_DONE

MODF01:
;       < XPORT_FLAG >
        CMP     AX,8001H                ;XPORT ?
        JNE     MODF02                  ;NO,
        MOV     AL,[XPORT_FLAG]         ;GET FLAG INFO.
        JMP     SHORT MODF_DONE

MODF02:
;       < KDRV_FLAG >
        CMP     AX,8002H                ;KDRV ?
        JNE     MODF_ER                 ;NO,
        MOV     AL,[KDRV_FLG]           ;GET FLAG INFO.
MODF_DONE:
        XOR     AH,AH                   ;CLEAR (AH)
MODF_ER:
        MOV     [EXT_SAVAX],AX          ;SET RETURN VALUE
        RET

        PAGE
;************************************************
;*                                              *
;*      FUNC #129                               *
;*      EXTENDED MEMORY MANAGEMENT FUNCTION     *
;*                              NEW 88/3/31     *
;*                                              *
;*      INPUT:  (AX) COMMAND                    *
;*                0000 GET EX-MEMORY SIZE       *
;*                0001 ALLOCATE MEMORY          *
;*                  (BX) ALLOCATE BLOCK SIZE    *
;*                                              *
;*      OUTPUT: COMMAND=0000                    *
;*                (AX) EX-MEMORY SIZE           *
;*              COMMAND=0001                    *
;*                (AX) RESULT CODE              *
;*                  0000 NORMAL                 *
;*                  0001 NOT ENOUGH MEMORY      *
;*                  FFFF MEMORY NOT EXIST       *
;*                                              *
;************************************************
EX_MMFNC:
        PUSH    ES
        XOR     CX,CX
        MOV     ES,CX                   ;ES = SEGMENT 0

        MOV     DX,[EXT_SAVDX]
        MOV     BX,[EXT_SAVBX]
        MOV     AX,[EXT_SAVAX]
        OR      AX,AX                   ;PARAM ?
        JNZ     EXMMF_00                ;NOT 0000

;  <COMMAND 0000 >
        MOV     AL,[EXMM_SIZE]          ;GET REAL MEMORY SIZE
        JMP     short EXMMF_DONE        ;(AH)=00

;  <COMMAND 0001 >
EXMMF_00:
        CMP     [EXMM_SIZE],0
        JNE     EXMMF_10                ;EX-MEMORY NOT EXIST
        MOV     AX,-1                   ;RESULT IS ERROR
        JMP     short EXMMF_DONE

EXMMF_10:
        MOV     CL,ES:[0401H]           ;GET AVAILABLE MEMORY SIZE
        CMP     BX,CX                   ;CHECK MEMORY SIZE
        JA      EXMMF_ER01              ;LESS
        MOV     DX,CX
        SUB     ES:[0401H],BX           ;ADJUST AVAIL MEMORY SIZE
        SHL     DX,1
        SHL     BX,1
        MOV     AX,DX
        SUB     AX,BX
        MOV     BX,AX                   ;DX = END(+1), BX = BEGIN
        ADD     BX,0010H                ;ADD 1MB                        880517
        ADD     DX,0010H                ;ADD 1MB                        880517
        XOR     AX,AX                   ;RESULT IS NORMAL
        JMP     short EXMMF_DONE

EXMMF_ER01:
        MOV     AX,0001H                ;RESULT IS ERROR
        MOV     BX,CX
EXMMF_DONE:
        MOV     [EXT_SAVAX],AX          ;SET RESULT
        MOV     [EXT_SAVBX],BX
        MOV     [EXT_SAVDX],DX
        POP     ES
        RET

        PAGE
;************************************************
;*                                              *
;*      FUNC #130                               *
;*      EXTENDED MEMORY CHECK  FUNCTION         *
;*                      NEW MSDOS 3.3B PATCH    *
;*                                              *
;*      INPUT:  (AX) COMMAND                    *
;*                0000 FREE EX-MEMORY SIZE      *
;*                                              *
;*      OUTPUT: COMMAND=0000                    *
;*                (AX) FREE EX-MEMORY SIZE      *
;*                (BX) START ADDRESS            *
;*                (DX) END ADDRESS              *
;************************************************
EX_MMCHECK:
        PUSH    ES
        XOR     CX,CX
        MOV     ES,CX
        MOV     DX,WORD PTR [EXT_SAVDX]
        MOV     BX,WORD PTR [EXT_SAVBX]
        MOV     AX,WORD PTR [EXT_SAVAX]
        OR      AX,AX
        JNZ     MMCHECK050
        MOV     AX,WORD PTR ES:[401H]
;------------------------------------------------DOS5 91/02/19-----------
        AND     AX,00FFH                        ;use low byte
;------------------------------------------------------------------------
        MOV     DX,AX
        SHL     DX,1
        ADD     DX,0010H
        MOV     BX,0010H
        TEST    BYTE PTR ES:[501H],08H
        JZ      MMCHECK060
        ADD     BX,0004H
        SUB     AX,2
        JNB     MMCHECK060
        MOV     DX,0014H
        XOR     AX,AX
        JMP     short MMCHECK060
MMCHECK050:
        MOV     AX,0FFFFH
MMCHECK060:
        MOV     WORD PTR [EXT_SAVAX],AX
        MOV     WORD PTR [EXT_SAVBX],BX
        MOV     WORD PTR [EXT_SAVDX],DX
        POP     ES
        RET

        PAGE
;********************************************************
;*                                                      *
;*                                                      *
;*      EXTENDED BIOS USE DATA AREA                     *
;*                                                      *
;*                                                      *
;********************************************************

        EVEN
;****************************************
;*                                      *
;*      FUNCTION TABLE                  *
;*                                      *
;****************************************

EXT_RTNTBL      DW      EXT_MODK        ;#9  GET/SET MO DISK    89/08/16
                DW      EX_RSINIT       ;#10 INITIALIZE RS232C
                DW      EX_NOP          ;#11 RFU
                DW      EX_RFKY         ;#12 READ SOFT KEY
                DW      EX_SFKY         ;#13 SET SOFT KEY
                DW      EX_RSFNC        ;#14 RS232C FUNCTION
                DW      EX_CTRLFLG      ;#15 3270SE MODE
                DW      EXB_16          ;#16 DIRECT CONOUT
                DW      EX_PRFLG        ;#17 PRINTER MODE
                DW      EX_VER          ;#18 IO.SYS VERSION             87/8/14
                DW      EX_LPTABLE      ;#19 LPTABLE/SINGLE DRIVE INFO  87/8/14
                DW      EX_CRTMD        ;#20 GET/SET CRT MODE   89/08/16
;------------------------------------------------------ DOS5 91/09/09 -
                DW      EX_MINORVER     ;#21 IO.SYS MINOR VERSION
;----------------------------------------------------------------------
                DW      EX_VARIABLE     ;#128 IO.SYS VARIABLE           87/8/14
                DW      EX_MMFNC        ;#129 EXTENDED MM FUNCTION      88/03/31
                DW      EX_MMCHECK      ;#130 EXTENDED MM CHECK         90/03/16

;****************************************
;*                                      *
;*      EXB_16 USE TABLE                *
;*                                      *
;****************************************

EX16TBL         DW EX16_DSP  ,CRTOUT            ;AH=0 : DATA DISPLAY
                DW EX16_STR  ,0000H             ;   1 : DISPLAY STRING DATA
                DW EX16_ATTR ,0000H             ;   2 : SET ATTRIBUTE
                DW EX16_CUP  ,ESCADM+22         ;   3 : CURSOR POSITION
                DW EX16_UPDN ,ESCIND            ;   4 : INDEX
                DW EX16_UPDN ,ESCRI             ;   5 : REVERSE INDEX
                DW EX16_ANSI1,ESCVT_CUU+9       ;   6 : CSR UP
                DW EX16_ANSI1,ESCVT_CUD+9       ;   7 : CSR DOWN
                DW EX16_ANSI1,ESCVT_CUF+9       ;   8 : CSR FOREWARD
                DW EX16_ANSI1,ESCVT_CUB+9       ;   9 : CSR BACKWARD
                DW EX16_ANSI2,ESCVT_ED+9        ;   A : ERASE IN DISPLAY
                DW EX16_ANSI2,ESCVT_EL+9        ;   B : ERASE IN LINE
                DW EX16_ANSI1,ESCVT_IL+16       ;   C : INSERT LINE
                DW EX16_ANSI1,ESCVT_DL+9        ;   D : DELETE LINE
                DW EX16_CHR  ,ESCKNJ+7          ;   E : KANJI/GRAPH
;-----------------------------------------------------  89/08/16  ---

MO_DEV_STR      STRUC
        MO_DEV_UNIT     DB      ?
        MO_DEV_FLG      DB      ?
        MO_DEV_ID       DB      ?
        MO_DEV_RFU      DB      ?
MO_DEV_STR      ENDS

;       MOVE BIO2.ASM 
;
;ATTRF          DW      0001H           ;2BYTE ATTR FLAG
;CRTDOTF                DW      0001H           ;480DOT MODE FLAG
;BIOSF_3                DB      00H             ;BIOS_FLG(3)            89/08/21

;--------------------------------------------------------------------
;-----------------------------------------------------  89/08/16  ---
;****************************************
;*                                      *
;*      MO_DISK                         *
;*                      89/08/16        *
;****************************************
;
EXT_MODK:
;
        MOV     DX,[EXT_SAVDX]
        MOV     AX,[EXT_SAVAX]

        CMP     AX,0000H                ;GET EQUIP
        JE      GET_MO_EQUIP
        CMP     AX,0001H                ;SET AI FLAG
        JE      SET_AI_FLAG
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     ax,0010h
        je      LockUnlock
        cmp     ax,0011h
        je      LockUnlock
;---------------------------------------------------------------------
        RET
;
GET_MO_EQUIP:
        MOV     ES,[EXT_SAVDS]
        MOV     DI,DX

;       PUSH    CS
;       POP     DS
        MOV     DS,CS:[BDATA_SEG]

        MOV     SI,OFFSET SCSI_EQUIP
        MOV     CX,8
        CLD
        REP     MOVSB
        RET
;
SET_AI_FLAG:
;------------------------------------------------DOS5 91/06/06-----------
        MOV     [EXT_SAVAX],0FFFFH      ;SET ERR END STATUS
;------------------------------------------------------------------------
        CMP     MO_COUNT,0
        JZ      NO_MO

;       PUSH    CS                      ;DOS5
;       POP     DS                      ;DOS5

        AND     DL,0FH
        MOV     BX,OFFSET MO_DEVICE_TBL
        XOR     CH,CH
        MOV     CL,MO_COUNT
        SHL     CX,1
        SHL     CX,1
;------------------------------------------------DOS5 91/06/06-----------
;       MOV     AX,0FFFFH               ;SET ERR END STATUS
;------------------------------------------------------------------------
SET_AI_LOOP:
        CMP     [BX.MO_DEV_ID],DL
        JNE     NOT_SET_AI
        MOV     BYTE PTR [BX.MO_DEV_FLG],2
;------------------------------------------------DOS5 91/06/06-----------
        MOV     [EXT_SAVAX],0000H
;------------------------------
;       MOV     AX,0000H
;------------------------------------------------------------------------
NOT_SET_AI:
        ADD     BX,[MO_DEV_LENGTH]
        LOOP    SET_AI_LOOP
NO_MO:
        RET

;----------------------------------------------- DOS5 91/08/00 -------
LockUnlock:
        mov     [EXT_SAVAX],0ffffh      ;set error
        cmp     MO_COUNT,0
        jz      LockRet

        xor     dh,dh
        mov     cx,26
        mov     bx,offset EXLPTBL
LockSearch:
        cmp     byte ptr [bx+1],dl      ; compare DA/UA
        je      LockSearch10
        add     bx,2
        inc     dh
        loop    LockSearch
        jmp     short LockRet

LockSearch10:
        test    byte ptr [bx],01h       ; check mo flag
        jz      LockRet

        mov     CURDRV,dh               ; drive letter
        cmp     ax,0010h
        jne     UnlockStart
LockStart:
        call    LockMO
        jmp     short LockStatus

UnlockStart:
        mov     [EXT_SAVAX],01h         ; set error
        mov     bl,dl
        and     bl,0fh
        xor     bh,bh                   ; scsi id -> bx
        cmp     byte ptr Lockcnt.[bx],0
        je      LockRet
        call    UnlockMO

LockStatus:
        mov     [EXT_SAVAX],0           ; status clear
        jnc     LockRet
        mov     [EXT_SAVAX],02h         ; drive not ready
        cmp     [ERR_STATUS],02h        ; check scsi sense code
        je      LockRet
        mov     [EXT_SAVAX],03h         ; other error
LockRet:
        ret
;---------------------------------------------------------------------

;
;****************************************
;*                                      *
;*      NPC CRT MODE                    *
;*                      89/08/16        *
;****************************************
;
EX_CRTMD:
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   patch10:near

        call    patch10                 ;NPC or TA architecture 
                                        ; or EX graph architecture bit on?
        jz      CRTMD_ERR               ;no
        jmp     short EX_CRTMD10
        db      3 dup (90h)
;---------------
;       TEST    byte PTR [BIOSF_3],80H  ;NPC CHECK      89/08/21
;       JNZ     EX_CRTMD10
;       JMP     CRTMDRET
;---------------------------------------------------------------------
EX_CRTMD10:
        MOV     AX,[EXT_SAVAX]  ;GET FUNCTION
        CMP     AX,0000H                ;2BYTE ATTRIBUTE
        JE      CRTMD2AT
        CMP     AX,0001H                ;1BYTE ATTRIBUTE
        JE      CRTMD1AT
        CMP     AX,0010H                ;480 DOT MODE
        JE      CRTMD480
        CMP     AX,0011H                ;400 DOT MODE
        JE      CRTMD400
        TEST    AX,8000H
        JZ      CRTMD_ERR
        JMP     SHORT CRTMD_GET
CRTMD_ERR:
        RET                             ;ERR

CRTMD2AT:                               ;CHANGE 2BYTE ATTR
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   CRTMD_TA_2AT:near

        call    CRTMD_TA_2AT
        db      90h
;---------------
;       MOV     AH,2BH
;       INT     18H                     ;STATUS READ
;---------------------------------------------------------------------
        TEST    AL,80H                  ;USE EGH
        JNZ     CRTMD070
        AND     AL,3FH
        OR      AL,80H                  ;EGH SET
        MOV     AH,2AH
        INT     18H                     ;SET 2BYTE ATTR
;--------------------------------------------------------- 90/01/19 --
;       CALL    CLRRTN                  ;CLEAR SCREEN & POS CURSOR
;       MOV     AL,[DEFATTR]
;       MOV     [CURATTR],AL            ;SET ATTRIBUTE TO DEFAULT
;       MOV     AX,[DEFATTR2]           ;                       89/08/22
;       MOV     [CURATTR2],AX           ;SET ATTRIBUTE TO DEFAULT 89/08/22
        CALL    CRTMD_DEF
;----------------------------------------------------------------------
CRTMD080:
        MOV     AH,2BH
        INT     18H                     ;READ STATUS
        TEST    AL,80H
        JNZ     CRTMD070

        MOV     WORD PTR ATTRF,0001H    ;1BYTE ATTRIBUTE
        JMP     short CRTMDRET
CRTMD070:
        MOV     WORD PTR ATTRF,0000H    ;2BYTE ATTRIBUTE
        JMP     short CRTMDRET


CRTMD1AT:
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   CRTMD_TA_1AT:near

        call    CRTMD_TA_1AT
        db      90h
;---------------
;       MOV     AH,2BH
;       INT     18H                     ;STATUS READ
;---------------------------------------------------------------------
        TEST    AL,80H                  ;USE EGH
        JZ      CRTMDRET
        AND     AL,7FH
        MOV     AH,2AH
        INT     18H                     ;SET 2BYTE ATTR
;--------------------------------------------------------- 90/01/19 --
;       CALL    CLRRTN                  ;CLEAR SCREEN & POS CURSOR
;       MOV     AL,[DEFATTR]
;       MOV     [CURATTR],AL            ;SET ATTRIBUTE TO DEFAULT
;       MOV     AX,[DEFATTR2]           ;                       89/08/22
;       MOV     [CURATTR2],AX           ;SET ATTRIBUTE TO DEFAULT 89/08/22
        CALL    CRTMD_DEF
;---------------------------------------------------------------------
        JMP     CRTMD080                ;


CRTMD480:
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   CRTMD_TA_480:near

        call    CRTMD_TA_480
        db      90h
;---------------
;       MOV     AH,2BH
;       INT     18H                     ;READ STATUS
;----------------------------------------------------------------------
        TEST    AL,01H                  ;USE 480
        JNZ     CRTMDRET
        OR      AL,01H
CRTMD100:
        MOV     AH,2AH
        INT     18H                     ;SET 480DOT
        CALL    CRTMD_DEF

        MOV     AH,2BH
        INT     18H                     ;READ STATUS
        TEST    AL,01H                  ;480DOT
        JZ      CRTMD090
        MOV     WORD PTR CRTDOTF,0000H  ;480 DOT MODE
        JMP     SHORT CRTMDRET
CRTMD090:
        MOV     WORD PTR CRTDOTF,0001H  ;400 DOT MODE
        JMP     SHORT CRTMDRET
CRTMD400:
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   CRTMD_TA_400:near

        call    CRTMD_TA_400
        db      90h
;---------------
;       MOV     AH,2BH
;       INT     18H                     ;READ STATUS
;---------------------------------------------------------------------
        TEST    AL,01H                  ;USE 480
        JZ      CRTMDRET
        AND     AL,0FEH
        JMP     CRTMD100

CRTMDATR:
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   CRTMD_TA_ATR:near

        call    CRTMD_TA_ATR
        db      90h
;---------------
;       MOV     AH,2BH
;       INT     18H                     ;READ STATUS
;---------------------------------------------------------------------
        ROL     AL,1
        JMP     short CRTMD110

CRTMD_GET:
        CMP     AX,8000H                ;GET ATTRIBUTE
        JE      CRTMDATR
        CMP     AX,8010H                ;GET DOT MODE
        JE      CRTMDDOT
        JMP     SHORT CRTMDRET

CRTMDDOT:
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   CRTMD_TA_DOT:near

        call    CRTMD_TA_DOT
        db      90h
;---------------
;       MOV     AH,2BH
;       INT     18H                     ;READ STATUS
;---------------------------------------------------------------------
CRTMD110:
        NOT     AX
        AND     AX,0001H
        MOV     [EXT_SAVAX],AX
CRTMDRET:
        RET
;--------------------------------------------------------------------

CRTMD_DEF       PROC
        CALL    CLRRTN                  ;CLEAR SCREEN & POS CURSOR
        MOV     AL,[DEFATTR]
        MOV     [CURATTR],AL            ;SET ATTRIBUTE TO DEFAULT
        MOV     AX,[DEFATTR2]           ;                       89/08/22
        MOV     [CURATTR2],AX           ;SET ATTRIBUTE TO DEFAULT 89/08/22
        RET
CRTMD_DEF       ENDP

;----------------------------------------------- DOS5 91/08/00 -------
;************************************************
;*                                              *
;*      FUNC #21                                *
;*      GET IO.SYS MINOR VERSION                *
;*                                              *
;*      INPUT:                                  *
;*                                              *
;*      OUTPUT:                                 *
;*                                              *
;************************************************
EX_MINORVER     proc    near
        cmp     ax,0
        jne     EX_MINORVER_RET
        mov     al,[MINOR_REV]
        xor     ah,ah
        mov     [EXT_SAVAX],ax
EX_MINORVER_RET:
        ret
EX_MINORVER     endp
;---------------------------------------------------------------------

;****************************************
;*                                      *
;*      SAVE AREA & LOCAL STACK         *
;*                                      *
;****************************************
;--------------------------------------------------------- 91/01/20 --
;EXT_SAVAX      DW      ?               ;AX SAVE
;EXT_SAVSS      DW      ?               ;SS SAVE
;EXT_SAVSP      DW      ?               ;SP SAVE
;EXT_SAVDS      DW      ?               ;DS SAVE
;EXT_SAVDX      DW      ?               ;DX SAVE                87/8/14
;EXT_SAVBX      DW      ?               ;BX SAVE                88/03/31
;
                DW      192 DUP(0CCCCH) ;EXT_BIOS LOCAL STACK
                                        ;SIZE 128 WORD          87/9/27
;EXT_STACK      EQU     $
;---------------------------------------------------------------------

FC_TABLE        DB      01H,02H,03H,04H,05H,06H,07H,08H,09H,0AH
                DB      10H,11H,12H,13H,14H,15H,16H,17H,18H,19H
                DB      1FH,20H,21H,22H,23H,24H,25H,26H,27H,28H,29H
                DB      0BH,0CH,0DH,0EH,0FH
                DB      1AH,1BH,1CH,1DH,1EH
        PAGE
;****************************************************************
;*                                                              *
;*                                                              *
;*   BREAK INTERRUPT ([STOP] KEY) PROC                          *
;*                                                              *
;*                                                              *
;****************************************************************
;
STOP_INT_CODE:
        PUSH    DS
        MOV     DS,CS:[BDATA_SEG]
        CMP     [STOP_FLAG],0
        JE      STOP_EXE
        POP     DS
        IRET                            ;NEST                   870927

STOP_EXE:
        MOV     [STOP_FLAG],1
        MOV     [STP_SAVAX],AX  ;SAVE AX

        CLI
        IN      AL,02H
        OR      AL,02H                  ;KB MASK
        JMP     SHORT $+2               ;DELAY                  870927
        JMP     SHORT $+2               ;DELAY                  870927
        JMP     SHORT $+2               ;DELAY                  870927
        OUT     02H,AL

        MOV     [STP_SAVSS],SS  ;SAVE SS
        MOV     [STP_SAVSP],SP  ;SAVE SP
;--------------------------------------------------------- 91/01/20 --
;       MOV     AX,CS

        MOV     SS,CS:[BDATA_SEG]                       ;SET OUR SEGMENT
;---------------------------------------------------------------------
        MOV     SP,OFFSET STOP_STACK    ;STACK ADDR
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    SI
        PUSH    DI
        CLD                             ;
        MOV     AH,2
        INT     18H                     ;SHIFT KEY SENSE
        TEST    AL,01H                  ;SHIFT + STOP ?
        JNZ     STP_CTLS                ;YES, MAKE DC3 CODE
        MOV     AL,'C'-'@'              ;CTRL-C
        CALL    STP_CKB                 ;CLEAR KB_FIFO

;-------------------------------------------------------------- 880526
        TEST    [HDIO_FLG],1            ;CURRENTLY HD I/O ?
        JNZ     SKP_RTRCT               ;YES,
        MOV     DL,[INF5H]              ;SASI HD EQUIPMENT FLAG
        MOV     AL,80H                  ;SET DA
        MOV     CX,4                    ;MAX 4 UNIT
        CALL    RETRACT                 ;SASI RETRACT
        MOV     DL,[INFSH]              ;SCSI HD EQUIPMENT FLAG
        MOV     AL,0A0H                 ;SET DA
        MOV     CX,7                    ;MAX 7 UNIT
        CALL    RETRACT                 ;SCSI RETRACT
;---------------------------------------------------------------------
;       TEST    [HDIO_FLG],1
;       JNZ     SKP_RTRCT
;       TEST    [INF5H],01H             ;HD #1 CONNECT ?
;       JZ      SKP_HD1                 ;JUMP IF NOT
;       MOV     AX,0F80H                ;SET RETRACT COMMAND & DA/UA
;       INT     1BH
SKP_HD1:
;       TEST    [INF5H],02H             ;HD #2 CONNECT ?
;       JZ      SKP_RTRCT               ;JUMP IF NOT
;       MOV     AX,0F81H
;       INT     1BH
;----------------------------------------
SKP_RTRCT:

        MOV     [CSRSW],1               ;CURSOR SWITCH ON
        MOV     AH,11H                  ;
        INT     18H                     ;SET CURSOR FORM   "
        CALL    DSPCSR

        MOV     AL,0
        MOV     [HEXMOD],AL             ;RESET HEX/KANJI INPUT MODE
        MOV     [ESCCNT],AL             ;RESET ESCAPE MODE
        MOV     [SRMFLG],AL             ;RESET ESCAPE MODE
        MOV     [KANJICNT],AL
        MOV     [PR_KNJCNT],AL
        MOV     [WRAPMOD],AL            ;SET "WRAP AT EOL"
        MOV     AL,[DEFATTR]
        MOV     [CURATTR],AL            ;SET ATTRIBUTE TO DEFAULT
        MOV     AX,[DEFATTR2]           ;                       89/08/22
        MOV     [CURATTR2],AX           ;SET ATTRIBUTE TO DEFAULT 89/08/22
;
;CHECK COPY MODE
        CMP     [COPY_FLAG],0           ;COPY MODE ?
        JE      STP_RET                 ;IRETURN
        MOV     [COPYSTOP],1            ;COPY ABORT
        JMP     SHORT STP_RET           ;IRETURN
STP_CTLS:
        MOV     AL,'S'-'@'              ;CTRL-S
        CALL    STP_CKB                 ;
STP_RET:

        CLI
        POP     DI
        POP     SI
        POP     DX
        POP     CX
        POP     BX
        MOV     SS,[STP_SAVSS]  ;RESUME SS
        MOV     SP,[STP_SAVSP]  ;RESUME SP

        IN      AL,02H
        AND     AL,0FDH
        JMP     SHORT $+2               ;DELAY                  870927
        JMP     SHORT $+2               ;DELAY                  870927
        JMP     SHORT $+2               ;DELAY                  870927
        OUT     02H,AL

        MOV     AX,[STP_SAVAX]
        MOV     [STOP_FLAG],0
        POP     DS
COPY_INT_CODE:
        IRET

STP_CKB:
        CALL    FLUSH                   ;FLUSH THE KB-FIFO
        MOV     [FKY_BUFFER],AL         ;SET CTRL-C/S CODE
        MOV     [FKYPTR],OFFSET FKY_BUFFER
        MOV     [FKYCNT],1              ;ENTER FUNC-KEY MODE
        RET

;-------------------------------------------------------------- 880526
RETRACT:
;       HARD DISK RETRACT SUBROUTINE
;       INPUT: (DL)=EQUIPMENT FLAG
;              (CX)=MAX UNIT
;              (AL)=DA (A0 OR 80)

        MOV     DH,1
RETR_LOOP:
        TEST    DL,DH                   ;TARGET HD CONNECT ?
        JZ      SKP_RETR                ;NO, SKIP THIS UNIT
        PUSH    AX
        PUSH    CX
        PUSH    DX
        MOV     AH,0FH                  ;COMMAND "RETRACT"
        INT     1BH                     ;RETRACT !
        POP     DX
        POP     CX
        POP     AX
SKP_RETR:
        INC     AL                      ;UA 1UP
        SHL     DH,1                    ;NEXT UNIT
        LOOP    RETR_LOOP               ;LOOP
        RET
;---------------------------------------------------------------------

        PAGE
;************************************************
;*                                              *
;*      DATA                                    *
;*                                              *
;************************************************
        EVEN
;
; ---- DELETE SIGNAL_TBL,VECT_TBL1 & VECT_TBL2 ---- 88/05/06 ---------

;--------------------------------------------------------- 91/01/20 --
;STP_SAVAX      DW      ?               ;AX SAVE
;STP_SAVSS      DW      ?               ;SS SAVE
;STP_SAVSP      DW      ?               ;SP SAVE

                DW      192 DUP(0CCCCH) ;STOP KEY LOCAL STACK
                                        ;SIZE 128 LEVEL         870927
;STOP_STACK     EQU     $
;---------------------------------------------------------------------
        PAGE
;****************************************************************
;*                                                              *
;*                                                              *
;*      STOP / COPY  CHECK ROUTINE                              *
;*                                                              *
;*                                                              *
;****************************************************************
;

STOP_CHK_FAR    PROC    FAR
        CALL    STOP_CHK
        RET
STOP_CHK_FAR    ENDP

STOP_CHK:
        PUSH    DS
        MOV     DS,[BDATA_SEG]
        CLI                             ;DISABLE INTERRUPT
        MOV     [BIOS_FLAG],0           ;EXIT FROM BIOS MODE
        CMP     [COPY_FLAG],1           ;COPY KEY PRESSED ?
        JNE     COPY_ACTV               ;NO
        CMP     [COPYSTOP],1            ;CANCEL ?
        JE      COPY_RESET              ;YES
        STI
        PUSH    AX
        CALL    HARD_COPY
        POP     AX
        POP     DS
        RET

COPY_RESET:
        MOV     [COPY_FLAG],0
        MOV     [COPYSTOP],0
COPY_ACTV:
        STI
        POP     DS
        RET


HARD_COPY:
        CMP     WORD PTR DS:[PR_HEADER+2],0
        JZ      COPY_RET
        PUSH    DS
        MOV     WORD PTR DS:[PR_HEADER],18H
;----------------------------------------------- DOS5 92/07/08 -------
;<patch BIOS50-P21>
        db      9ah                     ;direct far call "call 60:patch05"
        dw      offset patch05          ;
        dw      60h                     ;
        db      3 dup (90h)             ;nop
;---------------
;       MOV     DS,WORD PTR DS:[PR_HEADER+2]
;       CALL    DWORD PTR DS:[PR_HEADER]
;---------------------------------------------------------------------
        POP     DS
COPY_RET:
        RET

;****************************************************************
;*                                                              *
;*      END OF EXTBIOS MODULE                                   *
;*                                                              *
;****************************************************************
EXTBIOS_CODE_END:
EXTBIOS_END:
BIOS_CODE       ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\hdsasi.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 HDSASI.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: HDSASI.ASM                                 *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

        PAGE

BRANCH = 0                              ;ASSEMBLE SWITCH        871002

INTVEC  SEGMENT AT      0000H

        ORG     500H
BIO_FLAG        LABEL   BYTE
BIO_FLAG1       LABEL   BYTE
        ORG     564H
DISK_RESULT     LABEL   BYTE
        ORG     5D8H
F2DD_RESULT     LABEL   BYTE

INTVEC  ENDS

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Data       segment word public 'Bios_Data'
                ASSUME  CS:DATAGRP,DS:DATAGRP

        EXTRN   HD_OFFSET:WORD,HDS_OFFSET:WORD
        EXTRN   HD_LAST:WORD,HDS_LAST:WORD
        EXTRN   HDDSK5_1:NEAR,HDDSKS_1:NEAR

;--------------------------------------------------------- 88/03/25 --
        EXTRN   EXLPTBL:WORD
        EXTRN   DSK_TYP:BYTE,COM:BYTE,COM1:BYTE
        EXTRN   LNG_TRNS:WORD,CUR_TRNS:WORD,NO_TRNS:WORD,MAX_TRNS:WORD
        EXTRN   S_SEC:WORD,LNG_SEC:WORD,VRFY_FLG:BYTE,RTRY_CNT:BYTE
        EXTRN   RW_SW:BYTE
        EXTRN   SW_HD:BYTE,SW_5:BYTE,EXTSW:BYTE,VOLNUM:BYTE
        EXTRN   CURUA:BYTE,CURDA:BYTE,CURDRV:BYTE
        EXTRN   BPS:NEAR,BPSS:NEAR
        EXTRN   PWINF:BYTE
        EXTRN   HDIO_FLG:BYTE
        EXTRN   X2_SW_00:BYTE,X2_SW_01:BYTE             ;850505
IF BRANCH ;----------------------------------------------- 90/03/16 --
        EXTRN   X2_SW_VT:BYTE,VT_OFFSET:WORD,VT_LAST:WORD       ;850515
        EXTRN   VBPB:NEAR,VCPV:WORD,VBPS:WORD,VTPC:BYTE         ;850515
        EXTRN   VSPT:BYTE                                       ;850515
ENDIF ;---------------------------------------------------------------
;       EXTRN   VOLTABLE:BYTE           BDS USED        88/05/30
        EXTRN   PTRSAV:DWORD
        EXTRN   DB_TRNS:WORD
        EXTRN   DSK_BUF2:NEAR           ;BUFFER 1K --> 2K       88/05/06
        EXTRN   EXIT:FAR
        EXTRN   SVBPS:WORD

;----------------------------------------------- DOS5 90/12/14 -------
        EXTRN   START_SEC_H:WORD
        EXTRN   OLD_AX:WORD
        EXTRN   OLD_DX:WORD
        EXTRN   BPBCOPY:WORD
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 91/01/09 -------
        EXTRN   save_ss:WORD, save_sp:WORD, save_ax:WORD
        EXTRN   stack:NEAR
;---------------------------------------------------------------------

        EXTRN   SPT:BYTE, SPTS:BYTE, TPC:BYTE, TPCS:BYTE

;----------------------------------------------- DOS5 90/02/23 -------
;       EXTRN   EXIT_FAR:FAR
;---------------------------------------------------------------------

Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   SetDrive:NEAR
        EXTRN   STOP_CHK:NEAR

;----------------------------------------------- DOS5 90/12/14 -------
        EXTRN   BDATA_SEG:WORD
;---------------------------------------------------------------------
;----------------------------------------------- DOS5 91/11/02 -------
;<patch BIOS50-P06>
        EXTRN   patch2:near
;---------------------------------------------------------------------

Bios_Code       ends


IODAT   STRUC
CMDLEN  DB      ?
UNIT    DB      ?
CMD     DB      ?
STATUS  DW      ?
        DB      8 DUP(?)
MEDIA   DB      ?
TRANS   DD      ?
COUNT   DW      ?
START   DW      ?
IODAT   ENDS

;**     BIOS PARAMETER BLOCK DEFINITION
;
;       The BPB contains information about the disk structure.  It dates
;       back to the earliest FAT systems and so FAT information is
;       intermingled with physical driver information.
;
;       A boot sector contains a BPB for its device; for other disks
;       the driver creates a BPB.  DOS keeps copies of some of this
;       information in the DPB.
;
;       The BDS structure contains a BPB within it.
;

A_BPB                   STRUC
BPB_BYTESPERSECTOR      DW      ?
BPB_SECTORSPERCLUSTER   DB      ?
BPB_RESERVEDSECTORS     DW      ?
BPB_NUMBEROFFATS        DB      ?
BPB_ROOTENTRIES         DW      ?
BPB_TOTALSECTORS        DW      ?
BPB_MEDIADESCRIPTOR     DB      ?
BPB_SECTORSPERFAT       DW      ?
BPB_SECTORSPERTRACK     DW      ?
BPB_HEADS               DW      ?
BPB_HIDDENSECTORS       DW      ?
                        DW      ?
BPB_BIGTOTALSECTORS     DW      ?
                        DW      ?
                        DB      6 DUP(?)        ; NOTE:  many times these
;                                               ;        6 bytes are omitted
;                                               ;        when BPB manipulations
;                                               ;        are performed!
A_BPB                   ENDS


bds_struc       struc
bds_link        dd              0ffffh  ; link to next bds
bds_drivenum    db              80      ; int 13 drive number
bds_drivelet    db              3       ; dos drive number

;       We want to embed a BPB declaration here, but we can't initialize
;       it properly if we do, so we duplicate the byte/word/dword architecture
;       of the BPB declaration.

;BDS_BPB        db      size BPBSTRUC dup (?)   ; actual BPB
BDS_BPB         dw      512             ; BPB_BYTESPERSECTOR
                db      1               ; BPB_SECTORSPERCLUSTER
                dw      1               ; BPB_RESERVEDSECTORS
                db      2               ; BPB_NUMBEROFFATS
                dw      16              ; BPB_ROOTENTRIES
                dw      0               ; BPB_TOTALSECTORS
                db      0f8h            ; BPB_MEDIADESCRIPTOR
                dw      1               ; BPB_SECTORSPERFAT
                dw      0               ; BPB_SECTORSPERTRACK
                dw      0               ; BPB_HEADS
                dd      0               ; BPB_HIDDENSECTORS
                dd      0               ; BPB_BIGTOTALSECTORS

bds_fatsiz      db              0       ; flags...
bds_opcnt       dw              0       ; open ref. count
bds_formfactor  db              3       ; form factor index
bds_flags       dw              0020h   ; various flags
bds_ccyln       dw              40      ; max number of cylinders

BDS_RBPB        db size A_BPB dup (0)   ; recommended BPB

bds_track       db              -1      ; last track accessed on drive
bds_tim_lo      dw              1       ; time of last access. keep
bds_tim_hi      dw              0       ; these contiguous.
bds_volid       db "NO NAME    ",0      ; volume id of medium
bds_vol_serial  dd      0         ;current volume serial number from boot record
bds_filesys_id  db      "FAT12   ",0 ; current file system id from boot record
bds_struc       ends


;---------------------------------------------------------------------

;----------------------------------------------- DOS5 90/12/14 -------
BPB_SIZE        EQU     17
HDDSK_SIZE      EQU     BPB_SIZE*4              ;BPB*4PT
;---------------------------------------------------------------------


Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

;-------------------------------------------------------------------
IF BRANCH ;----------------------------------------------- 90/03/16 --
        PUBLIC  MEDIA_VIRTUAL
        PUBLIC  GET_VTBPB
ENDIF ;---------------------------------------------------------------
        PUBLIC  MEDIA_HD
        PUBLIC  GET_HD
        PUBLIC  CMN_RW_HD
        PUBLIC  HDSASI_CODE_END,HDSASI_CODE_START
        PUBLIC  HDSASI_END
;-------------------------------------------------------------------
;       public  save_ax,save_ss,save_sp,stack

HDSASI_CODE_START:

;********************************************************
;*                                                      *
;*      < MEDIA_CHK >                   FUNCTION 1      *
;*                                                      *
;*      WHICH MEDIA WAS EXCHANGED OR NOT ?              *
;*                                                      *
;*      INPUT:  UNIT NUMBER                             *
;*      OUTPUT: RETUEN BYTE                             *

;*              1:UNKOWN  0:NOT CHANGED  -1:CHANGED     *
;*                                                      *
;********************************************************
IF BRANCH ;-------------------------------------------- 871002 -------
;****************************************
;*                                      *
;*      HERE, UNIT VIRTUAL              *
;*                                      *
;****************************************
MEDIA_VIRTUAL:
        MOV     AL,VDSK_AI      ;GET CONTROL INFORMATION
        MOV     CL,CURUA        ;GET UNIT ADDRESS
        AND     CL,07H
        MOV     AH,01H
        SHL     AH,CL
        TEST    AL,AH           ;CURRENT READY ?
        JNE     MEDIA_VT10
;       NOT READY !!
        MOV     AX,2
        JMP     DSK_ERR_EXIT    ;NOT CHANGED
MEDIA_VT10:
        MOV     AH,10H
        SHL     AH,CL           ;MAKE ATTENTION BIT
        TEST    AL,AH           ;ATTENTION HAPPENED ?
        JNE     MEDIA_VT20
;       NOT ATTENTION !!
        MOV     AH,1                    ;850507 (AX -> AH) "NOT CHANGED"
        JMP     DSKCHG_OK
;
;       READY AND ATTENTION !!
;
MEDIA_VT20:
        CALL    MV_GET_TYP              ;850510 GET VOLUME TYPE **
        CMP     AL,5                    ;HARD DISK
        JB      MEDIA_VT30
;
;-----LOAD CURRENT HARD BPB IMAGE
;
        CALL    HARDBPB
        JC      MEDIA_VT40
MEDIA_VT30:
        MOV     AH,-1                   ;850506 SET CHANGED CODE
        JMP     DSKCHG_OK
MEDIA_VT40:
        MOV     AX,2
        JMP     DSK_ERR_EXIT

MV_GET_TYP:     MOV     SI,OFFSET VDSK_TYP      ;SET VIRTUAL DISK TYPE OFFSET
                MOV     AL,[CURUA]              ;
                AND     AX,0007H                ;
                ADD     SI,AX                   ;
                CLD                             ;
                LODSB                           ;
                RET                             ;
ENDIF   ;-------------------------------------------------------------



;****************************************
;*                                      *
;*      HERE, UNIT IS SASI HD           *
;*                                      *
;****************************************
MEDIA_HD:
        MOV     AH,01H          ;SET RETURN BYTE, NOT CHANGED
        JMP     short DSKCHG_OK

;****************************************
;*                                      *
;*      END OF MEDIA CHECK              *
;*                                      *
;****************************************
DSKCHG_OK:
        CMP     AH,1                    ;MEDIA CHANGED ?
        JZ      DSKCHG_OK10             ; CHANGED/DON'T KNOW
        PUSH    AX
        CALL    SET_IDPTR               ;SET VOLUME ID POINTER
        POP     AX
        JMP     SHORT DSKCHG_OK20
DSKCHG_OK10:
        LDS     BX,[PTRSAV]
DSKCHG_OK20:
        MOV     BYTE PTR [BX.TRANS],AH  ;SET RETURN BYTE
;----------------------------------------------- DOS5 90/02/23 -------
;       JMP     EXIT_FAR                                ;
        JMP     EXIT
;---------------------------------------------------------------------

;****************************************
;*                                      *
;*      SET VOLUME ID                   *
;*      (DOS 3.XX ENHANCEMENT)          *
;*                                      *
;****************************************
SET_IDPTR:
;--------------------------------------------------------- 88/05/30 --
;       MOV     AL,CURDRV       ;GET CURRENT DRIVE NUMBER
;       MOV     AH,12
;       MUL     AH              ;CAL 12*CURDRV
;       MOV     DI,OFFSET VOLTABLE
;       ADD     DI,AX
;---------------------------------------------------------------------
        MOV     AL,CURDRV
        CALL    SetDrive
        LEA     BX,[DI].BDS_VOLID
        LDS     BX,[PTRSAV]
        MOV     WORD PTR [BX.TRANS+1],DI ;SET OFFSET
        MOV     WORD PTR [BX.TRANS+3],CS ;SET SEGMENT
        RET


;********************************************************
;                                                       *
;       GET APROPRIATE BPB ADDR                         *
;        INPUT  : DRIVE NUMBER                          *
;               : POINT TO BUFFET WHICH READ FAT-ID     *
;        OUTPUT : POINT TO TRUE BPB                     *
;                                                       *
;********************************************************

IF BRANCH       ;------------------------------------ 871002 ---------
GET_VTBPB:
;
;       SET APROPRIATE ADDR OF VIRTUAL
;
        CALL    SUBVTB
        MOV     BL,[CURUA]              ;850516(I)
        AND     BL,03H                  ;850516(I)
        MOV     CL,BL                   ;850516(I)
        MOV     BL,10H                  ;850516(I)
        SHL     BL,CL                   ;850516(I)
        XOR     [VDSK_AI],BL            ;850516(I) STRIP AI FALG
        MOV     AL,[SI+BPB_MDA]         ;850507 GET (NEW)MEDIA DISCRIPTOR
        ret                             ;
ENDIF   ;-------------------------------------------------------------
;
;       SET APROPRIATE ADDR OF SASI HD
;
GET_HD:
        CALL    CALLOG
        XOR     AL,AL
        ret                             ;

;****************************************
;*                                      *
;*      HD READ/WRITE SUBROUTINE        *
;*                                      *
;****************************************

CMN_RW_HD:
        CMP     LNG_TRNS,0              ;TRANSFER LENGTH = 0 ?
        JNZ     CMNPHASE10
        JMP     RW_RET                  ;SKIP IF SO(NOT DONE)
CMNPHASE10:
;--------------------------------------------------------- 90/03/16 --
        PUSH    AX
        PUSH    BX
        PUSH    CX
        XOR     BX,BX
        MOV     AL,CURUA
        OR      AL,CURDA
        MOV     BX,OFFSET EXLPTBL+1
        XOR     CX,CX
CMNPHASE20:
        CMP     BYTE PTR [BX],AL
        JE      CMNPHASE30
        INC     BX
        INC     BX
        INC     CX
        JMP     CMNPHASE20
CMNPHASE30:
        MOV     AL,CURDRV
        SUB     AL,CL
        MOV     VOLNUM,AL
        POP     CX
        POP     BX
        POP     AX
;---------------------------------------------------------------------
        MOV     RTRY_CNT,AH             ;SAVE IT
        CALL    CONV_REC
        MOV     AH,RTRY_CNT             ;RESET IT
        JMP     HD_RW

DB_ERR_DB:
        CLD
        CMP     BYTE PTR RW_SW,0        ;READ ?
        JE      DB_ERR_DB10
        JMP     short DB_W              ;JUMP IF NOT
DB_ERR_DB10:
        PUSH    ES
        PUSH    BP
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     ES,CS:[BDATA_SEG]
;-----------------
;       PUSH    CS
;       POP     ES                      ;ES <= CS
;---------------------------------------------------------------------
        MOV     BP,OFFSET DSK_BUF2      ;BUFFER 1K --> 2K       88/05/06
        CALL    DB_RW
        POP     BP
        POP     ES
        JNC     DB_ERR_DB20
        JMP     short ERROR1
DB_ERR_DB20:
        MOV     SI,OFFSET DSK_BUF2      ;BUFFER 1K --> 2K       88/05/06
        MOV     DI,BP
        PUSH    CX
        MOV     CX,BX                   ;SET TRANSFER LENGTH
        CLD
        REP     MOVSB
        POP     CX
        RET

DB_W:
        PUSH    ES
        PUSH    DS
        PUSH    ES
        POP     DS                      ;DS <= ES
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     ES,CS:[BDATA_SEG]
;------------------
;       PUSH    CS
;       POP     ES                      ;ES <= CS
;---------------------------------------------------------------------
        MOV     SI,BP
        MOV     DI,OFFSET DSK_BUF2      ;BUFFER 1K --> 2K       88/05/06
        PUSH    CX
        MOV     CX,BX                   ;SET TRANSFER LENGTH
        REP     MOVSB
        POP     CX
        POP     DS
        PUSH    BP
        MOV     BP,OFFSET DSK_BUF2      ;BUFFER 1K --> 2K       88/05/06
        CALL    DB_RW
        POP     BP
        POP     ES
        JNC     DB_W10
        JMP     short ERROR1
DB_W10:
        RET

ERROR1:
        POP     CX                      ;DUMMY POP

;****************************************
;*                                      *
;*      MAKE ERROR CODE                 *
;*      WHICH MS-DOS REQUESTS           *
;*                                      *
;****************************************

ERROR:
;----------------------------------------------- 871010 --------------
        CALL    ERR_SUB                 ;SET AI FLAG
;---------------------------------------------------------------------
        AND     AH,0F0H                 ;MASK HIGH BITS
        XOR     AL,AL                   ;CLEAR AL
        CMP     AH,70H                  ;NOT WRITABLE ?
        JE      ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=1
        CMP     AH,60H                  ;NOT READY ?
        JE      ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=2
        CMP     AH,0A0H                 ;DATA ERROR ?
        JE      ERR_RET                 ;SKIP IF SO  
        CMP     AH,0B0H                 ;DATA ERROR ?
        JE      ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=3
        CMP     AH,0C0H                 ;SEEK ERROR  ?
        JE      ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=4
        CMP     AH,0D0H                 ;SECTOR NOT FOUND ?
        JAE     ERR_RET                 ;SKIP IF SO
        INC     AL                      ;AL=5
        CMP     RW_SW,0                 ;READ ?
        JE      SKP_WRT_FLT             ;SKIP IF SO
        CMP     AH,40H                  ;WRITE  FAULT ?
        JE      ERR_RET                 ;SKIP IF SO
SKP_WRT_FLT:
        INC     AL                      ;AL=6
ERR_RET:
        SHL     AL,1                    ;SET ERROR CODE
ERR_RET1:
        MOV     CX,LNG_TRNS
        ADD     CX,CUR_TRNS
        ADD     CX,NO_TRNS
        CALL    STOP_CHK
        STC
        RET

;------------------------------------------------ 871010 -------------
;****************************************
;*                                      *
;*      SET AI FLAG                     *
;*                                      *
;****************************************
ERR_SUB:
        PUSH    AX
;------------------------------------------------ PATCH FIX 88/02/25 -
        AND     AL,70H
        CMP     AL,70H
        POP     AX
        PUSH    AX
;
;       TEST    AL,80H                  ;MEDIA ?
;----------------------------------------------------------------------
        JNZ     ERR8                    ;JUMP IF 1MB MEDIA
ERR5:                   ;SET 640KB MEDIA'S AI FLAG
        MOV     BX,OFFSET F2DD_RESULT   ;2DD RESULT AREA OFFSET
        MOV     CL,1                    ;SHIFT COUNT
        JMP     SHORT ERR_COMMON

ERR8:                   ;SET 1.2MB MEDIA'S AI FLAG
        MOV     BX,OFFSET DISK_RESULT   ;2HD RESULT AREA OFFSET
        MOV     CL,3                    ;SHIFT COUNT
ERR_COMMON:
        AND     AL,0FH                  ;ONLY UA
        SHL     AL,CL                   ;WORD(2DD) OR QWORD(3HD)
        MOV     CL,AL
        XOR     CH,CH
        ADD     BX,CX

        PUSH    ES
;------------------------------------------------ PATCH FIX 88/02/25 -
        XOR     CX,CX
        MOV     ES,CX                   ;SEGMENT 0
;---------------------------------------------------------------------
        OR      BYTE PTR ES:[BX],0C0H   ;SET 'AI' FLAG
        POP     ES
        POP     AX
        RET


;****************************************
;*                                      *
;*      SET BIOS INTERFACE PARAMETER    *
;*                                      *
;****************************************

CONV_REC:
        MOV     [DSK_TYP],0             ;SINGLE SIDED
        MOV     [COM],00H               ;COMMAND OF HARD
;--------------------------------------------------------- 88/05/07 --
IF BRANCH ;----------------------------------------------- 90/03/16 --
        TEST    CURUA,08H               ;
        JZ      CONV_REC10
        MOV     [LNG_SEC],1024
        JMP     CONV_REC30
ENDIF ;---------------------------------------------------------------
CONV_REC10:
;--------------------------------------------------------- 90/03/16 --
        PUSH    AX
        PUSH    BX
        PUSH    CX
        MOV     BX,OFFSET HDDSK5_1
        CMP     CURDA,80H
        JZ      CONV_REC20
        MOV     BX,OFFSET HDDSKS_1
CONV_REC20:
        XOR     AH,AH
        MOV     AL,CURUA
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     CL,HDDSK_SIZE
;------------------
;       MOV     CL,34H
;---------------------------------------------------------------------
        MUL     CL
        ADD     BX,AX
        XOR     AH,AH
        MOV     AL,VOLNUM
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     CL,BPB_SIZE
;------------------
;       MOV     CL,13
;---------------------------------------------------------------------
        MUL     CL
        ADD     BX,AX
        MOV     AX,WORD PTR [BX]
        MOV     [LNG_SEC],AX
        POP     CX
        POP     BX
        POP     AX
;----------------------------------------------------------------------
;       PUSH    AX
;       PUSH    BX
;       MOV     BX,OFFSET HDDSK5_1      ;SASI #0 BPB
;       CMP     CURUA,00H               ;SASI #0?
;       JZ      CONV_REC20              ;YES
;       MOV     BX,OFFSET HDDSK5_2      ;SASI #1 BPB
;       CMP     CURUA,01H               ;SASI #1?
;       JZ      CONV_REC20              ;YES
;       MOV     BX,OFFSET HDDSK5_3      ;SASI #2 BPB
;       CMP     CURUA,02H               ;SASI #2?
;       JZ      CONV_REC20              ;YES
;       MOV     BX,OFFSET HDDSK5_4      ;SASI #3 BPB
;CONV_REC20:
;-----------------------------------------------------  89/07/28  ---
;       PUSH    CX
;       PUSH    BX
;       MOV     AL,BYTE PTR [CURUA]
;       OR      AL,BYTE PTR [CURDA]
;       MOV     BX,OFFSET EXLPTBL+1
;       XOR     CX,CX
;CONV_REC24:
;       CMP     BYTE PTR [BX],AL
;       JZ      CONV_REC27
;       INC     BX
;       INC     BX
;       INC     CX
;       JMP     CONV_REC24
;CONV_REC27:
;       MOV     AL,BYTE PTR [CURDRV]
;       SUB     AL,CL
;       XOR     AH,AH
;       MOV     CL,0DH                  ;BPB SIZE
;       MUL     CL
;       POP     BX
;       ADD     BX,AX
;       POP     CX
;-----------------------------------------------------  89/07/28  ---
;       MOV     AX,WORD PTR [BX]        ;COPY BYTE PER SEC IN BPB
;       MOV     [LNG_SEC],AX            ;8"2D, 5"HD
;CONV_REC30:
;       POP     BX
;       POP     AX
;       MOV     [LNG_SEC],1024          ;8"2D, 5"HD
;---------------------------------------------------------------------
        MOV     [S_SEC],8               ;8"2D, 5"2D(8), 5"2DD(8)
        MOV     AL,[PWINF]              ;SET DA/UA
        RET

VERIFY:
        CMP     BYTE PTR VRFY_FLG,0     ;VERIFY FLG ON ?
        JE      V_RET                   ;SKIP IF NO
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     BYTE PTR RTRY_CNT,5     ;SET RETRY TIMES
;------------------
;       MOV     BYTE PTR RTRY_CNT,3     ;SET RETRY TIMES
;---------------------------------------------------------------------
VRFY_ENT:
        PUSH    BP
        PUSH    ES
        XOR     BP,BP
        MOV     ES,BP
        MOV     AH,01H
        OR      AH,COM                  ;FORCE TO READ
        CALL    ROMBIO
        POP     ES
        POP     BP
        JC      VRFY_ERR
V_RET:
        RET
VRFY_ERR:
        DEC     BYTE PTR RTRY_CNT       ;DECREMENT RETRY COUNTER
        JZ      VRFY_ERR1
        CALL    RCBL                    ;EXECUTE RECALIBLATE
        JMP     VRFY_ENT
VRFY_ERR1:
        POP     CX
        JMP     ERROR

;
;       SET  COMMAND
;
S_HCMD:
        MOV     AL,CURUA
        OR      AL,CURDA
        AND     AL,7FH
        MOV     AH,COM
        OR      AH,COM1
        CALL    ROMBIO
        RET

;------------------------------------------------ DB ERROR PROC ------
DB_RW:
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     BYTE PTR RTRY_CNT,5
;------------------
;       MOV     BYTE PTR RTRY_CNT,3
;---------------------------------------------------------------------
DB_LOOP_HD:                             ;---------------------- BY MAMA -
        CALL    S_HCMD                  ;HD I/O --------------- BY MAMA -
        JNC     DB_RET                  ;NO ERROR ------------- BY MAMA -
        DEC     [RTRY_CNT]              ;---------------------- BY MAMA -
        JZ      DB_ERET                 ;RETRY IS OVER -------- BY MAMA -
        CALL    RCBL                    ;RECALIBRATE ---------- BY MAMA -
        JMP SHORT DB_LOOP_HD            ;RETRY ! -------------- BY MAMA -
DB_ERET:
        STC
DB_RET:
        RET

COMP_DB:
        PUSH    AX
        PUSH    CX
        PUSH    DX
        MOV     DX,ES                   ;GET I/O BUFFER SEGMENT
        MOV     CL,4
        SHL     DX,CL
        ADD     DX,BP
        MOV     AX,0FFFFH
        SUB     AX,DX                   ;REST BYTES UNTIL DB ERROR
        XOR     DX,DX
        DIV     WORD PTR LNG_SEC        ;GET TRANSFER LENGTH IN AX
        MOV     DB_TRNS,AX              ;SAVE IT
        MUL     WORD PTR LNG_SEC
        MOV     BX,AX
        POP     DX
        POP     CX
        POP     AX
        RET


RW_RET:
        CALL    STOP_CHK
        XOR     CX,CX
        RET


;****************************************
;*                                      *
;*      HARD DISK READ/WRITE            *
;*                                      *
;****************************************

HD_RW:
        MOV     NO_TRNS,0               ;CLEAR NON-TRANSFED LENGTH FIELD
;--------------------------------------------------------- 90/03/16 --
;       XOR     BX,BX                   ;CLEAR BX
;       MOV     AL,CURUA                ;SET CURRENT UA
;       OR      AL,CURDA                ;MAKE DA/UA 
;       MOV     BX,OFFSET EXLPTBL+1     ;SET CONVERTING TABLE
;       XOR     CX,CX
;HD_RW10:
;       CMP     BYTE PTR[BX],AL         ;FIND FIRST SAME DA/UA
;       JE      HD_RW20                 ;SKIP IF HIT
;       INC     BX
;       INC     BX                      ;POINT NEXT ENTRY
;       INC     CX                      ;INCREMENT COUNTER
;       JMP     HD_RW10
;HD_RW20:
;       MOV     AL,CURDRV
;       SUB     AL,CL                   ;GET RELATIVE VOLUME NUMBER IN DEV
;       MOV     VOLNUM,AL               ;SAVE IT
;---------------------------------------------------------------------
IF BRANCH ;----------------------------------------------- 90/03/16 --
        MOV     SI,OFFSET VT_LAST       ;850505
        CALL    GET_VT                  ;850505
        TEST    CURUA,08H
        JNE     HD_RW30
ENDIF ;---------------------------------------------------------------
;--------------------------------------------------------- 88/03/26 --
;--------------------------------------------------------- 90/03/16 --
        MOV     BX,OFFSET HD_LAST
        CMP     CURDA,80H
        JZ      HD_RW10
        MOV     BX,OFFSET HDS_LAST
HD_RW10:
        XOR     AH,AH
        MOV     AL,CURUA
        SHL     AL,1
        SHL     AL,1
        SHL     AL,1
        SHL     AL,1
        ADD     BX,AX
        MOV     AL,VOLNUM
        SHL     AL,1
        SHL     AL,1
        ADD     BX,AX
        MOV     CX,LNG_TRNS
;----------------------------------------------------------------------
;       MOV     BX,OFFSET HD_LAST       ;SET VOL SIZE TABLE ADDR
;       CMP     CURUA,00H               ;#0 ?
;       JZ      HD_RW30                 ;SKIP IF DEV=#0
;       MOV     BX,OFFSET HD1_LAST      ;SET VOL SIZE TABLE ADDR
;       CMP     CURUA,01H               ;#1 ?
;       JZ      HD_RW30                 ;SKIP IF DEV=#1
;       MOV     BX,OFFSET HD2_LAST      ;SET VOL SIZE TABLE ADDR
;       CMP     CURUA,02H               ;#2 ?
;       JZ      HD_RW30                 ;SKIP IF DEV=#2
;       MOV     BX,OFFSET HD3_LAST      
;---------------------------------------------------------------------
;HD_RW30:
;       MOV     CX,LNG_TRNS
;       SHL     AL,1                    ;DWORD POINTER
;       SHL     AL,1
;       XOR     AH,AH                   ;CLEAR AH
;       ADD     BX,AX
;----------------------------------------------------------------------
        CMP     DX,[BX]                 ;REQUESTED START SECTOR IN THIS VOL ?
        JMP     SHORT   STRT_SEC_OK             ;1024.                 
;
;       FAIL TO I/O...
;
        MOV     NO_TRNS,CX
        MOV     LNG_TRNS,0
        JMP     HD_RW_RET               ;ERROR RETURN (NO DONE)
;
STRT_SEC_OK:
        ADD     CX,DX
        SUB     CX,[BX]                 ;REQUESTED LAST SECTOR IN THIS VOL ?
        JMP     SHORT  SEC_OK                  ;        
        MOV     NO_TRNS,CX
        SUB     LNG_TRNS,CX             ;SET TRANSING DATA LENGTH
;
;       FINISH TO CHECK REQUESTED SECTOR NUMBER
;
SEC_OK:
        MOV     CX,LNG_TRNS             ;GET TRANSFERING DATA LENGTH
        MOV     CUR_TRNS,CX
;--------------------------------------------------------- 90/03/16 --
;       MOV     CL,VOLNUM
;       XOR     CH,CH
;       SHL     CL,1                    ; CL=CL*4, ENTRY HAS 4 BYTE
;       SHL     CL,1
IF BRANCH ;----------------------------------------------- 90/03/16 --
        MOV     SI,OFFSET VT_OFFSET     ;850505
        CALL    GET_VT                  ;850505
        CALL    GET_VBPS                ;850505 GET B.P.S INTO (SI)
        TEST    CURUA,08H
        JNE     SEC_OK10
ENDIF ;---------------------------------------------------------------
;--------------------------------------------------------- 88/03/26 --
;       MOV     SI,BPS                  ;850507 SET BYTE/SECTOR IN DEV #0
;       MOV     BX,OFFSET HD_OFFSET
;       CMP     CURUA,00H               ;#0 DEV
;       JZ      SEC_OK10                ;SKIP IF DEV=#0
;       MOV     SI,BPS1                 ;850507 SET BYTE/SECTOR IN DEV #1
;       MOV     BX,OFFSET HD1_OFFSET
;       CMP     CURUA,01H               ;#1 DEV
;       JZ      SEC_OK10                ;SKIP IF DEV=#1
;       MOV     SI,BPS2                 ;850507 SET BYTE/SECTOR IN DEV #2
;       MOV     BX,OFFSET HD2_OFFSET
;       CMP     CURUA,02H               ;#2 DEV
;       JZ      SEC_OK10                ;SKIP IF DEV=#2
;       MOV     SI,BPS3                 ;SET BYTE PER SECTOR IN DEV #3
;       MOV     BX,OFFSET HD3_OFFSET
;---------------------------------------------------------------------
        MOV     SI,OFFSET BPS
        MOV     BX,OFFSET HD_OFFSET
        CMP     CURDA,80H
        JZ      SEC_OK05
        MOV     SI,OFFSET BPSS
        MOV     BX,OFFSET HDS_OFFSET
SEC_OK05:
        XOR     CH,CH
        MOV     CL,CURUA
        SHL     CX,1
        ADD     SI,CX
        MOV     SI,[SI]
        SHL     CX,1
        SHL     CX,1
        SHL     CX,1
        ADD     BX,CX
        XOR     CH,CH
        MOV     CL,VOLNUM
        SHL     CX,1
        SHL     CX,1
        ADD     BX,CX
;SEC_OK10:
;       ADD     BX,CX                   ;POINT CURRENT OFFSET TABLE
;--------------------------------------------------------- 88/04/19 --
IF BRANCH ;----------------------------------------------- 90/03/16 --
        TEST    CURUA,08H               ;
        JZ      SEC_OK12
        MOV     CX,4
        JMP     SEC_OK14
ENDIF ;---------------------------------------------------------------
SEC_OK12:
        PUSH    AX
        PUSH    BX
        PUSH    DX
;--------------------------------------------------------- 90/03/16 --
;       MOV     BX,OFFSET HDDSK5_1      ;SASI #0 BPB
;       CMP     CURUA,00H               ;SASI #0?
;       JZ      SEC_OK13                ;YES
;       MOV     BX,OFFSET HDDSK5_2      ;SASI #1 BPB
;       CMP     CURUA,01H               ;SASI #1?
;       JZ      SEC_OK13                ;YES
;       MOV     BX,OFFSET HDDSK5_3      ;SASI #2 BPB
;       CMP     CURUA,02H               ;SASI #2?
;       JZ      SEC_OK13                ;YES
;       MOV     BX,OFFSET HDDSK5_4      ;SASI #3 BPB
;SEC_OK13:

        MOV     BX,OFFSET HDDSK5_1
        CMP     CURDA,80H
        JZ      SEC_OK13
        MOV     BX,OFFSET HDDSKS_1
SEC_OK13:
        XOR     AH,AH
        MOV     AL,CURUA
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     CL,HDDSK_SIZE
;------------------
;       MOV     CL,34H
;---------------------------------------------------------------------
        MUL     CL
        ADD     BX,AX
;-----------------------------------------------------  89/07/28  ---
        XOR     AH,AH
        MOV     AL,BYTE PTR [VOLNUM]
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     CL,BPB_SIZE
;------------------
;       MOV     CL,0DH          ;BPB SIZE
;---------------------------------------------------------------------
        MUL     CL
        ADD     BX,AX
;-----------------------------------------------------  89/07/28  ---
        MOV     AX,WORD PTR [BX]        ;COPY BYTE PER SEC IN BPB
        MOV     [SVBPS],AX              ;SAVE BYTE PER SEC
        MOV     BX,256
        XOR     DX,DX
        DIV     BX
        MOV     CX,AX
        POP     DX
        POP     BX
        POP     AX
SEC_OK14:
;------------------------------------------------
;       MOV     CX,4
;---------------------------------------------------------------------
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     OLD_DX,DX               ;SAVE START SEC LOW
        MOV     AX,START_SEC_H          ;CALCULATE HIGH WORD FIRST
        XOR     DX,DX
        MUL     CX
        MOV     OLD_AX,AX               ;SAVE RESULT HIGH
        MOV     AX,OLD_DX               ;THEN CALCULATE LOW WORD
        XOR     DX,DX
        MUL     CX
        ADD     DX,OLD_AX               ;RESULT IN DX:AX
;------------------
;       MOV     AX,DX                   ;SET START SECTOR
;       XOR     DX,DX
;       MUL     CX                      ;1024. -> 256.
;---------------------------------------------------------------------
        ADD     AX,[BX]
        ADC     DX,[BX+2]               ;REP BY 256 BPS
SEC_OK15:
        MOV     CX,AX                   ;(DX.CX) IS NUMBER OF SECTOR

HD_LOOP:
        CMP     CUR_TRNS,64             
        JBE     L_OK                    ;SKIP IF CUR_TRNS < 64K
        MOV     CUR_TRNS,64             
L_OK:
        PUSH    CX
;--------------------------------------------------------- 88/04/21 --
        XOR     CX,CX
        MOV     AX,SVBPS
L_OK10:
        CMP     AX,0001H
        JZ      L_OK20
        SHR     AX,1
        INC     CL
        JMP     L_OK10
L_OK20:
;       MOV     CL,10
;---------------------------------------------------------------------
        MOV     AX,CUR_TRNS
        MOV     BX,AX
        SHL     BX,CL
        SUB     LNG_TRNS,AX
        POP     CX
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     BYTE PTR RTRY_CNT,5     ;SET RETRY TIMES
;------------------
;       MOV     BYTE PTR RTRY_CNT,3     ;SET RETRY TIMES
;---------------------------------------------------------------------
RW_LOOP_HD:
        CALL    S_HCMD                  ;SET BIO PARAMETER
        JC      RTRY_RW_HD
        CALL    VERIFY
HD_RW_ENT:
        CMP     WORD PTR LNG_TRNS,0
        JE      HD_RW_RET
        MOV     AX,CUR_TRNS
HD_RW_SKIP:
;--------------------------------------------------------- 88/04/19 --
        PUSH    CX
        MOV     CX,SVBPS
HD_RW_10:
        CMP     CX,256
        JZ      HD_RW_20
        SHL     AX,1                    ;n KB/SEC --> 256 B/S
        SHR     CX,1
        JMP     HD_RW_10
HD_RW_20:
        POP     CX
        CLC
;----------------------------
;       SHL     AX,1
;       SHL     AX,1
;---------------------------------------------------------------------
        ADD     CX,AX
        ADC     DX,0                    ;10-25-85
        MOV     AX,LNG_TRNS
        MOV     CUR_TRNS,AX
        CLC
        ADD     BP,BX
        PUSH    AX
        MOV     AX,ES
        JNB     HD_BOUN
        ADD     AX,1000H
        MOV     ES,AX
HD_BOUN:
        POP     AX
        JMP     HD_LOOP

HD_RW_RET:
        CMP     NO_TRNS,0
        JE      NO_ERR_HD
        MOV     CUR_TRNS,0
        MOV     AH,0C0H
        JMP     ERROR
NO_ERR_HD:
        JMP     RW_RET
RTRY_RW_HD:
;------------------------------------------ DB ERR CHECK ---------
        AND     AH,0F0H
        CMP     AH,20H                  ;DB ERROR ?
        JE      DB_ERR_HD               ;YES,
;-----------------------------------------------------------------
        DEC     BYTE PTR RTRY_CNT       ;DECREMENT RETRY COUNTER
        JE      HD_ERROR
        CALL    RCBL
        JMP     RW_LOOP_HD

;------------------------------------------ DB ERROR PROC --------
DB_ERR_HD:
        CALL    COMP_DB
        OR      BX,BX
        JZ      SKP_PRER_HD
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     [RTRY_CNT],5
;------------------
;       MOV     [RTRY_CNT],3
;---------------------------------------------------------------------
RTRY_PRER:
        CALL    S_HCMD                  ;CHG "S_CMD" >> "S_HCMD" --BY MAMA--
        JNC     PRER_OK
        DEC     [RTRY_CNT]
        JZ      HD_ERROR
        CALL    RCBL
        JMP     SHORT   RTRY_PRER
HD_ERROR:
        JMP     ERROR
PRER_OK:
        CALL    VERIFY
        MOV     AX,[DB_TRNS]
        SUB     [CUR_TRNS],AX
;--------------------------------------------------------- 88/04/19 --
        PUSH    CX
        MOV     CX,SVBPS
PRER_OK02:
        CMP     CX,256
        JZ      PRER_OK04
        SHL     AX,1                    ;n KB/SEC --> 256 B/S
        SHR     CX,1
        JMP     PRER_OK02
PRER_OK04:
        POP     CX
;-----------------------------
;       SHL     AX,1
;       SHL     AX,1
;---------------------------------------------------------------------
PRER_OK05:
        CLC
        ADD     CX,AX
        ADC     DX,0                    ;10-23-85
        ADD     BP,BX
SKP_PRER_HD:
        MOV     BX,SVBPS                ;1024 --> SVBPS         88/04/21
        CALL    DB_ERR_DB
        CALL    VERIFY
;--------------------------------------------------------- 88/04/21 --
        PUSH    AX
        PUSH    BX
        PUSH    DX
        MOV     AX,SVBPS
        MOV     BX,256
        XOR     DX,DX
        DIV     BX
        POP     DX
        POP     BX
        CLC
        ADD     CX,AX
        POP     AX

;       ADD     CX,4                    ;86-08-20
;---------------------------------------------------------------------
        ADC     DX,0                    ;10-23-85
        DEC     [CUR_TRNS]
        JNZ     SKP_RWDB_HD
        JMP     HD_RW_ENT
SKP_RWDB_HD:
        ADD     BP,BX
        PUSH    CX
;--------------------------------------------------------- 88/04/21 --
        PUSH    AX
        XOR     CX,CX
        MOV     AX,SVBPS
SKP_RWDB_HD10:
        CMP     AX,0001H
        JZ      SKP_RWDB_HD20
        SHR     AX,1
        INC     CL
        JMP     SKP_RWDB_HD10
SKP_RWDB_HD20:
        POP     AX
;       MOV     CL,10
;---------------------------------------------------------------------
        MOV     BX,[CUR_TRNS]
        SHL     BX,CL
        POP     CX
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     [RTRY_CNT],5
;------------------
;       MOV     [RTRY_CNT],3
;---------------------------------------------------------------------
REAR_HD:
        CALL    S_HCMD                  ;CHG "S_CMD" >> "S_HCMD" --BY MAMA--
        JNC     SKP_RW2_HD
        DEC     [RTRY_CNT]
        JZ      HD_ERROR
        CALL    RCBL
        JMP     SHORT   REAR_HD
SKP_RW2_HD:
        CALL    VERIFY
        JMP     HD_RW_ENT

;------------------------------------------------ BY MAMA ----------

CALLOG:
        MOV     AL,CURUA                ;SET CURRENY UA
        OR      AL,CURDA                ;MSKE DA/UA
        MOV     BX,OFFSET EXLPTBL+1     ;SET CONVERTING TABLE
        XOR     CX,CX                   ;CLEAR CX
CALLOG10:
        CMP     BYTE PTR[BX],AL         ;FIND FIRST SAME DA/UA
        JE      CALLOG20                ;SKIP IF MATCH
        INC     BX
        INC     BX
        INC     CX
        JMP     CALLOG10
CALLOG20:
        MOV     AL,CURDRV
        SUB     AL,CL                   ;GET RELATIVE VOLUME NUMBER IN DEV
        MOV     BYTE PTR [VOLNUM],AL    ;               90/03/16
IF BRANCH ;----------------------------------------------- 90/03/16 --
        TEST    [CURUA],08H             ;850505 VIRTUAL ?
        JZ      CALLOG30X               ;850505 NO,
        MOV     BX,OFFSET VBPB          ;850505
        MOV     AL,[CURUA]              ;850505
        AND     AL,07H                  ;850505
        JMP     CALLOG30                ;850505
CALLOG30X:                              ;850505
ENDIF ;---------------------------------------------------------------
;--------------------------------------------------------- 88/03/26 --
;       MOV     BX,OFFSET HDDSK5_1
;       CMP     CURUA,00H
;       JZ      CALLOG30                ;SKIP IF DEV=#0
;       MOV     BX,OFFSET HDDSK5_2
;       CMP     CURUA,01H
;       JZ      CALLOG30                ;SKIP IF DEV=#1
;       MOV     BX,OFFSET HDDSK5_3
;       CMP     CURUA,02H
;       JZ      CALLOG30                ;SKIP IF DEV=#2
;       MOV     BX,OFFSET HDDSK5_4
;---------------------------------------------------------------------
        MOV     BX,OFFSET HDDSK5_1
        CMP     CURDA,80H
        JZ      CALLOG30
        MOV     BX,OFFSET HDDSKS_1
CALLOG30:
        XOR     AH,AH
        MOV     AL,CURUA
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     CL,HDDSK_SIZE
;------------------
;       MOV     CL,34H
;---------------------------------------------------------------------
        MUL     CL
        ADD     BX,AX
        XOR     AH,AH
        MOV     AL,[VOLNUM]
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     CL,BPB_SIZE
;------------------
;       MOV     CL,13
;---------------------------------------------------------------------
        MUL     CL
        ADD     BX,AX
        MOV     SI,BX
;----------------------------------------------- DOS5 90/12/14 -------
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DI,OFFSET BPBCOPY
        PUSH    DI

        MOV     CX,13                   ;SIZE OF OLD BPB
        REP     MOVSB
        PUSH    SI

        MOV     SI,OFFSET SPT
        CMP     CURDA,80H
        JZ      CALLOG31
        MOV     SI,OFFSET SPTS
CALLOG31:
        MOV     CL,CURUA
        XOR     CH,CH
        ADD     SI,CX
        MOVSB                           ;SET SECTORS/TRACK
        MOV     AL,0
        STOSB

        MOV     SI,OFFSET TPC
        CMP     CURDA,80H
        JZ      CALLOG32
        MOV     SI,OFFSET TPCS
CALLOG32:
        MOV     CL,CURUA
        XOR     CH,CH
        ADD     SI,CX
        MOVSB                           ;SET HEADS/CYLINDER
        MOV     AL,0
        STOSB

        MOV     SI,OFFSET HD_OFFSET
        CMP     CURDA,80H
        JZ      CALLOG33
        MOV     SI,OFFSET HDS_OFFSET
CALLOG33:
        MOV     AL,CURUA
        XOR     AH,AH
        MOV     CL,10H
        MUL     CL
        ADD     SI,AX
        MOV     AL,[VOLNUM]
        XOR     AH,AH
        SHL     AX,1
        ADD     SI,AX
;----------------------------------------------- DOS5 91/11/02 -------
;<patch BIOS50-P06>
        jmp     patch2
db      90h
        public  patch2_end
patch2_end:
;---------------
;       MOV     CX,2
;       MOVSW                           ;SET HIDDEN SECTORS
;--------------------------------------------------------------------
        POP     SI
        MOV     CX,2
        REP     MOVSW                   ;SET BIG TOTAL SECTORS

        POP     SI                      ;SET ADDR OF BPBCOPY
        POP     ES
;---------------------------------------------------------------------
CALLOG35:
        CMP     CURDA,0A0H
        JZ      CALLOG40
        CALL    GET_SW                  ;850505
        MOV     BYTE PTR [DI],0         ;850505 CLEAR SWITCH
        CMP     WORD PTR [SI],1024      ;850505 CHECK B.P.S.
        JE      CALLOG40                ;850505
        MOV     BYTE PTR[DI],-1         ;850505 SET X2-ID.
CALLOG40:
        RET
IF BRANCH ;----------------------------------------------- 90/03/16 --
;850505.850505.850505.850505.850505......
;                                       .
;       FOR VIRTUAL DRIVE               .
;                                       .
;......850505.850505.850505.850505.850505

GET_VT:
;......
        MOV     BL,[CURUA]
        AND     BX,0007H
        SHL     BX,1
        SHL     BX,1
        ADD     BX,SI
        RET

GET_VBPS:
;........
        PUSH    BX
        MOV     BL,[CURUA]
        AND     BX,0007H
        SHL     BX,1
        MOV     SI,[BX.VBPS]
        POP     BX
        RET

CHECK_X2SW:
;..........
        PUSH    BX
        PUSH    SI
        MOV     BL,[CURUA]
        TEST    BL,08H
        JZ      CHK_SW1
        AND     BX,0007H
        LEA     SI,[BX.X2_SW_VT]
        JMP     SHORT CHK_SW2
CHK_SW1:
        MOV     SI,OFFSET X2_SW_00
        TEST    BL,01H
        JZ      CHK_SW2
        MOV     SI,OFFSET X2_SW_01
CHK_SW2:
        TEST    BYTE PTR [SI],-1
        POP     SI
        POP     BX
        RET
ENDIF ;----------------------------------------------------------------

GET_SW:
;......
IF BRANCH ;----------------------------------------------- 90/03/16 --
        TEST    [CURUA],08H
        JZ      GET_SW350
        MOV     BL,[CURUA]
        AND     BX,0007H
        LEA     DI,[BX.X2_SW_VT]
        JMP     SHORT GET_SW351
ENDIF ;---------------------------------------------------------------
GET_SW350:
        PUSH    AX
        MOV     DI,OFFSET X2_SW_00
        XOR     AX,AX
        MOV     AL,CURUA
        ADD     DI,AX
        POP     AX
GET_SW351:
        RET


;------------------------------------------------------------;
;                                                            ;
;       RECALIBRATE HERE                                     ;
;                                                            ;
;------------------------------------------------------------;
RCBL:
        MOV     AH,07H          ;SET RECALIBLATE COMMAND
        CALL    ROMBIO          ;CALL ROM BIO ROUTINE
        RET

;------------------------------------------------------------;
;                                                            ;
;       CALL DISK BIO ROM                                    ;
;                                                            ;
;------------------------------------------------------------;
ROMBIO:

        RET

;----------------------------------------------- DOS5 91/01/09 -------
;save_ss        dw      0
;save_sp        dw      0
;save_ax        dw      0
;       dw      128     dup     (0cccch)
;stack  equ     $
;---------------------------------------------------------------------

HDSASI_CODE_END:
HDSASI_END:

BIOS_CODE       ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\modisk.asm ===
PAGE     109,132

        TITLE    MS-DOS 5.0 MODISK.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: MODISK.ASM                                 *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************
;************************************************************************
;************************************************************************
;*                                                                      *
;*     PROGRAM DEVISION                                                 *
;*                                                                      *
;************************************************************************

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Data       segment word public 'Bios_Data'

        EXTRN   CURUA:BYTE,CURDRV:BYTE
        EXTRN   HDS_OFFSET:WORD
        EXTRN   HDS_LAST:WORD
        EXTRN   HDDSKS_1:NEAR
        EXTRN   COM1:BYTE
        EXTRN   EXLPTBL:WORD
        EXTRN   HDIO_FLG:BYTE
        EXTRN   EXIT:FAR
        EXTRN   ERR_EXIT:FAR
        EXTRN   PTRSAV:DWORD
        EXTRN   LNG_TRNS:WORD 
        EXTRN   DSK_BUF2:NEAR

;----------------------------------------------- DOS5 90/12/14 -------
        EXTRN   START_SEC_H:WORD
        EXTRN   BLOCK_TRNS_H:WORD
        EXTRN   OLD_AX:WORD
        EXTRN   BPBCOPY:WORD
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 91/01/09 -------
        EXTRN   MO_HEAD:BYTE, MO_SECTOR:BYTE
        EXTRN   MAX_PART:BYTE, VOL_INF_LENGTH:WORD
        EXTRN   B_COMMAND:BYTE, B_FLAG:BYTE, B_SCSIID:BYTE
        EXTRN   B_LUN:BYTE, B_LBAVH:BYTE, B_LBAH:BYTE
        EXTRN   B_LBAM:BYTE, B_LBAL:BYTE, B_DOFFSET:WORD
        EXTRN   B_DSEGMENT:WORD, B_DLENGTH:WORD
        EXTRN   B_ODC_STATUS:BYTE, B_SCSI_STATUS:BYTE
        EXTRN   B_SENSE_KEY:BYTE, B_SENSE_CODE:BYTE
        EXTRN   YUKO_UNIT:BYTE, SUB_UNIT:BYTE
        EXTRN   SUB_ID:BYTE, MO_DEV_OFFSET:WORD, MO_SUB_OFFSET:BYTE
        EXTRN   READ_V_FLG:BYTE, ERR_STATUS:BYTE
        EXTRN   LNG_TRNSMO:WORD, LNG_PTRNS:WORD, BLOCK_TRNS:WORD
        EXTRN   SEC_PBLOCK:WORD
        EXTRN   CALLADDR:WORD, MO_DEVICE_TBL:BYTE
        EXTRN   MO_ADDR_LENGTH:WORD, MO_ADDR_TBL:BYTE, ERR_CODE_TBL:NEAR
        EXTRN   PARAMETER:BYTE, CDB:BYTE, REMAIN_ADDR:WORD
        EXTRN   REMAIN_LNG:WORD

        EXTRN   RTRY_CNT:BYTE, VRFY_FLG:BYTE, RW_SW:BYTE, COM:BYTE
        EXTRN   CUR_TRNS:WORD, NO_TRNS:WORD, LNG_SEC:WORD

        EXTRN   READ_BUF:BYTE

        extrn   save_ax:word,save_ss:word,save_sp:word,stack:near
;---------------------------------------------------------------------

        EXTRN   FAT12:BYTE, FAT16:BYTE

        EXTRN   NO_NAME:BYTE
        EXTRN   CURDA:BYTE

;----------------------------------------------- DOS5 91/08/08 -------
        EXTRN   MOSW2:BYTE, MAXSEC:WORD, Lockcnt:byte
        EXTRN   time_buf:byte, time_to_retry:word
;---------------------------------------------------------------------

Bios_Data       ends


Bios_Code       segment word public 'Bios_Code'

        EXTRN   SetDrive:NEAR
;       extrn   save_ax:word,save_ss:word,save_sp:word,stack:near
;----------------------------------------------- DOS5 90/12/14 -------
        EXTRN   BDATA_SEG:WORD
;---------------------------------------------------------------------
        EXTRN   MOV_MEDIA_IDS:NEAR

;----------------------------------------------- DOS5 91/10/08 -------
;<patch BIOS50-P02>
        EXTRN   PATCH01:NEAR

        public  MEDIA_RE_ERR, MEDIA_RE_071
;---------------------------------------------------------------------



Bios_Code       ends



Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP
MODISK_CODE_START:

        PUBLIC          MODISK_CODE_END
        PUBLIC          MODISK_END
        PUBLIC          MEDIA_MO
        PUBLIC          OPEN_MO
        PUBLIC          CLOSE_MO
        PUBLIC          GET_MO
        PUBLIC          CMN_RW_MO
        PUBLIC          CMD_CLEAR,MO_BIOS
        PUBLIC          CMD_CLEAR_FAR,MO_BIOS_FAR
;----------------------------------------------- DOS5 91/08/00 -------
        public          LockMO, UnlockMO
;---------------------------------------------------------------------
;
;*********************************************************
;*  STRACTUR TABLE AREA                                  *
;*********************************************************

;****************************************
;*  REQUEST HEADER     @@@@@@@@ *
;****************************************
REQUEST_HDR     STRUC                   ; MS-DOS COMMAND PACKET FORMAT  
        REQ_LEN         DB      ?       ; COMMAND PACKET LENGTH 
        REQ_UNIT        DB      ?       ; SUB UNIT NUMBER
        REQ_CMD         DB      ?       ; COMMAND CODE
        REQ_STATUS      DW      ?       ; STATUS 
        REQ_RESERVE     DB      8 DUP(?); RESERVE AREA
REQUEST_HDR     ENDS                    ;      

;****************************************
;*  INIT COMMAND              @@@ @ *
;****************************************
INIT_HDR     STRUC                      ; STRUCTUR USE INIT COMMAND
        INIT_RQH        DB      SIZE REQUEST_HDR DUP(?)
        INIT_UNITS      DB      ?       ; UNIT NUMBER
        INIT_ENDADDR    DD      ?       ; POINTER FOR FREE AREA
        INIT_BPBARRY    DD      ?       ; POINTER FOR BPB ARRY
        INIT_DEVNO      DB      ?       ; DEVICE NUMBER
INIT_HDR     ENDS                       ; 

;****************************************
;*  MEDIA CHECK             @@@@ @ *
;****************************************
MEDIA_HDR     STRUC                     ; STRUCTUR USE MEDIA CHECK COMMAND
        MEDIA_RQH       DB      SIZE REQUEST_HDR DUP(?)
        MEDIA_DESCRIPT  DB      ?       ; MEDIA DESCRIPTR
        MEDIA_STATUS    DB      ?       ; MEDIA CHENGE STATUS
        MEDIA_VOLID     DD      ?       ; VOLUM ID PTR 
MEDIA_HDR     ENDS                      ;      

;****************************************
;*  BUILD BPB           @@@@@@ @ *
;****************************************
BUILD_HDR     STRUC                     ; STRUCTUR USE BUILD BPB COMMAND
        BUILD_RQH       DB      SIZE REQUEST_HDR DUP(?)
        BUILD_DESCRIPT  DB      ?       ; MEDIA DESCRIPTER
        BUILD_ADDR      DD      ?       ; BOOT SECTOR READ ADDR
        BUILD_BPBPTR    DD      ?       ; BPB TBL POINTER
BUILD_HDR     ENDS                      ;      

PAGE
;****************************************
;*  READ / WRITE / WRITE & VERIFY       *
;****************************************
RW_HDR      STRUC                       ; STRUCTUR USE READ WRITE ETC COMMAND 
        RW_RQH          DB      SIZE REQUEST_HDR DUP(?)
        RW_DESCRIPT     DB      ?       ; MEDIA DESCRIPTER
        RW_ADDR         DD      ?       ; TRANSFER ADDR
        RW_COUNT        DW      ?       ; TRABSFER BLOCK LENGTH
        RW_SECTOR       DW      ?       ; TRANSFER BLOCK NUMBER
        RW_VID          DD      ?       ; VOLUM ID PTR 
RW_HDR     ENDS                         ;      

;****************************************
;*  BPB                                 *
;****************************************
MO_BPB_STR      STRUC            
        BPB_BYTE        DW      ?       ; BYTE / SECTOR
        BPB_CSEC        DB      ?       ; SECTOR / CLUSTER
        BPB_RSEC        DW      ?       ; RESERVE SECTOR
        BPB_FAT         DB      ?       ; FAT AREA 
        BPB_DIR         DW      ?       ; ROOT DIRECTORY ENTRY
        BPB_MSEC        DW      ?       ; SECTOR / MEDIA
        BPB_MDIC        DB      ?       ; MEDIA DESCRIPTER
        BPB_FSEC        DW      ?       ; SECTOR / FAT AREA
        bpb_tsec        DW      ?       ; sector / track
        bpb_head        DW      ?       ; number of head
        bpb_osec        DW      ?       ; out sector
        bpb_vid         DB   11 dup (?) ; volum id
                        DB      0       ;
MO_BPB_STR      ENDS


;**     BIOS PARAMETER BLOCK DEFINITION
;
;       The BPB contains information about the disk structure.  It dates
;       back to the earliest FAT systems and so FAT information is
;       intermingled with physical driver information.
;
;       A boot sector contains a BPB for its device; for other disks
;       the driver creates a BPB.  DOS keeps copies of some of this
;       information in the DPB.
;
;       The BDS structure contains a BPB within it.
;

A_BPB                   STRUC
BPB_BYTESPERSECTOR      DW      ?
BPB_SECTORSPERCLUSTER   DB      ?
BPB_RESERVEDSECTORS     DW      ?
BPB_NUMBEROFFATS        DB      ?
BPB_ROOTENTRIES         DW      ?
BPB_TOTALSECTORS        DW      ?
BPB_MEDIADESCRIPTOR     DB      ?
BPB_SECTORSPERFAT       DW      ?
BPB_SECTORSPERTRACK     DW      ?
BPB_HEADS               DW      ?
BPB_HIDDENSECTORS       DW      ?
                        DW      ?
BPB_BIGTOTALSECTORS     DW      ?
                        DW      ?
                        DB      6 DUP(?)        ; NOTE:  many times these
;                                               ;        6 bytes are omitted
;                                               ;        when BPB manipulations
;                                               ;        are performed!
A_BPB                   ENDS


EXT_BOOT_SIGNATURE       EQU     41             ;Extended boot signature
;
EXT_BPB_INFO            STRUC
EBPB_BYTESPERSECTOR      DW      ?
EBPB_SECTORSPERCLUSTER   DB      ?
EBPB_RESERVEDSECTORS     DW      ?
EBPB_NUMBEROFFATS        DB      ?
EBPB_ROOTENTRIES         DW      ?
EBPB_TOTALSECTORS        DW      ?
EBPB_MEDIADESCRIPTOR     DB      ?
EBPB_SECTORSPERFAT       DW      ?
EBPB_SECTORSPERTRACK     DW      ?
EBPB_HEADS               DW      ?
EBPB_HIDDENSECTOR        DD      ?
EBPB_BIGTOTALSECTORS     DD      ?
EXT_BPB_INFO            ENDS
;
;AN001; EXT_PHYDRV, EXT_CURHD included in the header for OS2.
EXT_IBMBOOT_HEADER      STRUC
EXT_BOOT_JUMP           DB      3 DUP (?)
EXT_BOOT_OEM            DB      8 DUP (?)
EXT_BOOT_BPB            DB      size EXT_BPB_INFO dup (?)
EXT_PHYDRV              DB      80h
EXT_CURHD               DB      0
EXT_BOOT_SIG            DB      EXT_BOOT_SIGNATURE
EXT_BOOT_SERIAL         DD      ?
EXT_BOOT_VOL_LABEL      DB      11 DUP (?)
EXT_SYSTEM_ID           DB      8  DUP (?)
EXT_IBMBOOT_HEADER      ENDS


; values for various flags in bds_flags.

fnon_removable      equ     01h         ;for non-removable media
fchangeline         equ     02h         ;if changeline supported on drive
return_fake_bpb     equ     04h         ; when set, don't do a build bpb
                                        ; just return the fake one
good_tracklayout    equ     08h         ; the track layout has no funny sectors
fi_am_mult          equ     10h         ;if more than one logical for this physical
fi_own_physical     equ     20h         ;signify logical owner of this physical
fchanged            equ     40h         ;indicates media changed
set_dasd_true       equ     80h         ; set dasd before next format
fchanged_by_format  equ    100h         ;media changed by format
unformatted_media   equ    200h         ;an001; fixed disk only


bds_struc       struc
bds_link        dd              0ffffh  ; link to next bds
bds_drivenum    db              80      ; int 13 drive number
bds_drivelet    db              3       ; dos drive number

;       We want to embed a BPB declaration here, but we can't initialize
;       it properly if we do, so we duplicate the byte/word/dword architecture
;       of the BPB declaration.

;BDS_BPB        db      size BPBSTRUC dup (?)   ; actual BPB
BDS_BPB         dw      512             ; BPB_BYTESPERSECTOR
                db      1               ; BPB_SECTORSPERCLUSTER
                dw      1               ; BPB_RESERVEDSECTORS
                db      2               ; BPB_NUMBEROFFATS
                dw      16              ; BPB_ROOTENTRIES
                dw      0               ; BPB_TOTALSECTORS
                db      0f8h            ; BPB_MEDIADESCRIPTOR
                dw      1               ; BPB_SECTORSPERFAT
                dw      0               ; BPB_SECTORSPERTRACK
                dw      0               ; BPB_HEADS
                dd      0               ; BPB_HIDDENSECTORS
                dd      0               ; BPB_BIGTOTALSECTORS

bds_fatsiz      db              0       ; flags...
bds_opcnt       dw              0       ; open ref. count
bds_formfactor  db              3       ; form factor index
bds_flags       dw              0020h   ; various flags
bds_ccyln       dw              40      ; max number of cylinders

BDS_RBPB        db size A_BPB dup (0)   ; recommended BPB

bds_track       db              -1      ; last track accessed on drive
bds_tim_lo      dw              1       ; time of last access. keep
bds_tim_hi      dw              0       ; these contiguous.
bds_volid       db "NO NAME    ",0      ; volume id of medium
bds_vol_serial  dd      0         ;current volume serial number from boot record
bds_filesys_id  db      "FAT12   ",0 ; current file system id from boot record
bds_struc       ends


;****************************************
;*  DEVICE MANEGEMENT TABLE   @@@@@*
;****************************************
MO_DEV_STR    STRUC             ; 
        MO_DEV_UNIT     DB      ?       ; UNIT#  
        MO_DEV_FLG      DB      ?       ; FLAG   
        MO_DEV_ID       DB      ?       ; SCSI ID
        MO_DEV_RFU      DB      ?       ; RFU    
MO_DEV_STR   ENDS                       ;


PAGE 
;*********************************************************
;*  EQU                                                  *
;*********************************************************
;********************************
;*  SCSI COMAND TABLE           *
;********************************

_TEST_UNIT      =       00H     ; Test Unit Ready
_REZERO_UNIT    =       01H     ; 
_FORMAT_UNIT    =       04H     ; 
_READ1          =       08H     ; 
_WRITE1         =       0AH     ; 
_INQUIRY        =       12H     ; Inquiry
_PREVENT_ALLOW  =       1EH     ; Door Lock
_READ_CAPACITY  =       25H     ;
_READ2          =       28H     ; Read
_WRITE2         =       2AH     ;
_WRITE_VERIFY   =       2EH     ;
_LOAD_UNLOAD    =      0C1H     ;
_ERASE          =      0E0H     ;
_READ_ID_HOLE   =      0E3H     ;
_SENSE_ALT_TRACK =     0E7H     ;

;********************************
;*  MS_DOS ERR STATUS EQU       *
;********************************

_ERR_00         =       00H     ; CgveNgiیjᔽ
_ERR_01         =       01H     ; ȃjbg
_ERR_02         =       02H     ; hCȕłĂȂ
_ERR_03         =       03H     ; ȃR}h
_ERR_04         =       04H     ; bqbG[
_ERR_05         =       05H     ; sȃhCuNGXg̒
_ERR_06         =       06H     ; V[NG[
_ERR_07         =       07H     ; ȃfBA
_ERR_08         =       08H     ; ZN^݂Ȃ
_ERR_09         =       09H     ; v^̗p؂
_ERR_0A         =       0AH     ; CgG[
_ERR_0B         =       0BH     ; [hG[
_ERR_0C         =       0CH     ; ʓIȃG[
_ERR_0D         =       0DH     ; \
_ERR_0E         =       0EH     ; \
_ERR_0F         =       0FH     ; sȃfBXŇ

;----------------------------------------------- DOS5 90/12/14 -------
;********************************
;*  OTHER EQU                   *
;********************************

BPB_SIZE        EQU     17
HDDSK_SIZE      EQU     BPB_SIZE*4
;---------------------------------------------------------------------


PAGE
;********************************************************************
;*                                                                  *
;*     DATA    DIVISION                                             *
;*                                                                  *
;********************************************************************
;****************************************
;*  VOLUM INFORMATION                   *
;****************************************

;MO_CYLINDER    DW     4656             ; fBXNu
;MO_HEAD                DB        1             ; zAhXl
;MO_SECTOR      DB       64             ;
;
;MAX_PART       DB       16             ; p[eBV\
;VOL_INF_LENGTH DW       32             ; {[ǗPe[u
;
;****************************************
;*  COMMAND PACKET FOR MO-BIOS          *
;****************************************
;               EVEN
;B_COMMAND      DB      00H     ; COMMAND
;B_FLAG                 DB      00H     ; COMMAND FLAG
;B_SCSIID       DB      00H     ; SCSI ID
;B_LUN          DB      00H     ; SCSI LUN      
;B_LBAVH                DB      00H     ; Logical Block Address Very Hight
;B_LBAH                 DB      00H     ; Logical Block Address Hight
;B_LBAM                 DB      00H     ; Logical Block Address Middle 
;B_LBAL                 DB      00H     ; Logical Block Address Low 
;B_DOFFSET      DW    0000H     ; Data Area Pointer Offset 
;B_DSEGMENT     DW    0000H     ; Data Area Pointer Segment
;B_DLENGTH      DW    0000H     ; Data Area Length
;B_ODC_STATUS   DB      00H     ; ODC 141 Status
;B_SCSI_STATUS  DB      00H     ; SCSI Status
;B_SENSE_KEY    DB      00H     ; 
;B_SENSE_CODE   DB      00H     ;
;B_RESERVE      DW    0000H     ; RESERVE
;        
;****************************************
;*  WORK DATA                           *
;****************************************
;YUKO_UNIT      DB      04H     ; Pu̗Lp[eBV
;MO_LPFLG       DB      00H     ; foCXڑ
;SUB_UNIT       DB      00H     ; TujbgԍZ[uGA
;SUB_ID         DB      00H     ; Tujbgrbrh-hcZ[uGA
;RETRY_COUNT    DB      00H     ; RETRAY COUNTER
;MO_DEV_OFFSET  DW      0000H   ; YufoCXe[ugd`c|C^
;MO_SUB_OFFSET  DB      00H     ; Yu΃hCuԍ
;READ_V_FLG     DB      00H     ; VOLUM LABEL READ FLG
;READ_LABEL     DB      00H     ; VOLUM LABEL READ END FLG
;ERR_STATUS     DB      00H     ; ERR STATUS FOR MS-DOS
;
;****************************************
;* read write process use data          *
;****************************************
;VRFY_FLG       DB      00H     ; VERYFAY FLAG
;RW_SW          DB      00H     ; READ & WRITE FUNCTION SWITCH
;COM            DB      00H     ; COMMAND CODE SET AREA
;LNG_TRNSMO     DW    0000H     ; ]v_ZN^@
;LNG_PTRNS      DW    0000H     ; ]vZN^
;BLOCK_TRNS     DW    0000H     ; ]Jn_ZN^ԍ
;CUR_TRNS       DW    0000H     ; ]ρ@̈搔
;NO_TRNS                DW    0000H     ; ]@̈搔
;LNG_SEC                DW    0000H     ; _ZN^̃oCg
;SEC_PBLOCK     DW    0000H     ; _ZN^̕ZN^
;SCSI_FLG       DB      00H     ;
;NSMO           DB      00H     ;
;CALLADDR       DW    0000H
;
;PAGE
;****************************************
;*  DEVICE DRIVER SYSTEM INFORMATION    *
;****************************************
;
;               EVEN
;MO_DEV_LENGTH  DW      4           ; PfoCXǗe[u
;MO_DEVICE_TBL  DB      32 DUP(00H) ; foCXǗe[u (4*8)
;   +-------+-------+-------+-------+
;   | SUB   | FLAG  | SCSI  | RFU   |
;   | UNIT# | (AI)  |    ID |       |
;   +-------+-------+-------+-------+
;              01 - aoaXVς
;              02 - aoaXV
;
;
;               EVEN
;MO_ADDR_LENGTH DW      12          ; P{[AhXǗe[u
;
;MO_ADDR_TBL     DB      96 DUP(00H) ; 12*8
;   +-------+-------+-------+-------+-------+-------+-------+-------+
;   | IPL  SECTOR                   | _{[Jn SECTOR     |
;   |   L       M       H      VH   |   L       M       H      VH   |
;   +-------+-------+-------+-------+-------+-------+-------+-------+
;   +-------+-------+-------+-------+ 
;   | _{[I SECTOR     |   ZN^Őݒ肳
;   |   L       M       H      VH   |   
;   +-------+-------+-------+-------+
;
;NO_NAME                DB      'NO_NAME    ',0        ; 
;
;****************************************
;*  ERR CODE TBL  (16 DATA / 1LINE)     *
;****************************************
;
;ERR_CODE_TBL:  
;-----------------------------------------------------------------------+---
; low   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F   +   
;-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
; DB    0CH,0CH,0CH,0AH,02H,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 0
; DB    04H,0BH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 1
; DB    0CH,08H,0CH,0CH,0CH,01H,05H,00H,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 2
; DB    0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 3
; DB    0CH,0CH,0CH,0CH,0CH,0CH,0CH,04H,0CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH  ; 4
;

PAGE
;************************************************
;*    MEDIA CHECK COMMAND PROCESS               *
;*----------------------------------------------*
;*                                              *
;*    IN   AL<- SUB UNIT #                      *
;*                                              *
;*                                              *
;************************************************
;=========
MEDIA_MO:
;=========

        CALL    GET_SCSI_ID                     ; 

        CALL    M_TEST_UNIT                     ; TEST & UNIT READY
        JAE     MEDIA_C00                       ; CF=0 THEN JMP
        JMP     short MEDIA_CHG00               ; ERR JMP 

MEDIA_C00:
        MOV     BX , WORD PTR [MO_DEV_OFFSET]   ; DEVICE TBL PTR HEAD
        XOR     AH , AH 
        MOV     AL , BYTE PTR [MO_SUB_OFFSET]   ; LOGICAL UNIT#/MEDIA
        SHL     AX , 1                          ; *DEVICE TBL LENGTH (4)
        SHL     AX , 1                          ; 
        ADD     BX , AX                         ; BX <- OFFSET OF TBL
        MOV     AH , 0FFH                       ; -1 SET
        CMP     [BX.MO_DEV_FLG] , 02H           ; MEDIA CHG FLG?
        JZ      MEDIA_REINIT                    ; IF CHENGED THEN JMP

MEDIA_NO_CHG:                                   ; MEDIA NO CHG PROCESS
        MOV     AH , 01H                        ; 1 SET (MEDIA NO CHENG)
        JMP     MEDIA_EXIT                      ;

;****************************************
;*      PROCESS WHEN MEDIA CHENGED      *
;****************************************
MEDIA_CHG00:
;----------------------------------------------- DOS5 91/08/00 -------
        MOV     DL , SUB_ID                     ; SET UA                H1.7.27
        OR      DL , 0A0H                       ; DA
        MOV     CL , 09H                        ; FUNCTION CODE SET     H1.7.27
        MOV     AX , 0001H                      ; SET MODISK AI FLAG    H1.7.27
        INT     220                             ;                       H1.7.27
;---------------------------------------------------------------------
        CMP     B_SENSE_KEY , 06H               ; UNIT ATTENSION?
        JZ      MEDIA_CHG10                     ;
        JMP     MEDIA_ERR                       ;

MEDIA_CHG10:
;----------------------------------------------- DOS5 91/08/00 -------
;       MOV     DL , SUB_ID                     ; SET UA                H1.7.27
;       OR      DL , 0A0H                       ; DA
;       MOV     CL , 09H                        ; FUNCTION CODE SET     H1.7.27
;       MOV     AX , 0001H                      ; SET MODISK AI FLAG    H1.7.27
;       INT     220                             ;                       H1.7.27
;---------------------------------------------------------------------
        MOV     AH , 0FFH                       ; -1 SET

MEDIA_REINIT:
        PUSH    AX
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     [MOSW2],0ffh                    ;if 3.5" MO ?
        jne     MEDIA_RESTART                   ;  no
        mov     si,03h                          ; large partition, 16 bit fat
        jmp     short MEDIA_RE_06
MEDIA_RESTART:
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 90/12/18 -------
        MOV     ES,CS:[BDATA_SEG]
;       MOV     AX,CS
;       MOV     ES,AX
;---------------------------------------------------------------------
        MOV     DI,OFFSET DSK_BUF2

        CALL    FORMAT_CHK                      ;
        JAE     MEDIA_RE_00                     ;
        JMP     MEDIA_RE_ERR                    ; CF = ON SCSI ERR
                                                ;
MEDIA_RE_00:
        CMP     CL , 00H                        ; 
        JZ      MEDIA_RE_01                     ; FORMAT THEN JMP
        MOV     ERR_STATUS , _ERR_08            ; UN FORMAT STATUS SET
        JMP     MEDIA_RE_ERR                    ;

;****************************************
;*  SET LOGICAL VOLUM INFORMATION       *
;****************************************
MEDIA_RE_01:
        CALL    READ_VOL_INF                    ; VOL INFORMATION READ
        JAE     MEDIA_RE_02                     ;
        JMP     MEDIA_RE_ERR                    ;

;****************************************
;*      CHECK PARTITIONS                *
;****************************************
MEDIA_RE_02:
        MOV     DL , MO_SUB_OFFSET              ; DRIVE NUMBER OFFSET / MEDIA 
        MOV     CH , MAX_PART                   ; MAX PARTISHION IN VOLUM
        XOR     CL , CL                         ; BUSY PARTISION COUNTER
        
MEDIA_RE_03:                                    ; CHECK SYSTEM FLAG 
        MOV     SI,0000h
        CMP     BYTE PTR ES:[DI+01H] , 81H      ;(ACTIVE & MS-DOS 12bit FAT) 
        JZ      MEDIA_RE_MATCH                  ; JMP MATCH 
        MOV     SI,0001h
        CMP     BYTE PTR ES:[DI+01H] , 91H      ;(ACTIVE & MS-DOS 16bit FAT)
;----------------------------------------------- DOS5 90/12/20 -------
        JZ      MEDIA_RE_MATCH                  ; JMP MATCH 
        MOV     SI,0003h
        CMP     BYTE PTR ES:[DI+01H] , 0A1H     ;(ACTIVE LARGE PARTITION)
;---------------------------------------------------------------------
        JNZ     MEDIA_RE_04                     ; JMP NOT MATCH

MEDIA_RE_MATCH:
        CMP     CL , DL                         ; CHECK UNIT
        JZ      MEDIA_RE_06                     ; FIND!
        INC     CL                              ;

MEDIA_RE_04:
        ADD     DI , VOL_INF_LENGTH             ;
        DEC     CH                              ;
        JNZ     MEDIA_RE_05                     ; NON ACTIVE RETURN
        MOV     ERR_STATUS , _ERR_02            ; NOT READY STATUS SET
        JMP     MEDIA_RE_ERR                    ; ERR RET

MEDIA_RE_05:
        JMP     MEDIA_RE_03                     ;
;---------------------------------------------------------------------

;*****************************
;*  READ BPB         @@    *
;*****************************
MEDIA_RE_06:
;----------------------------------------------- DOS5 91/01/22 -------
        PUSH    DI
        MOV     AL,CURDRV
        CALL    SETDRIVE
        AND     WORD PTR [DI].BDS_FLAGS, NOT UNFORMATTED_MEDIA
;----------------------------------------------- DOS5 91/02/19  ------
        MOV     BX,OFFSET EXLPTBL
        MOV     AL,CURDA
        OR      AL,CURUA
MEDIA_RE_SRCH:
        CMP     BYTE PTR [BX+1],AL
        JE      MEDIA_RE_SRCHEND
        ADD     BX,2
        JMP     MEDIA_RE_SRCH
MEDIA_RE_SRCHEND:
        XOR     AH,AH
        MOV     AL,MO_SUB_OFFSET
        ADD     BX,AX
        ADD     BX,AX

        MOV     BYTE PTR [DI].BDS_FATSIZ, 0     ;Reset BigFAT flag
        AND     BYTE PTR [BX], 0FDH             ;  Large partition bit
        TEST    SI,0001h
        JZ      MEDIA_READ_BPB
        MOV     BYTE PTR [DI].BDS_FATSIZ, 40H   ;set BigFAT flaag
        TEST    SI,0002h
        JZ      MEDIA_READ_BPB
        OR      BYTE PTR [BX], 02H              ;set large partitin bit
MEDIA_READ_BPB:
;---------------------------------------------------------------------
        POP     DI
        CALL    CONV_L_P                        ; DS:SI <- MO_ADDR_TBL PTR
        CALL    READ_BPB                        ; DI <- GET BPB PTR
;----------------------------------------------- DOS5 91/10/08 -------
;<patch BIOS50-P02>
        jc      MEDIA_RE_ERR                    ;
        jmp     PATCH01
        db      90h
MEDIA_RE_071:
;---------------
;       JAE     MEDIA_RE_07                     ;
;       JMP     short MEDIA_RE_ERR              ;
;MEDIA_RE_07:
;       MOV     SI , DI                         ;
;------------------------------------------------------------------------------
        MOV     BX , MO_DEV_OFFSET              ; CHECK FIRST BPB SET ? /MEDIA
        MOV     AL , MO_SUB_OFFSET              ;
        XOR     AH , AH                         ;
        SHL     AX , 1                          ; *4 (1DEVTBL LENGTH)
        SHL     AX , 1                          ;
        MOV     DI , BX                         ;
        ADD     BX , AX                         ; DI <- DEV TBL PTR
        MOV     CL , YUKO_UNIT                  ;
        XOR     CH , CH                         ;

MEDIA_RE_08:
        CMP     BYTE PTR [DI.MO_DEV_FLG] , 01H  ;
        JZ      MEDIA_RE_09                     ; NOT FIRST BPB SET THEN JMP
        ADD     DI , AX                         ;
        LOOP    MEDIA_RE_08                     ;
        MOV     AL,CURDRV
        CALL    SETDRIVE
        MOV     [DI].BDS_OPCNT,00H
MEDIA_RE_09:
        MOV     BYTE PTR [BX.MO_DEV_FLG] , 01H  ; SET BPB UPDATE FLAG

        POP     AX
MEDIA_EXIT:
        LES     BX , PTRSAV                     ; CMD PACKET PTR GET
        MOV     ES:[BX.MEDIA_STATUS] , AH       ;

        MOV     AL,CURDRV
        CALL    SETDRIVE
        LEA     SI,[DI].BDS_VOLID

        MOV     WORD PTR ES:[BX.MEDIA_VOLID] , SI
        MOV     WORD PTR ES:[BX.MEDIA_VOLID+2] , DS
        MOV     AL , 00H                        ; NORMAL END STATUS
        JMP     EXIT                            ;
MEDIA_RE_ERR:
        POP     AX

MEDIA_ERR:
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     [MOSW2],0ffh                    ;if 3.5" MO
        je      MEDIA_ERR10                     ; skip setting flags
;---------------------------------------------------------------------
;----------------------------------------------- DOS5 91/01/22 -------
        MOV     AL,CURDRV
        CALL    SETDRIVE
        OR      WORD PTR [DI].BDS_FLAGS, UNFORMATTED_MEDIA
;---------------------------------------------------------------------
;----------------------------------------------- DOS5 91/08/00 -------
MEDIA_ERR10:
;---------------------------------------------------------------------
        MOV     AL,[ERR_STATUS]                 ;SET ERROR STATUS
        JMP     ERR_EXIT                        ;

PAGE 
;************************************************
;*    BUILD BPB COMMAND PROCESS                 *
;*----------------------------------------------*
;*                                              *
;*    IN   AL<- SUB UNIT #                      *
;*                                              *
;*                                              *
;************************************************
;=========
GET_MO:
;=========

        CALL    GET_SCSI_ID                     ;

        XOR     AH,AH
        MOV     AL,CURUA
        MOV     CL,HDDSK_SIZE
        MUL     CL
        MOV     SI,OFFSET HDDSKS_1
        ADD     SI,AX
        MOV     AL,[MO_SUB_OFFSET]              ;MO DISK PT NUMBER
        MOV     CL,BPB_SIZE
        MUL     CL
        ADD     SI,AX

;----------------------------------------------- DOS5 90/12/14 -------
        MOV     ES,CS:[BDATA_SEG]
        MOV     DI,OFFSET BPBCOPY
        PUSH    DI
        MOV     CX,13                           ;SIZE OF OLD BPB
        REP     MOVSB
        PUSH    SI                              ;SAVE IT

        MOV     AL,MO_SECTOR
        XOR     AH,AH
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     [MOSW2],0ffh                    ;if 3.5" MO
        jne     GET10
        mov     ax,19h
GET10:
;---------------------------------------------------------------------
        STOSW                                   ;SET SECTORS/TRACK

        MOV     AL,MO_HEAD
        XOR     AH,AH
        STOSW                                   ;SET HEADS/CYLINDER

        MOV     SI,OFFSET HDS_OFFSET
        XOR     AH,AH
        MOV     AL,CURUA
        MOV     CL,10H
        MUL     CL
        ADD     SI,AX
        MOV     AL,[MO_SUB_OFFSET]
        MOV     CL,4
        MUL     CL
        ADD     SI,AX
        MOV     CX,2
        REP     MOVSW                           ;SET HIDDEN SECTORS

        POP     SI
        MOV     CX,2
        REP     MOVSW                           ;SET BIG TOTAL SECTORS
        POP     SI                              ;SET ADDR OF BPBCOPY
;---------------------------------------------------------------------

BUILD_10:                                       ; STATUS SET FOR DOS 
        LES     BX , [PTRSAV]
;;----------------------------------------------- DOS5 90/02/23 -------
;;      MOV     WORD PTR ES:[BX.BUILD_BPBPTR] , SI   ; BPB OFFSET SET
;;      MOV     WORD PTR ES:[BX.BUILD_BPBPTR+2] , DS ; BPB SEGMENT SET
;;---------------------------------------------------------------------
        MOV     AL,BYTE PTR ES:[BX.BUILD_DESCRIPT]   ; MEDIA DESCRIPTER
        INC     AL                                   ;
;----------------------------------------------- DOS5 90/02/23 -------
        RET
;;--------------------
;;      MOV     BYTE PTR ES:[BX.BUILD_DESCRIPT] , AL ; SET MEDIA DESCRIPTER
;;      XOR     AL,AL                                ;
;;---------------------------------------------------------------------
;;
;;BUILD_RET:
;;      POP     [CALLADDR]
;;      JMP     EXIT                                 ;
;;
;;BUILD_ERR:
;;      POP     [CALLADDR]
;;      JMP     ERR_EXIT                ;
;;---------------------------------------------------------------------

PAGE 
;************************************************
;*   OPEN COMMAND PROCESS          0DH          *
;*----------------------------------------------*
;*                                              *
;*    IN   AL <- SUB UNIT #                     *
;*                                              *
;************************************************
;=======
OPEN_MO:
;=======

;----------------------------------------------- DOS5 91/08/00 -------
        cmp     byte ptr [di].BDS_Opcnt,01h     ; FIRST OPEN?
        jne     MO_OPEN_EXIT
        call    LockMO
;---------------
;;      CALL    GET_SCSI_ID             ;
;;----------------------------------------------- DOS5 90/12/22 -------
;;PATCH FIX
;       CMP     BYTE PTR [DI].BDS_Opcnt,01H     ; FIRST OPEN?
;;------------------
;;      MOV     AL,CURDRV
;;      CALL    SetDrive
;;      CMP     BYTE PTR [BX+Opcnt],01H ; FIRST OPEN?
;;---------------------------------------------------------------------
;       JNE     MO_OPEN_EXIT            ; ALL READY     
;
;; MO DEVICE OPEN  * DOOR LOCK PROCESS 
;
;       CALL    CMD_CLEAR               ; SUB ROUTINE COMMAND AREA CLEAR
;                                       ; DS:BX <- COMMAND AREA PTR
;       MOV     B_COMMAND,_PREVENT_ALLOW ; PREVENT ALLOW (DOOR LOCK)
;       MOV     B_SCSIID,AL             ; SET SCSI ID 
;       MOV     B_FLAG,01H              ; DOOR LOCK
;
;       CALL    CMD_FOR_SCSI            ; SCSI COMMAND EXE (ES:BX PACKET PTR) 
;----------------------------------------------------------------------
        JAE     MO_OPEN_EXIT            ;
        MOV     AL,[ERR_STATUS]
        JMP     ERR_EXIT                ; ERR RETURN

MO_OPEN_EXIT:
        JMP     EXIT                    ;

;----------------------------------------------- DOS5 91/08/00 -------
;* DOOR LOCK PROCESS 
LockMO:
        call    GET_SCSI_ID
        mov     bl,SUB_ID
        xor     bh,bh
        cmp     byte ptr Lockcnt.[bx],0 ; already be locked?
        jne     LockMO_Ret              ; yes

        push    bx
        call    CMD_CLEAR               ; SUB ROUTINE COMMAND AREA CLEAR
                                        ; DS:BX <- COMMAND AREA PTR
        mov     B_COMMAND,_PREVENT_ALLOW ; PREVENT ALLOW (DOOR LOCK)
        mov     B_SCSIID,AL             ; SET SCSI ID 
        mov     B_FLAG,01H              ; DOOR LOCK

        call    CMD_FOR_SCSI            ; SCSI COMMAND EXE (ES:BX PACKET PTR) 
        pop     bx

        jc      LockMO_Err
LockMO_Ret:
        inc     byte ptr Lockcnt.[bx]
LockMO_Err:
        ret
;----------------------------------------------------------------------

;************************************************
;*   CLOSE COMMAND PROCESS       0EH            *
;*----------------------------------------------*
;*                                              *
;*    IN   AL <- SUB UNIT #                     *
;*                                              *
;************************************************
;========
CLOSE_MO:
;========

;----------------------------------------------- DOS5 91/08/00 -------
        cmp     byte ptr [di].BDS_Opcnt,00h     ; CLOSE OK?
        jne     MO_CLOSE_EXIT
        call    UnlockMO
;---------------
;       CALL    GET_SCSI_ID             ;
;;----------------------------------------------- DOS5 90/12/22 -------
;;PATCH FIX
;       CMP     BYTE PTR [DI].BDS_Opcnt,00H     ; CLOSE OK?
;;------------------
;;      MOV     AL,CURDRV
;;      CALL    SetDrive
;;      CMP     BYTE PTR [BX+Opcnt],00H ; CLOSE OK  ?
;;---------------------------------------------------------------------
;       JNE     MO_CLOSE_EXIT           ; ALL READY     
;
;; MO DEVICE CLOSE * DOOR UNLOCK PROCESS 
;
;       CALL    CMD_CLEAR               ; SUB ROUTINE COMMAND AREA CLEAR
;                                       ; DS:BX <- COMMAND AREA PTR
;       MOV     B_COMMAND,_PREVENT_ALLOW ; PREVENT ALLOW (LOCK)
;       MOV     B_SCSIID,AL             ; SET SCSI ID 
;       MOV     B_FLAG,00H              ; DOOR UNLOCK
;
;       CALL    CMD_FOR_SCSI            ; SCSI COMMAND EXE (ES:BX PACKET PTR) 
;----------------------------------------------------------------------
        JAE     MO_CLOSE_EXIT           ;
        MOV     AL,[ERR_STATUS]
        JMP     ERR_EXIT                ;

MO_CLOSE_EXIT:
        JMP     EXIT                    ;

;----------------------------------------------- DOS5 91/08/00 -------
;* DOOR UNLOCK PROCESS 
UnlockMO:
        call    GET_SCSI_ID
        mov     bl,SUB_ID
        xor     bh,bh
        cmp     byte ptr Lockcnt.[bx],1 ; is it time to unlock ?
        jne     UnlockMO_Ret            ; no

        push    bx
        call    CMD_CLEAR               ; SUB ROUTINE COMMAND AREA CLEAR
                                        ; DS:BX <- COMMAND AREA PTR
        mov     B_COMMAND,_PREVENT_ALLOW ; PREVENT ALLOW (LOCK)
        mov     B_SCSIID,AL             ; SET SCSI ID 
        mov     B_FLAG,00H              ; DOOR UNLOCK

        call    CMD_FOR_SCSI            ; SCSI COMMAND EXE (ES:BX PACKET PTR) 
        pop     bx

        jc      UnlockMO_Err
UnlockMO_Ret:
        dec     byte ptr Lockcnt.[bx]
UnlockMO_Err:
        ret
;----------------------------------------------------------------------

PAGE
;********************************************************************
;*                                                                  *
;*    SUBROUTINE DIVISION                                           *
;*                                                                  *
;********************************************************************
;***************************************
;* FORMAT CHECK                        *
;*-------------------------------------*
;*   IN : ES:DI READ BUFFER            *
;*   OUT: CL=00 FORMAT                 *
;*           01 NOT FORMAT             *
;*        CF=ON ERR                    *
;***************************************
;==========
FORMAT_CHK:
;==========
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     BYTE PTR [RTRY_CNT],05H         ;
;------------------
;       MOV     BYTE PTR [RTRY_CNT],03H         ;
;---------------------------------------------------------------------

FORMAT_00:                                      ; RETRY LABEL 
        CALL    CMD_CLEAR                       ;
        MOV     BYTE PTR [B_COMMAND],_READ2     ; SET COMMAND
        MOV     WORD PTR [B_LBAVH],0000H        ; TURGET BLOCK IPL 
        MOV     WORD PTR [B_LBAM],0000H         ; 
        MOV     WORD PTR [B_DLENGTH],0001H      ; 1 SECTOR(READ WITH VOL INF)
        MOV     [B_DOFFSET],DI                  ; READ BUFFSER PTR SET
        MOV     [B_DSEGMENT],ES                 ;

        CALL    CMD_FOR_SCSI                    ; 
        JAE     FORMAT_01                       ; READ_OK JMP
        SUB     BYTE PTR [RTRY_CNT],01H         ; READ ERR 
        CMP     BYTE PTR [RTRY_CNT],00H         ; RETRY END?
        JNZ     FORMAT_00                       ; JMP RETRY

        CMP     BYTE PTR [B_SENSE_CODE],0FEH    ; UN PHYSICAL FORMAT DISK?
        JZ      FORMAT_02                       ; YES THEN JMP           H1.7.5

        CMP     BYTE PTR [B_SENSE_CODE],0ABH    ; CAN'T READ
        JZ      FORMAT_02                       ; YES THEN JMP           H1.7.6

        STC                                     ; SET CF
        JMP     short FORMAT_RET                ; Can't read 

;********************************
;* CHECK VOL FORMAT (IPL1,55AAH)*
;********************************
FORMAT_01:
        CMP     BYTE PTR ES:[DI+4],'I'          ;
        JNZ     FORMAT_02
        CMP     BYTE PTR ES:[DI+5],'P'          ;
        JNZ     FORMAT_02
        CMP     BYTE PTR ES:[DI+6],'L'          ;
        JNZ     FORMAT_02
        CMP     BYTE PTR ES:[DI+7],'1'          ;
        JNZ     FORMAT_02

        CMP     WORD PTR ES:[DI+1022],0AA55H    ;
        JNZ     FORMAT_02

        XOR     CL,CL                           ; CL=00 FORMAT OK
        CLC                                     ;
        JMP     short FORMAT_RET                        ; 

FORMAT_02:
        MOV     CL,01H                          ; NOT FORMAT STATUS SET
        CLC     
        
FORMAT_RET:
        RET                                     ;

PAGE
;***************************************
;* VOL INFORMATION READ                *
;*-------------------------------------*
;*   IN : ES:DI READ BUFFER            *
;*   OUT: CF = ON ERR                  *
;***************************************
;============
READ_VOL_INF:
;============
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     BYTE PTR [RTRY_CNT],05H         ;
;------------------
;       MOV     BYTE PTR [RTRY_CNT],03H         ;
;---------------------------------------------------------------------

READ_VOL_00:                                    ; RETRY LABEL 
        CALL    CMD_CLEAR                       ;
        MOV     BYTE PTR [B_COMMAND],_READ2     ; SET COMMAND
        MOV     WORD PTR [B_LBAVH],0000H        ; TURGET BLOCK VOL INF
        MOV     byte PTR [B_LBAM],00H           ; 
        MOV     byte PTR [B_LBAL],01H           ; 
        MOV     WORD PTR [B_DLENGTH],0001H      ; 1 SECTOR
        MOV     [B_DOFFSET],DI                  ; READ BUFFER PTR SET
        MOV     [B_DSEGMENT],ES                 ;

        CALL    CMD_FOR_SCSI                    ; 
        JAE     READ_VOL_RET                    ; READ_OK JMP
        SUB     BYTE PTR [RTRY_CNT],01H         ; READ ERR 
        CMP     BYTE PTR [RTRY_CNT],00H         ; RETRY END?
        JNZ     READ_VOL_00                     ; JMP RETRY
        STC                                     ; SET CF
READ_VOL_RET:
        RET

;***************************************
;* CONVERT PHISYCAL ADDR FROM LOGICAL  *
;*-------------------------------------*
;*   IN: ES:DI <- VOL INFORMATION TBL  *
;*                                     *
;*  OUT: DS:SI <- MO_ADDR_TBL PTR      *
;*                                     *
;***************************************
;========
CONV_L_P:
;========
        PUSH    DI              ;
        PUSH    AX              ;
        PUSH    BX              ;
        PUSH    CX              ;
        PUSH    DX              ;

        MOV     SI,OFFSET MO_ADDR_TBL ; ADDR TBL HEAD POINTER
        MOV     AX,[MO_ADDR_LENGTH]   ; 1 ADDR TBL LENGTH 
        MUL     [SUB_UNIT]      ; 
        ADD     SI,AX           ; DI<-MO ADDR TBL OFFSET 
        XOR     AH,AH           ;
        MOV     AL,[MO_HEAD]    ;
        MUL     [MO_SECTOR]     ; AX<-SECTOR/CYLINDER
        ADD     DI,04H          ; IPL ADDR SET  

;----------------------------------------------- DOS5 91/08/00 -------
        cmp     [MOSW2],0ffh    ; if 3.5" MO
        je      CONV10          ;  skip addr_tbl setting
;---------------------------------------------------------------------
        CALL    SET_ADDR_TBL    ; SET PHISICAL ADDR IPL,START,END

;----------------------------------------------- DOS5 91/08/00 -------
CONV10:
;---------------------------------------------------------------------
        PUSH    SI
        PUSH    DI
        PUSH    ES
;----------------------------------------------- DOS5 90/12/18 -------
        MOV     ES,CS:[BDATA_SEG]
;       PUSH    CS
;       POP     ES
;---------------------------------------------------------------------
        MOV     DI,OFFSET HDS_OFFSET 
        MOV     AL,CURUA
        MOV     CL,10H          ;HDS_OFFSET I UNIT SIZE
        MUL     CL
        ADD     DI,AX
        MOV     AL,[MO_SUB_OFFSET];MO DISK PT NUMBER
        MOV     CL,4
        MUL     CL
        ADD     DI,AX

        ADD     SI,4
        MOV     CX,4
        REP     MOVSB

;----------------------------------------------- DOS5 91/01/20 -------
        MOV     AL,CURDRV
        CALL    SETDRIVE
        LEA     DI,[DI].BDS_BPB.BPB_HIDDENSECTORS
        SUB     SI,4
        MOV     CX,4
        REP     MOVSB
;---------------------------------------------------------------------

        MOV     DI,OFFSET HDS_LAST
        MOV     AL,CURUA
        MOV     CL,10H          ;HDS_OFFSET I UNIT SIZE
        MUL     CL
        ADD     DI,AX
        MOV     AL,[MO_SUB_OFFSET];MO DISK PT NUMBER
        MOV     CL,4
        MUL     CL
        ADD     DI,AX

        MOV     CX,4
        REP     MOVSB

        POP     ES
        POP     DI
        POP     SI

        POP     DX              ;
        POP     CX              ;
        POP     BX              ;
        POP     AX              ;
        POP     DI              ;

        RET                     ;

PAGE
;***************************************
;* SET ADDR INFORMATION FROM VOL INF   *
;*-------------------------------------*
;*   IN: AX <- SECTOR/CYLINDER         *
;*       ES:DI <- VOL INF IPL ADDR PTR *
;*       DS:SI <- SET ADDR TBL POINTER *
;*                                     *
;*  OUT: DS:SI <- ADDR TBL PTR         *
;***************************************
;============
SET_ADDR_TBL:
;============
        PUSH    SI              ;
        MOV     CX,3            ; IPL,START,END SET

SET_ADDR_LOOP:
        PUSH    CX              ; LOOP  COUNTER SAVE
        PUSH    AX              ;
        XOR     DX,DX           ;
        XOR     CX,CX           ;
        MOV     CL,BYTE PTR ES:[DI]; CX <- SECTOR

        XOR     AX,AX           ;
        MOV     AL,BYTE PTR [MO_SECTOR] ;
        MUL     BYTE PTR ES:[DI+1] ; AX <- SECTOR/HEAD * HEAD 
        ADD     CX,AX           ; ADD SECTOR

        POP     AX              ;
        PUSH    AX              ;
        CLC                     ;
        MUL     WORD PTR ES:[DI+2]      ; DX:AX SECTOR/CYLINDER * CYLINDER
        ADD     AX,CX           ; ADD 
        ADC     DX,0000H        ; ADD CF 

        XCHG    BX,AX           ; BX <- AX
        POP     AX              ; AX <- SECTOR/CYLINDER
        POP     CX              ; CX <- COUNTER RESET
        PUSH    CX              ;
        PUSH    AX              ;
        CMP     CX,1            ; END ADDR SET ?
        JNZ     NOT_SET_END     ;
        DEC     AX              ;
        ADD     BX,AX           ; + (1CYLINDER-1)
        ADC     DX,0000H        ;
NOT_SET_END:
        XCHG    AX,BX           ;
        MOV     WORD PTR [SI],AX   ; L,M SET
        MOV     WORD PTR [SI+2],DX ; H,VH SET    

        POP     AX              ;
        POP     CX              ; LOOP COUNTER RESET

        ADD     SI,4            ;
        ADD     DI,4            ;

        LOOP    SET_ADDR_LOOP   ;
        POP     SI              ;
        RET                     ;

PAGE
;***************************************
;* BPB READ & SET BPB TBL              *
;*-------------------------------------*
;*  IN:  DS:SI <- ADDR TBL PTR         *
;*                                     *
;*  OUT: DS:DI <- BPB PTR              *
;*                                     *
;***************************************
;========
READ_BPB:
;========
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     BYTE PTR [RTRY_CNT] , 05H       ;
;------------------
;       MOV     BYTE PTR [RTRY_CNT] , 03H       ;
;---------------------------------------------------------------------

READ_BPB_00:                                    ; RETRY LABEL 
        CALL    CMD_CLEAR                       ;
        MOV     BYTE PTR [B_COMMAND] , _READ2   ; SET COMMAND
        MOV     AX , WORD PTR [SI]              ; START OF IPL L,M
        MOV     BYTE PTR [B_LBAM] , AH          ; 
        MOV     BYTE PTR [B_LBAL] , AL          ; 
        MOV     AX , WORD PTR [SI+2]            ; START OF IPL H,VH
        MOV     BYTE PTR [B_LBAVH] , AH         ; 
        MOV     BYTE PTR [B_LBAH] , AL          ;
        MOV     WORD PTR [B_DLENGTH] , 0001H    ; 1SECTOR (LOGICAL BLOCK #0)
        
        MOV     BX , OFFSET DSK_BUF2            ; BOOT SECTOR READ OFFSET
        MOV     [B_DOFFSET] , BX                ; DATA AREA PTR SET
        PUSH    CS:[BDATA_SEG]
        POP     [B_DSEGMENT]                    ; BOOT SECTOR READ SEGEMNT
;       MOV     CS:[B_DSEGMENT] , CS            ; BOOT SECTOR READ SEGEMNT

        CALL    CMD_FOR_SCSI                    ; 
        JAE     READ_BPB_01                     ; READ_OK JMP
        SUB     BYTE PTR [RTRY_CNT] , 01H       ; READ ERR
        JNZ     READ_BPB_00                     ; JMP RETRY
        STC                                     ;
        JMP     READ_BPB_RET                    ;

;********************************
;* SET BPB FOR BPB TBL          *
;********************************
READ_BPB_01:
        XOR     AH,AH
        MOV     AL,CURUA
        MOV     CL,HDDSK_SIZE
        MUL     CL
        MOV     DI,OFFSET HDDSKS_1
        ADD     DI,AX
        MOV     AL,[MO_SUB_OFFSET]              ;MO DISK PT NUMBER
        MOV     CL,BPB_SIZE
        MUL     CL
        ADD     DI,AX

        
        PUSH    DS                              ;
        PUSH    DI                              ;

        MOV     SI , OFFSET DSK_BUF2            ; BOOT SECTOR READ OFFSET
;----------------------------------------------- DOS5 90/12/18 -------
        MOV     DS,CS:[BDATA_SEG]
;       MOV     AX , CS
;       MOV     DS , AX                         ; BOOT SECTOR READ SEGEMNT
;---------------------------------------------------------------------
        ADD     SI , 11                         ; BPB PTR SET
        MOV     CX , 0DH                                ; STRING WORD
;----------------------------------------------- DOS5 90/12/18 -------
        MOV     ES,CS:[BDATA_SEG]
;       MOV     AX , CS                         ;
;       MOV     ES , AX                         ;
;---------------------------------------------------------------------
        REP     MOVSB                           ; 13 BYTE STRING
;----------------------------------------------- DOS5 91/02/19 -------
        CMP     WORD PTR DSK_BUF2.EXT_BOOT_BPB.BPB_TOTALSECTORS,0
        JE      READ_BPB_BIG
        MOV     AX,0
        MOV     CX,2
        REP     STOSW                           ;set 0
        JMP     SHORT READ_BPB_02
READ_BPB_BIG:
;----------------------------------------------- DOS5 90/12/14 -------
        ADD     SI,8
        MOV     CX,2
        REP     MOVSW                           ;TRANSFER DW-SECTOR
READ_BPB_02:
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 91/01/20 -------
        MOV     AL,CURDRV
        CALL    SETDRIVE
        MOV     SI,OFFSET DSK_BUF2.EXT_BOOT_BPB
        LEA     DI,[DI].BDS_BPB
        MOV     CX,13
        REP     MOVSB
        MOV     AL,MO_SECTOR
        XOR     AH,AH
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     [MOSW2],0ffh                    ;if 3.5" MO
        jne     SET_SECTOR
        mov     ax,WORD PTR DSK_BUF2.EXT_BOOT_BPB.BPB_SECTORSPERTRACK
SET_SECTOR:
;---------------------------------------------------------------------
        STOSW                                   ;SET SECTORS/TRACK
        MOV     AL,MO_HEAD
        XOR     AH,AH
        STOSW                                   ;SET HEADS/CYLINDER
        ADD     DI,4                            ;SKIP HIDDEN SECTORS
        CMP     WORD PTR DSK_BUF2.EXT_BOOT_BPB.BPB_TOTALSECTORS,0
        JE      SET_BIGTOTAL
        MOV     AX,0
        MOV     CX,2
        REP     STOSW                           ;set 0
        JMP     SHORT READ_BPB_03
SET_BIGTOTAL:
        ADD     SI,8
        MOV     CX,2
        REP     MOVSW                           ;BIGTOTALSECTORS
;----------------------------------------------- DOS5 91/02/19 -------
READ_BPB_03:
        MOV     AL,CURDRV
        CALL    SETDRIVE
        CALL    MOV_MEDIA_IDS
        JNC     READ_BPB_04                     ;If formatted 3.3c or before
        MOV     WORD PTR [DI.BDS_VOL_SERIAL],0  ; then reset serial number
        MOV     WORD PTR [DI.BDS_VOL_SERIAL+2],0; VolID, File SystemID
        PUSH    DI
        MOV     SI,OFFSET NO_NAME
        LEA     DI,[DI].BDS_VOLID
        MOV     CX,11
        REP     MOVSB
        POP     DI
        MOV     SI,OFFSET FAT12
        LEA     DI,[DI].BDS_FILESYS_ID
        MOV     CX,8
        REP     MOVSB
READ_BPB_04:
;---------------------------------------------------------------------

        POP     DI                              ;
        POP     DS                              ;
        CLC                                     ;

READ_BPB_RET:
        RET                                     ;

PAGE
;***************************************
;* TEST UNIT READY COMMAND TRANSFER    *
;*-------------------------------------*
;*  IN:  NOTHING                       *
;*                                     *
;*  OUT: NOTHING                       *
;*                                     *
;***************************************
;===========
M_TEST_UNIT:
;===========
;----------------------------------------------- DOS5 91/09/00 -------
        mov     byte ptr [RTRY_CNT],05h
M_TEST_RETRY:
;---------------------------------------------------------------------
        CALL    CMD_CLEAR                               ;
        MOV     BYTE PTR [B_COMMAND] , _TEST_UNIT       ;
        CALL    CMD_FOR_SCSI                            ;
;----------------------------------------------- DOS5 91/09/00 -------
        jnc     M_TEST_EXIT

        cmp     [MOSW2],0ffh                    ;if 3.5" MO
        jne     M_TEST_ERR
        cmp     [B_ODC_STATUS],08h              ;busy?
        jne     M_TEST_ERR

        dec     [RTRY_CNT]
        jz      M_TEST_ERR
        call    get_time
        mov     bx,ax

wait_loop:
        xor     cx,cx
        loop    $
        call    get_time
        sub     ax,bx
        jnc     @f
        add     ax,60
@@:     cmp     ax,[time_to_retry]
        jb      wait_loop

        jmp     M_TEST_RETRY

M_TEST_ERR:
        stc
M_TEST_EXIT:
;---------------------------------------------------------------------
        RET                                             ;

;----------------------------------------------- DOS5 91/09/00 -------
get_time        proc    near
        push    es
        push    bx
        push    cx

        mov     ax,0
        push    ds
        pop     es
        mov     bx,offset time_buf
        int     1ch

        mov     al,byte ptr es:[bx+5]
        and     ax,00f0h
        mov     cl,4
        shr     ax,cl
        mov     cx,ax

        shl     ax,1                    ; ax=ax*10
        shl     ax,1                    ;
        add     ax,cx                   ;
        shl     ax,1                    ;

        mov     cl,byte ptr es:[bx+5]
        and     cx,000fh
        add     ax,cx

        pop     cx
        pop     bx
        pop     es
        ret
get_time        endp
;---------------------------------------------------------------------

;***************************************
;* COMMAND PACKET FOR MO_BIOS CLEAR    *
;*-------------------------------------*
;*  IN:  NOTHING                       *
;*                                     *
;*  OUT: NOTHING                       *
;*                                     *
;***************************************
CMD_CLEAR_far   PROC    FAR
        CALL    CMD_CLEAR
        RET
CMD_CLEAR_far   ENDP

;========
CMD_CLEAR:
;========
        PUSH    AX                      ;
        PUSH    DI                      ;
        PUSH    CX                      ;
        PUSH    ES                      ;
;----------------------------------------------- DOS5 91/01/10 -------
        MOV     CX , DS                 ;
;       MOV     CX , CS                 ;
;---------------------------------------------------------------------
        MOV     ES , CX                 ;
        MOV     CX , 10                 ; 10 WORD CLEAR
        MOV     DI , OFFSET B_COMMAND   ; MO-BIOS COMMAND PACKET PTR
        MOV     AX , 0000H              ;
        CLD                             ;
        REP     STOSW                   ; CLEAR

        POP     ES                      ;
        POP     CX                      ;
        POP     DI                      ;
        POP     AX                      ;
        
        RET                             ;

PAGE
;****************************************
;* READ WRITE COMMON PHASE              *
;****************************************

CMN_RW_MO:
        CALL    GET_SCSI_ID             ;
        CMP     [COM1],06H
        JNZ     WRITE_MO
READ_MO:
        MOV     BYTE PTR [RW_SW],0            ; SET READ FUNCTION
        MOV     BYTE PTR [COM],_READ2         ; SET READ COMMAND
        JMP     short COMMON_PHASE05

WRITE_MO:
        MOV     BYTE PTR [RW_SW] , 1           ; SET WRITE FUNCTION
        MOV     BYTE PTR [COM] , _WRITE_VERIFY ; SET WRITE COMMAND
        
COMMON_PHASE05:
        MOV     BX , WORD PTR [MO_DEV_OFFSET]   ; CHECK MEDIA RECOGNITION
        XOR     AH , AH                         ;
        MOV     AL , BYTE PTR [MO_SUB_OFFSET]   ;
        SHL     AX , 1                          ;
        SHL     AX , 1                          ;
        ADD     BX , AX                         ;
        CMP     BYTE PTR [BX.MO_DEV_FLG] , 01H  ; CHECK ACTIVE
        JZ      COMMON_PHASE10
        TEST    BYTE PTR [READ_V_FLG] , 01H     ; WHEN VOL LABEL READ ?
        JNZ     COMMON_PHASE10                  ; THEN READ OK

        MOV     BYTE PTR [ERR_STATUS] , _ERR_0C ; NOT BPB UPDATE ERR
        JMP     HD_ERROR                        ;

COMMON_PHASE10:
        MOV     BP , DI                         ; BP <- ]AhX OFFSET 
        MOV     CX , LNG_TRNS
        MOV     LNG_TRNSMO , CX                 ; ]v_ZN^
        MOV     BLOCK_TRNS , DX                 ; ]Jn_ZN^ԍ
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     DX,START_SEC_H
        MOV     BLOCK_TRNS_H,DX
;---------------------------------------------------------------------

        MOV     CUR_TRNS , 0                    ; CLEAR TRANSFERED BLOCK LENGTH
        MOV     NO_TRNS , 0                     ; CLEAR NON

CMN_RW_SCSI:                                    ;
        CMP     LNG_TRNSMO , 0                  ; TRANSFER BLOCK LENGTH = 0 ?
        JNZ     CMNPHASE10                      ;
        JMP     RW_COMMON_RET                   ; ZF ON RETURN

CMNPHASE10:
        PUSH    CX
        XOR     AH,AH
        MOV     AL,CURUA
        MOV     CL,HDDSK_SIZE
        MUL     CL
        MOV     BX,OFFSET HDDSKS_1
        ADD     BX,AX
        MOV     AL,[MO_SUB_OFFSET]              ;MO DISK PT NUMBER
        MOV     CL,BPB_SIZE
        MUL     CL
        ADD     BX,AX
        POP     CX

        MOV     AX , WORD PTR [BX]              ; AX<-_ZN^̃oCg
        MOV     LNG_SEC , AX                    ;

HD_RW:
        MOV     NO_TRNS , 0                     ; CLEAR NON-TRANSFED BLOCK 
        MOV     BX , OFFSET MO_ADDR_TBL         ;
        XOR     AH , AH                         ;
        MOV     AL , SUB_UNIT                   ;
        MUL     [MO_ADDR_LENGTH]                ;
        ADD     BX , AX                         ;
        ADD     BX , 4                          ; set start sector of partition

        PUSH    BX                              ;
        MOV     AX , WORD PTR [LNG_SEC]         ; _ZN^̃oCg
        MOV     BX , 1024                       ; ZN^̃oCg
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     [MOSW2],0ffh                    ;if 3.5" MO
        jne     HD_RW10
        mov     bx,512                          ; 512 bytes/physical sector
HD_RW10:
;---------------------------------------------------------------------
        XOR     DX , DX                         ;
        DIV     BX                              ; AX <- DX:AX/BX 
        MOV     CX , AX                         ; _ZN^̕ZN^
        MOV     [SEC_PBLOCK] , CX               ;
        POP     BX                              ;

        MOV     AX , [LNG_TRNSMO]               ; ]_ZN^
        MUL     [SEC_PBLOCK]                    ; _ZN^̕ZN^

        CMP     BYTE PTR [READ_V_FLG] , 01H     ;
        JNZ     NOT_V_READ                      ;
        MOV     AX , 1                          ; SET 1SECTOR  WHEN LABEL READ

NOT_V_READ:     
        MOV     [LNG_PTRNS] , AX                ; ]ZN^

        MOV     CX,SEC_PBLOCK
;----------------------------------------------- DOS5 90/12/14 -------
        MOV     AX,BLOCK_TRNS_H                 ;CALCULATE HIGH WORD FIRST
        XOR     DX,DX
        MUL     CX
        MOV     OLD_AX,AX                       ;SAVE RESULT HIGH
        MOV     AX,BLOCK_TRNS                   ;THEN CALCULATE LOW WORD
        XOR     DX,DX
        MUL     CX
        ADD     DX,OLD_AX                       ;RESULT IN DX:AX
;------------------
;       MOV     AX , BLOCK_TRNS                 ; AX<-]Jn_ZN^ԍ
;       XOR     DX , DX                         ;
;       MUL     CX                              ; DX:AX<-]Jn_ZN^ԍ
;---------------------------------------------------------------------
        ADD     AX , [BX]                       ; 
        ADC     DX , [BX+2]                     ; DX:AX<-]JnZN^ԍ
                                                ; 
;----------------------------------------------- DOS5 91/08/00 -------
        mov     MAXSEC,128
        cmp     [MOSW2],0ffh                    ;if 3.5" MO
        je      HD_LOOP
        mov     MAXSEC,64
;---------------------------------------------------------------------
        CALL    REM_CHK                         ; CHECK READ ADDR LIMIT
        JB      HD_ERROR                        ;
HD_LOOP:
;----------------------------------------------- DOS5 91/08/00 -------
        mov     bx,MAXSEC                       ; 
        cmp     LNG_PTRNS , bx                  ; 64K WRAP AROUND CHECK
        jbe     L_OK                            ;
        mov     LNG_PTRNS , bx                  ;
;---------------
;       CMP     LNG_PTRNS , 64                  ; 64K WRAP AROUND CHECK
;       JBE     L_OK                            ;
;       MOV     LNG_PTRNS , 64                  ;
;---------------------------------------------------------------------
L_OK:
;----------------------------------------------- DOS5 91/01/11 -------
        MOV     BYTE PTR [RTRY_CNT] , 5         ; SET RETRY TIMES
;------------------
;       MOV     BYTE PTR [RTRY_CNT] , 3         ; SET RETRY TIMES
;---------------------------------------------------------------------
RW_LOOP_HD:
        CALL    S_HCMD                          ; EXE MO_BIOS
        JB      RTRY_RW_HD                      ; 

        CALL    VERIFY                          ;
        CLC                                     ;
        JMP     short RW_COMMON_RET             ; NORMAL RETURN

RTRY_RW_HD:
        CMP     B_SENSE_KEY , 02H               ; UNIT ATTENSHION
        JZ      HD_ERROR00                      ; 
        CMP     B_SENSE_KEY , 06H               ; 
        JNZ     RETRY_RW_HD00                   ; MEDIA CHENGED
HD_ERROR00:
        CALL    CHECK_MEDIA_OPEN                ; ERR
        JMP     short HD_ERROR                  ;

RETRY_RW_HD00:                                  ;
        DEC     BYTE PTR [RTRY_CNT]             ;
        JZ      HD_ERROR                        ;
        JMP     RW_LOOP_HD                      ; JMP RETRAY 

;***** RETURN PROCESS  *******************

RW_COMMON_RET:
        RET                                     ;

HD_ERROR:
        MOV     AL,[ERR_STATUS]
        STC                                     ; CF<-ON
        RET                                     ;


PAGE
;*************************************
;* VERYIFY                           *
;*                                   *
;* NO OPERATION                      *
;*                                   *
;*************************************
VERIFY:
        CMP     BYTE PTR [VRFY_FLG] , 0 ;
        JZ      VERIFY_RET              ;

VERIFY_RET:
        RET                             ;


;***************************************
;* CHECK ADDR LIMIT                    *
;*-------------------------------------*
;* IN : BX<-ADDR TBL PTR               *
;*      AX:DX <- READ START SECTOR     *
;* OUT: CF = ON  ERR                   *
;*           OFF OK                    *
;***************************************
;-------
REM_CHK:
;-------
        PUSH    DX
        PUSH    AX
        CLC                             ;
        ADD     AX , WORD PTR [LNG_PTRNS]       ; COMPUTE END SECTOR
        ADC     DX , 0000H                      ;
        CMP     DX , WORD PTR [BX+6]            ;
        JA      REM_ERR                         ;
        JB      REM_OK                          ;
        CMP     AX , WORD PTR [BX+4]            ;
        JBE     REM_OK                          ;
REM_ERR:
        MOV     [ERR_STATUS] , _ERR_0C          ;
        STC                                     ;
        JMP     SHORT REM_RET                   ;

REM_OK:
        CLC
REM_RET:
        POP     AX
        POP     DX
        RET


;***************************************
;* ABNORMAL MEDIA CHENGE CHECK         *
;*-------------------------------------*
;*                                     *
;*                                     *
;*                                     *
;***************************************
;-----------------
CHECK_MEDIA_OPEN:
;-----------------
        PUSH    DI
        MOV     AL,CURDRV
        CALL    SETDRIVE
        LEA     SI,[DI].BDS_OPCNT
        POP     DI

        CMP     BYTE PTR [SI] , 00H             ; NOW OPEN ?
        JZ      CHECK_MEDIA_RET                 ; NO THEN JMP
        MOV     ERR_STATUS , _ERR_0F            ;
        MOV     BYTE PTR [SI] , 00H             ; COUNTER RESET

CHECK_MEDIA_RET:
        MOV     DL , SUB_ID                     ; SET UA
        OR      DL , 0A0H
        MOV     CL , 09H                        ; FUNCTION CODE SET
        MOV     AX , 0001H                      ; SET MODISK AI FLAG
        INT     220                             ;

        RET

PAGE
;***************************************
;* GET SCSI ID                         *
;*-------------------------------------*
;*                                     *
;*  OUT: [SUB_ID] <- SCSI ID           *
;*       [MO_DEV_OFFSET]               *
;*       [SUB_OFFSET]                  *
;***************************************
;===========
GET_SCSI_ID:
;===========
        PUSH    AX                              ;
        PUSH    BX                              ;
        PUSH    DX                              ;
;----------------------------------------------- DOS5 91/08/00 -------
        xor     dl,dl
;---------------------------------------------------------------------
        PUSH    CX
        MOV     BX,OFFSET EXLPTBL
        XOR     CX,CX
GET_ID05:
;----------------------------------------------- DOS5 91/08/00 -------
        test    byte ptr [bx],01h               ;CHECK MO DISK FLAG
        jz      GET_ID200

        mov     al,byte ptr [bx+1]
        cmp     al,byte ptr [bx-1]
        je      GET_ID100
        xor     dl,dl
GET_ID100:
        inc     dl                              ; num of partition
        cmp     cl,CURDRV
        je      GET_ID07
GET_ID200:
;----------------------------------------------- DOS5 90/12/22 -------
;       TEST    BYTE PTR [BX],01H               ;CHECK MO DISK FLAG
;       JNZ     GET_ID07
;;------------------
;;      CMP     BYTE PTR [BX],01H               ;CHECK MO DISK FLAG
;;      JE      GET_ID07
;;---------------------------------------------------------------------
        INC     BX
        INC     BX
        INC     CX
        JMP     GET_ID05
GET_ID07:
;----------------------------------------------- DOS5 91/08/00 -------
        pop     cx
        dec     dl                              ; convert to 0 based number
        mov     dh,dl
        mov     bx,offset MO_DEVICE_TBL
        and     al,0fh
GET_ID08:
        cmp     al,[bx.MO_DEV_ID]
        je      GET_ID10
        add     bx,16                           ; 16 byte / 1 unit
        add     dh,4                            ; 4 entry / 1 unit
        jmp     GET_ID08
GET_ID10:
        mov     SUB_UNIT,dh                     ; unit # of MO_DEVICE_TBL
;---------------
;       MOV     AL,CURDRV
;       SUB     AL,CL
;       MOV     SUB_UNIT,AL
;       POP     CX
;
;       MOV     BX , OFFSET MO_DEVICE_TBL       ; 
;       MOV     DL , BYTE PTR [SUB_UNIT]        ; DL <-  LOGICAL UNIT#/MEDIA
;       MOV     AL , DL
;
;GET_ID_10:
;       SUB     AL , BYTE PTR [YUKO_UNIT]       ;
;       JB      GET_ID_20                       ; OFFSET GET
;       PUSH    AX                              ;
;       MOV     AL , BYTE PTR [YUKO_UNIT]       ;
;       XOR     AH , AH                         ;
;       SHL     AX , 1                          ; *4 1DEVTBL LENGTH
;       SHL     AX , 1                          ;
;       ADD     BX , AX                         ;
;       POP     AX                              ;
;       MOV     DL , AL                         ; DL <-  LOGICAL UNIT#/MEDIA  
;       JMP     GET_ID_10                       ; NEXT TBL
;---------------------------------------------------------------------

 GET_ID_20:
        MOV     AL , [BX.MO_DEV_ID]             ; SCSI ID SET
        MOV     BYTE PTR [SUB_ID] , AL          ; SCSI ID SAVE
        MOV     WORD PTR [MO_DEV_OFFSET] , BX   ;
        MOV     BYTE PTR [MO_SUB_OFFSET] , DL   ;

        POP     DX                              ;
        POP     BX                              ;
        POP     AX                              ;

        RET

;***************************************
;* COMMAND FOR SCSI BIOS               *
;*-------------------------------------*
;*  IN:  DX:AX ]JnZN^      *
;*       ES:BP ]AhX            *
;*                                     *
;*  OUT: CF ON<-ERR                    *
;***************************************
;======
S_HCMD:
;======
        CALL    CMD_CLEAR               ;
        MOV     BL , [COM]              ; COMMAND CODE SET
        MOV     B_COMMAND , BL          ;
        MOV     B_LBAVH , DH            ; VERY HIGH SET
        MOV     B_LBAH , DL             ; HIGH SET
        MOV     B_LBAM , AH             ; M SET
        MOV     B_LBAL , AL             ; LOW SET

        MOV     BX , [LNG_PTRNS]        ; ]ZN^
        MOV     B_DLENGTH , BX          ; 
        MOV     B_DOFFSET , BP          ;
        MOV     B_DSEGMENT , ES         ;

        CALL    CMD_FOR_SCSI            ;

S_HCMD_RET:
        RET                             ;

PAGE
;***************************************
;* SCSI CMD FOR MO_BIOS                *
;*-------------------------------------*
;* IN : [B_COMMAND]                    *
;* OUT: CF=01 ERR                      *
;*         [ERR_STATUS]                *
;***************************************
;===========
CMD_FOR_SCSI:
;===========
        PUSH    BX              
        PUSH    ES              
        MOV     BX , DS         
        MOV     ES , BX         
        MOV     BH , [SUB_ID]                   ; SCSI ID SET
        MOV     BYTE PTR [B_SCSIID] , BH        ;
        MOV     BX , OFFSET B_COMMAND           ;
        CALL    MO_BIOS                         ;
        JB      MT_01                           ; CF <- ON ERR
        CMP     [B_ODC_STATUS] , 00H            ;
        JZ      MT_00                           ;
        JMP     short MT_03                     ;
MT_00:  
        CLC                                     ;
        CMP     [B_SCSI_STATUS] , 06H           ; SCSI NORMAL END?
        JZ      MT_RET                          ;
MT_01:
        STC                                     ;
        MOV     [ERR_STATUS] , _ERR_02          ; SCSI ERR
        JMP     short MT_RET                    ;
MT_03:
        CALL    CHECK_ERR_STATUS                ;
        STC
MT_RET:
        POP     ES
        POP     BX
        RET

;***************************************
;* ODC CONTROLER STATUS CHECK          *
;*-------------------------------------*
;*  IN:  [B_SENSE_CODE]                *
;*                                     *
;*  OUT: [ERR_STATUS]<-FOR MS-DOS      *
;***************************************
;===============
CHECK_ERR_STATUS:
;===============
        PUSH    SI                              ;
        PUSH    AX                              ;
        MOV     [ERR_STATUS] , 00H              ;
        MOV     AL , BYTE PTR [B_SENSE_CODE]    ;
        CMP     AL , 50H                        ;
        JB      GET_ERR_CODE                    ; IF SENSE_CODE < 50H THEN JMP 

        CMP     BYTE PTR [B_SENSE_CODE] , 98H   ; Write err?            H1.7.5
        JNE     CHECK_ERR_01                    ;                       H1.7.5
        MOV     [ERR_STATUS] , _ERR_0A          ;Write err ststus set   H1.7.5
        JMP     SHORT CHECK_ERR_RET             ;                       H1.7.5

CHECK_ERR_01:                                   ;                       H1.7.5
        CMP     BYTE PTR [B_SENSE_CODE] , 0ABH  ; Read err?             H1.7.5
        JNE     CHECK_ERR_02                    ;                       H1.7.5
        MOV     [ERR_STATUS] , _ERR_0B          ; Read err ststus set   H1.7.5
        JMP     SHORT CHECK_ERR_RET             ;                       H1.7.5

CHECK_ERR_02:
        MOV     [ERR_STATUS] , _ERR_0C          ;
        JMP     SHORT CHECK_ERR_RET             ;

GET_ERR_CODE:
        MOV     SI , OFFSET ERR_CODE_TBL        ; GET ERR CODE FROM TBL
        XOR     AH , AH                         ;
        ADD     SI , AX                         ;
        MOV     AL , BYTE PTR [SI]              ;
        MOV     [ERR_STATUS] , AL                       ;

CHECK_ERR_RET:
        POP     AX
        POP     SI                      ;
        RET     
PAGE
SUBTTL  ncbPSP@CfBXN@R}hahnr
;************************************************************************
;****************************************************************
;*                                                              *
;*              ʃvOƂ̃C^tF[X                *
;*                                                              *
;*               +---------------+---------------+              *
;*      ES:BX -> |  Command code |  Command flag |  +00H        *
;*               +---------------+---------------+              *
;*               |    SCSI-ID    |    Reserve    |  +02H        *
;*               +---------------+---------------+              *
;*               |  Logical Block address (V-H/H)|  +04H        *
;*               +---------------+---------------+              *
;*               |          "             (M/L)  |  +06H	*
;*               +---------------+---------------+              *
;*               |  Data area pointer (offset)   |  +08H        *
;*               +---------------+---------------+              *
;*               |          "         (segment)  |  +0AH	*
;*               +---------------+---------------+              *
;*               |          Data length          |  +0CH        *
;*               +---------------+---------------+              *
;*               | ODC141 Status |  SCSI Status  |  +0EH        *
;*               +---------------+---------------+              *
;*               |   Sense Key   |   Sense Code  |  +10H        *
;*               +---------------+---------------+              *
;*               |            Reserve            |  +12H        *
;*               +---------------+---------------+              *
;*                                                              *
;*                                                              *
;*              b`kk        lnQahnr                  *
;*                                                              *
;*              óFbeEEEnee@R}hI            *
;*                              nm    荞݂ۗ          *
;*                                                              *
;*      c@@                      *
;*              XVĕԂB                                  *
;*              îc@@wj*
;*                                                              *
;*      c@                                  *
;*              vꂽ̖̒ԂB            *
;*              iȌꍇ́AvꂽSĂ̒*
;*              @ɂȂj                                      *
;*                                                              *
;****************************************************************

PAGE

CMD_CNT         = 8

;*****************************************************************
;**                                                             **
;**                    MO_BIOS main routine                     **
;**                                                             **
;*****************************************************************
MO_BIOS_FAR     PROC    FAR
        CALL    MO_BIOS
        RET
MO_BIOS_FAR     ENDP

MO_BIOS:                                ;
        PUSH    AX                      ;
        PUSH    BX                      ;
        PUSH    CX                      ;
        PUSH    DX                      ;
        PUSH    SI                      ;
        PUSH    DI                      ;
        PUSH    BP                      ;
        PUSH    DS                      ;
        PUSH    ES                      ;

        or      HDIO_FLG,01h    ;

        CLI
        mov     [save_ax],ax
        mov     [save_ss],ss
        mov     [save_sp],sp
        mov     ax,ds
        mov     ss,ax
        mov     sp,offset stack
        mov     ax,[save_ax]
        STI
;----------------------------------------------- DOS5 91/01/10 -------
        MOV     AX , DS                 ;
;       MOV     AX , CS                 ;
;       MOV     DS , AX                 ;
;---------------------------------------------------------------------
        PUSH    ES                      ; Work area clear
        MOV     ES , AX                 ;
        XOR     AX , AX                 ;
        LEA     DI , REMAIN_ADDR        ;
        MOV     CX , 3                  ;
        REP     STOSW                   ;
        POP     ES                      ;

        MOV     AL , ES:[BX]._CMD       ; Get command code
        LEA     SI , MO_CMD_TBL         ;
        MOV     CX , CMD_CNT            ;

CMD_SEARCH:                             ;
        CMP     AL , CS:[SI]            ; Found command code ?
        JE      MO_CMD_GO               ;  [Yes]

        ADD     SI , 3                  ; Next command code pointer
        LOOP    CMD_SEARCH              ;

        CLC                             ; Command error
        JMP     SHORT   SET_PATH        ;

MO_CMD_GO:                              ;
        INC     SI                      ; Function routine pointer
;---------------------------------------;
        CALL    cs:[SI]                 ;
;---------------------------------------;
        JC      SET_PATH                ; Command don't go

        MOV     AX , [REMAIN_ADDR]      ; Next buffer address set (offset)
        MOV     ES:[BX]._BPTR , AX      ;            "
        MOV     AX , [REMAIN_ADDR+2]    ;            "		  (segment)
        MOV     ES:[BX]._BPTR+2 , AX    ;            "
        MOV     AX , [REMAIN_LNG]               ; Remain data length set
        MOV     ES:[BX]._LNG , AX       ;            "

SET_PATH:                               ;

        CLI
        mov     ss,[save_ss]
        mov     sp,[save_sp]
        pushf
        and     HDIO_FLG,0feh   ;
        popf

        STI
        POP     ES                      ;
        POP     DS                      ;
        POP     BP                      ;
        POP     DI                      ;
        POP     SI                      ;
        POP     DX                      ;
        POP     CX                      ;
        POP     BX                      ;
        POP     AX                      ;
        RET                             ;

PAGE
;*****************************************************************
;**                                                             **
;**                ODC141 Function process area                 **
;**                                                             **
;*****************************************************************
;****************************************
;*           TEST UNIT READY            *
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*                                      *
;*      OUT : Nothing                   *
;****************************************
;=========
TEST_UNIT:
;=========
        CALL    CLR_PARA_AREA           ;
        MOV     AL , 6                  ; CDB Length set
        MOV     [PARAMETER+2] , AL      ;        "
        MOV     AL , 00H                ; Command code set
        MOV     [CDB] , AL              ;        "
        CALL    SET_ID_NO               ; SCSI-ID Set (CDB and AL)
        CALL    SCSI_01_CMD             ;
        JZ      TEST_UNIT               ; Command retry
        RET                             ;

PAGE
;****************************************
;*                 READ                 *
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*                                      *
;*      OUT : Nothing                   *
;****************************************
;====
READ:
;====
        CALL    CLR_PARA_AREA           ;
        MOV     AX , 0A44H              ; Send vector and CDB Length set
        MOV     Word Ptr [PARAMETER+1] , AX;            "
        MOV     AL , 28H                ; Command code set
        MOV     [CDB] , AL              ;        "
        MOV     AX , ES:[BX]._SPTR      ; Read sector pointer set (MSB)
        MOV     Word Ptr [CDB+2] , AX   ;            "
        MOV     AX , ES:[BX]._SPTR+2    ;            "		  (LSB)
        MOV     Word Ptr [CDB+4] , AX   ;            "
        MOV     AX , ES:[BX]._LNG       ; Read block count set
        XCHG    AL , AH                 ;          "
        MOV     Word Ptr [CDB+7] , AX   ;          "
        XCHG    AH , AL                 ;
        MOV     CL , 10                 ;
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     [MOSW2],0ffh            ;if 3.5" MO
        jne     READ10
        mov     cl,9                    ; 512 bytes/physical sector
READ10:
;---------------------------------------------------------------------
        SHL     AX , CL                 ; Sector count * 1024
        PUSH    AX                      ;
        MOV     AL , 00H                ; read without error check
        MOV     [CDB+9] , AL            ;       "
        CALL    SET_ID_NO               ; SCSI-ID Set (CDB and AL)
        POP     CX                      ; Read data length set
        CALL    SCSI_01_CMD             ;
        JZ      READ                    ; Command retry
        RET                             ;

;****************************************
;*                WRITE                 *
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*                                      *
;*      OUT : Nothing                   *
;****************************************
;============
WRITE:
WRITE_VERIFY:
;============
        CALL    CLR_PARA_AREA           ;
        MOV     AX , 0A48H              ; Send vector and CDB Length set
        MOV     Word Ptr [PARAMETER+1] , AX;            "
        MOV     AL , _WRITE2            ; Command code set
        MOV     [CDB] , AL              ;        "
        MOV     AX , ES:[BX]._SPTR      ; Write sector pointer set (MSB)
        MOV     Word Ptr [CDB+2] , AX   ;             "
        MOV     AX , ES:[BX]._SPTR+2    ;             "		   (LSB)
        MOV     Word Ptr [CDB+4] , AX   ;             "
        MOV     AX , ES:[BX]._LNG       ; Write block count set
        XCHG    AL , AH                 ;           "
        MOV     Word Ptr [CDB+7] , AX   ;           "
        XCHG    AH , AL                 ;
        MOV     CL , 10                 ;
;----------------------------------------------- DOS5 91/08/00 -------
        cmp     [MOSW2],0ffh            ;if 3.5" MO
        jne     WRITE10
        mov     cl,9                    ; 512 bytes/physical sector
WRITE10:
;---------------------------------------------------------------------
        SHL     AX , CL                 ; Sector count * 1024
        PUSH    AX                      ;
        MOV     AL , 00H                ; Function set (Change sector and Track)
        MOV     [CDB+9] , AL            ;       "
        CALL    SET_ID_NO               ; SCSI-ID Set (CDB and AL)
        POP     CX                      ; Write data length set
        CALL    SCSI_01_CMD             ;
        JZ      WRITE                   ; Command retry
        RET                             ;

PAGE
;****************************************
;*               INQUIRY                *
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*                                      *
;*      OUT : Nothing                   *
;****************************************
;=======
INQUIRY:
;=======
        CALL    CLR_PARA_AREA           ;
        MOV     AX , 0644H              ; Send vector and CDB Length set
        MOV     Word Ptr [PARAMETER+1] , AX;            "
        MOV     AL , 12H                ; Command code set
        MOV     [CDB] , AL              ;        "
        MOV     AX , ES:[BX]._LNG       ; Get data length set
        MOV     [CDB+4] , AL            ;          "
        CALL    SET_ID_NO               ; SCSI-ID Set (CDB and AL)
        MOV     CX , ES:[BX]._LNG       ; Get data length set
        CALL    SCSI_01_CMD             ;
INQ_RET:
        RET                             ;

;****************************************
;*     PREVENT/ALLOW MEDIA REMOVAL      *
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*                                      *
;*      OUT : Nothing                   *
;****************************************
;=============
PREVENT_ALLOW:
;=============

        CALL    CLR_PARA_AREA           ;
        MOV     AL , 6                  ; CDB Length set
        MOV     [PARAMETER+2] , AL      ;        "
        MOV     AL , 1EH                ; Command code set
        MOV     [CDB] , AL              ;        "
        MOV     AL , ES:[BX]._FLAG      ; Command flag set
        MOV     [CDB+4] , AL            ;        "
        CALL    SET_ID_NO               ; SCSI-ID Set (CDB and AL)
        CALL    SCSI_01_CMD             ;
        JZ      PREVENT_ALLOW           ; Command retry
        RET                             ;


PAGE
;*****************************************************************
;**                                                             **
;**             All function common subroutine area             **
;**                                                             **
;*****************************************************************
;****************************************
;*     Parameter area clear process     *
;*--------------------------------------*
;*      IN  : Nothing                   *
;*                                      *
;*      OUT : Nothing                   *
;****************************************
;-------------
CLR_PARA_AREA:
;-------------

        PUSH    ES                      ;
;----------------------------------------------- DOS5 91/01/10 -------
        MOV     AX , DS                 ;
;       MOV     AX , CS                 ;
;---------------------------------------------------------------------
        MOV     ES , AX                 ;
        XOR     AX , AX                 ; Parameter clear data
        LEA     DI , [PARAMETER]                ;
        MOV     CX , 7                  ; Parameter area length (word)
        REP     STOSW                   ;
        POP     ES                      ;
        RET                             ;

;****************************************
;* SCSI-ID Parameter & CDB Set process  *
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*                                      *
;*      OUT : AL  SCSI-ID         *
;****************************************
;---------
SET_ID_NO:
;---------

        MOV     AL , ES:[BX]._LUN       ; Get LUN (For ICB)
        MOV     CL , 5                  ;
        SHL     AL , CL                 ; For ODC141 CDB
        OR      [CDB+1] , AL            ; CDB Set

        MOV     AL , ES:[BX]._SCSI_ID   ; Get SCSI-ID No. (For ICB)
        OR      AL , 0C0H               ; For SCSI-BIOS Parameter
        XOR     CX , CX                 ;
        RET                             ;

PAGE
;****************************************
;*SCSI-BIOS Command put process (GRP0,1)*
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*            AL  SCSI-ID         *
;*            CX  Data length     *
;*                                      *
;*      OUT : CF  Command don't go*
;*            ZF  Peset put       *
;****************************************

;-----------
SCSI_01_CMD:
;-----------

        RET                             ;

;****************************************
;*        SCSI LSI Reset process        *
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*                                      *
;*      OUT : Nothing                   *
;****************************************
;----------
SCSI_RESET:
;----------
ifndef                                  ;NEC 93/2/18
        MOV     AH , 00H                ; Reset command code
        MOV     AL , ES:[BX]._SCSI_ID   ; SCSI-ID Set
        OR      AL , 0C0H               ;
        MOV     DX , 0080H              ;
        INT     1BH                     ;
endif                                   ;NEC 93/2/18
        RET                             ;

;****************************************
;*        SCSI STATUS PHASE             *
;*--------------------------------------*
;*      IN  : ES:BX  ICB Pointer     *
;*                                      *
;*      OUT : Nothing                   *
;****************************************
;*
;*****  Status phase  *****
;*
STATUS_PHASE0:                          ;
        RET                             ;

PAGE
;*****************************************************************
;*****************************************************************
;**                                                             **
;**                                                             **
;**                     DATA AREA                               **
;**                                                             **
;**                                                             **
;*****************************************************************
;*****************************************************************

;****************************************
;*            Command table             *
;****************************************

MO_CMD_TBL:
                DB      00H             ; Group 0
                DW      TEST_UNIT
                DB      08H
                DW      READ
                DB      0AH
                DW      WRITE
                DB      12H
                DW      INQUIRY
                DB      1EH
                DW      PREVENT_ALLOW
                DB      28H
                DW      READ
                DB      2AH
                DW      WRITE
                DB      2EH
                DW      WRITE_VERIFY

;;----------------------------------------------- DOS5 91/01/10 -------
;;****************************************
;;*      For SCSI Parameter area        *
;;****************************************
;;
;;PARAMETER     DB      00H                     ; Target LUN
;;              DB      00H                     ; Data send vector
;;              DB      00H                     ; CDB Length
;;              DB      00H                     ; Reserve
;;CDB           DB      00H                     ; Command code  0
;;              DB      00H                     ; Bit7-5 LUN    1
;;              DB      00H                     ;               2
;;              DB      00H                     ;               3
;;              DB      00H                     ;               4
;;              DB      00H                     ;               5
;;              DB      00H                     ;               6
;;              DB      00H                     ;               7
;;              DB      00H                     ;               8
;;              DB      00H                     ;               9
;;
;;****************************************
;;*           Work data area            *
;;****************************************
;;
;;REMAIN_ADDR   DW      0000H                   ; Next buffer address (offset)
;;              DW      0000H                   ;          "	      (segment)
;;REMAIN_LNG    DW      0000H                   ; Remain length
;;
;;BUFFER                DB      23 DUP (0CCH)
;;---------------------------------------------------------------------

ICB_TBL         STRUC
    _CMD        DB      00H     ; Command code
    _FLAG       DB      00H     ;    "	  flag
    _SCSI_ID    DB      00H     ; SCSI-ID
    _LUN        DB      00H     ; Local Unit Number
    _SPTR       DW      0000H   ; Logical block address (MSB)
                DW      0000H   ;           "		(LSB)
    _BPTR       DW      0000H   ; Buffer pointer (offset)
                DW      0000H   ;        "	 (segment)
    _LNG        DW      0000H   ; Data length
    _ODC_ST     DB      00H     ; Completion status
    _SCSI_ST    DB      00H     ; SCSI Status
    _SEN_KEY    DB      00H     ; Sense key
    _SEN_DT     DB      00H     ; Sense code
                DB      00H     ; Reserve
                DB      00H     ; Reserve
ICB_TBL         ENDS

MODISK_CODE_END:
MODISK_END:
BIOS_CODE       ENDS
        END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\hdbiok.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 HDBIOK.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: HDBIOK.ASM                                 *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************
;

        PAGE

;---------------------------------------
;
;       SYSTEM_COMMON AREA     85/02/19
;
;---------------------------------------

DATA    SEGMENT AT      0000H           ;DSEG   0
        ORG     480H
BIOS_FLAG1              DB      1 DUP(?)
HDSK_MODE               DB      1 DUP(?)
        ORG     492H
DISK_RESET              DB      1 DUP(?)
F2HD_MODE               DB      1 DUP(?)
DISK_EQUIP2             DB      1 DUP(?)
        ORG     500H
BIOS_FLAG               DW      1 DUP(?)

        ORG     55CH
DISK_EQUIP              DW      1 DUP(?)
DISK_INT                DW      1 DUP(?)
DISK_TYPE               DB      1 DUP(?)
DISK_MODE               DB      1 DUP(?)
DISK_TIME               DW      1 DUP(?)
DISK_RESULT             DW      16 DUP(?)
DISK_BOOT               DB      1 DUP(?)
DISK_STATUS             DB      1 DUP(?)
DISK_SENSE              DW      2 DUP(?)
        ORG     586H
DISK_SSB0A              DW      1 DUP(?)
        ORG     5E8H
DISK_PRM0               DW      2 DUP(?)
DISK_PRM1               DW      2 DUP(?)

DATA    ENDS
;
        PAGE
;
;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATA

        EXTRN   H5_STUS:NEAR,H5_DPM:WORD

Bios_Code       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATA

        PUBLIC  HDBIOK_CODE_START
        PUBLIC  HDBIOK_CODE_END
        PUBLIC  HDBIOK_END

HDBIOK_CODE_START:

        PUBLIC  HD_ENTC

;
;------ 5" HARD	DISK BASIC I/O ROUTINE
;
;
;       '86/09/01
;       '85/05/08
;       '85/04/23
;       '85/04/19	CREATED
;       '88/04/xx	DOS 3.3 N10 ROUTIN
;
;       5" HARD DISK BIOS
;                                       AUTHOR I.HASHIBA
;
DISK_EQIP       EQU     BYTE PTR DS:[055DH]
DISK_INTF       EQU     BYTE PTR DS:[055FH]
DISK_INTO       EQU     WORD PTR DS:[0044H]
DISK_INTS       EQU     WORD PTR DS:[0046H]
DISK_STUS       EQU     BYTE PTR DS:[0585H]
DISK_SSB0W      EQU     WORD PTR DS:[0586H]
DISK_SSB0       EQU     BYTE PTR DS:[0586H]
DISK_SSB1       EQU     BYTE PTR DS:[0587H]
DISK_SSB2W      EQU     WORD PTR DS:[0588H]
DISK_SSB2       EQU     BYTE PTR DS:[0588H]
DISK_SSB3       EQU     BYTE PTR DS:[0589H]
;
DSK_IDR EQU     80H                     ;INPUT DATA REGISTER
DSK_ODR EQU     80H                     ;OUTPUT DATA REGISTER
DSK_CSR EQU     82H                     ;CHANNEL STATUS REGISTER
DSK_CCR EQU     82H                     ;CHANNEL CONTROL REGISTER
;
S_INT   EQU     01H                     ;INTERRUPT
S_PER   EQU     02H                     ;PARITY ERROR
S_IXO   EQU     04H                     ;INPUT/OUTPUT
S_CXD   EQU     08H                     ;COMMAND/DATA
S_MSG   EQU     10H                     ;MESSAGE
S_BSY   EQU     20H                     ;BUSY
S_ACK   EQU     40H                     ;ACKNOWLEDGE
S_REQ   EQU     80H                     ;REQUEST
;
C_SWC   EQU     00H                     ;SWITCH
C_INT   EQU     01H                     ;INTERRUPT ENABLE
C_DMA   EQU     02H                     ;DIRECT MEMORY ACCESS ENABLE
C_RST   EQU     08H                     ;RESET
C_SEL   EQU     20H                     ;SELECT
C_CTL   EQU     40H                     ;CONTROL
C_CHN   EQU     80H                     ;CHANNEL ENABLE

DMA_ADR0        EQU     01H
DMA_CNT0        EQU     03H
DMA_ADR1        EQU     05H
DMA_CNT1        EQU     07H
DMA_ADR2        EQU     09H
DMA_CNT2        EQU     0BH
DMA_ADR3        EQU     0DH
DMA_CNT3        EQU     0FH
DMA_SMR         EQU     15H
DMA_BPTR        EQU     19H
DMA_BNK0        EQU     27H
DMA_BNK2        EQU     23H
DMA_BNK3        EQU     25H
DMA_CMD         EQU     11H
DMA_MOD         EQU     17H
DMA_MCL         EQU     1BH
DMA_MSK         EQU     15H

BIO_FLG EQU     BYTE PTR 18[BP] ; FLAG
BIO_CMD EQU     BYTE PTR  1[BP] ; COMMAND
BIO_UNT EQU     BYTE PTR  0[BP] ; UNIT
BIO_DTL EQU     WORD PTR  2[BP] ; DATA LENGTH
BIO_BLK EQU     BYTE PTR  3[BP]
BIO_CYW EQU     WORD PTR  4[BP]
BIO_CYL EQU     BYTE PTR  4[BP] ; CYLINDER #
BIO_HED EQU     BYTE PTR  7[BP] ; HEAD #
BIO_SEC EQU     BYTE PTR  6[BP] ; SECTER #
BIO_NUM EQU     BYTE PTR  5[BP] ; SECTER LENGTH
BIO_DTA EQU     WORD PTR  8[BP] ; DATA OFFSET
BIO_DTS EQU     WORD PTR 10[BP] ; DATA SEGMENT

;
;---------- ENTRY
;
HD_ENTC:
        PUSHF
        STI
        CLD
        PUSH    DS
        PUSH    SI
        PUSH    DI
        PUSH    ES
        PUSH    BP
        PUSH    DX
        PUSH    CX
        PUSH    BX
        PUSH    AX
        MOV     BP,SP
        XOR     BX,BX
        MOV     DS,BX
        MOV     ES,BX
        CLI                             ;DISABLE
        MOV     WORD PTR DISK_INTO,OFFSET H5_INTR
        MOV     DISK_INTS,CS
        IN      AL,0AH                  ;READ IMR
        AND     AL,0FDH
        OUT     0AH,AL
        STI                             ;ENABLE
        AND     AH,0FH
        SAL     AH,1
        MOV     BL,AH
H5_ENTR:
        CALL    CS:WORD PTR H5_JPT[BX]
        MOV     BIO_CMD,AH
        AND     BIO_FLG,0FEH
        CMP     AH,20H
        JB      H5_EXTC
        OR      BIO_FLG,01H
H5_EXTC:
        MOV     AL,04H
        OUT     DMA_SMR,AL
        CLI
        IN      AL,0AH                  ;READ IMR
        OR      AL,02H
        OUT     0AH,AL
DS_CEXT:
        STI
        POP     AX
        POP     BX
        POP     CX
        POP     DX
        POP     BP
        POP     ES
        POP     DI
        POP     SI
        POP     DS
        POPF
        RET
;
;------ JUMP TABLE
;
H5_JPT  DW      OFFSET  H5_SEEK
        DW      OFFSET  H5_VRFY
        DW      OFFSET  H5_NOP
        DW      OFFSET  H5_INZT
        DW      OFFSET  H5_SENS
        DW      OFFSET  H5_WRIT
        DW      OFFSET  H5_READ
        DW      OFFSET  H5_RCAL
        DW      OFFSET  H5_ASGN
        DW      OFFSET  H5_NOP
        DW      OFFSET  H5_NOP
        DW      OFFSET  H5_FBAD
        DW      OFFSET  H5_NOP
        DW      OFFSET  H5_FORM
        DW      OFFSET  H5_MODE         ;MODE SET
        DW      OFFSET  H5_RTRT

        PAGE

;
;------ ASSIGN ALTERNATE TRACK ADDRESS
;
H5_ASGN:
        CALL    H5_CHKM
        CALL    H5_PRMH
        CALL    H5_LADS
        MOV     ES,BIO_DTS
        MOV     DI,BIO_DTA
        MOV     AL,DISK_SSB1
        AND     AL,1FH
        STOSB
        MOV     AL,DISK_SSB2
        STOSB
        MOV     AL,DISK_SSB3
        STOSB
        MOV     AL,0
        STOSB
;
;------ NO OPERATION
;
H5_NOP:
        MOV     AH,00H
        RET
H5_RSET:
        AND     DISK_INTF,0FCH
        CALL    H5_BRST                 ;BUS RESET
        JNZ     H5_NOP
        CALL    DS_WSEC
        XOR     AH,AH
        PUSH    BP
        PUSH    AX
        MOV     BP,SP
        MOV     BIO_UNT,00H
        CALL    H5_ARRS
        MOV     BIO_UNT,01H
        CALL    H5_ARRS
        POP     AX
        POP     BP
        MOV     AH,00H
        RET
H5_ARRS:
        CALL    H5_ADPR
        CALL    H5_RCAL
        CALL    H5_RTRT
        RET
;
;       BUS RESET SUBROUTINE
;
H5_BRST:
        MOV     AL,C_RST
        OUT     DSK_CCR,AL              ;RESET
        XOR     CX,CX
        LOOP    $
        MOV     AL,0
        OUT     DSK_CCR,AL              ;RESET
        MOV     AL,C_CTL
        JMP     SHORT   $+2
        OUT     DSK_CCR,AL
        JMP     SHORT   $+2
        IN      AL,DSK_CSR
        TEST    AL,S_BSY
        RET
;
;------ INITIALIZE
;
H5_INZT:
        AND     DISK_EQIP,0FCH
        AND     DISK_INTF,0FCH
        CALL    H5_BRST                 ;BUS RESET
        JNZ     H5_NOP
;
        MOV     AL,C_SWC
        OUT     DSK_CCR,AL
        JMP     SHORT   $+2
        IN      AL,DSK_CSR
        MOV     AH,AL
;
        MOV     DH,00H
        AND     AL,38H
        CMP     AL,38H
        JE      H5_INZ0
        OR      DH,01H
H5_INZ0:
        AND     AH,07H
        CMP     AH,07H
        JE      H5_INZ1
        OR      DH,02H
H5_INZ1:
        MOV     DL,2                    ;READY CHECK COUNT AT WARM START
        TEST    BYTE PTR BIOS_FLAG,80H
        JNZ     H5_INZ2
        MOV     DL,30                   ;READY CHECK COUNT AT COLD START
H5_INZ2:
        CALL    DS_WSEC                 ;WAIT LOOP 1 SECOND
        XOR     AH,AH
        PUSH    BP
        PUSH    DX                      ;DH,DL=BYTE PTR 3,2[BP]
        PUSH    AX
        MOV     BP,SP
;
        MOV     BIO_UNT,00H
        CALL    H5_ADPR
        MOV     BIO_UNT,01H
        CALL    H5_ADPR
;
H5_INZ4:
        TEST    BYTE PTR 3[BP],01H
        JZ      H5_INZ5
        MOV     BIO_UNT,00H
        CALL    H5_SENS
        CMP     AH,90H
        JE      H5_INZ41
        TEST    AH,0F0H
        JNZ     H5_INZ5
        OR      DISK_EQIP,01H
H5_INZ41:
        AND     BYTE PTR 3[BP],0FEH
H5_INZ5:
        TEST    BYTE PTR 3[BP],02H
        JZ      H5_INZ6
        MOV     BIO_UNT,01H
        CALL    H5_SENS
        CMP     AH,90H
        JE      H5_INZ51
        TEST    AH,0F0H
        JNZ     H5_INZ6
        OR      DISK_EQIP,02H
H5_INZ51:
        AND     BYTE PTR 3[BP],0FDH
H5_INZ6:
        TEST    BYTE PTR 3[BP],03H
        JZ      H5_INZ7
        DEC     BYTE PTR 2[BP]
        JZ      H5_INZ7
        CALL    DS_WSEC                 ;WAIT LOOP 1 SECOND
        JMP     SHORT   H5_INZ4
H5_INZ7:
        MOV     BIO_UNT,00H
        CALL    H5_ARRS
        MOV     BIO_UNT,01H
        CALL    H5_ARRS
        POP     AX
        POP     DX
        POP     BP
H5_INZ8:
        MOV     AH,00H
        RET
;
;       SEEK COMMAND
;
H5_SEEK:
        CALL    H5_ADPR
        CALL    H5_PRMH
        CALL    H5_LADS
        CALL    H5_SLCT                 ;SELECTION
        MOV     AX,0B00H+C_CHN+C_CTL+C_INT
        OUT     DSK_CCR,AL
        CALL    H5_6BYT                 ;OUTPUT 6 BYTE COMMAND
        XOR     CX,CX
H5_SEK1:
        TEST    DISK_INTF,01H
        LOOPZ   H5_SEK1
        JZ      H5_SEK3
        CALL    H5_RSLT
        RET
H5_SEK3:
        CALL    H5_RSLT
        TEST    AH,0F0H
        JNZ     H5_SEK4
        MOV     AH,10H
H5_SEK4:
        RET
;
;------ SENSE
;
H5_SENS:
        CALL    H5_SLCT                 ;SELECTION
        MOV     AX,0000H+C_CHN+C_CTL+C_INT
        OUT     DSK_CCR,AL
        CALL    H5_COMD
        MOV     AH,BIO_UNT
        MOV     CL,5
        SAL     AH,CL
        CALL    H5_COMD
        MOV     AH,0
        MOV     CX,4
H5_SEN0:
        CALL    H5_COMD
        LOOP    H5_SEN0
        CALL    H5_RSLT
        TEST    AH,0F0H
        JNZ     H5_SEN1         ; ERROR
        CALL    H5_PRMH
        OR      AH,CS:20[BX]                    ;ES --> CS      88/04/11
        TEST    BIO_CMD,80H
        JZ      H5_SEN1
        AND     AH,0F0H
        OR      AH,CS:28[BX]                    ;ES --> CS      88/04/11
        PUSH    AX
        MOV     BIO_DTL,0100H
        MOV     BIO_SEC,33
        CALL    H5_RDSW
        JZ      H5_SEN2
        MOV     BIO_DTL,0200H
        MOV     BIO_SEC,17
H5_SEN2:
        POP     AX
        MOV     DL,CS:3[BX]                     ;ES --> CS      88/04/11
                                        ;#                              860829
        INC     DL                      ;<                              860829
        MOV     BIO_HED,DL
        MOV     DX,CS:4[BX]                     ;ES --> CS      88/04/11
        XCHG    DH,DL
        MOV     BIO_CYW,DX
H5_SEN1:
        RET
;
;------ VERIFY DATA
;
H5_VRFY:
        MOV     AL,C_CTL
        OUT     DSK_CCR,AL
        JMP     SHORT   $+2
        IN      AL,DSK_CSR
        TEST    AL,02H
        MOV     AX,0540H
        JNZ     H5_VRF1
        MOV     AX,0840H
H5_VRF1:
        CALL    H5_RWCM
        CMP     AH,08H
        JNE     H5_VRF0
        TEST    BIO_CMD,20H
        JZ      H5_CDER
        OR      AH,0B0H
H5_VRF0:
        RET
;
;------ READ DATA
;
H5_READ:
        MOV     AX,0844H
        CALL    H5_RWCM
        CMP     AH,08H
        JNE     H5_REA0
        TEST    BIO_CMD,20H
        JZ      H5_CDER
        OR      AH,0B0H
H5_REA0:
        RET
;
;------ CORRECTABLE DATA FIELD ERROR
;
H5_CDER:
        MOV     AH,40H
        TEST    DISK_SSB0,80H
        JZ      H5_CDE0
        INC     DISK_SSB3
        ADC     DISK_SSB2,0
        ADC     DISK_SSB1,0
        IN      AL,DMA_CNT0
        MOV     AH,AL
        IN      AL,DMA_CNT0
        XCHG    AL,AH
        INC     AX
        PUSH    AX
        CALL    H5_RDSW
        POP     AX
        JZ      H5_CDE3
        SHR     AH,1
        CMP     AH,0
        JNZ     H5_CDE3
        MOV     AH,80H
H5_CDE3:
        MOV     DISK_SSB0,AH
        MOV     AH,40H
        CMP     AL,0
        JNE     H5_CDE0
        MOV     AH,08H
        CMP     DISK_SSB0,00H
        JE      H5_CDE0
        CALL    H5_SLCT
        MOV     AX,0800H+C_CHN+C_CTL+C_DMA+C_INT
        CALL    H5_IOCM
        CMP     AH,08H
        JE      H5_CDER
        JA      H5_CDE0
        MOV     AH,08H
H5_CDE0:
        RET
;
;------ WRITE DATA
;
H5_WRIT:
        MOV     AX,0A48H                ;WRITE COMMAND
H5_RWCM:
        CALL    H5_CHKM
        PUSH    AX
        CALL    H5_DMAS
        POP     AX
        JB      H5_BUND                 ;DMA BOUNDALY ERROR
        CALL    H5_PRMH
        CALL    H5_LADS
        CALL    H5_SLCT
        MOV     AL,C_CHN+C_CTL+C_DMA+C_INT
H5_IOCM:
        OUT     DSK_CSR,AL
        CALL    H5_6BYT
        CALL    H5_RSLT
        RET
H5_6BYT:
        CALL    H5_COMD
        MOV     AH,DISK_SSB1
        CALL    H5_COMD
        MOV     AH,DISK_SSB2
        CALL    H5_COMD
        MOV     AH,DISK_SSB3
        CALL    H5_COMD
        MOV     AH,DISK_SSB0
        CALL    H5_COMD
        MOV     AH,00H
        TEST    BIO_CMD,20H
        JZ      H5_6BYX
        MOV     AH,0C0H
H5_6BYX:
        CALL    H5_COMD
        RET
;
;------ DMA BOUNDARY
;
H5_BUND:
        MOV     AH,20H
        RET
;
H5_DMAS:
        CLI                                     ;90/03/22
        CALL    DS_PADR
        PUSH    AX
        OUT     DMA_ADR0,AL
        MOV     AL,AH
        OUT     DMA_ADR0,AL
        MOV     AL,CH
        OUT     DMA_BNK0,AL
        MOV     AX,BIO_DTL
        DEC     AX
        OUT     DMA_CNT0,AL
        XCHG    AL,AH
        OUT     DMA_CNT0,AL
        XCHG    AL,AH
        POP     CX
        ADD     AX,CX
        MOV     AL,00H
        OUT     DMA_SMR,AL
        STI                                     ;90/03/22
        RET
;
;------ RECALIBRATE
;
H5_RCAL:
        CALL    H5_ADPR
        CALL    H5_SLCT
        CALL    H5_PRMH                 ;SETUP PARAMETOR ADDRESS
        MOV     AX,5
        CALL    H5_CYAD                 ;SETUP CYLINDER ADDRESS
        CALL    H5_LUNS                 ;SETUP LOGICAL UNIT NUMBER
        MOV     AX,0B00H+C_CHN+C_CTL+C_INT
        CALL    H5_IOCM                 ;SEEK TO CYLINDER 0
        CALL    H5_SLCT
        XOR     AX,AX
        MOV     DISK_SSB0W,AX
        MOV     DISK_SSB2W,AX
        CALL    H5_LUNS
        MOV     AX,0100H+C_CHN+C_CTL+C_INT
        CALL    H5_IOCM
        PUSH    AX
        CALL    H5_ADPM
        POP     AX
        RET
;
;------ FORMAT BAD TRACK
;
H5_FBAD:
        MOV     AX,0E48H
        CALL    H5_CHKM
        PUSH    AX
        CALL    H5_DMAS
        POP     AX
        JB      H5_BUND                 ;DMA BOUNDALY ERROR
        CALL    H5_PRMH
        CALL    H5_LADS
        MOV     DL,BIO_BLK
        MOV     DISK_SSB0,DL
        CALL    H5_SLCT
        MOV     AL,C_CHN+C_CTL+C_DMA+C_INT
        JMP     H5_IOCM
;
;------ FORMAT TRACK/DRIVE
;
H5_FORM:
        CALL    H5_CHKM
        MOV     AX,0600H+C_CHN+C_CTL+C_INT
        TEST    BIO_CMD,80H
        JZ      H5_FOR0
        CALL    H5_RCAL
        CMP     AH,0
        JNE     H5_FOR1
        MOV     AX,0400H+C_CHN+C_CTL+C_INT
H5_FOR0:
        CALL    H5_PRMH
        CALL    H5_LADS
        CALL    H5_SLCT
        MOV     DL,BIO_BLK
        MOV     DISK_SSB0,DL
        CALL    H5_IOCM
H5_FOR1:
        RET
;
;       MODE SET
;
H5_MODE:
        CALL    H5_RDSW
        TEST    BIO_CMD,80H
        MOV     BL,AL
        MOV     AL,00H
        JZ      H5_MOD0
        OR      BL,08H
        JMP     SHORT   H5_MODX
H5_MOD0:
        TEST    AH,80H
        JZ      H5_MODX
        MOV     AL,01H
H5_MODX:
        XOR     BH,BH
        SAL     BL,1
        MOV     BX,CS:WORD PTR H5_DPM[BX]
        TEST    BIO_UNT,01H
        JNZ     H5_MOD1
        MOV     DISK_PRM0+2,CS
        MOV     DISK_PRM0,BX
        MOV     AH,0FEH
        JMP     SHORT   H5_MOD2
H5_MOD1:
        MOV     DISK_PRM1+2,CS
        MOV     DISK_PRM1,BX
        SAL     AL,1
        MOV     AH,0FDH
H5_MOD2:
        AND     HDSK_MODE,AH    
        OR      HDSK_MODE,AL
        MOV     AH,00H
        RET
;
;       MODE CHECK
;
H5_CHKM:
        MOV     CX,0101H
        AND     CL,BIO_UNT
        SAL     CH,CL
        TEST    HDSK_MODE,CH
        JNZ     H5_CHKE
        RET
H5_CHKE:
        LEA     SP,-2[BP]
        MOV     AH,40H
        RET
;
;------ RETRACT
;
H5_RTRT:
        CALL    H5_ADPR
        CALL    H5_SLCT
        CALL    H5_PRMH                 ;SETUP PARAMETOR ADDRESS
        MOV     AX,CS:14[BX]            ;ES --> CS      88/04/11
                                        ;GET RETRACT CYLINDER ADDRESS
        XCHG    AL,AH
        CALL    H5_CYAD                 ;SETUP CYLINDER ADDRESS
        CALL    H5_LUNS
        MOV     AX,0B00H+C_CHN+C_CTL+C_INT
        CALL    H5_IOCM
;
;------ ASSIGN DISK PARAMETER
;
H5_ADPM:
        CALL    H5_PRMH
        MOV     SI,BX
        JMP     SHORT   H5_ADP0
H5_ADPR:
        CALL    H5_PRMH
        LEA     SI,10[BX]
H5_ADP0:
        CALL    H5_SLCT                 ;SELECT
        MOV     AH,0C2H
        CALL    H5_COMD
        MOV     AH,BIO_UNT
        MOV     CL,5
        SAL     AH,CL
        CALL    H5_COMD
        MOV     AH,0
        MOV     CX,4
H5_ADP1:
        CALL    H5_COMD
        LOOP    H5_ADP1
        MOV     CX,8
H5_ADP2:
        LODS    BYTE PTR CS:[SI]                ;ES --> CS      88/04/11
        MOV     AH,AL
        CALL    H5_ODAT
        LOOP    H5_ADP2
        CALL    H5_RDSW
        ROL     AH,1
        AND     AH,01H
        MOV     AL,C_CHN+C_CTL
        OUT     DSK_CCR,AL
        CALL    H5_ODAT
        MOV     AH,00H
        CALL    H5_ODAT
        JMP     H5_NINT                 ;RESULT
;
;------ REQUEST SENSE
;
H5_RSEN:
        CALL    H5_SLCT
        MOV     AX,0300H+C_CHN+C_CTL
        OUT     DSK_CSR,AL
        CALL    H5_COMD
        MOV     AH,BIO_UNT              ;UNIT #
        MOV     CL,5
        SAL     AH,CL
        CALL    H5_COMD
        MOV     AH,0
        MOV     CX,4
H5_RSE1:
        CALL    H5_COMD
        LOOP    H5_RSE1
        PUSH    DISK_SSB0W
        PUSH    DISK_SSB2W
        XOR     DI,DI
        MOV     ES,DI
        MOV     DI,OFFSET DISK_SSB0A
        MOV     CX,4
H5_RSE2:
        CALL    H5_IDAT                 ;READ 4 BYTES
        LOOP    H5_RSE2
        CALL    H5_PRMH
        POP     CX
        XCHG    CH,CL
        MOV     DX,DISK_SSB2W
        XCHG    DH,DL
        CMP     DX,CX
        POP     CX
        ADC     CH,0
        MOV     DISK_SSB1,CH
        CALL    H5_NINT
        MOV     BX,OFFSET H5_STUS
        MOV     AL,DISK_SSB0
        AND     AL,3FH
        MOV     AH,40H
        CMP     AL,24H
        JNB     H5_RSE3
        XLAT    CS:BYTE PTR [BX]
        MOV     AH,AL
H5_RSE3:
        RET
;
;------ GET POINTER
;
H5_PRMH:
;--------------------------------------------------------- 88/04/12 --
;       TEST    BIO_UNT,01H
;       JZ      H5_PRM0
;       LES     BX,DWORD PTR DISK_PRM1
;       RET
;H5_PRM0:
;       LES     BX,DWORD PTR DISK_PRM0
;---------------------------------------------------------------------
        PUSH    AX
        XOR     BX,BX
        CALL    H5_RDSW
;--------------------------------------------------------- 88/05/28 --
;       JZ      H5_PRM1
;---------------------------------------------------------------------
        OR      BL,08H
H5_PRM1:
        OR      BL,AL
        SAL     BL,1
        MOV     BX,CS:H5_DPM[BX]
;--------------------------------------------------------- 88/05/12 --
        MOV     AL,C_CTL
        OUT     DSK_CCR,AL
        JMP     SHORT $+2
;---------------------------------------------------------------------
        POP     AX
;---------------------------------------------------------------------
        RET
;
;       READ SWITCH
;
H5_RDSW:
        MOV     AL,C_SWC
        OUT     DSK_CCR,AL
        JMP     SHORT   $+2
        IN      AL,DSK_CSR              ;READ SWITCH
        MOV     AH,AL
        TEST    BIO_UNT,01H             ;UNIT# ?
        JZ      H5_RDS0                 ;JMP IF UNIT#1
        AND     AX,4007H
        SHL     AH,1
        JMP     SHORT   H5_RDS1
H5_RDS0:
        AND     AX,8038H
        SHR     AL,1
        SHR     AL,1
        SHR     AL,1
H5_RDS1:
        OR      AL,AH
        TEST    AL,80H
        RET
;
H5_CYAD:
        MOV     CX,CS:12[BX]            ;ES --> CS      88/04/11
        XCHG    CL,CH
        INC     CX                      ;PHSICAL HEAD COUNT
        MUL     CX
        MOV     DX,AX
        MOV     CX,33
        CALL    H5_RDSW
        JZ      H5_CYA0
        MOV     CX,17
H5_CYA0:
        MOV     AX,DX
        MUL     CX
        XCHG    DL,DH
        MOV     DISK_SSB0W,DX
        XCHG    AL,AH
        MOV     DISK_SSB2W,AX
        RET
;
;------ SELECTION
;
H5_SLCT:
        PUSH    AX
        MOV     AL,C_CTL
        OUT     DSK_CCR,AL
        MOV     DX,S_BSY*0100H
        CALL    H5_STAT
        JNZ     H5_TOUT
        MOV     AL,01H                  ;CONTROLER#1
        OUT     DSK_ODR,AL
        MOV     AL,C_SEL+C_CTL
        JMP     SHORT   $+2
        OUT     DSK_CCR,AL
        MOV     DX,S_BSY*0100H+S_BSY
        CALL    H5_STAT
        JNZ     H5_TOUT
        MOV     AL,C_CHN+C_CTL
        OUT     DSK_CCR,AL
        POP     AX
        RET
;
;------ INPUT DATA
;
H5_IDAT:
        MOV     DX,0FCA4H
        CALL    H5_STAT
        JNE     H5_TOUT
        IN      AL,DSK_IDR
        STOSB
        JMP     SHORT   H5_SACK
;
;------ OUTPUT DATA
;
H5_ODAT:
        MOV     DX,0FCA0H
        CALL    H5_STAT
        JNE     H5_TOUT
        MOV     AL,AH
        OUT     DSK_ODR,AL
        JMP     SHORT   H5_SACK
;
;------ OUTPUT COMMAND
;
H5_COMD:
        MOV     DX,0FC00H+S_REQ+S_BSY+S_CXD
        CALL    H5_STAT
        JNE     H5_TOUT
        MOV     AL,AH
        OUT     DSK_ODR,AL
        JMP     SHORT   $+2
H5_SACK:
        MOV     DX,S_ACK*0100H
        CALL    H5_STAT
        JNZ     H5_TOUT
        RET
;
;------ TIME OUT
;
H5_TOUT:
        LEA     SP,-2[BP]
        TEST    BIO_CMD,0FH
        JZ      H5_TOU0
        CALL    H5_RSET
H5_TOU0:
        MOV     AH,90H
        RET
;
;------ RESULT
;
H5_RSLT:
        TEST    DISK_INTF,01H
        JZ      H5_RSLT
        XOR     DISK_INTF,01H
H5_NINT:                                ;NON INTERRUPT
        MOV     DX,0FC00H+S_REQ+S_BSY+S_CXD+S_IXO
        CALL    H5_STAT
        JNE     H5_TOUT
        IN      AL,DSK_IDR
        MOV     DISK_STUS,AL
        CALL    H5_SACK
        MOV     DX,0FCBCH
        CALL    H5_STAT
        JNE     H5_TOUT
        IN      AL,DSK_IDR
        CALL    H5_SACK
        MOV     DX,0FC00H
        CALL    H5_STAT
        JNZ     H5_TOUT
        MOV     AL,C_CTL
        OUT     DSK_CCR,AL
        MOV     AH,00H
        TEST    DISK_STUS,03H
        JZ      H5_BSF0
        MOV     AH,40H
        TEST    DISK_STUS,01H
        JNZ     H5_BSF0
        CALL    H5_RSEN
H5_BSF0:
        RET
;
;       STATUS CHECK
;
H5_STAT:
        PUSH    CX
        XOR     CX,CX
H5_STAE:
        IN      AL,DSK_CSR
        AND     AL,DH   
        CMP     AL,DL
        LOOPNE  H5_STAE
        POP     CX
        RET
;
;------ LOGICAL ADDRESS
;
H5_LADS:
        PUSH    AX
        TEST    BIO_UNT,80H
        JNZ     H5_LAD0
        MOV     DL,BIO_SEC
        MOV     CX,BIO_CYW
        MOV     DISK_SSB1,DL
        MOV     DISK_SSB2,CH
        MOV     DISK_SSB3,CL
        JMP     SHORT   H5_LAD1
H5_LAD0:
        MOV     AX,CS:24[BX]            ;ES --> CS      88/04/11
        MOV     CX,BIO_CYW
        MUL     CX
        ADD     AL,BIO_HED
        ADC     AH,0
        MOV     DX,AX                   ;SAVE AX
        MOV     CX,33
        CALL    H5_RDSW
        JZ      H5_LAD2
        MOV     CX,17
H5_LAD2:
        MOV     AX,DX                   ;RESTORE AX
        MUL     CX
        ADD     AL,BIO_SEC
        ADC     AH,0
        ADC     DX,0
        MOV     DISK_SSB1,DL
        MOV     DISK_SSB2,AH
        MOV     DISK_SSB3,AL
H5_LAD1:
        CALL    H5_RDSW
        MOV     AL,BIO_BLK
        JZ      H5_LAD3
        SHR     AL,1                    ;#                              860829
        CMP     AL,0
        JNZ     H5_LAD3
        MOV     AL,80H
H5_LAD3:
        MOV     DISK_SSB0,AL
        POP     AX
H5_LUNS:
        MOV     CH,BIO_UNT
        MOV     CL,5
        SAL     CH,CL
        OR      DISK_SSB1,CH
        RET
;
;------ INTERRUPT
;
H5_INTR:
        PUSH    AX
        MOV     AL,20H
        OUT     08H,AL
        MOV     AL,0BH
        OUT     08H,AL
        JMP     SHORT   $+2
        IN      AL,08H
        TEST    AL,0FFH
        JNZ     H5_INT0
        MOV     AL,20H
        OUT     00,AL
H5_INT0:
        STI
        JMP     SHORT   $+2
        IN      AL,DSK_CSR
        AND     AL,0FDH
        CMP     AL,0ADH
        JE      H5_INT1
        AND     AL,0F9H
        CMP     AL,0A1H
        JNE     H5_INT2
H5_INT1:
        PUSH    DS
        XOR     AX,AX
        MOV     DS,AX
        OR      DISK_INTF,01H
        MOV     AL,C_CHN+C_CTL
        OUT     DSK_CCR,AL
        POP     DS
H5_INT2:
        POP     AX
        IRET

        PAGE
;--------------------------------------------------------- 90/03/20 --
;
;------ DISK PARAMETER
;
;H5_DPM DW      H5_05M,H5_10M,H5_15M,H5_20M
;       DW      H5_20H,H5_30H,H5_40H,H5_10H
;
;       DW      H5_05M,H5_10M,H5_15M,H5_20M
;       DW      H5_20X,H5_30H,H5_40H,H5_10H
;
;H5_05M DB      001H,001H,000H,003H,000H,098H,040H,000H,000H,000H
;       DB      001H,001H,000H,003H,001H,054H,040H,000H,000H,000H
;       DB      000H
;       DB      000H,0AFH,050H
;       DB      004H
;       DB      000H,002H,094H
;       DB      000H,000H
;H5_10M DB      001H,001H,000H,003H,001H,035H,080H,000H,000H,000H
;       DB      001H,001H,000H,003H,001H,054H,080H,000H,000H,000H
;       DB      001H
;       DB      000H,0AFH,050H
;       DB      004H
;       DB      000H,002H,094H
;       DB      001H,000H
;H5_15M DB      001H,001H,000H,005H,001H,035H,080H,000H,000H,000H
;       DB      001H,001H,000H,005H,001H,054H,080H,000H,000H,000H
;       DB      002H
;       DB      001H,006H,0F8H
;       DB      006H
;       DB      000H,003H,0DEH
;       DB      002H,000H
;H5_20M DB      001H,001H,000H,007H,001H,035H,080H,000H,000H,000H
;       DB      001H,001H,000H,007H,001H,054H,080H,000H,000H,000H
;       DB      003H
;       DB      001H,05EH,0A0H
;       DB      008H
;       DB      000H,005H,028H
;       DB      003H,000H
;H5_20H DB      001H,001H,000H,003H,002H,066H,000H,000H,000H,000H
;       DB      001H,001H,000H,003H,002H,0A0H,000H,000H,000H,000H
;       DB      003H
;       DB      001H,05AH,080H
;       DB      008H
;       DB      000H,002H,094H
;       DB      003H,000H
;H5_30H DB      001H,001H,000H,005H,002H,066H,000H,000H,000H,000H
;       DB      001H,001H,000H,005H,002H,0A0H,000H,000H,000H,000H
;       DB      004H
;       DB      002H,007H,0C0H
;       DB      006H
;       DB      000H,003H,0DEH
;       DB      005H,000H
;H5_40H DB      001H,001H,000H,007H,002H,066H,000H,000H,000H,000H
;       DB      001H,001H,000H,007H,002H,0A0H,000H,000H,000H,000H
;       DB      005H
;       DB      002H,0B5H,000H
;       DB      008H
;       DB      000H,005H,028H
;       DB      007H,000H
;H5_10H DB      001H,001H,000H,003H,001H,035H,080H,000H,000H,000H
;       DB      001H,001H,000H,003H,001H,04CH,080H,000H,000H,000H
;       DB      001H
;       DB      000H,0ABH,030H
;       DB      004H
;       DB      000H,002H,094H
;       DB      001H,000H
;
;       XA MODE 20MB HARD DISK PARAMETOR
;
;H5_20X DB      001H,001H,000H,003H,002H,066H,000H,000H,000H,000H
;       DB      001H,001H,000H,003H,002H,0A0H,000H,000H,000H,000H
;       DB      003H
;       DB      001H,05AH,080H
;       DB      004H
;       DB      000H,002H,094H
;       DB      003H,000H
;
;------ ERROR TYPE/CODE
;
;H5_STUS        DB 040H ; NO STATUS
;       DB 040H ; NO INDEX SIGNAL
;       DB 040H ; NO SEEK COMPLETE
;       DB 040H ; WRITE FAULT
;       DB 060H ; DRIVE NOT READY
;       DB 040H ; DRIVE NOT SELECTED
;       DB 040H ; NO TRACK 0
;       DB 040H ; MULTIPLE DRIVES SELECTED
;       DB 040H
;       DB 040H
;       DB 040H
;       DB 040H
;       DB 040H
;       DB 040H ; SEEK IN       PROGRESS
;       DB 040H
;       DB 040H
;       DB 0A0H ; ID READ ERROR
;       DB 0B0H ; UNCORRECTABLE DATA ERROR DURING READ
;       DB 0E0H ; ID ADDRESS MARK NOT FOUND
;       DB 0F0H ; DATA ADDRESS MARK NOT FOUND
;       DB 0C0H ; RECORD NOT FOUND
;       DB 0C8H ; SEEK ERROR
;       DB 040H
;       DB 070H ; WRITE PROTECTED
;       DB 008H ; CORRECTABLE DATA FIELD ERROR
;       DB 0D0H ; BAD BLOCK FOUND
;       DB 040H ; FORMAT ERROR
;       DB 040H
;       DB 0B8H ; UNABLE TO READ THE ALTERNATE TRACK
;       DB 040H
;       DB 088H ; ATTEMPTED TO DIRECTRY ACCESS AN ALTERNATE TRACK
;       DB 050H ; SEQUENCER TIME-OUT ERROR DURING A DISK OR A HOST TRANSFER
;       DB 040H ; INVALID COMMAND RECEIVED FROM THE HOST
;       DB 038H ; ILLEGAL DISK ADDRESS
;       DB 040H
;       DB 030H ; VOLUME OVERFLOW
;
;       WAIT LOOP 1 SECOND SUBROUTINE
;
DS_WSEC:
        XOR     CX,CX
        LOOP    $
        LOOP    $
        LOOP    $
        LOOP    $
        LOOP    $
        TEST    BYTE PTR BIOS_FLAG1,01H ;80286 ?
        JNZ     DS_W286
        TEST    BYTE PTR BIOS_FLAG+1,0C0H
        JZ      DS_WSEX                 ;8086-5M
DS_W286:
        LOOP    $
        LOOP    $
        LOOP    $
        TEST    BYTE PTR BIOS_FLAG1,01H ;80286 ?
        JZ      DS_WSEX                 ;NO,
        LOOP    $
        LOOP    $
DS_WSEX:
        RET
;
;       DMA SETUP SUBROUTINE
;
DS_PADR:
        OUT     DMA_BPTR,AL
        JMP     SHORT   $+2
        OUT     DMA_MOD,AL
        MOV     AX,BIO_DTS
        MOV     CL,4
        ROL     AX,CL
        MOV     CH,AL
        AND     AL,0F0H
        ADD     AX,BIO_DTA
        ADC     CH,0
        AND     CH,0FH
        RET

HDBIOK_CODE_END:
HDBIOK_END:

Bios_Code       ends

        END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\keyboard.asm ===
PAGE    109,132
        TITLE   MS-DOS 5.0 KEYBOARD.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: KEYBOARD.ASM                               *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;************************************************************************
;*                                                                      *
;*                                                                      *
;*      KEYBORD HANDLE ROUTINE  (VER 3.10 / VER 2.11)                   *
;*                              STATUS / INPUT / FLUSH                  *
;*                                                                      *
;************************************************************************
;
;       COLLECTION HISTORY
;       84/11/18  MAKE PRINTER-I/O DEVICE DRIVER
;       85/02/01  CORRECT FOR X2ROM(1/31)
;       85/02/28  JAPAN DRIVER
;       85/03/13  COMMON AREA
;       85/03/31  ADDING 2 BYTE HEX INPUT
;       85/04/22  ADDING 31 LINE CRT MODE
;
;       87/08/20- FOR HIRESO/NORMAL DOS
;
;       90/11,12 FOR MS-DOS 5.0
;

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends


Bios_Data       segment word public 'Bios_Data'
                ASSUME CS:DATAGRP

        EXTRN   CURLIN:BYTE,FKYSW:BYTE,ENDLINE:BYTE
        EXTRN   DEFATTR:BYTE,MODMARK1:BYTE,MODMARK2:BYTE
        EXTRN   ROLSW:BYTE,SFTJISMOD:BYTE,CSRSW:BYTE
        EXTRN   MEM_SW3:BYTE,KBKNJ_FLG:BYTE,KBGLIN:BYTE
        EXTRN   KANJI_MODE:BYTE,KBINP_CNT:BYTE,X_PAGE_FLAG:BYTE
        EXTRN   TEMPB1_CNT:BYTE,FKY_BUFFER:BYTE
        EXTRN   KBCODTBL:NEAR,FKYTBL:NEAR,LINMOD:BYTE,FKYTBL2:NEAR

        EXTRN   P_FLAG:BYTE
        EXTRN   FKYCNT:BYTE
        EXTRN   FKYPTR:WORD
        EXTRN   HEXMOD:BYTE
        EXTRN   HEXWRK:BYTE
        EXTRN   KBH_ADR:WORD

        EXTRN   CTRLCMD:BYTE
        EXTRN   CTRLFKY:WORD
        EXTRN   PR_HEADER:WORD
        EXTRN   KDRV_FLG:BYTE

;--------------------------------------------------- H/N 870820 ----
        EXTRN   SYS_501:BYTE,VRAMSEG:WORD
        EXTRN   PR_RATIO:BYTE
        EXTRN   CHRTBL:WORD
        EXTRN   KNJ_HEADER:WORD
        EXTRN   CTRLXFER:BYTE                   ;870922
;--------------------------------------------------- MAMA ----------
;--------------------------------------------------------- 89/08/08 --
        EXTRN   PTRSAV:WORD
;---------------------------------------------------------------------
;--------------------------------------------------------- 89/08/22 --
        EXTRN   CURATTR2:WORD,DEFATTR2:WORD,ATRSAVE2:WORD
        EXTRN   WAKU_TABLE:NEAR,JPN_SCRD1H:NEAR,JPN_SCRD1N:NEAR,ROME_1STSAV:BYTE
;---------------------------------------------------------------------
Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE

        EXTRN   STOP_CHK:NEAR
        EXTRN   BELRTN:NEAR,CRTCLR:NEAR
        EXTRN   LINECLR:NEAR,ROLLUP:NEAR,DSPCSR:NEAR
        EXTRN   DSPFKY:NEAR,CLRRTN:NEAR,HOMERTN:NEAR
        EXTRN   CRTOUT:NEAR
        extrn   bdata_seg:word

Bios_Code       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        PUBLIC  KEYBOARD_CODE_START
        PUBLIC  KEYBOARD_CODE_END
        PUBLIC  KEYBOARD_END

        PUBLIC  KBSTAT,KBIN,KBFLUSH,FLUSH
        PUBLIC  KBSTAT_FAR,KBIN_FAR,KBFLUSH_FAR

        PUBLIC  FKYDSP
        PUBLIC  HEXCHK
        PUBLIC  HEXCHK_FAR
        PUBLIC  CHGLIN

KEYBOARD_CODE_START:

GLIN_SEG        EQU     001F0H          ;--GLINE E1F0H OR A1F0H --------870826
;GDCSTS EQU     60H                     ;GDC STATUS PORT
;GDCCMD EQU     62H                     ;GDC COMMAND PORT
;GDCPRM EQU     60H                     ;GDC PARAMETER PORT

KBFIFO  EQU     410H                    ;KB FIFO BUFFER ADDRESS
KBSEG   EQU     412H                    ;KB BUFFER SEGMENT ADDRESS
KBGETP  EQU     WORD PTR 0524H          ;KB FIFO GET POINTER
KBPUTP  EQU     WORD PTR 0526H          ;         PUT
KBCOUNT EQU     BYTE PTR 0528H          ;         DATA COUNTER
NEWKY   EQU     -2                      ;

        PAGE
        EVEN
;*
;*   KB SUBROUTINE TABLE
;*
        EVEN
KBRTNTBL        DW      KB_NOP          ;SCAN CODE 0X
                DW      KB_NOP          ;           1X
                DW      KB_NOP          ;           2X
                DW      KB_CODE1        ;           3X
                DW      KB_NOP          ;           4X
                DW      KB_CODE2        ;           5X
                DW      KB_FNCKEY       ;           6X
                DW      KB_NOP          ;           7X
                DW      KB_FNCKY2       ;           8X
                DW      KB_CTRLFNC      ;           9X
                DW      KB_HOME         ;           AX
                DW      KB_KANJ1        ;           BX
                DW      KB_SIF_11_15    ;           CX
                DW      KB_CTR_11_15    ;           DX
                DW      KB_NOP          ;           EX
                DW      KB_NOP          ;           FX
;*
;*   CTRL SUBROUTINE (CTRL + F.1 -F.15)
;*
KBCTLTBL        DW      KB_NOP          ;
                DW      KB_NOP          ;RFU
                DW      KB_NOP
                DW      KNJSW           ;KANJI <-> ANK MODE
                DW      HEXINP          ;HEX INPUT MODE
                DW      CHGLIN          ;CHANGE LINE MODE
                DW      FKYDSP          ;DISP/ERASE FUNCTION KEY
                DW      CLRSCREN        ;LOCAL SCREEN CLEAR
                DW      ROLSPD          ;SCROLL SPEED CONTROL
                DW      KB_NOP          ;RFU
                DW      KB_NOP          ;F.11
                DW      KB_NOP          ;F.12
                DW      KB_NOP          ;F.13
                DW      KB_NOP          ;F.14
                DW      KB_NOP          ;F.15
        PAGE

;****************************************************************
;*                                                              *
;*      KEYBOARD STATUS CHECK                                   *
;*              EXIT:   (ZF) = 1 : NOT READY                    *
;*                             0 : READY  ( AL=KEY CODE )       *
;*                                                              *
;****************************************************************
;
KBSTAT_FAR      PROC    FAR             ;FOR BIOS_DATA I/F
        CALL    KBSTAT
        RET
KBSTAT_FAR      ENDP

;======
KBSTAT:
;======
;
;****** KANJI CHECK *************
;
        PUSH    ES
        TEST    BYTE PTR [KBKNJ_FLG],80H        ;KANJI MODE ?
        JZ      KBSTAT01                ;NO,
        CMP     DS:[KNJ_HEADER+2],0     ;KNJI DRIVER EXIST ?
        JE      KBSTAT01                ;SKIP IF NONE
        CALL    DS:DWORD PTR [KNJ_HEADER]       ;WITHOUT KEY
;
KBSTAT01:
;
;       SENSE "^C" / "^S" / "^F"
;
        XOR     BX,BX
        MOV     ES,BX
        CMP     ES:KBCOUNT[BX],0        ;CHECK KEY-CODE COUNT
        JNE     KBSTAT005
        JMP     KBSTAT_X1               ;JUMP IF EMPTY
KBSTAT005:
KBSTAT010:
        CALL    CHECK_NORMAL
;------------------------------------------------------- MAMA ----
        CMP     AL,'S'-'@'              ;CTRL-S ?
        JE      KBSTAT_X0               ;Y
;--------
        CMP     AL,'F'-'@'              ;CTRL-F ?
        JE      KBSTAT_X0               ;Y
        CMP     AL,'C'-'@'              ;CTRL-C ?
        JNE     KBSTAT_X2               ;Y
KBSTAT_X0:
        CMP     [KDRV_FLG],1            ;NECDIC.DRV ?
        JZ      KBSTAT_X2               ;
KBSTAT_X:
        CALL    KBFLUSH                 ;FLUSH THE KB-FIFO
        MOV     [FKY_BUFFER],AL         ;SET KEY CODE
        MOV     [FKYPTR],OFFSET FKY_BUFFER
        MOV     [FKYCNT],1
        JMP     KBSTATR                 ;

KB_KANJ1:
;-------------------------------------------------- 870922 -----------
        TEST    [CTRLCMD],00000010B     ;CTRL XFER ?
        JNZ     KB_KANJ2                ;YES
;---------------------------------------------------------------------
        CMP     DS:[KNJ_HEADER+10],0
        JE      KB_KANJ1_EXT0
        CALL    DS:DWORD PTR [KNJ_HEADER+8]
        JMP     short KB_KANJ1_EXT

KB_KANJ1_EXT0:
        CMP     [SFTJISMOD],0           ;KANJI DISPLAY MODE ?
        JNZ     KKB_HEX                 ;Y
KKB_ERR:
        CALL    BELRTN
        JMP     short KB_KANJ1_EXT
KKB_HEX:
        MOV     AH,2
        INT     18H
        TEST    AL,04H                  ;KANA LOCK ?
        JNZ     KKB_ERR                 ;Y
        CMP     [HEXMOD],-1             ;2 BYTE INPUT MODE ?
        JNZ     KKB_ENT                 ;GO TO ENT
KKB_EXT:
        MOV     [HEXMOD],0
        MOV     [KBINP_CNT],BL
        CALL    KKB_ERASE_GLINE
        JMP     short KB_KANJ1_EXT
KKB_ENT:
        MOV     WORD PTR [KBH_ADR],OFFSET KKB_HEXA
        MOV     [HEXMOD],-1
        MOV     [KBINP_CNT],1
        CALL    KKB_CLEAR_GLINE
        CALL    KKB_CHANG_G_SHFT
        CALL    KKB_DISP_GLINE
;
KB_KANJ1_EXT:
        RET

;------85/02/28-------

;
;       CHECK FUNCTION KEY BUFFER
;
KBSTAT_X1:
        CMP     BYTE PTR [FKYCNT],0     ;SOFT KEY MODE ?
        JE      KBSTATNR                ;YES,
        JMP     KBSTAT3_R               ;NO,
KBSTAT_X2:
        CMP     BYTE PTR [FKYCNT],0     ;SOFT KEY MODE ?
        JZ      KBSTAT_X2_2             ;
        JMP     KBSTAT3_R               ;READY

;------------------------------------------------------ 870922 -------
KB_KANJ2:
        XOR     DX,DX
        MOV     BX,OFFSET CTRLXFER
        JMP     KB_FNC00
;---------------------------------------------------------------------

;
;       GET & CHECK KEY-CODE
;
KBSTAT_X2_2:
        CALL    CHECK_NORMAL2           ;KEY SENSE SUBROUTINE
;---------------------------------------------------------------------
        CMP     [KDRV_FLG],1            ;Bunsetsu driver exists ?
        JNZ     KBSTAT_X2_3             ;No, skip
        TEST    [KBKNJ_FLG],80H         ;NipponGo mode ?
        JNZ     KBSTAT3                 ;Yes
        CMP     AH,0B0H                 ;Scan Code < 0B0H ?
        JB      KBSTAT_X2_3             ;Yes
        CMP     AH,0BFH                 ;Scan Code > 0BFH ?
        JNA     KBSTAT3                 ;No
KBSTAT_X2_3:                            ;
;
        CMP     AL,0                    ;LOCAL FNC KEY ?
        JNE     KB_STAT1                ;N
        CMP     AH,1AH                  ;CTRL-@ ?
        JE      KB_STAT1                ;Y
;
;       BIOS LOCAL FUNCTION
;
        MOV     AH,0
        INT     18H                     ;GET KEY CODE
        XCHG    AH,AL                   ;AL := SCAN CODE
        MOV     DX,AX
        MOV     CL,4
        SHR     AL,CL                   ;AL := AL/8
        SHL     AL,1
        MOV     BX,AX
        ADD     BX,OFFSET KBRTNTBL
        CALL    WORD PTR CS:[BX]                ;CALL SUBROUTINE
;
; NOT READY EXIT
KBSTATNR:
;--------
        CALL    STOP_CHK
        XOR     AL,AL                   ;SET ZERO FLAG
        POP     ES
        RET


;
;      GRAPHIC CHARACTER        
;               IF HEXMOD <> 0   THEN ;CALL HEX-INPUT ROUTINE
;               IF KBKNJ_FLG = 1 THEN ;CALL KANJI-INPUT ROUTINE
KB_STAT1:
        CMP     [SFTJISMOD],0           ;KANJI MODE ?
        JE      KBSTAT11                ;NO,
        CMP     AL,80H                  ;GRAPH CHAR ?
        JB      KBSTAT11                ;NO,
        CMP     AL,9FH                  ;GRAPH CHAR ?
        JBE     KBSTAT10                ;YES,
        CMP     AL,0E0H                 ;GRAPH CHAR
        JB      KBSTAT11                ;NO,
KBSTAT10:
        MOV     AH,0
        INT     18H
        CALL    BELRTN                  ;ERRR BEEP
        JMP     SHORT   KBSTATNR        ;IGNORE THIS DATA
KBSTAT11:
        CMP     BYTE PTR [HEXMOD],0     ;HEX-INPUT MODE ?
        JNE     KBSTAT4                 ;NO
KBSTAT2:
        TEST    BYTE PTR [KBKNJ_FLG],80H        ;KANJI-INPUT MODE ?
        JZ      CHK_CHRTBL              ;NO                     870825
KBSTAT3:
        MOV     AH,0
        INT     18H
        CMP     DS:[KNJ_HEADER+6],0
        JE      KBSTATR                                 
;---------------------------------------------------    89/07/24  --
        PUSH    [PTRSAV]                        ;                       
        PUSH    [PTRSAV+2]              ;                       
        CALL    DS:DWORD PTR [KNJ_HEADER+4]     ;WITH KEY CODE  
        POP     [PTRSAV+2]              ;                       
        POP     [PTRSAV]                        ;                       
;---------------------------------------------------    89/07/24  --
        JNB     KBSTATNR                ;
KBSTAT3_R:
        MOV     BX,[FKYPTR]
        MOV     AL,[BX]
        ;
; READY EXIT
KBSTATR:
;-------
        CALL    STOP_CHK
        OR      AH,1                    ;CLEAR (ZF)
        POP     ES
        RET
KBSTAT4:
;
;       HEX INPUT (1 OR 2 BYTE CHARACTER)
;
        MOV     AH,0
        INT     18H
        CALL    WORD PTR [KBH_ADR]
        JMP     SHORT   KBSTATNR


;----------------------- CHECK CHRTBL ------------------------ 870825
CHK_CHRTBL:
        MOV     CX,[CHRTBL]             ;GET # OF ENTRY
        JCXZ    JMP_KBSTATR             ;JMP IF NO ENTRY
        MOV     SI,OFFSET CHRTBL + 2    ;BUFFER(TABLE) OFFSET
CHKCHRT10:
        CMP     AL,[SI+2]               ;FOUND KEY CODE ?
        JE      CHKCHRT20               ;YES,
        XOR     BX,BX                   ;
        MOV     BL,[SI]                 ;ENTRY SIZE
        ADD     SI,BX                   ;SEARCH FOR NEXT ENTRY
        LOOP    CHKCHRT10               ;
JMP_KBSTATR:
        JMP     KBSTATR                 ;READY RETURN
CHKCHRT20:
        XOR     AH,AH                   ;BIOS COMMAND (GET)
        INT     18H                     ;
        XOR     CX,CX                   ;
        MOV     CL,[SI]                 ;GET ENTRY SIZE
        SUB     CX,3                    ;TREAT TO STRING SIZE
        JBE     JMP_KBSTATR             ;INVALID ENTRY
        PUSH    CX                      ;
        ADD     SI,3                    ;POINT STRING
        MOV     DI,OFFSET FKY_BUFFER    ;
        MOV     [FKYPTR],DI             ;SET BUFF POINTER
        PUSH    ES                      ;
        mov     ES,cs:[bdata_seg]       ;ES = bios_data seg             @DOS5
        CLD                             ;
        REP     MOVSB                   ;TRANSFER STRING DATA
        POP     ES                      ;RESUME ES
        POP     CX                      ;
        MOV     [FKYCNT],CL             ;SET STRING SIZE
        JMP     KBSTATNR                ;NOT READY RETURN

;----------------------- CHECK NORMAL-MODE -------------------
CHECK_NORMAL:
        TEST    DS:[SYS_501],08H        ;NORMAL MODE ?
        JZ      DONT_TOASCII            ;YES,
        MOV     SI,ES:KBPUTP[BX]        ;GET KB PUT POINTER
        CMP     SI,ES:KBFIFO[BX]        ;BUG ? FIX BY MAMA (87/8/12)------
        JA      CHECK_N00
        ADD     SI,16*2
CHECK_N00:
        PUSH    ES                      ;
        MOV     AX,ES:KBSEG[BX]         ;
        MOV     ES,AX                   ;
        MOV     AX,ES:NEWKY[SI]         ;GET LAST CODE
        MOV     BL,AL                   ;AH KEY CODE AL SHIFT
        MOV     AL,AH                   ;AH <- 9                TO ASCII
        MOV     AH,9                    ;AL <- KEY CODE
        INT     18H                     ;BL <- SHIFT
        XOR     BX,BX                   ;
        POP     ES
        RET

DONT_TOASCII:
        MOV     SI,ES:KBPUTP[BX]        ;GET KB PUT POINTER
        CMP     SI,0502H                ;PUTP > BUFF TOP ?
        JA      CHECK_N10               ;YES,
        ADD     SI,16*2
CHECK_N10:
        MOV     AX,ES:NEWKY[SI]         ;GET LAST CODE
        RET
;------------------------------------------------

CHECK_NORMAL2:
        TEST    DS:[SYS_501],08H        ;NORMAL MODE ?
        JZ      DONT_TOASCI2            ;YES,

        PUSH    ES
        MOV     SI,ES:KBGETP[BX]        ;GET POINTER
        MOV     AX,ES:KBSEG[BX]         ;ES <- SEGMENT
        MOV     ES,AX
        MOV     AX,ES:[SI]              ;GET KEY CODE
        PUSH    BX                      ;AX = AH KEY CODE
        MOV     BL,AL                   ;       AL SHIFT
        MOV     AL,AH                   ;AH <- 9 (TO ASCII)
        MOV     AH,9                    ;AL <- KEY CODE
        INT     18H                     ;BL <- SHIFT
        POP     BX                      ;ASCII CODE -> AL SCAN CODE -> AH
        POP     ES
        RET

DONT_TOASCI2:
        MOV     SI,ES:KBGETP[BX]        ;GET POINTER
        MOV     AX,ES:[SI]              ;GET KEY CODE
        RET

        PAGE
;****************************************************************
;*                                                              *
;*      CONSOLE INPUT (KEY BOAD)                                *
;*                                                              *
;*      ENRTY: NONE                                             *
;*      EXIT : (AL)=ASCII CODE                                  *
;*                                                              *
;****************************************************************

KBIN_FAR        PROC    FAR
        CALL    KBIN
        RET
KBIN_FAR        ENDP


;=======
KBIN:
;=======

        CALL    N_KBIN                  ;KEY CODE INPUT
        CMP     AL,'P'-'@'              ;CTRL-P ?
        JE      PRN_TOGGLE              ;YES,
        CMP     AL,'N'-'@'              ;CTRL-N ?
        JE      PRN_TOGGLE              ;YES,
        JMP     SHORT   KBIN_EXIT

;
PRN_TOGGLE:
        XOR     [P_FLAG],1              ;ENTER ^P MODE ?
        JNZ     KBIN_EXIT               ;BR. IF YES
;-------------------------------------------------------- H/N 870820 --
CTLPON = 10000000B
        TEST    [PR_RATIO],CTLPON       ;IF CTLPON = 0
        JNZ     KBIN_EXIT               ; THEN ECHO BACK 
;----------------------------------------------------------------------
        PUSH    AX
        MOV     CL,0DH                  ;CR (CARRIAGE RETURN)
        CALL    PRNOUT
        MOV     CL,0AH                  ;LF (LINE FEED)
        CALL    PRNOUT
        POP     AX
KBIN_EXIT:
        CALL    STOP_CHK
        RET

;------------------------------------

PRNOUT:
        MOV     [PR_HEADER],15H
        CMP     [PR_HEADER+2],0
        JE      PRNOUTSKIP
        PUSH    DS
        PUSH    ES
        MOV     ES,CS:[BDATA_SEG]
        MOV     DS,ES:[PR_HEADER+2]
        CALL    ES:DWORD PTR [PR_HEADER]        ;CALL PRINTER DRIVER
        POP     ES
        POP     DS
PRNOUTSKIP:
        RET

;------------------------------------



N_KBIN:
;------
        CALL    KBSTAT                  ;CONSOLE CHECK
        JZ      N_KBIN                  ;NOT READY
        CMP     BYTE PTR [FKYCNT],0     ;SOFT KEY MODE ?
        JE      N_KBIN1                 ;NO,
;SOFT KEY
        MOV     BX,[FKYPTR]             ;
        MOV     AL,[BX]                 ;GET KEY CODE
        INC     WORD PTR [FKYPTR]
        DEC     BYTE PTR [FKYCNT]
        RET
;NOT SOFT KEY
N_KBIN1:
        MOV     AH,0
        INT     18H
        RET
        PAGE
;************************************************
;*                                              *
;*                                              *
;*      FLUSH KEYBOARD BUFFER                   *
;*                                              *
;*                                              *
;************************************************

KBFLUSH_FAR     PROC    FAR
        CALL    KBFLUSH
        RET
KBFLUSH_FAR     ENDP

KBFLUSH:
        CALL    FLUSH
        CALL    STOP_CHK
        RET

FLUSH:
;----------------------------------------------- CHECK NORMAL ----
        TEST    DS:[SYS_501],08H        ;NORMAL ?
        JZ      NORMAL_FLUSH            ;YES,
;-----------------------------------------------------------------
        PUSH    AX                      ;INIT
        MOV     AH,06                   ;*KB_HEAD_POINTER
        INT     18H                     ;*KB_TAIL_POINTER
        CLI                             ;*KB_BUFFER_COUNTER
        MOV     [FKYCNT],0              ;
        STI
        POP     AX
        RET

;------------------------------------------ NORMAL FLUSH ROUTINE -
NORMAL_FLUSH:
        CLI
        CLD
        PUSH    ES
        PUSH    AX
        XOR     DI,DI
        MOV     ES,DI                   ;COMMON DATA SEG
        MOV     DI,0524H                ;*KB_GETP
        MOV     AX,0502H                ;*KB_FIFO
        STOSW
        STOSW                           ;INIT GETP & PUTP
        XOR     AL,AL
        STOSB                           ;INIT COUNTER
        POP     AX
        POP     ES
        MOV     [FKYCNT],0              ;INIT FUNC KEY COUNTER
        STI
        RET
;-------------------------------------------------- BY MAMA -----
        PAGE
;************************************************
;*                                              *
;*      PROGRAMABLE FUNCTION KEY                *
;*                                              *
;************************************************
        
;--------
KB_CODE1:
;--------

        CMP     DL,35H
        JB      KB_CODEER
        JA      KB_CODE1_NOTXFER        ;BR. IF NOT XFER
        ;
        ; NFER  XFER PRESSED
        ;
KB_FER:                                 ;
        TEST    BYTE PTR [KBKNJ_FLG],80H        ;NIPPONGO MODE & ?????
        JZ      KB_CODEER               ;NO, IGNORE
        CMP     DS:[KNJ_HEADER+14],0
        JE      KB_FER_EXIT
        CALL    DS:DWORD PTR [KNJ_HEADER+12]    ;TRANSFER
KB_FER_EXIT:
        RET


KB_CODE1_NOTXFER:
        SUB     DL,36H
        TEST    [KBKNJ_FLG],80H         ;Q. KANJI MODE & INDIRECT ?
        JZ      KB_CODE12
        TEST    [KBKNJ_FLG],40H         ;INDIRECT MODE ?
        JZ      KB_CODE12
        CMP     [TEMPB1_CNT],0          ;BUFFER IS EMPTY ?
        JE      KB_CODE12               ;BR. IF YES
        CMP     DS:[KNJ_HEADER+18],0
        JE      KB_CODE1_EXIT
        CALL    DS:DWORD PTR [KNJ_HEADER+16]   ;KBCODE_NIP
KB_CODE1_EXIT:
        RET

KB_CODE12:
        MOV     BX,OFFSET KBCODTBL      ;TABLE ADDR
        MOV     CL,3
        JMP     SHORT   KB_FNC01

KB_CODEER:
        RET


;--------
KB_CODE2:
;--------
        CMP     DL,51H                  ;
        JE      KB_FER                  ;  I
        CMP     DL,57H                  ;  V
        JB      KB_FNC_11_15            ; ----
        RET
KB_HOME:
        CMP     DL,0AEH                 ;HOME
        JNE     KB_CODEER               ;N
        TEST    [KBKNJ_FLG],80H         ;Q. KANJI-MODE
        JZ      KB_CODE21
        TEST    [KBKNJ_FLG],40H
        JE      KB_CODE21
        CMP     [TEMPB1_CNT],0
        JE      KB_CODE21
        CMP     DS:[KNJ_HEADER+22],0
        JE      KB_HOMEXIT
        CALL    DS:DWORD PTR [KNJ_HEADER+20]   ;KANJI HOME
KB_HOMEXIT:
        RET

KB_FNC_11_15:                           ;
        SUB     DL,48H
        JMP     SHORT   KB_FNCKEY_1

KB_SIF_11_15:                           ;
        SUB     DL,0B8H
        JMP     SHORT   KB_FNCKEY2_1

KB_CTR_11_15:                           ;
        SUB     DL,0C8H
        TEST    [CTRLCMD],01
        JNZ     KB_CTRL2_11_15          ;
        JMP     KB_CTRLFNC_1

KB_CTRL2_11_15:                         ;
        MOV     BX,OFFSET CTRLFKY
        JMP     SHORT   KB_FNC00

;                                       ;
;       F.11    SCAN CODE
;       BASE    52H  ----->  52H-48H
;       SHIFT   C2H  ----->  C2H-B8H
;       CONTROL D2H  ----->  D2H-C8H

KB_CODE21:
        MOV     DL,0AH
        MOV     BX,OFFSET KBCODTBL
        MOV     CL,3
        JMP     SHORT   KB_FNC01


;---------
KB_FNCKEY:
;---------
;       FUNCTION KEY HANDLE  (F.1 - F.15)
;
        SUB     DL,62H
KB_FNCKEY_1:                            ;
        TEST    BYTE PTR [KBKNJ_FLG],80H        ;NIPPON GO MODE ?
        JNZ     KB_FNC_KANJI            ;YES
        MOV     BX,OFFSET FKYTBL        ;TABLE ADDR
        JMP     SHORT   KB_FNC00

KB_FNC_KANJI:                           ;NIPPONGO INPUT MODE
        CMP     DS:[KNJ_HEADER+26],0
        JE      KB_FNC_KANJI_EXT
        CALL    DS:DWORD PTR [KNJ_HEADER+24]
KB_FNC_KANJI_EXT:
        RET


;---------
KB_FNCKY2:
;---------
;       FUNCTION KEY (WITH "SHIFT")
;
        SUB     DL,82H
KB_FNCKEY2_1:                           ;
        MOV     BX,OFFSET FKYTBL2       ;TABLE ADDR

;
; KEY DATA (STRING) STORE TO FKY-BUFFER
;
KB_FNC00:
        MOV     CL,4
KB_FNC01:
        SHL     DL,CL
        XOR     DH,DH
        ADD     BX,DX                   ;
        MOV     AH,[BX]                 ;GET TABLE CONTENT (COUNTER)
        AND     AH,AH
        JZ      KB_FNCRET               ;CNT=0 (NOP)
        INC     BX
        MOV     AL,[BX]                 ;GET 1ST DATA
        CMP     AL,0FEH                 ;SKIP CODE ?
        JNE     KB_FNC02                ;NO
        ADD     BX,6
        SUB     AH,6
        CMP     BYTE PTR[BX],00H        ;
        JNE     KB_FNC02                ;
        XOR     AH,AH                   ;CLEAR COUNTER
KB_FNC02:
        MOV     SI,BX                   ;
        MOV     DI,OFFSET FKY_BUFFER    ;DEST. POINTER
        PUSH    ES                      ;
        PUSH    DS
        POP     ES                      ;ES := DS
        MOV     CL,AH                   ;COUNTER
        XOR     CH,CH
        REP     MOVSB                   ;
        POP     ES                      ;RESUME ES
        MOV     [FKYPTR],OFFSET FKY_BUFFER
        MOV     [FKYCNT],AH
KB_FNCRET:
KB_NOP:
        RET
        PAGE
;****************************************
;*   HEX DATA (1BYTE) INPUT             *
;*                                      *
;*      HEXMOD = 1                      *
;****************************************
KBH_ASCI:
        MOV     BL,[HEXMOD]
        CALL    HEXCHK                  ;KEY CHECK
        CMP     AH,0                    ;NOT HEX DATA ?
        JE      KBH_ASCI0               ;Y (DISPLAY)
        XOR     AH,AH
        CMP     BL,3
        JNE     KBH_ASCI1
KBH_ASCI0:
        MOV     AH,0FFH
        XOR     BL,BL
        MOV     [FKY_BUFFER],AL
        MOV     WORD PTR [FKYPTR],OFFSET FKY_BUFFER
        MOV     BYTE PTR [FKYCNT],1
KBH_ASCI1:
        MOV     [HEXMOD],BL
        RET
;
;********************************
;*   KEY CHECK (HEXA)           *
;********************************
HEXCHK_FAR      PROC    FAR
        CALL    HEXCHK
        RET
HEXCHK_FAR      ENDP

HEXCHK:
        CMP     AL,'0'
        JB      HEXCHK1                 ;CHECK KEY IN DATA 
        CMP     AL,':'                  ; 0 - 9
        JB      HEXCHK3                 ; A - B
        CMP     AL,'A'                  ; SMALL A - SMALL F
        JB      HEXCHK1
        CMP     AL,'G'
        JB      HEXCHK2
        CMP     AL,'a'
        JB      HEXCHK1
        CMP     AL,'g'
        JB      HEXCHK2
HEXCHK1:
        PUSH    AX
        CALL    BELRTN                  ;ERROR;BEEP
        POP     AX
        MOV     AH,0                    ;RTN CODE
        RET
HEXCHK2:                                ;ALPHA DATA
        ADD     AL,9
HEXCHK3:                                ;(ALPHA),NUMERIC DATA
        INC     BL
        JPE     HEXCHK4
        MOV     CL,4
        SHL     AL,CL
        MOV     [HEXWRK],AL
        MOV     AH,0FFH
        RET
HEXCHK4:
        AND     AL,0FH
        OR      AL,[HEXWRK]
        MOV     AH,0FFH
        RET

;********************************************************
;*                                                      *
;*   CTRL + F.1 - F.15                                  *
;*      LOCAL FUNCTION PROCESS                          *
;*                                                      *
;********************************************************

;----------
KB_CTRLFNC:
;----------
;
        SUB     DL,92H
        TEST    [CTRLCMD],01            ;
        JNZ     KB_CTRLFNC_2
KB_CTRLFNC_1:                           ;
        SHL     DL,1
        XOR     DH,DH
        MOV     BX,OFFSET KBCTLTBL
        ADD     BX,DX
        TEST    BYTE PTR [KBKNJ_FLG],80H        ;NIPPON-GO INPUT MODE ?
        JNZ     KB_CTRLRET              ;YES, IGNORE
        CMP     [HEXMOD],-1             ;HEXADECIMAL 2 BYTE INPUT MODE ?
        JZ      KB_CTRLRET              ;YES, IGNORE
        CALL    WORD PTR CS:[BX]                ;
KB_CTRLRET:
        RET

KB_CTRLFNC_2:                           ;
        MOV     BX,OFFSET CTRLFKY
        JMP     KB_FNC00

;************************************************
;*                                              *870825 ALL NEW
;*      DISPLAY / ERASE FUNCTION KEY LIST       *
;*                                              *
;************************************************
FKYDSP:
;------
        MOV     DH,24                   ;ENDLINE VALUE FOR HIRESO
        MOV     DL,30                   ;
        TEST    [SYS_501],00001000B     ;HW MODE ?
        JNZ     FKYDSP00                ;HIRESO
        MOV     DH,19                   ;ENDLINE VALUE FOR NORMAL
        MOV     DL,24                   ;
FKYDSP00:
        MOV     [ENDLINE],DH
        CMP     [LINMOD],0
        JE      FKYDSP0
        MOV     [ENDLINE],DL
FKYDSP0:
        INC     [FKYSW]
        AND     [FKYSW],03H
        JNP     FKYDSP1                 ;IF FKYSW ^= 3
;FKYSW = 3 (TREAT 0)
        AND     [FKYSW],0
        MOV     DH,[ENDLINE]
        CALL    LINECLR                 ;CLEAR BOTTOM LINE
        RET
;
FKYDSP1:
        MOV     [MODMARK2],'*'          ;MARK (F16-F25)
        CMP     [FKYSW],1                       ;
        JNE     FKYDSP2
        MOV     [MODMARK2],' '          ;MARK (F1-F10)
        MOV     AL,[CURLIN]
        CMP     AL,[ENDLINE]            ;CURR. LINE = BOTTOM ?
        JB      FKYDSP2                 ;NO
        CALL    ROLLUP                  ;YES SCROLL UP
        DEC     [CURLIN]
        CALL    DSPCSR                  ;DISP CURSOR
FKYDSP2:
        DEC     [ENDLINE]
        CALL    DSPFKY                  ;FUNC KEY DISPLAY
        MOV     AH,0
        RET

;************************************************870825 ALL NEW
;*                                              *
;*      CHANGE LINE MODE                        *
;*                                              *
;*              HIRESO: 25LINE <--> 31LINE      *
;*              NORMAL: 20LINE <--> 25LINE      *
;*                                              *
;************************************************
CHGLIN:
;------
        PUSH    DX                      ;
        MOV     DH,24                   ;ENDLINE VALUE FOR HIRESO
        MOV     DL,30                   ;
        TEST    [SYS_501],00001000B     ;HW MODE ?
        JNZ     CHGLIN00                ;HIRESO
;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>
        extrn   patch09:near

        call    patch09
        db      90h
;---------------
;       MOV     DH,19                   ;ENDLINE VALUE FOR NORMAL
;       MOV     DL,24                   ;
;---------------------------------------------------------------------
CHGLIN00:                               ;
        MOV     AL,[FKYSW]
        OR      AL,AL
        JZ      CHGLIN1
        MOV     AL,1
CHGLIN1:
        MOV     [ENDLINE],DH            ;
        XOR     [LINMOD],01H
        JZ      CHGLIN2
        MOV     [ENDLINE],DL            ;
CHGLIN2:
        POP     DX
        SUB     [ENDLINE],AL
        CALL    CLRRTN
        CALL    HOMERTN                 ;CURSOR TO HOME POSITION
        CALL    CRTMS                   ;CRT M/S ACCESS
        RET



HEXINP:
;------
;  ENTER HEXA-INPUT MODE
;
        MOV     BYTE PTR [HEXMOD],1
        MOV     WORD PTR [KBH_ADR],OFFSET KBH_ASCI
        RET



CLRSCREN:
;--------
; CLEAR VIDEO & CURSOR HOME
;
        CALL    CLRRTN
        CALL    HOMERTN
        RET



ROLSPD:
;------
; SCROLL UP SPEED CONTROL (FAST <--> SLOW)
;
        XOR     [ROLSW],01H
        RET



KNJSW:                                  ;CTRL-F4
;-----
; CHANGE CHARACTER MODE ( KANJI <--> GRAPHIC CHAR )
;
        MOV     [MODMARK1],'g'          ;GRAPH MODE (JIS-8)
        XOR     [SFTJISMOD],01H
        JZ      KNJSW1                  ;BR. IF KANJI MODE
        MOV     [MODMARK1],' '          ;KANJI MODE (SHIFT JIS)
KNJSW1:
        CALL    DSPFKY                  ;DISPLAY FUNCTION KEY
        RET

CRTMS:
;-----
;       CRT M/S CONTROL ( CHANGE CHARACTER FONT )
;
N_80CRT  = 10000000B                    ;80CRT(640x200) BIT             870825
N_20LINE = 00000001B                    ;20LINE MODE BIT                870825

        MOV     AH,0BH
        INT     18H                     ;GET CRT MODE
;--------------------- INS -------------------------------------870825H/N-
        TEST    [SYS_501],00001000B     ;CHECK H/W MODE
        JNZ     CRTMSH                  ;HIRESO MODE
        AND     AL,NOT N_80CRT AND NOT N_20LINE
        OR      [LINMOD],0              ;20LINE MODE ?
        JNZ     CRTMS10                 ;NO
        OR      AL,N_20LINE             ;SET 20LINE MODE
        JMP SHORT CRTMS10
CRTMSH:
;------------------------------------------------------------------------
        AND     AL,0EFH                 ;CLEAR LINE MODE BIT
        OR      BYTE PTR [LINMOD],0
        JZ      CRTMS10
        OR      AL,10H
CRTMS10:
        MOV     AH,0AH
        INT     18H                     ;SET CRT MODE
        MOV     AH,12H
        SUB     AH,[CSRSW]
        INT     18H                     ;CURSOR ON/OFF
        RET

        PAGE
;************************************************
;*                                              *
;*      CODE CONVERT                            *
;*              JIS C6226 -> SJC26(SHIFT JIS)   *
;*                                              *
;************************************************

D_PCONV:
;-------

        ADD     AL,1FH                  ;AL := AL+1FH
        SHR     AH,1                    ;AH := AH/2
        JB      D_PCONV0                ;IF AH MOD 2 = 0
        DEC     AH                      ; THEN AH := AH-1
        ADD     AL,5EH                  ;       AL := AL+5EH
D_PCONV0:
        CMP     AL,7FH                  ;IF AL >= 7FH
        JB      D_PCONV1                ; THEN AL := AL+1
        INC     AL
D_PCONV1:
        CMP     AH,2EH                  ;IF AH < 2FH
        JA      D_PCONV2                ; THEN AH := AH+71H
        ADD     AH,71H
        RET
D_PCONV2:
        ADD     AH,0B1H                 ; ELSE AH := AH+0B1H
        RET

KKB_DISP_GLINE:
;--------------
;       CLEAR & DISPLAY GUIDE_LINE

        MOV     AL,[CURLIN]
        XOR     CX,CX
        CMP     [FKYSW],0
        JNE     DISP_GLINE1             ;25/31 LINE MODE
        CMP     AL,[ENDLINE]
        JB      DISP_GLINE1
        MOV     CL,02H
DISP_GLINE1:
        MOV     [KBGLIN],CL
        ADD     CL,[LINMOD]
        CALL    GSCROLL                 ;GDC SCROLL CMD
        RET


KKB_ERASE_GLINE:
;---------------
;       ERASE GUIDE LINE

        MOV     CX,4                    ;
        ADD     CL,[LINMOD]             ;
        CALL    GSCROLL                 ;GDC SCROLL COMMAND
        MOV     [KBGLIN],0              ;RESET GLINE MOD
        RET


GSCROLL:
        ;               CALL MULTI WINDOW FUNCTION OF CRT BIOS FOR GUIDE LINE
        SHL     CX,1
        SHL     CX,1
        SHL     CX,1
;----------------------------------------------------------870825-------
        ADD     CX,OFFSET JPN_SCRD1H
        TEST    [SYS_501],00001000B     ;HW MODE ?
        JNZ     GS0001                  ;HIRESO
        SUB     CX,OFFSET JPN_SCRD1H
        ADD     CX,OFFSET JPN_SCRD1N 
GS0001:
;-----------------------------------------------------------------------
        MOV     AH,0FH                  ;MULTI WINDOW FUNCTION CALL
        MOV     DX,02H                  ;DH=0:START WIN#,DL=2:NUMBER OF WIN
        CLI
        MOV     BX,DS                   ;                               @DOS5
        INT     18H                     ;CRT BIO COMMAND
        STI
        RET
 

KKB_CLEAR_GLINE:
;---------------
;
        XOR     DI,DI                   ;GUIDE LINE OFFSET
        MOV     CX,80
        JMP     SHORT   CLEAR_VRAM

                                        
KB_CLRMNU:                              ;UPDATE
;---------
;       CLEAR TEMPLATE (GUIDE LINE)

        MOV     DI,0014H                ;OFFSET (GUIDE LINE)
        MOV     CX,72                   ;LENGTH
CLEAR_VRAM:
        PUSH    AX
        PUSH    ES
        PUSH    DI
        PUSH    CX
;-------------------------------------------------------------870825----
;       MOV     AX,GLIN_SEG             ;GUIDE LINE SEGMENT ADDR
;----------------
        MOV     AX,[VRAMSEG]            ;GET VRAM SEGMENT
        ADD     AX,[GLIN_SEG]
;-----------------------------------------------------------------------
        MOV     ES,AX
        MOV     AX,0020H
        REP     STOSW                   ;NULL PADDING
        POP     CX
        POP     DI
        ADD     DI,2000H                ;ADD ATTRIBUTE OFFSET
        MOV     AX,00C1H                ;YELLOW NOMAL ATTRIBUTE
        REP     STOSW
        POP     ES
        POP     AX
        RET

        PAGE
KKB_CHANG_G_SHFT:
;----------------
        PUSH    SI
        PUSH    DI
        PUSH    ES
;----------------------------------------------------------870825------
;       MOV     SI,GLIN_SEG
;----------------
        MOV     SI,[VRAMSEG]            ;GET VRAM SEGMENT
        ADD     SI,[GLIN_SEG]
;----------------------------------------------------------------------
        MOV     ES,SI
        MOV     SI,OFFSET WAKU_TABLE
        XOR     DI,DI
        MOV     CX,10
        REP     MOVSW
        POP     ES
        POP     DI
        POP     SI
        RET
;=======
KKB_HEXA:   
;=======

        CMP     AL,20H
        JB      HEXA_CTL
        MOV     BL,[KBINP_CNT]
        CALL    HEXCHK                  ;KEY CHECK
        AND     AH,AH                   ;KEY ERROR
        JZ      HEXA_ER1
        CMP     BL,5
        JE      HEXA_2                  ;END
        CMP     BL,3
        JNE     HEXA_1
        MOV     [ROME_1STSAV],AL                ;SAVE 1ST BYTE
HEXA_1:
        XOR     AH,AH
        MOV     [KBINP_CNT],BL
        RET
HEXA_CTL:
        MOV     BYTE PTR [FKY_BUFFER],AL
        MOV     [FKYPTR],OFFSET FKY_BUFFER
        MOV     [FKYCNT],1
        MOV     AH,0FFH
        RET
HEXA_2: 
        MOV     BL,1
        MOV     AH,[ROME_1STSAV]        ;GET 1ST BYTE
        CMP     AH,0                    ;PC-HANKAKU ?
        JNE     HEXA_3                  ;N
        MOV     AH,29H                  ;CONVERT TO JIS-HANKAKU
        CMP     AL,0A1H                 ;0021-007E -> 2921-297E
        JB      HEXA_3                  ;00A1-00DF -> 2A21-2A5F
        INC     AH
        CMP     AL,0E0H
        JNB     HEXA_ER
        SUB     AL,80H
HEXA_3:
        CMP     AH,21H
        JB      HEXA_ER                 ;ERROR
        CMP     AH,7FH
        JNB     HEXA_ER                 ;ERROR
        CMP     AL,21H
        JB      HEXA_ER                 ;ERROR
        CMP     AL,7FH
        JNB     HEXA_ER                 ;ERROR
        CALL    D_PCONV                 ;CONVERT TO SHIFT-JIS
HEXA_RET:
        XCHG    AH,AL
        CMP     [FKYCNT],0              ;FKY BUFF EMPTY ?
        JNE     HEXA_RET_NOTEMP         ;BR. IF NO (ADD)
        MOV     WORD PTR [FKY_BUFFER],AX        ;
        MOV     [FKYPTR],OFFSET FKY_BUFFER
        MOV     [FKYCNT],2              ;ENTER FKY-MODE
        JMP     KKB_EXT


; ERROR BEEP
HEXA_ER:
        CALL    BELRTN                  ;ERROR BEEP
HEXA_ER1:
        MOV     [KBINP_CNT],1           ;CLEAR COUNTER
        XOR     AH,AH
        RET

HEXA_RET_NOTEMP:
        CALL    STORE_FKY
HEXA_RET_DONE:
        MOV     [KBINP_CNT],BL
        RET

STORE_FKY:
;---------

        MOV     DI,[FKYPTR]
        XOR     DH,DH
        MOV     DL,[FKYCNT]
        ADD     DI,DX
        PUSH    ES
        MOV     DX,DS                   ;
        MOV     ES,DX
        STOSW
        POP     ES
        ADD     [FKYCNT],2
        RET

KEYBOARD_CODE_END:
KEYBOARD_END:

BIOS_CODE       ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\hdint.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 HDINT.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: HDINT.ASM                                  *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************
;
;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Data       segment word public 'Bios_Data'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   INT1B_OFST:DWORD

Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   HD_ENTC:NEAR

Bios_Code       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        PUBLIC  HD_ENTI_CODE
        PUBLIC  HDINT_CODE_START
        PUBLIC  HDINT_CODE_END
        PUBLIC  HDINT_END

HDINT_CODE_START:

;
;------ 5" HARD DISK BASIC I/O
;
HD_ENTI_CODE:
        PUSH    BP
        MOV     BP,SP
        AND     BYTE PTR 6[BP],0FEH     ;CARRY FLAG OFF
        POP     BP
        CALL    HD_ENTC
        JNB     HD_EXTI
        PUSH    BP
        MOV     BP,SP
        OR      BYTE PTR 6[BP],001H     ;CARRY FLAG ON
        POP     BP
HD_EXTI:
        IRET

HDINT_CODE_END  EQU     $
HDINT_END       EQU     $

Bios_Code       ends
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\mschar.asm ===
page	,160
	title	mschar - character and clock devices
;
;----------------------------------------------------------------------------
;
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------
;

	.xlist

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include msequ.inc
	include	devsym.inc
        include ioctl.inc
        include vint.inc

break	macro
	endm

        include biosbop.inc

	include error.inc
	.list

	include msgroup.inc	; define Bios_Data segment


	extrn	ptrsav:dword

	extrn	altah:byte
	extrn	keyrd_func:byte
	extrn	keysts_func:byte

	extrn	auxnum:word
	extrn	auxbuf:byte

	extrn	wait_count:word
	extrn	printdev:byte
	extrn	Old10:dword
	extrn	spc_mse_int10:dword
	extrn	int29Perf:dword


; close Bios_Data and open Bios_Code segment

	tocode

	extrn	bc_cmderr:near
	extrn	bc_err_cnt:near

MODE_CTRLBRK	equ	0ffh		; M013

;************************************************************************
;*									*
;*	device driver dispatch tables					*
;*									*
;*	each table starts with a byte which lists the number of		*
;*	legal functions, followed by that number of words.  Each	*
;*	word represents an offset of a routine in Bios_Code which	*
;*	handles the function.  The functions are terminated with	*
;*	a near return.  If carry is reset, a 'done' code is returned	*
;*	to the caller.  If carry is set, the ah/al registers are	*
;*	returned as abnormal completion status.  Notice that ds		*
;*	is assumed to point to the Bios_Data segment throughout.	*
;*									*
;************************************************************************

	public	con_table
con_table:
	db	(((offset con_table_end) - (offset con_table) - 1)/2)
	dw	bc_exvec	; 00 init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	con_read	; 04
	dw	con_rdnd	; 05
	dw	bc_exvec	; 06
	dw	con_flush	; 07
	dw	con_writ	; 08
	dw	con_writ	; 09
	dw	bc_exvec	; 0a
con_table_end:

	public	prn_table
prn_table	label	byte
	db	(((offset prn_table_end) - (offset prn_table) -1)/2)
	dw	bc_exvec	; 00 init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	prn_input	; 04 indicate zero chars read
	dw	z_bus_exit	; 05 read non-destructive
	dw	bc_exvec	; 06
	dw	bc_exvec	; 07
	dw	prn_writ	; 08
	dw	prn_writ	; 09
	dw	prn_stat	; 0a
	dw	bc_exvec	; 0b
	dw	bc_exvec	; 0c
	dw	prn_open	; 0d
	dw	prn_close	; 0e
	dw	bc_exvec	; 0f
	dw	prn_tilbusy	; 10
	dw	bc_exvec	; 11
	dw	bc_exvec	; 12
	dw	prn_genioctl	; 13
	dw	bc_exvec	; 14
	dw	bc_exvec	; 15
	dw	bc_exvec	; 16
	dw	bc_exvec	; 17
	dw	bc_exvec	; 18
	dw	prn_ioctl_query	; 19
prn_table_end:



	public	aux_table
aux_table	label	byte
	db	(((offset aux_table_end) - (offset aux_table) -1)/2)

	dw	bc_exvec	; 00 - init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	aux_read	; 04 - read
	dw	aux_rdnd	; 05 - read non-destructive
	dw	bc_exvec	; 06
	dw	aux_flsh	; 07
	dw	aux_writ	; 08
	dw	aux_writ	; 09
	dw	aux_wrst	; 0a
aux_table_end:


	public	tim_table
tim_table	label	byte
	db	(((offset tim_table_end) - (offset tim_table) -1)/2)
	dw	bc_exvec	; 00
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	bc_cmderr	; 04
	dw	z_bus_exit	; 05
	dw	bc_exvec	; 06
	dw	bc_exvec	; 07
	dw	bc_cmderr	; 08
	dw	bc_cmderr	; 09
tim_table_end:

;************************************************************************
;*									*
;*	con_read - read cx bytes from keyboard into buffer at es:di	*
;*									*
;************************************************************************

con_read proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	con_exit

con_loop:
	call	chrin		;get char in al
	stosb			;store char at es:di
	loop	con_loop

con_exit:
	clc
	ret
con_read endp

;************************************************************************
;*									*
;*	chrin - input single char from keyboard into al			*
;*									*
;*	  we are going to issue extended keyboard function, if		*
;*	  supported.  the returning value of the extended keystroke	*
;*	  of the extended keyboard function uses 0e0h in al		*
;*	  instead of 00 as in the conventional keyboard function.	*
;*	  this creates a conflict when the user entered real		*
;*	  greek alpha charater (= 0e0h) to  distinguish the extended	*
;*	  keystroke and the greek alpha.  this case will be handled	*
;*	  in the following manner:					*
;*									*
;*	      ah = 16h							*
;*	      int 16h							*
;*	      if al == 0, then extended code (in ah)			*
;*	      else if al == 0e0h, then					*
;*	      if ah <> 0, then extended code (in ah)			*
;*		else greek_alpha character.				*
;*									*
;*	also, for compatibility reason, if an extended code is		*
;*	  detected, then we are going to change the value in al		*
;*	  from 0e0h to 00h.						*
;*									*
;************************************************************************


chrin	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah,keyrd_func		; set by msinit. 0 or 10h
	xor	al,al
	xchg	al,altah		;get character & zero altah

	or	al,al
	jnz	keyret

	int	16h			; do rom bios keyrd function

alt10:
	or	ax,ax			;check for non-key after break
	jz	chrin

	cmp	ax,7200h		;check for ctrl-prtsc
	jnz	alt_ext_chk

	mov	al,16
	jmp	short keyret

alt_ext_chk:

;**************************************************************
;  if operation was extended function (i.e. keyrd_func != 0) then
;    if character read was 0e0h then
;      if extended byte was zero (i.e. ah == 0) then
;	 goto keyret
;      else
;	 set al to zero
;	 goto alt_save
;      endif
;    endif
;  endif

	cmp	byte ptr keyrd_func,0
	jz	not_ext
	cmp	al,0e0h
	jnz	not_ext

	or	ah,ah
	jz	keyret
ifdef	DBCS
ifdef   KOREA                           ; Keyl  1990/11/5
        cmp     ah, 0f0h                ; If hangeul code range then
        jb      EngCodeRange1           ; do not modify any value.
        cmp     ah, 0f2h
        jbe     not_ext
EngCodeRange1:
endif	; KOREA
endif	; DBCS
	xor	al,al
	jmp	short alt_save

not_ext:

	or	al,al			;special case?
	jnz	keyret

alt_save:
	mov	altah,ah		;store special key
keyret:
	ret
chrin	endp

;************************************************************************
;*									*
;*	con_rdnd - keyboard non destructive read, no wait		*
;*									*
;*	pc-convertible-type machine: if bit 10 is set by the dos	*
;*	in the status word of the request packet, and there is no	*
;*	character in the input buffer, the driver issues a system	*
;*	wait request to the rom. on return from the rom, it returns	*
;*	a 'char-not-found' to the dos.					*
;*									*
;************************************************************************

con_rdnd proc	near
	assume	ds:Bios_Data,es:nothing

	mov	al,[altah]
	or	al,al
	jnz	rdexit

	mov	ah,keysts_func		; keyboard i/o interrupt - get
	int	16h			;  keystroke status (keysts_func)
	jnz	gotchr

;
; pc-convertible checking is not needed on NTVDM
; if no key in buff return immediatly with busy status
;04-Aug-1992 Jonle
;
;	cmp	fhavek09,0
;	jz	z_bus_exit		; return with busy status if not k09
;
;       les     bx,[ptrsav]
;       assume  es:nothing
;       test    es:[bx].status,0400h    ; system wait enabled?
;       jz      z_bus_exit              ;  return with busy status if not
;
;	need to wait for ibm response to request for code
;	on how to use the system wait call.
;
;        mov     ax,4100h                ; wait on an external event
;        xor     bl,bl                   ; M055; wait for any event
;        int     15h                     ; call rom for system wait

z_bus_exit:
	stc
	mov	ah,3			; indicate busy status
	ret

gotchr:
	or	ax,ax
	jnz	notbrk			;check for null after break

	mov	ah,keyrd_func		; issue keyboard read function
	int	16h
	jmp	con_rdnd		;and get a real status

notbrk:
	cmp	ax,7200h		;check for ctrl-prtsc
	jnz	rd_ext_chk

	mov	al,'P' and 1fh		; return control p
	jmp	short rdexit

rd_ext_chk:
	cmp	keyrd_func,0		; extended keyboard function?
	jz	rdexit			; no. normal exit.

	cmp	al,0e0h 		; extended key value or greek alpha?
	jne	rdexit

ifdef	DBCS
ifdef   KOREA
        cmp     ah, 0f0h                ; If hangeul code range then
        jb      EngCodeRange            ; do not modify any value.
        cmp     ah, 0f2h
        jbe     rdexit                  ; Keyl 90/11/5
EngCodeRange:
endif	; KOREA
endif	; DBCS

	cmp	ah,0			; scan code exist?
	jz	rdexit			; yes. greek alpha char.
	mov	al,0			; no. extended key stroke.
					;  change it for compatibility

rdexit:
	les	bx,[ptrsav]
	assume	es:nothing
	mov	es:[bx].media,al	; *** return keyboard character here

bc_exvec:
	clc				; indicate normal termination
	ret

con_rdnd endp

;************************************************************************
;*									*
;*	con_write - console write routine				*
;*									*
;*	entry:	es:di -> buffer						*
;*		cx    =  count						*
;*									*
;************************************************************************

con_writ proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	bc_exvec

	push	es

	mov	bx,word ptr [int29Perf]
	mov	dx,word ptr [int29Perf+2] ;DX:BX is original INT 29h vector
	sub	ax,ax
	mov	es,ax
	cmp	BX,es:[29h*4+0]
	jne	con_lp1 		; if not the same do single int10s
	cmp	DX,es:[29h*4+2]
	jne	con_lp1 		; if not the same do single int10s
	mov	bx,word ptr [spc_mse_int10]
	mov	dx,word ptr [spc_mse_int10+2] ;DX:BX is original INT 10h vector
	cmp	BX,es:[10h*4+0]
	jne	con_lp1 		; if not the same do single int10s
	cmp	DX,es:[10h*4+2]
	jne	con_lp1 		; if not the same do single int10s

	pop	es

	; Sudeepb 21-Jul-1992:	We know that no one has hooked in10 so we
	; can optimize it by calling a private in1t10h which takes a full
	; string, displays it with the same attribute as present on the
	; screen and moves the cursor to the end.

	mov	ax,46h		; sounds like a good flag value
	push	ax		; make an iret frame
	push	cs
	mov	ax, offset ret_adr
	push	ax
	push	dx		; dx:bx is pointing to softpc int10 handler
	push	bx		; make the retf frame
	mov	ax,13FFh	; AH = WRITESTRING, AL = subfunction
	retf
ret_adr:
	jmp	short cc_ret

con_lp1:
	pop	es

con_lp:
	mov	al,es:[di]		;get char
	inc	di
	int	chrout			;output char
	loop	con_lp			;repeat until all through

cc_ret:
	clc
	ret
con_writ	endp

;************************************************************************
;*									*
;*	con_flush - flush out keyboard queue				*
;*									*
;************************************************************************

	public	con_flush	; called from msbio2.asm for floppy swapping
con_flush proc	near
	assume	ds:Bios_Data,es:nothing


	mov	[altah],0		;clear out holding buffer

;	while (charavail()) charread();

flloop:
	mov	ah,1			; command code for check status
	int	16h			; call rom-bios keyboard routine
	jz	cc_ret			; return carry clear if none

	xor	ah,ah			; if zf is nof set, get character
	int	16h			; call rom-bios to get character
	jmp	flloop

con_flush endp

;************************************************************************
;*									*
;*	some equates for rom bios printer i/o				*
;*									*
;************************************************************************

; ibm rom status bits (i don't trust them, neither should you)
; warning!!!  the ibm rom does not return just one bit.  it returns a
; whole slew of bits, only one of which is correct.


notbusystatus	=   10000000b		; not busy
nopaperstatus	=   00100000b		; no more paper
prnselected	=   00010000b		; printer selected
ioerrstatus	=   00001000b		; some kinda error
timeoutstatus	=   00000001b		; time out.

noprinter	=   00110000b		; no printer attached

;************************************************************************
;*									*
;*	prn_input - return with no error but zero chars read		*
;*									*
;*	enter with cx = number of characters requested			*
;*									*
;************************************************************************

prn_input proc	near
	assume	ds:Bios_Data,es:nothing

	call	bc_err_cnt	; reset count to zero (sub reqpkt.count,cx)
	clc			;  but return with carry reset for no error
	ret

prn_input endp

;************************************************************************
;*									*
;*	prn_writ - write cx bytes from es:di to printer device		*
;*									*
;*	auxnum has printer number					*
;*									*
;************************************************************************

prn_writ proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	prn_done		;no chars to output

prn_loop:
	mov	bx,2			;retry count

prn_out:
	call	prnstat 		; get status
	jnz	TestPrnError		; error

	mov	al,es:[di]		; get character to print
	xor	ah,ah
	call	prnop			; print to printer
	jz	prn_con			; no error - continue

	cmp	ah, MODE_CTRLBRK	; M013
	jne	@f			; M013
	mov	al, error_I24_gen_failure ; M013
	mov	altah, 0		; M013
	jmp	short pmessg		; M013
@@:
	test	ah,timeoutstatus
	jz	prn_con			; not time out - continue

TestPrnError:
	dec	bx			;retry until count is exhausted.
	jnz	prn_out

pmessg:
	jmp	bc_err_cnt		; return with error

; next character

prn_con:
	inc	di			;point to next char and continue
	loop	prn_loop

prn_done:
	clc
	ret
prn_writ	endp

;************************************************************************
;*									*
;*	prn_stat - device driver entry to return printer status		*
;*									*
;************************************************************************

prn_stat proc	near

	call	prnstat 		;device in dx
	jnz	pmessg			; other errors were found
	test	ah,notbusystatus
	jnz	prn_done		;no error. exit
	jmp	z_bus_exit		; return busy status
prn_stat endp

;************************************************************************
;*									*
;*	prnstat - utilty function to call ROM BIOS to check		*
;*		 printer status.  Return meaningful error code		*
;*									*
;************************************************************************

prnstat proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah, 2			; set command for get status
prnstat	endp				; fall into prnop

;************************************************************************
;*									*
;*	prnop - call ROM BIOS printer function in ah			*
;*		return zero true if no error				*
;*		return zero false if error, al = error code		*
;*									*
;************************************************************************

prnop	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	dx,[auxnum]		; get printer number
	int	17h			; call rom-bios printer routine

		; This check was added to see if this is a case of no
		; printer being installed. This tests checks to be sure
		; the error is noprinter (30h)

	push	ax			; M044
	and	ah, noprinter		; M044
	cmp	AH,noprinter		; Chk for no printer
	pop	ax			; M044

	jne	NextTest
	and	AH,NOT nopaperstatus
	or	AH,ioerrstatus

; examine the status bits to see if an error occurred.	unfortunately, several
; of the bits are set so we have to pick and choose.  we must be extremely
; careful about breaking basic.

NextTest:
	test	ah,(ioerrstatus+nopaperstatus) ; i/o error?
	jz	checknotready		; no, try not ready

; at this point, we know we have an error.  the converse is not true.

	mov	al,error_I24_out_of_paper
					; first, assume out of paper
	test	ah,nopaperstatus	; out of paper set?
	jnz	ret1			; yes, error is set
	inc	al			; return al=10 (i/o error)
ret1:
	ret				; return with error

checknotready:
	mov	al,2			; assume not-ready
	test	ah,timeoutstatus	; is time-out set?
	ret				; if nz then error, else ok
prnop endp

;************************************************************************
;*                                                                      *
;*      prn_open    - send bop to disable auto-close, and wait for      *
;*                   a DOS close                                        *
;*                                                                      *
;*      inputs:                                                         *
;*      outputs: BOP has been issued                                    *
;*                                                                      *
;************************************************************************

prn_open proc near
        push    si
        push    dx
        push    ds
        mov     dx,40h
        mov     ds,dx
        test    word ptr ds:[FIXED_NTVDMSTATE_REL40],  EXEC_BIT_MASK
        pop     ds
        jnz     po_nobop
        xor     dh, dh
        mov     dl, [printdev]
        or      dl, dl
        jz      @f
        dec     dl
@@:
        mov     si,PRNIO_OPEN
        bop     %BIOS_PRINTER_IO
po_nobop:
        pop     dx
        pop     si
        ret
prn_open endp

;************************************************************************
;*                                                                      *
;*      prn_close   - send bop to close actual printer, and re-enable   *
;*                   autoclose                                          *
;*                                                                      *
;*      inputs:                                                         *
;*      outputs: BOP has been issued                                    *
;*                                                                      *
;************************************************************************

prn_close proc near
        push    si
        push    dx
        push    ds
        mov     dx,40h
        mov     ds,dx
        test    word ptr ds:[FIXED_NTVDMSTATE_REL40],  EXEC_BIT_MASK
        pop     ds
        jnz     pc_nobop
        xor     dh, dh
        mov     dl, [printdev]
        or      dl, dl
        jz      @f
        dec     dl
@@:
        mov     si,PRNIO_CLOSE
        bop     %BIOS_PRINTER_IO
pc_nobop:
        pop     dx
        pop     si
        ret
prn_close endp

;************************************************************************
;*									*
;*	prn_tilbusy - output until busy.  Used by print spooler.	*
;*		     this entry point should never block waiting for	*
;*		     device to come ready.				*
;*									*
;*	inputs:	cx = count, es:di -> buffer				*
;*	outputs: set the number of bytes transferred in the		*
;*		 device driver request packet				*
;*									*
;************************************************************************

prn_tilbusy proc near

	mov	si,di			; everything is set for lodsb

prn_tilbloop:
	push	cx

	push	bx
	xor	bh,bh
	mov	bl,[printdev]
	shl	bx,1
	mov	cx,wait_count[bx]	; wait count times to come ready
	pop	bx

prn_getstat:
	call	prnstat 		; get status
	jnz	prn_bperr		; error
	test	ah,10000000b		; ready yet?
	loopz	prn_getstat		; no, go for more

	pop	cx			; get original count
	jz	prn_berr		; still not ready => done

	lods	es:byte ptr [si]
	xor	ah,ah
	call	prnop
	jnz	prn_berr		; error

	loop	prn_tilbloop		; go for more

	clc				; normal no-error return
	ret				;   from device driver

prn_bperr:
	pop	cx			; restore transfer count from stack

prn_berr:
	jmp	bc_err_cnt
prn_tilbusy endp

;************************************************************************
;*									*
;*	prn_genioctl - get/set printer retry count			*
;*									*
;************************************************************************

prn_genioctl proc near
	assume	ds:Bios_Data,es:nothing

	les	di,[ptrsav]
	cmp	es:[di].majorfunction,ioc_pc
	jz	prnfunc_ok

prnfuncerr:
	jmp	bc_cmderr

prnfunc_ok:
	mov	al,es:[di].minorfunction
	les	di,es:[di].genericioctl_packet
	xor	bh,bh
	mov	bl,[printdev]		; get index into retry counts
	shl	bx,1
	mov	cx,wait_count[bx]	; pull out retry count for device

	cmp	al,get_retry_count
	jz	prngetcount

	cmp	al,set_retry_count
	jnz	prnfuncerr

	mov	cx,es:[di].rc_count
prngetcount:
	mov	wait_count[bx],cx	; place "new" retry count
	mov	es:[di].rc_count,cx	; return current retry count
	clc
	ret
prn_genioctl endp

;************************************************************************
;*									*
;*  prn_ioctl_query							*
;*									*
;*  Added for 5.00							*
;************************************************************************

prn_ioctl_query PROC NEAR
	assume	ds:Bios_Data,es:nothing

	les	di,[ptrsav]
	cmp	es:[di].majorfunction,ioc_pc
	jne	prn_query_err

	mov	al,es:[di].minorfunction
	cmp	al,get_retry_count
	je	IOCtlSupported
	cmp	al,set_retry_count
	jne	prn_query_err

IOCtlSupported:
	clc
	ret

prn_query_err:
	stc
	jmp	BC_CmdErr

prn_ioctl_query ENDP

;************************************************************************
;*									*
;*	aux port driver code -- "aux" == "com1"				*
;*									*
;*	the device driver entry/dispatch code sets up auxnum to		*
;*	give the com port number to use (0=com1, 1=com2, 2=com3...)	*
;*									*
;************************************************************************

;	values in ah, requesting function of int 14h in rom bios

auxfunc_send	 equ	1	;transmit
auxfunc_receive  equ	2	;read
auxfunc_status	 equ	3	;request status

;	error flags, reported by int 14h, reported in ah:

flag_data_ready  equ	01h	;data ready
flag_overrun	 equ	02h	;overrun error
flag_parity	 equ	04h	;parity error
flag_frame	 equ	08h	;framing error
flag_break	 equ	10h	;break detect
flag_tranhol_emp equ	20h	;transmit holding register empty
flag_timeout	 equ	80h	;timeout

;	these flags reported in al:

flag_cts	 equ	10h	;clear to send
flag_dsr	 equ	20h	;data set ready
flag_rec_sig	 equ	80h	;receive line signal detect

;************************************************************************
;*									*
;*	aux_read - read cx bytes from [auxnum] aux port to buffer	*
;*		   at es:di						*
;*									*
;************************************************************************

aux_read proc near
	assume	ds:Bios_Data,es:nothing

	jcxz	exvec2		; if no characters, get out

	call	getbx		; put address of auxbuf in bx
	xor	al,al		; clear al register
	xchg	al,[bx] 	; get character , if any, from
				;   buffer and clear buffer
	or	al,al		; if al is nonzero there was a
				;   character in the buffer
	jnz	aux2		; if so skip first auxin call

aux1:
	call	auxin		; get character from port
;		^^^^^ 		  won't return if error
aux2:
	stosb			; store character
	loop	aux1		; if more characters, go around again

exvec2:
	clc			; all done, successful exit
	ret

aux_read endp

;************************************************************************
;*									*
;*	auxin - call rom bios to read character from aux port		*
;*		if error occurs, map the error and return one		*
;*		level up to device driver exit code, setting		*
;*		the number of bytes transferred appropriately		*
;*									*
;************************************************************************

;
; M026 - BEGIN
;
auxin	proc	near
	mov	ah,auxfunc_receive
	call	auxop		;check for frame, parity, or overrun errors
	 			;warning: these error bits are unpredictable
				; if timeout (bit 7) is set
	test	ah, flag_frame or flag_parity or flag_overrun
	jnz	arbad		; skip if any error bits set
	ret			; normal completion, ah=stat, al=char

;	error getting character

arbad:
	pop	ax		; remove return address (near call)
	xor	al,al
	or	al,flag_rec_sig or flag_dsr or flag_cts
	jmp	bc_err_cnt

auxin	endp

IFDEF	COMMENTEDOUT
auxin	proc	near
	push	cx
	mov	cx, 20		; number of retries on time out errors
@@:
	mov	ah,auxfunc_receive
	call	auxop		;check for frame, parity, or overrun errors
	 			;warning: these error bits are unpredictable
				; if timeout (bit 7) is set
	test	ah, flag_timeout
	jz	no_timeout
	loop	@b
no_timeout:
	pop	cx
	test	ah, flag_timeout or flag_frame or flag_parity or flag_overrun
	jnz	arbad		; skip if any error bits set
	ret			; normal completion, ah=stat, al=char

;	error getting character

arbad:
	pop	ax		; remove return address (near call)
	xor	al,al
	or	al,flag_rec_sig or flag_dsr or flag_cts
	jmp	bc_err_cnt

auxin	endp
ENDIF

;
; M026 - END
;
;************************************************************************
;*									*
;*	aux_rdnd - non-destructive aux port read			*
;*									*
;************************************************************************

aux_rdnd proc	near
	assume	ds:Bios_Data,es:nothing

	call	getbx		; have bx point to auxbuf
	mov	al,[bx] 	; copy contents of buffer to al
	or	al,al		; if al is non-zero (char in buffer)
	jnz	auxrdx		;   then return character

	call	auxstat 	;   if not, get status of aux device
	test	ah,flag_data_ready ; test data ready
	jz	auxbus		;   then device is busy (not ready)

	test	al,flag_dsr	;test data set ready
	jz	auxbus		;   then device is busy (not ready)

	call	auxin		;   else aux is ready, get character
	mov	[bx],al 	; save character in buffer

auxrdx:
	jmp	rdexit		; return al in [packet.media]

auxbus:
	jmp	z_bus_exit	; return busy status
aux_rdnd endp

;************************************************************************
;*									*
;*	aux_wrst - return aux port write status				*
;*									*
;************************************************************************

aux_wrst proc	near
	assume	ds:Bios_Data,es:nothing

	call	auxstat 	; get status of aux in ax
	test	al,flag_dsr	; test data set ready
	jz	auxbus		;   then device is busy (not ready)
	test	ah,flag_tranhol_emp ;test transmit hold reg empty
	jz	auxbus		;   then device is busy (not ready)
	clc
	ret
aux_wrst endp

;************************************************************************
;*									*
;*	auxstat - call rom bios to determine aux port status		*
;*									*
;*	exit:	ax = status						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxstat	proc near
	mov	ah,auxfunc_status
auxstat endp			; fall into auxop

;************************************************************************
;*									*
;*	auxop - perform rom-biox aux port interrupt			*
;*									*
;*	entry:	ah = int 14h function number				*
;*	exit:	ax = results						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxop	proc	near
				;ah=function code
				;0=init, 1=send, 2=receive, 3=status
	mov	dx,[auxnum]	; get port number
	int	14h		; call rom-bios for status
	ret
auxop	endp

;************************************************************************
;*									*
;*	aux_flsh - flush aux input buffer - set contents of		*
;*		   auxbuf [auxnum] to zero				*
;*									*
;*	cas - shouldn't this code call the rom bios input function	*
;*	      repeatedly until it isn't ready?  to flush out any	*
;*	      pending serial input queue if there's a tsr like MODE	*
;*	      which is providing interrupt-buffering of aux port?	*
;*									*
;************************************************************************

aux_flsh proc	near
	call	getbx		; get bx to point to auxbuf
	mov	byte ptr [bx],0 ; zero out buffer
	clc			; all done, successful return
	ret
aux_flsh endp

;************************************************************************
;*									*
;*	aux_writ - write to aux device					*
;*									*
;************************************************************************

aux_writ proc	near
	assume	ds:Bios_Data 	; set by aux device driver entry routine
	jcxz	exvec2		; if cx is zero, no characters
				;   to be written, jump to exit
aux_loop:
	mov	al,es:[di]	; get character to be written
	inc	di		; move di pointer to next character
	mov	ah,auxfunc_send ;value=1, indicates a write
	call	auxop		;send character over aux port

	test	ah,flag_timeout ;check for error
	jz	awok		;   then no error
	mov	al,10		;   else indicate write fault
	jmp	bc_err_cnt 	; call error routines

				; if cx is non-zero, still more
awok:
	loop	aux_loop	; more characrter to print
	clc			; all done, successful return
	ret
aux_writ endp

;************************************************************************
;*									*
;*	getbx - return bx -> single byte input buffer for		*
;*		selected aux port ([auxnum])				*
;*									*
;************************************************************************

getbx	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	bx,[auxnum]
	add	bx,offset auxbuf
	ret
getbx	endp

Bios_Code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\msbio1.asm ===
page	,160
	title	msbio1.asm - Bios_Data definition and device driver entry/exit

;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------
;
	include version.inc	; set build flags
	include biosseg.inc	; define BIOS segments

	include	devsym.inc
	include	msequ.inc
	include vint.inc


; Assembly conditional for stack switching
;
STACKSW		equ	1

Bios_Data	segment

	assume	cs:Bios_Data
	public	BData_start
BData_start:


	assume	ds:nothing,es:nothing

	public	hdrv_pat
hdrv_pat label	word			; patched by msinit
	assume	cs:Bios_Data

	extrn	init:near		; this is in msinit

	jmp	init			; go to initialization code


;	define some stuff that is also used by msdos.sys from an include file

In_Bios	=	0ffffh	; define flag for msbdata.inc
	include	msbdata.inc


	public	inHMA,xms
inHMA	db	0		; flag indicates we're running from HMA
xms	dd	0		; entry point to xms if above is true

	align	4

	public	ntvdmstate
ntvdmstate  dd	0
IF 2
.errnz	ntvdmstate-BData_start-FIXED_NTVDMSTATE_OFFSET
ENDIF


	public	ptrsav
ptrsav	dd	0

	public	auxbuf
auxbuf	db	0,0,0,0   	;set of 1 byte buffers for com 1,2,3, and 4
	public	zeroseg
zeroseg dw	0		; easy way to load segment registers with zero

	public	auxnum
auxnum	dw	0			;which aux device was requested


	public	res_dev_list

res_dev_list	label	byte
	p_attr	=	chardev+outtilbusy+dev320+IOQUERY+DEVOPCL
; **	p_attr	=	chardev+outtilbusy+dev320

	sysdev <auxdev2,8013h,strategy,con_entry,'CON     '>
auxdev2 sysdev <prndev2,8000h,strategy,aux0_entry,'AUX     '>
prndev2 sysdev <timdev,p_attr,strategy,prn0_entry,'PRN     '>
timdev	sysdev <com1dev,8008h,strategy,tim_entry,'CLOCK$  '>
com1dev sysdev <lpt1dev,8000h,strategy,aux0_entry,'COM1    '>
lpt1dev sysdev <lpt2dev,p_attr,strategy,prn1_entry,"LPT1    ">
lpt2dev sysdev <lpt3dev,p_attr,strategy,prn2_entry,"LPT2    ">
lpt3dev sysdev <com2dev,p_attr,strategy,prn3_entry,"LPT3    ">
com2dev sysdev <com3dev,8000h,strategy,aux1_entry,"COM2    ">
com3dev sysdev <com4dev,8000h,strategy,aux2_entry,"COM3    ">
com4dev dw	-1,Bios_Data,8000h,strategy,aux3_entry
	db	"COM4    "


		public	RomVectors
RomVectors	label	byte
	public	Old10,	Old15, Old19, Old1B
	db	10h					; M028
Old10	dd	(?)					; M028
	db	15h
Old15	dd	(?)
	db	19h
Old19	dd	(?)
	db	1bh
Old1B	dd	(?)
EndRomVectors	equ	$
		public	NUMROMVECTORS
NUMROMVECTORS	equ	((EndRomVectors - RomVectors)/5)

	public	spc_mse_int10
spc_mse_int10	dd	(?)

	public	int29Perf
int29Perf	dd	(?)


	public	keyrd_func
	public	keysts_func

; moved altah to inc\msbdata.inc so it could go in instance table in DOS

keyrd_func	db	0	; default is conventional keyboard read
keysts_func	db	1	; default is conventional keyboard status check.

	public printdev
printdev	db	0		; index into above array

		public	multrk_flag
multrk_flag	dw	0

; the following variable can be modified via ioctl sub-function 16. in this
; way, the wait can be set to suit the speed of the particular printer being
; used. one for each printer device.

	public wait_count
wait_count	dw	4 dup (50h)	; array of retry counts for printer

	public	int19sem
int19sem db	0			; indicate that all int 19
					; initialization is complete

;	we assume the following remain contiguous and their order doesn't change
i19_lst:
	irp	aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
	public	int19old&aa
		db	aa&h	; store the number as a byte
int19old&aa	dd	-1	;orignal hardware int. vectors for int 19h.
	endm

num_i19 =	((offset $) - (offset i19_lst))/5


;variables for dynamic relocatable modules
;these should be stay resident.

	public	int6c_ret_addr
int6c_ret_addr	dd	?		; return address from int 6c for p12 machine

;
;   data structures for real-time date and time
;
	public	bin_date_time
	public	month_table
	public	daycnt2
	public	feb29

bin_date_time:
	db	0		; century (19 or 20) or hours (0-23)
	db	0		; year in century (0...99) or minutes (0-59)
	db	0		; month in year (1...12) or seconds (0-59)
	db	0		; day in month (1...31)

month_table:
	dw	0		; january
	dw	31		; february
	dw	59
	dw	90
	dw	120
	dw	151
	dw	181
	dw	212
	dw	243
	dw	273
	dw	304
	dw	334		; december
daycnt2 dw	0000		; temp for count of days since 1-1-80
feb29	db	0		; february 29 in a leap year flag


;************************************************************************
;*									*
;*	entry points into Bios_Code routines.  The segment values	*
;*	  are plugged in by seg_reinit.					*
;*									*
;************************************************************************

	public	cdev
cdev	dd	chardev_entry
bcode_i2f dd	i2f_handler
end_BC_entries:

;************************************************************************
;*									*
;*	cbreak - break key handling - simply set altah=3 and iret	*
;*									*
;************************************************************************

	public	cbreak
cbreak	proc	near
	assume	ds:nothing,es:nothing

	mov	altah,3		;indicate break key set

	public	intret		; general purpose iret in the Bios_Data seg
intret:
        FIRET
cbreak	endp

;************************************************************************
;*									*
;*	strategy - store es:bx (device driver request packet)		*
;*		     away at [ptrsav] for next driver function call	*
;*									*
;************************************************************************

	public	strategy
strategy proc	far
	assume	ds:nothing,es:nothing

	mov	word ptr cs:[ptrsav],bx
	mov	word ptr cs:[ptrsav+2],es
	ret
strategy endp

;************************************************************************
;*									*
;*	device driver entry points.  these are the initial		*
;*	  'interrupt' hooks out of the device driver chain.		*
;*	  in the case of our resident drivers, they'll just		*
;*	  stick a fake return address on the stack which		*
;*	  points to dispatch tables and possibly some unit		*
;*	  numbers, and then call through a common entry point		*
;*	  which can take care of a20 switching				*
;*									*
;************************************************************************

con_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry	; call into code segment handler
	dw	con_table

con_entry endp

;--------------------------------------------------------------------

prn0_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	0,0		; device numbers

prn0_entry endp

;--------------------------------------------------------------------

prn1_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	0,1

prn1_entry endp

;--------------------------------------------------------------------

prn2_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	1,2

prn2_entry endp

;--------------------------------------------------------------------

prn3_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	2,3

prn3_entry endp

;--------------------------------------------------------------------

aux0_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	0

aux0_entry endp

;--------------------------------------------------------------------

aux1_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	1

aux1_entry endp

;--------------------------------------------------------------------

aux2_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	2

aux2_entry endp

;--------------------------------------------------------------------

aux3_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	3

aux3_entry endp

;--------------------------------------------------------------------

tim_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	tim_table

tim_entry endp

;--------------------------------------------------------------------

;************************************************************************
;*									*
;*	Ensure A20 is enabled before jumping into code in HMA.		*
;*	This code assumes that if Segment of Device request packet is	*
;*	DOS DATA segment then the Device request came from DOS & that	*
;*	A20 is already on.						*
;*									*
;************************************************************************

cdev_entry proc	near
	assume	ds:nothing,es:nothing
;
; M064 - BEGIN
;
	cmp	inHMA, 0
	je	ce_enter_codeseg; optimized for DOS in HMA

	push	ax
	mov	ax, DosDataSg
	cmp	word ptr [ptrsav+2], ax
	pop	ax
	jne	not_from_dos	; jump is coded this way to fall thru
				;	in 99.99% of the cases
ce_enter_codeseg:
	jmp	cdev
not_from_dos:
	call	EnsureA20On
;
; M064 - END
;
	jmp	short ce_enter_codeseg
cdev_entry endp

;************************************************************************
;*									*
;*	outchr - this is our int 29h handler.  it writes the		*
;*	   character in al on the display using int 10h ttywrite	*
;*									*
;************************************************************************

	public	outchr
outchr	proc	far
	assume	ds:nothing,es:nothing

	push	ax
	push	si
	push	di
	push	bp
	push	bx
	mov	ah,0eh		; set command to write a character
	mov	bx,7		; set foreground color
	int	10h		; call rom-bios
	pop	bx
	pop	bp
	pop	di
	pop	si
	pop	ax
        jmp     intret
outchr	endp

; M001 - BEGIN

;************************************************************************
;*									*
;*	EnsureA20On - ensure that a20 is enabled if we're running	*
;*	  in the HMA before interrupt entry points into Bios_Code	*
;*									*
;************************************************************************

HiMem	label	dword
	dw	90h
	dw	0ffffh

LoMem	label	dword
	dw	80h
	dw	0h

EnsureA20On	proc near
	assume	ds:nothing,es:nothing
	call	IsA20Off
	jz	ea_enable
	ret

EnableA20	proc	near	; M041
ea_enable:
	push	ax
	push	bx
	mov	ah,5		; localenablea20
	call	xms
	pop	bx
	pop	ax
bie_done:
	ret
EnableA20	endp		; M041

EnsureA20On	endp
;
; M001 - END

; M041 : BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : IsA20Off
;
;----------------------------------------------------------------------------
;
IsA20Off	proc	near
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, HiMem
		les	di, LoMem
		mov	cx, 8
		rep	cmpsw
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		ret
IsA20Off	endp

;
;----------------------------------------------------------------------------
;
; procedure : DisableA20
;
;----------------------------------------------------------------------------
;
DisableA20	proc	near
		push	ax
		push	bx
		mov	ah,6		; localdisable a20
		call	xms
		pop	bx
		pop	ax
		ret
DisableA20	endp

; M041 : END

;************************************************************************
;*									*
;*	int19 - bootstrap interrupt -- we must restore a bunch of the	*
;*	  interrupt vectors before resuming the original int19 code	*
;*									*
;************************************************************************


	public	int19
int19	proc	far
	assume	ds:nothing,es:nothing

	push	cs
	pop	ds
	assume	ds:Bios_Data

	mov	es,zeroseg

	mov	cx, NUMROMVECTORS	; no. of rom vectors to be restored
	mov	si, offset RomVectors	; point to list of saved vectors
next_int:
	lodsb				; get int number
	cbw				; assume < 128
	shl	ax, 1
	shl	ax, 1			; int * 4
	mov	di, ax
	lodsw
	stosw
	lodsw
	stosw				; install the saved vector
	loop	next_int

	cmp	byte ptr int19sem,0	; don't do the others unless we
	jz	doint19			; set our initialization complete flag

;	stacks code has changed these hardware interrupt vectors
;	stkinit in sysinit1 will initialize int19holdxx values.

	mov	si,offset i19_lst
	mov	cx,num_i19

i19_restore_loop:
	lodsb			; get interrupt number
	cbw			; assume < 128
	mov	di,ax		; save interrupt number
	lodsw			; get original vector offset
	mov	bx,ax		; save it
	lodsw			; get original vector segment
	cmp	bx,-1		; check for 0ffffh (unlikely segment)
	jz	i19_restor_1	;opt no need to check selector too
	cmp	ax,-1		;opt 0ffffh is unlikely offset
	jz	i19_restor_1

	add	di,di
	add	di,di
	xchg	ax,bx
	stosw
	xchg	ax,bx
	stosw			; put the vector back

i19_restor_1:
	loop	i19_restore_loop

doint19:
	int	19h
int19	endp
;
; M036 - BEGIN
;
;
;----------------------------------------------------------------------------
;
; procedure : int15
;
;		Int15 handler for recognizing ctrl-alt-del seq.
;
;----------------------------------------------------------------------------
;
DELKEY		equ	53h
	public	Int15
Int15	proc	far
	assume	ds:nothing
	cmp	ax, (4fh shl 8) + DELKEY	; del keystroke ?
	je	@f
	jmp	dword ptr Old15			
@@:
	stc
	jmp	dword ptr Old15
Int15	endp
;
;
;************************************************************************
;*									*
;*	the int2f handler chains up to Bios_Code through here.		*
;*	  it returns through one of the three functions that follow.	*
;*	  notice that we'll assume we're being entered from DOS, so	*
;*	  that we're guaranteed to be A20 enabled if needed		*
;*									*
;************************************************************************

int_2f	proc	far
	assume	ds:nothing,es:nothing
	jmp	bcode_i2f
int_2f	endp



;************************************************************************
;*									*
;*	re_init - called back by sysinit after a bunch of stuff		*
;*		is done.  presently does nothing.  affects no		*
;*		registers!						*
;*									*
;************************************************************************

	public	re_init
re_init proc	far
	assume	ds:nothing,es:nothing
	ret
re_init endp


;SR; WIN386 support
; WIN386 instance data structure
;
;
; Here is a Win386 startup info structure which we set up and to which
; we return a pointer when Win386 initializes.
;

public	Win386_SI, SI_Version, SI_Next

Win386_SI	label	byte		; Startup Info for Win386
SI_Version	db	3, 0		; for Win386 3.0
SI_Next		dd	?		; pointer to next info structure
		dd	0		; a field we don't need
		dd	0		; another field we don't need
SI_Instance	dw	Instance_Table, Bios_Data ; far pointer to instance table

;
; This table gives Win386 the instance data in the BIOS and ROM-BIOS data
; areas.  Note that the address and size of the hardware stacks must
; be calculated and inserted at boot time.
;
Instance_Table	label	dword
	dw	00H, 50H		; print screen status...
	dw	02			; ...2 bytes
	dw	0Eh, 50H		; ROM Basic data...
	dw	14H			; ...14H bytes
	dw	ALTAH, Bios_Data	; a con device buffer...
	dw	01			; ... 1 byte
IF STACKSW
public NextStack
NextStack	label dword

;	NOTE:  If stacks are disabled by STACKS=0,0, the following
;		instance items WILL NOT be filled in by SYSINIT.
;		That's just fine as long as these are the last items
;		in the instance list since the first item is initialized
;		to 0000 at load time.

	dw	0, 0		; pointer to next stack to be used...
	dw	02			; ...2 bytes
; The next item in the instance table must be filled in at sysinit time
public IT_StackLoc, IT_StackSize
IT_StackLoc	dd	?		; location of hardware stacks
IT_StackSize	dw	?		; size of hardware stacks
ENDIF
	dd	0			; terminate the instance table

;SR;
; Flag to indicate whether Win386 is running or not
;
public	IsWin386
IsWin386		db	0

;
;This routine was originally in BIOS_CODE but this causes a lot of problems
;when we call it including checking of A20. The code being only about
;30 bytes, we might as well put it in BIOS_DATA
;
PUBLIC	V86_Crit_SetFocus

V86_Crit_SetFocus	PROC	FAR

			push	di
			push	es
			push	bx
			push	ax

			xor	di,di
			mov	es,di
			mov	bx,0015h	;Device ID of DOSMGR device
			mov	ax,1684h	;Get API entry point
			int	2fh
			mov	ax,es
			or	ax,di		
			jz	Skip
;
;Here, es:di is address of API routine. Set up stack frame to simulate a call
;
			push	cs		;push return segment
			mov	ax,OFFSET Skip
			push	ax		;push return offset
			push	es
			push	di		;API far call address
			mov	ax,1		;SetFocus function number
			retf			;do the call
Skip:
			pop	ax
			pop	bx
			pop	es
			pop	di
			ret
V86_Crit_SetFocus	ENDP



;
;End WIN386 support
;

		public	FreeHMAPtr
		public	MoveDOSIntoHMA
FreeHMAPtr	dw	-1
MoveDOSIntoHMA	dd	sysinitseg:FTryToMovDOSHi


;SR;
; A communication block has been setup between the DOS and the BIOS. All
;the data starting from SysinitPresent will be part of the data block.
;Right now, this is the only data being communicated. It can be expanded
;later to add more stuff
;
		public	SysinitPresent
		public	DemInfoFlag
SysinitPresent	db	0
DemInfoFlag     db      0


; this will be the end of the BIOS data if no hard disks are in system

	public	endBIOSData
endBIOSData label byte

Bios_Data ends

;
;	okay.  so much for Bios_Data.  Now let's put our device driver
;	  entry stuff up into Bios_Code.

Bios_Code	segment
	assume	cs:Bios_Code

; ORG a bit past zero to leave room for running in HMA...

	org	30h
	public	BCode_start
BCode_start:

;	device driver entry point tables

	extrn	con_table:near
	extrn	tim_table:near
	extrn	prn_table:near
	extrn	aux_table:near

	extrn	i2f_handler:far

	public	Bios_Data_Word
Bios_Data_Word	dw	Bios_Data

;************************************************************************
;*									*
;*	seg_reinit is called with ax = our new code segment value,	*
;*	  trashes di, cx, es						*
;*									*
;*	cas -- should be made disposable!				*
;*									*
;************************************************************************

	public	seg_reinit
seg_reinit	proc	far
	assume	ds:nothing,es:nothing

	mov	es,Bios_Data_Word
	assume	es:Bios_Data
	mov	di,2+offset cdev
	mov	cx,((offset end_BC_entries) - (offset cdev))/4

seg_reinit_1:
	stosw				; modify Bios_Code entry points
	inc	di
	inc	di
	loop	seg_reinit_1
	ret
seg_reinit	endp

;************************************************************************
;*									*
;*	chardev_entry - main device driver dispatch routine		*
;*	   called with a dummy parameter block on the stack		*
;*	   dw dispatch_table, dw prn/aux numbers (optional)		*
;*									*
;*	will eventually take care of doing the transitions in		*
;*	   out of Bios_Code						*
;*									*
;************************************************************************

chardev_entry	proc	far
	assume	ds:nothing,es:nothing

	push	si
	push	ax
	push	cx
	push	dx
	push	di
	push	bp
	push	ds
	push	es
	push	bx
	mov	bp,sp			; point to stack frame
	mov	si,18[bp]		; get return address (dispatch table)
	mov	ds,Bios_Data_Word	;  load ds: -> Bios_Data
	assume	ds:Bios_Data
	mov	ax,word ptr 2[si]	; get the device number if present
	mov	byte ptr [auxnum],al
	mov	byte ptr [printdev],ah
	mov	si,word ptr [si]	; point to the device dispatch table

	les	bx,[ptrsav]		;get pointer to i/o packet

	mov	al,byte ptr es:[bx].unit	;al = unit code
	mov	ah,byte ptr es:[bx].media	;ah = media descrip
	mov	cx,word ptr es:[bx].count	;cx = count
	mov	dx,word ptr es:[bx].start	;dx = start sector

	xchg	di,ax
	mov	al,byte ptr es:[bx].cmd
	cmp	al,cs:[si]
	jae	command_error

	cbw				; note that al <= 15 means ok
	shl	ax,1

	add	si,ax
	xchg	ax,di

	les	di,dword ptr es:[bx].trans

	cld				; ***** always clear direction
	call	cs:word ptr [si+1] 	;go do command
	assume	ds:nothing

	jc	already_got_ah_status	; if function returned status, don't
	mov	ah,1			;  load with normal completion

already_got_ah_status:
	mov	ds,Bios_Data_Word	; cas///// note: shouldn't be needed!
	assume	ds:Bios_Data
	lds	bx,[ptrsav]
	assume	ds:nothing
	mov	word ptr [bx].status,ax ;mark operation complete

	pop	bx
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	dx
	pop	cx
	pop	ax
	pop	si
	add	sp,2		; get rid of fake return address

chardev_entry endp		; fall through into bc_retf

	public	bc_retf
bc_retf	proc	far
	assume	ds:nothing,es:nothing

	ret

bc_retf	endp


command_error:
	call	bc_cmderr
	jmp	short already_got_ah_status

;
;----------------------------------------------------------------------------
; The following piece of hack is for supporting CP/M compatibility
; Basically at offset 5 we have a far call into 0:c0. But this does not call
; 0:c0 directly instead it call f01d:fef0, because it needs to support 'lhld 6'
; The following hack has to reside at ffff:d0 (= f01d:fef0) if BIOS is loaded
; high.
;----------------------------------------------------------------------------


; BUGBUG sudeepb 21-May-1991 ; We can save these 30 bytes by moving
; off_d0 to right place.

	db	1fh dup (?)	; pad to bring offset to 0d0h

if2
	if ( offset off_d0 - 0d0h )
		%out CP/M compatibilty broken!!!
		%out Please re-pos hack to ffff:d0
	endif
endif

	public	off_d0
off_d0	db	5 dup (?)	; 5 bytes from 0:c0 will be copied onto here
				;  which is the CP/M call 5 entry point
	.errnz (offset off_d0 - 0d0h)


;----------------------------------------------------------
;
;	exit - all routines return through this path
;

	public	bc_cmderr
bc_cmderr:
	mov	al,3			;unknown command error

;	now zero the count field by subtracting its current value,
;	  which is still in cx, from itself.


;	subtract the number of i/o's NOT YET COMPLETED from total
;	  in order to return the number actually complete


	public	bc_err_cnt
bc_err_cnt:
	assume	ds:Bios_Data
	les	bx,[ptrsav]
	assume	es:nothing
	sub	es:word ptr [bx].count,cx;# of successful i/o's
	mov	ah,81h			;mark error return
	stc				; indicate abnormal end
	ret

Bios_Code	ends


;	the last real segment is sysinitseg

sysinitseg	segment
	assume	cs:sysinitseg
	extrn	FTryToMovDOSHi:far
	public	SI_start
SI_start:
sysinitseg	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\msend.asm ===
page	,160
;
;----------------------------------------------------------------------------
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------

;	Define end labels for each segment in
;	   IO.SYS.  Make the segments paragraph aligned
;	   to save the trouble of rounding up at run-time.
;
;	also defines a special segment called dos_load_seg which is
;	  used to figure out where to load MSDOS (after sysinit)

Bios_Data	segment	para public 'Bios_Data'
	assume	cs:Bios_Data
	public	BData_end
BData_end:
Bios_Data	ends

Bios_Code	segment para public 'Bios_Code'
	assume	cs:Bios_Code
	public	BCode_end
BCode_end:
Bios_Code       ends

sysinitseg      segment para public 'system_init'
	assume	cs:sysinitseg
sysinitseg     ends

SpcKbdSeg       segment para public 'SoftpcKeyboard'
        assume  cs:SpcKbdSeg
SpcKbdSeg      ends

SpcMseSeg       segment para public 'SoftpcMouse'
        assume  cs:SpcMseSeg
SpcMseSeg       ends

SpcEmmSeg       segment para public 'SoftpcEmm'
        assume  cs:SpcEmmSeg
        public  SI_end
SI_end:
SpcEmmSeg      ends


dos_load_seg    segment para public 'dos_load_seg'
dos_load_seg	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\msinit.asm ===
page	,160
	title	msinit for BIOS
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------
;

EXTENDEDKEY	equ	1	; use extended keyboard functions

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include	msequ.inc
	include dossym.inc
	include	dosmac.inc
	include biostruc.inc
        include dossvc.inc
        include vint.inc

;	the following segment follows sysinit.  It is used to define
;	the location to load MSDOS.SYS into.

dos_load_seg	segment	para public 'dos_load_seg'
dos_load_seg	ends

	extrn	RomVectors:dword
	extrn	NUMROMVECTORS:abs
	extrn	res_dev_list:word
	extrn	keyrd_func:byte 	; for mscon. defined in msdata.
	extrn	keysts_func:byte	; for mscon. defined in msdata.
	extrn	endBIOSData:byte

	extrn	dosdatasg:word

	extrn	Int15:far		; M036
	extrn	int19:far
	extrn	intret:near
	extrn	cbreak:near
	extrn	outchr:near
	extrn	outchr:near

sysinitseg segment 
	assume	cs:sysinitseg
	extrn	current_dos_location:word
	extrn	device_list:dword
	extrn	memory_size:word
	extrn	sysinit:far
sysinitseg ends

Bios_Data_Init segment
	assume	cs:datagrp

;*********************************************************
;	system initialization
;
;	the entry conditions are established by the bootstrap
;	loader and are considered unknown. the following jobs
;	will be performed by this module:
;
;	1.	all device initialization is performed
;
;	2.	a local stack is set up and ds:si are set
;		to point to an initialization table. then
;		an inter-segment call is made to the first
;		byte of the dos
;
;	3.	once the dos returns from this call the ds
;		register has been set up to point to the start
;		of free memory. the initialization will then
;		load the command program into this area
;		beginning at 100 hex and transfer control to
;		this program.
;
;********************************************************



;===========================================================================
;
; entry from boot sector.  the register contents are:
;
;   dl = int 13 drive number we booted from
;   ch = media byte
;   bx = first data sector on disk.
;   ax = first data sector (high)
;   di = sectors/fat for the boot media.
;
	public	init
init	proc	near
	assume	ds:nothing,es:nothing

        FCLI
	xor	ax,ax
	mov	ds,ax

; Save a pack of interrupt vectors...

	push	cs
	pop	es			; cannot use cs override for stos

	mov	cx, NUMROMVECTORS     	; no. of rom vectors to be saved
	mov	si, offset RomVectors	; point to list of int vectors
next_int:				
	lods	byte ptr cs:[si]	; get int number
	cbw				; assume < 128
	shl	ax, 1
	shl	ax, 1			; int no * 4
	mov	di, ax
	xchg	si, di
	lodsw
	stosw
	lodsw
	stosw				; save the vector
	xchg	si, di
	loop	next_int

; set up int 15 for new action				; M036

	mov	word ptr ds:[15h*4],offset Int15	; M036
	mov	ds:[15h*4+2],cs				; M036



; set up int 19 for new action

	mov	word ptr ds:[19h*4],offset int19
	mov	ds:[19h*4+2],cs

;
	xor	dx,dx
	mov	ss,dx
	mov	sp,700h 		;local stack
        FSTI
	assume	ss:nothing

       ; NTVDM we do not intialize the com,prn ports here
       ; to stay seamless with the host OS
       ; 15-Sep-1992 Jonle
       ;
       ; mov     al,3            ; init com4
       ; call    aux_init
       ; mov     al,2            ; init com3
       ; call    aux_init
       ; mov     al,1            ; init com2
       ; call    aux_init
       ; xor     al,al           ; init com1
       ; call    aux_init
       ;
       ; mov     al,2            ; init lpt3
       ; call    print_init
       ; mov     al,1            ; init lpt2
       ; call    print_init
       ; xor     al,al           ; init lpt1
       ; call    print_init

        xor     dx,dx
	mov	ds,dx		; to initialize print screen vector
	mov	es,dx

	xor	ax,ax
	mov	di,initspot
	stosw			; init four bytes to 0
	stosw

	mov	ax,cs		; fetch segment

	mov	ds:word ptr brkadr,offset cbreak ;break entry point
	mov	ds:brkadr+2,ax		;vector for break

	mov	ds:word ptr chrout*4,offset outchr
	mov	ds:word ptr chrout*4+2,ax

	mov	di,4
	mov	bx,offset intret	;will initialize rest of interrupts
	xchg	ax,bx
	stosw				;location 4
	xchg	ax,bx
	stosw				;int 1	;location 6
	add	di,4
	xchg	ax,bx
	stosw				;location 12
	xchg	ax,bx
	stosw				;int 3	;location 14
	xchg	ax,bx
	stosw				;location 16
	xchg	ax,bx
	stosw				;int 4	;location 18

	mov	ds:word ptr 500h,dx	;set print screen & break =0
	mov	ds:word ptr lstdrv,dx	;clean out last drive spec


	mov	dx,sysinitseg
	mov	ds,dx

	assume	ds:sysinitseg

; set pointer to resident device driver chain

	mov	word ptr device_list,offset res_dev_list
	mov	word ptr device_list+2,cs


        mov     current_dos_location,dos_load_seg ; will load MSDOS here



        push    cs
        pop     ds
        assume  ds:datagrp

	push	cs
	pop	es
        assume  es:datagrp


ifdef   EXTENDEDKEY

; we will check if the system has ibm extended keyboard by
; looking at a byte at 40:96.  if bit 4 is set, then extended key board
; is installed, and we are going to set keyrd_func to 10h, keysts_func to 11h
; for the extended keyboard function. use cx as the temporary register.

        mov     cl, ss:[0496h]                  ; get keyboard flag
	test	cl,00010000b
	jz	org_key				; orginal keyboard
	mov	byte ptr keyrd_func,10h		; extended keyboard
	mov	byte ptr keysts_func,11h	; change for ext. keyboard functions
org_key:

endif


        mov     di, offset endBIOSData  ; BIOS data segment end address
	shr	di,1
	shr	di,1
	shr	di,1
	shr	di,1			; Converted to segmnet
	inc	di			; para align

	add	di,datagrp		; Add segment of BIOS data
	mov	[dosdatasg],di		; di = to be dos data segment

	mov	di,dos_load_seg

	SVC	SVC_DEMLOADDOS		; di is segment to load DOS
					; If it fails it never comes back

	jmp	sysinit

init	endp


;--------------------------------------------------------------------

; al = device number

print_init proc	near
	assume	ds:nothing,es:nothing

	cbw
	mov	dx,ax			; get printer port number into dx
	mov	ah,1			;initalize printer port
	int	17h			;call rom-bios routine
	ret

print_init endp

;--------------------------------------------------------------------

aux_init proc	near
	assume	ds:nothing,es:nothing

	cbw
	mov	dx,ax
	mov	al,rsinit		;2400,n,1,8 (msequ.inc)
	mov	ah,0			;initalize aux port
	int	14h			;call rom-bios routine
	ret

aux_init endp

Bios_Data_Init	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\msequ.inc ===
ftoobig 	equ	80h
fbig		equ	40h
romstatus	equ	1
romread 	equ	2
romwrite	equ	3
romverify	equ	4
romformat	equ	5


rsinit	=	0a3h	;rs232 initialization
			;9600 baud:no parity:1 stop:8 bit word

lf	=	10	;line feed
cr	=	13	;carriage return
backsp	=	8	;backspace
brkadr	=	1bh * 4	;006c	1bh break vector address
timadr	=	1ch * 4	;0070	1ch timer interrupt
dskadr	=	1eh * 4	;address of ptr to disk parameters
sec9	=	522h	;address of disk parameters
headsettle=	sec9+9	;address of head settle time
normsettle=	15	;normal head settle
speedsettle=	0	;speed up settle time
initspot=	534h	;ibm wants 4 zeros here
akport	=	20h
eoi	=	20h

cmdlen	=	0	;length of this command
unit	=	1	;sub unit specifier
cmd	=	2	;command code
status	=	3	;status
media	=	13	;media descriptor
trans	=	14	;transfer address
count	=	18	;count of blocks or characters
start	=	20	;first block to transfer
extra	=	22	;usually a pointer to vol id for error 15
start_l =	26	; extended start sector (low)
start_h =	28	; extended start sector (high)


chrout	=	29h
maxerr	=	5
lstdrv	=	504h

bootbias	=	200h
notbusystatus	=	10000000b	; not busy
ackstatus	=	01000000b	; acknowledge (for what?)
nopaperstatus	=	00100000b	; no more paper
.selectedstatus	=	00010000b	; the printer said it was selected
ioerrstatus	=	00001000b	; some kinda error
reserved	=	00000110b	; nops
timeoutstatus	=	00000001b	; time out.
error_unknown_media = 7			; for use in build bpb call



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\msgroup.inc ===
tocode	macro
Bios_Data	ends
Bios_Code	segment
	assume	cs:Bios_Code
	endm

todata	macro
Bios_Code	ends
Bios_Data	segment
	assume	cs:Bios_Data
	endm

;align the segment on word boundary to allow for even alignment of data

Bios_Data	segment
	assume	cs:Bios_Data

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\msint13.asm ===
page	,160
	title	MS-DOS BIOS int 2f handler
; 
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

; THIS FILE SHOULD BE NAMED INT2f.ASM RATHER THAN INT13.ASM AS I HAVE RIPPED
; THE INT 13 SUPPORT. TO REDUCE CONFUSION WHEN PICKING FIXES FROM DOS 5.1
; THE NAME IS RETAINED AS IT IS.

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include	msequ.inc
	include	biostruc.inc

        include msgroup.inc     ; establish Bios_Data segment
        include vint.inc

multMULT		equ	4ah
multMULTGETHMAPTR	equ	1
multMULTALLOCHMA	equ	2


Win386_RelTS	equ	80h
NT_WAIT_BOP	equ	5Ah

bop MACRO callid
    db 0c4h,0c4h,callid
endm

;SR;
; Include file for WIN386 support
;
	include win386.inc


	extrn	SysinitPresent:byte
	extrn	FreeHMAPtr:word
	extrn	MoveDOSIntoHMA:dword

;SR; 
;New variables for Win386 support
;
	extrn	IsWin386:byte
	extrn	Win386_SI:byte
	extrn	SI_Next:dword


; close data, open Bios_code segment

	tocode

	extrn	Bios_Data_Word:word

; Int 2f functions to support communication of external block device
; drivers with msdisk are not supported. It also does'nt support
; function 13h which replaces the int 13 vector.
;

	public	i2f_handler
i2f_handler proc far
	assume	ds:nothing,es:nothing

	cmp	ah,13h
	jz	i2f_iret
	cmp	ah,8
	jz	i2f_iret

;
;Check for WIN386 startup and return the BIOS instance data
;
	cmp	ah,MULTWIN386
	jz	win386call

	cmp	ah, multMULT
	jne	i2f_iret
	jmp	handle_multmult

i2f_iret:
        FIRET


;WIN386 startup stuff is done here. If starting up we set our WIN386 present
;flag and return instance data. If exiting, we reset the WIN386 present flag
;NOTE: We assume that the BIOS int 2fh is at the bottom of the chain.

win386call:
	push	ds
	mov	ds,cs:Bios_Data_Word
	assume	ds:Bios_Data

	cmp	al, Win386_Init		; is it win386 initializing?
	je	Win386Init
	cmp	al, Win386_Exit		; is it win386 exiting?
	je	Win386Exit
	cmp	al, Win386_RelTS	; is it app release timeslice call?
	jne	win_iret		; if not, continue int2f chain

	push	ax			; It's the idling case - call MS BOP A
	xor	ax,ax			; with AX = 0
	bop	NT_WAIT_BOP
	pop	ax
	xor	al, al
	jmp	short win_iret

Win386Exit:
	test	dx, 1			; is it win386 or win286 dos extender?
	jnz	win_iret		; if not win386, then continue
	and	[IsWin386], 0		; indicate that win386 is not present
	jmp	short win_iret

Win386Init:
	test	dx, 1			; is it win386 or win286 dos extender?
	jnz	win_iret		; if not win386, then continue

	or	[IsWin386], 1		; Indicate WIN386 present
	mov	word ptr [SI_Next], bx	; Hook our structure into chain
	mov	word ptr [SI_Next + 2], es
	mov	bx, offset Win386_SI	; point ES:BX to Win386_SI
	push	ds
	pop	es

win_iret:
	pop	ds
	assume 	ds:nothing
        jmp     i2f_iret                ;return back up the chain

handle_multmult:
	cmp	al, multMULTGETHMAPTR
	jne	try_2

	push	ds
	call	HMAPtr			; get offset of free HMA
	mov	bx, 0ffffh
	mov	es, bx			; seg of HMA
	mov	bx, di
	not	bx
	or	bx, bx
	jz	@f
	inc	bx
@@:
	pop	ds
	jmp	i2f_iret
try_2:
	cmp	al, multMULTALLOCHMA
	jne	try_3

	push	ds
	mov	di, 0ffffh		; assume not enough space
	mov	es, di
	call	HMAPtr			; get offset of free HMA
	assume	ds:Bios_Data
	cmp	di, 0ffffh
	je	InsuffHMA		
	neg	di			; free space in HMA
	cmp	bx, di
	jbe	@f
	mov	di, 0ffffh
	jmp	short InsuffHMA
@@:
	mov	di, FreeHMAPtr
	add	bx, 15
	and	bx, 0fff0h
	add	FreeHMAPtr, bx		; update the free pointer
	jnz	InsuffHMA
	mov	FreeHMAPtr, 0ffffh	; no more HMA if we have wrapped
InsuffHMA:
	pop	ds
	assume	ds:nothing
	jmp	i2f_iret
try_3:
	jmp	i2f_iret
i2f_handler endp

;
;--------------------------------------------------------------------------
;
; procedure : HMAPtr
;
;		Gets the offset of the free HMA area ( with respect to
;							seg ffff )
;		If DOS has not moved high, tries to move DOS high.
;		In the course of doing this, it will allocate all the HMA
;		and set the FreeHMAPtr to past the end of the BIOS and 
;		DOS code.  The call to MoveDOSIntoHMA (which is a pointer)
;		enters the routine in sysinit1 called FTryToMoveDOSHi.
;
;	RETURNS : offset of free HMA in DI
;		  BIOS_DATA, seg in DS
;
;--------------------------------------------------------------------------
;
HMAPtr	proc	near
	mov	ds, Bios_Data_Word
	assume	ds:Bios_Data
	mov	di, FreeHMAPtr
	cmp	di, 0ffffh
	jne	@f
	cmp	SysinitPresent, 0
	je	@f
	call	MoveDOSIntoHMA
	mov	di, FreeHMAPtr
@@:
	ret
HMAPtr	endp


Bios_Code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\readdos.asm ===
PAGE    109,132
        TITLE   MS-DOS 5.0 READDOS.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE NAME: READDOS.ASM                                *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;****************************************************************
;*                                                              *
;*      LOAD MSDOS.SYS                                          *
;*                                                              *
;****************************************************************
;HISTORY
; 1987/10 (DOS3.1) CREATE THIS MODULE.
; 1988/ 5 (DOS3.3) BIGFAT SUPPORT
;                  LIM4.0 SUPPORT (HiRESO ONLY)
; 1990/ 3 MSDOS 3.3C EMM.SYS,EMM386.SYS SUPPORT
;                  MSDOS3.3B PATCH 

;93/03/25 MVDM DOS5.0A----------- NEC NT PROT -------
include dossvc.inc
;----------------------------------------------------

DEBUG = 0       ;CUT DEBUG ROUTINE

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Data       segment word public 'Bios_Data'
                ASSUME  CS:DATAGRP,DS:DATAGRP

        EXTRN   SYS_501:BYTE                    ;BIO2
        EXTRN   DSK_BUF2:NEAR                   ;BIO2
        EXTRN   STRATEGY:FAR,DSK_INT:FAR        ;BIO2

;----------------------------------------------- DOS5 91/01/11 -------
        EXTRN   REQUEST:NEAR, REQ_LEN:BYTE, REQ_UNT:BYTE
        EXTRN   REQ_CMD:BYTE, REQ_STS:WORD, REQ_MDA:BYTE
        EXTRN   REQ_TRNS:WORD, REQ_CNT:WORD, REQ_STRT:WORD
        EXTRN   RD_UNIT:BYTE, MDA_DSC:BYTE, FATSEC:WORD
        EXTRN   DIRSEC:WORD, DATASEC:WORD, FATLEN:WORD
        EXTRN   FATLOC:WORD, FAT1ST:WORD, BPBPTR:WORD
        EXTRN   DOSCNT:WORD, DOSLOC:WORD, RD_FBIGFAT:BYTE
        EXTRN   DIRLEN:WORD, FAT1CONF:WORD, CONFSIZE:WORD
        EXTRN   SW_RCONF:BYTE
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 91/05/30 -------
        EXTRN   REQ_STRTL:WORD, REQ_STRTH:WORD, MAXSEC:WORD
;---------------------------------------------------------------------

Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   MSGLOOP_FAR:FAR                 ;REINIT

Bios_Code       ends

SysInitSeg      segment word public 'system_init'
                ASSUME  CS:SYSINITSEG,DS:SYSINITSEG

;-------------------------------------------------------------- 880520
        EXTRN   MEMORY_SIZE:WORD                ;SYSINIT
        EXTRN   SYSINIT:FAR                     ;(SEGMENT)
;---------------------------------------------------------------------
SysInitSeg      ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
                ASSUME  CS:datagrp,DS:datagrp

        PUBLIC  READDOS

IF DEBUG 
;
;       MACROS
;
DEB     MACRO   ADR
        PUSH    AX
        PUSH    BX
        MOV     BX,OFFSET DATAGRP:ADR
        CALL    display_string
        POP     BX
        POP     AX
        ENDM

movnumw macro   p1,p2
        PUSH    AX
        mov     ax,p1
        call    bin2hex
        mov     cs:p2[2],ax
        mov     ax,p1
        mov     al,ah
        call    bin2hex
        mov     cs:p2[0],ax
        POP     AX
        endm

movnumb macro   p1,p2
        mov     al,p1
        call    bin2hex
        mov     cs:p2[0],ax
        endm
ENDIF

        PAGE

;
;       EQUATES
;
INIT    =       0                       ;COMMAND (INIT)
MCHK    =       1                       ;COMMAND (MEDIA CHECK)
GBPB    =       2                       ;COMMAND (BUILD BPB)
READ    =       4                       ;COMMAND (READ)
;BIOSSIZ        =       0C00H                   ;IO.SYS PARAGRAPH SIZE (48KB)
;-------------------------------------------------------------- 880520
MM768K  =       0C000H                  ;768KB
MM64K   =       01000H                  ;64KB
;---------------------------------------------------------------------

IF DEBUG
;********* DEBUG FLAG AREA BIT INFO. ***************
;       DEBUG FLAG AREA = 0000:0634 (BYTE)
DEB_INT1B =     00000001B               ;DISPLAY INT1B PARA
DEB_CLSTR =     00000010B               ;DISPLAY CLUSTER NO.
;***************************************************
ENDIF

;
;       BPB STRUCTURE
;
PARABLK STRUC
BYTEPSEC        DW      ?               ;BYTES/SECTOR
SECTPCLS        DB      ?               ;SECTORS/CLUSTER
RESSEC          DW      ?               ;RESERVED SECTOR
NUM_OF_FATS     DB      ?               ;NUMBER OF FATS
ROOT_DIR        DW      ?               ;NUMBER OF ROOT DIR ENTRIES
VOL_SIZE        DW      ?               ;VOLUME SIZE
MEDIA           DB      ?               ;MEDIA DESCRIPTOR
SEC_PER_FAT     DW      ?               ;SECTORS/FAT
PARABLK ENDS

;
;       DIRECTORY STRUCTURE
;
DIRSTR  STRUC
D_NAME          DB      11 DUP(?)       ;FILE NAME & EXT
D_ATTR          DB      ?               ;ATTRIBUTE
D_RFU           DB      10 DUP(?)       ;RESERVE
D_TIME          DW      ?               ;TIME
D_DATE          DW      ?               ;DATE
D_CLUS          DW      ?               ;START CLUSTER
D_SIZE          DD      ?               ;FILE SIZE
DIRSTR  ENDS

;----------------------------------------------- DOS5 91/01/11 -------
;
;       REQUEST PACKET
;
;REQUEST        LABEL   BYTE
;REQ_LEN                DB      ?               ;LENGTH OF REQUEST
;REQ_UNT                DB      ?               ;UNIT NUMBER
;REQ_CMD                DB      ?               ;COMMAND CODE
;REQ_STS                DW      ?               ;STATUS
;REQ_RFU                DB      8 DUP(?)        ;RESERVE
;
;REQ_MDA                DB      ?               ;MEDIA DESCRIPTOR
;REQ_TRNS       DD      ?               ;TRANSFER ADDRESS
;REQ_CNT                DW      ?               ;COUNT OF BLOCK
;REQ_STRT       DW      ?               ;1ST BLOCK FOR TRANSFER
;
;
;       VARIABLES
;
;UNIT           DB      0               ;UNIT NUMBER
;MDA_DSC                DB      0               ;MEDIA DESCRIPTOR SAVE
;FATSEC         DW      0               ;FAT SECTOR
;DIRSEC         DW      0               ;DIRECTORY SECTOR
;DATASEC                DW      0               ;TOP OF DATA AREA
;FATLEN         DW      0               ;FAT LENGTH (# OF SECTOR)
;FATLOC         DW      0               ;PARAGRAPH OF FAT-BUFFER
;FAT1ST         DW      0               ;1ST FAT NO.
;BPBPTR         DW      0               ;BPB POINTER
;DOSCNT         DW      0               ;READ SECTOR COUNT
;DOSLOC         DW      0               ;PARAGRAPH OF MSDOS SEG
;--------------------------------------------------------- 88/04/07 --
;FBIGFAT                DB      0               ;12Bit FAT:0, 16Bit FAT:FFH
;-------------------------------------------------------------- 880520
;DIRLEN         DW      0               ;SECTOR SIZE OF DIRECTORY
;FAT1CONF       DW      0               ;1ST FAT OF 'CONFIG.SYS'
;CONFSIZE       DW      0               ;SIZE 'CONFIG.SYS' (LOW WORD)
;---------------------------------------------------------------------
FILESCONF       DB      'CONFIG  SYS'   ;FILE NAME
FILESEMS        DB      'EMSDRIVE.SYS'  ;FILE NAME FOR LIM4.0 DRIVER
FILESEMM        DB      'EMM.SYS'       ;FILE NAME FOR LIM4.0 DRIVER
FILESEMM386     DB      'EMM386.SYS'    ;FILE NAME FOR LIM4.0 DRIVER
FILESEMM386EXE  DB      'EMM386.EXE'    ;FILE NAME FOR LIM4.0 DRIVER
;----------------------------------------------- DOS5 91/01/11 -------
;SW_RCONF       DB      0               ;0 :CONFIG.SYS NOT READ
;                                       ;-1:CONFIG.SYS READ & CHECK LIM
;---------------------------------------------------------------------
FILESPEC        DB      'MSDOS   SYS'   ;FILE NAME
;---------------------------------------------------------------------

IF DEBUG

DEB_FLG         DB      0               ;DEBUG FLAG SAVE
;
;       MESSAGES
;
INIT_M          DB      '---- DISK INITIALIZE ----',13,10,'$'
MCHK_M          DB      '---- MEDIA CHECK --------',13,10,'$'
FAT1_M          DB      '---- FAT READ (1ST) -----',13,10,'$'
GBPB_M          DB      '---- BUILD BPB ----------',13,10,'$'
DIRR_M          DB      '---- DIRECTORY READ -----',13,10,'$'
FATR_M          DB      '---- FAT READ (ALL) -----',13,10,'$'
DOSR1_M         DB      '---- MSDOS.SYS LOAD -----',13,10,'$'
FND_DOS         DB      '*** MSDOS.SYS FOUND ! ***',13,10,'$'
DOSR_DON        DB      '\\\\\ READ DOS END \\\\\',13,10,'$'

ENDIF

MSG_IOER        DB      13,10,07,'MSDOS.SYS ǂݍݎɃG[܂',0
MSG_NOSYS       DB      13,10,07,'MSDOS.SYS ܂',0

IF DEBUG

STSDSP          DB      'STATUS : '
A_STS           label   word
                db      'xxxx',13,10,'$'

PARDSP          DB      'FATSEC : '
A_FAT           LABEL   WORD
                DB      'xxxx  DIRSEC : '
A_DIR           LABEL   WORD
                DB      'xxxx  BPB ADR : '
A_BPB           LABEL   WORD
                DB      'xxxx  MDA : '
A_MDA           LABEL   WORD
                DB      'xx  FATLEN : '
A_LEN           LABEL   WORD
                DB      'xxxx  DATASEC : '
A_DAT           LABEL   WORD
                DB      'xxxx  FATLOC : '
A_LOC           LABEL   WORD
                DB      'xxxx',13,10,'$'

DSPDOS          DB      '1ST DOS FAT : '
A_DOS           LABEL   WORD
                DB      'xxxx  DOS LOCATION : '
A_DLC           LABEL   WORD
                DB      'xxxx',13,10,'$'

NEW_FAT         LABEL   WORD
DSPCLS_M        DB      'xxxx ','$'

DSPBUF_M        DB      13,10,'[LOAD ADDRESS] = '
RD_SEG          LABEL   WORD
                DB      'xxxx:'
RD_OFS          LABEL   WORD
                DB      'xxxx  / [START SECTOR]= '
RD_STRT         LABEL   WORD
                DB      'xxxx  / [COUNT] = '
RD_CNT          LABEL   WORD
                DB      'xxxx',13,10,'$'

ENDIF

        PAGE
;************************************************
;*                                              *
;*      READ MSDOS.SYS                          *
;*                                              *
;*      INPUT:  (BL) CURRENT DRIVER NO.         *
;*              (DS) LOAD LOCATION              *
;*                                              *
;*      OUTPUT: NONE                            *
;*                                              *
;************************************************

READDOS:

        PUSH    DI              ;NEC NT PROT
        PUSH    DS              ;NEC NT PROT
        POP     DI              ;NEC NT PROT
        SVC     SVC_DEMLOADDOS  ;NEC NT PROT
        POP     DI              ;NEC NT PROT

        RET                     ;NEC NT PROT

ERROR_J:
        JMP     SHORT ERROR

        PUSH    ES
        PUSH    DS                      ;SAVE DS (MSDOS SEG)
        PUSH    BX                      ;SAVE BX (CURR. DRIVE)
        MOV     CS:[DOSLOC],DS          ;SET DOS PARAGRAPH
        MOV     CS:[RD_UNIT],BL         ;SET UNIT NUMBER
;-------------------------------------------------------------- 880520
        TEST    CS:[SYS_501],08H        ;HW MODE = HiRESO ?
        JZ      RDOS00                  ;NO, NORMAL MODE
     ASSUME DS:SYSINITSEG
        MOV     BX,SEG SYSINIT
        MOV     DS,BX                   ;DS := SYSINIT SEG
        CMP     [MEMORY_SIZE],MM768K
        JNE     RDOS00                  ;IF DOS CONVENTIONAL MEMORY = 768KB
        MOV     CS:[SW_RCONF],-1                ;THEN READ 'CONFIG.SYS'
     ASSUME DS:DATAGRP
RDOS00:
;---------------------------------------------------------------------
        PUSH    CS
        POP     DS                      ;DS := OUR SEGMENT
     IF DEBUG
        CALL    start0          ;**DEB
        DEB     INIT_M          ;**DEB
     ENDIF
        CALL    DSKINIT                 ;INITIALIZE DISK DRIVER
     IF DEBUG
        CALL    DSPSTS          ;**DEB
        DEB     MCHK_M          ;**DEB
     ENDIF
        CALL    MEDIACHK                ;CHECK MEDIA
     IF DEBUG
        CALL    DSPSTS          ;**DEB
     ENDIF
        JNZ     ERROR_J                 ;ERROR
     IF DEBUG
        DEB     FAT1_M          ;**DEB
     ENDIF
        CALL    PREFAT                  ;FAT(1ST) PRE-READ
     IF DEBUG
        CALL    DSPSTS          ;**DEB
     ENDIF
        JNZ     ERROR_J                 ;ERROR
     IF DEBUG
        DEB     GBPB_M          ;*DEB
     ENDIF
        CALL    GETBPB                  ;BUILD BPB
     IF DEBUG 
        CALL    DSPSTS          ;**DEB
     ENDIF
        JNZ     ERROR                   ;ERROR
     IF DEBUG
        DEB     DIRR_M          ;*:DEB
     ENDIF
        CALL    SET_PARA                ;SET PARAMETER
     IF DEBUG
        CALL    PARADSP         ;**DEB
     ENDIF
        CALL    READDIR                 ;READ DIRECTORY
     IF DEBUG
        CALL    DSPSTS          ;**DEB
     ENDIF
        JNZ     ERROR                   ;ERROR
     IF DEBUG
        DEB     FATR_M          ;**DEB
     ENDIF
        CALL    READFAT                 ;READ FILE ALLOCATION TABLE
     IF DEBUG
        CALL    DSPSTS          ;**DEB
     ENDIF
        JNZ     ERROR                   ;ERROR
;-------------------------------------------------------------- 880520
        MOV     ES,[DOSLOC]             ;BUFFER PARAGRAPH
        CMP     [SW_RCONF],0            ;CONFIG READ ?
        JE      RDOS100                 ;NO,
        MOV     BX,[FAT1CONF]           ;1ST FAT OF CONFIG.SYS
        OR      BX,BX                   ;CONFIG EXIST ?
        JZ      RDOS100                 ;NO, SKIP READ PROC
        CALL    READFIL                 ;READ 'CONFIG.SYS'
        CALL    CHKCONF                 ;CHECK LIM4.0 DRIVER
        JC      RDOS100                 ;NOT FOUND
        PUSH    DS
     ASSUME DS:SYSINITSEG
        MOV     BX,SEG SYSINIT
        MOV     DS,BX                   ;IF LIM4.0 DRIVER EXIST
        SUB     [MEMORY_SIZE],MM64K     ;THEN MM MINUS 64KB
     ASSUME DS:DATAGRP                  ;FOR PAGE FRAME
        POP     DS
RDOS100:
        MOV     BX,[FAT1ST]             ;1ST CLUSTER
        CALL    READFIL                 ;LOAD MSDOS.SYS
;---------------------------------------------------------------------
     IF DEBUG
        DEB     DOSR_DON        ;**DEB
        CALL    END0            ;**DEB
     ENDIF
        POP     BX
        POP     DS
        POP     ES
        RET                             ;END OF MSDOS.SYS LOAD



ERROR:
        MOV     BX,OFFSET DATAGRP:MSG_IOER      ;I/O ERROR MESSAGE
        JMP     SHORT MSG
NOSYS:
        MOV     BX,OFFSET DATAGRP:MSG_NOSYS     ;NO SYSTEM MESSAGE
MSG:    CALL    MSGLOOP_FAR
HLTLOOP:
        JMP     HLTLOOP                 ;FAULT

;-------------------------------------------------------------- 880520
;-                                      -
;-      FILE READ SUBROUTINE            -
;-                                      -
;-      IN:  (BX) 1ST FAT               -
;-      OUT: NONE                       -
;----------------------------------------
READFIL:
        XOR     CX,CX
        MOV     DI,[BPBPTR]             ;BPB ADDR.
        MOV     CL,[DI.SECTPCLS]        ;CX := SECTOR/CLUSTER
        MOV     ES,[DOSLOC]
        XOR     DI,DI                   ;ES:DI := LOAD LOCATION
     IF DEBUG
        DEB     DOSR1_M         ;**DEB
        CALL    DSPDOSLOC       ;**DEB
     ENDIF
READFIL_LOOP:
        CALL    GETCLUS                 ;
        CALL    ISEOF
        JB      READFIL_LOOP            ;NO,
        RET
;----------------------------------------
;-                                      -
;-      SEARCH LIM4.0 DRIVER            -
;-                                      -
;-      IN:  NONE                       -
;-      OUT: [CF] =0 EMSDRIVE FOUND     -
;-                 1 NOT FOUND          -
;-                                      -
;----------------------------------------
CHKCONF:
        XOR     DI,DI                   ;BUFFER TOP
        MOV     CX,[CONFSIZE]           ;GET SIZE OF CONFIG.SYS
        PUSH    CX                      ;SAVE IT
CCONF0: MOV     AL,ES:[DI]              ;GET CHAR
        CMP     AL,'a'                  ;CHAR CONVERT TO UPPERCASE
        JB      CCONF01
        CMP     AL,'z'
        JA      CCONF01
        AND     AL,NOT 'a'-'A'
CCONF01:
        STOSB                           ;STORE & POINTER INCREMENT
        LOOP    CCONF0
        XOR     DI,DI
        POP     CX                      ;RESUME FILE SIZE
CCONF1: MOV     AL,'E'                  ;1ST CHAR OF LIM4.0 DRIVER-NAME
        REPNZ   SCASB                   ;SEARCH 'E'
        JCXZ    CCONF_ER                ;NOT FOUND
;------------------------------------------------ MSDOS 3.3B PATCH ----
;       MOV     SI,OFFSET FILESEMS      ;FULL NAME 'EMSDRIVE.SYS'
;       DEC     DI                      ;POINT 'E'
;       PUSH    CX
;       MOV     CX,12                   ;LENGTH OF FILE NAME
;       REPZ    CMPSB
;       POP     CX
;       JNZ     CCONF1                  ;NOT EQUAL, TO NEXT
;       RET                             ;FOUND

        DEC     DI                      ;90/03/16
        PUSH    CX
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        db      90h
;---------------
;       PUSH    DI
;---------------------------------------------------------------------
        MOV     SI, OFFSET DATAGRP:FILESEMS     ;'EMSDRIVE.SYS' CHECK
        MOV     CX,000CH
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        extrn   patch03:near
        public  filesemm386exe
        call    patch03
;---------------
;       REPZ CMPSB
;       POP     DI
;---------------------------------------------------------------------
        JZ      CCONF050
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        db      90h
;---------------
;       PUSH    DI
;---------------------------------------------------------------------
        MOV     SI,OFFSET DATAGRP:FILESEMM      ;'EMM.SYS' CHECK
        MOV     CX,0007H
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        call    patch03
;---------------
;       REPZ CMPSB
;       POP     DI
;---------------------------------------------------------------------
        JZ      CCONF050
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        db      90h
;---------------
;       PUSH    DI
;---------------------------------------------------------------------
        MOV     SI,OFFSET DATAGRP:FILESEMM386   ;'EMM386.SYS' CHECK
        MOV     CX,000AH
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        call    patch03
;---------------
;       REPZ CMPSB
;       POP     DI
;---------------------------------------------------------------------
        JZ      CCONF050
;------------------------------------------------DOS5 91/06/12-----------
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        db      90h
;---------------
;       PUSH    DI
;---------------------------------------------------------------------
        MOV     SI,OFFSET DATAGRP:FILESEMM386EXE;'EMM386.EXE' CHECK
        MOV     CX,000AH
;----------------------------------------------- DOS5 92/02/04 -------
;<patch BIOS50-P08>
        call    patch03
;---------------
;       REPZ CMPSB
;       POP     DI
;---------------------------------------------------------------------
        JZ      CCONF050
;------------------------------------------------------------------------
        POP     CX
        INC     DI
        JMP     CCONF1
CCONF050:
        POP     CX
        RET
;----------------------------------------------------------------------
CCONF_ER:
        STC                             ;SET ERROR CODE
        RET
;---------------------------------------------------------------------

IF DEBUG
;*****************************DEB****************
DSPSTS:
        PUSHF
        PUSH    BX
        MOV     BX,AX
        movnumw BX,A_STS
        mov     bx,offset DATAGRP:STSDSP
        call    display_string
        POP     BX
        POPF
        RET

PARADSP:
        PUSH    BX
        MOV     BX,[FATSEC]
        movnumw BX,A_FAT
        MOV     BX,[DIRSEC]
        movnumw BX,A_DIR
        MOV     BX,[BPBPTR]
        movnumw BX,A_BPB
        MOV     AL,[MDA_DSC]
        movnumb AL,A_MDA
        MOV     BX,[FATLEN]
        movnumw BX,A_LEN
        MOV     BX,[DATASEC]
        movnumw BX,A_DAT
        MOV     BX,[FATLOC]
        movnumw BX,A_LOC
        MOV     BX,OFFSET DATAGRP:PARDSP
        CALL    display_string
        POP     BX
        RET

DSPDOSLOC:
        PUSH    BX
        MOV     BX,[FAT1ST]
        movnumw BX,A_DOS
        MOV     BX,[DOSLOC]
        movnumw BX,A_DLC
        MOV     BX,OFFSET DATAGRP:DSPDOS
        CALL    display_string
        POP     BX
        RET
;******************************DEB******************
ENDIF 

        PAGE
;****************************************
;*                                      *
;*      INITIALIZE THE DISK DRIVER      *
;*                                      *
;****************************************
DSKINIT:
        CALL    STRATP
        MOV     [REQ_LEN],23            ;SET REQ LENGTH
        MOV     [REQ_CMD],INIT          ;COMMAND (INIT)
        CALL    DSK_INT                 ;CALL(FAR) INIT FUNC.
        RET

;****************************************
;*                                      *
;*      MEDIA CHECK                     *
;*                                      *
;****************************************
MEDIACHK:
        CALL    STRATP
        MOV     AL,[RD_UNIT]
        MOV     [REQ_UNT],AL            ;SET UNIT
        MOV     [REQ_CMD],MCHK          ;COMMAND (MEDIA-CHECK)
        MOV     [REQ_LEN],19            ;SET REQ LENGTH
        CALL    CALDISK                 ;CALL(FAR) MEDIA_CHK
        RET

;****************************************
;*                                      *
;*      BUILD BPB                       *
;*                                      *
;****************************************
GETBPB:
        CALL    STRATP
        MOV     AL,[RD_UNIT]
        MOV     [REQ_UNT],AL            ;SET UNIT
        MOV     [REQ_CMD],GBPB          ;COMMAND (BUILD BPB)
        MOV     [REQ_LEN],22            ;SET REQ LENGTH
        MOV     WORD PTR [REQ_TRNS],OFFSET DATAGRP:DSK_BUF2
        MOV     WORD PTR [REQ_TRNS+2],CS
        CALL    CALDISK                 ;CALL(FAR) BUILD BPB
        MOV     BX,WORD PTR [REQ_CNT]   ;GET BPB OFFSET (SEGMENT = 0060)
        MOV     [BPBPTR],BX             ;SAVE IT
        RET

;****************************************
;*                                      *
;*      SET PARAMETERS                  *
;*                                      *
;****************************************
SET_PARA:
        MOV     BX,[BPBPTR]             ;GET BPB POINTER

        MOV     AL,[BX.MEDIA]           ;GET MEDIA DESCRIPTOR
        MOV     [MDA_DSC],AL            ;SAVE IT.

        MOV     AX,[BX.RESSEC]
        MOV     [FATSEC],AX             ;SET FAT SECTOR NUMBER

        PUSH    AX
        XOR     CX,CX
        MOV     AX,[BX.SEC_PER_FAT]
        MOV     CL,[BX.NUM_OF_FATS]
        MOV     [FATLEN],AX             ;SET SECTORS/FAT
;------------------------------------------------DOS5 91/02/15-----------
        MUL     CX
;------------------
;       MUL     CL
;------------------------------------------------------------------------
        POP     CX
        ADD     AX,[FATSEC]             ;DIRSEC = FATSEC + FATLEN
        MOV     [DIRSEC],AX             ;SET DIRECTORY SECTOR NUMBER

        MOV     AX,[BX.ROOT_DIR]
        MOV     CX,32
        MUL     CX                      ;DX:AX = DIRECTORY SIZE (IN BYTE)
        MOV     CX,[BX.BYTEPSEC]
        DIV     CX                      ;AX = SECTORS/DIRECTORY
;-------------------------------------------------------------- 880520
        MOV     [DIRLEN],AX             ;SAVE (SECTORS/DIRECTORY)
;---------------------------------------------------------------------
        ADD     AX,[DIRSEC]
        MOV     [DATASEC],AX            ;SET FIRST DATA SECTOR

        MOV     AL,[SYS_501]
        AND     AX,000FH                ;MEMORY SIZE
        INC     AX
        MOV     CX,13                   ;SHIFT COUNT
        SHL     AX,CL                   ;MM SIZE (PARAGRAPH)
        PUSH    AX
        MOV     AX,[FATLEN]
        MOV     CX,[BX.BYTEPSEC]
        MUL     CX                      ;FAT SIZE(IN BYTE)
;--------------------------------------------------------- 90/05/26 --
;       MOV     CL,4                    ;        (PARAGRAPH)
;       SHR     AX,CL

        MOV     CX,10H
        DIV     CX
;---------------------------------------------------------------------
        MOV     CX,AX
        POP     AX
        SUB     AX,CX                   ;FATLOC = MM SIZE / FAT SIZE
        MOV     [FATLOC],AX             ;SET FAT-BUFFER LOCATION
        RET

;****************************************
;*                                      *
;*      READ DIRECTORY                  *
;*                                      *
;*      OUTPUT: (ZF) 1 NORMAL           *
;*                   0 ERROR            *
;*              [FAT1ST] = 1ST FAT NO.  *
;*                                      *
;****************************************
;---------------------------------------------- ALL NEW ------- 880520
READDIR:
        PUSH    CS
        POP     ES                      ;OUR SEGMENT
        MOV     DX,[DIRSEC]             ;SET START SECTOR
RDIR00: 
        MOV     DI,OFFSET DATAGRP:DSK_BUF2      ;ES:DI := LOAD LOCATION
        MOV     CX,1                    ;READ ONLY 1 SECTOR
;----------------------------------------------- DOS5 91/05/30 -------
        MOV     AX,0                    ;HIGH WORD OF START SECTOR
;---------------------------------------------------------------------
        CALL    DSK_READ
        JNZ     RDIR_DONE               ;ERROR
        MOV     DI,OFFSET DATAGRP:DSK_BUF2
RDIR10:
        PUSH    DI                      ;SAVE DIR ADDR
        MOV     SI,OFFSET DATAGRP:FILESPEC
        MOV     CX,11                   ;FILE NAME LENGTH
        CLD
        REPE    CMPSB                   ;CHECK FILESPEC
        POP     DI
        JNZ     RDIR20                  ;DIR IS NOT 'MSDOS.SYS'
        MOV     AX,[DI.D_CLUS]          ;FOUND, GET FIRST FAT NO.
        MOV     [FAT1ST],AX             ;SAVE IT.
     IF DEBUG
        DEB     FND_DOS         ;**DEB
     ENDIF
        CMP     [FAT1CONF],0            ;CONFIG.SYS FOUND ?
        JNE     RDIR40                  ;YES, RETURN
RDIR20:
        CMP     [SW_RCONF],0            ;READ CONFIG ?
        JE      RDIR30                  ;NO,
        PUSH    DI
        MOV     SI,OFFSET DATAGRP:FILESCONF
        MOV     CX,11                   ;FILE NAME LENGTH
        REPE    CMPSB                   ;CHECK FOR 'CONFIG.SYS'
        POP     DI
        JNZ     RDIR30                  ;NOT CONFIG
        MOV     AX,[DI.D_CLUS]          ;FOUND, GET 1ST FAT NO.
        MOV     [FAT1CONF],AX           ;SAVE IT.
        MOV     AX,WORD PTR [DI.D_SIZE] ;GET FILE SIZE (LOW WORD)
        MOV     [CONFSIZE],AX           ;SAVE IT.
        CMP     [FAT1ST],0              ;MSDOS.SYS FOUND ?
        JNE     RDIR40                  ;YES, RETURN
RDIR30:
        ADD     DI,32                   ;NEXT DIR ENTRY
;-----------------------------------------------------  89/07/28  ---
        PUSH    BX
        MOV     BX,[BPBPTR]
        MOV     BX,[BX]
        ADD     BX,OFFSET DATAGRP:DSK_BUF2
        CMP     DI,BX
        POP     BX
;-----------------------------------------------------  89/07/28  ---
        JB      RDIR10                  ;NO,  SEARCH NEXT
        INC     DX                      ;SECTOR 1UP
        DEC     [DIRLEN]                ;LAST SECTOR ?
        JNZ     RDIR00                  ;NO,  READ NEXT SECTOR
        CMP     [FAT1ST],0              ;MSDOS.SYS EXIST ?
        JE      READDIR_NOSYS           ;NO, PRINT ERROR MESSAGE & FAULT
RDIR40:
        XOR     AX,AX                   ;EXIST, SET (ZF)
RDIR_DONE:
        RET

READDIR_NOSYS:
        POP     AX
        JMP     NOSYS                   ;ERROR ROUTINE
;---------------------------------------------------------------------

;****************************************
;*                                      *
;*      FAT PRE-READ                    *
;*                                      *
;****************************************
PREFAT:
        PUSH    CS
        POP     ES
        MOV     DI,OFFSET DATAGRP:DSK_BUF2      ;ES:DI := LOAD LOCATION
        MOV     CX,1                    ;SET COUNT
        MOV     DX,1                    ;SET START SECTOR NO.
;----------------------------------------------- DOS5 91/05/30 -------
        MOV     AX,0                    ;HIGH WORD OF START SECTOR
;---------------------------------------------------------------------
        CALL    DSK_READ
        RET

;****************************************
;*                                      *
;*      READ ENTIRE FAT                 *
;*                                      *
;****************************************
READFAT:
;----------------------------------------------- DOS5 91/05/30 -------
        MOV     DX,1
        XOR     AX,AX
        MOV     DI,[BPBPTR]
        MOV     CX,WORD PTR [DI.BYTEPSEC]
        DIV     CX                      ;64Kb / BYTES PER SECTOR
        MOV     [MAXSEC],AX             ;SECTOR COUNT WITHIN 64Kb
;---------------------------------------------------------------------
        MOV     ES,[FATLOC]
        XOR     DI,DI                   ;ES:DI := LOAD LOCATION
RF_64K:                                                 ;DOS5 91/05/30
        MOV     CX,[FATLEN]             ;SET COUNT
;----------------------------------------------- DOS5 91/05/30 -------
        CMP     CX,[MAXSEC]             ;IF FATLEN > MAXSEC THEN
        JBE     RF_10                   ; COUNT=MAXSEC
        MOV     CX,[MAXSEC]             ;ELSE
RF_10:                                  ; COUNT=FATLEN
;---------------------------------------------------------------------
        MOV     DX,[FATSEC]             ;START SECTOR
;----------------------------------------------- DOS5 91/05/30 -------
        MOV     AX,0                    ;HIGH WORD OF START SECTOR
        PUSH    CX
;---------------------------------------------------------------------
        CALL    DSK_READ
;----------------------------------------------- DOS5 91/05/30 -------
        POP     CX
        PUSHF
        SUB     [FATLEN],CX             ;SECTORS TO GO
        JZ      RF_20                   ; NO SECTOR REMAIN
        POPF
        ADD     [FATSEC],CX             ;NEXT START SECTOR
        MOV     AX,ES
        ADD     AX,1000H
        MOV     ES,AX                   ;NEXT BUFFER ADDR
        JMP     RF_64K
RF_20:
        POPF
;---------------------------------------------------------------------
;--------------------------------------------------------- 88/04/07 --
        PUSHF
        MOV     ES,[FATLOC]
        XOR     DI,DI                   ;ES:DI := LOAD LOCATION
        MOV     [RD_FBIGFAT],0          ;12 BIT FAT
        CMP     BYTE PTR ES:[DI+3],0FFH ;IF 16BIT FAT?
        JNZ     READFAT0                ;NO
        MOV     [RD_FBIGFAT],0FFH               ;16 BIT FAT
READFAT0:
        POPF
;---------------------------------------------------------------------
        RET

;****************************************
;*                                      *
;*      DISK READ                       *
;*                                      *
;*      CALL DISK DRIVER (READ)         *
;*                                      *
;*      INPUT:  (CX) SECTOR COUNT       *
;*              (AX) START SECTOR H     *
;*              (DX) START SECTOR L     *
;*              (ES:DI) LOAD ADDRESS    *
;*                                      *
;*      OUTPUT: (ZF) 1 NORMAL           *
;*                   0 ERROR            *
;*                                      *
;****************************************
DSK_READ:
        CALL    STRATP
;----------------------------------------------- DOS5 91/05/30 -------
        MOV     [REQ_STRTL],DX          ;LOW WORD OF START SECTOR
        MOV     [REQ_STRTH],AX          ;HIGH WORD OF START SECTOR
;---------------------------------------------------------------------
        MOV     [REQ_CMD],READ          ;SET COMMAND (READ)
        MOV     AL,[RD_UNIT]
        MOV     [REQ_UNT],AL            ;SET UNIT
        MOV     AL,[MDA_DSC]
        MOV     [REQ_MDA],AL            ;SET MEDIA DESCRIPTOR
        MOV     [REQ_CNT],CX            ;SET COUNT
        MOV     WORD PTR [REQ_TRNS],DI
        MOV     WORD PTR [REQ_TRNS+2],ES
;----------------------------------------------- DOS5 91/05/30 -------
        MOV     [REQ_STRT],-1           ;USE LARGE SECTOR NUMBER
        MOV     [REQ_LEN],30            ;REQUEST SIZE
;------------------
;       MOV     [REQ_STRT],DX           ;START SECTOR
;       MOV     [REQ_LEN],26            ;REQUEST SIZE
;---------------------------------------------------------------------
        CALL    CALDISK                 ;CALL DRIVER
        RET

;****************************************
;*                                      *
;*      DISK DRIVER CALL                *
;*                                      *
;*      OUTPUT: (AX) STATUS             *
;*              (ZF) 1 NORMAL           *
;*                   0 ERROR            *
;****************************************
CALDISK:
        CALL    DSK_INT                 ;DISK DRIVER CALL
        MOV     AX,[REQ_STS]            ;GET STATUS
        TEST    AX,8000H                ;CHECK ERROR
        RET

;****************************************
;*                                      *
;*      STRATEGY ROUTINE                *
;*                                      *
;****************************************
STRATP:
        PUSH    ES
        PUSH    CS
        POP     ES
        MOV     BX,OFFSET DATAGRP:REQUEST       ;REQ ADDRESS
        CALL    STRATEGY                ;CALL(FAR) STRATEGY
        MOV     [REQ_STS],0             ;CLEAR STATUS FIELD
        POP     ES
        RET

;****************************************
;*                                      *
;*      GETCLUS                         *
;*                                      *
;*      READ CLUSTER                    *
;*                                      *
;*      INPUT:  (BX) START CLUSTER      *
;*                       TO READ        *
;*              (CX) SECTORS / CLUSTER  *
;*              (DI) LOAD LOCATION      *
;*                                      *
;****************************************
GETCLUS:
        PUSH    CX
        PUSH    DI
        MOV     [DOSCNT],CX             ;SAVE NUMBER OF SECTORS TO READ
        MOV     AX,BX
        DEC     AX
        DEC     AX
        MUL     CX                      ;CONVERT TO LOGICAL SECTOR
;----------------------------------------------- DOS5 91/05/30 -------
        ADD     AX,[DATASEC]            ;ADD IN FIRST DATA SECTOR
        ADC     DX,0                    ;
        XCHG    DX,AX                   ;AX:DX = FIRST SECTOR TO READ
;------------------
;       ADD     AX,[DATASEC]            ;ADD IN FIRST DATA SECTOR
;       MOV     DX,AX                   ;DX = FIRST SECTOR TO READ
;---------------------------------------------------------------------
GETCL1:
        CALL    UNPACK                  ;SI = BX, BX = NEXT ALLOCATION UNIT
     IF DEBUG
        CALL    DSPCLS2         ;**DEB
     ENDIF
        SUB     SI,BX
        CMP     SI,-1                   ;ONE APART ?
        JNZ     GETCL2
        ADD     [DOSCNT],CX
        JMP     GETCL1

GETCL2:
        PUSH    BX
     IF DEBUG
        CALL    DSPCLS3         ;**DEB
     ENDIF 
        MOV     CX,[DOSCNT]
        CALL    DSK_READ                ;READ THE CLUSTERS
        POP     BX
        POP     DI
        MOV     AX,[DOSCNT]             ;GET NUMBER OF SECTORS READ
        MOV     SI,[BPBPTR]
        MOV     CX,[SI.BYTEPSEC]
        MUL     CX                      ;
        ADD     DI,AX                   ;UPDATE LOAD LOCATION
        POP     CX                      ;RESTORE SECTORS/CLUSTER
        RET

;****************************************
;*                                      *
;*      UNPACK                          *
;*                                      *
;*      GET THE FAT ENTRY AT BX,        *
;*      WHEN FINISHED SI=ENTRY BX       *
;*                                      *
;****************************************
UNPACK:
        PUSH    DS
        PUSH    BX
        MOV     SI,[FATLOC]
;--------------------------------------------------------- 88/04/07 --
        CMP     [RD_FBIGFAT],0FFH
        JZ      UNPACK0
;---------------------------------------------------------------------
        MOV     DS,SI
        MOV     SI,BX
        SHR     SI,1
        MOV     BX,[SI+BX]              ;       p = fat[clus+clus/2];
        JNC     HAVCLUS                 ;       if (clus&1)
        PUSH    CX
        MOV     CL,4
        SHR     BX,CL
        POP     CX
HAVCLUS:
        AND     BX,0FFFH                ;       oldclus=clus; clus = p & 0xFFF;
        POP     SI                      ;       return;
        POP     DS                      ;       }
        RET
;--------------------------------------------------------- 88/04/07 --
UNPACK0:
        MOV     DS,SI
        SHL     BX,1
;----------------------------------------------- DOS5 91/05/30 -------
        JNC     WITHIN64
        ADD     SI,1000H
        MOV     DS,SI
WITHIN64:
;---------------------------------------------------------------------
        MOV     BX,[BX]                 ;GET CLUS
        POP     SI
        POP     DS
        RET
;---------------------------------------------------------------------
;--------------------------------------------------------- 88/04/07 --
;****************************************
;*                                      *
;*      FAT END OF FILE                 *
;*                                      *
;****************************************
ISEOF:
        CMP     [RD_FBIGFAT],0FFH
        JZ      ISEOF0
        CMP     BX,0FF7H
        RET
ISEOF0:
        CMP     BX,0FFF7H
        RET
;---------------------------------------------------------------------

IF DEBUG
;********************************************************* DEB
DSPCLS2:
        PUSH    BX
        movnumw BX,NEW_FAT
        MOV     BX,OFFSET DATAGRP:DSPCLS_M
        CALL    display_string
        POP     BX
        RET
DSPCLS3:
        PUSH    BX
        MOV     BX,ES
        movnumw BX,RD_SEG
        MOV     BX,DI
        movnumw BX,RD_OFS
        movnumw DX,RD_STRT
        MOV     BX,[DOSCNT]
        movnumw BX,RD_CNT
        MOV     BX,OFFSET DATAGRP:DSPBUF_M
        CALL    display_string
        POP     BX
        RET

;******************************************************* DEB
ENDIF 
IF DEBUG
; Data Area
;
dsp             db      0dh,0ah,"[<ROM>] AX = "
a_ax            label   word
                db      "xxxx , BX = "
a_bx            label   word
                db      "xxxx , CX = "
a_cx            label   word
                db      "xxxx , DX = "
a_dx            label   word
                db      "xxxx , ES/BP ="
a_es            label   word
                db      "xxxx:"
a_bp            label   word
                db      "xxxx",0dh,0ah,"$"
old_strategy    dw      ?
                dw      ?

;************************** SET/RESET INT1B VECTOR ***********
start0:
        PUSH    ES
        PUSH    BX
        xor     ax,ax
        mov     es,ax
        MOV     AL,ES:[0634H]           ;GET DB MODE FLAG
        MOV     [DEB_FLG],AL            ;SAVE
        TEST    AL,DEB_INT1B            ;INT1B DEBUG ?
        JZ      START0_DON              ;NO,
        mov     bx,1BH *4
        mov     ax,offset DATAGRP:nextp
        mov     cx,cs
        xchg    ax,es:[bx]
        xchg    cx,es:[bx+2]
        mov     CS:[old_strategy],ax
        mov     CS:[old_strategy+2],cx
START0_DON:
        POP     BX
        POP     ES
        RET

END0:
        PUSH    ES
        PUSH    BX
        xor     ax,ax
        mov     es,ax
        TEST    [DEB_FLG],DEB_INT1B     ;DEBUG MODE ?
        JZ      END0_DON
        mov     bx,1BH *4
        mov     ax,CS:[old_strategy]
        mov     cx,CS:[old_strategy+2]
        xchg    ax,es:[bx]
        xchg    cx,es:[bx+2]
END0_DON:
        POP     BX
        POP     ES
        RET

;************************ INT1B TRAP ROUTINE ***********
nextp:
        push    ax
        push    bx
                push    bx
                mov     bx,ax
                movnumw bx,a_ax
                pop     bx
                movnumw bx,a_bx
                movnumw cx,a_cx
                movnumw dx,a_dx
                movnumw es,a_es
                movnumw bp,a_bp
                mov     bx,offset DATAGRP:dsp
                call    display_string
        pop     bx
        pop     ax
                jmp     dword ptr cs:[old_strategy]
        

;
;----------------
; bin2hex
;----------------
;
hextable        db      "0123456789ABCDEF"
bin2hex         proc
                push    bx
                mov     bx,offset DATAGRP:hextable
                mov     ah,al
                and     al,0fh
                xlat    cs:[bx]
                xchg    ah,al
                and     al,0f0h
                shr     al,1
                shr     al,1
                shr     al,1
                shr     al,1
                xlat    cs:[bx]
                pop     bx
                ret
bin2hex         endp
;
;----------------
; display_string
;----------------
;
display_string  proc
ds0:
        TEST    [DEB_FLG],DEB_CLSTR
        JZ      dsret
                cmp     byte ptr cs:[bx],'$'
                je      dsret
                mov     al,cs:[bx]
                int     29h
                inc     bx
                jmp     ds0
dsret:
                ret
display_string  endp
ENDIF


Bios_Data_Init  ends
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\sysconf.asm ===
page	,160
	title	bios system initialization
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

	include version.inc		; set version build flags
	include biosseg.inc		; establish bios segment structure

lf	equ	10
cr	equ	13
tab	equ	 9

have_install_cmd      equ     00000001b ; config.sys has install= commands
has_installed	      equ     00000010b ; sysinit_base installed.

default_filenum = 8

	break	macro	; dummy empty macro
	endm

	include sysvar.inc
ifdef NEC_98
	include dpb.inc
endif   ;NEC_98
	include	pdb.inc			; M020
	include syscall.inc
	include doscntry.inc
	include devsym.inc
	include devmark.inc

	include	umb.inc
	include	dossym.inc
        include dossvc.inc
        include cmdsvc.inc
        include softpc.inc

ifndef NEC_98
stacksw equ	true		;include switchable hardware stacks
else    ;NEC_98
stacksw equ	false		;include switchable hardware stacks
endif   ;NEC_98

	if	ibmjapver
noexec	equ	true
	else
noexec	equ	false
	endif




; external variable defined in ibmbio module for multi-track

multrk_on	equ	10000000b	;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
multrk_off1	equ	00000000b	;initial value. no "multitrack=" command entered.
multrk_off2	equ	00000001b	;user specified multitrack=off.

Bios_Data segment 
	extrn	multrk_flag:word
	extrn	keyrd_func:byte
	extrn	keysts_func:byte
Bios_Data ends

; end of multi-track definition.

sysinitseg	segment 

assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing

	extrn	badopm:byte,crlfm:byte,badcom:byte,badmem:byte,badblock:byte
	extrn	badsiz_pre:byte,badld_pre:byte
	extrn	badstack:byte,badcountrycom:byte
	extrn	badcountry:byte,insufmemory:byte
	extrn	condev:byte,auxdev:byte,prndev:byte,commnd:byte,config:byte
	extrn	cntry_drv:byte,cntry_root:byte,cntry_path:byte
	extrn	memory_size:word
	extrn	buffers:word
	extrn	files:byte,num_cds:byte
	extrn	dosinfo:dword
	extrn	fcbs:byte,keep:byte
	extrn	confbot:word,alloclim:word,command_line:byte
	extrn	zero:byte,sepchr:byte
	extrn	count:word,chrptr:word,cntryfilehandle:word
	extrn	memlo:word,memhi:word,prmblk:word,ldoff:word
	extrn	packet:byte,unitcount:byte,break_addr:dword
	extrn	bpb_addr:dword,drivenumber:byte,sysi_country:dword
	extrn	config_size:word
	extrn	install_flag:word
	extrn	badorder:byte
	extrn	errorcmd:byte
	extrn	linecount:word
	extrn	showcount:byte
	extrn	buffer_linenum:word
	extrn	h_buffers:word
	extrn	badparm:byte
	extrn	configmsgflag:word
	extrn	org_count:word
	extrn	multi_pass_id:byte

	extrn	mem_err:near,setdoscountryinfo:near
	extrn	pararound:near,tempcds:near
	extrn	set_country_path:near,move_asciiz:near,delim:near
	extrn	badfil:near,round:near
	extrn	do_install_exec:near
	extrn	setdevmark:near

	extrn	print:near,organize:near,newline:near
ifndef NEC_98
	extrn	parseline:near
else    ;NEC_98
	extrn	deviceparameters:byte
	extrn	diddleback:near,parseline:near,setparms:near
endif   ;NEC_98
	extrn	badload:near,calldev:near,prnerr:near

	extrn	runhigh:byte
	extrn	IsXMSLoaded:near

	extrn	TryToMovDOSHi:near

ifdef DBCS
	extrn	testkanj:near
endif

ifdef	JAPAN
extrn	badblock2:byte,badsiz_pre2:byte,badcountry2:byte,insufmemory2:byte
extrn	badcountry2:byte,badcountrycom2:byte,badstack2:byte,badopm2:byte
extrn	badparm2:byte,badorder2:byte,errorcmd2:byte
endif

        extrn   bEchoConfig:byte  ; NTVDM flag off\on echo of cfg processing

	if	stacksw

; internal stack parameters

entrysize	equ	8

mincount	equ	8
defaultcount	equ	9
maxcount	equ	64

minsize 	equ	32
defaultsize	equ	128
maxsize 	equ	512

DOS_FLAG_OFFSET	equ	86h

	extrn  stack_count:word
	extrn  stack_size:word
	extrn  stack_addr:dword

	endif

ifdef NEC_98
DOS_FLAG_OFFSET equ	86h
endif   ;NEC_98
	public doconf
	public getchr
	public multi_pass
        public AllocUMB
        public AllocUMBLow      ; NTVDM
	public	multdeviceflag
multdeviceflag	db	0
	public	devmark_addr
devmark_addr	dw	?		;segment address for devmark.
	public	setdevmarkflag
setdevmarkflag	    db	    0		;flag used for devmark

ems_stub_installed  db	    0

IFDEF	DONT_LOAD_OS2_DD		; M045

Os2ChkBuf	DD	0		; Tmp read buffer

ENDIF					; M045

badparm_ptr	label	dword
badparm_off	dw	0
badparm_seg	dw	0

;******************************************************************************
;take care of config.sys file.
;system parser data and code.
;******************************************************************************

;*******************************************************************
; parser options set for msbio sysconf module
;*******************************************************************
;
;**** default assemble swiches definition **************************

	ifndef	farsw
farsw	equ	0	; near call expected
	endif

	ifndef	datesw
datesw	equ	0	; check date format
	endif

	ifndef	timesw
timesw	equ	0	; check time format
	endif

	ifndef	filesw
filesw	equ	1	; check file specification
	endif

	ifndef	capsw
capsw	equ	0	; perform caps if specified
	endif

	ifndef	cmpxsw
cmpxsw	equ	0	; check complex list
	endif

	ifndef	numsw
numsw	equ	1	; check numeric value
	endif

	ifndef	keysw
keysw	equ	0	; support keywords
	endif

	ifndef	swsw
swsw	equ	1	; support switches
	endif

	ifndef	val1sw
val1sw	equ	1	; support value definition 1
	endif

	ifndef	val2sw
val2sw	equ	0	; support value definition 2
	endif

	ifndef	val3sw
val3sw	equ	1	; support value definition 3
	endif

	ifndef	drvsw
drvsw	equ	1	; support drive only format
	endif

	ifndef	qussw
qussw	equ	0	; support quoted string format
	endif


	include parse.asm		;together with psdata.inc

;control block definitions for parser.
;---------------------------------------------------
; buffer = [n | n,m] {/e}

p_parms struc
	dw	?
	db	1		; an extra delimiter list
	db	1		; length is 1
	db	';'		; delimiter
p_parms ends

p_pos	struc
	dw	?		; numeric value??
	dw	?		; function
	dw	?		; result value buffer

; note: by defining result_val before this structure, we could remove
;  the "result_val" from every structure invocation

	dw	?		; value list
	db	0		; no switches/keywords
p_pos	ends

p_range struc
	db	1		; range definition
	db	1		; 1 definition of range
	db	1		; item tag for this range
	dd	?		; numeric min
	dd	?		; numeric max
p_range ends

buf_parms p_parms <buf_parmsx>
buf_parmsx dw	201h,buf_pos1,buf_pos2	; min 1, max 2 positionals
	   db	1			; one switch
	   dw	sw_x_ctrl
	   db	0			; no keywords

buf_pos1    p_pos   <8000h,0,result_val,buf_range_1> ; numeric
ifndef NEC_98
buf_range_1 p_range <,,,1,99>			     ; M050
else    ;NEC_98
;<patch BIOS50-P18>
buf_range_1 p_range <,,,1,62>                        ; M050
endif   ;NEC_98
buf_pos2    p_pos   <8001h,0,result_val,buf_range_2> ; optional num.
buf_range_2 p_range <,,,0,8>

sw_x_ctrl p_pos <0,0,result_val,noval,1> ; followed by one switch
switch_x  db	'/X',0			; M016

p_buffers	dw	0	; local variables
p_h_buffers	dw	0
p_buffer_slash_x db	0

;common definitions ------------
noval	db	0

result_val	label	byte
	db	?		; type returned
	db	?		; item tag returned
	dw	?		; es:offset of the switch defined
rv_byte 	label	byte
rv_dword dd	?		; value if number,or seg:offset to string.
;-------------------------------

; break = [ on | off ]

brk_parms	p_parms  <brk_parmsx>

brk_parmsx dw	101h,brk_pos	; min,max = 1 positional
	   db	0		; no switches
	   db	0		; no keywords

brk_pos p_pos	<2000h,0,result_val,on_off_string> ; simple string

on_off_string	label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	2		; 2 strings for choice
	db	1		; the 1st string tag
	dw	on_string
	db	2		; the 2nd string tag
	dw	off_string

on_string	db	"ON",0
off_string	db	"OFF",0

p_ctrl_break	db	0	; local variable

;--------------------------------

; country = n {m {path}}
; or
; country = n,,path

cntry_parms	p_parms <cntry_parmsx>

cntry_parmsx dw	301h,cntry_pos1,cntry_pos2,cntry_pos3 ; min 1, max 3 pos.
	     db	0		; no switches
	     db	0		; no keywords

cntry_pos1 p_pos <8000h,0,result_val,cc_range> ; numeric value
cc_range p_range <,,,1,999>
cntry_pos2 p_pos <8001h,0,result_val,cc_range> ; optional num.
cntry_pos3 p_pos <201h,0,result_val,noval>     ; optional filespec

p_cntry_code	dw	0	; local variable
p_code_page	dw	0	; local variable

;--------------------------------

; files = n

files_parms	p_parms <files_parmsx>

files_parmsx dw	101h,files_pos	; min,max 1 positional
	     db	0		; no switches
	     db	0		; no keywords

files_pos   p_pos   <8000h,0,result_val,files_range,0> ; numeric value
files_range p_range <,,,8,255>

p_files db	0		; local variable

;-------------------------------

; fcbs = n,m

fcbs_parms	p_parms <fcbs_parmsx>

fcbs_parmsx dw	201h,fcbs_pos_1,fcbs_pos_2 ; min,max = 2 positional
	    db	0		; no switches
	    db	0		; no keywords

fcbs_pos_1	p_pos	<8000h,0,result_val,fcbs_range> ; numeric value
fcbs_range	p_range	<,,,1,255>
fcbs_pos_2	p_pos	<8000h,0,result_val,fcbs_keep_range> ; numeric value
fcbs_keep_range p_range <,,,0,255>

p_fcbs	db	0		; local variable
p_keep	db	0		; local variable

;-------------------------------
; lastdrive = x

ldrv_parms	p_parms <ldrv_parmsx>

ldrv_parmsx dw	101h,ldrv_pos	; min,max = 1 positional
	    db	0		; no switches
	    db	0		; no keywords

ldrv_pos p_pos	<110h,10h,result_val,noval> ; drive only, ignore colon
					    ; remove colon at end
p_ldrv	db	0		; local variable

;-------------------------------

; stacks = n,m

stks_parms	p_parms <stks_parmsx>

stks_parmsx dw	202h,stks_pos_1,stks_pos_2 ; min,max = 2 positionals
	    db	0		; no switches
	    db	0		; no keywords

stks_pos_1     p_pos   <8000h,0,result_val,stks_range> ; numeric value
stks_range     p_range <,,,0,64>
stks_pos_2     p_pos   <8000h,0,result_val,stk_size_range> ; numeric value
stk_size_range p_range <,,,0,512>

p_stack_count	dw	0	; local variable
p_stack_size	dw	0	; local variable

;-------------------------------

; multitrack = [ on | off ]

mtrk_parms	p_parms <mtrk_parmsx>

mtrk_parmsx dw	101h,mtrk_pos	; min,max = 1 positional
	    db	0		; no switches
	    db	0		; no keywords

mtrk_pos p_pos	<2000h,0,result_val,on_off_string> ; simple string

p_mtrk	db	0		; local variable

;-------------------------------
; switches=/k

swit_parms	p_parms <swit_parmsx>

swit_parmsx dw	0		; no positionals
	    db	3		; 2 switches for now.	M059 M063
	    dw	swit_k_ctrl	; /k control
	    dw	swit_t_ctrl	; /t control		M059
	    dw	swit_w_ctrl	; /w control		M063
	    db	0		; no keywords

swit_k_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_k db	'/K',0
swit_t_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M059
swit_t db	'/T',0			   ;				M059
swit_w_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M063
swit_w db	'/W',0			   ;				M063

p_swit_k	db     0	; local variable
p_swit_t	db     0	; local variable			M059
p_swit_w	db     0	; local variable			M063

;-------------------------------

; DOS = [ high | low ]

dos_parms	p_parms  <dos_parmsx>

dos_parmsx db	1		; min parameters
	   db	2		; max parameters
	   dw	dos_pos		; 
	   dw	dos_pos		; 
	   db	0		; no switches
	   db	0		; no keywords

dos_pos p_pos	<2000h,0,result_val,dos_strings> ; simple string
        p_pos	<2000h,0,result_val,dos_strings> ; simple string

dos_strings	label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	4		; 4 strings for choice
	db	1		; the 1st string tag
	dw	hi_string
	db	2		; the 2nd string tag
	dw	lo_string
	db	3
	dw	umb_string
	db	4
	dw	noumb_string

hi_string	db	"HIGH",0
lo_string	db	"LOW",0
umb_string	db	"UMB",0
noumb_string	db	"NOUMB",0

p_dos_hi	db	0	; local variable
				; BUGBUG : I dont know whether PARSER uses
				;          this variable or not



;******************************************************************************

		public	DevEntry

DevSize		dw	?	; size of the device driver being loaded(paras)
DevLoadAddr	dw	?	; Mem addr where the device driver is 2 b loaded
DevLoadEnd	dw	?	; MaxAddr to which device can be loaded
DevEntry	dd	?	; Entry point to the device driver
DevBrkAddr	dd	?	; Break address of the device driver
;
DevUMB		db	0	; byte indicating whether to load DDs in UMBs
DevUMBAddr	dw	0	; cuurent UMB used fro loading devices (paras)
DevUMBSize	dw	0	; Size of the current UMB being used   (paras)
DevUMBFree	dw	0	; Start of free are in the current UMB (paras)
;
DevXMSAddr	dd	?
;
DevExecAddr	dw	?	; Device load address parameter to Exec call
DevExecReloc	dw	?	; Device load relocation factor
;
DeviceHi	db	0	; Flag indicating whther the current device
				;  is being loaded into UMB
DevSizeOption	dw	?	; SIZE= option
;
Int12Lied	db	0	; did we trap int 12 ?
OldInt12Mem	dw	?	; value in 40:13h (int 12 ram)
ThreeComName	db	'PROTMAN$'	; 3Com Device name
;
FirstUMBLinked	db	0
DevDOSData	dw	?	; segment of DOS Data
DevCmdLine	dd	?	; Current Command line
ifndef NEC_98
DevSavedDelim	db	?	; The delimiter which was replaced with null
else    ;NEC_98
DevSavedDelim	db	00h	; The delimiter which was replaced with null
endif   ;NEC_98
				; to use the file name in the command line
;
;----------------------------------------------------------------------------
;
; procedure : doconf
;
;             Config file is parsed intitially with this routine. For the
;             Subsequent passes 'multi_pass' entry is used .
;
;----------------------------------------------------------------------------
;
doconf	proc	near
	push	cs
	pop	ds
	assume	ds:sysinitseg

	mov	ax,(char_oper shl 8)	;get switch character
	int	21h
	mov	[command_line+1],dl	; set in default command line

	mov	dx,offset config	;now pointing to file description
	mov	ax,open shl 8		;open file "config.sys"
	stc				;in case of int 24
	int	21h			;function request
	jnc	noprob			; brif opened okay
	mov	multi_pass_id,11	; set it to unreasonable number
	ret
noprob: 				;get file size (note < 64k!!)
	mov	bx,ax
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	int	21h
	mov	[count],ax

	xor	dx,dx
	mov	ax,lseek shl 8		;reset pointer to beginning of file
	int	21h

	mov	dx,[confbot]		;use current confbot value
	mov	ax,[count]
	mov	[config_size],ax	;save the size of config.sys file.
	call	pararound
	sub	dx,ax
	sub	dx,11h			;room for header
	mov	[confbot],dx		; config starts here. new conbot value.
	call	tempcds 		; finally get cds to "safe" location
	assume	ds:nothing,es:nothing

	mov	dx,[confbot]
	mov	ds,dx
	mov	es,dx
	xor	dx,dx
	mov	cx,[count]
	mov	ah,read
	stc				;in case of int 24
	int	21h			;function request
	pushf

; find the eof mark in the file.  if present,then trim length.

	push	ax
	push	di
	push	cx
	mov	al,1ah			; eof mark
	mov	di,dx			; point ro buffer
	jcxz	puteol			; no chars
	repnz	scasb			; find end
	jnz	puteol			; none found and count exahusted

; we found a 1a.  back up

	dec	di			; backup past 1a

;  just for the halibut,stick in an extra eol

puteol:
	mov	al,cr
	stosb
	mov	al,lf
	stosb
	sub	di,dx			; difference moved
	mov	count,di		; new count

	pop	cx
	pop	di
	pop	ax

	push	cs
	pop	ds
	assume	ds:sysinitseg

	push	ax
	mov	ah,close
	int	21h
	pop	ax
	popf
	jc	conferr 		;if not we've got a problem
	cmp	cx,ax
	jz	getcom			;couldn't read the file

conferr:
	mov	dx,offset config	;want to print config error
	call	badfil
endconv:
	ret
;
;----------------------------------------------------------------------------
;
; entry : multi_pass
;
;             called to execute device=,install= commands
;
;----------------------------------------------------------------------------
;

multi_pass:
	push	cs
	pop	ds

	cmp	multi_pass_id,10
	jae	endconv 		; do nothing. just return.

	push	confbot
	pop	es			; es -> confbot

	mov	si,org_count
	mov	count,si		; set count
	xor	si,si
	mov	chrptr,si		; reset chrptr,linecount
	mov	linecount,si
	call	getchr
	jmp	short conflp

getcom:
	call	organize		;organize the file
	call	getchr

conflp: jc	endconv

;***	call	reset_dos_version	; still need to reset version even ibmdos handles this through
;***					; function 4bh call,since ibmdos does not know when load/overlay call finishes.

	inc	linecount		; increase linecount.
	mov	multdeviceflag,0	; reset multdeviceflag.
	mov	setdevmarkflag,0	; reset setdevmarkflag.
	cmp	al,lf			; linefeed?
	je	blank_line		;  then ignore this line.

	mov	ah,al
	call	getchr
	jnc	tryi

	cmp	multi_pass_id,2
	jae	endconv 		;do not show badop again for multi_pass.
	jmp	badop

coff:	push	cs
	pop	ds
	call	newline
	jmp	conflp

blank_line:
	call	getchr
	jmp	conflp

coff_p:
	push	cs
	pop	ds


;to handle install= commands,we are going to use multi-pass.
;the first pass handles the other commands and only set install_flag when
;it finds any install command.	 the second pass will only handle the
;install= command.

;------------------------------------------------------------------------------
;install command
;------------------------------------------------------------------------------
tryi:
        cmp     multi_pass_id,0         ; the initial pass for DOS=HI
        je      multi_try_doshi

        cmp     multi_pass_id,2         ; the second pass was for ifs=
        je      coff                    ; now it is NOPs
					; This pass can be made use of if
					; we want do some config.sys process
					; after device drivers are loaded
					; and before install= commands
					; are processed

	cmp	multi_pass_id,3		; the third pass for install= ?
	je	multi_try_i
	cmp	ah, 'H'
        je      coff
        cmp     ah, 'E'
        je      coff
	cmp	ah,'I'			; install= command?
	jne	tryb				; the first pass is for normal operation.
	or	install_flag,have_install_cmd	; set the flag
	jmp	coff				; and handles the next command

multi_try_i:
	cmp	ah,'I'			; install= command?
	jne	multi_pass_filter	; no. ignore this.
	call	do_install_exec 	;install it.
	jmp	coff			;to handle next install= command.

multi_pass_filter:
	cmp	ah,'Y'			; comment?
	je	multi_pass_adjust
	cmp	ah,'Z'			; bad command?
	je	multi_pass_adjust
	cmp	ah,'0'			; rem?
        jne     coff         ; ignore the rest of the commands.

multi_pass_adjust:			; these commands need to
	dec	chrptr			;  adjust chrptr,count
	inc	count			;  for newline proc.

multi_pass_coff:
	jmp	coff			; to handle next install= commands.



;----------------------------------------------------------------------------
; DOS=HIGH/LOW command
;
; EchoConfig command turns on con echo for config processing
;            NTVDM 14-Aug-1992 Jonle
;----------------------------------------------------------------------------
;
multi_try_doshi:
	cmp	ah, 'H'
        je      it_is_h
        cmp     ah, 'E'
        jne     multi_pass_filter

        mov     cs:bEchoConfig, ah     ; init console
        CMDSVC  SVC_CMDINITCONSOLE
        jmp     coff


it_is_h:                                ; M003 - removed initing DevUMB
					;	 & runhigh
	mov	di,offset dos_parms
	xor	cx,cx
	mov	dx,cx
h_do_parse:
	call	sysinit_parse
	jnc	h_parse_ok		; parse error
h_badparm:
	call	badparm_p		;  show message and end the serach loop.
	jmp	short h_end

h_parse_ok:
	cmp	ax,$p_rc_eol		; end of line?
	jz	h_end			; then end the $endloop
	call	ProcDOS
	jmp	short h_do_parse
h_end:
	jmp	coff


;------------------------------------------------------------------------------
; buffer command
;------------------------------------------------------------------------------
;*******************************************************************************
;									      *
; function: parse the parameters of buffers= command.			      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	buffers set							      *
;	buffer_slash_x	flag set if /x option chosen.			      *
;	h_buffers set if secondary buffer cache specified.		      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di points to buf_parms;  /*parse control definition*/	      *
;	set dx,cx to 0; 						      *
;	reset buffer_slash_x;						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val.$p_synonym_ptr == slash_e) then /*not a switch  *
;		    buffer_slash_x = 1					      *
;	       else if	 (cx == 1) then 	    /* first positional */    *
;			  buffers = result_val.$p_picked_val;		      *
;		    else  h_buffers = result_val.$p_picked_val; 	      *
;	  else	{show error message;error exit} 			      *
;	};								      *
;	if (buffer_slash_x is off & buffers > 99) then show_error;	      *
; };									      *
;									      *
;*******************************************************************************

tryb:
	cmp	ah,'B'
        jnz     tryc

        ; NTVDM - buffers command is ignored
        ; 15-Aug-1992 Jonle
        jmp     coff

if  0
        mov     p_buffer_slash_x,0
        mov     di,offset buf_parms
        xor     cx,cx
        mov     dx,cx

do7:
        call    sysinit_parse
        jnc     if7                     ; parse error,
        call    badparm_p               ;   and show messages and end the search loop.
        jmp     short sr7

if7:
        cmp     ax,$p_rc_eol            ; end of line?
        jz      en7                     ;  then jmp to $endloop for semantic check
        cmp     result_val.$p_synonym_ptr,offset switch_x
        jnz     if11

;       mov     p_buffer_slash_x,1      ; set the flag M016
	jmp	short en11

if11:
	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if13

	mov	p_buffers,ax
	jmp	short en11

if13:
	mov	p_h_buffers,ax
en11:
	jmp	do7

en7:
	cmp	p_buffers,99
	jbe	if18
;	cmp	p_buffer_slash_x,0	; M016
;	jnz	if18

	call	badparm_p
	mov	p_h_buffers,0
	jmp	short sr7

if18:
	mov	ax,p_buffers	; we don't have any problem.
	mov	buffers,ax	; now,let's set it really.

	mov	ax,p_h_buffers
	mov	h_buffers,ax

;	mov	al,p_buffer_slash_x	; M016
;	mov	buffer_slash_x,al

	mov	ax,linecount
	mov	buffer_linenum,ax ; save the line number for the future use.

sr7:
        jmp     coff
endif


;------------------------------------------------------------------------------
; break command
;------------------------------------------------------------------------------
;****************************************************************************
;									    *
; function: parse the parameters of break = command.			    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	turn the control-c check on or off.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di to brk_parms;						    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val.$p_item_tag == 1) then	  /*on		 */ *
;		   set p_ctrl_break,on;					    *
;	       else					  /*off 	 */ *
;		   set p_ctrl_break,off;				    *
;	  else {show message;error_exit};				    *
;	};								    *
;	if (no error) then						    *
;	   dos function call to set ctrl_break check according to	    *
; };									    *
;									    *
;****************************************************************************

tryc:
	cmp	ah,'C'
	jnz	trym
	mov	di,offset brk_parms
	xor	cx,cx
	mov	dx,cx
do22:
	call	sysinit_parse
	jnc	if22			; parse error
	call	badparm_p		;  show message and end the serach loop.
	jmp	short sr22

if22:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en22			; then end the $endloop
	cmp	result_val.$p_item_tag,1
	jnz	if26

	mov	p_ctrl_break,1		; turn it on
	jmp	short en26

if26:
	mov	p_ctrl_break,0		; turn it off
en26:
	jmp	short do22		; we actually set the ctrl break

en22:
	mov	ah,set_ctrl_c_trapping ; if we don't have any parse error.
	mov	al,1
	mov	dl,p_ctrl_break
	int	21h
sr22:
	jmp	coff

;------------------------------------------------------------------------------
; multitrack command
;------------------------------------------------------------------------------
;******************************************************************************
;									      *
; function: parse the parameters of multitrack= command.		      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	turn multrk_flag on or off.					      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di to brk_parms;						      *
;	set dx,cx to 0; 						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val.$p_item_tag == 1) then	  /*on		 */   *
;		   set p_mtrk,on;					      *
;	       else					  /*off 	 */   *
;		   set p_mtrk,off;					      *
;	  else {show message;error_exit};				      *
;	};								      *
;	if (no error) then						      *
;	   dos function call to set multrk_flag according to p_mtrk.	      *
;									      *
; };									      *
;									      *
;******************************************************************************

trym:
	cmp	ah,'M'
	jnz	tryu

	mov	di,offset mtrk_parms
	xor	cx,cx
	mov	dx,cx
do31:
	call	sysinit_parse
	jnc	if31		; parse error
	call	badparm_p	;  show message and end the serach loop.
	jmp	short sr31
if31:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en31		; then end the $endloop

	cmp	result_val.$p_item_tag,1
	jnz	if35

	mov	p_mtrk,1	; turn it on temporarily.
	jmp	short en35

if35:
	mov	p_mtrk,0	; turn it off temporarily.
en35:
	jmp	short do31	; we actually set the multrk_flag here

en31:
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data

	cmp	p_mtrk,0
	jnz	if39

	mov	multrk_flag,multrk_off2	; 0001h
	jmp	short en39

if39:
	mov	multrk_flag,multrk_on	; 8000h
en39:
	pop	ds
	assume	ds:sysinitseg
sr31:
	jmp	coff


;
;-----------------------------------------------------------------------------
; devicehigh command
;-----------------------------------------------------------------------------
;
	assume	ds:nothing
tryu:
	cmp	ah, 'U'
	jne	tryd
	mov	badparm_off, si		; stash it there in case of an error
	mov	badparm_seg, es
	call	ParseSize		; process the size= option
	jnc	@f
	call	badparm_p
	jmp	coff
@@:
	push	si
	push	es
@@:
	mov	al, es:[si]
	cmp	al, cr
	je	@f
	cmp	al, lf
	je	@f
	call	delim
	jz	@f
	inc	si
	jmp	@b
@@:
ifndef NEC_98
	mov	DevSavedDelim, al	; Save the delimiter before replacing
					;  it with null
else    ;NEC_98
	db	4 dup (90h)		; 4 bytes of NOPs
endif   ;NEC_98
	mov	byte ptr es:[si], 0
	pop	es
	pop	si

	mov	DeviceHi, 0
	cmp	DevUMB, 0		; do we support UMBs
	je	LoadDevice		; no, we don't
	mov	DeviceHi, 1
	jmp	short LoadDevice
;
;------------------------------------------------------------------------------
; device command
;------------------------------------------------------------------------------

	assume	ds:nothing
tryd:
	cmp	ah,'D'
	jz	gotd
	jmp	tryq
gotd:
	mov	DeviceHi, 0		; not to be loaded in UMB ;M007
	mov	DevSizeOption, 0
ifndef NEC_98
	mov	DevSavedDelim, ' '	; In case of DEVICE= the null has to
					;  be replaced with a ' '
else    ;NEC_98
	mov	DevSavedDelim, 00h
endif   ;NEC_98

LoadDevice:
	mov	bx,cs			;device= or devicehigh= command.
	mov	ds,bx

	mov	word ptr [bpb_addr],si	; pass the command line to the dvice
	mov	word ptr [bpb_addr+2],es

	mov	word ptr DevCmdLine, si	; save it for ourself
	mov	word ptr DevCmdLine+2, es

	call	round

	call	SizeDevice
        jc      BadFile

        call    InitDevLoad

	mov	ax, DevLoadAddr
	add	ax, DevSize
	jc	NoMem
	cmp	DevLoadEnd, ax
	jae	LoadDev

NoMem:
	jmp	mem_err

BadFile:
	cmp	byte ptr es:[si], cr
	jne	@f
	jmp	badop
@@:
	call	badload
	jmp	coff

LoadDev:
	push	es
	pop	ds
	assume	ds:nothing
	mov	dx,si			;ds:dx points to file name

	if	noexec
	les	bx,dword ptr cs:[memlo]
	call	ldfil			;load in the device driver

	else

	call	ExecDev			; load device driver using exec call

	endif

badldreset:
	push	ds
	pop	es			;es:si back to config.sys
	push	cs
	pop	ds			;ds back to sysinit
	jc	BadFile
goodld:
	push	es
	push	si			; ???

	call	RemoveNull

        push    es
        push    si

	push	cs
	pop	es


;NTVDM: block device drivers are not supported.
;       Putup user warning popup for unsupported device driver
;       29-Sep-1992 Jonle
;
        push    ds
	push	si
        lds     si, DevEntry                    ; peek the header attribute
        test    word ptr ds:[si.sdevatt],devtyp ; IS block device driver?
        pop     si
        pop     ds
        jnz     got_device_com_cont             ; no!

        pop     si                              ;clear the stack
        pop     es

ifndef NEC_98
        mov     ax, NOSUPPORT_DRIVER
        BOP     BOP_NOSUPPORT
        jmp     short erase_dev_do
endif   ;NEC_98

got_device_com_cont:

	call	LieInt12Mem
	call	UpdatePDB		; update the PSP:2 value M020

	cmp	cs:multdeviceflag, 0	; Pass limit only for the 1st device
					;  driver in the file ; M027
	jne	skip_pass_limit		;		      ; M027

	mov	word ptr break_addr, 0	; pass the limit to the DD
	mov	bx, DevLoadEnd
	mov	word ptr break_addr+2, bx
skip_pass_limit:					      ; M027
	mov	bx,sdevstrat
	call	calldev 		;   calldev (sdevstrat);
	mov	bx,sdevint
	call	calldev 		;   calldev (sdevint);

	call	TrueInt12Mem

	mov	ax, word ptr break_addr	; move break addr from the req packet
	mov	word ptr DevBrkAddr, ax
	mov	ax, word ptr break_addr+2
	mov	word ptr DevBrkAddr+2, ax

	assume	ds:nothing

	cmp	DevUMB, 0
	jz	@f
	call	AllocUMB
@@:

;
;------ If we are waiting to be moved into hma lets try it now !!!
;
	cmp	runhigh, 0ffh
	jne	@f

	call	TryToMovDOSHi		; move DOS into HMA if reqd
@@:

	pop	si
	pop	ds
	mov	byte ptr [si],0 	;   *p = 0;

	push	cs
	pop	ds

	jmp	short was_device_com


erase_dev_do:                           ; modified to show message "error in config.sys..."
	pop	si
	pop	es

	push	cs
	pop	ds

;	test	[setdevmarkflag],setbrkdone	;if already set_break is done,
;	jnz	skip1_resetmemhi		; then do not
;	dec	[memhi] 			;adjust memhi by a paragrah of devmark.

skip1_resetmemhi:
	cmp	configmsgflag,0
	je	no_error_line_msg

	call	error_line		; no "error in config.sys" msg for device driver. dcr d493
	mov	configmsgflag,0		;set the default value again.

no_error_line_msg:
	jmp	coff
;
;----------------------------------------------------------------------------
;
was_device_com:
	mov	ax,word ptr [DevBrkAddr+2]
	cmp	ax,DevLoadEnd
	jbe	breakok

	pop	si
	pop	es
	jmp	BadFile

breakok:
        lds     si,DevEntry             ;ds:si points to header
        les     di,cs:[dosinfo]         ;es:di point to dos info
        mov     ax,ds:[si.sdevatt]      ;ax    Dev attributes
;
;------ lets deal with character devices,
;       NTVDM: removed check for block drivers, jonle
;
ischardev:
        or      cs:[setdevmarkflag],for_devmark
	call	DevSetBreak		; go ahead and alloc mem for device
        jc      erase_dev_do            ;device driver's init routine failed.

	test	ax,iscin		;is it a console in?
	jz	tryclk

        mov     word ptr es:[di.sysi_con],si
	mov	word ptr es:[di.sysi_con+2],ds

tryclk: test	ax,isclock		;is it a clock device?
        jz      linkit

        mov     word ptr es:[di+sysi_clock],si
	mov	word ptr es:[di+sysi_clock+2],ds

linkit:

        mov     cx,word ptr es:[di.sysi_dev]    ;dx:cx = head of list
	mov	dx,word ptr es:[di.sysi_dev+2]

        mov     word ptr es:[di.sysi_dev],si    ;set head of list in dos
	mov	word ptr es:[di.sysi_dev+2],ds
	mov	ax,ds:[si]			;get pointer to next device
	mov	word ptr cs:[DevEntry],ax	;and save it

	mov	word ptr ds:[si],cx		;link in the driver
	mov	word ptr ds:[si+2],dx

enddev:
	pop	si
	pop	es
	inc	ax			;ax = ffff (no more devs if yes)?
	jz	coffj3

	inc	cs:multdeviceflag	; possibly multiple device driver.
	call	DevBreak		; M009
	jmp	goodld			; otherwise pretend we loaded it in

coffj3: mov	cs:multdeviceflag,0	; reset the flag
	call	DevBreak
	jmp	coff

bad_bpb_size_sector:
	pop	si
	pop	es
	mov	dx,offset badsiz_pre
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badsiz_pre2
@@:
endif
	mov	bx,offset crlfm
	call	prnerr

;	test	[setdevmarkflag],setbrkdone ;if already set_break is done,
;	jnz	skip2_resetmemhi	; then do not
;	dec	[memhi] 		;adjust memhi by a paragrah of devmark.

skip2_resetmemhi:
	jmp	coff


;------------------------------------------------------------------------------
; country command
;      the syntax is:
;	country=country id {,codepage {,path}}
;	country=country id {,,path}	:default codepage id in dos
;------------------------------------------------------------------------------

tryq:
	cmp	ah,'Q'
	jz	tryq_cont
	jmp	tryf
tryq_cont:

	mov	cntry_drv,0		; reset the drive,path to default value.
	mov	p_code_page,0
	mov	di,offset cntry_parms
	xor	cx,cx
	mov	dx,cx
do52:
	call	sysinit_parse
	jnc	if52			; parse error,check error code and

	call	cntry_error		;  show message and end the search loop.
	mov	p_cntry_code,-1		; signals that parse error.
	jmp	short sr52

if52:
	cmp	ax,$p_rc_eol		; end of line?
	jz	sr52			; then end the search loop

	cmp	result_val.$p_type,$p_number	; numeric?
	jnz	if56

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if57

	mov	p_cntry_code,ax
	jmp	short en57

if57:
	mov	p_code_page,ax
en57:
	jmp	short en56		; path entered

if56:
	push	ds
	push	es
	push	si
	push	di

	push	cs
	pop	es

	lds	si,rv_dword		; move the path to known place.
	mov	di,offset cntry_drv
	call	move_asciiz

	pop	di
	pop	si
	pop	es
	pop	ds

en56:
	jmp	do52

sr52:
	cmp	p_cntry_code,-1		; had a parse error?
	jne	tryq_open
	jmp	coff

tryqbad:				;"invalid country code or code page"
       stc
       mov     dx,offset badcountry
ifndef NEC_98
ifdef	JAPAN
	pushf
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badcountry2
@@:
	popf
endif
else    ;NEC_98
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badsiz_pre2
@@:
endif
endif   ;NEC_98
       jmp     tryqchkerr

tryq_open:
	cmp	cntry_drv,0
	je	tryq_def
	mov	dx,offset cntry_drv
	jmp	short tryq_openit

tryq_def:
	mov	dx,offset cntry_root
tryq_openit:
	mov	ax,3d00h		;open a file
	stc
	int	21h
	jc	tryqfilebad		;open failure

	mov	cs:cntryfilehandle,ax	;save file handle
	mov	bx,ax
	mov	ax,cs:p_cntry_code
	mov	dx,cs:p_code_page	; now,ax=country id,bx=filehandle
	mov	cx,cs:[memhi]
	add	cx,384			; need 6k buffer to handle country.sys
					; M023
	cmp	cx,cs:[alloclim]
	ja	tryqmemory		;cannot allocate the buffer for country.sys

	mov	si,offset cntry_drv	;ds:si -> cntry_drv
	cmp	byte ptr [si],0 	;default path?
	jne	tryq_set_for_dos

	inc	si
	inc	si			;ds:si -> cntry_root

tryq_set_for_dos:
	les	di,cs:sysi_country	;es:di -> country info tab in dos
	push	di			;save di
	add	di,ccpath_countrysys
	call	move_asciiz		;set the path to country.sys in dos.
	pop	di			;es:di -> country info tab again.

	mov	cx,cs:[memhi]
	mov	ds,cx
	xor	si,si			;ds:si -> 2k buffer to be used.
	call	setdoscountryinfo	;now do the job!!!
	jnc	tryqchkerr		;read error or could not find country,code page combination

	cmp	cx,-1			;could not find matching country_id,code page?
	je	tryqbad 		;then "invalid country code or code page"

tryqfilebad:
	push	cs
	pop	es
	cmp	cs:cntry_drv,0		;is the default file used?
	je	tryqdefbad

	mov	si,offset cntry_drv
	jmp	short tryqbadload

tryqdefbad:				;default file has been used.
	mov	si,offset cntry_root	;es:si -> \country.sys in sysinit_seg
tryqbadload:
	call	badload 		;ds will be restored to sysinit_seg
	mov	cx,cs:[confbot]
	mov	es,cx			;restore es -> confbot.
	jmp	short coffj4

tryqmemory:
	mov	dx,offset insufmemory
ifdef	JAPAN
	pushf
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset insufmemory2
@@:
	popf
endif
tryqchkerr:
	mov	cx,cs:[confbot]
	mov	es,cx			;restore es -> confbot seg
	push	cs
	pop	ds			;retore ds to sysinit_seg
	jnc	coffj4			;if no error,then exit

	call	print			;else show error message
	call	error_line

coffj4:
	mov	bx,cntryfilehandle
	mov	ah,3eh
	int	21h			;close a file. don't care even if it fails.
	jmp	coff

cntry_error	proc	near

;function: show "invalid country code or code page" messages,or
;		"error in country command" depending on the error code
;		in ax returned by sysparse;
;in:	ax - error code
;	ds - sysinitseg
;	es - confbot
;out:	show message.  dx destroyed.

	cmp	ax,$p_out_of_range
	jnz	if64
	mov	dx,offset badcountry	;"invalid country code or code page"
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badcountry2
@@:
endif
	jmp	short en64

if64:
	mov	dx,offset badcountrycom ;"error in contry command"
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badcountrycom2
@@:
endif
en64:
	call	print
	call	error_line
	ret
cntry_error	endp

;------------------------------------------------------------------------------
; files command
;------------------------------------------------------------------------------
;*******************************************************************************
; function: parse the parameters of files= command.			       *
;									       *
; input :								       *
;	es:si -> parameters in command line.				       *
; output:								       *
;	variable files set.						       *
;									       *
; subroutines to be called:						       *
;	sysinit_parse							       *
; logic:								       *
; {									       *
;	set di points to files_parms;					       *
;	set dx,cx to 0; 						       *
;	while (end of command line)					       *
;	{ sysinit_parse;						       *
;	  if (no error) then						       *
;	     files = result_val.$p_picked_val				       *
;	  else								       *
;	     error exit;						       *
;	};								       *
; };									       *
;									       *
;*******************************************************************************
tryf:
	cmp	ah,'F'
	jnz	tryl

	mov	di,offset files_parms
	xor	cx,cx
	mov	dx,cx

do67:
	call	sysinit_parse
        jnc     if67                    ; parse error

; sudeepb - 27-Feb-1997
; if a bad value is found, set it to DOS default i.e. 20. If its WOW VDM
; the BOP will return the right value.
        mov     p_files,20


;       call    badparm_p              ;   and show messages and end the search loop.
        jmp     short en67

if67:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en67			; then end the $endloop
	mov	al,byte ptr result_val.$p_picked_val
	mov	p_files,al		; save it temporarily
	jmp	short do67

en67:
	mov	al,p_files
	SVC	SVC_DEMWOWFILES 	; For WOW VDM Set the file= to max.
	mov	files,al		; no error. really set the value now.

sr67:
	jmp	coff

;------------------------------------------------------------------------------
; lastdrive command
;------------------------------------------------------------------------------
;*******************************************************************************
; function: parse the parameters of lastdrive= command. 		       *
;									       *
; input :								       *
;	es:si -> parameters in command line.				       *
; output:								       *
;	set the variable num_cds.					       *
;									       *
; subroutines to be called:						       *
;	sysinit_parse							       *
; logic:								       *
; {									       *
;	set di points to ldrv_parms;					       *
;	set dx,cx to 0; 						       *
;	while (end of command line)					       *
;	{ sysinit_parse;						       *
;	  if (no error) then						       *
;	     set num_cds to the returned value; 			       *
;	  else	/*error exit*/						       *
;	     error exit;						       *
;	};								       *
; };									       *
;									       *
;*******************************************************************************

tryl:
	cmp	ah,'L'
        jnz     tryp
        jmp     coff

;NTVDM Ignore the lastdrive command. Dos will figure this from the host OS.
;      17-Aug-1992 Jonle
if 0

	mov	di,offset ldrv_parms
	xor	cx,cx
	mov	dx,cx

do73:
	call	sysinit_parse
	jnc	if73		; parse error
	call	badparm_p	;   and show messages and end the search loop.
	jmp	short sr73

if73:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en73		; then end the $endloop
	mov	al,rv_byte	; pick up the drive number
	mov	p_ldrv,al	; save it temporarily
	jmp	do73

en73:
	mov	al,p_ldrv
	mov	num_cds,al	; no error. really set the value now.
sr73:
        jmp     coff
endif


;--------------------------------------------------------------------------
; setting drive parameters
;--------------------------------------------------------------------------

tryp:
	cmp	ah,'P'
        jnz     tryk
        jmp     coff

; sudeepb 04-Mar-1991 : Ignoring DRIVEPARM command
;       call    parseline
;       jc      trypbad
;
;	call	setparms
;	call	diddleback
;	jc	trypbad
;       jmp     coff
;trypbad:jmp     badop

;--------------------------------------------------------------------------
; setting internal stack parameters
; stacks=m,n where
;	m is the number of stacks (range 8 to 64,default 9)
;	n is the stack size (range 32 to 512 bytes,default 128)
; j.k. 5/5/86: stacks=0,0 implies no stack installation.
;	any combinations that are not within the specified limits will
;	result in "unrecognized command" error.
;--------------------------------------------------------------------------

;****************************************************************************
;									    *
; function: parse the parameters of stacks= command.			    *
;	    the minimum value for "number of stacks" and "stack size" is    *
;	    8 and 32 each.  in the definition of sysparse value list,they   *
;	    are set to 0.  this is for accepting the exceptional case of    *
;	    stacks=0,0 case (,which means do not install the stack.)	    *
;	    so,after sysparse is done,we have to check if the entered	    *
;	    values (stack_count,stack_size) are within the actual range,    *
;	    (or if "0,0" pair has been entered.)			    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	set the variables stack_count,stack_size.			    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di points to stks_parms;					    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	     { if (cx == 1) then /* first positional = stack count */	    *
;		   p_stack_count = result_val.$p_picked_val;		    *
;	       if (cx == 2) then /* second positional = stack size */	    *
;		   p_stack_size = result_val.$p_picked_val;		    *
;	     }								    *
;	  else	/*error exit*/						    *
;	     error exit;						    *
;	};								    *
;	here check p_stack_count,p_stack_size if it meets the condition;    *
;	if o.k.,then set stack_count,stack_size;			    *
;	 else error_exit;						    *
; };									    *
;****************************************************************************

tryk:
ifndef NEC_98
	cmp	ah,'K'
	je	do_tryk
	jmp	trys

		if	stacksw

do_tryk:
	mov	di,offset stks_parms
	xor	cx,cx
	mov	dx,cx

do79:
	call	sysinit_parse
	jnc	if79			; parse error

	mov	dx,offset badstack	; "invalid stack parameter"
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badstack2
@@:
endif
	call	print			;  and show messages and end the search loop.
	call	error_line
	jmp	sr79

if79:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en79			; then end the $endloop

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if83

	mov	p_stack_count,ax
	jmp	short en83

if83:
	mov	p_stack_size,ax
en83:
	jmp	do79

en79:
	cmp	p_stack_count,0
	jz	if87

	cmp	p_stack_count,mincount
	jb	ll88
	cmp	p_stack_size,minsize
	jnb	if88

ll88:
	mov	p_stack_count,-1	; invalid
if88:
	jmp	short en87

if87:
	cmp	p_stack_size,0
	jz	en87
	mov	p_stack_count,-1	; invalid
en87:
	cmp	p_stack_count,-1	; invalid?
	jnz	if94

	mov	stack_count,defaultcount ;reset to default value.
	mov	stack_size,defaultsize
	mov	word ptr stack_addr,0

	mov	dx,offset badstack
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badstack2
@@:
endif
	call	print
	call	error_line
	jmp	short sr79

if94:
	mov	ax,p_stack_count
	mov	stack_count,ax
	mov	ax,p_stack_size
	mov	stack_size,ax
	mov	word ptr stack_addr,-1	; stacks= been accepted.
sr79:
	jmp	coff

	endif
else    ;NEC_98
	if	stacksw

	cmp	ah,'K'
	je	do_tryk
	jmp	trys

do_tryk:
	mov	di,offset stks_parms
	xor	cx,cx
	mov	dx,cx

do79:
	call	sysinit_parse
	jnc	if79			; parse error

	mov	dx,offset badstack	; "invalid stack parameter"
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badstack2
@@:
endif
	call	print			;  and show messages and end the search loop.
	call	error_line
	jmp	sr79

if79:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en79			; then end the $endloop

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if83

	mov	p_stack_count,ax
	jmp	short en83

if83:
	mov	p_stack_size,ax
en83:
	jmp	do79

en79:
	cmp	p_stack_count,0
	jz	if87

	cmp	p_stack_count,mincount
	jb	ll88
	cmp	p_stack_size,minsize
	jnb	if88

ll88:
	mov	p_stack_count,-1	; invalid
if88:
	jmp	short en87

if87:
	cmp	p_stack_size,0
	jz	en87
	mov	p_stack_count,-1	; invalid
en87:
	cmp	p_stack_count,-1	; invalid?
	jnz	if94

	mov	stack_count,defaultcount ;reset to default value.
	mov	stack_size,defaultsize
	mov	word ptr stack_addr,0

	mov	dx,offset badstack
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badstack2
@@:
endif
	call	print
	call	error_line
	jmp	short sr79

if94:
	mov	ax,p_stack_count
	mov	stack_count,ax
	mov	ax,p_stack_size
	mov	stack_size,ax
	mov	word ptr stack_addr,-1	; stacks= been accepted.
sr79:
	jmp	coff

	endif
endif   ;NEC_98

;------------------------------------------------------------------------
; shell command
;------------------------------------------------------------------------

trys:
	cmp	ah,'S'
	jnz	tryx

	mov	[command_line+1],0
	mov	di,offset commnd + 1
	mov	[di-1],al

storeshell:
	call	getchr
	or	al,al
	jz	getshparms

	cmp	al," "
	jb	endsh

	mov	[di],al
	inc	di
	jmp	storeshell

endsh:
	mov	byte ptr [di],0
;	push	di
;	mov	di,offset commnd
;	SVC	SVC_SETSHELLNAME
;	pop	di

	call	getchr
	cmp	al,lf
	jnz	conv

	call	getchr
conv:	jmp	conflp

getshparms:
	mov	byte ptr [di],0
	mov	di,offset command_line+1

parmloop:
	call	getchr
	cmp	al," "
	jb	endsh
	mov	[di],al
	inc	di
	jmp	parmloop

;------------------------------------------------------------------------
; fcbs command
;------------------------------------------------------------------------

;************************************************************************
; function: parse the parameters of fcbs= command.			*
;									*
; input :								*
;	es:si -> parameters in command line.				*
; output:								*
;	set the variables fcbs,keep.					*
;									*
; subroutines to be called:						*
;	sysinit_parse							*
; logic:								*
; {									*
;	set di points to fcbs_parms;					*
;	set dx,cx to 0; 						*
;	while (end of command line)					*
;	{ sysparse;							*
;	  if (no error) then						*
;	     { if (cx == 1) then /* first positional = fcbs */		*
;		   fcbs = result_val.$p_picked_val;			*
;	       if (cx == 2) then /* second positional = keep */ 	*
;		   keep = result_val.$p_picked_val;			*
;	     }								*
;	  else	/*error exit*/						*
;	     error exit;						*
;	};								*
; };									*
;************************************************************************

tryx:
	cmp	ah,'X'
	jnz	tryy

	mov	di,offset fcbs_parms
	xor	cx,cx
	mov	dx,cx

do98:
	call	sysinit_parse
	jnc	if98			; parse error
	call	badparm_p		;  and show messages and end the search loop.
	jmp	short sr98

if98:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en98		; then end the $endloop

	mov	al,byte ptr result_val.$p_picked_val
	cmp	cx,1		; the first positional?
	jnz	if102
	mov	p_fcbs,al
	jmp	short en102

if102:
	mov	p_keep,al
en102:
	jmp	do98

en98:
	mov	al,p_fcbs	; M017
	mov	fcbs,al		; M017
	mov	keep,0		; M017
sr98:
	jmp	coff

;-------------------------------------------------------------------------
; comment= do nothing. just decrese chrptr,and increase count for correct
;		line number
;-------------------------------------------------------------------------

tryy:
	cmp	ah,'Y'
	jne	try0

donothing:
	dec	chrptr
	inc	count
	jmp	coff

;------------------------------------------------------------------------
; rem command
;------------------------------------------------------------------------

try0:				;do nothing with this line.
	cmp	ah,'0'
	je	donothing

;-----------------------------------------------------------------------
; switches command
;-----------------------------------------------------------------------
;****************************************************************************
;									    *
; function: parse the option switches specified.			    *
; note - this command is intended for the future use also.  when we need to *
; to set system data flag,use this command.				    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	p_swit_k set if /k option chosen.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di points to swit_parms;  /*parse control definition*/	    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val.$p_synonym_ptr == swit_k) then		    *
;		    p_swit_k = 1					    *
;	       endif							    *
;	  else {show error message;error exit}				    *
;	};								    *
; };									    *
;									    *
;****************************************************************************

	cmp	ah,'1'		;switches= command entered?
	je	do_try1
	jmp	tryt
do_try1:
	mov	di,offset swit_parms
	xor	cx,cx
	mov	dx,cx

do110:
	call	sysinit_parse
	jnc	if110		; parse error
	call	badparm_p	;  and show messages and end the search loop.
	jmp	short sr110

if110:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en110		; then jmp to $endloop for semantic check

	cmp	result_val.$p_synonym_ptr,offset swit_k
	jnz	if115		;				;M059
	mov	p_swit_k,1	; set the flag
	jmp	do110
if115:								;M059
	cmp	result_val.$p_synonym_ptr, offset swit_t	;M059
	jne	if116						;M059 M063
	mov	p_swit_t, 1					;M059
	jmp	do110						;M059
if116:
	cmp	result_val.$p_synonym_ptr, offset swit_w	;M063
	jne	do110						;M063
	mov	p_swit_w, 1					;M063
	jmp	do110						;M063
en110:
	cmp	p_swit_k,1	;if /k entered,

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data
	jnz	if117
	mov	keyrd_func,0	;use the conventional keyboard functions
	mov	keysts_func,1
if117:
ifndef NEC_98
;	mov	al, p_swit_t					;M059
else    ;NEC_98
	mov	al, p_swit_t					;M059
endif   ;NEC_98
;	mov	t_switch, al					;M059

	cmp	p_swit_w, 0					;M063
	je	skip_dos_flag					;M063
	push	es
	push	bx
	mov	ah, GET_IN_VARS					;M063
	int	21h						;M063
	or	byte ptr es:[DOS_FLAG_OFFSET], SUPPRESS_WINA20	;M063
	pop	bx
	pop	es
skip_dos_flag:							;M063
	pop	ds
	assume	ds:sysinitseg

sr110:
	jmp	coff

;------------------------------------------------------------------------
; NTCMDPROMPT command. This command forces SCS functionality to use
; cmd.exe prompt rather than command.com's prompt on shelling out
; and on finding a TSR.
;------------------------------------------------------------------------
tryt:
	cmp	ah,'T'
	je	tryt_5
        jmp     short tryo

tryt_5:
	push	si
	push	bp
	xor	ax,ax
	mov	bp,ax
	mov	si,ax
	mov	al,4
	mov	ah,setdpb
	int	21h
	pop	bp
	pop	si
	jmp	coff

;------------------------------------------------------------------------
; DOSONLY command. This command forces only DOS binaries to run from
; command.com prompt. non_dos binaries will putup the stub message
; of unable to run it under DOS.
;------------------------------------------------------------------------
tryo:
        cmp     ah,'O'
        je      tryo_5
        jmp     short tryz

tryo_5:
	push	si
	push	bp
	xor	ax,ax
	mov	bp,ax
	mov	si,ax
        mov     al,6
	mov	ah,setdpb
	int	21h
	pop	bp
	pop	si
        jmp     coff

;------------------------------------------------------------------------
; bogus command
;------------------------------------------------------------------------

tryz:
	cmp	ah,0ffh
	je	tryff

	dec	chrptr
	inc	count
	jmp	short badop

;------------------------------------------------------------------------
; null command
;------------------------------------------------------------------------

tryff:				;skip this command.
	jmp	donothing

doconf	endp

;------------------------------------------------------------------------------

sysinit_parse	proc
;set up registers for sysparse
;in)	es:si -> command line in  confbot
;	di -> offset of the parse control defintion.
;
;out)	calls sysparse.
;	carry will set if parse error.
;	*** the caller should check the eol condition by looking at ax
;	*** after each call.
;	*** if no parameters are found,then ax will contain a error code.
;	*** if the caller needs to look at the synomym@ of the result,
;	***  the caller should use cs:@ instead of es:@.
;	cx register should be set to 0 at the first time the caller calls this
;	 procedure.
;	ax - exit code
;	bl - terminated delimeter code
;	cx - new positional ordinal
;	si - set to pase scanned operand
;	dx - selected result buffer

	push	es			;save es,ds
	push	ds

	push	es
	pop	ds			;now ds:si -> command line

	push	cs
	pop	es			;now es:di -> control definition

	mov	cs:badparm_seg,ds	;save the pointer to the parm
	mov	cs:badparm_off,si	; we are about to parse for badparm msg.
	mov	dx,0
	call	sysparse
	cmp	ax,$p_no_error		;no error

;**cas note:  when zero true after cmp, carry clear

	jz	ll4
	cmp	ax,$p_rc_eol		;or the end of line?
	jnz	if4

ll4:
	clc
	jmp	short en4

if4:
	stc
en4:
	pop	ds
	pop	es
	ret
sysinit_parse	endp

;
;----------------------------------------------------------------------------
;
; procedure : badop_p
;
;             same thing as badop,but will make sure to set ds register back
;             to sysinitseg and return back to the caller.
;
;----------------------------------------------------------------------------
;
badop_p proc	near


	push	cs
	pop	ds			;set ds to configsys seg.
	mov	dx,offset badopm
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badopm2
@@:
endif
	call	print
	call	error_line
	ret

badop_p endp
;
;----------------------------------------------------------------------------
;
; label : badop
;
;----------------------------------------------------------------------------
;
badop:	mov	dx,offset badopm	;want to print command error "unrecognized command..."
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badopm2
@@:
endif
	call	print
	call	error_line		;show "error in config.sys ..." .
	jmp	coff


;
;----------------------------------------------------------------------------
;
; procedure : badparm_p
;
;             show "bad command or parameters - xxxxxx"
;             in badparm_seg,badparm_off -> xxxxx
;
;----------------------------------------------------------------------------
;
badparm_p	proc	near


	push	ds
	push	dx
	push	si

	push	cs
	pop	ds

	mov	dx,offset badparm
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badparm2
@@:
endif
	call	print			;"bad command or parameters - "
	lds	si,badparm_ptr

;	print "xxxx" until cr.

do1:
	mov	dl,byte ptr [si]	; get next character
	cmp	dl,cr			; is a carriage return?
	jz	en1			; exit loop if so

	mov	ah,std_con_output	; function 2
	int	21h			; display character
	inc	si			; next character
	jmp	do1
en1:
	push	cs
	pop	ds

	mov	dx,offset crlfm
	call	print
	call	error_line

	pop	si
	pop	dx
	pop	ds
badparmp_ret:
	ret
badparm_p	endp

;
;----------------------------------------------------------------------------
;
; procedure : getchr
;
;----------------------------------------------------------------------------
;
getchr	proc	near
	push	cx
	mov	cx,count
	jcxz	nochar

	mov	si,chrptr
	mov	al,es:[si]
	dec	count
	inc	chrptr
	clc
get_ret:
	pop	cx
	ret

nochar: stc
	jmp	short get_ret
getchr	endp

;
;----------------------------------------------------------------------------
;
; procedure : incorrect_order
;
;             show "incorrect order in config.sys ..." message.
;
;----------------------------------------------------------------------------
;

incorrect_order proc	near

	mov	dx,offset badorder
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badorder2
@@:
endif
	call	print
	call	showlinenum
	ret

incorrect_order endp

;
;----------------------------------------------------------------------------
;
; procedure : error_line
;
;             show "error in config.sys ..." message.
;
;----------------------------------------------------------------------------
;
		public	error_line
error_line	proc	near


	push	cs
	pop	ds
	mov	dx,offset errorcmd
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset errorcmd2
@@:
endif
	call	print
	call	showlinenum
	ret

error_line	endp

;
;----------------------------------------------------------------------------
;
; procedure : showlinenum
;
; convert the binary linecount to decimal ascii string in showcount
;and display showcount at the current curser position.
;in.) linecount
;
;out) the number is printed.
;
;----------------------------------------------------------------------------
;
showlinenum	proc	near


	push	es
	push	ds
	push	di

	push	cs
	pop	es		; es=cs

	push	cs
	pop	ds

	mov	di,offset showcount+4	; di -> the least significant decimal field.
	mov	cx,10			; decimal devide factor
	mov	ax,cs:linecount

sln_loop:
	cmp	ax,10			; < 10?
	jb	sln_last

	xor	dx,dx
	div	cx
	or	dl,30h			; add "0" (= 30h) to make it an ascii.
	mov	[di],dl
	dec	di
	jmp	sln_loop

sln_last:
	or	al,30h
	mov	[di],al
	mov	dx,di
	call	print			; show it.
	pop	di
	pop	ds
	pop	es
	ret
showlinenum	endp

comment ^
set_devmark	proc	near
;***************************************************************************
; function: set a paragraph of informations infront of a device file or    *
;	    an ifs file to be loaded for mem command.			   *
;	    the structure is:						   *
;	      devmark_id	byte "d" for device,"i" for ifs		   *
;	      devmark_size	size in para for the device loaded	   *
;	      devmark_filename	11 bytes. filename			   *
;									   *
; input :								   *
;	    [memhi] = address to set up devmark.			   *
;	    [memlo] = 0 						   *
;	    es:si -> pointer to [drive][path]filename,0 		   *
;	    [ifs_flag] = is_ifs bit set if ifs= command.		   *
;									   *
; output:   devmark_id,devmark_filename set				   *
;	    cs:[devmark_addr] set.					   *
;	    ax,cx register destroyed.					   *
;***************************************************************************

	push	ds
	push	si
	push	es
	push	di

	mov	di,cs:[memhi]
	mov	ds,di
	assume	ds:nothing
	mov	[devmark_addr],di	; save the devmark address for the future.
	mov	ds:[devmark_id],devmark_device	; 'd'
	inc	di
	mov	ds:[devmark_seg],di
	xor	al,al
	push	si
	pop	di			; now es:si = es:di = [path]filename,0
	mov	cx,128			; maximum 128 char
	repnz	scasb			; find 0
	dec	di			; now es:di-> 0
sdvmk_backward: 			; find the pointer to the start of the filename.
	mov	al,byte ptr es:[di]	; we do this by check es:di backward until
	cmp	al,'\' 		        ; di = si or di -> '\' or di -> ':'.
	je	sdvmk_gotfile
	cmp	al,':'
	je	sdvmk_gotfile
	cmp	di,si
	je	sdvmk_fileptr
	dec	di
	jmp	sdvmk_backward
sdvmk_gotfile:
	inc	di
sdvmk_fileptr:				; now es:di -> start of file name
	push	di			; cas - holy sh*t!!!  CODE!
	pop	si			; save di to si.

	push	ds			; switch es,ds
	push	es
	pop	ds
	pop	es			; now,ds:si -> start of filename

	mov	di,devmark_filename
	push	di
	mov	al,' '
	mov	cx,8
	rep	stosb			; clean up memory.
	pop	di
	mov	cx,8			; max 8 char. only
sdvmk_loop:
	lodsb
	cmp	al,'.'
	je	sdvmk_done
	cmp	al,0
	je	sdvmk_done
	stosb
	loop	sdvmk_loop

sdvmk_done:
	pop	di
	pop	es
	pop	si
	pop	ds
	ret
set_devmark	endp
^
; =========================================================================
;reset_dos_version	proc	near
;
;;function: issue ax=122fh,dx=0,int 2fh to restore the dos version.
;
;	push	ax
;	push	dx
;	mov	ax,122fh
;	mov	dx,0
;	int	2fh
;	pop	dx
;	pop	ax
;	ret
;reset_dos_version	endp
;
;
; =========================================================================

IFDEF	DONT_LOAD_OS2_DD		; M045

EXE_SIG		EQU	5a4dh		; .EXE file signature
OS2_SIG 	EQU	454eh		; OS2 .EXE file signature

SIGNATURE_LEN	EQU	2		; Lenght of .EXE signature in bytes
SIZE_DWORD	EQU	4

SEG_SIG_OFFSET	EQU	18h		; Offset of segmented .EXE signature
SEG_EXE_SIG	EQU	40h		; Signature of a segmented .EXE file
SEG_HEADER_PTR	EQU	3ch		; Offsets of ptr to segmented header

; =========================================================================
; CheckForOS2 PROC
;
; Examines an open file to see if it is really an OS2 executable file.
;
; REGISTERS:	AX	- Open file handle
; RETURNS:	Carry	- Carry set if file is an OS2 executable or error.
; DESTROYS:	NOTHING
;		NOTE:	The file ptr is assumed to be set to start of file
;			on entry and is not reset to begining of the file
;			on exit.
;
; Strategy:	If word value at 00h == 454eh file is OS2
;		else if word value at 00h == 5a4dh and
;		        (word value at 18h == 40h and the dword ptr at 3ch
;			 points to word value of 454eh) file is OS2.
;
; =========================================================================

CheckForOS2 PROC NEAR

	push	AX
	push	BX
	push	CX
	push	DX
	push	DS
	push	BP

	push	CS				; BUGBUG
	pop	DS				; NOT ROM DOS COMPATIBLE

	mov	BX,AX				; Put open file handle in BX
	mov	BP,offset DS:Os2ChkBuf		; Save buff offset for latter

		; First we need to read in the first 2 bytes of the file
		; to see if it's an OS2 .EXE file and if not see if 
		; it is a DOS .EXE file. 

	mov	AX,(read shl 8)			; AH = DOS read function
	mov	CX,SIGNATURE_LEN		; CX = size of word value
	mov	DX,BP				; DS:DX --> tmp buffer
	int	21h
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

	mov	AX, WORD PTR DS:Os2ChkBuf
	cmp	AX, OS2_SIG			; Check for 454eh
	je	IsOS2				; Return is OS2 if match
	cmp	AX, EXE_SIG			; Now see if it's a DOS .EXE
	jne	NotOS2				; If no match can't be OS2

		; Here we know the file has a valid DOS .EXE signature so
		; now we need to see if it's a segmented .EXE file by looking
		; for the segmented .EXE signature at file offset 18h

	mov	AX,(lseek shl 8)		; AX = Seek from begining
	xor	CX,CX
	mov	DX,SEG_SIG_OFFSET		; CX:DX = offset of segmented
	int	21h				; Seek to offset 18h
	jc	OS2ChkExit			; Return carry on error

	mov	AX,read shl 8			; AX = Read file
	mov	CX,SIGNATURE_LEN		; CX = size of word value
	mov	DX,BP				; Restore buffer offset
	int	21h 				; DS:DX -> buffer
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

	cmp	WORD PTR DS:Os2ChkBuf,SEG_EXE_SIG ; Chk for segmented .EXE file
	jne	NotOS2				; Can't be OS2 if no match

		; Here we know we have a segmented .EXE file so we have
		; to get the offset of the start of the segmented  header
		; from offset 3ch in the file.

	mov	AX,(lseek shl 8)		; AX = Seek from begining
	xor	CX,CX
	mov	DX,SEG_HEADER_PTR		; CX:DX = offset of head ptr
	int	21h				; Seek to offset 3ch
	jc	OS2ChkExit			; Return carry on error

	mov	AX,(read shl 8)			; AX = Read file
	mov	CX,SIZE_DWORD			; CX = size of dword (4 bytes)
	mov	DX,BP				; Restore buffer offset
	int	21h 				; Read in 4 byte offset
	jc	OS2ChkExit			; Return carry on error

	cmp	AX,SIZE_DWORD			; Check number of byte read
	jne	NotOs2				; Must be at end of file

		; At this point OS2ChkBuf has a 4 byte offset into the file
		; to the start of a segmented .EXE header so we need to read
		; the 2 bytes at this location to see if they are 454eh

	mov	DX,WORD PTR DS:Os2ChkBuf
	mov	CX,WORD PTR DS:Os2ChkBuf[2]	; CX:DX = offset of new header
	mov	AX,(lseek shl 8)		; AX = Seek from begining
	int	21h				; Seek to offset 3ch
	jc	OS2ChkExit			; Return carry on error

	mov	AX,(read shl 8)			; AX = Read file
	mov	CX,SIGNATURE_LEN		; CX = size of word (2 bytes)
	mov	DX,BP				; DS:DX --> Os2ChkBuf
	int	21h 				; Read in 4 byte offset
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

		; We have the segmented .EXE header in OS2ChkBuf so all
		; we have left to do is see if it's a .EXE signature.

	cmp	WORD PTR DS:OS2ChkBuf,OS2_SIG	; Check for 454eh
	jne	NotOs2				; Not OS2 if it doesn't match

IsOs2:
	stc					; Signal error or OS2 .EXE
	jmp	SHORT OS2ChkExit
NotOs2:
	clc					; Signal no err and not OS2

OS2ChkExit:
	pop	BP
	pop	DS
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret

CheckForOS2 ENDP

ENDIF						; M045

;
;----------------------------------------------------------------------------
;
; procedure : ProcDOS
;
;	Process the result of DOS= parsing
;
;	result_val.$p_item_tag	= 1 for DOS=HIGH
;				= 2 for DOS=LOW
;				= 3 for DOS=UMB
;				= 4 for DOS=NOUMB
;----------------------------------------------------------------------------
;
ProcDOS	proc	near
	assume	ds:nothing, es:nothing
	xor	ah, ah
	mov	al, result_val.$p_item_tag
	dec	ax
	jz	pd_hi
	dec	ax
	jz	pd_lo
	dec	ax
	jz	pd_umb
	mov	DevUMB, 0
	ret
pd_umb:
	mov	DevUMB, 0ffh
	ret
pd_lo:
	mov	runhigh, 0
	ret
pd_hi:
	mov	runhigh, 0ffh
	ret
ProcDOS	endp

;
;----------------------------------------------------------------------------
;
; procedure : LieInt12Mem
;
;	Input : DevEntry points to Device Start address (offset == 0)
;		alloclim set to the limit of low memory.
;
;	Output : none
;
;	Changes the ROM BIOS variable which stores the total low memory
;	If a 3com device driver (any character device with name 'PROTMAN$')
;	is being loaded alloclim is converted into Ks and stored in 40:13h
;	Else if a device driver being loaded into UMB the DevLoadEnd is
;	converted into Ks and stored in 40:13h
;
;----------------------------------------------------------------------------
;
LieInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		mov	ax, alloclim		; lie INT 12 as alloclim
						; assuming that it is 3Com
		call	IsIt3Com?		; Is it 3Com driver?
		je	lim_set			; yes, lie to him differently
		cmp	DeviceHi, 0		; Is the DD being loaded in UMB
		je	limx			; no, don't lie
		mov	ax, DevLoadEnd		; lie INT 12 as end of UMB
lim_set:
		call	SetInt12Mem
limx:
		ret
LieInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : SetInt12Mem
;
;	Input : AX = Memory size to be set (in paras)
;	Output : none
;
;	Sets the variable 40:13 to the memory size passed in AX
;	It saves the old value in 40:13 in OldInt12Mem,
;	It also sets a flag Int12Lied to 0ffh, which is checked before
;	restoring the value of 40:13
;
;----------------------------------------------------------------------------
;
SetInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		push	ds
		mov	bx, 40h
		mov	ds, bx			; ROM BIOS Data Segment
		mov	bx, word ptr ds:[13h]	; INT 12 memory variable
		mov	OldInt12Mem, bx		; save it
		mov	cl, 6
		shr	ax, cl			; convert paras into Ks
		mov	word ptr ds:[13h], ax	; Lie
		mov	Int12Lied, 0ffh		; mark that we are lying
		pop	ds
		ret
SetInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : TrueInt12Mem
;
;	Input : Int12Lied = 0 if we are not lying currently
;			  = 0ffh if we are lying
;		OldInt12Mem = Saved value of 40:13h
;
;	Output : none
;
;	Resets the INT 12 Memory variable if we were lying about int 12
;	and resets the flag which indicates that we were lying
;
;----------------------------------------------------------------------------
;
TrueInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		cmp	Int12Lied, 0		; were we lying so far?
		mov	Int12Lied, 0		; reset it anyway
		je	timx			; no, we weren't
		push	ds
		mov	ax, 40h
		mov	ds, ax
		mov	ax, OldInt12Mem
		mov	word ptr ds:[13h], ax	; restore INT 12 memory
		pop	ds
timx:
		ret
TrueInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : IsIt3Com?
;
;	Input : DevEntry = Seg:0 of device driver
;	Output : Zero flag set if device name is 'PROTMAN$'
;		 else Zero flag is reset
;
;----------------------------------------------------------------------------
;
IsIt3Com?	proc	near
		assume	ds:nothing, es:nothing, ss:nothing
		push	ds
		push	es
		push	si
		lds	si, DevEntry		; ptr to device header
		add	si, sdevname		; ptr device name
		push	cs
		pop	es
		mov	di, offset ThreeComName
		mov	cx, 8			; name length
		rep	cmpsb
		pop	si
		pop	es
		pop	ds
		ret
IsIt3Com?	endp

;M020 : BEGIN
;
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;
UpdatePDB	proc	near
		assume	ds:nothing
		push	ds
		mov	ah, 62h
		int	21h
		mov	ds, bx
		mov	bx, alloclim
		mov	ds:[PDB_Block_Len], bx
		pop	ds
		ret
UpdatePDB	endp
;
; M020 : END
;
;----------------------------------------------------------------------------
;
; procedure : InitDevLoad
;
;	Input : DeviceHi = 0 indicates load DD in low memory
;			 = 1 indicates load in UMB
;		DevSize  = Size of the device driver file in paras
;
;	Output : none
;
;	Initializes DevLoadAddr, DevLoadEnd & DevEntry.
;	Also sets up a header for the Device driver entry for mem utility
;
;----------------------------------------------------------------------------
;
InitDevLoad	proc	near

		assume	ds:nothing, es:nothing

		cmp	DeviceHi, 0		; Are we loading in UMB
		je	InitForLo		; no, init for lo mem
		call	SpaceInUMB?		; Do we have space left in the
						;  current UMB ?
		jnc	InitForHi		; yes, we have
		call	ShrinkUMB		; shrink the current UMB in use
		call	GetUMBForDev		; else try to allocate new UMB
		jc	InitForLo		; we didn't succeed, so load
						;  in low memory
InitForHi:
		mov	ax, DevUMBFree		; get Para addr of free mem
		mov	dx, DevUMBAddr		; UMB start addr
		add	dx, DevUMBSize		; DX = UMB End addr
		jmp	short idl1
		
InitForLo:
		mov	DeviceHi, 0		; in case we failed to load
						;  into UMB indicate that we
						;  are loading low
		mov	ax, memhi		; AX = start of Low memory
		mov	dx, alloclim		; DX = End of Low memory
idl1:
		call	DevSetMark		; setup a sub-arena for DD
		mov	DevLoadAddr, ax		; init the Device load address
		mov	DevLoadEnd, dx		; init the limit of the block
		mov	word ptr DevEntry, 0	; init Entry point to DD
		mov	word ptr DevEntry+2, ax
		ret
InitDevLoad     endp


;------------------------------------------------------------------
; NTVDM  08-Dec-1992 Jonle
;
; AllocUMBLow- Allocates a chunk from memory from UMB area
;              or from low memory area in case UMB memory
;              is unavailable.
;
; The arena is marked as
;
; Input:  es:di addr of arena name to copy
;         cx    size to allocate
;
; Output: es:di points to memory allocated
;
;------------------------------------------------------------------
AllocUMBLow  proc    near

             assume  ds:nothing, es:nothing

             mov     ax, cx              ; convert size to paras
             add     ax, 18              ; extra for dummy dev header for mem.exe
             call    pararound
             mov     DevSize, ax

             mov     word ptr [bpb_addr],   di  ; fake cmd line for dev name
             mov     word ptr [bpb_addr+2], es

             mov     al, DevUMB                 ; we want UMB
             mov     DeviceHi, al

             call    InitDevLoad

             mov     ax, word ptr DevEntry+2    ; mark arena for mem.exe
             dec     ax
             mov     es, ax
             mov     byte ptr es:[devmark_id], devmark_spc

             inc     ax                         ; mark final size
             add     ax, DevSize
             mov     word ptr DevBrkAddr+2,ax
             mov     word ptr DevBrkAddr, 0
             call    DevBreak

             mov     di, word ptr DevEntry      ; es:di -> deventry
             mov     ax, word ptr DevEntry+2
             mov     es, ax

AllocUMBLow  endp


;
;----------------------------------------------------------------------------
;
; procedure : SpaceInUMB?
;
;	Input : DevUMBAddr, DevUMBSize, DevUMBFree & DevSize
;	Output : Carry set if no space in UMB
;		 Carry clear if Space is available for the device in
;		   current UMB
;
;----------------------------------------------------------------------------
;
SpaceInUMB?	proc	near

		assume	ds:nothing, es:nothing

		mov	ax, DevUMBSize
		add	ax, DevUMBAddr		; End of UMB
		sub	ax, DevUMBFree		; - Free = Remaining space
		or	ax, ax			; Nospace ?
		jnz	@f
		stc
		ret
@@:
		dec	ax			; space for sub-arena
		cmp	ax, DevSize		; do we have space ?
		ret
SpaceInUMB?	endp

;
;----------------------------------------------------------------------------
;
; procedure : GetUMBForDev
;
;	Input : DevSize
;	Output : Carry set if couldn't allocate a UMB to fit the
;		 the device.
;		 If success carry clear
;
;	Allocates the biggest UMB for loading devices and updates
;	DevUMBSize, DevUMBAddr & DevUMBFree if it succeeded in allocating
;	UMB.
;
;	This routine relies on the fact that all of the low memory
;	is allocated, and any DOS alloc calls should return memory
;	from the UMB pool.
;
;----------------------------------------------------------------------------
;
GetUMBForDev	proc	near

		assume	ds:nothing, es:nothing

if 0
;;
		mov	bx, 0ffffh
		mov	ax, 4800h
		int	21h

		or	bx, bx
		jz	gufd_err

		dec	bx
		cmp	DevSize, bx
		ja	gufd_err
		inc	bx
		mov	ax, 4800h
		int	21h
		jc	gufd_err

		push	ds
		dec	ax
		mov	ds, ax
		mov	word ptr ds:[arena_owner], 8
		mov	word ptr ds:[arena_name], 'DS'
		inc	ax
		pop	ds

		mov	DevUMBSize, bx		; update the UMB Variables
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		clc				; mark no error
		ret
gufd_err:
		xor	ax, ax
		mov	DevUMBSize, ax		; erase the previous values
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		stc
		ret
else
;; we changed the allocation strategy to best-fit for NT. This is because
;; we want to reserve bigger blocks for loadhigh command. In most case,
;; device drivers are smaller than TSR(ran from loadhigh). This change give
;; us a better chance to load the big tsr like DOSX.EXE to UMB and
;; give applications more free conventional memory.
;; The following implementation seems slow because every time we need an
;; UMB, we go through the chain. This is done because each request has
;; different size - We can grab all UMBs from the very beginning and put
;; them in a list, but we have to maintain the list. -williamh
		push	cx
		push	dx
		push	es
		xor	cx, cx			;; allocated count = 0
		mov	dx, DevSize
		inc	dx			;; minimum size in paras
						;; bios needs its sub-arena
search_for_best_block:
		mov	bx, 0ffffh		;; get largest block size
		mov	ah, 48h 		;; so far
		int	21h
		cmp	bx, dx			;; will this satisfy ours?
		jb	allocate_the_block	;; no, break
		mov	ah, 48h			;; allocate this block
		int	21h
		jc	allocate_the_block	;; failed, use the previous one
		inc	cx			;; we have one more allocated
		push	bx			;; save the size
		push	ax			;; save the address
		jmp	short search_for_best_block

allocate_the_block:
;; the block saved on the top of the stack is the best fit one
;; grab it if there is one
		jcxz	gufd_err		;; no block found, error
		pop	ax			;; get the address
		pop	DevUMBSize		;; and size
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		dec	ax
		push	ds
		mov	ds, ax
		mov	word ptr ds:[arena_owner], 8
		mov	word ptr ds:[arena_name], 'DS'
		pop	ds
		dec	cx
;; now free those unnecessary blocks
		jcxz	allocate_done
free_allocated_blocks:
		pop	es			;; get the address
		add	sp, 2			;; discard the size
		mov	ah, 49h 		;; free it
		int	21h
		loop	free_allocated_blocks
allocate_done:
		clc				; mark no error
		jmp	short GetUMBForDevExit
gufd_err:
		xor	ax, ax
		mov	DevUMBSize, ax		; erase the previous values
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		stc
GetUMBForDevExit:
		pop	es
		pop	dx
		pop	cx
		ret
endif

GetUMBForDev	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevSetMark
;
;	Input : AX - Free segment were device is going to be loaded
;	Output : AX - Segment at which device can be loaded (AX=AX+1)
;
;	Creates a sub-arena for the device driver
;	puts 'D' marker in the sub-arena
;	Put the owner of the sub-arena as (AX+1)
;	Copies the file name into sub-arena name field
;
;	Size field of the sub-arena will be set only at succesful
;	completion of Device load.
;
;----------------------------------------------------------------------------
;
DevSetMark	proc	near

		assume	ds:nothing, es:nothing

		push	es
		push	di
		push	ds
		push	si
		mov	es, ax
		mov	byte ptr es:[devmark_id], devmark_device	; 'D'
		inc	ax
		mov	word ptr es:[devmark_seg], ax
;
;-------------- Copy file name
;
		push	ax			; save load addr
		lds	si, bpb_addr		; command line is still there
;M004 - BEGIN
		mov	di, si
		cld
dsm_again:
		lodsb
		cmp	al, ':'
		jne	isit_slash
		mov	di, si
		jmp	dsm_again
isit_slash:
		cmp	al, '\'
		jne	isit_null
		mov	di, si
		jmp	dsm_again
isit_null:

ifdef DBCS
		call	testkanj
		jz	@f		; if this is not lead byte
		lodsb			; get tail byte
@@:
endif

		or	al, al
		jnz	dsm_again
		mov	si, di
;M004 - END
		mov	di, devmark_filename
		mov	cx, 8			; maximum 8 characters
dsm_next_char:
		lodsb
		or	al, al
		jz	blankout
		cmp	al, '.'
		jz	blankout
		stosb
		loop	dsm_next_char
blankout:
		jcxz	dsm_exit
		mov	al, ' '
		rep	stosb			; blank out the rest
dsm_exit:
		pop	ax			; restore load addr
		pop	si
		pop	ds
		pop	di
		pop	es
		ret
DevSetMark	endp

;
;----------------------------------------------------------------------------
;
; procedure : SizeDevice
;
;	Input : ES:SI - points to device file to be sized
;
;	Output : Carry set if file cannot be opened or if it is an OS2EXE file
;
;	Calculates the size of the device file in paras and stores it
;	in DevSize
;
;----------------------------------------------------------------------------
;
SizeDevice	proc	near

		assume	ds:nothing, es:nothing

		push	es
		pop	ds
		mov	dx, si			; ds:dx -> file name
		mov	ax, 3d00h		; open
		int	21h
		jc	sd_err			; open failed

IFDEF	DONT_LOAD_OS2_DD			; M045
		call	CheckForOS2		; is it a OS2 EXE file ?
		jc	sd_close		; yeah, we dont load them
ENDIF						; M045

		mov	bx, ax			; BX - file handle
		mov	ax, 4202h		; seek
		xor	cx, cx
		mov	dx, cx			; to end of file
		int	21h
		jc	sd_close		; did seek fail (impossible)
		add	ax, 15			; para convert
		adc	dx, 0
		test	dx, 0fff0h		; size > 0ffff paras ?
		jz	@f			; no
		mov	DevSize, 0ffffh		; invalid device size
						; assuming that we fail later
		jmp	short sd_close
@@:
		mov	cl, 4			; conver it to paras
		shr	ax, cl
		mov	cl, 12
		shl	dx, cl
		or	ax, dx			;
		cmp	ax, DevSizeOption
		ja	@f
		mov	ax, DevSizeOption
@@:
		mov	DevSize, ax		; save file size
		clc
sd_close:
		pushf				; let close not spoil our
						;  carry flag
		mov	ax, 3e00h		; close
		int	21h			; we are not checking for err
		popf
sd_err:
		ret
SizeDevice	endp

;
;----------------------------------------------------------------------------
;
; procedure : ExecDev
;
;	Input : ds:dx -> device to be executed
;		DevLoadAddr - contains where device has to be loaded
;
;	Output : Carry if error
;		 Carry clear if no error
;
;	Loads a device driver using the 4b03h function call
;
;----------------------------------------------------------------------------
;
ExecDev		proc	near

		assume	ds:nothing, es:nothing

		mov	bx, DevLoadAddr
		mov	DevExecAddr, bx		; Load the parameter block
						;  block for exec with
						;  Load address
		mov	DevExecReloc, bx
		mov	bx,cs
		mov	es,bx
		mov	bx,offset DevExecAddr	;es:bx points to parameters
		mov	al,3
		mov	ah,exec
		int	21h			;load in the device driver
		ret
ExecDev		endp

;
;----------------------------------------------------------------------------
;
; procedure : RemoveNull
;
;	Input : ES:SI points to a null terminated string
;
;	Output : none
;
;	Replaces the null at the end of a string with blank
;
;----------------------------------------------------------------------------
;

RemoveNull	proc	near

		assume	ds:nothing, es:nothing

rn_next:
		mov	bl, es:[si]
		or	bl, bl			; null ?
		jz	rn_gotnull
		inc	si			; advance the pointer
		jmp	rn_next
rn_gotnull:
		mov	bl, DevSavedDelim
		mov	byte ptr es:[si], bl	; replace null with blank
		ret
RemoveNull	endp

;
;----------------------------------------------------------------------------
;
; procedure : RoundBreakAddr
;
;	Input : DevBrkAddr
;	Output : DevBrkAddr
;
;	Rounds DevBrkAddr to a para address so that it is of the form xxxx:0
;
;----------------------------------------------------------------------------
;
RoundBreakAddr	proc	near

		assume	ds:nothing, es:nothing

		mov	ax, word ptr DevBrkAddr
		call	pararound
		add	word ptr DevBrkAddr+2, ax
		mov	word ptr DevBrkAddr, 0
		mov	ax, DevLoadEnd
		cmp	word ptr DevBrkAddr+2, ax
		jbe	rba_ok
		jmp	mem_err
rba_ok:
		ret
RoundBreakAddr	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevSetBreak
;
;	Input : DevBrkAddr
;	Output : Carry set if Device returned Init failed
;		 Else carry clear
;
;----------------------------------------------------------------------------
;
DevSetBreak	proc	near

		assume	ds:nothing, es:nothing

		push	ax

		mov	ax,word ptr [DevBrkAddr+2]  ;remove the init code
		cmp	multdeviceflag, 0
		jne	set_break_continue	    ;do not check it.
		cmp	ax, DevLoadAddr
		jne	set_break_continue	    ;if not same, then o.k.

		cmp	word ptr [DevBrkAddr],0
		je	break_failed		;[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0

set_break_continue:
		call	RoundBreakAddr
		pop	ax
		clc
		ret
break_failed:
		pop	ax
		stc
		ret
DevSetBreak	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevBreak
;
;	Input : DevLoadAddr & DevBrkAddr
;	Output : none
;
;	Marks a succesful install of a device driver
;	Sets device size field in sub-arena &
;	Updates Free ptr in UMB or adjusts memhi
;
;----------------------------------------------------------------------------
;
DevBreak	proc	near

		assume	ds:nothing, es:nothing

		push	ds
		mov	ax, DevLoadAddr
		mov	bx, word ptr [DevBrkAddr+2]
		dec	ax			; seg of sub-arena
		mov	ds, ax
		inc	ax			; Back to Device segment
		sub	ax, bx
		neg	ax			; size of device in paras
		mov	ds:[devmark_size], ax	; store it in sub-arena
		cmp	DeviceHi, 0
		je	db_lo
		mov	DevUMBFree, bx		; update Free ptr in UMB
		jmp	short db_exit
db_lo:
		mov	memhi, bx
		mov	memlo, 0
db_exit:
		pop	ds
		ret
DevBreak	endp
;
;----------------------------------------------------------------------------
;
; procedure : ParseSize
;
;	Parses the command line for SIZE= command
;
;	ES:SI = command line to parsed
;
;	returns ptr to command line after SIZE= option in ES:SI
;	updates the DevSizeOption variable with value supplied
;	in SIZE=option
;	Returns carry if the SIZE option was invalid
;
;----------------------------------------------------------------------------
;
ParseSize	proc	near

		assume	ds:nothing, es:nothing

		mov	DevSizeOption, 0	; init the value
		mov	word ptr DevCmdLine, si
		mov	word ptr DevCmdLine+2, es
		call	SkipDelim
		cmp	word ptr es:[si], 'IS'
		jne	ps_no_size
		cmp	word ptr es:[si+2], 'EZ'
		jne	ps_no_size
		mov	al, es:[si+4]
		call	delim
		jne	ps_no_size
		add	si, 5
		call	GetHexNum
		jc	ps_err
		mov	DevSizeOption, ax
		call	SkipDelim
ps_no_size:
		clc
		ret
ps_err:
		stc
		ret
ParseSize	endp
;
;----------------------------------------------------------------------------
;
; procedure : SkipDelim
;
;	Skips delimiters in the string pointed to by ES:SI
;	Returns ptr to first non-delimiter character in ES:SI
;
;----------------------------------------------------------------------------
;
SkipDelim	proc	near

		assume	ds:nothing, es:nothing

sd_next_char:
		mov	al, es:[si]
		call	delim
		jnz	sd_ret
		inc	si
		jmp	sd_next_char
sd_ret:
		ret
SkipDelim	endp
;
;----------------------------------------------------------------------------
;
; procedure : GetHexNum
;
;	Converts an ascii string terminated by a delimiter into binary.
;	Assumes that the ES:SI points to a Hexadecimal string
;
;	Returns in AX the number number of paras equivalent to the
;	hex number of bytes specified by the hexadecimal string.
;
;	Returns carry in case it encountered a non-hex character or
;	if it encountered crlf
;
;----------------------------------------------------------------------------
;
GetHexNum	proc	near

		assume	ds:nothing, es:nothing

		xor	ax, ax
		xor	dx, dx
ghn_next:
		mov	bl, es:[si]
		cmp	bl, cr
		je	ghn_err
		cmp	bl, lf
		je	ghn_err
		push	ax
		mov	al, bl
		call	Delim
		pop	ax
		jz	ghn_into_paras
		call	GetNibble
		jc	ghn_err
		mov	cx, 4
ghn_shift1:
		shl	ax, 1
		rcl	dx, 1
		loop	ghn_shift1
		or	al, bl
		inc	si
		jmp	ghn_next
ghn_into_paras:
		add	ax, 15
		adc	dx, 0
		test	dx, 0fff0h
		jnz	ghn_err
		mov	cx, 4
ghn_shift2:
		clc
		rcr	dx, 1
		rcr	ax, 1
		loop	ghn_shift2
		clc
		ret
ghn_err:
		stc
		ret
GetHexNum	endp
;
;----------------------------------------------------------------------------
;
; procedure : GetNibble
;
;	Convert one nibble (hex digit) in BL into binary
;
;	Retruns binary value in BL
;
;	Returns carry if BL contains non-hex digit
;
;----------------------------------------------------------------------------
;
GetNibble	proc	near
		cmp	bl, '0'
		jb	gnib_err
		cmp	bl, '9'
		ja	is_it_hex
		sub	bl, '0'			; clc
		ret
is_it_hex:
		cmp	bl, 'A'
		jb	gnib_err
		cmp	bl, 'F'
		ja	gnib_err
		sub	bl, 'A'- 10		; clc
		ret
gnib_err:
		stc
		ret
GetNibble	endp
;
;
;============================================================================
;============================================================================
;
;----------------------------------------------------------------------------
;
; procedure : AllocUMB
;
;	Allocate all UMBs and link it to DOS arena chain
;
;----------------------------------------------------------------------------
;
AllocUMB	proc	near
		call	InitAllocUMB		; link in the first UMB
		jc	au_exit			; quit on error
au_next:
		call	umb_allocate		; allocate
		jc	au_coalesce
		call	umb_insert		; & insert till no UMBs
		jmp	short au_next
au_coalesce:
		call	umb_coalesce		; coalesce all UMBs
au_exit:
		ret
AllocUMB	endp
;
;----------------------------------------------------------------------------
;
; procedure : InitAllocUMB
;
;----------------------------------------------------------------------------
;
InitAllocUMB	proc	near
		call	IsXMSLoaded
		jnz	iau_err			; quit on no XMS driver
		mov	ah, 52h
		int	21h			; get DOS DATA seg
		mov	DevDOSData, es		; & save it for later
		mov	ax, 4310h
		int	2fh
		mov	word ptr DevXMSAddr, bx	; get XMS driver address
		mov	word ptr DevXMSAddr+2, es
		cmp	FirstUMBLinked, 0	; have we already linked a UMB?
		jne	@f			; quit if we already did it
		call	LinkFirstUMB		; else link the first UMB
		jc	iau_err
		mov	FirstUMBLinked, 0ffh	; mark that 1st UMB linked
@@:
		clc
		ret
iau_err:
		stc
		ret
InitAllocUMB	endp

;-------------------------------------------------------------------------
;
; Procedure Name	: umb_allocate
;
; Inputs		: DS = data
;
; Outputs		: if UMB available
;				Allocates the largest available UMB and 
;			  	BX = segment of allocated block
;				DX = size of allocated block
;				NC
;			  else 
;				CY
;
; Uses			: BX, DX
;
;-------------------------------------------------------------------------

umb_allocate	proc	near

		push	ax
		mov	ah, XMM_REQUEST_UMB
		mov	dx, 0ffffh		; try to allocate largest
						;   possible
		call	dword ptr DevXMSAddr
						; dx now contains the size of
						; the largest UMB
		or	dx, dx
		jz	ua_err
	
		mov	ah, XMM_REQUEST_UMB
		call	dword ptr DevXMSAddr

		cmp	ax, 1			; Q: was the reqst successful
		jne	ua_err			; N: error

		clc

ua_done:
		pop	ax
		ret		

ua_err:
		stc
		jmp	short ua_done

umb_allocate	endp



;---------------------------------------------------------------------------
;
; Procedure Name	: umb_insert
;
; Inputs		: DOSDATA:UMB_HEAD = start of umb chain
;			: BX = seg address of UMB to be linked in
;			: DX = size of UMB to be linked in paras
;			; DS = data
;
; Outputs		: links the UMB into the arena chain
;
; Uses			: AX, CX, ES, DX, BX
;
;---------------------------------------------------------------------------


umb_insert	proc	near

		push	ds

		mov	ds, [DevDOSData]
		mov	ds, ds:[UMB_ARENA]	; es = UMB_HEAD
		mov	ax, ds
		mov	es, ax

ui_next:
		cmp	ax, bx			; Q: is current block above
						;    new block
		ja	ui_insert     		; Y: insert it
						; Q: is current block the
						;    last
		cmp	es:[arena_signature], arena_signature_end
		jz	ui_append		; Y: append new block to chain
						; N: get next block

		mov	ds, ax			; M005
		call	get_next		; ax = es = next block
		jmp	short ui_next

ui_insert:
	
		mov	cx, ds			; ds = previous arena
		inc	cx			; top of previous block

		sub	cx, bx
		neg	cx			; cx = size of used block
		mov	ds:[arena_signature], arena_signature_normal
		mov	ds:[arena_owner], 8	; mark as system owned
		mov	ds:[arena_size], cx	
		mov	word ptr ds:[arena_name], 'CS'

; prepare the arena at start of new block

		mov	es, bx
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], arena_owner_system
						; mark as free
		sub	dx, 2			; make room for arena at
						; start & end of new block
		mov	es:[arena_size], dx	
		
; prepare arena at end of new block
	
		add	bx, dx
		inc	bx
		mov	es, bx			; es=arena at top of new block
		inc	bx			; bx=top of new block

						; ax contains arena just above
						; this block
		sub	ax, bx			; ax = size of used block
	
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'

		jmp	short ui_done

ui_append:

						; es = arena of last block	

		add	ax, es:[arena_size]	; ax=top of last block-1 para
		sub	es:[arena_size], 1	; reflect the space we are
						; going to rsrv on top of this 
						; block for the next arena.
		mov	es:[arena_signature], arena_signature_normal

		mov	cx, ax			; cx=top of prev block-1
		inc	ax
		sub	ax, bx			; ax=top of prev block - 
						;    seg. address of new block

		neg	ax

		mov	es, cx			; ds = arena of unused block


		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'

; prepare the arena at start of new block

		mov	es, bx
		mov	es:[arena_signature], arena_signature_end
		mov	es:[arena_owner], arena_owner_system
						; mark as free
		dec	dx			; make room for arena
		mov	es:[arena_size], dx	

ui_done:
		pop	ds
		ret

umb_insert	endp


;
;----------------------------------------------------------------------------
;
;**	umb_coalesce - Combine free blocks ahead with current block
;
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	cx, di, ds, es
;
;----------------------------------------------------------------------------
;

umb_coalesce	proc	near



		xor	di, di

		mov	es, [DevDOSData]
		mov	es, es:[UMB_ARENA]	; es = UMB_HEAD

uc_nextfree:
		mov	ax, es
		mov	ds, ax
		cmp	es:[arena_owner], di	; Q: is current arena free
		jz	uc_again		; Y: try to coalesce with next block
						; N: get next arena
		call	get_next		; es, ax = next arena
		jc	uc_done
		jmp	short uc_nextfree
uc_again:
		call	get_next		; ES, AX <- next block
		jc	uc_done
uc_check:
		cmp     es:[arena_owner],di	; Q: is arena free
		jnz	uc_nextfree		; N: get next free arena
						; Y: coalesce
		mov     cx,es:[arena_size]      ; cx <- next block size
		inc     cx                      ; cx <- cx + 1 (for header size)
		add     ds:[arena_size],cx      ; current size <- current size + cx
		mov     cl,es:[di]              ; move up signature
		mov     ds:[di],cl
		jmp     short uc_again		; try again
uc_done:
		ret

umb_coalesce	endp

;
;----------------------------------------------------------------------------
;
;**	get_next - Find Next item in Arena
;
;	ENTRY	dS - pointer to block head
;	EXIT	AX,ES - pointers to next head
;		'C' set iff arena damaged
;
;----------------------------------------------------------------------------
;

get_next	proc	near

		cmp	byte ptr ds:[0], arena_signature_end
		je	gn_err

		mov     ax,ds                   ; ax=current block
		add     ax,ds:[arena_size]      ; ax=ax + current block length
		inc     ax                      ; remember that header!
		mov	es, ax
		clc
		ret
gn_err:
		stc
		ret

get_next	endp

;
;----------------------------------------------------------------------------
;
; procedure : LinkFirstUMB
;
;----------------------------------------------------------------------------
;
LinkFirstUMB	proc	near

		call	umb_allocate
ifndef NEC_98
		jc	lfu_err
else    ;NEC_98
		jnc	lfu_next
		jmp	lfu_err
lfu_next:
endif   ;NEC_98

; bx = segment of allocated UMB
; dx = size of UMB

ifndef NEC_98
		int	12h			; ax = size of memory
else    ;NEC_98
		xor	cx,cx
		mov	es,cx
		mov	al,byte ptr es:[501h]	; BIOS_FLG
		and	ax,07h			; main memory size
		inc	ax
		mov	cl,7
		shl	ax,cl			; ax= size of memory

		test	byte ptr es:[501h],08h	; hireso?
		jz	got_mm			;   no
		cmp	ax,768
		jb	got_mm
		sub	ax,64
got_mm:
endif   ;NEC_98
		mov	cl, 6
		shl	ax, cl			; ax = size in paragraphs

		mov	cx, ax			; cx = size in paras
		sub	ax, bx			; ax = - size of unused block

		neg	ax

		sub	cx, 1			; cx = first umb_arena
		mov	es, cx			; es = first umb_arena
	
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
					
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'


; put in the arena for the first UMB

		mov	es, bx			; es has first free umb seg
		mov	es:[arena_signature], arena_signature_end
		mov	es:[arena_owner], arena_owner_system	
						; mark as free 
		dec	dx			; make room for arena
		mov	es:[arena_size], dx	


		mov	es, [DevDOSData]
		mov	di, UMB_ARENA
		mov	es:[di], cx		; initialize umb_head in DOS
						;  data segment with the arena
						;  just below Top of Mem

; we must now scan the arena chain and update the size of the last
; arena

		mov	di, DOS_ARENA
		mov	es, word ptr es:[di]	; es = start arena
		xor	di, di

	
scan_next:
		cmp	byte ptr es:[di], arena_signature_end
		jz	got_last
	
		mov	ax, es
		add	ax, es:[arena_size]
		inc	ax
		mov	es, ax
		jmp	short scan_next

got_last:
;; -williamh- we reserved the last paragraph for UMB_HEAD already.
;; refer to sysinit1.asm!goinit
;; The following instruction was commentted out for this reason.
;;		sub	es:[arena_size], 1
;;
ifdef NEC_98
		sub	es:[arena_size], 1
endif   ;NEC_98
		mov	es:[arena_signature], arena_signature_normal
		clc
		ret

lfu_err:
		stc
		ret
LinkFirstUMB	endp

;
;----------------------------------------------------------------------------
;
; procedure : ShrinkUMB
;
;	Shrinks the current UMB in use, so that the unused portions
;	of the UMB is given back to the DOS free mem pool
;
;----------------------------------------------------------------------------
;
		public	ShrinkUMB

ShrinkUMB	proc	near
		cmp	DevUMBAddr, 0
		je	su_exit
		push	es
		push	bx
		mov	bx, DevUMBFree
		sub	bx, DevUMBAddr
		mov	es, DevUMBAddr
		mov	ax, 4a00h
		int	21h
		mov	ax, es
		dec	ax
		mov	es, ax
		mov	word ptr es:[arena_owner], 8
		pop	bx
		pop	es
su_exit:
		ret
ShrinkUMB	endp

;M002 - BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : UnlinkUMB
;
;	Unlinks the UMBs from the DOS arena chain
;
;----------------------------------------------------------------------------
;
		public	UnlinkUMB

UnlinkUMB	proc	near
		push	ds
		push	es
		cmp	FirstUMBLinked, 0
		je	ulu_x			; nothing to unlink
		mov	es, DevDOSData		; get DOS data seg
		mov	ds, es:[DOS_ARENA]
		mov	di, es:[UMB_ARENA]
ulu_next:
		call	get_next
		jc	ulu_x
		cmp	di, ax			; is the next one UMB ?
		je	ulu_found
		mov	ds, ax
		jmp	ulu_next
ulu_found:
		mov	ds:[arena_signature], 'Z'	
ulu_x:
		pop	es
		pop	ds
		ret
UnlinkUMB	endp

;M002 - END

; =========================================================================
;

ifdef	JAPAN
	public	IsDBCSCodePage
IsDBCSCodePage	proc	near
	push	ax
	push	bx
	mov	ax,4f01h		; get code page
	xor	bx,bx
	int	2fh
	cmp	bx,932
	pop	bx
	pop	ax
	ret
IsDBCSCodePage	endp
endif

sysinitseg	ends
		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\spckbd.asm ===
;******************************************************************************
;
;       Copyright (c) 1992 Insignia Solutions Ltd.
;
;       Program:
;
;       Purpose:
;
;       Version:
;
;       Author:         Dave Bartlett
;       Modifications:
;               1) Tim June 92. Changes to get DEC PC working. Take over
;                  IVT entries 6h (illegal instruction), 11h (equipment
;                  check), 16h (keyboard BIOS), 17h (printer),
;                  42h (default video).
;               2) Tim June 92. Changed version to 1.11
;               3) Tim June 92. Avoid accesses to host ROM as far as
;                  possible. Take over lots of IVT entries and continue to
;                  point them at this driver.
;               4) Tim July 92. Version num 1.12, put pseudo ROM stuff back in.
;               5) Tim July 92. v 1.13, use SoftPC video BIOS when windowed.
;
;      6) 12-Sep-1992 Jonle, Merged with ntio.sys
;                            cleanup usage of assumes espcially with ES
;                            optimized loading of IVT
;                            other general cleanup
;
;      This obj module is intially loaded in a temporary memory location
;      along with ntio.sys. Ntio.sys will copy the resident code (marked by
;      SpcKbdBeg, SpcKbdEnd) into the permanent memory location which resides
;      just below the normal device drivers loaded by config.sys.
;
;      The nonresident intialization code is run with CS= temp seg
;      and DS= final seg.
;
;******************************************************************************


.286

include vint.inc

;================================================================
; Macros and includes
;================================================================

bop MACRO callid
    db 0c4h,0c4h,callid
endm


BIOS_CPU_QUIT   equ     0FEh
BIOS_KB_INT     equ     9
BIOS_INT15      equ     15h
BIOS_PRINTER_IO equ     17h
UNEXP_BOP       equ     2
RTC_WAIT_FLAG   equ     0a0h     ; offset of rtc_wait_flag in bios data seg
VERSIONID       equ     0BEEFh

FULLSCREEN      equ     1
STREAM_IO       equ     2
MAX_VIDEO_FUNC  equ     1Ch
GET_FONT_FUNC   equ     11h

VID_MODECHANGE  equ     0
VID_VESA_BIOS   equ     4fh
MOUSE_LIGHT_PEN equ     4
MIN_MOUSE_FUNC  equ     0F0H
MAX_MOUSE_FUNC  equ     0F7H
XTRA_MOUSE_FUNC equ     0FAH
MS_VIDEO_STRING equ     13FFH

MOUSE_VID_BOP   equ     0BEh
EGA_VIDEO_BOP   equ     42h

PRT_NOTBUSY     equ     80h
PRT_NUM_PORTS   equ     3
PRT_STATE_READY equ     0
PRT_IRQ         equ     10h
PRT_LPT_BUSY    equ     1

TIMER_LOW       equ 6ch
TIMER_HIGH      equ 6eh
TIMER_OVFL      equ 70h
MOTOR_STATUS    equ 3fh
MOTOR_COUNT     equ 40h

; Keyboard buf ptrs
BUFFER_HEAD     equ 1ah
BUFFER_TAIL     equ 1ch
BUFFER_START    equ 80h
BUFFER_END      equ 82h

; kb_flag and LED bits
KB_FLAG         equ  17h
CAPS_STATE      equ  40h
NUM_STATE       equ  20h
SCROLL_STATE    equ  10h

KB_FLAG_1       equ  18h

KB_FLAG_2       equ  97h
KB_LEDS         equ  07h   ; Keyboard LED state bits
KB_PR_LED       equ  40h   ; Mode indicator update


KB_FLAG_3       equ  96h
KBF3_ALT_CTRL   equ  0ch




;..............................................keyboard constants

; bits in kb_flag
        RIGHT_SHIFT = 1
        LEFT_SHIFT = 2
        CTL_SHIFT = 4
        ALT_SHIFT = 8


; bit in kb_flag_1
        HOLD_STATE = 8
        SCROLL_SHIFT = 10h
        NUM_SHIFT = 20h
        CAPS_SHIFT = 40h
        INS_SHIFT = 80h
        SYS_SHIFT = 04h


; IBM scan codes
        CTL_KEY = 29
        LEFT_SHIFTKEY = 42
        RIGHT_SHIFTKEY = 54
        ALT_KEY = 56
        CAPS_KEY = 58
        NUM_KEY = 69
        SCROLL_KEY = 70
        INS_KEY = 82



;
; Segment definitions for ntio.sys,
;
include biosseg.inc


SpcKbdSeg    segment

        assume  cs:SpcKbdSeg,ds:nothing,es:nothing

;
; SpcKbdBeg - SpcKbdEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 13-Sep-1992 Jonle
;
        public SpcKbdBeg

SpcKbdBeg    label  byte

;
; Reduced data table for Video 7 modes 0 and 2.
; This table is extracted from our video7 ROM. Only text modes are
; required, mode 0 and 1 are identical as are modes 2 and 3.
;
ega_parm_setup:

;--40x25--
        DB 40,24,16     ; width,height,character height
        DW 00800H       ; Page size in bytes

        DB 008H, 003H, 000H, 002H       ; Sequencer Parameters

        DB 067H ;Misc Reg

; CRTC Parameters
        DB 02dH, 027H, 028H, 090H, 02bH
        DB 0a0H, 0bfH, 01fH, 000H, 04fH
        DB 00dH, 00eH, 000H, 000H, 000H
        DB 000H, 09cH, 0aeH, 08fH, 014H
        DB 01fH, 096H, 0b9H, 0a3H, 0ffH

; Attribute parameters
        DB 000H, 001H, 002H, 003H, 004H
        DB 005H, 014H, 007H, 038H, 039H
        DB 03aH, 03bH, 03cH, 03dH, 03eH
        DB 03fH, 00cH, 000H, 00fH, 008H

; Graph parameters
        DB 000H, 000H, 000H, 000H, 000H
        DB 010H, 00eH, 000H, 0ffH

;--80x25--
        DB 80,24,16     ; width,height,character height
        DW 01000H       ; Page size in bytes

        DB 000H, 003H, 000H, 002H       ; Sequencer Parameters

        DB 067H ;Misc Reg

; CRTC Parameters
        DB 05fH, 04fH, 050H, 082H, 055H
        DB 081H, 0bfH, 01fH, 000H, 04fH
        DB 00dH, 00eH, 000H, 000H, 000H
        DB 000H, 09cH, 08eH, 08fH, 028H
        DB 01fH, 096H, 0b9H, 0a3H, 0ffH

; Attribute parameters
        DB 000H, 001H, 002H, 003H, 004H
        DB 005H, 014H, 007H, 038H, 039H
        DB 03aH, 03bH, 03cH, 03dH, 03eH
        DB 03fH, 00cH, 000H, 00fH, 008H

; Graph parameters
        DB 000H, 000H, 000H, 000H, 000H
        DB 010H, 00eH, 000H, 0ffH

;--80x25 mono--
        DB 80,24,16     ; width,height,character height
        DW 01000H       ; Page size in bytes

        DB 000H, 003H, 000H, 003H       ; Sequencer Parameters

        DB 0a6H ;Misc Reg

; CRTC Parameters
        DB 05fH, 04fH, 050H, 082H, 055H
        DB 081H, 0bfH, 01fH, 000H, 04dH
        DB 00bH, 00cH, 000H, 000H, 000H
        DB 000H, 083H, 0a5H, 05dH, 028H
        DB 00dH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
        DB 000H, 008H, 008H, 008H, 008H
        DB 008H, 008H, 008H, 010H, 018H
        DB 018H, 018H, 018H, 018H, 018H
        DB 018H, 00eH, 000H, 00fH, 008H

; Graph parameters
        DB 000H, 000H, 000H, 000H, 000H
        DB 010H, 00aH, 000H, 0ffH

; Mode b (font load)

        DB 5eh,32H,8    ; width,height,character height
        DW 09700H       ; Page size in bytes

        DB 001H, 00fH, 000H, 006H       ; Sequencer Parameters

        DB 0e7H ;Misc Reg

; CRTC Parameters
        DB 06dH, 05dH, 05eH, 090H, 061H
        DB 08fH, 0bfH, 01fH, 000H, 040H
        DB 000H, 000H, 000H, 000H, 000H
        DB 000H, 0a2H, 08eH, 099H, 02fH
        DB 000H, 0a1H, 0b9H, 0e3H, 0ffH

; Attribute parameters
        DB 000H, 001H, 002H, 003H, 004H
        DB 005H, 014H, 007H, 038H, 039H
        DB 03aH, 03bH, 03cH, 03dH, 03eH
        DB 03fH, 001H, 000H, 00fH, 000H

; Graph parameters
        DB 000H, 000H, 000H, 000H, 000H
        DB 000H, 005H, 00fH, 0ffH


;--350 scanline 40x25
        DB 40,24,14     ; width,height,character height
        DW 00800H       ; Page size in bytes

        DB 009H, 003H, 000H, 002H       ; Sequencer Parameters

        DB 0a3H ;Misc Reg

; CRTC Parameters
        DB 02dH, 027H, 028H, 090H, 02bH
        DB 0a0H, 0bfH, 01fH, 000H, 04dH
        DB 00bH, 00cH, 000H, 000H, 000H
        DB 000H, 083H, 0a5H, 05dH, 014H
        DB 01fH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
        DB 000H, 001H, 002H, 003H, 004H
        DB 005H, 014H, 007H, 038H, 039H
        DB 03aH, 03bH, 03cH, 03dH, 03eH
        DB 03fH, 008H, 000H, 00fH, 000H

; Graph parameters
        DB 000H, 000H, 000H, 000H, 000H
        DB 010H, 00eH, 000H, 0ffH

;--350 scanline 80x25
        DB 80,24,14     ; width,height,character height
        DW 01000H       ; Page size in bytes

        DB 001H, 003H, 000H, 002H       ; Sequencer Parameters

        DB 0a3H ;Misc Reg

; CRTC Parameters
        DB 05fH, 04fH, 050H, 082H, 055H
        DB 081H, 0bfH, 01fH, 000H, 04dH
        DB 00bH, 00cH, 000H, 000H, 000H
        DB 000H, 083H, 0a5H, 05dH, 028H
        DB 01fH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
        DB 000H, 001H, 002H, 003H, 004H
        DB 005H, 014H, 007H, 038H, 039H
        DB 03aH, 03bH, 03cH, 03dH, 03eH
        DB 03fH, 008H, 000H, 00fH, 000H

; Graph parameters
        DB 000H, 000H, 000H, 000H, 000H
        DB 010H, 00eH, 000H, 0ffH

;
; End of baby mode table.
;
; Table of VGA bios 'capability' info for func 1b to point at.
vga_1b_table    db 07fh, 060h, 00fh, 000h, 000h, 000h, 000h, 007h
                db 002h, 008h, 0ffh, 00eh, 000h, 000h, 03fh, 000h

; Configuration table for INT 15 Func C0 to point at.
conf_table      dw 008h
;;              db 0fch, 002h, 000h, 070h, 000h, 000h, 000h, 000h
                db 0fch, 002h, 074h, 070h, 000h, 000h, 000h, 000h


PRT_BUF_SIZE     equ     255

;================================================================
; Printer status table
;================================================================
prt_status      db PRT_NUM_PORTS dup (?)
prt_state       db PRT_NUM_PORTS dup (?)
prt_control     db PRT_NUM_PORTS dup (?)
prt_lpt_stat    db PRT_NUM_PORTS dup (?)
cur_buf_size    dw PRT_BUF_SIZE
prt_data_buf    db PRT_BUF_SIZE dup (?) ; buffer in the 16bit side for perf.
cur_lpt         db 0ffh                 ; buffer is not being used
cur_count       dw ?
cur_busy        db 0                    ; initially not busy

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; Keyboard tables
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


shift_keys:                                                     ;K6
        DB INS_KEY,CAPS_KEY,NUM_KEY,SCROLL_KEY
        DB ALT_KEY,CTL_KEY,LEFT_SHIFTKEY,RIGHT_SHIFTKEY

shift_masks:                                                    ;K7
        DB INS_SHIFT,CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT
        DB ALT_SHIFT,CTL_SHIFT,LEFT_SHIFT,RIGHT_SHIFT

ctl_n_table:                                                    ;K8
        DB  27,  -1,   0,  -1,  -1,  -1,  30,  -1
        DB  -1,  -1,  -1,  31,  -1, 127, 148,  17
        DB  23,   5,  18,  20,  25,  21,   9,  15
        DB  16,  27,  29,  10,  -1,   1,  19,   4
        DB   6,   7,   8,  10,  11,  12,  -1,  -1
        DB  -1,  -1,  28,  26,  24,   3,  22,   2
        DB  14,  13,  -1,  -1,  -1,  -1, 150,  -1
        DB ' ',  -1

ctl_f_table:                                                    ;K9
        DB  94,  95,  96,  97,  98,  99, 100, 101
        DB 102, 103,  -1,  -1, 119, 141, 132, 142
        DB 115, 143, 116, 144, 117, 145, 118, 146
        DB 147,  -1,  -1,  -1, 137, 138

lowercase:
        DB  27, '1', '2', '3', '4', '5', '6', '7', '8', '9'     ;K10
        DB '0', '-', '=',   8,   9, 'q', 'w', 'e', 'r', 't'
        DB 'y', 'u', 'i', 'o', 'p', '[', ']',  13, -1,  'a'
        DB 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',  39
        DB  96,  -1,  92, 'z', 'x', 'c', 'v', 'b', 'n', 'm'
        DB ',', '.', '/',  -1, '*',  -1, ' ',  -1

lc_tbl_scan:
        DB  59,  60,  61,  62,  63,  64,  65,  66,  67,  68
        DB  -1,  -1

base_case:
        DB  71,  72,  73,  -1,  75,  -1,  77,  -1,  79,  80
        DB  81,  82,  83,  -1,  -1,  92, 133, 134               ;K15

uppercase:                                                      ;K11
        DB  27, '!', '@', '#', '$', '%', '^', '&', '*', '('
        DB ')', '_', '+',   8,   0, 'Q', 'W', 'E', 'R', 'T'
        DB 'Y', 'U', 'I', 'O', 'P', '{', '}',  13,  -1, 'A'
        DB 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"'
        DB 126,  -1, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M'
        DB '<', '>', '?',  -1,   0,  -1, ' ',  -1;

ucase_scan:
        DB  84,  85,  86,  87,  88,  89,  90,  91,  92,  93
        DB  -1,  -1

numb_state:
        DB '7', '8', '9', '-', '4', '5', '6', '+', '1', '2'     ;K14
        DB '3', '0', '.' , -1,  -1, 124, 135, 136

alt_table:
        DB 82,  79,  80,  81,  75,  76,  77,  71,  72,  73      ;K30
        DB 16,  17,  18,  19,  20,  21,  22,  23,  24,  25
        DB 30,  31,  32,  33,  34,  35,  36,  37,  38,  44
        DB 45,  46,  47,  48,  49,  50

;================================================================
; Keyboard break caller
;================================================================

keyboard_break_caller:
        int 1bh     ;keyboard break
        bop %BIOS_CPU_QUIT

;================================================================
; Print screen caller
;================================================================

print_screen_caller:
        int 5h              ;print screen
        bop %BIOS_CPU_QUIT

;================================================================
; Int 15 caller
;================================================================
; Tim modified int 15 caller. Copied from BIOS2. It gives CPU
; a chance to take other interrupts. Suspect the extra jumps are
; now harmless with IRET hooking.
;int15h_caller:
        ;int    15h
        ;bop    %BIOS_CPU_QUIT
int15h_caller:
        int     15h     ; Cassette I/O.
        jmp     k1
k1:     jmp     k2
k2:     jmp     k3
k3:     BOP     %BIOS_CPU_QUIT

;================================================================
; Unexpected interrupt handler
;================================================================

unexp_int:
        bop %UNEXP_BOP
        jmp     iret_com

;================================================================
;Int 13 caller
;================================================================
int13h_caller:
        int     13h
        bop %BIOS_CPU_QUIT

ifdef JAPAN
;================================================================
;int 16 caller
;================================================================
int16h_caller:
    int 16h
    bop %BIOS_CPU_QUIT
endif ; JAPAN

;================================================================
; New interrupt 9h handler
;================================================================

int09h_vector:
        push    ax
        xor     ax, ax
        bop     %BIOS_KB_INT
        pop     ax
        jmp     iret_com

        ; CarbonCopy traces int 9 in order to gain control
        ; over where the kbd data is coming from (the physical kbd
        ; or the serial link) The kbd_inb instruction must be visible
        ; in the 16 bit code via int 1 tracing, for CarbonCopy to work.
        ; Softpc assumes the exact location of the first nop
        ; relative to the bop just above.
        nop
        nop
        in      al, 60h      ; keyba_io_buffers
        nop
        nop
        BOP     %BIOS_CPU_QUIT





;=================================================================
; IRET hooks bop table
;=================================================================


IRET_HOOK = 5dh                 ;IRET hook BOP

iret_bop_table:
        bop %IRET_HOOK
        db 0
iret_end_first_entry:
        bop %IRET_HOOK
        db 1
        bop %IRET_HOOK
        db 2
        bop %IRET_HOOK
        db 3
        bop %IRET_HOOK
        db 4
        bop %IRET_HOOK
        db 5
        bop %IRET_HOOK
        db 6
        bop %IRET_HOOK
        db 7
        bop %IRET_HOOK
        db 8
        bop %IRET_HOOK
        db 9
        bop %IRET_HOOK
        db 10
        bop %IRET_HOOK
        db 11
        bop %IRET_HOOK
        db 12
        bop %IRET_HOOK
        db 13
        bop %IRET_HOOK
        db 14
        bop %IRET_HOOK
        db 15

;================================================================
; New interrupt 13h handler
;================================================================

int13h_vector:
        cmp     dl,80h          ; 0 - 7f are floppy commands
        jb      int40h_vector

        cmp     ah,2            ; we fail the direct access commands
        jb      diskcmd         ; read/write/seek/verify/format
        cmp     ah,5            ; but let others go through (disk tables etc)
        jbe     faildisk
        cmp     ah,0ah
        jb      diskcmd
        cmp     ah,0ch
        ja      diskcmd
faildisk:
        push    ax
        mov     ax,1            ; direct access error panel
        bop     59h
        pop     ax              ; preserve AL for safety sake
        mov     ah, 80h         ; error - timeout
        stc
        retf    2

diskcmd:
        bop     13h
        retf    2

;================================================================
; New interrupt 40h handler
;================================================================

int40h_vector:
;       cmp     ah,2            ; we fail the direct access commands
;       jb      flopcmd         ; read/write/seek/verify/format
;       cmp     ah,5            ; but let others go through (disk tables etc)
;       jbe     failflop
;       cmp     ah,0ah
;       jb      flopcmd
;       cmp     ah,0ch
;       ja      flopcmd
failflop:
;       push    ax
;       mov     ax,0            ; direct access error panel
;       bop     59h
;       pop     ax
;       mov     ah, 80h         ; error - timeout
;       stc
;       retf    2

flopcmd:
        bop     40h
        retf    2

;; waiting for diskette interrupt
wait_int:
        push    ds
        push    ax
        push    cx
        mov     ax, 40h
        mov     ds, ax
        mov     cx, 10h
wait_int_loop:
        mov     al, [3Eh]
        test    al, 80h
        loopz   wait_int_loop
        pop     cx
        pop     ax
        pop     ds
        bop     %BIOS_CPU_QUIT

;; floppy parameters table
floppy_table    label   byte

        DB      01                              ;; 360KB in 360KB
        DW      OFFSET md_tbl1
        DB      82H                             ;; 360KB in 1,2MB
        DW      OFFSET md_tbl2
        DB      02                              ;; 1.2MB in 1.2MB
        DW      OFFSET md_tbl3
        DB      03                              ;; 720KB in 720KB
        DW      OFFSET md_tbl4
        DB      84H                             ;; 720KB in 1.44MB
        DW      OFFSET md_tbl5
        DB      04                              ;; 1.44MB in 1.44MB
        DW      OFFSET md_tbl6
        DB      85h                             ;; 720KB in 2.88MB
        DW      OFFSET md_tbl7
        DB      85h                             ;; 1.44MB in 2.88MB
        DW      OFFSET md_tbl8
        DB      5                               ;; 2.88MB in 2.88MB
        DW      OFFSET md_tbl9


md_tbl1:
        ; MEDIA = 40 track low data rate; DRIVE = 40 track low data rate
        DB 0DFh         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 9            ; sectors/track
        DB 02Ah         ; gap length
        DB 0FFh         ; data length
        DB 050h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start time
        DB 39           ; maximum track number
        DB 80H          ; transfer rate

md_tbl2:
        ; MEDIA = 40 track low data rate; DRIVE = 80 track high data rate
        DB 0DFh         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 9            ; sectors/track
        DB 02Ah         ; gap length
        DB 0FFh         ; data length
        DB 050h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start time
        DB 39           ; maximum track number
        DB 40H          ; transfer rate

md_tbl3:
        ; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
        DB 0DFh         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 15           ; sectors/track
        DB 01Bh         ; gap length
        DB 0FFh         ; data length
        DB 054h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start time
        DB 79           ; maximum track number
        DB 0            ; transfer rate

md_tbl4:
        ; MEDIA = 80 track low data rate; DRIVE = 80 track low data rate
        DB 0DFh         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 9            ; sectors/track
        DB 02Ah         ; gap length
        DB 0FFh         ; data length
        DB 050h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start ime
        DB 79           ; maximum track number
        DB 80H          ; transfer rate

md_tbl5:
        ; MEDIA = 80 track low data rate; DRIVE = 80 track high data rate
        DB 0DFh         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 9            ; sectors/track
        DB 02Ah         ; gap length
        DB 0FFh         ; data length
        DB 050h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start time
        DB 79           ; maximum track number
        DB 80H          ; transfer rate

md_tbl6:
        ; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
        DB 0AFh         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 18           ; sectors/track
        DB 01Bh         ; gap length
        DB 0FFh         ; data length
        DB 06Ch         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start time
        DB 79           ; maximum track number
        DB 0            ; transfer rate

md_tbl7:
        ;MEDIA = 80 tracks, 9 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

        DB 0E1h         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 9            ; sectors/track
        DB 02Ah         ; gap length
        DB 0FFh         ; data length
        DB 050h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start ime
        DB 79           ; maximum track number
        DB 80H          ; transfer rate
md_tbl8:
        ;MEDIA = 80 tracks, 18 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

        DB 0D1h         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 18           ; sectors/track
        DB 01Bh         ; gap length
        DB 0FFh         ; data length
        DB 065h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start time
        DB 79           ; maximum track number
        DB 0            ; transfer rate

md_tbl9:
        ;MEDIA = 80 tracks, 36 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

        DB 0A1h         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 36           ; sectors/track
        DB 038h         ; gap length
        DB 0FFh         ; data length
        DB 053h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start time
        DB 79           ; maximum track number
        DB 0C0h         ; transfer rate



floppy_table_len    equ $ - floppy_table

bios_floppy_table   label   byte
        DB 0DFh         ; 1st specify byte
        DB 2            ; 2nd specify byte
        DB 25H          ; motor off wait time
        DB 2            ; ie 2 bytes/sector
        DB 18           ; sectors/track
        DB 01Bh         ; gap length
        DB 0FFh         ; data length
        DB 054h         ; gap length for format
        DB 0F6h         ; fill byte for format
        DB 15           ; head settle time/ms
        DB 8            ; ie 1s motor start time
bios_floppy_table_len   equ $ - bios_floppy_table

;===============================================================
; New interrupt 15h handler
;================================================================
; Tim, modified this to be like a "normal" SoftPC ROM.
; Copied from BIOS2, but rtc_wait_flag is now referenced via ES not
; DS.
;
;  17-Sep-1992 Jonle , ES ref to rtc_wait was change from assume ES
;  to seg overides to prevent accidents in assuming.
;

;int15h_vector:
        ;bop      %BIOS_INT15
        ;iret
;;;;;;;;;STF hide this int15h_vector:
int15h_vector:
        call    DOSTI
        cmp ah, 88h
        je lbl1
        cmp ah, 91h
        je lbl1
        cmp ah, 86h
        je lbl2
        BOP 15h
        RETF 2
lbl1:   BOP 15h
        jmp iret_com
lbl2:   BOP 15h
        jc lbl5
        push cx
        push dx
        push es                         ; Tim, save ES not DS.
        mov ax, 40h                      ; point es to biosdata
        mov es, ax
        xchg dx, cx
lbl3:
        test byte ptr es:[RTC_WAIT_FLAG], 080h ; check for end of wait
        loopz lbl3                             ; dec timeout delay
        jnz lbl4                               ; exit if wait ended
        sub dx, 1                              ; dec error timeout counter
        jnc lbl3                               ; loop till counters timeout
lbl4:
        mov byte ptr es:[RTC_WAIT_FLAG], 0   ; set function inactive
        pop es                               ; Kipper, restore ES not DS.
        pop dx
        pop cx
        clc
lbl5:
        RETF 2

;=================================================================
; Regular SoftPC int 17 handler (especially important for DEC PCs)
;=================================================================

int17h_vector:
;
;    Do a get status purely in 16-bit code but only if the printer is ready and
;we don't have interrupts turned on. Otherwise we must do a BOP and let 32-bit
;code handle it.
;
        push    si
        push    dx
        push    ax
        mov     ax, dx                  ; dx = adapter no., ensure it is no
        xor     dx, dx                  ; greater than PRT_NUM_PORTS.
        mov     si, PRT_NUM_PORTS
        div     si
        mov     si, dx
        pop     ax
        cmp     ah, 2
        je      do_prt_status
        or      ah,ah
        je      do_write
        jmp     do_print_bop

do_prt_status:
        cmp     byte ptr cs:[si + prt_state], PRT_STATE_READY
        jne     do_print_bop
        test    byte ptr cs:[si + prt_control], PRT_IRQ
        je      get_status
        jmp     short do_print_bop

do_write:
        cmp     byte ptr cs:[cur_lpt],0ffh
        jne     check_lpti
        mov     byte ptr cs:[cur_lpt],dl
        mov     word ptr cs:[cur_count],0
        mov     byte ptr cs:[cur_busy],0ffh
        jmp     short do_print_bop
check_lpti:
        cmp     byte ptr cs:[cur_lpt],dl
        je      buf_ok
        push    si
        xor     si,si
        bop     %BIOS_PRINTER_IO
        pop     si
        mov     word ptr cs:[cur_count],0
        mov     byte ptr cs:[cur_lpt],dl
        jmp     short do_print_bop
buf_ok:
        mov     dx,word ptr cs:[cur_count]
        mov     si,dx
        mov     byte ptr cs:[si + prt_data_buf],al
        inc     word ptr cs:[cur_count]
        cmp     word ptr cs:[cur_count],PRT_BUF_SIZE
        jne     no_flushing
        xor     si,si                       ; sub-function 0 for this bop
        bop     %BIOS_PRINTER_IO
        test    ah,08h
        jz      flush_ok
        dec     word ptr cs:[cur_count]
        jmp     short int17h_end
flush_ok:
        mov     word ptr cs:[cur_count],0
no_flushing:
        mov     ah,90h
        jmp     short int17h_end


        ;
        ; Risc int17 entry point, provided to cope with si subfunctions
        ;
int17h_RiscVector:

        push    si
        push    dx

do_print_bop:
        mov     si,0ffffh                     ; sub-function 1
        bop     %BIOS_PRINTER_IO
        jmp     int17h_end

get_status:
        test    byte ptr cs:[si + prt_lpt_stat], PRT_LPT_BUSY
        jne     noset
        or      byte ptr cs:[si + prt_status], PRT_NOTBUSY
noset:
        mov     ah, cs:[si + prt_status]
        and     ah, 0f8h
        xor     ah, 48h
int17h_end:
        pop     dx
        pop     si
iret_com:
        FIRET


;=================================================================
; Pseudo-ROM vectuz, copied from BIOS2.ASM
;=================================================================

dummy_vector:           ; Copied from BIOS2.ASM
        jmp iret_com
illegal_bop_vector:
        bop     72h
        jmp     iret_com
intD11_vector:
        bop     72h
        jmp     iret_com

int05h_vector:          ; Print Screen func. copied from BIOS2.ASM
        call DOSTI
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH DS
        ;::::::::::::::::::::::::::::::::: Setup DS to point to BIOS data area
        MOV AX,40H
        MOV DS,AX
        ;::::::::::::::::::::::::::::::: Print screen already in progress ????
        CMP BYTE PTR DS:[100H],1
        JE end_print
        ;::::::::::::::::::::::::::::::::::::::::::::::: Set print screen busy
        MOV BYTE PTR DS:[100h],1

        ;::::: fetch no rows, columns, curr page from bios data area
        mov ch, byte ptr ds:[4ah]     ; cols
        mov cl, byte ptr ds:[84h]     ; rows
        mov bh, byte ptr ds:[62h]     ; curr page num


        ;::::::::::::::::::::::::::::::::::: Print line feed / carriage return
        CALL print_crlf
        ;:::::::::::::::::::::::::::::::::::::::::: Get current cursor postion
        PUSH CX
        MOV AH,3
        INT 10H
        POP CX
        ;::::::::::::::::::::::::::::::::::::::::::::::::: Save cursor postion
        PUSH DX                     ;save current cursor postion
        XOR DH,DH                   ;current row being processed
start_print_col:
        XOR DL,DL                   ;current column being processed
        ;::::::::::::::::::::::::::::::::::::::::::::::: Start printing screen
start_print_row:
        ;:::::::::::::::::::::::::::::::::::::::::::::::::: Set cursor postion
        PUSH DX                     ;save current row,column
        MOV AH,2
        INT 10H
        ;::::::::::::::::::::::::::::::::::: Read character at current postion
        MOV AH,8
        INT 10H
        ;::::::::::::::::::::::::::::::::::::::::::::::::::::: Print character
        OR al,al
        JNZ print_char
        MOV AL,20H
print_char:
        XOR DX,DX
        XOR AH,AH
        INT 17H
        ;:::::::::::::::::::::::::::::::::::::::::::: Check for printer errors
        POP DX                  ;Restore current row,column
        AND AH,25H
        JZ  cont2
        MOV BYTE PTR DS:[100H],0FFH
        JMP short exit_print
        ;::::::::::::::::::::::::::::::::::::::::::: Move to mext print column
cont2:
        INC DL                  ;Inc current column
        CMP DL,CH               ;Current col compared to no. of cols
        JB start_print_row
        ;:::::::::::::::::::::::::::::::::::::::::: End of column, print CR/LF
        CALL print_crlf
        ;:::::::::::::::::::::::::::::::::::::::::::::::::: More rows to print
        INC DH                  ;Inc current row
        CMP DH,CL               ;Current row compared to no. of rows
        JBE start_print_col
        MOV BYTE PTR DS:[0100H],0
        ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Exit print
exit_print:
        ;:::::::::::::::::::::::::::::::::::::; Restore orginal cursor postion
        POP DX
        MOV AH,2
        INT 10H
        ;:::::::::::::::::::::::::::::::::::::::::::::::::::: Tidy up and exit
end_print:
        POP DS
        POP DX
        POP CX
        POP BX
        POP AX
        jmp iret_com

        ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Print CR/LF
print_crlf:
        PUSH DX
        XOR DX,DX
        MOV AX,0DH
        INT 17H
        XOR DX,DX
        MOV AX,0AH
        INT 17H
        POP DX
        RET
;       End of int05_vector (print screen).

int06h_vector:
        bop     06h
        jmp     iret_com

; IVT 7 is set to unexpected interrupt.


int08h_vector:
; The usual int8 handler modified for optimum performance.
; - stays in 16 bit code (no BOP)
; - keeps interrupts off when not needed
; - calls int 1c directly
;
        call  DOCLI                ; make sure interrupts stay off until iret

        push  es
        push  ds                  ; save some registers
        push  ax
        push  dx

        mov   ax, 40h             ; set ds to bios data area
        mov   ds, ax
        xor   ax, ax
        mov   es, ax              ; set es to IVT seg for i1c callout

        inc   word ptr ds:[TIMER_LOW]        ; inc time counters
        jnz   i8v1
        inc   word ptr ds:[TIMER_HIGH]
i8v1:
        cmp   word ptr ds:[TIMER_HIGH], 018h  ; check for 24 hours, wrap point
        jnz   i8v2
        cmp   word ptr ds:[TIMER_LOW], 0b0h
        jnz   i8v2


        mov   word ptr ds:[TIMER_HIGH], ax    ; 24 hour wrap, set OVFL bit
        mov   word ptr ds:[TIMER_LOW], ax
        mov   byte ptr ds:[TIMER_OVFL], 1
        or    al, 8                ; set Overflow bit for fake flags

        ;---                       ; skip floppy motor stuff


i8v2:                              ; handle the floppy motor stuff
        push  ax
        dec   byte ptr ds:[MOTOR_COUNT]
        jnz   i8v3
        and   byte ptr ds:[MOTOR_STATUS], 0f0h
        mov   al, 0ch
        mov   dx, 03f2h            ; costly outb happens 1/256 timer tics...
        out   dx, al

i8v3:
        pop   ax

; if a dpmi app has interrupts hooked in PM, then we have to do a real
; INT 1C so that the dpmi host has a chance to switch to PM
        test  word ptr ds:[FIXED_NTVDMSTATE_REL40], VDM_INTS_HOOKED_IN_PM
        jnz   i8v4
                                   ; call int1c user routine directly
        lahf                       ; get lobyte of flags for fake flags
        xchg  ah,al
        push  ax                   ; put fake flags on the stack
        call  dword ptr es:[1ch*4] ; do it!
        jmp   i8v5

i8v4:
        int   1ch                  ; do real int1C
i8v5:

        call  DOCLI                ; make sure interrupts stay off until iret

        mov   al, 20h              ; send eoi
        out   20h, al

        pop   dx                   ;restore the stack
        pop   ax
        pop   ds
        pop   es

        jmp     iret_com



int0e_vector:
        bop     0eh
        jmp     iret_com

DOCLI:
        FCLI
        ret

DOSTI:
        FSTI
        ret




;-----------------------------------------------------------------------
;function: sw_video_io
;
;description:
; int10 ah=0e and ax=13ffh handler for "well-behaved" applications which
; do their video i/o through dos/file or WriteTTy call
; Since the output won't go to the video hardware, it was called software
; video.
;
;input: whatever to int10
;
;output: carry flag = 1 if we have done the function
;        carry flag = 0 if we have not done anything, the caller has
;                       to carry on the operation
;
;modified: none
;-----------------------------------------------------------------------

sw_temp     db      0
SW_VIDEO_BUFFER_SEGMENT =   0B000h
SW_VIDEO_BUFFER_SIZE    =   82 * 2
;; make sure we are in word boundary because they are accessed from
;; 32bits code
    EVEN
sw_video_dirty_count    dw      0
sw_video_busy           dw      0
sw_video_io proc    near
;stop 32bits code from accessing shared variables.
;We do not bop to 32bits at all unless our buffer doesn't have
;enough space for the new data. The 32 bits code would refresh
;our buffer contents to the console periodically.
;
        inc     cs:sw_video_busy            ;indicate we are busy
                                            ;this is the basic sync mechanism
                                            ;with 32bits stream_io update code
        cmp     ax,13ffh                    ;secret write string?
        jne     sw_check_write_tty          ;no, check for write tty
        cmp     cx, 1
        je      sw_video_string_1

        push    si
        mov     si, SW_VIDEO_BUFFER_SIZE
        sub     si, cs:sw_video_dirty_count
        cmp     cx, si
        jae     sw_video_overflow

        push    di
        push    cx
        push    dx
        push    ds
        push    es
        mov     dx, es                      ;ds:di ptr to the string
        mov     ds, dx
        mov     dx, SW_VIDEO_BUFFER_SEGMENT
        mov     es, dx
        mov     dx, cx
        mov     si, di
        mov     di, cs:sw_video_dirty_count
        cld                                 ;ds:si ptr to the string
        shr     cx, 1                       ;cs has the byte count
        rep     movsw
        adc     cl, 0
        rep     movsb
        add     cs:sw_video_dirty_count, dx
        pop     es
        pop     ds
        pop     dx
        pop     cx
        pop     di
        pop     si
        stc                                 ;tell the caller we've done it
        dec     cs:sw_video_busy
        ret

sw_video_string_1:
        push    ax
        mov     ah, 0eh
        mov     al, es:[di]
        call    sw_video_write_tty
        pop     ax
        ret
;; this should be a rare case as we have a big buffer
;; we go directly to 32bits and we will take care of it there
sw_video_overflow:
        pop     si
        dec     cs:sw_video_busy
        bop     EGA_VIDEO_BOP               ;not free buffer space
        stc                                 ;do it on 32bits
        ret

sw_check_write_tty:
        cmp     ah, 0eh
        jne     sw_mode_change              ;we have to enable video h/w

sw_video_write_tty:
        push    si
        mov     si, cs:sw_video_dirty_count     ;the current count(index)
        cmp     si, SW_VIDEO_BUFFER_SIZE
        jae     sw_video_overflow
        push    ds
        mov     si, SW_VIDEO_BUFFER_SEGMENT
        mov     ds, si
        mov     si, cs:sw_video_dirty_count
        mov     ds:[si], al                 ;put it in the buffer
        inc     si
        mov     cs:sw_video_dirty_count, si ;new count, new index
        pop     ds
        pop     si
sw_video_done:
        stc
        dec     cs:sw_video_busy
        ret

sw_mode_change:
        push    ax
        mov     ax, 013FEh                  ;tell 32bits to initialize
        bop     EGA_VIDEO_BOP               ;video hardware for us
        pop     ax
        clc                                 ;tell caller we didn't do any
        dec     cs:sw_video_busy
        ret
sw_video_io endp

;
; Tim August 92. Video BIOS grabber.
; Call SPC BIOS when in windowed mode and the host BIOS when in full-screen.
; Controled by value of 'use_host_int10'.
; Try to limit bops by validating calling values. Mouse has to get first shot
; and then video bios.
;

use_host_int10     db 01h       ; native/softpc bios flag
changing_mode      db 01h       ; delay handshake if in bios mode change

PUBLIC int10h_vector

int10h_vector:
        cmp     use_host_int10, STREAM_IO
        jne     hw_video_io
        call    sw_video_io
        jc      viddone
hw_video_io:
        cmp     use_host_int10, FULLSCREEN
        je      nativebios

        cmp     ah,VID_MODECHANGE       ; mode change??
        je      modechange
        cmp     ah,MAX_VIDEO_FUNC       ; range check
        ja      mousecheck              ; not a vid func but mouse has higher
        cmp     ah,MOUSE_LIGHT_PEN      ; light pen special case
        je      mousebios
spcbios:
        bop     EGA_VIDEO_BOP           ; regular windowed Int 10
        jmp     viddone

mousecheck:
        cmp     ah,VID_VESA_BIOS        ; Is VESA bios call?
        jne     short @f                ; ne, no, proceed normally

        bop     MOUSE_VID_BOP           ; yes, will go fullscreen
        jmp     jmp_native              ; and handle the int10 by native bios

@@:
        cmp     ah,MIN_MOUSE_FUNC       ; range check mouse fn f0-f7 + fa.
        jb      badvid
        cmp     ah,MAX_MOUSE_FUNC
        jbe     mousebios
        cmp     ah,XTRA_MOUSE_FUNC
        jne     badvid

mousebios:                              ; call softpc mouse video entrypoint
        bop     MOUSE_VID_BOP
        jmp     viddone

modechange:                     ; windowed modechange. Mouse gets a look
        mov     changing_mode,1 ; then softpc video bios. If gfx mode then
        bop     MOUSE_VID_BOP   ; will go fullscreen
        ;;;nop
        ;;;nop                  ; nops aid debugging
        ;;;bop  EGA_VIDEO_BOP   ; will go fullscreen here
        nop
        nop
        push    ax              ; save video mode which may have top bit set
        and     ax,7fh
        cmp     al,3
        jbe     endmode         ; if graphics mode, repeat modechange to setup
        cmp     al,7            ; video card, else fall through
        je      endmode
        pop     ax
        jmp     nativebios
endmode:
        pop     ax
        mov     changing_mode,0 ; Clear 'mode changing' flag.

viddone:
        jmp     iret_com

badvid:                         ; unrecognised video func
        stc
        jmp viddone

nativebios:
        mov     changing_mode,0         ; Clear 'mode changing' flag.
        cmp     ax,MS_VIDEO_STRING      ; ensure not MS special video string fn
        je      ms_wrt_string

        cmp     ah,MIN_MOUSE_FUNC       ; could be a mouse call
        jb      chk_mse_vid
        cmp     ah,MAX_MOUSE_FUNC       ; range check mouse fn f0-f7 + fa.
        jbe     mousebios
        cmp     ah,XTRA_MOUSE_FUNC
        je      mousebios
        jmp     jmp_native              ; probably bad func but...

chk_mse_vid:
        cmp     ah,MOUSE_LIGHT_PEN      ; mouse handles light pen
        je      mousebios
        cmp     ah,VID_MODECHANGE
        jne     chk_font_change
        bop     MOUSE_VID_BOP   ; mouse wants first sniff at mode changes
        jmp     jmp_native      ; then fall through
chk_font_change:
        cmp     ah,GET_FONT_FUNC
        jne     jmp_native
        bop     MOUSE_VID_BOP   ; select mouse buffer for new no. of lines
                                ; then fall through

jmp_native:

                   db      0EAh     ; far jump
host_int10         dd      ?        ; to native int 10 vector

ms_wrt_string:
        push    si
        push    di
        push    bp
go_loop1:
        mov     dx,46h          ; looks a good value for flags
        push    dx              ; make an iret frame
        push    cs
        mov     bx, offset go_cont
        push    bx
        mov     bx,7            ; set foreground color
        mov     ah,0eh          ; set command to write a character
        mov     al,es:[di]      ; get char
        inc     di
        jmp     jmp_native      ; make far jmp to int 10 vector

go_cont:
        loop    go_loop1        ;repeat until all through
        pop     bp
        pop     di
        pop     si
        mov     ax,1            ; return success
goto_viddone:
        jmp     viddone
;
; int 42 - 'old' video bios entry point. Use same windowed/fullscreen
; redirection as Int 10 above.
;
int42h_vector:
        cmp     use_host_int10, STREAM_IO
        jne     hw_video_io_42
        call    sw_video_io
        jc      goto_viddone

hw_video_io_42:
        cmp     use_host_int10, FULLSCREEN
        jz      maybe_host_42_bios

        bop     10h     ; old video bop
        jmp     iret_com

        ; If it's the special BIOS print string function, don't call the
        ; host video BIOS cos it won't know what we are talking about.
        ; It's only in our video BIOS.
maybe_host_42_bios:
        cmp     AH, 013h
        jnz     gogo_host_42_bios
        cmp     AL, 0ffh
        jz      ms_wrt_string           ; reuse path from Int 10

gogo_host_42_bios:
                   db      0EAh     ; far jump
host_int42         dd      ?        ; to native int 42 vector

int10h_caller:
        int     10h     ; Re-entrant video entry point.
        bop     0feh

int11h_vector:          ; Equipment check.
        bop     11h
        jmp     iret_com
int12h_vector:          ; Get memory size, copied from BIOS2.ASM
        bop     12h
        jmp     iret_com

; IVT 13 is floppy io, grabbed above to fake error status.

int14h_vector:          ; RS-232 serial comms, copied from BIOS2
        bop     14h
        jmp     iret_com

; Int 15 cassette io, is done above.



; Idle indicators- All word sized, and dword aligned
; Int 16 keyboard vector

        align   4
        public Icounter,CharsPerTick,MinTicks

Icounter        dw  0
                dw  0
CharsPerTick    dw  0
                dw  0
MinTicks        dw  50
                dw  0

int16h_vector:
        push    ds
        push    bx
        mov     bx, 40h           ; bios data adressable
        mov     ds, bx
        cmp     ah, 10h
        call    DOCLI             ; make sure interrupts are off
        jb      i16vStdFns
        jmp     i16vExtFns


        ; The dispatch code must preserve the jz,dec,dec pattern
        ; to return the same ah value as is returned by the
        ; standard bios (0 for supported unless otherwise documented
        ; and nonzero for unsupported). This is because some apps look
        ; at the ret value of ah even tho it is a side effect of the
        ; original dispatch code in the rom bios.

i16vStdFns:
        or      ah, ah
        jz      i16v00h           ; read key, wait
        dec     ah
        jz      i16v01h           ; read key no wait
        dec     ah
        jz      i16v02h           ; get shift state
        dec     ah
        jz      i16viret          ; we don't support ah=3, set kbd rate
        dec     ah
        jz      i16viret          ; undefined function
        dec     ah
        jz      i16v05h           ; push char into kbd buffer
                                  ; the rest are undefined\unsupported

        ; normal iret exit
i16viret:
        pop     bx
        pop     ds
        jmp     iret_com


        ; return shift state in al
i16v02h:
        mov     al, ds:[KB_FLAG]
        jmp     i16viret


i16v05h:
        push    si
        mov     bx, word ptr ds:[BUFFER_TAIL]
        mov     si, bx
        call    IncrBuffPtr
        cmp     bx, word ptr ds:[BUFFER_HEAD]
        je      i16v05h1
        mov     word ptr ds:[si], cx
        mov     word ptr ds:[BUFFER_TAIL], bx
        mov     al, 0
        pop     si
        jmp     i16viret

i16v05h1:
        mov     al, 1
        pop     si
        jmp     i16viret


        ; read a character, wait if none available
i16v00h:
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        jne     i16v00h1
        call    DOSTI
        mov     ax, 09002h
        int     15h              ; wait device

i16v00h0:
        call    DOCLI
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]

i16v00h1:
        call    UpdateLed
        jne     i16v00h2
        call    IdlePoll
        jmp     i16v00h0

i16v00h2:        ; translate.....
        mov     ax, [bx]
        call    IncrBuffPtr
        mov     word ptr ds:[BUFFER_HEAD], bx
        call    TranslateStd
        jc      i16v00h0
        call    IdleInit
        jmp     i16viret


        ; read a character, nowait if none available
i16v01h:
        mov     bx, word ptr ds:[BUFFER_HEAD]  ;;maybe should turn IF on ??
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        mov     ax, [bx]
        call    UpdateLed
        je      i16vretf1

        call    IdleInit
        call    TranslateStd
        call    DOSTI
        jnc     i16vretf5             ; got a key, all done!
        call    IncrBuffPtr           ; throw away key
        mov     word ptr ds:[BUFFER_HEAD], bx
        jmp     i16v01h               ; go for the next one


        ; ExtKbd read a character, nowait if none available
i16v11h:
        mov     bx, word ptr ds:[BUFFER_HEAD]  ;;maybe should turn IF on ??
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        mov     ax, [bx]
        call    UpdateLed
        je      i16vretf1          ; common retf stuff for nowait

        call    IdleInit
        call    TranslateExt
        call    DOSTI
        jmp     i16vretf5


         ; retf2 exit preserving flags
i16vretf1:
        call  DOSTI
        push  ax
        lahf
        push  ax

        mov   ax, cs:Icounter
        cmp   ax, cs:MinTicks
        jb    i16vretf2

        mov   ah, 1               ; polling kbd, idle now
        BOP   16h
        jmp   i16vretf4

i16vretf2:
        inc   cs:CharsPerTick


i16vretf4:
        pop  ax
        sahf
        pop  ax

i16vretf5:
        pop     bx
        pop     ds
        retf    2



i16vExtFns:
        sub     ah, 10h
        jz      i16v10h           ; extended read key, wait
        dec     ah
        jz      i16v11h           ; extended read key, nowait
        dec     ah
        jz      i16v12h           ; extended shift status
        jmp     i16viret          ; undefined


        ; return extended shift state
i16v12h:
        mov     al, ds:[KB_FLAG_1]
        mov     ah, al
        and     al, SYS_SHIFT
        push    cx
        mov     cl, 5
        shl     al, cl
        pop     cx
        and     ah, NOT (SYS_SHIFT+HOLD_STATE+INS_SHIFT)
        or      al, ah
        mov     ah, ds:[KB_FLAG_3]
        and     ah, KBF3_ALT_CTRL
        or      ah, al
        mov     al, ds:[KB_FLAG]
        jmp     i16viret


        ; ExtKbd read a character, wait if none available
i16v10h:
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        jne     i16v10h1
        call    DOSTI
        mov     ax, 09002h
        int     15h              ; wait device

i16v10h0:
        call    DOCLI
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]

i16v10h1:
        call    UpdateLed
        jne     i16v10h2
        call    IdlePoll
        jmp     i16v10h0

i16v10h2:        ; translate.....
        mov     ax, [bx]
        call    IncrBuffPtr
        mov     word ptr ds:[BUFFER_HEAD], bx
        call    TranslateExt
        call    IdleInit
        jmp     i16viret



; IdlePoll  - Spins waiting for a key, doing idle callouts as needed
;             flags trashed, all registers preserved
;             interrupts are left on upon exit
;
IdlePoll  proc near
          push  ax

          call  DOSTI
          mov   ah, 2                          ; Idle_waitio
          BOP   16h
IPoll1:
          mov   bx, word ptr ds:[BUFFER_HEAD]
          cmp   bx, word ptr ds:[BUFFER_TAIL]  ; interrupts are off only
          jne   IPoll3                         ; safe to peek for change

          mov   ax, cs:Icounter
          cmp   ax, cs:MinTicks
          jae   IPoll2
          inc   cs:CharsPerTick
          jmp   IPoll1
IPoll2:
          mov   ah, 1                          ; idle now
          BOP   16h
IPoll3:
          pop   ax
          ret
IdlePoll  endp




; IdleInit - reinits the idle indicators, dups functionality
;            of IDLE_init()
;
IdleInit  proc near

          mov cs:Icounter, 0
          mov cs:CharsPerTick, 0

          ret
IdleInit  endp


;  TranslateExt - Retrieves and translates next scan code
;  pair for extended kbd
;
;  input:   ax - raw scan code pair
;  output:  ax - translated scan code pair
;
;  all other flags,registers preserved

TranslateExt proc near

             push    bx
             push    ax
             lahf
             mov     bx, ax
             pop     ax
             push    bx

             cmp     al, 0f0h
             jne     TExt1
             or      ah, ah
             jz      TExt1
             xor     al, al
TExt1:
             mov     bx, ax
             pop     ax
             sahf
             mov     ax, bx
             pop     bx
             ret

TranslateExt endp


;  TranslateStd - Retrieves and translates next scan code
;  pair for standard kbd
;
;  input:   ax - raw scan code pair
;  output:  ax - translated scan code pair
;  returns carry for throw away
;  all other flags,registers preserved

TranslateStd proc near

            push    bx
            push    ax
            lahf
            mov     bx, ax
            pop     ax
            push    bx

            cmp     ah, 0e0h
            jne     TStd1

            ; keypad enter or '/'
            mov     ah, 1ch        ; assume enter key
            cmp     al, 0dh
            je      TStdNoCarry
            cmp     al, 0ah
            je      TStdNoCarry
            mov     ah, 35h        ; oops it was key pad!
            jmp     TStdNoCarry

TStd1:
            cmp     ah, 84h
            ja      TStdCarry      ; extended key ?

            cmp     al, 0f0h       ; fill in key ?
            jne     TStd2
            or      ah, ah         ; ah = 0 is special
            jz      TStdNoCarry
            jmp     TStdCarry

TStd2:
            cmp     al, 0e0h       ; convert to compatible output
            jne     TStdNoCarry
            or      ah, ah
            jz      TStdNoCarry
            xor     al, al

TStdNoCarry:
            mov     bx, ax
            pop     ax
            sahf
            mov     ax, bx
            pop     bx
            clc
            ret

TStdCarry:
            mov     bx, ax
            pop     ax
            sahf
            mov     ax, bx
            pop     bx
            stc
            ret
TranslateStd endp



; IncrBuffPtr - increments the buffer pointer
;
; input:  ds:bx - curr buf ptr
; output: ds:bx - new buf ptr
; does not update the bios buf ptr

IncrBuffPtr  proc near
             inc bx
             inc bx
             cmp bx, word ptr ds:[BUFFER_END]
             jne ibpExit
             mov bx, word ptr ds:[BUFFER_START]
ibpExit:
             ret
IncrBuffPtr  endp



; UpdateLed - forms the data byte for the mode indicators
;             updates the led bits (MAKE_LED,SEND_LED)
;
; input:  none
; output: led bits updated
;
; Caveats: all low flags,registers preserved
;          MUST be called with interrupts off
;          does not update the kbd hardware (send_led)
;
UpdateLed  proc near

           push bx
           push cx
           push ax
           lahf
           push ax

           ; make_led
           mov  al, byte ptr ds:[KB_FLAG]            ; get led bits
           and  al, CAPS_STATE+NUM_STATE+SCROLL_STATE
           mov  cl, 4
           shr  al, cl                               ; shift for kb_flag_2
           and  al, KB_LEDS                          ; only led mode bits

           mov  bl, byte ptr ds:[KB_FLAG_2]
           xor  bl, al                               ; see if different
           and  bl, KB_LEDS                          ; only led mode bits
           jz   UledExit


           test byte ptr ds:[KB_FLAG_2], KB_PR_LED   ;if update under way
           jnz  ULedExit                             ;    skip update
           or   byte ptr ds:[KB_FLAG_2], KB_PR_LED   ;else upd in progress

           shl   bl, cl                              ; add in changebits
           or    al, bl                              ; to hi nibble of al
           mov   ah, 3                               ; inform softpc to set lights
           BOP   16h

           and  byte ptr ds:[KB_FLAG_2], NOT KB_LEDS   ; clear led bits
           and  al, 0fh                                ; remove change bits
           or   byte ptr ds:[KB_FLAG_2], al            ; stick in new led bits

           and  byte ptr ds:[KB_FLAG_2], NOT KB_PR_LED ; clear upd bit


ULedExit:
           pop  ax
           sahf
           pop  ax
           pop  cx
           pop  bx

           ret
UpdateLed  endp




; IVT 17 is printer IO, done above.

int18h_vector:          ; ROM BASIC, copied from BIOS2.ASM
        bop     18h
        jmp     iret_com
int19h_vector:          ; reboot vector, we terminate vdm!
        bop     19h
        jmp     iret_com


IdleTicLo   dw  0
IdleTicHi   dw  0
IdleTicNum  db  0

int1Ah_vector:          ; Time of day.
        call    DOSTI
        cmp     ah, 2
        jb      i1aTic1

        bop     1ah
        jmp     iret_com

i1aTic1:
        push    ds                                  ; bios data adressable
        push    bx
        push    ax
        mov     ax, 40h
        mov     ds, ax
        pop     ax
        call    DOCLI

        or      ah, ah                              ; fn 0 or fn 1 ?
        jnz     i1aTic5

i1aTic2:
        mov     al, byte ptr ds:[TIMER_OVFL]        ; GetTickCount
        mov     cx, word ptr ds:[TIMER_HIGH]
        mov     dx, word ptr ds:[TIMER_LOW]


        ; If time stamp is within 1 tic of curr tic count
        ; do idle polling managment

        cmp     cs:IdleTicHi, cx                    ; check TIMER_HIGH
        jnz     i1aTic8

        mov     bx, cs:IdleTicLo                    ; check TIMER_LOW
        cmp     bx, dx
        jz      i1aTic3
        inc     bx
        cmp     bx, dx
        jnz     i1aTic8


i1aTic3:
        inc     cs:IdleTicNum                       ; Yes, inc poll count
        cmp     cs:IdleTicNum, 16                   ; Is poll count too hi ?
        jb      i1aTic9

        call    DOSTI
        xor     ax,ax                               ; Yes, do idle BOP
        dec     cs:IdleTicLo                        ; make sure only bop once
        BOP     5ah
        call    DOCLI
        jmp     short i1aTic2

i1aTic5:
        mov     word ptr ds:[TIMER_LOW], dx         ; SetTickCount
        mov     word ptr ds:[TIMER_HIGH], cx

i1aTic8:
        mov     cs:IdleTicNum, 0                    ; reset idle indicators

i1aTic9:
        mov     cs:IdleTicLo, dx                    ; store time stamp
        mov     cs:IdleTicHi, cx
        mov     byte ptr ds:[TIMER_OVFL], 0         ; common TicCount exit
        pop     bx
        pop     ds
        jmp     iret_com


; IVT 1B is keyboard break, set to dummy.


int1Eh_vector:
        bop     1eh
        jmp     iret_com

int70h_vector:          ; Real time clock, copied from BIOS1.ASM
        bop     70h     ; rtc_bios.c:rtc_int()
        jmp     iret_com

int4Ah_caller:
        call    DOSTI   ; Called from base\bios\rtc_bios.c:rtc_int()
        int     4ah     ; User installed alarm.
        jmp     r1
r1:     jmp     r2
r2:     jmp     r3
r3:
        call    DOCLI
        bop     0feh

int71h_vector:          ; redirect, copied from BIOS1.ASM
        bop     71h
        int     0Ah
        jmp     iret_com
int75h_vector:          ; NPX 287.
        bop     75h
        int     02h
        jmp     iret_com
;=================================================================
; End of pseudo-ROM vectuz.
;=================================================================


;================================================================
; Wait for interrupts
;================================================================

cpu_nop_code:
        call    DOSTI
        jmp     short nxt1
nxt1:   jmp     short nxt2
nxt2:   jmp     short nxt3
nxt3:   bop     %BIOS_CPU_QUIT

           public SpcKbdEnd
SpcKbdEnd  label byte

        align   4                       ;; makes MIPS happy

; offset table for redirected functions
ifdef JAPAN
kio_table dw  34 dup(?)
else ; !JAPAN
kio_table dw  33 dup(?)
endif ; !JAPAN

        public InstSpcKbd

;
; InstSpcKbd - Installs the softpc custom interrupt hooks
;
; Inputs:  ds == Resident location of SysInitSeg
; Outputs: None
;
InstSpcKbd   proc near

        pusha
        call    DOCLI

        ; The following vectors are used for both x86\mips
        ; The dos interrupts Int 25\Int26 are handled by the dos kerenl
        xor     ax, ax
        mov     es, ax
        mov     word ptr es:[08h*4], offset int08h_vector
        mov     word ptr es:[(08h*4)+2], ds
        mov     word ptr es:[09h*4], offset int09h_vector
        mov     word ptr es:[(09h*4)+2], ds
        mov     word ptr es:[13h*4], offset int13h_vector
        mov     word ptr es:[(13h*4)+2], ds
        mov     word ptr es:[16h*4], offset int16h_vector
        mov     word ptr es:[(16h*4)+2], ds
        mov     word ptr es:[40h*4], offset int40h_vector
        mov     word ptr es:[(40h*4)+2], ds
        mov     word ptr es:[19h*4], offset int19h_vector
        mov     word ptr es:[(19h*4)+2], ds
        mov     word ptr es:[1ah*4], offset int1Ah_vector
        mov     word ptr es:[(1ah*4)+2], ds



        ; BOP 5F - send interesting addresses to softpc C BIOS
        ;  CS seg of kio_table
        ;  DS seg of resident keyboard code
        ;  DI offset of bop table
        ;  CX size of bop table entry
        ;  SI offset of kio_table
        mov     si,offset sysinitgrp:kio_table
        push    ds
        push    cs
        pop     ds
        mov     word ptr [si],    offset shift_keys     ;K6
        mov     word ptr [si+2],  offset shift_masks   ;K7
        mov     word ptr [si+4],  offset ctl_n_table   ;K8
        mov     word ptr [si+6],  offset ctl_f_table   ;K9
        mov     word ptr [si+8],  offset lowercase     ;K10
        mov     word ptr [si+10], offset uppercase     ;K11
        mov     word ptr [si+12], offset alt_table     ;K30
        mov     word ptr [si+14], offset dummy_vector
        mov     word ptr [si+16], offset print_screen_caller
        mov     word ptr [si+18], offset int15h_caller
        mov     word ptr [si+20], offset cpu_nop_code
        mov     word ptr [si+22], offset int15h_vector
        mov     word ptr [si+24], offset Icounter
        mov     word ptr [si+26], offset int4Ah_caller
        mov     word ptr [si+28], offset keyboard_break_caller
        mov     word ptr [si+30], offset int10h_caller
        mov     word ptr [si+32], offset int10h_vector
        mov     word ptr [si+34], offset use_host_int10
        mov     word ptr [si+36], offset ega_parm_setup
        mov     word ptr [si+38], offset changing_mode
        mov     word ptr [si+40], offset prt_status
        mov     word ptr [si+42], offset wait_int
        mov     word ptr [si+44], offset floppy_table
        mov     word ptr [si+46], offset vga_1b_table
        mov     word ptr [si+48], offset conf_table
        mov     word ptr [si+50], offset int08h_vector
        mov     word ptr [si+52], offset int13h_vector
        mov     word ptr [si+54], offset int13h_caller
        mov     word ptr [si+56], SW_VIDEO_BUFFER_SIZE
        mov     word ptr [si+58], SW_VIDEO_BUFFER_SEGMENT
        mov     word ptr [si+60], offset sw_video_dirty_count
        mov     word ptr [si+62], offset sw_video_busy
ifdef JAPAN
    mov word ptr [si+64], offset int16h_caller
endif ; JAPAN
; The last entry is reserved for assertion checking
ifdef JAPAN
    mov word ptr [si+66], VERSIONID
else ; !JAPAN
        mov     word ptr [si+64], VERSIONID
endif ; !JAPAN
        pop     ds

        ; mov    si, offset kio_table
        mov     di, offset iret_bop_table
        mov     cx, offset iret_end_first_entry  - offset iret_bop_table
        mov     ax, VERSIONID
        bop     5fh
        jc      isk_int9

        ;
        ; Risc only
        ;

        xor     ax, ax
        mov     es, ax
        mov     word ptr es:[17h*4], offset int17h_RiscVector
        mov     word ptr es:[(17h*4)+2], ds

        ;
        ; End Risc only
        ;
        jmp     isk_Exit

isk_int9:

        ;
        ; X86 only
        ;

        ; save old video int
        xor     ax, ax
        mov     es, ax
        mov     bx, es:[40h]
        mov     si, offset host_int10
        mov     word ptr ds:[si], bx
        mov     bx, es:[42h]
        mov     word ptr ds:[si+2], bx

        ; save old secondary video int (42h)
        mov     bx, es:[108h]
        mov     si, offset host_int42
        mov     word ptr ds:[si], bx
        mov     bx, es:[10ah]
        mov     word ptr ds:[si+2], bx


;-----------------------------------------------------------
;
; Crazy vector grabber
;
; Works OK on DEC PC when grab INT's 6, 11, 16, 17, 42.
; Now try and avoid all accesses to host ROM.
;
; At this point we assume ES=0
;-----------------------------------------------------------

     ; Grab some prominent vectors for pseudo-ROM routines.
     ; start at Int 0h and work our way up as needed
     cld

     mov   di, 20
     mov   ax, offset int05h_vector  ; INT 05h
     stosw                                             ; Print screen
     mov   ax, ds
     stosw
     mov   ax, offset int06h_vector  ; INT 06h
     stosw                                             ; Illegal instruction.
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 07h
     stosw
     mov   ax, ds
     stosw

     ; int 8h Timer hardware vector already done for both x86\mips
     ; int 9h kbd hardware vector already done for both x86\mips
     add   di, 8

     mov   ax, offset unexp_int      ; INT 0ah
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0bh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0ch
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0dh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int0e_vector   ; INT 0eh
     stosw                                             ; Floppy hardware int.
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0fh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int10h_vector  ; INT 10h
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int11h_vector  ; INT 11h
     stosw                                             ; Equipment check.
     mov   ax, ds
     stosw
     mov   ax, offset int12h_vector  ; INT 12h
     stosw                                             ; Get memory size.
     mov   ax, ds
     stosw

     ; int 13h already done (see above) for both mips\x86

     mov   di, 14h*4                                   ; Communications.
     mov   ax, offset int14h_vector
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int15h_vector  ; INT 15h
     stosw
     mov   ax, ds
     stosw

     ; int 16h kbd hardware vector already done for both x86\mips
     add   di, 4

     mov   ax, offset int17h_vector  ; INT 17h
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int18h_vector  ; INT 18h
     stosw                                             ; ROM BASIC.
     mov   ax, ds
     stosw

     ; int 19h (reboot vector) already done for both x86\mips

     ; int 1ah, time of day, already done for both x86\mips

     mov   di, 1Bh*4
     mov   ax, offset dummy_vector   ; INT 1Bh
     stosw                                             ; Keyboard break.
     mov   ax, ds
     stosw
     mov   ax, offset dummy_vector  ; INT 1Ch
     stosw                                             ; Timer tick.
     mov   ax, ds
     stosw

     mov   di, 1Eh*4                                   ; Floppy parameters.
     mov   ax, offset bios_floppy_table
     stosw
     mov   ax, ds
     stosw

     ; int 40h already done (see above) for both mips\x86

     mov   di, 41h*4
     mov   ax, offset unexp_int      ; INT 41h
     stosw                                             ; Hard disk parameters.
     mov   ax, ds
     stosw
     mov   ax, offset int42h_vector  ; INT 42h
     stosw                                             ; Default video.
     mov   ax, ds
     stosw

     mov   di, 70h*4                                    ; Real time clock init.
     mov   ax, offset int70h_vector
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int71h_vector  ; INT 71h Redirect.
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 72h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 73h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 74h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int75h_vector  ; INT 75h 287 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 76h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 77h D11 int
     stosw
     mov   ax, ds
     stosw


isk_Exit:
;;
;; williamh, May 16, 1996
;; Photostyler blindly calls EMS function without even checking
;; if EMS driver ever exists at all. On most x86 machines, we are fine because
;; the ROM BIOS sets the vector to a valid address. On certain x86 machines
;; and all RISC machines, the vector is 0:0. This hack is to repoint
;; the vector to our dummy iret routine if it is not initialized. Windows 3.1
;; Windows 95 ALWAYS redirect this vector to their own, so they don't have
;; the problem as we do.
;; Also note that the application may skip the EMS calls if the system has
;; big memory(more than 16MB, maybe). In this case, the problem won't get hit
;; at all.
;;
;; ds = segment of ntio.sys resident portion. It is the segment of our
;; iret_com rountine
;;
     xor    di, di
     mov    es, di
     mov    di, 067h * 4                    ; the EMS vector
     mov    ax, es:[di]
     or     ax, es:[di + 2]                 ;; anything set for the vector?
     jnz    i67_patch_done
     mov    word ptr es:[di], offset iret_com
     mov    es:[di + 2], ds

i67_patch_done:
     call  DOSTI
     popa
     ret

InstSpcKbd  endp

SpcKbdSeg    ends
             end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\spcemm.asm ===
;
; spcemm.asm,
;
; 10-Dec-1992 Jonle , adapted from em_drvr.asm from Insignia solutions
;
; This code serves as a stub device driver for emm memory manager.
; Its sole purpose is for apps to be able to identify that an emm driver is
; loaded and that LIM services are available. This code is linked into the
; device driver chain contains a strategy, interrupt and device header
;
; The driver should only be loaded if emm memory is available
; from NTVDM.
;

BOP     MACRO   callid
        db      0c4h, 0c4h, callid
endm


;
; Request Header, for initialization
;
REQHEAD  STRUC
ReqLen   DB      ?               ; Length in bytes of request block
ReqUnit  DB      ?               ; Block Device unit number
ReqFunc  DB      ?               ; Type of request
ReqStat  DW      ?               ; Status Word
REQHEAD  ENDS

;
; Segment definitions for ntio.sys,
;
include biosseg.inc
include vint.inc

SpcEmmSeg    segment

        assume  cs:SpcEmmSeg,ds:nothing,es:nothing

;
; SpcEmmBeg - SpcEmmEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 11-Dec-1992 Jonle
;

        public SpcEmmBeg

SpcEmmBeg    label  byte


;
; character device Header
; must be first in the .sys file
;
        dd      -1               ;pointer to next device driver
        dw      8000H            ;attribute (plain character device)
        dw      offset STRATEGY  ;pointer to device "strategy" routine
        dw      offset Interrupt ;pointer to device "interrupt" routine
        db      'EMMXXXX0'       ;8 byte name DO NOT CHANGE THE NAME

;
; Request Header address, saved here by strategy routine
;
pReqHdr   dd ?


;
; Device "strategy" entry point, save request header address
;
Strategy proc far
         mov     word ptr cs:pReqHdr, bx
         mov     word ptr cs:pReqHdr+2, es
         ret
Strategy endp


; EmmIsr  - int 67h isr
;
EmmIsr:          ; LIM Isr
        bop     67h
emmiret:
        FIRET

; ret trap for em function 'alter page map & call'
EmmRet:
        bop     68h
        jmp     emmiret



;----------------------------------------------------------------------
; 	Device "interrupt" entry point
;----------------------------------------------------------------------
Interrupt PROC FAR

        push    es
        push    di

        les     di, cs:pReqHdr           ; check for valid commands
        cmp     es:[di.ReqFunc], 0ah
        je      validcmd
        cmp     es:[di.ReqFunc], 0
        je      validcmd

        mov     ax, 8003h                ; we don't handle anything else
        jmp     short irptexit

validcmd:
        xor     ax,ax

irptexit:
        or      ax, 0100h          ;tell em we finished
        mov     es:[di.ReqStat],AX ;store status in request header

        pop    di
        pop    es
        ret

Interrupt ENDP

          public SpcEmmEnd
SpcEmmEnd label  byte

          public InitSpcEmm
;
; InitSpcEmm  Initializes Spc 32 bit memory manager
;             returns ax=0 for success
;
; Inputs:  ds is expected seg for drv code, cs is temporary sysinitseg
; Outputs: ax zero for success
;
InitSpcEmm  proc near

           ; BOP 66 - initialize LIM memory
           ; pass the address of bop 68 to the em manager
           ; in ds:dx and to return the number of em pages in BX
           ;
           ; NOTE: All EMM options come from pif file
           ;       There are NO command line options
           xor     bx, bx
           mov     dx, offset EmmRet
           bop     66h
           cmp     bx, 0ffffh     ;ffff means incorrect config (eg no 64K gap)
           je      fail
           cmp     bx, 0          ;check expanded memory is available
           je      fail

           ; set up IVT for INT 67h
           FCLI
           xor     ax, ax
           mov     es, ax
           mov     bx, offset EmmIsr
           mov     word ptr es:[67h*4], bx
           mov     word ptr es:[(67h*4)+2], ds
           FSTI

           ret
fail:
           mov ax, 0ffffh
           ret

InitSpcEmm endp

SpcEmmSeg  ends
           end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\spcmse.asm ===
;       Program:        Installable Device Driver for Mouse.
;
;       Purpose:        to provide compatability with the
;                       Microsoft MOUSE.SYS device driver.
;                       the code here installs the driver and
;                       hooks the IVT in exactly the same
;                       way as the current Insignia MOUSE.COM.
;
;       Version:        1.00    Date: 28th October 1992.
;
;       Author:         Andrew Watson
;
;       Revisions:
;
;	23-June-1994 Williamh, made mode 4/5 and 12 work.
;
;       12-Sep-1992 Jonle, Merged with ntio.sys
;                          optimized loading of IVT
;
;       5-March-1993 Andyw, Moved fullscreen text pointer code
;                           from 32bit land to 16bit driver for
;                           for speed purposes.
;
;      This obj module is intially loaded in a temporary memory location
;      along with ntio.sys. Ntio.sys will copy the resident code (marked by
;      SpcMseBeg, SpcMseEnd) into the permanent memory location which resides
;      just below the normal device drivers loaded by config.sys.
;
;      The nonresident intialization code is run with CS= temp seg
;      and DS= final seg.
;
;
;****************************************************************

.286
        include vint.inc

;================================================================
; Defined constants used in the driver.
;================================================================


        VERSIONID       equ     0BEEFh
        MAXCMD          equ     16
        UNKNOWN         equ     8003h
        DONE            equ     0100h
        MOUSEVER        equ     0003h
        INT1_BOP        equ     0BAh
        INT2_BOP        equ     0BBh
        IO_LANG_BOP     equ     0BCh
        IO_INTR_BOP     equ     0BDh
        VIDEO_IO_BOP    equ     0BEh
        UNSIMULATE_BOP  equ     0FEh
        VIDEO           equ     010h
        UNEXP_BOP       equ     2
        FORCE_YODA      equ     05bh
        ANDYS_BOP       equ     060h
        STACKSIZE       equ     200h-1

        TRUE            equ     0
        FALSE           equ     1
        STORED          equ     0
        NOTSTORED       equ     1
        ON              equ     0
        OFF             equ     1

        MAJOR_RELEASE_NUMBER    equ     6
        MINOR_RELEASE_NUMBER    equ     26

ifdef DBCS
	MAX_VIDEO_NUMBER	equ	013h
	DBCS_TEXT_MODE_NUMBER	equ	MAX_VIDEO_NUMBER + 1
	DBCS_GRAPHIC_MODE_NUMBER    equ     12h
endif ; DBCS


;MACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROS

bop MACRO callid
    db 0c4h,0c4h,callid
endm



;=============================================================================
; Macro to reassign the stack segment register to point at the driver code
; segment and the stack pointer to point to the most significant word in an
; array reserved as the driver stack.
;=============================================================================


;; !!!! interrupt must be disabled before calling this function !!!!!!

make_stack      MACRO
        LOCAL   reent                   ;; a local symbol to this macro
;;	 call	 DOCLI			 ;; turn off interrupts during this
                                        ;; macro's execution even if the CPU
                                        ;; does this for you when modifying SS
        inc     cs:reentrant            ;; has the interrupt been nested?
        jnz     reent                   ;; not reentrant if == zero

        ;; The driver code is not reentrant, so start the stack at the beginning

        mov     cs:top_of_stack,ss      ;; save the entry SS
        mov     cs:top_of_stack-2,sp    ;; save SP on the stack
        push    cs                      ;; the current code/data segment
        pop     ss                      ;; point SS at CS

        ;; point SP at the next free stack location.

        mov     sp,offset top_of_stack-2 ;; The current stack pointer position

reent:  ;; REENTRANT > 0 therefore reentrancy exists
        ;; The driver has gone reentrant due to a nested interrupt, so just
        ;; leave the stack alone because it is the same under reentrancy.

;;	 call  DOSTI				 ;; reenable interrupts

        ENDM

;=============================================================================
; Macro to return the stack pointer and segment back to what it was when
; the driver was called.
;=============================================================================

kill_stack      MACRO
        LOCAL   reent1
;;	 cli
        cmp     cs:reentrant,0          ;; is the code currently reentrant?
        jg      reent1                  ;; yes it is
        mov     sp,cs:top_of_stack-2    ;; pop SP
        mov     ss,cs:top_of_stack      ;; pop SS
reent1:
        dec     cs:reentrant            ;; reduce the level of reentrancy
;;	 call	 DOSTI
        ENDM

;MACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROS

;
; Segment definitions for ntio.sys,
;
include biosseg.inc




SpcMseSeg    segment
             assume  cs:SpcMseSeg, ds:nothing, es:nothing

;
; SpcMseBeg - SpcMseEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 15-Sep-1992 Jonle
;

        public SpcMseBeg

SpcMseBeg    label  byte

  ; CAUTION: for crazy apps mouse recognition
  ;
  ; The offset for int33h_vector must not be Zero for Borlands QuattroPro
  ; The segment must not be in ROM area for pctools
  ; to keep the int33h_vector from having an offset of ZERO
  ; I have moved the data above it
  ; 25-Sep-1992 Jonle


; describe the default screen and cursor masks
; remember that x86 machines are little-endian

        ;;; include     pointer.inc
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;;; We'll Get this back to an include file soon but I'm including it like
 ;;;; this for 'diplomatic' reasons. (ie I want to check this in without
 ;;;; also doing an 'addfile' at this stage)!!! - Simon.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This data will be accessed, on occasion, word by word, so
; be tidy and align to a word boundary

align   2

; Describe the default mouse pointer image. This is used if the
; user decides to switch on the pointer without specifying an image.

default_cursor		dw	0011111111111111b
			dw	0001111111111111b
			dw	0000111111111111b
			dw	0000011111111111b
			dw	0000001111111111b
			dw	0000000111111111b
			dw	0000000011111111b
			dw	0000000001111111b
			dw	0000000000111111b
			dw	0000000000011111b
			dw	0000000111111111b
			dw	0001000011111111b
			dw	0011000011111111b
			dw	1111100001111111b
			dw	1111100001111111b
			dw	1111110001111111b
			dw	0000000000000000b
			dw	0100000000000000b
			dw	0110000000000000b
			dw	0111000000000000b
			dw	0111100000000000b
			dw	0111110000000000b
			dw	0111111000000000b
			dw	0111111100000000b
			dw	0111111110000000b
			dw	0111110000000000b
			dw	0110110000000000b
			dw	0100011000000000b
			dw	0000011000000000b
			dw	0000001100000000b
			dw	0000001100000000b
			dw	0000000000000000b

        ; Set up the memory where the working cursor is situated. It is
        ; initialised to the default cursor image

;****************** ALIGNED FOR PIXEL ZERO *******************************

                ; screen mask

even
current_cursor          db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,01111111b,11111111b
                        db      00000000b,00111111b,11111111b
                        db      00000000b,00011111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,10000000b,00000000b
                        db      01111111b,11000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignData1:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,01111111b,11111111b
                        db      10000000b,00111111b,11111111b
                        db      10000000b,00011111b,11111111b
                        db      10000000b,00001111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,01111111b,11111111b
                        db      10011000b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111110b,00111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,10000000b,00000000b
                        db      00111111b,11000000b,00000000b
                        db      00111111b,11100000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignData2:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000000b,00111111b,11111111b
                        db      11000000b,00011111b,11111111b
                        db      11000000b,00001111b,11111111b
                        db      11000000b,00000111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000100b,00111111b,11111111b
                        db      11001100b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111111b,00011111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,10000000b,00000000b
                        db      00011111b,11000000b,00000000b
                        db      00011111b,11100000b,00000000b
                        db      00011111b,11110000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignData3:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,01111111b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100000b,00011111b,11111111b
                        db      11100000b,00001111b,11111111b
                        db      11100000b,00000111b,11111111b
                        db      11100000b,00000011b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100010b,00011111b,11111111b
                        db      11100110b,00011111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,10001111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,10000000b,00000000b
                        db      00001111b,11000000b,00000000b
                        db      00001111b,11100000b,00000000b
                        db      00001111b,11110000b,00000000b
                        db      00001111b,11111000b,00000000b
                        db      00001101b,10000000b,00000000b
                        db      00001000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignData4:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,01111111b,11111111b
                        db      11110000b,00111111b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110000b,00001111b,11111111b
                        db      11110000b,00000111b,11111111b
                        db      11110000b,00000011b,11111111b
                        db      11110000b,00000001b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110001b,00001111b,11111111b
                        db      11110011b,00001111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,11000111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,10000000b,00000000b
                        db      00000111b,11000000b,00000000b
                        db      00000111b,11100000b,00000000b
                        db      00000111b,11110000b,00000000b
                        db      00000111b,11111000b,00000000b
                        db      00000111b,11111100b,00000000b
                        db      00000110b,11000000b,00000000b
                        db      00000100b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignData5:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,00111111b,11111111b
                        db      11111000b,00011111b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,00000111b,11111111b
                        db      11111000b,00000011b,11111111b
                        db      11111000b,00000001b,11111111b
                        db      11111000b,00000000b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,10000111b,11111111b
                        db      11111001b,10000111b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11100011b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,10000000b,00000000b
                        db      00000011b,11000000b,00000000b
                        db      00000011b,11100000b,00000000b
                        db      00000011b,11110000b,00000000b
                        db      00000011b,11111000b,00000000b
                        db      00000011b,11111100b,00000000b
                        db      00000011b,11111110b,00000000b
                        db      00000011b,01100000b,00000000b
                        db      00000010b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignData6:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00011111b,11111111b
                        db      11111100b,00001111b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,00000011b,11111111b
                        db      11111100b,00000001b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000000b,01111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,01000011b,11111111b
                        db      11111100b,11000011b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11110001b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,11000000b,00000000b
                        db      00000001b,11100000b,00000000b
                        db      00000001b,11110000b,00000000b
                        db      00000001b,11111000b,00000000b
                        db      00000001b,11111100b,00000000b
                        db      00000001b,11111110b,00000000b
                        db      00000001b,11111111b,00000000b
                        db      00000001b,10110000b,00000000b
                        db      00000001b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignData7:

                        db      11111110b,01111111b,11111111b
                        db      11111110b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00001111b,11111111b
                        db      11111110b,00000111b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00000001b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,01111111b
                        db      11111110b,00000000b,00111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00100001b,11111111b
                        db      11111110b,01100001b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11111000b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11100000b,00000000b
                        db      00000000b,11110000b,00000000b
                        db      00000000b,11111000b,00000000b
                        db      00000000b,11111100b,00000000b
                        db      00000000b,11111110b,00000000b
                        db      00000000b,11111111b,00000000b
                        db      00000000b,11111111b,10000000b
                        db      00000000b,11011000b,00000000b
                        db      00000000b,10001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000000b,00000000b


; Data area reserved for the clipped cursor images. When the pointer
; reaches byte 78 in the current raster, the image needs to be clipped
; to prevent it from being wrapped to the left hand edge of the screen.
; The image below stops that from happening by loading the image with
; a 1's partial AND mask and a 0's partial XOR mask.
; Note that byte 79 also needs a clipped image set.

even
clip_cursor78           db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,01111111b,11111111b
                        db      00000000b,00111111b,11111111b
                        db      00000000b,00011111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,10000000b,00000000b
                        db      01111111b,11000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignClip178:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,01111111b,11111111b
                        db      10000000b,00111111b,11111111b
                        db      10000000b,00011111b,11111111b
                        db      10000000b,00001111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,01111111b,11111111b
                        db      10011000b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111110b,00111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,10000000b,00000000b
                        db      00111111b,11000000b,00000000b
                        db      00111111b,11100000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignClip278:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000000b,00111111b,11111111b
                        db      11000000b,00011111b,11111111b
                        db      11000000b,00001111b,11111111b
                        db      11000000b,00000111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000100b,00111111b,11111111b
                        db      11001100b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111111b,00011111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,10000000b,00000000b
                        db      00011111b,11000000b,00000000b
                        db      00011111b,11100000b,00000000b
                        db      00011111b,11110000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignClip378:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,01111111b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100000b,00011111b,11111111b
                        db      11100000b,00001111b,11111111b
                        db      11100000b,00000111b,11111111b
                        db      11100000b,00000011b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100010b,00011111b,11111111b
                        db      11100110b,00011111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,10001111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,10000000b,00000000b
                        db      00001111b,11000000b,00000000b
                        db      00001111b,11100000b,00000000b
                        db      00001111b,11110000b,00000000b
                        db      00001111b,11111000b,00000000b
                        db      00001101b,10000000b,00000000b
                        db      00001000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignClip478:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,01111111b,11111111b
                        db      11110000b,00111111b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110000b,00001111b,11111111b
                        db      11110000b,00000111b,11111111b
                        db      11110000b,00000011b,11111111b
                        db      11110000b,00000001b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110001b,00001111b,11111111b
                        db      11110011b,00001111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,11000111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,10000000b,00000000b
                        db      00000111b,11000000b,00000000b
                        db      00000111b,11100000b,00000000b
                        db      00000111b,11110000b,00000000b
                        db      00000111b,11111000b,00000000b
                        db      00000111b,11111100b,00000000b
                        db      00000110b,11000000b,00000000b
                        db      00000100b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignClip578:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,00111111b,11111111b
                        db      11111000b,00011111b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,00000111b,11111111b
                        db      11111000b,00000011b,11111111b
                        db      11111000b,00000001b,11111111b
                        db      11111000b,00000000b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,10000111b,11111111b
                        db      11111001b,10000111b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11100011b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,10000000b,00000000b
                        db      00000011b,11000000b,00000000b
                        db      00000011b,11100000b,00000000b
                        db      00000011b,11110000b,00000000b
                        db      00000011b,11111000b,00000000b
                        db      00000011b,11111100b,00000000b
                        db      00000011b,11111110b,00000000b
                        db      00000011b,01100000b,00000000b
                        db      00000010b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignClip678:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00011111b,11111111b
                        db      11111100b,00001111b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,00000011b,11111111b
                        db      11111100b,00000001b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,01000011b,11111111b
                        db      11111100b,11000011b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11110001b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,11000000b,00000000b
                        db      00000001b,11100000b,00000000b
                        db      00000001b,11110000b,00000000b
                        db      00000001b,11111000b,00000000b
                        db      00000001b,11111100b,00000000b
                        db      00000001b,11111110b,00000000b
                        db      00000001b,11111111b,00000000b
                        db      00000001b,10110000b,00000000b
                        db      00000001b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignClip778:

                        db      11111110b,01111111b,11111111b
                        db      11111110b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00001111b,11111111b
                        db      11111110b,00000111b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00000001b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00100001b,11111111b
                        db      11111110b,01100001b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11111000b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11100000b,00000000b
                        db      00000000b,11110000b,00000000b
                        db      00000000b,11111000b,00000000b
                        db      00000000b,11111100b,00000000b
                        db      00000000b,11111110b,00000000b
                        db      00000000b,11111111b,00000000b
                        db      00000000b,11111111b,00000000b
       			db      00000000b,11011000b,00000000b
                        db      00000000b,10001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000000b,00000000b


clip_cursor79           db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignClip179:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,11111111b,11111111b
                        db      10011000b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignClip279:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000100b,11111111b,11111111b
                        db      11001100b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignClip379:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100010b,11111111b,11111111b
                        db      11100110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001101b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignClip479:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110011b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignClip579:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111001b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignClip679:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignClip779:

                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b

CursorOffsetLUT         dw      current_cursor
                        dw      AlignData1
                        dw      AlignData2
                        dw      AlignData3
                        dw      AlignData4
                        dw      AlignData5
                        dw      AlignData6
                        dw      AlignData7
ClipOffsetLUT78         dw      clip_cursor78
                        dw      AlignClip178
                        dw      AlignClip278
                        dw      AlignClip378
                        dw      AlignClip478
                        dw      AlignClip578
                        dw      AlignClip678
                        dw      AlignClip778
ClipOffsetLUT79         dw      clip_cursor79
                        dw      AlignClip179
                        dw      AlignClip279
                        dw      AlignClip379
                        dw      AlignClip479
                        dw      AlignClip579
                        dw      AlignClip679
                        dw      AlignClip779

; pointer to the current look up table set for the pointer image.
; The LUTs are swapped when the pointer enters bytes 78 and 79
; along a scanline to prevent the pointer wrapping around the screen.

PointerLUT              label   word
                        dw      offset  CursorOffsetLUT
 ;;;;;;;;;;;;;;;;;;;;;;;
 ;;;; End of what should be an include for pointer.inc
 ;;;;;;;;;;;;;;;;;;;;;;;

	even
        clrgend		dw	06e41h,07964h,05720h,07461h,06f73h,0f36eh
	hiresylut	dw	350,350,480,480
		
;============================================================================
; Surprisingly, a look up table multiply is much faster than
; the shift - add instruction sequence for multiplying by 80.
; So it would be crazy not to use it eh? Times by 80 is needed
; to convert a raster location (1 raster = 80 bytes) in pixel
; y coordinates into a video buffer byte index
; Note: Multiply by 80 is also used for text mode calculations
; now! Andy on the 9/3/93
;============================================================================
        even

        mult80lut       label   word

                mulsum=0
                REPT    480             ; number of VGA scanlines for mode 12h
                dw      mulsum
                mulsum=mulsum+80
                ENDM

;============================================================================
; A table to do a multiply by 320. This is used for converting number of
; rasters into video buffer offsets for mode 13h (256 VGA colour mode).
;============================================================================
        even

        mult320lut      label   word

                mulsum=0
                REPT    200             ; number of VGA scanlines for mode 13h
                dw      mulsum
                mulsum=mulsum+320
                ENDM
        even

;============================================================================
; Look up table for use with modes 10h and 12h. This table provides the means
; for the selection of a clipped or unclipped pointer image depending on the
; current x position of the pointer.
;============================================================================

        ChooseImageLUT  label   word

                REPT    624
                dw      offset CursorOffsetLUT
                ENDM

                REPT    8
                dw      offset ClipOffsetLUT78
                ENDM

                REPT    8
                dw      offset ClipOffsetLUT79
                ENDM

;============================================================================
; Buffer arranged for 4 plane EGA video modes. The screen where
; the pointer is going to be drawn is scanned plane by plane and
; saved as bitplane separations.
;============================================================================

        even            ; make sure that this data is word aligned

        behindcursor    dw      24 dup(?)       ; Plane 0
                        dw      24 dup(?)       ; Plane 1
                        dw      24 dup(?)       ; Plane 2
                        dw      24 dup(?)       ; Plane 3


;============================================================================
; a table of the video buffer segment for the supported
; BIOS text and graphics modes.
;============================================================================

        even            ; make sure that this data is word aligned

        videomodetable  dw      0b800h,0b800h   ; modes 0,1
                        dw      0b800h,0b800h   ; modes 2,3
                        dw      0b800h,0b800h   ; modes 4,5
                        dw      0b800h,0b000h   ; modes 6,7
                        dw      0ffffh,0ffffh   ; n/a
                        dw      0ffffh,0ffffh   ; n/a
                        dw      0ffffh,0a000h   ; n/a,mode 0dh
                        dw      0a000h,0a000h   ; modes 0eh,0fh
                        dw      0a000h,0a000h   ; modes 10h,11h
                        dw      0a000h,0a000h   ; modes 12h,13h
        videobufferseg  dw      ?

        even            ; make sure that this data is word aligned

        hotspot         dw      2 dup(0)

	VRAMlasttextcelloff	label	word	; last text offset in VRAM
        VRAMlastbyteoff dw      ?               ; Last offset in VRAM
	VRAMlastbitoff	dw	?		; LSB: Where pointer is in byte
						; MSB: ODD/EVEN of the pointer
						;      first scan line
	LastXCounters	dw	?		; last X looping counter
	LastYCounters	dw	?		; last Y looping counter
						; ODD in LSB and EVEN in MSB
	lasttextimage	dw	?		; text cell from last time

        background      dw      NOTSTORED       ; STORED if data in buffer
        current_position_x      dw      ?
        current_position_y      dw      ?
        vidbytealigned  dw      ?
        lastmaskrotate  dw      ?
        lastvidmode     db      0ffh    ; the video mode during the last int.
        internalCF      db      0ffh    ; the mouse driver keeps a flag called
                                        ; the internal cursor flag. If the flag
                                        ; = 0, then int 33h f1 will display the
                                        ; pointer, -1 = default value.

 	; 32 bit code writes to this area on a hardware interrupt and
	; when an app does an int 33h function 3, it reads the data
	; directly from here.
	; Data format is: word 0 -> button status
	;                 word 1 -> x virtual coordinate
	;                 word 2 -> y virtual coordinate

	function3data	dw	3 dup(?)

	conditional_off db	0	;!= 0 if conditional off is on
					;
;=============================================================================
; Data to determine the address of where the latches should be saved in the
; video buffer for the current video mode.
; latchcache contains the value looked up by saveVGAregisters and used by
; restoreVGAregisters.
;=============================================================================


        latchcache      dw      ?       ; location of latch cache in VRAM
even
latchhomeLUT    label   word
                        dw      ?               ; mode 0
                        dw      ?               ; mode 1
                        dw      ?               ; mode 2
                        dw      ?               ; mode 3
                        dw      ?               ; mode 4
                        dw      ?               ; mode 5
                        dw      ?               ; mode 6
                        dw      ?               ; mode 7
                        dw      ?               ; mode 8
                        dw      ?               ; mode 9
                        dw      ?               ; mode a
                        dw      ?               ; mode b
                        dw      ?               ; mode c
                        dw      ?               ; mode d
                        dw      80*200+78       ; mode e
                        dw      80*350+78       ; mode f
                        dw      80*350+78       ; mode 10
                        dw      80*480+78       ; mode 11
                        dw      80*480+78       ; mode 12
ifdef DBCS
			dw	80*480+78	; DBCS_TEXT_MODE
endif ; DBCS

;=============================================================================
; CGA video mode 4 is a 2 bit per pixel graphics mode. The pointer images
; received from the application (or the default images for that matter) are
; described by a one bit per pixel map. This look up table provides the means
; of conversion from one to two bits per pixel.
;=============================================================================
even
LUT1to2bit      label   word
        dw      00000h,00003h,0000Ch,0000Fh,00030h,00033h,0003Ch,0003Fh
        dw      000C0h,000C3h,000CCh,000CFh,000F0h,000F3h,000FCh,000FFh
        dw      00300h,00303h,0030Ch,0030Fh,00330h,00333h,0033Ch,0033Fh
        dw      003C0h,003C3h,003CCh,003CFh,003F0h,003F3h,003FCh,003FFh
        dw      00C00h,00C03h,00C0Ch,00C0Fh,00C30h,00C33h,00C3Ch,00C3Fh
        dw      00CC0h,00CC3h,00CCCh,00CCFh,00CF0h,00CF3h,00CFCh,00CFFh
        dw      00F00h,00F03h,00F0Ch,00F0Fh,00F30h,00F33h,00F3Ch,00F3Fh
        dw      00FC0h,00FC3h,00FCCh,00FCFh,00FF0h,00FF3h,00FFCh,00FFFh

        dw      03000h,03003h,0300Ch,0300Fh,03030h,03033h,0303Ch,0303Fh
        dw      030C0h,030C3h,030CCh,030CFh,030F0h,030F3h,030FCh,030FFh
        dw      03300h,03303h,0330Ch,0330Fh,03330h,03333h,0333Ch,0333Fh
        dw      033C0h,033C3h,033CCh,033CFh,033F0h,033F3h,033FCh,033FFh
        dw      03C00h,03C03h,03C0Ch,03C0Fh,03C30h,03C33h,03C3Ch,03C3Fh
        dw      03CC0h,03CC3h,03CCCh,03CCFh,03CF0h,03CF3h,03CFCh,03CFFh
        dw      03F00h,03F03h,03F0Ch,03F0Fh,03F30h,03F33h,03F3Ch,03F3Fh
        dw      03FC0h,03FC3h,03FCCh,03FCFh,03FF0h,03FF3h,03FFCh,03FFFh

        dw      0C000h,0C003h,0C00Ch,0C00Fh,0C030h,0C033h,0C03Ch,0C03Fh
        dw      0C0C0h,0C0C3h,0C0CCh,0C0CFh,0C0F0h,0C0F3h,0C0FCh,0C0FFh
        dw      0C300h,0C303h,0C30Ch,0C30Fh,0C330h,0C333h,0C33Ch,0C33Fh
        dw      0C3C0h,0C3C3h,0C3CCh,0C3CFh,0C3F0h,0C3F3h,0C3FCh,0C3FFh
        dw      0CC00h,0CC03h,0CC0Ch,0CC0Fh,0CC30h,0CC33h,0CC3Ch,0CC3Fh
        dw      0CCC0h,0CCC3h,0CCCCh,0CCCFh,0CCF0h,0CCF3h,0CCFCh,0CCFFh
        dw      0CF00h,0CF03h,0CF0Ch,0CF0Fh,0CF30h,0CF33h,0CF3Ch,0CF3Fh
        dw      0CFC0h,0CFC3h,0CFCCh,0CFCFh,0CFF0h,0CFF3h,0CFFCh,0CFFFh

        dw      0F000h,0F003h,0F00Ch,0F00Fh,0F030h,0F033h,0F03Ch,0F03Fh
        dw      0F0C0h,0F0C3h,0F0CCh,0F0CFh,0F0F0h,0F0F3h,0F0FCh,0F0FFh
        dw      0F300h,0F303h,0F30Ch,0F30Fh,0F330h,0F333h,0F33Ch,0F33Fh
        dw      0F3C0h,0F3C3h,0F3CCh,0F3CFh,0F3F0h,0F3F3h,0F3FCh,0F3FFh
        dw      0FC00h,0FC03h,0FC0Ch,0FC0Fh,0FC30h,0FC33h,0FC3Ch,0FC3Fh
        dw      0FCC0h,0FCC3h,0FCCCh,0FCCFh,0FCF0h,0FCF3h,0FCFCh,0FCFFh
        dw      0FF00h,0FF03h,0FF0Ch,0FF0Fh,0FF30h,0FF33h,0FF3Ch,0FF3Fh
        dw      0FFC0h,0FFC3h,0FFCCh,0FFCFh,0FFF0h,0FFF3h,0FFFCh,0FFFFh

;============================================================================
;   Table for selection of the correct pointer image for the current location
;   in the video buffer, when using video BIOS mode 4.
;============================================================================

mode4pointerLUT label   word
        REPT    76              ; for the first 76 bytes of scanline, use these
        dw      current_cursor
        dw      AlignData1
        dw      AlignData2
        dw      AlignData3
        ENDM
        dw      clip_cursor78
        dw      AlignClip178
        dw      AlignClip278
        dw      AlignClip378
        dw      AlignClip478
        dw      AlignClip578
        dw      AlignClip678
        dw      AlignClip778
        dw      clip_cursor79
        dw      AlignClip179
        dw      AlignClip279
        dw      AlignClip379
        dw      AlignClip479
        dw      AlignClip579
        dw      AlignClip679
        dw      AlignClip779

;============================================================================
;   Look up table to adjust CX on clipping in mode 4. This allows the mode4
;   pointer drawing algorithm to use the modes 10h/12h clipped pointer data
;   without having to modify it. The problem is that mode 10/12 expects the
;   data to be 4 bits per pixel and aligned to a word, whereas mode 4 is 2 bits
;   per pixel and aligns to a byte.
;============================================================================

mode4clipCXadjustLUT    label   word
        adjtemp=0               ; data for pixel x-coordinates 0 -> 307
        REPT    77
        dw      4 dup(adjtemp)
        adjtemp=adjtemp+1
        ENDM
        dw      4 dup(76)       ; data for pixels 308 -> 311
        dw      8 dup(78)       ; data for pixels 312 -> 319


;============================================================================
; The CGA buffer is split at 2000h. Therefore if the pointer starts writing
; below scanline 199 on the video display, the odd scanline video buffer
; will become corrupted. In these cases, the pointer should be clipped to
; display scanline 199. The look up table below maps loop counters to a
; display scanline for this purpose.
;
;       table arrangement       (odd scanline data, even scanline data)
;
;============================================================================

mode4clipDXLUT  label   word

        db      200-15  dup(8,8)        ; scanlines 0 -> 184
        db                  8,7         ; scanline  185
        db                  7,7         ; scanline  186
        db                  7,6         ; scanline  187
        db                  6,6         ; scanline  188
        db                  6,5         ; scanline  189
        db                  5,5         ; scanline  190
        db                  5,4         ; scanline  191
        db                  4,4         ; scanline  192
        db                  4,3         ; scanline  193
        db                  3,3         ; scanline  194
        db                  3,2         ; scanline  195
        db                  2,2         ; scanline  196
        db                  2,1         ; scanline  197
        db                  1,1         ; scanline  198
        db                  1,0         ; scanline  199

mode4SelectedPointer    label   word
        dw      ?

;==========================================================================
;   Some space into which the Medium resolution graphics pointer background
;   gets stored. Note that the 256 colour mode buffer encroaches on that of
;   mode 4.
;==========================================================================

bkgrnd256       label   byte            ; 256 colour buffer = 24*16 @ 1 byte/pix
        db      384-64  dup(?)          ; share the CGA buffer(=64 bytes)

CGAbackgrnd     label   byte

        db      24/4*16 dup(?)          ; 24 pixels/row @ 4 pixels/byte for 16
                                        ; rows.
ifdef DBCS
dbcs_vector	label	DWORD
dbcs_vector_off dw	0
dbcs_vector_seg dw	0

even
saved_ac_on_mouse_cursor    dw	    ?
line_buffer	db	((80 + 1) * 2) dup (?)
mouse_cursor_offset	    dw	    ?
saved_ac_cursor_position    dw	    ?
saved_ac_count		    dw	    ?
saved_ac_offset 	    dw	    ?
active_page		    db	    ?

video_io_enter_count	    db	    0

SCREENtoCHARCELL macro
	shr	cx, 3
	shr	dx, 3
	mov	dh, dl
	mov	dl, cl
	endm

endif ; DBCS

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   Pointer drawing routines.
;===========================================================================
even
drawpointerJMPT label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  drawTextPointer         ; mode 2
        dw      offset  drawTextPointer         ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  drawMediumResPointer    ; mode 4
	dw	offset	drawMediumResPointer	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  drawTextPointer         ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  drawHiResPointer        ; mode f
        dw      offset  drawHiResPointer        ; mode 10
        dw      offset  drawHiResPointer        ; mode 11
        dw      offset  drawHiResPointer        ; mode 12
        dw      offset  drawC256pointer         ; mode 13
ifdef DBCS
	dw	offset DBCS_drawTextPointer	;DBCS_TEXT_MODE_NUMBER
endif ; DBCS

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   INT 33h Function 1 support modules.
;===========================================================================
even
int33function1JMPT      label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function1      ; mode 2
        dw      offset  TextInt33Function1      ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  MediumResInt33Function1 ; mode 4
	dw	offset	MediumResInt33Function1	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function1      ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  HiResInt33Function1     ; mode f
        dw      offset  HiResInt33Function1     ; mode 10
        dw      offset  HiResInt33Function1     ; mode 11
        dw      offset  HiResInt33Function1     ; mode 12
        dw      offset  C256Int33Function1      ; mode 13
ifdef DBCS
	dw	offset DBCS_TextInt33Function1	; DBCS_TEXT_MODE_NUMBER
endif ; DBCS

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   INT 33h Function 2 support modules.
;===========================================================================
even
int33function2JMPT      label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function2      ; mode 2
        dw      offset  TextInt33Function2      ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  MediumResInt33Function2 ; mode 4
	dw	offset	MediumResInt33Function2	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function2      ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  HiResInt33Function2     ; mode f
        dw      offset  HiResInt33Function2     ; mode 10
        dw      offset  HiResInt33Function2     ; mode 11
        dw      offset  HiResInt33Function2     ; mode 12
        dw      offset  C256Int33Function2      ; mode 13
ifdef DBCS
	dw	offset	DBCS_TextInt33Function2 ; DBCS_TEXT_MODE_NUMBER
endif ; DBCS



;==========================================================================
;   Some storage space for the critical VGA registers.
;==========================================================================

;Sequencer Registers

seqregs         label   byte
                db      4 dup(?)        ; N.B. sequencer reset reg doesn't
                                        ; get saved.

; Graphics Controller Registers

GCregs          label   byte
                db      9 dup(?)

;==========================================================================
; The mouse driver's very own stack. To prevent unnecessary tears,
; particulary from the application running in DOS land, a stack is
; maintained by the driver. This prevents the driver routines from
; blowing a very full stack elsewhere.
; N.B. on leaving the driver, the stack should be empty!
;==========================================================================

even
mouse_stack     dw      STACKSIZE dup(?)
top_of_stack    label   word
                dw      ?       ; this is where the stack starts

;===========================================================================
; The memory variable below is incremented on entry to the 16 bit code
; and on exit, decremented. If an interrupt occurs during the execution of
; this 16 bit code, the flag is incremented again, and thus greater than zero
; so it is known that the code has been reentered and the stack must be
; maintained accordingly.
;===========================================================================

reentrant       dw      -1

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;   END OF DATA
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



;================================================================
; code to redirect the flow of control from the segment:offset for
; the mouse interrupt (33h) as indicated in the IVT (the IVT entry
; has been set to point to here) to the Insignia mouse driver code.
;================================================================
ifdef DBCS
;; DBCS works needs this message just before the int33 vector	to work
screte_msg  label   byte
	db	"*** This is Copyright 1983 Microsoft ***"
endif ; DBCS
int33h_vector:

        jmp     short   skip

; High level language entry point.

lvector db      0EAh    ; far jump opcode
loffset dw      ?       ; destination offset
lseg    dw      ?       ; destination segment

skip:
db      0EAh    ; far jump opcode
moff    dw      ?       ; will be filled in by the driver code from the IVT
mseg    dw      ?       ; as before

DOCLI:
        FCLI
        ret

DOSTI:
        FSTI
        ret

DOIRET:
        FIRET


;================================================================
; Functions moved out of ROM - real ROMS mapped in
;================================================================

unexp_int:
        bop     UNEXP_BOP
        jmp     DOIRET

mouse_io:
	;
	; INT 33h entry point
	;

        jmp     mio_hack
        nop
mouse_io_lang:                  ; entry point for HLL
        pushf                   ; check ASAP if redundant show/hide cursor
        push    di              ; save di,
        mov     di, [di+14]     ; get first parameter (mouse function),
                                ; then duplicate mio_hack below.
                                ; this has to be done to preserve
                                ; compatibility between both ways to
                                ; call the mouse.
        jz      lbop            ; F0
        cmp     di,2
        jg      lbop            ; >F2
        je      miol_2
miol_1:
	mov	conditional_off, 0  ; disable conditonal off
        cmp     [internalCF],0  ; is the flag already zero?
        je      miol_12_quit    ; if so, do nothing
        inc     [internalCF]    ; increment it
        jz      lbop
miol_12_quit:
        pop     di
        popf
        jmp     DOIRET

miol_2:
        dec     [internalCF]      ; decrement the pointer internal flag
        cmp     [internalCF], 0ffh; currently displayed?
        jne     miol_12_quit
lbop:
        pop     ax
        popf
        bop     IO_LANG_BOP
        retf    8

mio_hack:			; int 33h handler
        pushf                   ; save up the flags
        cmp     ax,1		; mouse show cursor.
        je      mio_1		
        cmp     ax,2		; mouse hide cursor.
        je      mio_2
        cmp     ax,3		; get button status and mouse position.
        je      mio_3
        cmp     ax,9		; set graphics cursor
        je	mio_9
        cmp     ax,10		; set text cursor - not supported
        je	mio_quit	; return straight back to app.

        jmp short hack1bop      ; none of the above, so goto 32 bit land

mio_1:
	mov	conditional_off, 0  ; disable conditional off
        cmp     [internalCF],0  ; is the flag already zero?
        je      mio_quit        ; if so, do nothing
        inc     [internalCF]    ; increment it
        jz      hack1bop	; just turned zero, so turn pointer on
                                 ; via the 32 bit code.
mio_quit:
        popf
        jmp     DOIRET

mio_2:
        dec     [internalCF]      ; decrement the pointer internal flag
        cmp     [internalCF], 0ffh; currently displayed?
        jne      mio_quit	  ; Already turned off, so quit

hack1bop:
        popf
        bop     IO_INTR_BOP	; BOP to the 32 bit part of the handler
        jmp     DOIRET		; return back after the BOP to caller
mio_9:
	call	int33function9	; change the shape of the graphics pointer
        popf			; restore the flag state
        jmp     DOIRET		; back to the caller
mio_3:
	mov	bx,[function3data]	; return button status
	mov	cx,[function3data+2]	; return x coordinate
	mov	dx,[function3data+4]	; return x coordinate
        popf				; return back to the application
        jmp     DOIRET			; via an iret.


IFDEF MOUSE_VIDEO_BIOS

mouse_video_io:

        pushf
        or      ah,ah
        jne     mvio1
        jmp     do_bop
mvio1:
        cmp     ax,6f05h
        jne     mvio2
        jmp     do_bop
mvio2:
        cmp     ah,4
        jne     mvio3
        jmp     do_bop
mvio3:

;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

        ; Microsoft EGA.LIB function support
        ; input: AH = the function required

        cmp     ah,0f0h         ; is function F0 or greater?
        jge     mvio4           ; YES, so check to see if less than or == F7
        jmp     go_rom          ; NO, so do rom stuff
mvio4:
        cmp     ah,0f7h         ; is it greater than F7
        jg      mvio5           ; YES, so test for == FA
        jmp     ega_lib         ; NO, but in range F0 to F7, so do EGALIB emm
mvio5:
        cmp     ah,0fah
        jne     mvio6
        jmp     egaFA
mvio6:
        jmp     go_rom

        ; to get here, must want to do mouse video functions 0f0h to 0f7h or
        ; function 0fah.

        jmp     ega_lib

        ; data area for EGA.LIB function support
        ; Notice that the sequencer register buffer only has space
        ; for four entrys even though it actually has five addressable
        ; registers. The Sequencer RESET status is not stored, so the buffer
        ; is arranged thus:
        ;                  buffer offset   0   1   2   3
        ;                  register index  1   2   3   4
        ;

        even

        ega_current_crtc        db      25 dup(?) ; driver's copy of CRTC regs
        ega_current_seq         db      4  dup(?) ; driver's copy of Seq regs
        ega_current_graph       db      9  dup(?) ; driver's copy of GC regs
        ega_current_attr        db      20 dup(?) ; driver's copy of AC regs
        ega_current_misc        db      ?         ; driver's copy of misc reg
        dirty_crtc              db      25 dup(?)
        dirty_seq               db      4  dup(?)
        dirty_graph             db      9  dup(?)
        dirty_attr              db      20 dup(?)
        ega_default_crtc        db      25 dup(?) ; default EGA register values
        ega_default_seq         db      4  dup(?) ; as set by the application
        ega_default_graph       db      9  dup(?) ; through a call to F7
        ega_default_attr        db      20 dup(?)
        ega_default_misc        db      ?

        relnum                  label   word

        release_major           db      MAJOR_RELEASE_NUMBER
        release_minor           db      MINOR_RELEASE_NUMBER

        even

        egalibjmp       label   word    ; crafty jump table to replace a base
                                        ; switch
                                dw      egaF0   ; 0F0h - read one EGA register
                                dw      egaF1   ; 0F1h - write one EGA register
                                dw      egaF2   ; 0F2h - read register range
                                dw      egaF3   ; 0F3h - write register range
                                dw      egaF4   ; 0F4h - read register set
                                dw      egaF5   ; 0F5h - write register set
                                dw      egaF6   ; 0F6h - revert to default regs
                                dw      egaF7   ; 0F7h - define deflt reg table
                                dw      noint   ; 0F8h is not a valid function
                                dw      noint   ; 0F9h is not a valid function
                                dw      egaFA   ; 0FAh - interrogate driver
ega_lib:

        xor     al,al
        sub     ax,0f0h                 ; create a jump table index
        shl     ax,1                    ; remember that a word pointer is reqd
        mov     si,ax
        jmp     [egalibjmp+si]          ; get the relavent jump address

egaF0:  ;--- Read an EGA register ----------------------------------------------

        pusha
        and     bx,0ffh                 ; just want the lower byte (BL)
F00:
        cmp     dx,0
        jne     F08
        mov     bl,byte ptr [ega_current_crtc+bx]
        popa
        jmp     noint
F08:
        cmp     dx,8
        jne     F010
        dec     bx                      ; note that RESET is not stored
        mov     bl,byte ptr [ega_current_seq+bx]
        popa
        jmp     noint
F010:
        cmp     dx,010h
        jne     F018
        mov     bl,byte ptr [ega_current_graph+bx]
        popa
        jmp     noint
F018:
        cmp     dx,018h
        jne     F020
        mov     bl,byte ptr [ega_current_attr+bx]
        popa
        jmp     noint
F020:
        cmp     dx,020h
        jne     F028
        mov     bl,byte ptr [ega_current_misc]

F028:   ; do nothing for this case
F0quit:
        popa
        jmp     noint

egaF1:  ;--- Write an EGA register --------------------------------------------

F10:
        pusha
        cmp     dx,0
        jne     F18
        mov     dx,03d4h                ; write to the CRTC index register
        mov     ax,bx                   ; values to write to ports 3d4/3d5
        out     dx,ax                   ; do the write
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_crtc+di],bh
        mov     byte ptr [dirty_crtc+di],1
        popa
        jmp     noint
F18:
        cmp     dx,8
        jne     F110
        mov     dx,03c4h                ; write to the Sequencer index register
        mov     ax,bx                   ; values to write to ports 3c4/3c5
        out     dx,ax                   ; do the write
        cmp     bl,0                    ; Cannot index reset because it its
        jle     F18bra1                 ; not stored. range = 1->4
        and     bx,0ffh                 ; just want BL
        dec     bx                      ; actually, one less than that
        mov     byte ptr [ega_current_seq+bx],ah
        mov     byte ptr [dirty_seq+bx],1
F18bra1:
        popa
        jmp     noint
F110:
        cmp     dx,010h
        jne     F118
        mov     dx,03ceh                ; write to the Graphics controller
        mov     ax,bx                   ; values to write to ports 3ce/3cf
        out     dx,ax                   ; do the write
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_graph+di],bh
        mov     byte ptr [dirty_graph+di],1
        popa
        jmp     noint
F118:
        cmp     dx,018h
        jne     F120
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        mov     ax,bx                   ; need to write BX to the ports
        mov     dx,03c0h                ; Attribute Controller index register
        out     dx,ax                   ; do the write
        inc     dx
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; enable the palette
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_graph+di],bh
        mov     byte ptr [dirty_graph+di],1
        popa
        jmp     noint
F120:
        cmp     dx,020h
        jne     F128
        mov     dx,03c2h                ; EGA miscellaneous register
        mov     al,bl
        out     dx,al                   ; write to the register
        mov     [ega_current_misc],bl
        popa
        jmp     noint
F128:
        cmp     dx,028h
        jne     F128
        mov     dx,03dah                ; EGA feature register
        mov     al,bl
        out     dx,al
F1quit:
        popa
        jmp     noint

egaF2:  ;--- Read a register range ---------------------------------------------

        pusha
        cmp     dx,0
        jne     F28
F20:
        lea     si,ega_current_crtc     ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F28:
        cmp     dx,8
        jne     F210
        lea     si,ega_current_seq      ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        dec     cx                      ; RESET is not stored, so index-1
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F210:
        cmp     dx,010h
        jne     F218
        lea     si,ega_current_graph    ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F218:
        cmp     dx,018h
        jne     F2quit
        lea     si,ega_current_attr     ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy the application's register block
F2quit:
        popa
        jmp     noint

egaF3:  ;--- Write a register range to the EGA adapter ------------------------

        pusha
        push    ds
        push    es
F31:
        cmp     dx,0
        jne     F38
        lea     di,ega_current_crtc     ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_crtc           ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03d4h                ; CRTC index register
        mov     ah,ch                   ; CRTC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F31cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_crtc array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F31cp
        jmp     F3quit
F38:
        cmp     dx,8
        jne     F310
        lea     di,ega_current_seq      ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        dec     di                      ; RESET is not stored, so index-1
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_seq            ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        inc     bx
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03c4h                ; Sequencer index register
        mov     ah,ch                   ; Sequencer register to start at
        inc     ah
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F38cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_seq array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F38cp
        assume  ds:SpcMseSeg
        jmp     F3quit
F310:
        cmp     dx,010h
        jne     F318
        lea     di,ega_current_graph    ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_graph          ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03ceh                ; Graphics Controller index register
        mov     ah,ch                   ; GC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F310cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_graph array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F310cp
        assume  ds:SpcMseSeg
        jmp     short F3quit
F318:
        cmp     dx,018h
        jne     F3quit
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        lea     di,ega_current_attr     ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_attr           ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03c0h                ; Attribute Controller index register
        mov     ah,ch                   ; AC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F318cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_attr array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F318cp
        assume  ds:SpcMseSeg
F3quit:
        pop     es
        pop     ds
        popa
        jmp     noint

egaF4:  ;--- Read EGA register set -------------------------------------------
        ;
        ; note that the incoming/outgoing data is structured thus:
        ;
        ;       from application -->    db      Port number
        ;                        -->    db      must be zero
        ;                        -->    db      pointer value
        ;       to application   <--    db      data read from register

        pusha
F4lp:
        mov     al,byte ptr es:[bx]     ; get the type of the next EGA register
        mov     dl,byte ptr es:[bx+2]   ; load up the offset required
        xor     dh,dh                   ; convert DL to a word (DX)
        add     bx,3                    ; point to where the data should
                                        ; be written for the application
F40:
        cmp     al,0
        jne     F48
        lea     di,ega_current_crtc     ; point to the internal CRTC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F48:
        cmp     al,8
        jne     F410
        lea     di,ega_current_seq      ; point to the internal Sequencer buffer
        add     di,dx                   ; index into the buffer
        dec     di                      ; RESET is not stored, so index off 1
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F410:
        cmp     al,010h
        jne     F418
        lea     di,ega_current_graph    ; point to the internal GC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F418:
        cmp     al,018h
        jne     F420
        lea     di,ega_current_attr     ; point to the interal AC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F420:
        cmp     al,020h
        jne     F4lp2
        mov     al,[ega_current_misc]   ; load contents of miscellaneous reg
        mov     byte ptr[di],al         ; store the register value

        ; the C code actually loads BL here but I don't know why!
F4lp2:
        inc     bx               ; point to the next 'record'
        loop    F4lp
        popa
        jmp     noint

egaF5:  ;--- Write EGA register set -------------------------------------------
        ;
        ; note that the incoming data is structured thus:
        ;
        ;       from application -->    db      Port number
        ;                        -->    db      must be zero
        ;                        -->    db      pointer value
        ;                        -->    db      data read from register

        pusha
F5lp:
        mov     al,byte ptr es:[bx]     ; get the type of the next EGA register
        mov     dl,byte ptr es:[bx+2]   ; load up the offset required
        xor     dh,dh                   ; turn from 8 bit to a word quantity
        mov     si,dx                   ; need this when accessing buffers
        add     bx,3                    ; point to where the data should
                                        ; be written for the application
        mov     ah,byte ptr es:[bx]     ; load data to send to the port
        inc     bx                      ; point to the next 'record'
F50:
        cmp     al,0
        jne     F58
        mov     al,dl                   ; also the port offset to access
        mov     dx,03d4h                ; index register for CRTC
        out     dx,ax                   ; write to the specified port
        mov     byte ptr [ega_current_crtc+si],ah
        mov     byte ptr [dirty_crtc+si],1
        jmp     short F5lp2
F58:
        cmp     al,8
        jne     F510
        mov     al,dl                   ; also the port offset to access
        mov     dx,03c4h                ; index register for Sequencer
        out     dx,ax                   ; write to the specified port
        dec     si                      ; RESET is not stored, so index off 1
        mov     byte ptr [ega_current_seq+si],ah
        mov     byte ptr [dirty_seq+si],1
        jmp     short F5lp2
F510:
        cmp     al,010h
        jne     F518
        mov     al,dl                   ; also the port offset to access
        mov     dx,03ceh                ; index register for GC
        out     dx,ax                   ; write to the specified port
        mov     byte ptr [ega_current_graph+si],ah
        mov     byte ptr [dirty_graph+si],1
        jmp     short F5lp2
F518:
        cmp     al,018h
        jne     F520
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        lea     di,ega_current_attr     ; write the application data here
        mov     al,dl                   ; also the port offset to access
        mov     dx,03c0h                ; index register for AC
        out     dx,ax                   ; write to the specified port
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; reenable the video
        mov     byte ptr [ega_current_attr+si],ah
        mov     byte ptr [dirty_attr+si],1
        jmp     short F5lp2
F520:
        cmp     al,020h
        jne     F528
        mov     byte ptr [ega_current_misc],ah
        mov     dx,03c2h                ; Miscellaneous output register
        xchg    ah,al
        out     dx,al                   ; write one byte
        jmp     short F5lp2
F528:
        xchg    ah,al
        mov     dx,03dah                ; EGA feature register
        out     dx,al
F5lp2:
        dec     cx
        cmp     cx,0
        jz      F5quit
        jmp     F5lp
F5quit:
        popa
        jmp     noint

egaF6:  ;--- Restore the EGA default register values --------------------------
        pusha
        push    es

        ; copy the default EGA register sets to the driver's internal cache

        mov     ax,ds
        mov     es,ax

        mov     cx,25
        lea     di,ega_current_crtc
        lea     si,ega_default_crtc
        rep     movsb
        mov     cx,4
        lea     di,ega_current_seq
        lea     si,ega_default_seq
        rep     movsb
        mov     cx,9
        lea     di,ega_current_graph
        lea     si,ega_default_graph
        rep     movsb
        mov     cx,20
        lea     di,ega_current_attr
        lea     si,ega_default_attr
        rep     movsb
        mov     al,[ega_default_misc]
        mov     [ega_current_misc],al

        ; Set up the Sequencer defaults

        mov     dx,03c4h                ; Sequencer index register
        mov     ax,0100h                ; Synchronous reset
        out     dx,ax                   ; do the work

        xor     bx,bx                   ; do the four non reset registers
        inc     al                      ; point to the next Sequencer register
F6lp1:
        cmp     [dirty_seq+bx],1        ; has the dirty bit been set?
        jne     F6ne1
        mov     ah,[ega_default_seq+bx] ; default value to send to the register
        out     dx,ax                   ; do the work
F6ne1:
        inc     bx                      ; point to the next buffer location
        inc     al                      ; point to the next Sequencer register
        cmp     bx,3                    ; copy elements 0->3 to ports
        jl      F6lp1
        mov     ax,0300h                ; Clear synchronous reset
        out     dx,ax                   ; do the work

        ; Set up the default Miscellaneous Output Register value.

        mov     dx,03c2h                ; Miscellaneous o/p register address
        mov     al,[ega_default_misc]   ; the default value
        out     dx,al                   ; write to the EGA/VGA

        ; Set up the Cathode Ray Tube Controller in the default fashion

        mov     dx,03d4h                ; Index to the CRTC
        xor     bx,bx                   ; clear an index register
F6lp2:
        cmp     [dirty_crtc+bx],1       ; has the dirty bit been set?
        jne     F6ne2
        mov     ax,bx                   ; index for the CRTC index register
        mov     ah,[ega_default_crtc+bx] ; default value for the selected reg.
        out     dx,ax
F6ne2:
        inc     bx                      ; point to the next location
        cmp     bx,25                   ; 25 registers to copy
        jl      F6lp2

        ; Set up the Attribute Controller default values
        ; Remember that this is a funny beast which uses a flip-flop
        ; off just one address/data port

        mov     dx,03dah                ; CRT status register
        in      al,dx                   ; set the AC flip-flop
        mov     dx,03c0h                ; Attibute controller address/data regs
        xor     bx,bx                   ; clear an index register
F6lp3:
        cmp     [dirty_attr+bx],1       ; has the dirty bit been set?
        jne     F6ne3
        mov     ax,bx                   ; index for the CRTC index register
        mov     ah,[ega_default_attr+bx] ; default value for the selected reg.
        out     dx,al                   ; index the register, then flip the flop
        xchg    al,ah                   ; get the default data for this register
        out     dx,al                   ; write the data out
F6ne3:
        inc     bx                      ; point to the next location
        cmp     bx,20                   ; 20 registers to copy

        ; Set the Graphics Controller default values

        mov     dx,03ceh                ; Index to the GC
        xor     bx,bx                   ; clear an index register
F6lp4:
        cmp     [dirty_graph+bx],1      ; has the dirty bit been set?
        jne     F6ne4
        mov     ax,bx                   ; index for the GC index register
        mov     ah,[ega_default_graph+bx] ; default value for the selected reg.
        out     dx,ax
F6ne4:
        inc     bx                      ; point to the next location
        cmp     bx,9                    ; 9 registers to copy
        jl      F6lp2

        ; Reenable the video

        mov     dx,03c0h                ; index register for AC
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; reenable the video

        ; Clean out the dirty register arrays

        xor     al,al                   ; put a nice zero in all the dirty
                                        ; registers
        mov     cx,25+4+9+20            ; do the CRTC, SEQ, GC and AC in
        mov     di,offset dirty_crtc    ; one go
        rep     stosb

        pop     es
        popa
        jmp     noint

egaF7:  ;---Define default register table -------------------------------------
        pusha
        push    es
        push    ds

        ; Load a new set of default registers for a particular EGA/VGA component


        mov     si,bx           ; SOURCE of the incoming data from the app
        mov     ax,es           ; save the SOURCE segment register
        mov     bx,ds           ; save the DESTINATION offset
        mov     ds,ax           ; DS is now the SOURCE segment in the app
        mov     es,bx           ; ES is now the DESTINATION segment in the dvr

        assume ds:nothing, es:SpcMseSeg

F70:    ; Set the default CRTC registers

        cmp     dx,0
        jne     F78
        mov     cx,25           ; copy 25 register entries
        mov     di,offset ega_default_crtc
        rep     movsb           ; do the copy
        jmp     short F7dirty

F78:    ; Set the default Sequencer registers

        cmp     dx,8
        jne     F710
        mov     cx,4            ; copy 4 register entries
        mov     di,offset ega_default_seq
        rep     movsb           ; do the copy
        jmp     short F7dirty

F710:   ; Set the default Graphic Controller registers

        cmp     dx,10
        jne     F718
        mov     cx,9            ; copy 9 register entries
        mov     di,offset ega_default_graph
        rep     movsb           ; do the copy
        jmp     short F7dirty

F718:   ; Set the default Attribute Controller registers

        cmp     dx,18
        jne     F720
        mov     cx,20           ; copy 20 register entries
        mov     di,offset ega_default_attr
        rep     movsb           ; do the copy
        jmp     short F7dirty

F720:   ; Set the default Miscellaneous Output register

        cmp     dx,20
        jne     F7quit
        mov     word ptr cs:[ega_default_misc],si

F7dirty:

        ; Set all the dirty register arrays

        mov     al,1                    ; put a nice one in all the dirty
                                        ; registers
        mov     cx,25+4+9+20            ; dirty all the registers in one go
        mov     di,offset dirty_crtc
        rep     stosb

F7quit:
        pop     ds              ; need to restore the segment registers
        pop     es

        assume  ds:SpcMseSeg, es:nothing

        popa

        jmp     noint

egaFA:  ;--- Interrogate driver -----------------------------------------------
        ; The real Microsoft mouse driver gets this wrong (release 7.03)

        push    ax
        mov     ax,cs
        mov     es,ax
        mov     bx,offset relnum        ; return the address of the mouse
                                        ; driver version number
        pop     ax
        jmp     noint

;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

ENDIF ; MOUSE_VIDEO_BIOS

do_bop:

        bop     VIDEO_IO_BOP    ;BOP BE
        nop
        nop
        jnc     noint
go_rom:
        popf
        db      0EAh    ; this is a far jump
old_vid_int     dd ?    ; far pointer to the old int 10h vector
        jmp     DOIRET
noint:
        popf
        jmp     DOIRET

mouse_int1:
        bop     INT1_BOP
        jmp     DOIRET

mouse_version:
ifdef DBCS
	dw	0626h
else ; !DBCS
        dw      04242h
endif ; !DBCS
        dw      0000h

mouse_copyright:
        db      "Windows NT MS-DOS subsystem Mouse Driver"

video_io:
        int     VIDEO
        bop     UNSIMULATE_BOP

mouse_int2:
        bop     INT2_BOP
        jmp     DOIRET

mouseINB:
        in      al,dx
        bop     0feh

mouseOUTB:
        out     dx,al
        bop     0feh

mouseOUTW:
        out     dx,ax
        bop     0feh


;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;16 BIT ENTRY POINT 16 BIT ENTRY POINT 16 BIT ENTRY POINT 16 BIT ENTRY POINT
;
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure that provides the driver interface to 32 bit land. This is
;   the entry point to the Intel 16 bit driver from the mouse interrupt
;   handler in the host mouse code.
;
;   This procedure determines the current video mode from the BIOS data
;   area, and depending on this branches to the correct display routines
;   for this mode.
;
;   N.B. This function MUST NOT modify CX and DX because the next level
;   of functions in the driver heirarchy requires the values passed in
;   them from 32 bit land.
;========================================================================

        assume  ds:SpcMseSeg

entry_point_from_32bit  proc    near
        make_stack              ; use the driver's own stack
        push    ds
        push    ax
        push    bx

        mov     ax,cs
        mov     ds,ax

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [drawpointerJMPT+bx]    ; jump to the correct routine

        pop     bx
        pop     ax
        pop     ds
        kill_stack              ; return to the previous stack

        bop     0FEh            ; return to the 32 bit side

entry_point_from_32bit  endp


;========================================================================
;   Procedure to set the cursor draw flag to DO DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 1.
;
;   In accordance with the Microsoft Programmer's Reference, the internal
;   cursor flag (internalCF) has a default value of -1. If intenalCF = 0
;   then the cursor is drawn. If the flag is already 0, then this function
;   does nothing.
;
;   Note: with calls to int 33h AX = 2, it is legal to
;   make internalCF less than -1.
;========================================================================

int33function1  proc    near

        make_stack              ; use the driver's own stack
        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI

        ; check to see if the pointer should be drawn

;        cmp     [internalCF],0  ; is the flag already zero?
;        jz      fn1quit         ; if so, do nothing

	; pointer is not ON, so increment the flag to try to turn it ON

;        inc     [internalCF]    ; increment the pointer internal flag
;        cmp     [internalCF],0  ; if 0, then the pointer can be drawn
;        jl      fn1quit         ; it is < 0, so don't draw the pointer.

	; The internal cursor flag hits zero for the first time, so
	; draw the pointer.

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [Int33function1JMPT+bx] ; do the correct function 1 handler
fn1quit:
;;	call	DOSTI
        pop     ds
        pop     bx
        pop     ax
        kill_stack              ; return to the previous stack
        bop     0FEh            ; back to jolly old 32 bit land

int33function1  endp



;========================================================================
;   Procedure to set the cursor draw flag to DONT DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 2
;
;   Note: with calls to int 33h AX = 2, it is legal to
;   make internalCF less than -1.
;========================================================================

int33function2  proc    near

        make_stack              ; use the driver's own stack
        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI

;        dec     [internalCF]    ; decrement the pointer internal flag

	; if the internal cursor flag is less than -1, then do not try
	; do remove the pointer from the screen because this has already
	; been done.

;        cmp     [internalCF],0ffh
;        jl      fn2quit		; do nothing if < -1

	; Internal flag hits -1, so remove the pointer from the screen.

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [Int33function2JMPT+bx] ; do the correct function 1 handler
fn2quit:
;;	call	DOSTI
        pop     ds
        pop     bx
        pop     ax
        kill_stack              ; return to the previous stack

        bop     0feh

int33function2  endp

;========================================================================
;   Procedure to return straight back to cloud 32. This is needed if an
;   unsupported video mode is found in the BIOS data area.
;========================================================================

not_supported   proc    near
        ret                     ; cant't BOP 0feh here or the stack will die
                                ; (out of balance with CS:IP stored from call)
not_supported   endp

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; END 16 BIT ENTRY END 16 BIT ENTRY END 16 BIT ENTRY END 16 BIT ENTRY
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display for
;   high resolution graphics modes.
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================


drawHiResPointer        proc    near

        ; save the video card's read/write context

;;	call	 DOCLI
        pusha
        push    ds
        mov     ax,cs           ; make sure that DS points to the
        mov     ds,ax           ; right segment


        call    saveVGAregisters
        call    check_for_mode_change


        mov     bx,cx           ; get X coordinate into a base register
        shl     bx,1            ; calculate a word index
        mov     ax,[ChooseImageLUT+bx] ; select the right image LUT
        mov     [PointerLUT],ax ; store the LUT address

	xor	ax,ax		; assume carry clear after the next call
        call    determineboundary
	jnc	detcont		; pointer in buonds if carry clear
	not	ax		; carry was set, so set AX non zero

detcont:

        ; Coordinates are now transformed from Cartesian to physical VRAM
        ; memory byte and bit offsets.

        mov     di,dx           ; store DX for later

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition

        cmp     [internalCF],0
        jnz     end_the_if              ; request to turn pointer on
        cmp     [background],STORED
        jne     end_the_if

        mov     si,cx
        mov     di,dx
        mov     dx,[VRAMlastbyteoff]
        mov     cx,[VRAMlastbitoff]
        call    restore_background

	cmp	ax,0		; should the pointer be drawn?
	jnz	end_the_if	; if the pointer has gone off the edge of
				; the screen, then quit

        mov     [VRAMlastbyteoff],di    ; save the current position
        mov     [VRAMlastbitoff],si
        mov     cx,si
        mov     dx,di
        call    save_background
        mov     cx,si
        mov     dx,di
        call    drawEGApointer

end_the_if:

        call    restoreVGAregisters

        pop     ds
        popa
;;	call	 DOSTI
        ret

drawHiResPointer        endp

;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display.for
;   medium resolution graphics modes.
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

drawMediumResPointer    proc    near

        pusha
;;	call	DOCLI

        shr     cx,1                    ; map from 640 virtual to 320 real

        ; CX,DX = x,y cartesian coordinates here.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition


        cmp     [internalCF],0
        jnz     cant_draw_ptr           ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_ptr
	mov	si, cx			; save new cursor position
	mov	di, dx
	mov	dx,[VRAMlastbyteoff]	;
        mov     cx,[VRAMlastbitoff]
	mov	bp,[LastYCounters]	; Y looping counter
        call    restorebkgrndmode4
	mov	cx, si			; restore new cursor position
	mov	dx, di
	call	detboundmode4		; calculate new byte offset
	jc	cant_draw_ptr		; don't draw new cursor of out of scrn

	mov	[VRAMlastbyteoff], dx	; byte offset
	mov	[VRAMlastbitoff], cx	; MSB = 0FFh if start with ODD line
					; LSB = bit offset
	mov	[LastYCounters], bp	; MSB: even counter, LSB for odd
        call    savebkgrndmode4
        call    drawmode4pointer

cant_draw_ptr:

;;	call	DOSTI
        popa
        ret

drawMediumResPointer    endp

;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display for
;   medium resolution, 256 colour graphics mode. (video bios mode 13h).
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

drawC256Pointer proc    near
        pusha
;;	call	DOCLI
        shr     cx,1                    ; map from 640 virtual to 320 real x

        ; CX,DX = x,y cartesian coordinates here.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition


        cmp     [internalCF],0
        jnz     cant_draw_256ptr        ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_256ptr

        mov     si,cx
        mov     di,dx
        mov     dx,[VRAMlastbyteoff]
	mov	cx,[LastXCounters]
	mov	bp,[LastYCounters]
        call    restorebkgrndmode13
	mov	cx, si
	mov	dx, di
	call	detboundmode13
	jc	cant_draw_256ptr

	mov	[VRAMlastbyteoff],dx	 ; save the current position
	mov	[LastXCounters],cx
	mov	[LastYCounters], bp
        call    savebkgrndmode13
        call    draw256pointer

cant_draw_256ptr:
;;	call	DOSTI
        popa
        ret
drawC256Pointer endp

;========================================================================
;   Procedure to draw a pointer on the fullscreen X86 text display for
;   BIOS modes 3 and 7.
;   This procedure saves the area about to be written over, XORs the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

IFDEF SIXTEENBIT

drawTextPointer proc    near
        pusha
	push	es

        ; CX,DX = x,y virtual pixel coordinates here.
	; 0 <= x < 640
	; 0 <= y < 200	for 25 line mode
	; 0 <= y < 344	for 43 line mode
	; 0 <= y < 400	for 50 line mode
	; The virtual character size is always 8x8 virtual pixels.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition

        cmp     [internalCF],0
        jnz     cant_draw_text_ptr     ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_text_ptr


        ; Calculate the current cell location as an offset
        ; into the text buffer segment starting at B800:0
        ; Note: The following kinky shifts allow for the fact that the text
        ;       video buffer consists of word elements of the form char:attr.
        ;       So, if a row = 80 characters wide on the screen, it is 160
        ;       bytes wide in VRAM.

        mov     bx,dx                   ; create a word table index
        shr     bx,3                    ; virtual char height = 8, but 160 bytes
                                        ; per text row, so save some shifts.
        shl     bx,1                    ; make a word table index
        mov     di,[mult80lut+bx]       ; multiply by 80 words per text row.
        shl     di,1
        shr     cx,3                    ; divide the x virtual pixel coordinate
                                        ; by 8 = virtual char width and mult
                                        ; by 2 to get word offset in text row.
        shl     cx,1
        add     di,cx                   ; full VRAM location now in DI

        ; Restore the text cell previously overwritten.

        mov     si,[VRAMlasttextcelloff]; address of last modified text cell
        mov     [VRAMlasttextcelloff],di; store the current cell location

        mov     ax,0b800h               ; the text buffer segment
        mov     es,ax                   ; ES now points there

        ; The text pointer uses the same magic as the graphics code
        ; to place a pointer on the screen.

        mov     bx,07700h               ; the magic cursor mask for pointer
        mov     cx,077ffh               ; the magic screen mask for pointer

        assume es:nothing

        mov     ax,[lasttextimage]      ; restore the background
        mov     es:[si],ax              ; from last time
        mov     ax,es:[di]              ; load the cell to be modifyed
        mov     [lasttextimage],ax      ; save this cell for next time
        and     ax,cx                   ; apply the screen mask
        xor     ax,bx                   ; apply the cursor mask
        mov     es:[di],ax              ; and write back

        assume es:SpcMseSeg

cant_draw_text_ptr:

	pop	es
        popa
	ret
drawTextPointer endp

ENDIF ;; SIXTEENBIT

ifdef DBCS
;; video io handler

DBCS_mouse_int10:
	inc	cs:video_io_enter_count
	pushf
	call	cs:old_vid_int
	dec	cs:video_io_enter_count
	iret


;; input: cx = mouse cursor X position in screen coordinate
;;	  dx = mouse cursor Y position in screen coordinate

DBCS_drawTextPointer	proc	near
	cmp	cs:video_io_enter_count, 0
	jne	video_busy_01

	pusha
	push	es
	push	ds
	mov	ax, cs
	mov	ds, ax
	mov	es, ax
	cmp	[background], NOTSTORED
	je	@F
	call	DBCS_erase_cursor
@@:
	call	DBCS_save_ac
	mov	[background], STORED
	call	DBCS_draw_new_cursor
	pop	ds
	pop	es
	popa

video_busy_01:
	ret

DBCS_drawTextPointer	endp

DBCS_erase_cursor   proc    near
	push	cx
	push	dx
	mov	bx, mouse_cursor_offset
	mov	ax, saved_ac_on_mouse_cursor
	mov	[bx], ax
	mov	dx, saved_ac_cursor_position
	mov	cx, saved_ac_count
	mov	bh, active_page
	mov	bp, saved_ac_offset
	mov	ax, 1320h
	int	10h
	pop	dx
	pop	cx
	ret
DBCS_erase_cursor   endp


DBCS_draw_new_cursor	proc	near
	push	cx
	push	dx
	mov	bx, mouse_cursor_offset
	mov	ax, saved_ac_on_mouse_cursor
	and	ax, 077FFh
	xor	ax, 07700h
	mov	[bx], ax
	mov	bp, saved_ac_offset
	mov	ax, 1320h
	mov	cx, saved_ac_count
	mov	dx, saved_ac_cursor_position
	mov	bh, active_page
	int	10h
	pop	dx
	pop	cx
	ret
DBCS_draw_new_cursor	endp


;; input: cx = mouse X virtual screen coordinate
;;	  dx = mouse Y virtual screen coordinate
;; this function assumes that DS and ES are set to CS
DBCS_save_ac	proc	near
	push	cx
	push	dx
	push	es
	SCREENtoCHARCELL			;screen coord to cell coord
	mov	saved_ac_cursor_position, dx	;the cell coord where the
						; mouse cursor stay
	mov	cl, dl				;
	inc	cl				;read ac pairs from the
						;beginning of the line
	inc	cl
	xor	ch, ch
	mov	dl, ch
	mov	bp, offset line_buffer
	mov	bh, active_page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	xor	bl, bl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov	ax, 1310h
	int	10h
	dec	cx
	mov	si, bp
	les	di, dbcs_vector
	mov	bp, di
	mov	dl, 3				;dl = char code type
						;3->SBCS, 4->DBCS 1st
						;5->DBCS 2nd
	cld

MBCS_parsing_loop:
	lodsb					;get next char code
	inc	si				;place ptr to next one
	cmp	dl, 4				;previous code a DBCS 1st?
	je	DBCS_ac 			;yes, count this one the 2nd

	mov	dl, 3				;reset to SBCS

DBCS_lead_byte_loop:
	mov	bx, es:[di]		;get next dbcs lead byte pair
	or	bx, bx			;done with the table?
	je	parse_next_ac		;yes, try next ac

	inc	di			;advance the dbcs table index
	inc	di
	cmp	al, bl			;is the char code a DBCS 1st?
	jb	DBCS_lead_byte_loop	;
	cmp	al, bh
	ja	DBCS_lead_byte_loop
DBCS_ac:
	inc	dl			;either DBCS 1st or DBCS 2nd

parse_next_ac:
	mov	di, bp			;reset DBCS vector
	loop	MBCS_parsing_loop
	dec	si			;
	dec	si
	mov	ax, [si]		;the ac we want to save
	mov	saved_ac_on_mouse_cursor, ax
	mov	mouse_cursor_offset, si ;and so is the offset in the buffer
	cmp	dl, 5			;if the ac on the mouse cursor position
					;is a DBCS 2nd, we backward the
					;pointer
	jne	@F			;backward one ac
	dec	si
	dec	si
	dec	saved_ac_cursor_position ;and adjust the cursor position
@@:
	mov	saved_ac_offset, si	;
	shr	dl, 1
	xor	dh, dh
	mov	saved_ac_count, dx
	pop	es
	pop	dx
	pop	cx
	ret

DBCS_save_ac	endp
endif ; DBCS
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Interrupt 33h support functions.
; These functions are called via a jump table from the 16 bit entry
; point code.
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure to set the cursor draw flag to DO DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 1
;========================================================================

int33function0  proc    near

        make_stack                      ; use the driver's own stack
        push    ds
        push    es
        pusha

        ; sort out the segments

        mov     ax,cs
        mov     ds,ax
        mov     ax,cs
        mov     es,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI
        ; set the internal pointer flag to its default value.

        mov     [internalCF],0ffh

        ; set the default hotspot location = (0,0)

        xor     ax,ax
        mov     [hotspot],ax
        mov     [hotspot+2],ax

        ; copy the default pointer to the working pointer buffer

        lea     si,default_cursor
        lea     di,current_cursor
        call    copy_pointer_to_current

        ; clear the pointer enabled flag, turn the pointer off by restoring
        ; the background.

        mov     [background],NOTSTORED  ; there is no stored background now

;;	call	DOSTI
        popa
        pop     es
        pop     ds
        kill_stack                      ; restore the previous stack
        bop     0FEh

int33function0  endp



;========================================================================
;   Procedure to accept a cursor bit image from the current application
;   at ES:DX. This is stored as the current pointer image for use by
;   the driver.
;========================================================================

assume es:nothing

int33function9  proc    near
	call	DOCLI
        make_stack                      ; use the driver's own stack
        push    ds
        push    es
        pusha


        mov     ax,cs                   ; point at the driver data segment
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI
        ; Read in the hotspot cartesian coordinate values for the
        ; new pointer image. If the hotspot values are out of range
        ; i.e. >127 | < -128, then reset to the boundary value
        ; Now using kinky non modRM short forms by clever use of AX

        mov     ax,127                  ; load accumulator with 127
        mov     bp,ax                   ; store this constant in a register
        cmp     ax,bx                   ; compare X value of hotspot with 127
        jg      test_low_x              ; if 127 > BX, BX is within upper limit
        xchg    ax,bx                   ; BX > 127, so set to 127
        jmp     short check_y_hotspot   ; now test the Y values

test_low_x:

        not     ax                      ; change accumulator from 127 to -128
        cmp     ax,bx                   ; compare X value of hotspot with -128
        jl      check_y_hotspot         ; if -128 < BX, BX is within lower lim.
        xchg    ax,bx                   ; BX < -128, so set it to -128

check_y_hotspot:

        mov     ax,bp                   ; reload AX with 127
        cmp     ax,cx                   ; compare Y value of hotspot with 127
        jg      test_low_y              ; if 127 > CX, Cx is within upper limit
        xchg    ax,cx                   ; CX > 127, so set CX to 127
        jmp     short done_hotspot_check; both hotspot coords tested, so save

test_low_y:

        not     ax                      ; change accumulator from 127 to -128
        cmp     ax,cx                   ; compare Y value of hotspot with -128
        jl      done_hotspot_check      ; if -128 < CX, CX is within lower lim.
        xchg    ax,cx                   ; CX < -128, so set it to -128

done_hotspot_check:

        mov     [hotspot],bx            ; save the hotspot x,y
        mov     [hotspot+2],cx          ; y component of the hotspot

        ; DESTINATION: the driver current pointer buffer
        ; Note: the SOURCE is already being pointed at by DX

        lea     di,current_cursor       ; this is the bit that must change
        mov     si,dx

        ; copy in the new application pointer

        mov     ax,es
        mov     ds,ax                   ; DS now points to where ES points
        mov     ax,cs
        mov     ax,es                   ; ES points to our data area now
        call    copy_pointer_to_current ; Copy the pointer image appropriately

        popa
        pop     es
        pop     ds
        kill_stack                      ; restore the previous stack
	call	DOSTI
        ret				; this code is called from within this
					; 16 bit driver, so don't BOP
int33function9  endp

;============================================================================
;   Procedure to display the pointer image in HIRES graphics modes
;============================================================================

HiResInt33Function1     proc    near

        pusha
        call    check_for_mode_change
        call    saveVGAregisters
        mov     cx,[current_position_x] ; get the last known cursor position
        mov     dx,[current_position_y] ; from the OS via the event loop
        call    determineboundary       ; convert to VRAM coordinates
	jc	end_function1		; if the pointer has gone off the edge
					; of the screen, then quit
        mov     [VRAMlastbyteoff],dx    ; save the restore background location
        mov     [VRAMlastbitoff],cx
        mov     si,cx
        mov     di,dx
        call    save_background
        mov     cx,si
        mov     dx,di
        call    drawEGApointer
        mov     [background],STORED
end_function1:
        call    restoreVGAregisters
        popa
        ret                             ; return to driver surface manager code

HiResInt33Function1     endp

;============================================================================
;   Procedure to display the pointer image in MEDIUMRES graphics modes
;   Note that this function does a conversion from virtual pixel coordinates
;   to real screen coordinates as required if the stored values in the
;   current_position memory locations are greater than 320 for X or 200
;   for Y.
;============================================================================

MediumResInt33Function1 proc    near

        pusha
        call    check_for_mode_change
        mov     cx,[current_position_x] ; get the last known cursor position
        mov     dx,[current_position_y] ; from the OS via the event loop
	shr	cx,1			; virtual coor -> screen coor
        call    detboundmode4           ; convert to VRAM coordinates
	jc	MediumResFunction1_exit

        mov     [VRAMlastbyteoff],dx    ; save the restore background location
        mov     [VRAMlastbitoff],cx
	mov	[LastYCounters], bp
        call    savebkgrndmode4
        call    drawmode4pointer
        mov     [background],STORED

MediumResFunction1_exit:
        popa
        ret

MediumResInt33Function1 endp

;============================================================================
;   Procedure to display the pointer image in VGA 256 colour graphics modes
;============================================================================

C256Int33Function1      proc    near
        pusha
        call    check_for_mode_change
        call    modifyentry255          ; make sure that DAC entry 255 is white
        mov     cx,[current_position_x] ; get the last known cursor position
	mov	dx,[current_position_y]
	shr	cx, 1			; virtual coor -> screen coord
        call    detboundmode13          ; convert to VRAM coordinates
	jc	C256Function1_exit

        mov     [VRAMlastbyteoff],dx    ; save the restore background location
	mov	[LastXCounters],cx	; X loop counter
	mov	[LastYCounters], bp	; Y loop counter
        call    savebkgrndmode13
        call    draw256pointer
        mov     [background],STORED

C256Function1_exit:
        popa
        ret                             ; return to driver surface manager code

C256Int33Function1      endp

;============================================================================
; Procedure to show the TEXT pointer
;============================================================================
IFDEF SIXTEENBIT

TextInt33Function1     proc    near

        pusha
        push    es

        mov     [background],STORED
        call    check_for_mode_change

        mov     cx,[current_position_x] ; get the last known cursor position
        mov     bx,[current_position_y] ; from the OS via the event loop

        shr     bx,3                    ; virtual char height = 8, but 160 bytes
                                        ; per text row.
        shl     bx,1                    ; make a word table index
        mov     di,[mult80lut+bx]       ; multiply by 80 words per text row.
        shl     di,1                    ; remember 160 bytes NOT 80 in a row
        shr     cx,3                    ; divide the x virtual pixel coordinate
                                        ; by 8 = virtual char width and mult
                                        ; by 2 to get word offset in text row.
        shl     cx,1
        add     di,cx                   ; full VRAM location now in DI

        mov     [VRAMlasttextcelloff],di; store the current cell location

        mov     ax,0b800h               ; the text buffer segment
        mov     es,ax                   ; DS now points there

        mov     bx,07700h               ; the magic cursor mask for pointer
        mov     cx,077ffh               ; the magic screen mask for pointer

        assume es:nothing

        mov     ax,es:[di]              ; load the cell to be modifyed
        mov     [lasttextimage],ax      ; save this cell for next time
        and     ax,cx                   ; apply the screen mask
        xor     ax,bx                   ; apply the cursor mask
        mov     es:[di],ax              ; and write back

        assume es:SpcMseSeg

        pop     es
        popa
        ret                             ; return to driver surface manager code

TextInt33Function1     endp

ENDIF ;; SIXTEENBIT

ifdef DBCS
DBCS_TextInt33Function1 proc	near
	cmp	cs:video_io_enter_count, 0
	jne	video_busy_02
	pusha
	push	es
	push	ds
	mov	ax, cs
	mov	es, ax
	mov	ds, ax
	mov	cx, [current_position_x]
	mov	dx, [current_position_y]
	call	DBCS_save_ac
	mov	[background], STORED
	call	DBCS_draw_new_cursor
	pop	ds
	pop	es
	popa
video_busy_02:
	ret

DBCS_TextInt33Function1 endp
endif ; DBCS
;============================================================================
;   Procedure to remove the pointer image in HIRES graphics modes
;============================================================================

HiResInt33Function2     proc    near

        push    cx
        push    dx

        call    saveVGAregisters
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     no_background_stored    ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
        mov     cx,[VRAMlastbitoff]
        call    restore_background      ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

no_background_stored:

        call    restoreVGAregisters

        pop     dx
        pop     cx
        ret

HiResInt33Function2     endp

;============================================================================
;   Procedure to remove the pointer image in MEDIUMRES graphics modes
;============================================================================

MediumResInt33Function2 proc    near
        push    cx
        push    dx
	push	bp
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     nobkgrndstored          ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
        cmp     dx,80*100               ; mustn't be greater than buffer size
        jl      vidoffok                ; it's OK, so do nothing
        mov     dx,80*10-1              ; modify DX to fit in the buffer
vidoffok:
	mov	cx,[VRAMlastbitoff]	; CL = bit offset
					; CH = odd/even flag
	and	cl,3			; cannot be greater than bit 3( 2bits/p)
	mov	bp, [LastYCounters]
        call    restorebkgrndmode4      ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

nobkgrndstored:
	pop	bp
        pop     dx
        pop     cx
        ret
MediumResInt33Function2 endp

;============================================================================
;   Procedure to remove the pointer image in MEDIUMRES graphics modes
;============================================================================

C256Int33Function2      proc    near
        push    cx
        push    dx
	push	bp
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     nobkgrndstored256       ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
	mov	cx,[LastXCounters]
	mov	bp,[LastYCounters]
        call    restorebkgrndmode13     ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag
nobkgrndstored256:

	pop	bp
        pop     dx
        pop     cx
        ret

C256Int33Function2      endp

;============================================================================
;   Procedure to remove the pointer image in TEXT modes
;============================================================================

IFDEF SIXTEENBIT

TextInt33Function2     proc    near

	push	ax
	push	si
	push	es

        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     no_text_background_stored    ; no, so don't restore it

        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

	; Restore the text cell previously overwritten.

        mov	si,[VRAMlasttextcelloff]; address of last modified text cell

	mov	ax,0b800h		; the text buffer segment
	mov	es,ax			; DS now points there

	assume es:nothing

	mov	ax,[lasttextimage]	; restore the background
	mov	es:[si],ax		; from last time

no_text_background_stored:

	assume	es:SpcMseSeg

        pop     es
        pop     si
        pop     ax
        ret

TextInt33Function2     endp

ENDIF ;; SIXTEENBIT

ifdef DBCS
DBCS_TextInt33Function2 proc	near
	cmp	cs:video_io_enter_count, 0
	jne	video_busy_03
	cmp	cs:[background], NOTSTORED
	je	DBCS_TextInt33Function2_exit
	pusha
	push	es
	push	ds
	mov	ax, cs
	mov	ds, ax
	mov	es, ax
	call	DBCS_erase_cursor
	mov	[background], NOTSTORED
	pop	ds
	pop	es
	popa
video_busy_03:
DBCS_TextInt33Function2_exit:
	ret
DBCS_TextInt33Function2 endp
endif ; DBCS
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; End of Interrupt 33h support functions.
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Mouse driver general support functions
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


;========================================================================
;  Procedure to determine if the application has changed video modes since
;  the last mouse interrupt. If it has, then the image that is saved in the
;  background restore buffer is invalid and should not be drawn.
;========================================================================

check_for_mode_change   proc    near

        push    ax

        call    getBIOSvideomode; peek at the BIOS data area for video mode
        cmp     al,[lastvidmode]; compare with the last mode value
                                ; from the preceding interrupt
        jnz     mode_change     ; a mode change has occurred
        pop     ax              ; no mode change, so quit
        ret
mode_change:
        mov     [background],NOTSTORED
        mov     byte ptr [lastvidmode],al       ; store the new mode
        pop     ax

        ret
check_for_mode_change   endp

;========================================================================
; Procedure to read the BIOS data area and get the current video mode
; Output:   AL = BIOS video mode
; Modifies: memory variable -> currentvidmode, puts the video found in
;           the BIOS data area in this memory location.
;========================================================================

getBIOSvideomode        proc    near

        push    es
        push    bx
ifdef DBCS
	mov	bx, dbcs_vector_seg
	or	bx, bx
	je	got_dbcs_state
	mov	es, bx
	mov	bx, dbcs_vector_off
	mov	bh, es:[bx]
got_dbcs_state:
endif ; DBCS
        mov     ax,40h          ; BIOS data area segment
        mov     es,ax
ifdef DBCS
	mov	al,es:[62h];	; get current page number
	mov	active_page, al
endif ; DBCS

        mov     al,es:[49h]     ; get the BIOS video mode data

        mov     bl,al           ; copy the video mode value
ifdef DBCS
	cmp	bh, 0
	je	got_mode_number
	mov	al, DBCS_GRAPHIC_MODE_NUMBER
	cmp	bl, 72h
	je	got_mode_number
	mov	al, DBCS_TEXT_MODE_NUMBER
got_mode_number:
	mov	bl, al
endif ; DBCS
        xor     bh,bh
        shl     bx,1            ; create a word table index
        mov     bx,[latchhomeLUT+bx] ; get the latch hiding place for this
                                ; video mode
        mov     [latchcache],bx ; save in memory for use in save and restore
                                ; vga registers.

        pop     bx
        pop     es              ; restore the 'normal' data segment
        ret

getBIOSvideomode        endp

;=========================================================================
; Function to modify the 256th palette entry for 256 colour mode. The
; driver requires white to be set in this DAC register triple.
;=========================================================================
modifyentry255  proc    near
        push    ax
        push    dx
        mov     dx,03c8h
        mov     al,0ffh
        out     dx,al
        inc     dx
        out     dx,al
        out     dx,al
        out     dx,al
        pop     dx
        pop     ax
        ret
modifyentry255  endp


;========================================================================
;   Procedure to copy the required pointer image to the snapshot
;   buffers. Each buffer holds a different instance of the mouse
;   pointer for each possible alignment of the pointer image in
;   a VRAM byte.
;
;   INPUT DS:SI = pointer to the source image
;
;========================================================================

assume  ds:nothing

copy_pointer_to_current proc    near

        push    ds
        push    es
        pusha


        ; Set up the destination for the copy

        mov     ax,cs                   ; point ES to this segment
        mov     es,ax
        lea     di,current_cursor       ; this is the bit that must change
        mov     bx,di                   ; save this address for a while
        mov     bp,si                   ; save the application source address

        ; Fill the AND buffer with 1s and then fill the XOR buffer with
        ; 0s for the byte aligned pointer condition. This is done so that
        ; the last byte in the 3byte scanline sequence is set to the correct
        ; value to prevent image loss from the screen.

        cld                             ; move low mem -> high mem
        mov     ax,24                   ; avoid doing a modRM load of immediate
        mov     cx,ax                   ; 24 words to fill.
        mov     dx,ax                   ; store this for a while
        xor     ax,ax                   ; clear AX (AX = 0)
        not     ax                      ; AX = 0ffffh -> fill AND mask with it.
        rep     stosw                   ; fill the screen mask (AND mask)
        mov     cx,dx                   ; do the next 24 words (XOR mask)
        not     ax                      ; AX = 0h -> fill XOR mask with it
        rep     stosw                   ; Fill the cursor mask

        ; Now fill the prepared 48 word buffer with the user defined
        ; AND and XOR masks
        ; Note that the image passed in from the application is little-endian.
        ; To write to the VGA planes byte by byte, the image has to be reversed
        ; to big-endian for the purpose of quick drawing since the VGA can only
        ; read and write one byte from/to its latches.

        mov     di,bx                   ; point to the top of the buffer again
        mov     si,bp                   ; point to the new pointer image

	mov	cx,32
norept1:
        lodsw                           ; read in the required image word
        xchg    al,ah                   ; convert little endian to big endian
        stosw                           ; write into local buffer
        inc     di                      ; remember local buffer in 3 bytes wide
	dec	cx
	jnz	norept1

        ; Now, the aligned mask must be rotated, then copied into each of
        ; the seven unaligned image buffers.

        mov     ax,cs
        mov     ds,ax                   ; return to the default data segment

        mov     bp,1000000000000000b    ; a mask for the MSBit

        lea     di,AlignData1           ; point to the buffer for 1 bit offset
        mov     si,bx                   ; source = byte aligned pointer image

	push	bx
	mov	bx,32*7
norept2:
        lodsw                           ; load the word from 3 byte sequence
        xchg    al,ah                   ; put into little-endian format
        mov     cl,byte ptr [si]        ; load the remaining byte
        shr     ax,1                    ; LSB now stored in CF
        rcr     cl,1                    ; CF into MSB, lsb into CF
        jnc     $+4                     ; CF=0 -> don't need to do anything
        or      ax,bp                   ; OR in the carried bit from CF
        xchg    al,ah                   ; return to bitstream format
        stosw                           ; write the rotated data
        mov     byte ptr[di],cl
        inc     si                      ; point to the next source scanline
        inc     di                      ; point to the next dest scanline

	dec	bx
	jnz	norept2
	pop	bx

        ; Just to do a little bit more work, the rotated buffers created
        ; above must be copied to the instances for byte 78 and byte 79
        ; of the scanline. These images are then cunningly clipped in the
        ; process to the edge of the screen!

        mov     si,bx                   ; BX points to the top of current buffer
                                        ; Note DI points to clip_cursor78 now

        ; may as well use the nice string functions now that I don't
        ; have to XCHG bytes. (how space and cycle efficient

        xor     al,al                   ; constant for putting in masks

        ; there are 8 instances for bits 0 to 7

	mov	bx,8
norept3:

        ; Do the AND mask modifications for byte 78

        not     al                      ; AL = 11111111b
        REPT    16                      ; 16 scanlines
        movsw                           ; copy contents of AND word
        stosb                           ; Nice clear AND mask = 11111111b
        inc     si                      ; point to the first image byte in
                                        ; the next scanline
        ENDM

        ; Do the XOR mask modifications for byte 78

        not     al                      ; AL = 00000000b
        REPT    16                      ; 16 scanlines
        movsw                           ; copy contents of XOR word
        stosb                           ; Nice clear XOR mask = 00000000b
        inc     si                      ; point to the first image byte in
                                        ; the next scanline
        ENDM

	dec	bx
	jnz	norept3

        ; prepare the BYTE 79 instances
        ; SI and DI should be in the right place

        xor     ax,ax                   ; constant for putting in masks
        mov     bx,2                    ; constant for addressing source

        ; there are 8 instances for bits 0 to 7

	mov	cx,8
norept4:

        ; Do the AND mask modifications for byte 79

        not     ax                      ; AX = 0ffffh
        REPT    16                      ; 16 scanlines
        movsb                           ; copy contents of AND byte
        stosw                           ; Nice clear AND mask (=0ffffh)
        add     si,bx                   ; point to the first image byte in
                                        ; the next scanline
        ENDM

        ; Do the XOR mask modifications for byte 79

        not     ax                      ; AX = 0h
        REPT    16                      ; 16 scanlines
        movsb                           ; copy contents of XOR byte
        stosw                           ; Nice clear XOR mask
        add     si,bx                   ; point to the first image byte in
                                        ; the next scanline
        ENDM

	dec	cx
	jz	norept4quit
	jmp	norept4
norept4quit:
	
        popa
        pop     es
        pop     ds

        ret
copy_pointer_to_current endp

;========================================================================
;   Procedure to determine the segment of the video buffer for
;   the current display mode.
;========================================================================

assume ds:SpcMseSeg

getvideobuffer  proc    near

        push    ax
        push    si

        ; determine the current video mode from the BIOS and save it.
        ; Use this value to determine the video buffer segment address.

        mov     ah,0fh                  ; use the bios to get the video mode
        int     10h
        cbw                             ; create a table index
        shl     ax,1                    ; word sized table entries
        mov     si,ax
        mov     ax,[videomodetable+si]  ; use video mode to index the table
        mov     [videobufferseg],ax


        pop     si
        pop     ax
        ret

getvideobuffer  endp

IFDEF DEBUGMOUSE

;=========================================================================
; Code to provide 32 bit side with a dump of the VGA registers on request.
;=========================================================================

VGAregs db      9+5+25 dup(?)           ; enough room for sequencer, GC and CTRC

dumpVGAregs     proc    near

        call    DOCLI
        pusha
        push    ds


        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg

        ; Save the Graphics Controller registers

        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register
        xor     ax,ax

        mov	cx,9            ; save 9 G.C. registers
norept5:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; Sequencer index register
	dec	cx
	jnz	norept5

        ; Save the Sequencer registers

        mov     dx,03c4h        ; Sequencer index register
        xor     ax,ax

        mov	cx,5            ; save 5 sequencer registers
norept6:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; Sequencer index register
	dec	cx
	jnz	norept6

        ; Save the CRTC registers

        mov     dx,03d4h        ; CRTC index register
        xor     ax,ax

        mov	cx,25              ; save 25 sequencer registers
norept7:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; CRTC index register
	dec	cx
	jnz	norept7

        pop     ds
        popa
        call    DOSTI
        bop     0feh                    ; return to 32 bit land

dumpVGAregs     endp

ENDIF   ; DEBUGMOUSE


;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; End of Mouse driver general support functions
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure to draw an EGA pointer image on the graphics screen at a
;   specified bit location.
;
;   Input:      CX = pointer offset in the current VRAM byte.
;               DX = offset in the video buffer to pointer
;   Output:     None
;   Modifies:   AX,BX,CX,DX,BP,SI,DI
;========================================================================

        assume  ds:SpcMseSeg
.286
even

drawEGApointer  proc    near

        push    es
        push    ds

        mov     ax,cs
        mov     ds,ax

        cld                 ; index from low memory to high for LODSB

        ; point to the video buffer

        mov     ax,0a000h
        mov     es,ax
        mov     bp,dx       ; save the byte offset in VRAM for the XOR code

        ; Select the Graphics Controller

        mov     dx,03ceh

        ;************ AND MASK OPERATION **************************

        ; use the bit position to select the relavent pointer image

        shl     cx,1        ; need a word offset into LUT
        mov     di,cx       ; need an index register
        mov     bx,[PointerLUT]
        mov     si,[bx+di]  ; Point to the screen (AND) mask
        mov     di,bp       ; point to the byte offset in VRAM
        mov     ax,0803h    ; Index the data rotate register and select AND
        out     dx,ax       ; do it
        mov     ax,80-2     ; Avoid modRM loading of CX
        mov     cx,ax       ; A constant handily kept in a register

                            ; The pointer contains 16 words of information
	push	bx
	mov	bx,16
norept8:

        lodsw               ; Load 2 bytes from the AND mask into AL and AH
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        xchg    ah,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        lodsb               ; Load a byte from the AND mask into AL
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        add     di,cx       ; point to the next byte in VRAM on the next scan
                            ; line to write to. CX contains 80-2

	dec	bx
	jnz	norept8
	pop	bx

        ;************ XOR MASK OPERATION **************************

        ; Note: SI points to current_cursor+48 now, automatically
        ; i.e. at the start of the XOR mask.

        mov     di,bp       ; point to the byte offset in VRAM
        mov     ax,1803h    ; Index the DATA ROTATE REGISTER and
                            ; Select the XOR function to XOR CPU data in
        out     dx,ax       ; Do the deed

	push	bx
	mov	bx,16
norept9:

        lodsw               ; Load 2 bytes from the AND mask into AL and AH
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        xchg    ah,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        lodsb               ; Load a byte from the XOR mask into AL
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        add     di,cx       ; point to the next byte in VRAM on the next scan
                            ; line to write to. CX contains 80-2
	dec	bx
	jnz	norept9
	pop	bx

        pop     ds
        pop     es
        ret

drawEGApointer  endp

;========================================================================
; Procedure to determine what the byte and bit offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine. A flag is set,
; also, to relay whether or not the cursor bitmap is byte aligned or not.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  : DX    = byte offset to top left hand pointer pixel
;        CX    = bit offset in the byte
;	 CF    = set if it is not possible to draw the pointer on the
;                screen because of the hotspot adjustment. (Usually a
;		 negative hotspot value will cause clipping and wrapping
;		 problems at the right and bottom screen boundaries.
;========================================================================

determineboundary       proc    near

        push    ax
        push    bx
	push	es


        ; do the adjustment in x,y for pointer hotspot
        ; Also test for top or left screen boundary problems
	; and zero the coordinate if it goes negative.

	
        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_x     ; if x goes negative, assume zero
        xor     cx,cx
dont_zero_x:
        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_y     ; if y goes negative, assume zero
        xor     dx,dx
dont_zero_y:

	; Now check the right and bottom bounds to prevent the pointer
	; image wrapping if the hotspot adjustment forces either of
	; the coordinates to exceed the screen bounds.
 	; First, for all video modes that this function handles, the
	; X bound is always x < 640 ... check this first.

	cmp	cx,640
	jl	didntexceedX
	stc			; Oh oh - failed, so set carry flag.
	jmp	short quitdet	; bye bye.

didntexceedX:

	; Now check out the y value by finding the maximum extent from
	; a lut based on the current BIOS video mode.

	mov	ax,40h		; B.D.A. segment
	mov	es,ax		; and ES points to it.
	mov	al,byte ptr es:[49h]
	sub	al,0fh		; table is normalized. mode f is in entry
				; zero.
	xor	ah,ah		; create a look up table index
	shl	ax,1		; for a table with word sized elements.
	xchg	bx,ax		; use a suitable register as index

	cmp	dx,[hiresylut+bx]	; get the extent and compare y coord.
	jl	didntexceedY
	stc			; Oh oh - failed, so set carry flag.
	jmp	short quitdet	; bye bye.

didntexceedY:

        ; determine the byte offset from the start of the video buffer
        ; for the modified coordinates. First calculate how many bytes
        ; there are for the number of scanlines -1 to where the pointer
        ; is.

        mov     ax,dx           ; copy Y position into AX
	shl     ax,1            ; create a word table index
	xchg    ax,bx           ; copy table index into a base register
	mov     dx,[mult80lut+bx]       ; do a fast LUT multiply by 80

        ; determine the byte position of the pixel in question

        mov     ax,cx           ; save the x-coordinate displacement
        and     ax,7            ; do a modulus 8 to find the pixel position
                                ; in the byte. The bit number is in DX.

        ; add the whole number of bytes in the current row to the number
        ; of complete-row bytes

        shr     cx,3            ; divide pixels by 8 to get bytes
        add     dx,cx           ; DX hold the complete byte offset.
        xchg    ax,cx           ; CX = bit offset in the byte.

	; the pointer has not exceeded the screen buonds, so clear
	; the carry flag to signify this.

	clc

	; Wind up the routine and return with the carry flag:
	; SET if cursor exceeded screen bounds.
	; CLEAR otherwise.
quitdet:

	pop	es
        pop     bx
        pop     ax
        ret

determineboundary       endp

;========================================================================
; Procedure to buffer up the data over which the cursor will next be
; drawn. This data will be used to replace the cursor at a later point
; when the cursor position has changed and for generating a cursor image
; To prevent having separate routines for aligned and unaligned pointer
; saves, this routine saves a pixel block 24 x 16 deep in all cases. The
; start offset is a byte location into VRAM in which the pointer TLHC lives.
;
; Input:        DX = VRAM byte
; Modifies:     AX,BX,DI,CX,DX,ES
;
;========================================================================

assume ds:SpcMseSeg

even

save_background proc    near

        push    ds
        push    es
        pusha

        mov     ax,cs           ; point DS briefly at the driver data
        mov     ds,ax
        mov     es,ax           ; point ES to the driver segment

        lea     di,behindcursor ; DESTINATION: a nice, safe place in the
                                ; driver segment
        mov     ax,0a000h       ; point DS at VRAM
        mov     ds,ax

        assume  ds:nothing

        mov     bp,dx           ; save DX=VRAM byte offset for later use
        mov     dx,03ceh        ; VGA GC index register
        mov     al,4            ; select the read map select reg
        out     dx,al           ; Index in the map select register
        inc     dx              ; DX holds port address to map select register
        xor     al,al           ; plane 0 will be selected first

        cld                     ; make sure to address forward in memory
        mov     ah,3            ; number of bytes to copy per pointer scanline
        xor     cx,cx           ; counter for the REP MOVSB
        mov     bx,80-3         ; another handy constant: move to next scanline
                                ; byte.

        REPT    4               ; read the 4 EGA planes individually

        mov     si,bp           ; SOURCE: somewhere in VRAM
        out     dx,al           ; do the plane selection
        inc     al              ; select the next plane to latch

        ; note that only one byte at a time may be read from the latches

                                ; do 16 scanlines for each plane
	push	dx
	mov	dx,16
@@:
        mov     cl,ah           ; CX now contains 3
        rep     movsb           ; copy 3 bytes from VRAM to data segment
        add     si,bx           ; move down to the first byte in next scanline
	dec	dx
	jnz	@B		; norept10
	pop	dx

        ENDM

        popa
        pop     es
        pop     ds

        ret

save_background endp

;========================================================================
;   Procedure to restore the area of the screen that was behind the cursor
;   before it had moved.
;
;   Note. Currently (2/12/92) this is the only routine that modifies the
;   VGA sequencer. Therefore, the code from save and restore vga registers
;   that maintain the sequencer registers has been moved to here for
;   centralisation purposes.
;
;   Input:      DX = VRAM byte
;   Output:     None
;   Modifies:   AX,BX,CX,DX,DI,SI
;========================================================================
assume  ds:SpcMseSeg

even

restore_background      proc    near
        push    ds
        push    es
        pusha

;;	call	 DOCLI		 ; turn off interrupts
        mov     ax,cs
        mov     ds,ax           ; point at the driver data segment
        mov     ax,0a000h       ; videobufferseg
        mov     es,ax           ; point ES at VRAM segment
        mov     bp,dx           ; save the pointer for later
        mov     si,offset behindcursor ; SOURCE: point at the stored planes

        ; set up the Graphic Controller for the restore.

        mov     dx,03ceh        ; VGA GC index register
        mov     ax,0003h        ; Select copy into latches function
        out     dx,ax           ; i.e. data rotate -> replace
        mov     ax,0ff08h       ; bitmask register reset
        out     dx,ax

        ; do the 4 plane restore.

        mov     cx,80-2         ; point to the first byte in image on next line
        cld                     ; write forward in memory
        mov     bx,0102h        ; BH = initial plane mask value
                                ; plane 0 is selected with a 1
                                ; BL = map mask register offset
        mov     dx,03c4h        ; index register for sequencer

        mov     al,bl           ; point to the map mask register in sequencer
        out     dx,al           ; index the register into 03c5h
        inc     dx              ; point to the data register
        in      al,dx           ; read the data register value in
        dec     dx              ; restore DX to 03c4h
        mov     [seqregs],al    ; save the map mask register value

        REPT    4               ; 4 planes to restore

        mov     di,bp           ; DESTINATION: pointer into VRAM
        mov     ax,bx           ; select the plane to mask and map mask register
        out     dx,ax           ; do the mask
        shl     bh,1            ; point to the mask for the next iteration

	push	dx
	mov	dx,16
@@:

        lodsw                   ; load the old background data (ONE WORD)
        xchg    al,es:[di]      ; latch the VRAM data and swap with the
        inc     di              ; point to next byte to replace
        xchg    ah,es:[di]      ; latch the VRAM data and swap with the
        inc     di              ; point to next byte to replace
        lodsb                   ; load the old background data (ONE BYTE)
        xchg    al,es:[di]      ; latch the VRAM data and swap with the
        add     di,cx           ; point to the first byte in image on next line

	dec	dx
	jnz	@B		; norept11
	pop	dx

        ENDM

        mov     ah,[seqregs]    ; the old map mask value
        mov     al,bl           ; need to restore the map mask register
        out     dx,ax           ; do the restore
;;	call	 DOSTI		 ; reenable interrupts.
        popa
        pop     es
        pop     ds
        ret
restore_background      endp


;==========================================================================
;   Procedure to save the register state of the VGA card on receiving a
;   mouse pointer update interrupt. This procedure also sets up the following
;   VGA registers to nice values for the driver.
;
;   mode register               <write mode 0, read mode 0>
;   data rotate register        <do not rotate, no logical ops>
;   enable set/reset register   <disable set/reset>
;
;==========================================================================

even
assume ds:SpcMseSeg

saveVGAregisters        proc    near

        push    dx
        push    di
        push    es

        ; Save the Graphics Controller registers that the
        ; Driver uses

        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register
        xor     al,al

	push	cx
        mov	cx,9            ; save 9 G.C. registers
norept12:
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [GCregs+bx],al  ; Save the register
        inc     bx              ; index to next array entry
        mov     al,bl
        dec     dx              ; G.C. index register
	dec	cx
	jnz	norept12
	pop	cx

        ; save the latches to location in a bit of video buffer
        ; off the screen.

        mov     ax,0a000h       ; point to the video buffer
        mov     es,ax

        assume  es:nothing

        mov     ax,0105h        ; select write mode 1 to squirt latches out
        out     dx,ax           ; do the selection
        mov     di,[latchcache] ; 1 byte over the last location
        mov     es:[di],al      ; write the latches out to the planes

        ; disable the enable set/reset register

        mov     ax,01h          ; select enable set/reset register and clear it
        out     dx,ax

        ; clear the data rotate register (no logical operations).

        inc     ax
        inc     ax              ; select data rotate register and clear it
        out     dx,ax           ; AX = 3 therefore points to the DRR

        ; set write mode 0 for the graphics display
        ; conveniently, this also sets read mode to 0 which is needed too!

        inc     ax
        inc     ax              ; select write mode 0
        out     dx,ax           ; AX = 5, i.e. the mode register

	; color don't care. don't care for all planes
	inc	ax		;register 7, color don't care
	inc	ax
	out	dx, ax
	; bit mask register. enable all planes
	;
	inc	ax		;register 8, bit mask
	not	ah
	out	dx, ax
        pop     es
        pop     di
        pop     dx
        ret

saveVGAregisters        endp

;==========================================================================
;   Procedure to restore the register state of the VGA card after dealing
;   with mouse pointer update interrupt.
;==========================================================================

restoreVGAregisters     proc    near

        assume  ds:SpcMseSeg

        push    es
        push    di
        push    bx

        ; restore the latches that where saved in the video planes

        mov     ax,0a000h       ; point to the video buffer
        mov     es,ax

        assume  es:nothing

        mov     di,[latchcache] ; the byte just off the end of the buffer
        mov     al,es:[di]      ; read in the latches

        ; Restore the Graphics Controller registers that the
        ; Driver uses

        xor     ax,ax           ; create an index
        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register

norept13:
        mov     ah,[GCregs+bx]  ; restore the register
        out     dx,ax           ; Select it
        inc     al              ; index for the next register
        inc     bx              ; index to next array entry
	cmp	al,9
	jne	norept13

        pop     bx
        pop     di
        pop     es
        ret

restoreVGAregisters     endp

;=======================================================================
;   Procedure to draw a BIOS Mode 4 graphics pointer to the display.
;   Input:    DX = byte offset
;	      CL = bit offset in the byte
;	      CH = 0FFh if ODD, 0 if EVEN
;	      BP = Y loop counter, ODD in LSB, EVEN in MSB
;=======================================================================
drawmode4pointer        proc    near

        pusha
        push    es
        cld

	xchg	dx, bp			;
	mov	di, bp			; bp = di = byte offset, dx = y counters
        mov     ax,0b800h               ; point a segment register to
        mov     es,ax                   ; the CGA video buffer.
	or	ch, ch			;
	je	drawonevenscanline	;
        jmp     drawonoddscanline       ; otherwise do an ODD job

; ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN

drawonevenscanline:

        mov     si,[mode4SelectedPointer]
        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

	xor	cx, cx
	mov	cl, dh			; number of even scanlines to draw
	push	dx
evensl1:
	mov	dx,3
norept14:
        lodsb                           ; load 8 pixels from pointer bitmap
        xor     bh,bh                   ; want a zero extended 16 bit value
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah                   ; little-endianise
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept14

        add     si,3
        add     di,80-6
        loop    evensl1
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     si,3
        mov     di,bp
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer
        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl1:
	mov	dx,3
norept15:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept15

        add     si,3
        add     di,80-6
        loop    oddsl1
	pop	dx

; XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN


        mov     si,[mode4SelectedPointer]
        add     si,48

        mov     di,bp                   ; offset into video buffer

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        mov     cl,dh                   ; number of even scanlines to draw
	push	dx
evensl2:
	mov	dx,3
norept16:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept16

        add     si,3
        add     di,80-6
        loop    evensl2
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     si,48+3
        mov     di,bp
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer
        mov     cl,dl                   ; number of odd scanlines to draw
oddsl2:
	mov	dx,3
norept17:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept17

        add     si,3
        add     di,80-6
        loop    oddsl2
        pop     es
        popa
        ret


; ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD
;
;       This part of the code draws the pointer on an odd numbered scanline
;       of the video display. Since the video buffer is split, 0000 to 1fff
;       containing even scanlines and 2000 to 3fff containing odd, the data
;       must be manipulated in a subtly different fashion than that of the
;       even display scanline code.
;       The even scanline code display arrangement falls through naturally,
;       with an even scanline drawing thus:
;                                               buffer 0: scanline 0
;                                               buffer 1: scanline 0
;                                               buffer 0: scanline 1
;                                               buffer 1: scanline 1
;                                               buffer 0: scanline 2
;                                               buffer 1: scanline 2 etc.
;       whereas in the odd case:
;                                               buffer 1: scanline 0
;                                               buffer 0: scanline 0
;                                               buffer 1: scanline 1
;                                               buffer 0: scanline 1
;                                               buffer 1: scanline 2
;                                               buffer 0: scanline 2 etc.
;       and this requires that the odd image scanlines must be placed
;       one scanline lower in the even buffer than the even image scanlines
;       do in the odd buffer

drawonoddscanline:


        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer

        xor     cx,cx
        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl3:
	mov	dx,3
norept18:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept18

        add     si,3
        add     di,80-6
        loop    oddsl3
	pop	dx


        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        and     dh,dh
        jz      dontdothis1             ; can't do the loop 0 times

        mov     si,[mode4SelectedPointer]
        add     si,3
        mov     di,bp
        add     di,6                    ; This is required to align the
                                        ; even and odd scanlines together
        mov     cl,dh                   ; number of even scanlines to draw
	push	dx
evensl3:
        add     di,80-6                 ; remember even BELOW odd
	mov	dx,3
norept19:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept19
        add     si,3
        loop    evensl3
	pop	dx

dontdothis1:

; XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD


        mov     si,[mode4SelectedPointer]
        add     si,48
        mov     di,bp                   ; offset into video buffer
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl4:
	mov	dx,3
norept20:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept20
        add     si,3
        add     di,80-6
        loop    oddsl4
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        and     dh,dh                   ; can't do a loop 0 times
        jz      dontdothis2

        mov     si,[mode4SelectedPointer]
        add     si,48+3
        mov     di,bp
        add     di,6

        mov     cl,dh                   ; number of even scanlines to draw
	
evensl4:
        add     di,80-6
	mov	dx,3
norept21:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept21

        add     si,3
        loop    evensl4

dontdothis2:

; XORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXOR

        pop     es
        popa
        ret
drawmode4pointer        endp

;========================================================================
; Procedure to determine what the byte and bit offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine.
; Y looping counter(ODD and EVEN) are also returned
; The CGA buffer is interleaved, and runs from B800:0000 to B800:1999 for
; odd scanlines and from B800:2000 for even scanlines.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  :
;	 carry set if either X or Y is out of screen
;	 DX	= byte offset to top left hand pointer pixel of the pointer
;	 CL	= bit offset in the byte
;	 CH	= 0FFh if ODD, 0 if EVEN
;	 BP	= Y loop counter(ODD in LSB and EVEN in MSB)
;========================================================================

detboundmode4   proc    near

	push	ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg


        ; do the adjustment in x,y for pointer hotspot
        ; modify the raw X,Y values for hotspot

        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_xmode4; if x goes negative, assume zero
        xor     cx,cx

dont_zero_xmode4:

        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_ymode4; if y goes negative, assume zero
        xor     dx,dx

dont_zero_ymode4:

	cmp	cx, 320 		;
	jae	detboundmode4_exit	; CY is cleared
	cmp	dx, 200
	jae	detboundmode4_exit	; CY is cleared
        ; determine the byte offset from the start of the video buffer
        ; for the modified coordinates. First calculate how many bytes
        ; there are for the number of scanlines -1 to where the pointer
        ; is. Also if the pointer starts on a odd scanline, set CF, else
        ; clear CF.

        mov     ax,dx           ; copy Y position into AX
        mov     bp,dx           ; copy Y position into BP for use later

        ; CGA video buffer is split in two. Therefore, screen scanline 0 maps
        ; to video buffer scanline 0 and screen scanline 1 maps to video
        ; buffer+2000h, scanline 0

        and     ax,0fffeh       ; do the mapping 0->0, 1->0, 2->1, 3->1 etc.
                                ; and create a word table index
	mov	bx, ax		; copy table index into a base register
				; 2bits/pixel -> 4 pixels/byte
				; sine x total is 320, we have 80bytes
				; so a shl bx, 1 will be wrong.
	mov     dx,[mult80lut+bx]       ; do a fast LUT multiply by 80

        ; determine the byte position of the pixel in question

        mov     ax,cx           ; save the x-coordinate displacement
        and     ax,3            ; do a modulus 4 to find the pixel position
                                ; in the byte. The byte number will be in DX.

        ; add the whole number of bytes in the current row to the number
        ; of complete-row bytes. Note that mode 4 is 2bits per pixel, so
        ; there are four pixels represented by one byte.

        mov     bx,cx           ; Save in a base reg. to create a table index
        shl     bx,1            ; Create a table index for word sized entries
        add     dx,[mode4clipCXadjustLUT+bx]; DX hold the complete byte offset.
	mov	cx, ax		; CX = bit offset in the byte.

	mov	ax, [mode4pointerLUT + bx]  ; select appropriate pointer
	mov	[mode4SelectedPointer], ax

        ; Odd or Even scanline? note BP contains y cartesian coordinate

	mov	bx, bp		; y coordinate
	shr	bp, 1		; shift right to determine if odd or even
				; CF if odd, or 0 if even.
	sbb	ch, ch		; CH = 0FFh if ODD, 0 if EVEN
	shl	bx, 1
	mov	bp, [mode4clipDXLUT + bx] ;the Y counters
	stc			; we are fine, set the CY so we will return
				; CY cleared.
detboundmode4_exit:
	cmc				; revese the CY
        pop     ds
        pop     bx
	pop	ax
        ret

detboundmode4   endp



;=============================================================================
;   Procedure to save the area of CGA video buffer into which the pointer will
;   be drawn. The memory buffer in which this data is stored is arranged odd
;   scanlines first, then even. So, the first 48 bytes are the odd scanline
;   data.
;
;   Input:    DX = byte offset
;	      CL = bit offset in the byte
;	      CH = 0FFh if ODD, 0 if EVEN
;	      BP = Y loop counter, ODD in LSB, EVEN in MSB
;
;=============================================================================

savebkgrndmode4 proc    near

        pusha
        push    es
        push    ds

        ; set up the segment registers as required

        mov     ax,ds
        mov     es,ax
        mov     ax,0b800h
        mov     ds,ax
        assume  ds:nothing, es:SpcMseSeg
        mov     si,dx                   ; start the save.
	or	ch, ch
	je	svbkeven		 ; check the returned carry flag

        ; the image's first scanline is odd

        mov     di,offset CGAbackgrnd   ; where the background will be saved
        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; don't want unwanted mess in MSB
        add     si,2000h                ; odd part of buffer starts at 2000h
svodd1:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the image scanline save
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     svodd1                  ; do more scanlines if necessary

        ; save some even scanlines if need be.

        mov     si,dx                   ; offset into CGA buffer
	add	si, 80
        mov     bx,bp                   ; set up the loop counter
        xchg    bl,bh                   ; get the even part of loop counter
        xor     bh,bh                   ; trash the top end trash
        and     bx,bx                   ; check for a zero loop
        jz      misseven                ; can't have a loop which execs 0 times
        mov     di,offset CGAbackgrnd+48; where the background will be saved
sveven1:
        mov     cx,3                    ; copy six bytes = 24 pixels
        rep     movsw                   ; do the scanline save
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     sveven1                 ; do more scanlines if necessary

misseven:       ; jump to here if there are no even scanlines to draw

        jmp     short endsavemode4

svbkeven: ; the image's first scanline is even

        mov     di,offset CGAbackgrnd+48; where the background will be saved

        mov     bx,bp                   ; get the loop counter
        xchg    bl,bh                   ; rearrage to get the even part
        xor     bh,bh                   ; clear out the trash
sveven2:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the copy
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     sveven2                 ; do more scanlines if necessary

        mov     si,dx                   ; offset into CGA buffer
        add     si,2000h                ; odd part of the video buffer
        mov     di,offset CGAbackgrnd   ; where to save the odd scanlines
        mov     bx,bp                   ; get the loop counter
        xor     bh,bh                   ; clear out the unwanted trash
svodd2:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the copy
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     svodd2                  ; do more scanlines if necessary

endsavemode4:
        assume  ds:SpcMseSeg, es:nothing

        pop     ds
        pop     es
        popa
        ret
savebkgrndmode4 endp

;=============================================================================
;   Procedure to restore the area of CGA video buffer into which the pointer
;   was drawn. The memory buffer in which this data is stored is arranged
;   odd scanlines first, then even. So, the first 48 bytes are the odd scanline
;   data.
;
;   Input:
;	 DX	= byte offset to top left hand pointer pixel of the pointer
;	 CL	= bit offset in the byte
;	 CH	= 0FFh if ODD, 0 if EVEN
;	 BP	= Y loop counter(ODD in LSB and EVEN in MSB)
;
;=============================================================================

restorebkgrndmode4      proc    near

        pusha
        push    es

        ; set up the segment registers as required

        mov     ax,0b800h
        mov     es,ax
        mov     di,dx                   ; restore background
	or	ch, ch
	je	rsbkeven		 ; check the returned carry flag

        ; the image's first scanline is odd. The CGA buffer is translated
        ; so that a scanline (row N) from the even part of the buffer appears
        ; on the screen at raster I. The scanline at position N from the
        ; odd part of the video buffer maps to screen position I+1. If the
        ; 1st. scanline is odd, then this is drawn at raster A and the
        ; following algorithm draws the 1st. even row at raster A+1 to
        ; compensate for the video buffer arrangement.

        mov     si,offset CGAbackgrnd   ; where the background is be saved
        add     di,2000h                ; do the odd buffer

        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; clear out the MSB trash
rsodd1:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next odd scanline
        dec     bx                      ; decrement the loop counter
        jnz     rsodd1                  ; restore more even scanlines if needed

        mov     bx,bp                   ; let the loop counter
        xchg    bl,bh                   ; get the even part
        xor     bh,bh                   ; clear out the MSB trash
        and     bx,bx                   ; test for zero even scanlines
        jz      misseven1rs             ; can't have a zero execute loop
        mov     di,dx                   ; offset into CGA buffer
        add     di,80                   ; get the odd/even scanlines instep
        mov     si,offset CGAbackgrnd+48; where the background is be saved
rseven1:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next even scanline
        dec     bx                      ; decrement the loop counter
        jnz     rseven1                 ; restore more even scanlines if needed

misseven1rs:    ; jump to here if there are no even scanlines to be restored.

        jmp     short endrestoremode4

rsbkeven: ; the image's first scanline is even

        mov     si,offset CGAbackgrnd+48; where the background will be saved

        mov     bx,bp                   ; get the loop counter
        xchg    bl,bh                   ; get the even part of the loop counter
        xor     bh,bh                   ; scrap the MSB trash
rseven2:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next even scanline
        dec     bx                      ; decrement the loop counter
        jnz     rseven2                 ; do more even scanlines if needed

        mov     di,dx                   ; offset into CGA buffer
        add     di,2000h                ; do the odd buffer
        mov     si,offset CGAbackgrnd   ; where to save the odd scanlines

        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; scrap the MSB trash
rsodd2:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next  odd scanline
        dec     bx                      ; decrement the loop counter
        jnz     rsodd2                  ; restore more odd scanlines if needed

endrestoremode4:
        assume  ds:SpcMseSeg, es:nothing

        pop     es
        popa
        ret
restorebkgrndmode4      endp

;============================================================================
;   Procedure to draw the pointer image into the video buffer for mode 13h
;   VGA graphics.
;
;   Input:
;	   DX = byte offset
;	   BP = Y loop counter
;	   CX = X loop counter
;
;============================================================================

draw256pointer  proc    near
        pusha
        push    es
        push    ds

        mov     ax,0a000h       ; point to the 256 colour mode video buffer
        mov     es,ax
        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg, es:nothing

        cld                     ; write forward through the buffer
	; DX = TLHC pixel offset in the video buffer.
        mov     di,dx           ; point DI at the video buffer location of fun
	mov	si, offset current_cursor   ; we only use this cursor shape
					    ; because every pixel is on byte
					    ; boundary. The X counter would
					    ; take care of X clipping
y_256:
	push	cx
	lodsw			    ;and mask
	mov	dx, [si + 48 - 2]   ;xor mask
	inc	si		    ;we don't need the third byte
	xchg	al, ah		    ; byte sequence
	xchg	dh, dl		    ;
x_256:
	shl	ax, 1		    ;AND mask bit
	sbb	bl, bl		    ; bl = 0FFf if CY, 0 if not CY
	and	bl, es:[di]	    ;and the target and save the result
	shl	dx, 1		    ;XOR mask bit
	sbb	bh, bh		    ;
	xor	bl, bh		    ;xor with the save result
	mov	es:[di], bl	    ;update the target
	inc	di		    ;next pixel
	loop	x_256		    ;until this scan line is done
	pop	cx		    ;recovery X loop counter
	add	di, 320 	    ;target address to next scan line
	sub	di, cx
	dec	bp		    ;Y counter
	jne	y_256

        pop     ds
        pop     es
        popa
        ret
draw256pointer  endp

;=============================================================================
;   Procedure to save the area of 256 colour mode video buffer into which the
;   pointer will be drawn. The memory buffer in which this data is stored is
;   arranged odd scanlines first, then even. So, the first 48 bytes are the odd
;   scanline data.
;
;   Input:
;	    DX = byte offset
;	    BP = Y loop counter
;	    CX = X loop counter
;
;=============================================================================

savebkgrndmode13        proc    near
        pusha
        push    es
        push    ds

        mov     di,offset bkgrnd256     ; point to the area in which backgound
                                        ; data will be saved
        mov     si,dx           ; SOURCE: the video buffer at x,y

        mov     ax,0a000h
        mov     ds,ax
        mov     ax,cs
        mov     es,ax
	mov	bx, cx			;x counter
	mov	dx, 320
	sub	dx, bx
        assume  ds:nothing, es:SpcMseSeg
	cld
save_256_loop:
	mov	cx, bx
	shr	cx, 1
	rep	movsw
	adc	cl, 0
	rep	movsb
	add	si, dx			; next scan line offset
	dec	bp			; until Y counter is done
	jne	save_256_loop

        pop     ds
        pop     es

        assume  es:nothing, ds:SpcMseSeg

        popa
        ret
savebkgrndmode13        endp

;=============================================================================
;   Procedure to replace an existing pointer image in the 256 colour video
;   buffer with the data that was there previous to the pointer draw operation.
;   The data is stored in an internal (to the driver) buffer.
;
;   Input:
;	 DX = byte offset
;	 BP = Y loop counter
;	 CX = X loop counter
;
;=============================================================================

restorebkgrndmode13     proc    near
        pusha
        push    es

        mov     di,dx           ; DESTINATION: in the VRAM
        mov     ax,0a000h       ; point a segment register at video buffer
        mov     es,ax

        assume  es:nothing
	mov	bx, cx
        mov     si,offset bkgrnd256     ; where the data is saved
	mov	dx, 320
	sub	dx, bx

        cld                     ; write forward in memory
restore_256_loop:
	mov	cx, bx
	shr	cx, 1
	rep	movsw
	adc	cl, 0
	rep	movsb
	add	di, dx
	dec	bp
	jne	restore_256_loop

        pop     es
        popa
        ret
restorebkgrndmode13     endp

;========================================================================
; Procedure to determine what the byte offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine. X and Y looping
; counters are also returned.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  :
;	carry set if either X or Y is out of screen
;	DX	= byte offset to top left hand pointer pixel of the pointer
;	CX	= X counter
;	BP	= Y counter
;========================================================================

detboundmode13  proc    near

        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg


        ; do the adjustment in x,y for pointer hotspot
        ; modify the raw X,Y values for hotspot

        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_xmode13; if x goes negative, assume zero
        xor     cx,cx

dont_zero_xmode13:

        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_ymode13; if y goes negative, assume zero
        xor     dx,dx

dont_zero_ymode13:
	cmp	cx, 320
	jae	detboundmode13_exit ; CY is cleared
	cmp	dx, 200 	    ;
	jae	detboundmode13_exit ; CY is cleared

        ; CX and DX are now validated for the following section: buffer
        ; offset determination. Note, unlike other video modes, mode 13
        ; provides a direct mapping of the video display to video buffer.
        ; in other words; 1 byte represents 1 pixel. From this, it is not
        ; necessary to provide byte alignment data.

        mov     bx,dx                   ; save in a base register
	shl	bx,1			; create a word table index
        mov     dx,[mult320LUT+bx]      ; do the multiply by 320
        ; add in the offset along the current raster.

        add     dx,cx                   ; cx contains the byte offset from
	mov	ax,[mode4clipDXLUT + bx]; get Y loop counter from table
	add	al, ah			; the table has ODD/EVEN counters
	cbw
	mov	bp, ax			; the final Y counter
					; column 0.
	mov	ax, 320 		; calculate X loop counter
	sub	ax, cx
	cmp	ax, 16			;
	jl	set_new_x_counter
	mov	ax, 16
set_new_x_counter:
	mov	cx, ax			; X counter
	stc				; everything is fine, set CY
					; so we will return CY cleared
detboundmode13_exit:
	cmc				; complement the CY
        pop     ds
        pop     bx
        pop     ax
        ret

detboundmode13  endp


          public SpcMseEnd
SpcMseEnd label  byte

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;   Installation Code From Here Downwards
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; segment:offset table for redirected mouse functions for real rom version.

ifdef DBCS
mio_table	dw	42 dup(?)
else ; !DBCS
mio_table       dw      38 dup(?)
endif ; !DBCS



        assume  cs:SpcMseSeg,ds:nothing,es:nothing

        public InstSpcMse
;
; InstSpcMse - Installs the softpc mouse driver code
;
; Inputs:  ds == Resident location of SpcMseSeg
; Outputs: None
;
InstSpcMse   proc    near

        ;;;;;;;;;;;;;;;;do ret to use old mouse driver;;; ret

        pusha

ifdef DBCS
	push	ds
	mov	ax, 6300h
	int	21h
	mov	ax, ds
	pop	ds
	jc	got_dbcs_vector
	mov	ds:dbcs_vector_off, si
	mov	ds:dbcs_vector_seg, ax

got_dbcs_vector:
endif ; DBCS
        ; save old int 10 vector
        xor     ax,ax
        mov     es,ax
        mov     ax,es:[40h]
        mov     si,offset old_vid_int
        mov     word ptr ds:[si],ax
        mov     ax,es:[42h]
        mov     word ptr ds:[si+2],ax
ifdef DBCS
	mov	es:[40], offset DBCS_mouse_int10
	mov	ax, cs
	mov	es:[42], ax
endif ; DBCS

        mov     bx,ds
        mov     si,offset sysinitgrp:mio_table
        push    ds
        push    cs
        pop     ds

        mov     word ptr ds:[si], offset mouse_io
        mov     word ptr ds:[si+2],bx

IFDEF MOUSE_VIDEO_BIOS

        mov     word ptr ds:[si+4],offset mouse_video_io
        mov     word ptr ds:[si+6],bx

ENDIF ; MOUSE_VIDEO_BIOS

        mov     word ptr ds:[si+8],offset mouse_int1
        mov     word ptr ds:[si+10],bx
        mov     word ptr ds:[si+12], offset mouse_version
        mov     word ptr ds:[si+14],bx
        mov     word ptr ds:[si+16],offset mouse_copyright
        mov     word ptr ds:[si+18],bx
        mov     word ptr ds:[si+20],offset video_io
        mov     word ptr ds:[si+22],bx
        mov     word ptr ds:[si+24],offset mouse_int2
        mov     word ptr ds:[si+26],bx
        mov     word ptr ds:[si+28],offset entry_point_from_32bit
        mov     word ptr ds:[si+30],bx
        mov     word ptr ds:[si+32],offset int33function0
        mov     word ptr ds:[si+34],bx
        mov     word ptr ds:[si+36],offset int33function1
        mov     word ptr ds:[si+38],bx
        mov     word ptr ds:[si+40],offset int33function2
        mov     word ptr ds:[si+42],bx
        mov     word ptr ds:[si+44],offset int33function9
        mov     word ptr ds:[si+46],bx
        mov     word ptr ds:[si+48],offset current_position_x
        mov     word ptr ds:[si+50],bx
        mov     word ptr ds:[si+52],offset current_position_y
        mov     word ptr ds:[si+54],bx
        mov     word ptr ds:[si+56],offset mouseINB
        mov     word ptr ds:[si+58],bx
        mov     word ptr ds:[si+60],offset mouseOUTB
        mov     word ptr ds:[si+62],bx
        mov     word ptr ds:[si+64],offset mouseOUTW
        mov     word ptr ds:[si+66],bx
        mov     word ptr ds:[si+68],offset VRAMlasttextcelloff
        mov     word ptr ds:[si+70],bx
        mov     word ptr ds:[si+72],offset internalCF
        mov     word ptr ds:[si+74],bx
        mov     word ptr ds:[si+76],offset function3data
        mov     word ptr ds:[si+78],bx
	mov	word ptr ds:[si+80],offset conditional_off
	mov	word ptr ds:[si+82],bx
ifdef DBCS
	mov	word ptr ds:[si+84], offset saved_ac_on_mouse_cursor
	mov	word ptr ds:[si+86],bx
	mov	word ptr ds:[si+88], offset background
	mov	word ptr ds:[si+90],bx
endif ; DBCS
        pop     ds
        mov     bx, offset sysinitgrp:mio_table
        bop     0C8h            ; Host mouse installer BOP

; get the freshly written int 33h vector from IVT
; write the vector segment:offset data to the jump patch

        xor     ax,ax
        mov     es,ax
        mov     ax,es:[33h*4]
        mov     bx,es:[(33h*4)+2]
        mov     si,offset moff
        mov     word ptr ds:[si],ax
        mov     word ptr ds:[si+2],bx
        add     ax,2                          ; HLL entry point
        mov     si,offset loffset
        mov     word ptr ds:[si],ax
        mov     word ptr ds:[si+2],bx

; write the new value to the IVT
        call    DOCLI
        mov     bx, offset int33h_vector
        mov     word ptr es:[33h*4], bx
        mov     bx, ds
        mov     word ptr es:[(33h*4)+2], bx
        call    DOSTI

        popa
        ret
InstSpcMse  endp

SpcMseSeg    ends
             end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\res.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 RES.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE: RES.ASM                                         *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
;----------------------------------------------- DOS5 91/10/08 -------
;<patch BIOS50-P02>
        extrn   mosw2:byte, DSK_BUF2:byte, ERR_STATUS:byte
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 92/06/26 -------
;<patch BIOS50-P20>
        extrn   start_sec_h:word
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 92/06/22 -------
;<patch BIOS50-P22>
        extrn   SNGDRV_FLG:byte, RETCODE:byte
        extrn   PRVDRV:byte, samedrv:byte
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 92/10/01 -------
;<patch BIOS50-P27>
        extrn   CRTDOTF:word, ATTRF:word, EXT_SAVAX:word
        extrn   BIOSF_3:byte, CSRSW:byte, LINMOD:byte
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 92/10/01 -------
;<patch BIOS50-P30>
        extrn   RTRY_CNT:byte, CURUA:byte, BIDTBL:byte
        extrn   PWINF:byte, S_R8:byte, F_SW:byte
        extrn   DSK_144:byte, mode3_fd:byte
        extrn   DSK_BUF:byte,S_SEC:word
        extrn   DSK_TYP:byte,LNG_SEC:word
        extrn   CURDRV:byte
        extrn   BIDTBL:byte,BIDTBL5:byte
        extrn   PREDNST:byte,PREDENS5:byte
        extrn   CURDA:byte,CURUA:byte
        extrn   N5FD:byte,N8FD:byte
        extrn   DRV_NUM:byte, thisdrv_3mode:byte
        extrn   DSK8_DBL:byte, DSK_AT:byte, DSK8_SNG:byte
;---------------------------------------------------------------------
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:BIOS_DATA
        PUBLIC  RES_CODE_START
        PUBLIC  RES_CODE_END
        PUBLIC  RES_END

        PUBLIC  RES_AREA

RES_CODE_START:

;----------------------------------------------- DOS5 91/10/08 -------
;<patch BIOS50-P02>
        extrn   MEDIA_RE_ERR:near, MEDIA_RE_071:near
        public  PATCH01
PATCH01:
; ds:di contains the boot sector.in theory, (ha ha) the bpb in this thing
; is correct.  we can, therefore, suck out all the relevant statistics on the
; media if we recognize the version number.

        cmp     [MOSW2],0ffh            ;if 3.5" MO ?
        jne     valid_boot_record       ; no

        cmp     byte ptr [bx],0e9h      ; is it a near jump?
        je      check_1_ok              ; yes
        cmp     byte ptr [bx],0ebh      ;   is it a short jump?
        jne     invalid_boot_record     ;   no, invalid boot record
        cmp     byte ptr [bx+2],090h    ;   yes, is the next one a nop?
        jne     invalid_boot_record     ;     no, invalid boot record

check_1_ok:                             ; yes, jump instruction ok.
                                        ; now check some fields in
                                        ;  the boot record bpb
        mov     bx,offset DSK_BUF2+0bh  ;EXT_BOOT_BPB ; point to the bpb
                                        ;  in the boot record

                                        ; get the mediadescriptor byte
        mov     al,byte ptr [bx+0ah]    ;bpb_mediadescriptor

        and     al,0f0h                 ; mask off low nibble
        cmp     al,0f0h                 ; is high nibble = 0fh?
        jne     invalid_boot_record     ;   no, invalid boot record

        cmp     [bx],512                ;bpb_bytespersector,512 ; M042
        jnz     invalid_boot_record     ; M042 invalidate non 512 byte sectors

check_2_ok:                             ; yes, mediadescriptor ok.
                                        ; now make sure that
                                        ;     the sectorspercluster
                                        ;       is a power of 2

                                        ; get the sectorspercluster

        mov     al,byte ptr [bx+2]      ;bpb_sectorspercluster

        or      al,al                   ; is it zero?
        jz      invalid_boot_record     ;   yes, invalid boot record

;       M032 begin

ck_power_of_two:
        shr     al,1                    ; shift until first bit emerges
        jnc     ck_power_of_two

        jnz     invalid_boot_record     ; if bits left, then proceed not ok

;       M032 end

        cmp     word ptr DSK_BUF2+510,0aa55h
        je      valid_boot_record


invalid_boot_record:
        mov     ERR_STATUS,08h          ; sector not found
        jmp     MEDIA_RE_ERR            ; jump to invalid boot record
                                        ; unformatted or illegal media.
valid_boot_record:
        mov     si,di
        jmp     MEDIA_RE_071
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 91/11/02 -------
;<patch BIOS50-P06>
        extrn   patch2_end:near
        public  patch2
patch2:
        mov     cx,2
        rep     movsw                   ;SET HIDDEN SECTORS
        jmp     patch2_end
;---------------------------------------------------------------------

;----------------------------------------------- DOS5A 92/04/17 ------
;<patch BIOS50-P16>
        public  patch2k_1

patch2k_1:
        cmp     si,256
        je      @f
        shr     dx,1
        rcr     cx,1
        shr     si,1
        jmp     patch2k_1
@@:
        ret
;---------------------------------------------------------------------


;----------------------------------------------- DOS5 92/06/26 -------
;<patch BIOS50-P20>
        public  PATCH04
        extrn   setdrive:near, REMCHECK:near

baddrive:
        pop     di
        pop     si
        pop     dx
        pop     ax
        mov     al,8
        stc
        ret

PATCH04:
        push    ax
        push    dx
        push    si
        push    di
        CALL    SETDRIVE
; ensure that we are trying to access valid sectors on the drive

        mov     ax,dx                   ; save dx to ax
        xor     si,si
        add     dx,cx
        adc     si,0
        cmp     word ptr [di+0eh],0     ;[di].BDS_BPB.BPB_TOTALSECTORS,0 ; > 32 bit sector ?
        je      sanity32

        cmp     si,0
        jne     baddrive
        cmp     dx,word ptr [di+0eh]    ;[di].BDS_BPB.BPB_TOTALSECTORS
        ja      baddrive
        jmp     short sanityok

sanity32:
        add     si,[start_sec_h]
        cmp     si,word ptr [di+1dh]    ;[di].BDS_BPB.BPB_BIGTOTALSECTORS+2
        jb      sanityok
        ja      baddrive
        cmp     dx,word ptr [di+1bh]    ;[di].BDS_BPB.BPB_BIGTOTALSECTORS
        ja      baddrive

sanityok:
        pop     di
        pop     si
        pop     dx
        pop     ax

        call    REMCHECK
        ret
;---------------------------------------------------------------------


;----------------------------------------------- DOS5 92/06/22 -------
;<patch BIOS50-P22>
        public  patch06a, patch06c

patch06a:
        cmp     SNGDRV_FLG,0            ;not logically extended?
        je      @f                      ; no
        cmp     samedrv,1               ;same drive as previously accessed?
@@:     ret



patch06c:
        mov     samedrv,1
        cmp     al,PRVDRV               ;CURRNT = PREVIOUS ?
        je      @f
        mov     samedrv,0
@@:     ret
;---------------------------------------------------------------------

;----------------------------------------------- DOS5 92/08/13 -------
;<patch BIOS50-P25>
        public  patch07a, patch07b
        extrn   PAT0080:near, ROM55:near

patch07a:
        pop     dx
        pop     cx
        stc
        ret

patch07b:
        jne     @f
        jmp     PAT0080
@@:     stc
        jmp     ROM55
;---------------------------------------------------------------------


;----------------------------------------------- DOS5A 92/10/01 ------
;<patch BIOS50-P27>

        public  patch09                 ;keyboard.asm

patch09:
        cmp     CRTDOTF,0               ;480 dot?
        jnz     @f                      ; no, continue
        add     sp,2                    ;throw away ret addr
        pop     dx                      ;restore dx
        ret                             ;return to caller of CHGLIN
@@:
        mov     dh,19                   ;endline value for normal mode
        mov     dl,24                   ;
        ret



        public  patch10

patch10:
        test    byte ptr [BIOSF_3],0c0H ;NPC or TA architecture bit on?
        jnz     @f
CHK_EXgraph:
        push    es
        push    ax
        xor     ax,ax
        mov     es,ax
        test    byte ptr es:[45ch],40h  ;EX graph architecture bit on?
        pop     ax
        pop     es
@@:
        ret



        public  CRTMD_TA_1AT, CRTMD_TA_2AT
        public  CRTMD_TA_400, CRTMD_TA_480
        public  CRTMD_TA_ATR, CRTMD_TA_DOT

        extrn   CRTMD_DEF:near, CHGLIN:near

;
; sub func 00h
;
CRTMD_TA_2AT:                           ;CHANGE 2BYTE ATTR
        test    byte ptr [BIOSF_3],80h  ;NPC architecture bit on?
        jz      @f                      ; no, TA M11 etc.
        mov     ah,2bh
        int     18h                     ;read status
        ret                             ;continue NPC operation
@@:
        add     sp,2                    ;throw away ret addr
        ret                             ;ret without operation
;
; sub func 01h
;
CRTMD_TA_1AT:
        test    byte ptr [BIOSF_3],80h  ;NPC architecture bit on?
        jz      @f                      ; no, TA M11 etc.
        mov     ah,2bh
        int     18h                     ;read status
        ret                             ;continue NPC operation
@@:
        add     sp,2                    ;throw away ret addr
        ret                             ;ret without operation
;
; sub func 10h
;
CRTMD_TA_480:
        test    byte ptr [BIOSF_3],40H  ;TA architecture bit on?
        jnz     @f                      ; yes
        call    CHK_EXgraph             ;EX graph architecture bit on?
        jnz     @f                      ; yes
        mov     ah,2bh
        int     18h                     ;read status
        ret                             ;continue NPC operation
@@:
        add     sp,2                    ;throw away ret addr
        mov     ah,31h
        int     18h                     ;read status
        xor     bh,30h
        test    bh,30h                  ;600*480?
        jnz     @f                      ; no, continue
        mov     word ptr CRTDOTF,0      ;yes,480 dot mode
        ret
@@:
        mov     [LINMOD],0              ;SET FLAG
        call    CHGLIN                  ;change num of line ->25
        mov     bh,31h                  ;600*480 dot 25 line
        or      al,0ch                  ;31KHz
CRTMD_TA_100:
        mov     ah,30h
        int     18h                     ;set mode
        call    CRTMD_DEF_TA
        mov     ah,31h
        int     18h                     ;read status
        xor     bh,30h
        test    bh,30h                  ;600*480?
        jnz     CRTMD_TA_090            ; no

        mov     word ptr CRTDOTF,0      ;480 dot mode
        jmp     short CRTMD_TA_RET
CRTMD_TA_090:
        mov     word ptr CRTDOTF,1      ;400 dot mode
        mov     [LINMOD],0              ;SET FLAG
        call    CHGLIN                  ;change num of line ->25
        jmp     short CRTMD_TA_RET
;
; sub func 11h
;
CRTMD_TA_400:
        test    byte ptr [BIOSF_3],40H  ;TA architecture bit on?
        jnz     @f                      ; yes
        call    CHK_EXgraph             ;EX graph architecture bit on?
        jnz     @f                      ; yes
        mov     ah,2bh
        int     18h                     ;read status
        ret                             ;continue NPC operation
@@:
        add     sp,2                    ;throw away ret addr
        mov     ah,31h
        int     18h                     ;read status
        test    al,04h                  ;24KHz?
        jnz     @f                      ; no
        test    bh,30                   ;600*200 lower?
        jnz     @f                      ; no
        mov     word ptr CRTDOTF,1      ;yes, system default (400 dot)
        jmp     short CRTMD_TA_RET
@@:
        mov     bh,01h                  ;600*400 dot 25 line
        and     al,not 04h              ;24KHz
        jmp     short CRTMD_TA_100
;
; sub func 8000h
;
CRTMD_TA_ATR:
        test    byte ptr [BIOSF_3],80h  ;NPC architecture bit on?
        jz      @f                      ; no, TA M11 etc.
        mov     ah,2bh
        int     18h                     ;read status
        ret                             ;continue NPC operation
@@:
        add     sp,2                    ;throw away ret addr
        ret                             ;ret without operation
;
; sub func 8010h
;
CRTMD_TA_DOT:
        test    byte ptr [BIOSF_3],40H  ;TA architecture bit on?
        jnz     @f                      ; yes
        call    CHK_EXgraph             ;EX graph architecture bit on?
        jnz     @f                      ; yes
        mov     ah,2bh
        int     18h                     ;read status
        ret                             ;continue NPC operation
@@:
        add     sp,2                    ;throw away ret addr
        mov     ah,31h
        int     18h                     ;read status
        xor     bh,30h
        test    bh,30h                  ;600*480?
        mov     ax,0
        jz      @f                      ; yes
        mov     ax,1
@@:
        mov     [EXT_SAVAX],ax

CRTMD_TA_RET:
        ret


CRTMD_DEF_TA    proc    near
        mov     ah,0ch                          ;start display
        int     18h
        cmp     [CSRSW], 1                      ;cursor switch = 1 (on) ?
        jne     @f                              ; no, need not start cursor.
        mov     ah,11h                          ;start cursor
        int     18h
@@:
        call    CRTMD_DEF
        ret
CRTMD_DEF_TA    endp

;--------------------------------------------------------------------

;----------------------------------------------- DOS5A 92/12/01 ------
;<patch BIOS50-P30>

        public  patch144_1

patch144_1:
        mov     al,byte ptr es:[5aeh]
        and     al,0fh
        mov     [mode3_fd],al
        mov     cx,4
        ret

        extrn   BDATA_SEG:word


;---------------
        extrn   GET_8FD05:near, GET_5FD_UPS:near
        extrn   DSK_ERR_EXIT:near, GET_SET_EXBPB60:near

        public  patch144_3

patch144_3:
        test    byte ptr [si],80h       ;1MB?
        jnz     @f                      ; yes
        test    byte ptr [si],20h       ;1.44MB?
        jnz     is144                   ; yes
        jmp     GET_5FD_UPS             ;640k
@@:
        jmp     GET_8FD05

is144:
        cmp     ah,0f0h
        jne     @f
        mov     si,offset DSK_144
        push    es
        push    di
        push    si
        mov     al,CURDRV
        call    SETDRIVE
        mov     es,cs:[BDATA_SEG]
        lea     di,[di+6]               ;[di].BDS_BPB
        jmp     GET_SET_EXBPB60         ;back and copy bpb to BDS
@@:
        mov     al,7                    ;unknown disk err
        pop     bx                      ;discart ret addr on stack
        jmp     DSK_ERR_EXIT


;---------------
        extrn   SKP_8FDSETX:near, patch144_41_ret:near
        extrn   CMN_PASSFD:near

        public  patch144_41, patch144_42

patch144_41:
        test    al,80h                  ;1MB ?
        jz      @f                      ; no
        jmp     patch144_41_ret
@@:
        test    al,20h                  ;1.44MB?
        jnz     @f                      ; yes
        jmp     SKP_8FDSETX             ;640k

@@:
        not     [DSK_TYP]               ;double sided
        mov     [LNG_SEC],512
        mov     [S_SEC],18
        mov     ch,2                    ;set density
        jmp     CMN_PASSFD


patch144_42:
        not     [DSK_TYP]
        cmp     ch,3                    ;bytes/sector=1024?
        je      @f                      ; yes,skip
        mov     [LNG_SEC],512
        mov     [S_SEC],15
@@:
        jmp     CMN_PASSFD


;---------------
        extrn   GOTMEDIATYPE:near,UNKNOWNMEDIATYPE:near

        public  patch144_5

patch144_5:
        je      @f                              ;media discriptor=0f0h
        jmp     UNKNOWNMEDIATYPE
@@:
        cmp     word ptr [di+15h],1             ;[DI].BDS_BPB.BPB_HEADS
        je      @f                              ;3.5" MO
        mov     al,7                            ;1.44MB
@@:
        jmp     GOTMEDIATYPE


        public  patch144_7

        extrn   GET_SET_EXBPB:near, patch144_7_ret:near

patch144_7:
        mov     bx,offset PREDNST
        cmp     CURDA,90h
        jne     @f
        jmp     patch144_7_ret

@@:
        mov     bx,offset PREDENS5
        mov     al,CURUA
        xlat
        mov     si,offset DSK8_DBL
        cmp     al,6
        je      @f
        mov     si,offset DSK_AT
        cmp     al,7
        je      @f
        mov     si,offset DSK8_SNG
@@:
        jmp     GET_SET_EXBPB


;---------------
        public  patch144_8

patch144_8:
        test    CURDA,10h                       ;fd?
        jz      PATCH144_8_EXIT                 ; no
        push    bx
        mov     bx,offset BIDTBL
        test    CURDA,80h                       ;1M I/F?
        jnz     @f
        mov     bx,offset BIDTBL5
@@:
        mov     al,CURUA
        xlat
        pop     bx
        ret

PATCH144_8_EXIT:
        mov     al,CURDA
        ret
;---------------------------------------------------------------------


;----------------------------------------------- DOS5A 92/12/28 ------
;<patch BIOS50-P31>

        public  patch144_9

patch144_9:
        push    es
        xor     ax,ax
        mov     es,ax
        call    patch144_1
        pop     es
        mov     al,DRV_NUM
        ret
;---------------------------------------------------------------------


;----------------------------------------------- DOS5A 93/01/18 ------
;<patch BIOS50-P32>

        public  patch_p32

patch_p32:
        push    ds
        push    ax
db      31h,0c0h                        ;xor    ax,ax
        mov     ds,ax
        pop     ax
        pushf
        cli
db      3eh,0ffh,1eh,60h,00h            ;call   far ptr ds:[18h*4]
        pop     ds
        ret
;---------------------------------------------------------------------


RES_AREA:
;       DB      1576 DUP(0)
        DB      1576 - (RES_AREA - RES_CODE_START) DUP(0)

RES_CODE_END:
RES_END:
Bios_Code       ends
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\reinit.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 REINIT.ASM
;
;       INIT => INIT + REINIT
;
;850505 REINIT_END LABEL CORRECT
;850519 ADDED "NOT_BSYS_ENT"
;850520 INT FF
;
;************************************************************************
;*                                                                      *
;*                                                                      *
;*              R E - I N I T I A L I Z E                               *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1987                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************
;************************************************
;*                                              *
;*      OTHER SEGMENT                           *
;*                                              *
;************************************************

BRANCH=0

INTVEC  SEGMENT AT 0000H

        ORG     08H*4
USR_TIMR_OFST   DW      ?               ;INTERVAL TIMER (USER ROUTINE)
USR_TIMR_SGMT   DW      ?

        ORG     1AH*4
PRNT_VEC_OFST   DW      ?               ;PRINTER-BIOS VECTOR
PRNT_VEC_SGMT   DW      ?
DISK_VEC_OFST   DW      ?               ;DISK-BIOS VECTER
DISK_VEC_SGMT   DW      ?
TIMR_VEC_OFST   DW      ?               ;TIMER-BIOS VECTOR
TIMR_VEC_SGMT   DW      ?

        ORG     1EH*4
WARMBOOT        DD      ?               ;WARM BOOT ( NORMAL MODE ONLY )

        ORG     500H
BIOS_FLAG       DB      ?               ;BIOS FLAGS

INTVEC  ENDS

NORM_ROM SEGMENT AT 0FD80H

        ORG     091EH
WBOOT_ROM       LABEL FAR

NORM_ROM ENDS

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends



Bios_Data       segment word public 'Bios_Data'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

;************************************************
;*                                              *
;*      OUR SEGMENT                             *
;*                                              *
;************************************************

        EXTRN   DSK_BUF:NEAR
;------------------------------------------------------------ 870825 - -------
        EXTRN   SYS_500:BYTE,SYS_501:BYTE       ;                       870825
;       EXTRN   FAT_INF:NEAR                    ;                       870825
        EXTRN   INT1E_OFST:WORD,INT1E_SGMT:WORD
;-----------------------------------------------------------------------------
        EXTRN   SEG_DOS:WORD,CONSOLE_TABLE:NEAR
        EXTRN   AUXILIARY_TABLE:NEAR,JAPAN_TABLE:NEAR
        EXTRN   FKYTBL:NEAR,PRINTER_TABLE:NEAR
        EXTRN   OUT_NXT_PTR:NEAR
        EXTRN   NEW_1A_ENT:NEAR
        EXTRN   INT_1CH:NEAR
        EXTRN   TIM_INT:NEAR
        EXTRN   NEW_1B_INT:NEAR

        EXTRN   CONOUT_FAR:FAR
        EXTRN   BOOT_DRIVE:BYTE

;93/03/25 MVDM DOS5.0A---------
        EXTRN   DOSDATASG:WORD
;       EXTRN   DOSDATASG:BYTE
;------------------------------
        

Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
                ASSUME  CS:DATAGRP,DS:DATAGRP

        EXTRN   LEAP_IN:FAR

Bios_Data_Init  ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   CRTOUT:NEAR
        EXTRN   BDATA_SEG:word

Bios_Code       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

;       PUBLIC  RE_INIT,LEAP_OUT
        PUBLIC  LEAP_OUT

        PUBLIC  REINIT_END

        PUBLIC  INT_29_CODE,MSGLOOP,MSGL
        PUBLIC  MSGLOOP_FAR
        PUBLIC  INT_TRAP_CODE


        PUBLIC  NOT_BSYS_ENT                    ;85/5/19
        PUBLIC  INT_FF                          ;85/05/20
        PUBLIC  WARM_START
;---------------------------------------------------------------------------
;----------------------------------------------------- 88/02/25 ------------
        PUBLIC  SAVE_INT18,CRTBIOS_START_CODE
        PUBLIC  STACKINIT
;---------------------------------------------------------------------------
;------------------------------------------------------ DOS5 91/09/09 -
        public  OLD_1A_OFFSET,OLD_1B_OFFSET
;----------------------------------------------------------------------
GETCS   EQU     2               ;                               89/08/08
GETIP   EQU     0               ;                               89/08/08
CR =    13                      ;CARRIAGE RETURN
LF =    10                      ;LINE FEED

FONT16SIZE = 16/8 * 16 + 2
FONT24SIZE = 24/8 * 24 + 2
SET_FONT16 = 26
SET_FONT24 = 32

DEF_DRV EQU     0336H

        PUBLIC  REINIT_CODE_START
        PUBLIC  REINIT_CODE_END

REINIT_CODE_START:

;****************************************************************
;*                                                              *
;*      RE-INIT ENTRY:                                          *
;*              LOAD USER-KANJI-FONT & CONTENTS OF KEY.TBL      *
;*                                                              *
;****************************************************************
PUBLIC  REINIT_CODE_RTN

REINIT_CODE_RTN PROC    FAR

;RE_INIT:

        PUSH    ES                      ;NEW                            870826
        PUSH    DS
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
;************************************************
;*                                              * CORRECT AT 870825
;*      READ & LOAD USER KANJI FONT ( H/N )     *
;*                                              *
;************************************************
        PUSH    DS
        MOV     DX,0060H                        ;ES,DS <- 0060H
        MOV     DS,DX                   ;
;----------------------------------------------- DOS5 91/02/25 -------
        MOV     DL,BOOT_DRIVE
        MOV     ES,dosdatasg            ;
        MOV     ES:[DEF_DRV],DL         ; dosdata:[336h] <- BOOT_DRIVE
        MOV     DX,0060H
;---------------------------------------------------------------------
        MOV     ES,DX                   ;

        TEST    ES:[SYS_501],00001000B  ;CHECK H/W MODE
        POP     DS                      ;
        JNZ     USK24                   ;JUMP IF HIRESO(24DOT) MODE
        TEST    ES:[SYS_501],01110000B  ;CHECK PC9801 OR OTHER
        JNZ     USK16                   ;JUMP IF NOT 9801
        JMP     N10                     ;JUMP IF 9801(N10)
;****************************************
;*                                      *
;*      NORMAL MODE FONT   (870825)     *
;*                                      *
;****************************************
USK16:
        PUSH    DS                      ;
        PUSH    CS                      ;
        POP     DS                      ;
        MOV     DX,OFFSET USFONT16
        CALL    OPEN_FILE               ;OPEN 'USKCG16.SYS'
        JC      NOT_USFONT10            ;ERROR
        POP     DS                      ;
        PUSH    DS
        MOV     CX,2000H                ;FOMT FILE SIZE
        CALL    READ_FILE               ;READ FONT DATA
        JC      NOT_USFONT              ;ERROR
        PUSH    AX                      ;
        PUSH    ES                      ;
        XOR     AX,AX                   ;
        MOV     ES,AX                   ;
;------------------------------------------------------ MSDOS 3.3B PATCH --
        TEST    ES:BYTE PTR [0458H], 80H                ;90/03/16
        JNZ     SET65                                   ;90/03/16

        MOV     AL,3FH                  ;
        TEST    ES:BYTE PTR [054CH],00001000B
        JZ      SET63                   ;
        MOV     AL,0BCH                 ;
SET63:
        MOV     DS:[0100H],AL           ;
SET65:                                                  ;90/03/16
;--------------------------------------------------------------------------
        POP     ES                      ;
        POP     AX                      ;

        MOV     AH,SET_FONT16           ;BIOS COMMAND
        MOV     BX,DS                   ;BX:CX = BUFFER SEG & OFFSET
        MOV     CX,100H + FONT16SIZE    ;SKIP HEADER
L_SET16:
        MOV     SI,CX                   ;
        MOV     DX,[SI]                 ;JIS CODE
        INT     18H                     ;CALL BIOS;NEC NT PROT
        ADD     CX,FONT16SIZE           ;NEXT
        DEC     WORD PTR DS:[0100H]     ;DECREMENT COUNTER
        JNZ     L_SET16                 ;NEXT FONT
        CALL    LOAD_OK         ;-----------------------------DEB----------
        JMP     short NOT_USFONT        ;JMP TO CLOSE ROUTINE
;****************************************
;*                                      *
;*      HIRESO MODE FONT                *
;*                                      *
;****************************************
USK24:
        PUSH    DS                      ;
        PUSH    CS                      ;
        POP     DS                      ;
        MOV     DX,OFFSET USFONT24
        CALL    OPEN_FILE               ;OPEN 'USKCG24.SYS'
        JC      NOT_USFONT10            ;JMP IF OPEN ERROR
        POP     DS                      ;RESTORE DS
        PUSH    DS
        MOV     CX,4000H                ; SET NUMBER OF PATERN BYTE
        CALL    READ_FILE               ;READ
        JC      NOT_USFONT              ; SKIP IF FAIL TO READ
        MOV     AH,SET_FONT24           ; SET COMMAND FOR CRT-BIO
        MOV     BX,0100H + FONT24SIZE+2
L_SETFONT:
        MOV     SI,BX
        MOV     DX,[SI-2]               ; SET FONT #
        INT     18H                     ; CALL CRT-BIO
        ADD     BX,FONT24SIZE           ; SET NEXT FONT
        DEC     WORD PTR DS:[100H]
        JNZ     L_SETFONT
        CALL    LOAD_OK         ;-----------------------------DEB----------
NOT_USFONT:
        MOV     BX,CS:HANDOLE
        MOV     AH,3EH
        INT     21H                     ; CLOSE HANDOLE
NOT_USFONT10:
        POP     DS
N10:
;************************************************
;*                                              *
;*      READ & SET FUNCTION KEY TABLE           *
;*                                              *
KTBL_HED = 16           ;KEY.TBL HEADER   SIZE  *
FUNC_SIZ = 16 * 15 * 3  ;FUNCTION KEY TBL SIZE  *
ARRW_SIZ =  6 * 11      ;ARROW KEY    TBL SIZE  *
;************************************************
        PUSH    DS
        PUSH    CS
        POP     DS
        MOV     DX,OFFSET KEY_FCB
        CALL    OPEN_FILE               ;OPEN 'KEY.TBL'
        POP     DS
        JB      SKP_KEY10               ; JMP IF NO-KEY TABLE
        MOV     CX,1320                 ; SET NUMBER OF KEY-TABLE
;--------------------------------------------------------- 90/03/16 --
;       MOV     DX,OFFSET FAT_INF
;       MOV     AH,3FH                  ; READ KEY-TABLE FILE
;       INT     21H
        CALL    READ_FILE
;---------------------------------------------------------------------
        JB      SKP_KEY                 ; SKIP IF FAIL TO READ
        MOV     CL,0DH
        MOV     DX,100H + 16            ;SKIP HEADER
        MOV     AX,00FFH
        INT     220                     ;SET FUNCTION KEY
        MOV     CL,0DH
        MOV     DX,100H + KTBL_HED + FUNC_SIZ + ARRW_SIZ -2
        MOV     AX,0100H
        INT     220                     ;SET DATA KEY
        CALL    LOAD_OK_KEY     ;----------------------- DEB ---------------
SKP_KEY:
        MOV     BX,CS:HANDOLE
        MOV     AH,3EH
        INT     21H             ; CLOSE CURRENT HANDOLE
SKP_KEY10:
;--------------------------------------------------------- 90/03/20 --
;       MOV     AX,352FH                        ;FOR WIN/386 INSTANCETABLE
;       INT     21H
;       MOV     WORD PTR CS:[OLD2FVEC], BX
;       MOV     WORD PTR CS:[OLD2FVEC+2], ES
;       PUSH    CS
;       POP     DS
;       MOV     DX,OFFSET INST2F
;       MOV     AX,252FH
;       INT     21H
;       MOV     AX,[SEG_DOS]
;       MOV     [DOSSEG1],AX
;       MOV     [DOSSEG2],AX
;       MOV     [DOSSEG3],AX
;---------------------------------------------------------------------
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        POP     DS
        POP     ES                      ;NEW                            870826
        RET

REINIT_CODE_RTN ENDP


;****************************************
;*                                      *
;*      OPEN FILE                       *
;*                                      *
;****************************************
OPEN_FILE:
        MOV     AX,3D00H        ; SET OPEN HANDOLE
        INT     21H             ; OPEN USKCG.SYS
        JB      OPEN_FILE_DONE  ; JMP IF OPEN ERROR
        MOV     CS:[HANDOLE],AX
        MOV     BX,AX           ; SET HANDOLE
OPEN_FILE_DONE:
        RET

;****************************************
;*                                      *
;*      READ FILE RECORD                *
;*                                      *
;****************************************
READ_FILE:
        MOV     DX,0100H        ;BUFFER ADDRESS
        MOV     AH,3FH          ; READ FONT-PATERN
        INT     21H
        RET
;*************** FOR DEBUGGING **********
;*                                      *
USKCG_OK_M      DB      '  [U`[h܂',13,10,0
KEYTBL_OK_M     DB      '  jdxDsak[h܂',13,10,0

LOAD_OK:
        PUSH    BX
        MOV     BX,OFFSET USKCG_OK_M
        CALL    DEB_MSG
        POP     BX
        RET
LOAD_OK_KEY:
        PUSH    BX
        MOV     BX,OFFSET KEYTBL_OK_M
        CALL    DEB_MSG
        POP     SI
        RET
DEB_MSG:
        PUSH    DS
        PUSH    CS
        POP     DS
        CALL    MSGLOOP
        POP     DS
        RET
        PAGE
;****************************************************************
;*                                                              *
;*      INT29   1-BYTE CONSOLE OUTPUT                           *
;*                                                              *
;*              INPUT    : AL = ASCII CODE FOR DISPLAY          *
;*              OUTPUT   : NONE                                 *
;*              BREAK REG: NONE                                 *
;*                                                              *
;****************************************************************

CONOUT_CODE     DW      OFFSET DATAGRP:CONOUT_FAR
                DW      0060H

INT_29_CODE:
        STI
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    SI
        PUSH    DI
        PUSH    BP
        PUSH    DS
        PUSH    CS
        POP     DS
        CALL    CS:DWORD PTR CONOUT_CODE
        POP     DS
        POP     BP
        POP     DI
        POP     SI
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        IRET

;****************************************
;*  WIN/386 INSTANCE TABLE SUPPORT      *
;*                                      *
;****************************************

;WIN386INSTMUX  EQU     01603H
;WIN386INSTSIG  EQU     05248H
;OLD2FVEC       DD      0

;DOSINSTANCETABLE:
;DOSSEG1                DW      0000H
;               DW      0000H                   ;MSDOS.SYS STACK
;               DW      0009H
;               DW      0060H                   ;CONSOLE TABLE POINTER
;               DW      OFFSET CONSOLE_TABLE
;               DW      0180H                   ;384BYTE
;               DW      0060H                   ;AUXILIARY TABLE POINTER
;               DW      OFFSET AUXILIARY_TABLE
;               DW      001AH                   ;26BYTE
;               DW      0060H                   ;JAPAN FEP TABLE POINTER
;               DW      OFFSET JAPAN_TABLE
;               DW      2554H                   ;9556BYTE
;               DW      0060H                   ;FUNCTION KEY TABLE POINTER
;               DW      OFFSET FKYTBL
;               DW      0384H                   ;840BYTE
;               DW      0060H                   ;PRINTER TABLE POINTER
;               DW      OFFSET PRINTER_TABLE
;               DW      000BH                   ;11BYTE
;               DW      0060H
;               DW      0000H
;               DW      0261H                   ;609BYTE
;DOSSEG2                DW      0000H                   ;MSDOS SEGMENT
;               DW      0048H
;               DW      0004H
;DOSSEG3                DW      0000H                   ;MSDOS SEGMENT
;               DW      00A0H
;               DW      0090H
;               DW      0060H
;               DW      OFFSET OUT_NXT_PTR
;               DW      0004H

;INST2F:
;       CMP     AX,WIN386INSTMUX
;       JNE     SHORT I2FCHAIN
;       MOV     AX,WIN386INSTSIG
;       PUSH    CS
;       POP     DS
;       MOV     SI,OFFSET DOSINSTANCETABLE
;       IRET
;I2FCHAIN:
;       JMP     CS:[OLD2FVEC]


;****************************************
;*                                      *
;*      PRINT MESSAGE                   *
;*                                      *
;****************************************
MSGLOOP_FAR     PROC    FAR
        CALL    MSGLOOP
        RET
MSGLOOP_FAR     ENDP

MSGLOOP:
        PUSH    BX
        PUSH    DS
        MOV     DS,CS:[BDATA_SEG]
        MOV     CL,CR
        CALL    CRTOUT
        MOV     CL,LF
        CALL    CRTOUT
        POP     DS
        POP     BX
MSGL:
        MOV     AL,[BX]
        TEST    AL,AL                   ;END OF DATA?
        JZ      RETURN                  ;JUMP IF SO
        MOV     CL,AL
        PUSH    BX
        PUSH    DS
        MOV     DS,CS:[BDATA_SEG]
        CALL    CRTOUT
        POP     DS
        POP     BX
        INC     BX
        JMP     SHORT   MSGL
RETURN:
        RET

;****************************************
;*                                      *
;*      PRINT MESSAGE                   *
;*                                      *
;****************************************
WARM_START:
        ASSUME DS:INTVEC
        XOR     AX,AX
        MOV     DS,AX
        AND     [BIOS_FLAG],00111111B   ;
        MOV     AX,0060H
        MOV     ES,AX
        MOV     AX,ES:[INT1E_OFST]      ;RESUME INT1E VECTOR
        MOV     WORD PTR [WARMBOOT],AX
        MOV     AX,ES:[INT1E_SGMT]
        MOV     WORD PTR [WARMBOOT+2],AX
        JMP     WBOOT_ROM
        ASSUME DS:BIOS_CODE

;********************************************************
;*                                                      *
;*      CLEAR ROM-BIOS BUGS                             *
;*                                                      *
;********************************************************


LEAP_OUT        PROC    FAR
LEAP_OUT        ENDP
;--------
;
;----------------------------------------------------- 871015 --------
;       TEST    CS:[SYS_501],00001000B  ;CHECK HW MODE
        ASSUME  DS:INTVEC
        TEST    [BIOS_FLAG+1],00001000B ;CHECK HW MODE
;---------------------------------------------------------------------
        JNZ     BUG_HIRESO              ;JUMP IF HIRESO H/W

;
;   NORMAL MODE ONLY
;
;---------------------------------------------------- 871015 ---------
;       TEST    CS:[SYS_500],00000001B  ;CHECK V1/Y1
        TEST    [BIOS_FLAG],00000001B   ;CHECK V1/Y1
        ASSUME  DS:BIOS_CODE
;---------------------------------------------------------------------

        JMP     BUG_NORMAL_SKIP1A       ;NEC NT PROT
        ASSUME DS:INTVEC
        PUSH    [PRNT_VEC_OFST]
        POP     CS:[OLD_1A_OFFSET]
        PUSH    [PRNT_VEC_SGMT]
        POP     CS:[OLD_1A_SEGMENT]
        ADD     CS:[OLD_1A_OFFSET],0019H
        MOV     [PRNT_VEC_OFST],OFFSET NEW_1A_ENT
        MOV     [PRNT_VEC_SGMT],0060H           ;BIOS_CODE SEGMENT

        ASSUME DS:BIOS_CODE
        MOV     AH,10H
        INT     1AH                     ;INITIALIZE THE PRINTER
BUG_NORMAL_SKIP1A:
        JMP     BUG_COMMON_INT1B

;
;    HIRESOLUTION MODE ONLY
;
BUG_HIRESO:
        PUSH    DS
        MOV     AX,0F000H
        MOV     DS,AX
        TEST    DS:BYTE PTR [0FF88H],01H    ;CHECK X2(XA) 
        JNE     TIMER_SKIP                  ;JUMP IF NOT XA
        JMP     NEXT_LEAP
TIMER_SKIP:
        PUSH    CS:WORD PTR PAT0
        PUSH    CS:WORD PTR PAT0+1
        PUSH    CS:WORD PTR PAT1+1
        PUSH    CS:WORD PTR PAT2+1
        PUSH    CS:WORD PTR PAT3+1
        XOR     AX,AX
        MOV     DS,AX
        ASSUME DS:INTVEC
        LES     SI,DS:DWORD PTR [TIMR_VEC_OFST]
        MOV     CS:MEM1C,SI
        MOV     CS:MEM1C+2,ES
        MOV     [TIMR_VEC_OFST],OFFSET INT_1CH
        MOV     [TIMR_VEC_SGMT],0060H
        MOV     [USR_TIMR_OFST],OFFSET TIM_INT
        MOV     [USR_TIMR_SGMT],0060H
        ASSUME DS:BIOS_CODE
        PUSH    ES
        POP     DS
        PUSH    CS
        POP     ES
        MOV     DI,OFFSET TIMER
        PUSH    DI
        ADD     SI,1A3H
        MOV     CX,212H
        REP     MOVSB
        MOV     AL,0FAH                 ; CODE 'CLI'
        POP     DI
        STOSB
        MOV     DI,OFFSET CAL_CANCEL_PB
        STOSB
        MOV     DI,OFFSET TIMER+0BCH
        STOSB
        MOV     DI,OFFSET TIMER+19EH
        MOV     SI,OFFSET TBL1
;------------------------------------------------ PATCH FIX 88/02/25 -
;       MOV     CX,5
        MOV     CL,5
        PUSH    CS
        POP     DS
        REPZ    MOVSB
;       POP     CS:WORD PTR PAT3+1
;       POP     CS:WORD PTR PAT2+1
;       POP     CS:WORD PTR PAT1+1
;       POP     CS:WORD PTR PAT0+1
;       POP     CS:WORD PTR PAT0
        POP     WORD PTR CS:[PAT3+1]
        POP     WORD PTR CS:[PAT2+1]
        POP     WORD PTR CS:[PAT1+1]
        POP     WORD PTR CS:[PAT0+1]
        POP     WORD PTR CS:[PAT0]
        MOV     WORD PTR CS:[PAT0+12H], 0AEEBH  ;               89/07/28
;----------------------------------------------------------------------
NEXT_LEAP:
        POP     DS

;
;   DISK BIOS BUG FIX
;
BUG_COMMON_INT1B:
        JMP     LEAP_EXIT               ;NEC NT PROT

        ASSUME DS:INTVEC
        PUSH    [DISK_VEC_OFST]         ;SAVE DISK BIOS VECTOR
        POP     CS:[OLD_1B_OFFSET]
        PUSH    [DISK_VEC_SGMT]
        POP     CS:[OLD_1B_SEGMENT]
        MOV     [DISK_VEC_OFST],OFFSET NEW_1B_INT
        PUSH    CS:[BDATA_SEG]          ;0060H
        POP     [DISK_VEC_SGMT]         ;SET NEW VETOR
;       JMP     NEXT_BUG
        ASSUME DS:BIOS_CODE
LEAP_EXIT:                              ;NEC NT PROT
        JMP     LEAP_IN                 ;RETURN TO 'INIT' MODULE
;
;****************************************
;*                                      *
;*      PRINTER BIOS PATCH ROUTINE      *
;*                                      *
;*      ( NORMAL(V1/Y1) ONLY )          *
;*                                      *
;****************************************
PUBLIC  NEW_1A_ENT_CODE
NEW_1A_ENT_CODE:
        STI
        PUSH    DS
        PUSH    DX
        DB      0EAH
OLD_1A_OFFSET   DW      0
OLD_1A_SEGMENT  DW      0
;
;****************************************
;*                                      *
;*      DISK BIOS PATCH ROUTINE         *
;*                                      *
;*      ( HIRESO MODE ONLY )            *
;*                                      *
;****************************************
        PUBLIC  NEW_1B_INT_CODE
NEW_1B_INT_CODE:
        PUSH    AX
        AND     AL,78H
        CMP     AL,70H
        POP     AX
        JE      NEED_LOOP
NEW_1B_PRC:
        DB      0EAH
OLD_1B_OFFSET   DW      0
OLD_1B_SEGMENT  DW      0
;
NEED_LOOP:
        PUSH    BP
        MOV     BP,SP
        PUSH    SS:[BP+0002H]
        POP     CS:OLD_1B_OFF2
        PUSH    SS:[BP+0004H]
        POP     CS:OLD_1B_SEG2
        MOV     SS:WORD PTR [BP+0002H],OFFSET NEED_LOOP10
        MOV     SS:WORD PTR [BP+0004H],CS
        POP     BP
        JMP     NEW_1B_PRC
NEED_LOOP10:
        JNB     NEED_LOOP20
        PUSH    CX
        MOV     CX,0
        LOOP    $
        POP     CX
NEED_LOOP20:
        DB      0EAH
OLD_1B_OFF2     DW      0
OLD_1B_SEG2     DW      0

;****************************************
;*                                      *
;*      TIMER BIOS PATCH ROUTINE        *
;*                                      *
;*      ( HIRESO MODE ONLY )            *
;*                                      *
;****************************************
MEM1C   DW      0,0
TBL1    DB      0E8H,06DH,000H,0EBH,005H

PUBLIC  INT_1CH_CODE
INT_1CH_CODE:
        CMP     AH,2
        JB      TIM_00
        CMP     AH,6
        JBE     TIM_01
TIM_00:
        JMP     CS:DWORD PTR MEM1C
TIM_01:
        PUSH    DS
        PUSH    ES
        PUSH    SI
        PUSH    BP
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        XOR     SI,SI
        MOV     DS,SI
        SUB     AH,2
        JE      CAL_TIMER_SET98
        DEC     AH
        JE      CAL_CANCEL_PB
        DEC     AH
        JE      CAL_TIMER_SET0
        DEC     AH
        JE      CAL_TIMER_SET1
        JMP     CAL_BEEP_SETR
CAL_RESUME:
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        POP     BP
        POP     SI
        POP     ES
        POP     DS
        IRET

CAL_TIMER_SET98:
        JMP     short CAL_SINGLE_SET    
CAL_TIMER_SET0:
        DEC     AH
CAL_TIMER_SET1:
TIMER:
        DB      30H DUP (0)
PAT0:
        JMP     SHORT CAL_RESUME
        NOP
CAL_CANCEL_PB:
        DB      45H DUP (0)
PAT1:
        JMP     CAL_RESUME
CAL_SINGLE_SET:
        DB      15H DUP (0)
PAT2:
        JMP     CAL_RESUME
CAL_BEEP_SETR:
        DB      3 DUP (0)
PAT3:
        JMP     CAL_RESUME
        DB      18H DUP (0)

        PUBLIC  TIM_INT_CODE
TIM_INT_CODE:
        DB      161H DUP (0)

        JMP     SHORT $+2
        JMP     SHORT $+2
        CLI
        OUT     02,AL
        JMP     SHORT $+2
        JMP     SHORT $+2
        STI
        RET
        
;************************************************
;*                                              *
;*      CRT BIOS PATCH ROUTINE                  *
;*                                              *
;************************************************

SAVE_PIC        DB      0
SAVE_INT18      DW      2 DUP(0)

CRTBIOS_START_CODE:
                CMP     AH,0AH
                JB      CRTBIOS010
                CLI
                PUSH    AX
                IN      AL,02
                JMP     SHORT $+2
                MOV     CS:SAVE_PIC,AL
                MOV     AL,0FBH
                OUT     02,AL
                JMP     SHORT $+2
                POP     AX
                PUSHF
                CALL    DWORD PTR CS:[SAVE_INT18]
;----------------------------------------------- DOS5 90/12/22 -------
;PATCH FIX
                PUSH    AX
                PUSH    DS
                XOR     AX,AX
                MOV     DS,AX
                CMP     WORD PTR DS:[448H],0
                JNZ     CRT_BIOS1
                CMP     WORD PTR DS:[58AH],0
                JNZ     CRT_BIOS1
                CMP     WORD PTR DS:[444H],0
                JNZ     CRT_BIOS1
                MOV     AL,CS:[SAVE_PIC]
                JMP     SHORT CRT_BIOS2
CRT_BIOS1:
                MOV     AL,CS:[SAVE_PIC]
;93/03/25 MVDM DOS5.0A---------------------------DOS5 90/02/26-----------
;<patch BIOS50-P10>
                AND     AL,0FEH
;---------------
;               AND     AL,0EFH
;------------------------------------------------------------------------
CRT_BIOS2:
                OUT     02,AL
                JMP     $+2
                STI
                POP     DS
                POP     AX
;---------------------------------------------------------------------
;               PUSH    AX
;               IN      AL,02
;;-----------------------------------------------------  89/07/28  ---
;               AND     AL,0FEH
;               JMP     SHORT $+2
;               OUT     02,AL
;               JMP     SHORT $+2
;               STI
;               JMP     SHORT $+2
;               JMP     SHORT $+2
;               MOV     AL,CS:SAVE_PIC
;               cli
;               OUT     02,AL
;               JMP     SHORT $+2
;               sti
;               POP     AX
;               NOP
;               NOP
;----------------------------------------------------  890/7/28  ---
                IRET
CRTBIOS010:
                JMP     CS:DWORD PTR [SAVE_INT18]

;************************************************
;*                                              *
;*      STACKINIT ROUTINE                       *
;*                                              *
;************************************************
STACKINIT       PROC    FAR
                RET
STACKINIT       ENDP


;****************************************************************
;*                                                              *
;*      TRAP INTERUPT ENTRY                                     *
;*                                                              *
;****************************************************************
INT_TRAP_CODE:
        CLI
        MOV     AX,CS
        MOV     DS,AX
;-----------------------------------------------------  89/08/08  ---
        MOV     SI,SP
        MOV     AX,WORD PTR SS:[SI+GETCS]       ;GET USER CS
        MOV     ES,AX
        MOV     BX,WORD PTR SS:[SI+GETIP]       ;GET USER IP
        MOV     AL,ES:[BX-1]            ;GET INT NO.
        MOV     AH,AL
        MOV     CL,4
        SHR     AH,CL
        AND     AL,0FH
        CMP     AH,0AH                  ;IF 0-9
        JB      NUMDATA                 ;THEN JMP
        ADD     AH,7
NUMDATA:
        CMP     AL,0AH                  ;IF 0-9
        JB      NUMDATA1                ;THEN JMP
        ADD     AL,7
NUMDATA1:
        ADD     BYTE PTR INT_NO+1,AH    ;SET INT NO.
        ADD     BYTE PTR INT_NO+3,AL    ;SET INT NO.
;-----------------------------------------------------  89/08/08  ---
        MOV     BX,OFFSET INT_TRP
        CALL    MSGLOOP
        MOV     AL,06H
        OUT     37H,AL
        XOR     CX,CX
        MOV     BX,5
INT_BUZZ:
        LOOP    INT_BUZZ
        DEC     BX
        JNZ     INT_BUZZ
        MOV     AL,07H
        OUT     37H,AL
        HLT
INT_HLT:
        JMP     SHORT   INT_HLT

;****************************************************************
;*                                                              *
;*      ENTRY FOR INT78H ( NOT B4670 SYSTEM )   85/05/19        *
;*                                                              *
;****************************************************************

NOT_BSYS_ENT:
        MOV     AX,-1           ;SET "NOT BRANCH SYSTEM" ERROR CODE
        IRET

;****************************************************************
;*                                                              *
;*      INT FFH ENTRY   (85/05/20)                              *
;*                                                              *
;****************************************************************
INT_FF:
        IRET                    ;INTERRUPT RETURN ONLY

        PAGE
;****************************************************************
;*                                                              *
;*      REINIT DATA                                             *
;*                                                              *
;****************************************************************

;-----------------------------------------------------  89/08/08  ---
INT_TRP DB      'sȊ荞݂܂',CR,LF
        DB      '荞ݔԍ@@'
INT_NO  DB      'O','O','g',CR,LF
        DB      'ZbgXCb`Ă',0
;-----------------------------------------------------  89/08/08  ---
;INT_TRP        DB      'Int trap halt',0       ;TRAP INT MESSAGE

KEY_FCB DB      'KEY.TBL',0             ;FUNCTION KEY FILE NAME

USFONT24   DB   'USKCG24.SYS',0         ;USER FONT (24DOT) FILE
USFONT16   DB   'USKCG16.SYS',0         ;          (16DOT)

HANDOLE DW      0


REINIT_CODE_END:
REINIT_END      EQU     $

BIOS_CODE       ENDS


        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\sysimes.asm ===
page	,160
	;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

	include	version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

sysinitseg segment

	public	badopm,crlfm,badsiz_pre,badld_pre,badcom,badcountry
	public	badmem,badblock,badstack
	public	insufmemory,badcountrycom
	public	badorder,errorcmd
	public	badparm
        public  toomanydrivesmsg			;M029

ifdef	JAPAN
	public	badopm2,badsiz_pre2,badld_pre2,badcom2,badcountry2
	public	badmem2,badblock2,badstack2
	public	insufmemory2,badcountrycom2
	public	badorder2,errorcmd2
	public	badparm2
        public  toomanydrivesmsg2
endif

	include msbio.cl3

sysinitseg	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\sysinit2.asm ===
page	,160
title	bios system initialization

;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------


	include version.inc		; set version build flags
	include biosseg.inc		; establish bios segment structure

lf	equ	10
cr	equ	13
tab	equ	9

; the following depends on the positions of the various letters in switchlist

switchnum	equ 11111000b		; which switches require number

ifdef NEC_98
	include bpb.inc
endif   ;NEC_98
	include syscall.inc
	include doscntry.inc
	include devsym.inc
	include ioctl.inc
	include devmark.inc	; needed


ifndef NEC_98
stacksw equ	true		;include switchable hardware stacks
else    ;NEC_98
stacksw equ	false		;include switchable hardware stacks
endif   ;NEC_98

	if	ibmjapver
noexec	equ	true
	else
noexec	equ	false
	endif

ifdef NEC_98
Bios_Data segment
	extrn ec35_flag: byte
Bios_Data ends
endif   ;NEC_98

sysinitseg segment public

assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing

	extrn	badopm:byte,crlfm:byte,badcom:byte,badmem:byte,badblock:byte
	extrn	badsiz_pre:byte,badld_pre:byte

	extrn	dosinfo:dword
	extrn	memory_size:word,fcbs:byte,keep:byte
	extrn	default_drive:byte,confbot:word,alloclim:word
	extrn	buffers:word,zero:byte,sepchr:byte
	extrn	files:byte
	extrn	count:word,chrptr:word
	extrn	bufptr:byte,memlo:word,prmblk:byte,memhi:word
	extrn	ldoff:word,area:word,packet:byte,unitcount:byte,
	extrn	break_addr:dword,bpb_addr:dword,drivenumber:byte
	extrn	com_level:byte, cmmt:byte, cmmt1:byte, cmmt2:byte
	extrn	cmd_indicator:byte
	extrn	donotshownum:byte
	extrn	multdeviceflag:byte
	extrn	devmark_addr:word
	extrn	setdevmarkflag:byte
	extrn	org_count:word

	extrn	pararound:near
	extrn	getchr:near
	extrn	stall:near
	extrn	error_line:near

	extrn	DevEntry:dword

	insert_blank	db	0	; M051: indicates that blank has been
					; M051: inserted 
ifdef	JAPAN
	extrn	badmem2:byte,badld_pre2:byte
	extrn	IsDBCSCodePage:near
endif

	public	int24,open_dev,organize,mem_err,newline,calldev,badload
	public	prndev,auxdev,config,commnd,condev,getnum,badfil,prnerr
	public	round,delim,print
ifndef NEC_98
	public	parseline,
else    ;NEC_98
	public	setparms, parseline, diddleback
endif   ;NEC_98
	public	setdoscountryinfo,set_country_path,move_asciiz
	public	cntry_drv,cntry_root,cntry_path
	public	delim
        public  pathstring

        public  MseDev                  ; NTVDM internal mouse driver



ifdef NEC_98
;----------------------------------------------------------------------------
;
; procedure : setparms
;
; the following set of routines is used to parse the drivparm = command in
; the config.sys file to change the default drive parameters.
;
;----------------------------------------------------------------------------
;
setparms	proc	near

	push	ds
	push	ax
	push	bx
	push	cx
	push	dx

	push	cs
	pop	ds
	assume	ds:sysinitseg

	xor	bx,bx
	mov	bl,byte ptr drive
	inc	bl			; get it correct for ioctl
					;  call (1=a,2=b...)
	mov	dx,offset deviceparameters
	mov	ah,ioctl
	mov	al,generic_ioctl
	mov	ch,rawio
	mov	cl,set_device_parameters
	int	21h
	test	word ptr switches, flagec35
	jz	not_ec35

	mov	cl,byte ptr drive	; which drive was this for?

	mov	ax,Bios_Data		; get Bios_Data segment
	mov	ds,ax			; set Bios_Data segment
	assume	ds:Bios_Data

	mov	al,1			; assume drive 0
	shl	al,cl			; set proper bit depending on drive
	or	ds:ec35_flag,al 	; set the bit in the permanent flags

not_ec35:
	pop	dx			; fix up all the registers
	pop	cx
	pop	bx
	pop	ax
	pop	ds
	assume	ds:nothing
	ret

setparms	endp

;
;----------------------------------------------------------------------------
;
; procedure : diddleback
;
; replace default values for further drivparm commands
;
;----------------------------------------------------------------------------
;

diddleback	proc	near

	push	ds
	push	cs
	pop	ds
	assume	ds:sysinitseg
	mov	word ptr deviceparameters.dp_cylinders,80
	mov	byte ptr deviceparameters.dp_devicetype, dev_3inch720kb
	mov	word ptr deviceparameters.dp_deviceattributes,0
	mov	word ptr switches,0	    ; zero all switches
	pop	ds
	assume	ds:nothing
	ret

diddleback	endp
endif   ;NEC_98
;
;----------------------------------------------------------------------------
;
; procedure : parseline
;
; entry point is parseline. al contains the first character in command line.
;
;----------------------------------------------------------------------------
;

parseline	proc	near
					; don't get character first time
	push	ds

	push	cs
	pop	ds
	assume	ds:sysinitseg

nextswtch:
	cmp	al,cr			; carriage return?
	jz	done_line
	cmp	al,lf			; linefeed?
	jz	put_back		; put it back and done

; anything less or equal to a space is ignored.

	cmp	al,' '                  ; space?
	jbe	get_next		; skip over space
	cmp	al,'/'
	jz	getparm
	stc				; mark error invalid-character-in-input
	jmp	short exitpl

getparm:
	call	check_switch
	mov	word ptr switches,bx	; save switches read so far
	jc	swterr

get_next:
	call	getchr
	jc	done_line
	jmp	nextswtch

swterr:
	jmp	short exitpl		; exit if error

done_line:
	test	word ptr switches,flagdrive  ; see if drive specified
	jnz	okay
	stc				; mark error no-drive-specified
	jmp	short exitpl

okay:
ifndef NEC_98
;	mov	ax,word ptr switches
;	and	ax,0003h	    ; get flag bits for changeline and non-rem
;	mov	word ptr deviceparameters.dp_deviceattributes,ax
;	mov	word ptr deviceparameters.dp_tracktableentries, 0
;	clc			    ; everything is fine
;	call	setdeviceparameters
else    ;NEC_98
	mov	ax,word ptr switches
	and	ax,0003h	    ; get flag bits for changeline and non-rem
	mov	word ptr deviceparameters.dp_deviceattributes,ax
	mov	word ptr deviceparameters.dp_tracktableentries, 0
	clc			    ; everything is fine
	call	setdeviceparameters
endif   ;NEC_98
exitpl:
	pop	ds
	ret

put_back:
	inc	count			; one more char to scan
	dec	chrptr			; back up over linefeed
	jmp	short done_line

parseline	endp

;
;----------------------------------------------------------------------------
;
; procedure : check_switch
;
; processes a switch in the input. it ensures that the switch is valid, and
; gets the number, if any required, following the switch. the switch and the
; number *must* be separated by a colon. carry is set if there is any kind of
; error.
;
;----------------------------------------------------------------------------
;

check_switch	proc	near

	call	getchr
	jc	err_check
	and	al,0dfh 	    ; convert it to upper case
	cmp	al,'A'
	jb	err_check
	cmp	al,'Z'
	ja	err_check

	push	es

	push	cs
	pop	es

	mov	cl,byte ptr switchlist	; get number of valid switches
	mov	ch,0
	mov	di,1+offset switchlist	; point to string of valid switches
	repne	scasb

	pop	es
	jnz	err_check

	mov	ax,1
	shl	ax,cl			; set bit to indicate switch
	mov	bx,word ptr switches	; get switches so far
	or	bx,ax			; save this with other switches
	mov	cx,ax
	test	ax, switchnum		; test against switches that require number to follow
	jz	done_swtch

	call	getchr
	jc	err_swtch

	cmp	al,':'
	jnz	err_swtch

	call	getchr
	push	bx			; preserve switches
	mov	byte ptr cs:sepchr,' '	; allow space separators
	call	getnum
	mov	byte ptr cs:sepchr,0
	pop	bx			; restore switches

; because getnum does not consider carriage-return or line-feed as ok, we do
; not check for carry set here. if there is an error, it will be detected
; further on (hopefully).

	call	process_num

done_swtch:
	clc
	ret

err_swtch:
	xor	bx,cx			; remove this switch from the records
err_check:
	stc
	ret

check_switch	endp

;
;----------------------------------------------------------------------------
;
; procedure : process_num
;
; this routine takes the switch just input, and the number following (if any),
; and sets the value in the appropriate variable. if the number input is zero
; then it does nothing - it assumes the default value that is present in the
; variable at the beginning. zero is ok for form factor and drive, however.
;
;----------------------------------------------------------------------------
;

process_num	proc	near
	test	word ptr switches,cx	; if this switch has been done before,
	jnz	done_ret		; ignore this one.
	test	cx,flagdrive
	jz	try_f
	mov	byte ptr drive,al
	jmp	short done_ret

try_f:
	test	cx,flagff
	jz	try_t

; ensure that we do not get bogus form factors that are not supported

ifndef NEC_98
;	mov	byte ptr deviceparameters.dp_devicetype,al
else    ;NEC_98
	mov	byte ptr deviceparameters.dp_devicetype,al
endif   ;NEC_98
	jmp	short done_ret

try_t:
	or	ax,ax
	jz	done_ret		; if number entered was 0, assume default value
	test	cx,flagcyln
	jz	try_s

ifndef NEC_98
;	mov	word ptr deviceparameters.dp_cylinders,ax
else    ;NEC_98
	mov	word ptr deviceparameters.dp_cylinders,ax
endif   ;NEC_98
	jmp	short done_ret

try_s:
	test	cx,flagseclim
	jz	try_h
	mov	word ptr slim,ax
	jmp	short done_ret

; must be for number of heads

try_h:
	mov	word ptr hlim,ax

done_ret:
	clc
	ret

process_num	endp

ifdef NEC_98
;	M047 -- Begin modifications (too numerous to mark specifically)
;
;----------------------------------------------------------------------------
;
; procedure : setdeviceparameters
;
; setdeviceparameters sets up the recommended bpb in each bds in the
; system based on the form factor. it is assumed that the bpbs for the
; various form factors are present in the bpbtable. for hard files,
; the recommended bpb is the same as the bpb on the drive.
; no attempt is made to preserve registers since we are going to jump to
; sysinit straight after this routine.
;
;	if we return carry, the DRIVPARM will be aborted, but presently
;	  we always return no carry
;
;
;	note:  there is a routine by the same name in msdioctl.asm
;
;----------------------------------------------------------------------------
;

setdeviceparameters	proc	near

	push	es

	push	cs
	pop	es
	assume	es:sysinitseg

	xor	bx,bx
	mov	bl,byte ptr deviceparameters.dp_devicetype
	cmp	bl,dev_5inch
	jnz	got_80

	mov	word ptr deviceparameters.dp_cylinders,40	; 48 tpi=40 cyl

got_80:
	shl	bx,1			; get index into bpb table
	mov	si,bpbtable[bx] 	; get address of bpb

	mov	di,offset deviceparameters.dp_bpb ; es:di -> bpb
	mov	cx,size A_BPB
	cld
	repe	movsb

	pop	es
	assume es:nothing

	test	word ptr switches,flagseclim
	jz	see_heads

	mov	ax,word ptr slim
	mov	word ptr deviceparameters.dp_bpb.bpb_sectorspertrack,ax

see_heads:
	test	word ptr switches,flagheads
	jz	heads_not_altered

	mov	ax,word ptr hlim
	mov	word ptr deviceparameters.dp_bpb.bpb_heads,ax

heads_not_altered:


; set up correct media descriptor byte and sectors/cluster
;   sectors/cluster is always 2 except for any one sided disk or 1.44M

	mov	byte ptr deviceparameters.dp_bpb.bpb_sectorspercluster,2
	mov	bl,0f0h 		; get default mediabyte

;	preload the mediadescriptor from the bpb into bh for convenient access

	mov	bh,byte ptr deviceparameters.dp_bpb.bpb_mediadescriptor

	cmp	word ptr deviceparameters.dp_bpb.bpb_heads,2	; >2 heads?
	ja	got_correct_mediad	; just use default if heads>2

	jnz	only_one_head		; one head, do one head stuff

;	two head drives will use the mediadescriptor from the bpb

	mov	bl,bh			; get mediadescriptor from bpb

;	two sided drives have two special cases to look for.  One is
;	   a 320K diskette (40 tracks, 8 secs per track).  It uses
;	   a mediaid of 0fch.  The other is 1.44M, which uses only
;	   one sector/cluster.

;	any drive with 18secs/trk, 2 heads, 80 tracks, will be assumed
;	   to be a 1.44M and use only 1 sector per cluster.  Any other
;	   type of 2 headed drive is all set.

	cmp	deviceparameters.dp_bpb.bpb_sectorspertrack,18
	jnz	not_144m
	cmp	deviceparameters.dp_cylinders,80
	jnz	not_144m

;	We've got cyl=80, heads=2, secpertrack=18.  Set cluster size to 1.

	jmp	short got_one_secperclus_drive


;	check for 320K

not_144m:
	cmp	deviceparameters.dp_cylinders,40
	jnz	got_correct_mediad
	cmp	deviceparameters.dp_bpb.bpb_sectorspertrack,8
	jnz	got_correct_mediad

	mov	bl,0fch
	jmp	short got_correct_mediad


only_one_head:

;	if we don't have a 360K drive, then just go use 0f0h as media descr.

	cmp	deviceparameters.dp_devicetype,dev_5inch
	jnz	got_one_secperclus_drive

;	single sided 360K drive uses either 0fch or 0feh, depending on
;	  whether sectorspertrack is 8 or 9.  For our purposes, anything
;	  besides 8 will be considered 0fch

	mov	bl,0fch 		; single sided 9 sector media id
	cmp	word ptr deviceparameters.dp_bpb.bpb_sectorspertrack,8
	jnz	got_one_secperclus_drive ; okay if anything besides 8

	mov	bl,0feh 		; 160K mediaid

;	we've either got a one sided drive, or a 1.44M drive
;	  either case we'll use 1 sector per cluster instead of 2

got_one_secperclus_drive:
	mov	byte ptr deviceparameters.dp_bpb.bpb_sectorspercluster,1

got_correct_mediad:
	mov	byte ptr deviceparameters.dp_bpb.bpb_mediadescriptor,bl


;	 Calculate the correct number of Total Sectors on medium
;
	mov	ax,deviceparameters.dp_cylinders
	mul	word ptr deviceparameters.dp_bpb.bpb_heads
	mul	word ptr deviceparameters.dp_bpb.bpb_sectorspertrack
	mov	word ptr deviceparameters.dp_bpb.bpb_totalsectors,ax
	clc				; we currently return no errors

	ret

setdeviceparameters	endp

;	M047 -- end rewritten routine
endif   ;NEC_98
;
;----------------------------------------------------------------------------
;
; procedure : organize
;
;----------------------------------------------------------------------------
;
		assume ds:nothing, es:nothing
organize	proc	near

	mov	cx,[count]
	jcxz	nochar1
	call	mapcase
	xor	si,si
	mov	di,si
	xor	ax,ax
	mov	com_level, 0

;org1:	 call	 get			 ;skip leading control characters
;	 cmp	 al,' '
;	 jb	 org1
org1:
	call	skip_comment
	jz	end_commd_line		; found a comment string and skipped.
	call	get2			; not a comment string. then get a char.
	cmp	al, lf
	je	end_commd_line		; starts with a blank line.
	cmp	al, ' '
	jbe	org1			; skip leading control characters
	jmp	short findit

end_commd_line:
	stosb				; store line feed char in buffer for the linecount.
	mov	com_level, 0		; reset the command level.
	jmp	org1

nochar1:
	stc
	ret

findit:
	push	cx
	push	si
	push	di
	mov	bp,si
	dec	bp
	mov	si,offset comtab	;prepare to search command table
	mov	ch,0
findcom:
	mov	di,bp
	mov	cl,[si]
	inc	si
	jcxz	nocom
	repe	cmpsb
	lahf
	add	si,cx			;bump to next position without affecting flags
	sahf
	lodsb				;get indicator letter
	jnz	findcom
	cmp	byte ptr es:[di], cr	;the next char might be cr,lf
	je	gotcom0 		; such as in "rem",cr,lf case.
	cmp	byte ptr es:[di], lf
	je	gotcom0
	push	ax
	mov	al, byte ptr es:[di]	;now the next char. should be a delim.
	call	delim
	pop	ax
	jnz	findcom
gotcom0:
	pop	di
	pop	si
	pop	cx
	jmp	short gotcom

nocom:
	pop	di
	pop	si
	pop	cx
	mov	al,'Z'
	stosb				; save indicator char.
skip_line:
	call	get2
	cmp	al, lf			; skip this bad command line
	jne	skip_line
	jmp	end_commd_line		; handle next command line

gotcom: stosb				;save indicator char in buffer
	mov	cmd_indicator, al	; save it for the future use.

org2:	call	get2			;skip the commad name until delimiter
	cmp	al, lf
	je	org21
	cmp	al, cr
	je	org21

	call	delim
	jnz	org2
	jmp	short org3

org21:					;if cr or lf then
	dec	si			; undo si, cx register
	inc	cx			;  and continue

org3:
	cmp	cmd_indicator, 'Y'	; comment= command?
	je	get_cmt_token
	cmp	cmd_indicator, 'I'	; install= command?
	je	org_file
	cmp	cmd_indicator, 'D'	; device= command?
	je	org_file
	cmp	cmd_indicator, 'S'	; shell= is a special one!!!
	je	org_file
	cmp	cmd_indicator, '1'	; switches= command?
	je	org_switch

	jmp	org4

org_switch:
	call	skip_comment
	jz	end_commd_line_brdg

	call	get2
	call	org_delim
	jz	org_switch

	stosb
	jmp	org5

org_file:			; get the filename and put 0 at end,
	call	skip_comment
	jz	org_put_zero

	call	get2		; not a comment
	call	delim
	jz	org_file	; skip the possible delimeters

	stosb			; copy the first non delim char found in buffer

org_copy_file:
	call	skip_comment	; comment char in the filename?
	jz	org_put_zero	; then stop copying filename at that point

	call	get2
	cmp	al, '/' 	; a switch char? (device=filename/xxx)
	je	end_file_slash	; this will be the special case.

	stosb			; save the char. in buffer
	call	delim
	jz	end_copy_file

	cmp	al, ' '
	ja	org_copy_file	; keep copying
	jmp	short end_copy_file ; otherwise, assume end of the filename.

get_cmt_token:			; get the token. just max. 2 char.
	call	get2
	cmp	al, ' ' 	; skip white spaces or "=" char.
	je	get_cmt_token	; (we are allowing the other special
	cmp	al, tab 	;  charaters can used for comment id.
	je	get_cmt_token	;  character.)
	cmp	al, '=' 	; = is special in this case.
	je	get_cmt_token
	cmp	al, cr
	je	get_cmt_end	; cannot accept the carridge return
	cmp	al, lf
	je	get_cmt_end

	mov	cmmt1, al	; store it
	mov	cmmt, 1 	; 1 char. so far.
	call	get2
	cmp	al, ' '
	je	get_cmt_end
	cmp	al, tab
	je	get_cmt_end
	cmp	al, cr
	je	get_cmt_end
	cmp	al, lf
	je	end_commd_line_brdg

	mov	cmmt2, al
	inc	cmmt

get_cmt_end:
	call	get2
	cmp	al, lf
	jne	get_cmt_end		; skip it.

end_commd_line_brdg: jmp end_commd_line ; else jmp to end_commd_line

org_put_zero:				; make the filename in front of
	mov	byte ptr es:[di], 0	;  the comment string to be an asciiz.
	inc	di
	jmp	end_commd_line		;  (maybe null if device=/*)

end_file_slash: 			; al = "/" option char.
	mov	byte ptr es:[di],0	; make a filename an asciiz
	inc	di			; and
	stosb				; store "/" after that.
	jmp	short org5		; continue with the rest of the line

end_copy_file:
	mov	byte ptr es:[di-1], 0	; make it an asciiz and handle the next char.
	cmp	al, lf
	je	end_commd_line_brdg
	jmp	short org5

org4:					; org4 skips all delimiters after the command name except for '/'
	call	skip_comment
	jz	end_commd_line_brdg

	call	get2
	call	org_delim		; skip delimiters except '/' (mrw 4/88)
	jz	org4
	jmp	short org51

org5:					; rest of the line
	call	skip_comment		; comment?
	jz	end_commd_line_brdg
	call	get2			; not a comment.

org51:
	stosb				; copy the character
	cmp	al, '"' 		; a quote ?
	je	at_quote
	cmp	al, ' '
	ja	org5
					; M051 - Start

	cmp	cmd_indicator, 'U'	; Q: is this devicehigh
	jne	not_dh			; N: 
	cmp	al, lf			; Q: is this line feed
	je	org_dhlf		; Y: stuff a blank before the lf
	cmp	al, cr			; Q: is this a cr
	jne	org5			; N: 
	mov	byte ptr es:[di-1], ' '	; overwrite cr with blank
	stosb				; put cr after blank
	inc	[insert_blank]		; indicate that blank has been 
					; inserted
	jmp	org5
not_dh:					; M051 - End

	cmp	al, lf			; line feed?
	je	org1_brdg		; handles the next command line.
	jmp	org5			; handles next char in this line.

org_dhlf:				; M051 - Start
	cmp	[insert_blank], 1	; Q:has a blank already been inserted
	je	org1_brdg		; Y:
	mov	byte ptr es:[di-1], ' '	; overwrite lf with blank
	stosb				; put lf after blank
					; M051 - End

org1_brdg: 
	mov	[insert_blank], 0	; M051: clear blank indicator for 
					; M051: devicehigh
	jmp	org1

at_quote:
	cmp	com_level, 0
	je	up_level
	mov	com_level, 0		; reset it.
	jmp	org5

up_level:
	inc	com_level		; set it.
	jmp	org5

organize	endp

;
;----------------------------------------------------------------------------
;
; procedure : get2
;
;----------------------------------------------------------------------------
;
get2	proc	near
	jcxz	noget
	mov	al,es:[si]
	inc	si
	dec	cx
od_ret:
	ret
noget:
	pop	cx
	mov	count,di
	mov	org_count, di
	xor	si,si
	mov	chrptr,si
ng_ret:
	ret
get2	endp


;
;----------------------------------------------------------------------------
;
; procedure : skip_comment
;
;skip the commented string until lf, if current es:si-> a comment string.
;in) es:si-> sting
;	 cx -> length.
;out) zero flag not set if not found a comment string.
;	  zero flag set if found a comment string and skipped it. al will contain
;	  the line feed charater at this moment when return.
;	  ax register destroyed.
;	  if found, si, cx register adjusted accordingly.
;
;----------------------------------------------------------------------------
;
skip_comment	proc	near

	jcxz	noget		; get out of the organize routine.
	cmp	com_level, 0	; only check it if parameter level is 0.
	jne	no_commt	;  (not inside quotations)

	cmp	cmmt, 1
	jb	no_commt

	mov	al, es:[si]
	cmp	cmmt1, al
	jne	no_commt

	cmp	cmmt, 2
	jne	skip_cmmt

	mov	al, es:[si+1]
	cmp	cmmt2, al
	jne	no_commt

skip_cmmt:
	jcxz	noget		; get out of organize routine.
	mov	al, es:[si]
	inc	si
	dec	cx
	cmp	al, lf		; line feed?
	jne	skip_cmmt

no_commt:
	ret

skip_comment	endp

;
;----------------------------------------------------------------------------
;
; procedure : delim
;
;----------------------------------------------------------------------------
;
delim	proc	near
	cmp	al,'/'		; ibm will assume "/" as an delimeter.
	jz	delim_ret

	cmp	al, 0		; special case for sysinit!!!
	jz	delim_ret

org_delim:			; used by organize routine except for getting
	cmp	al,' '          ;the filename.
	jz	delim_ret
	cmp	al,9
	jz	delim_ret
	cmp	al,'='
	jz	delim_ret
	cmp	al,','
	jz	delim_ret
	cmp	al,';'
delim_ret:
	ret
delim	endp

;
;----------------------------------------------------------------------------
;
; procedure : newline
;
;  newline returns with first character of next line
;
;----------------------------------------------------------------------------
;

newline	proc	near

	call	getchr			;skip non-control characters
	jc	nl_ret
	cmp	al,lf			;look for line feed
	jnz	newline
	call	getchr
nl_ret:
	ret

newline	endp

;
;----------------------------------------------------------------------------
; 
; procedure : mapcase
;
;----------------------------------------------------------------------------
;
mapcase	proc	near
	push	cx
	push	si
	push	ds

	push	es
	pop	ds

	xor	si,si

convloop:
	lodsb

	ifdef	DBCS
	call	testkanj
	jz	normconv		; if this is not lead byte

	mov	ah,al
	lodsb				; get tail byte
	cmp	ax,DB_SPACE
	jnz	@f			; if this is not dbcs space
	mov	word ptr [si-2],'  '	; set 2 single space
@@:

	dec	cx
	jcxz	convdone		;just ignore 1/2 kanji error
	jmp	short noconv

;fall through, know al is not in 'a'-'z' range

normconv:
	endif

	cmp	al,'a'
	jb	noconv
	cmp	al,'z'
	ja	noconv
	sub	al,20h
	mov	[si-1],al
noconv:
	loop	convloop

convdone:
	pop	ds
	pop	si
	pop	cx
	ret

	ifdef	DBCS

	public	testkanj
testkanj:
	push	si
	push	ds

	push	ax
	mov	ax,6300h		; get dos dbcs vector
	int	21h
	pop	ax

bdbcs_do:

	cmp	ds:word ptr [si],0	; end of lead byte info?
	jz	bdbcs_notfound		; jump if so
	cmp	al,ds:[si]		; less than first byte character?
	jb	bdbcs_next		; jump if not
	cmp	al,ds:[si+1]		; grater than first byte character?
	ja	bdbcs_next

bdbcs_found:

	push	ax
	xor	ax,ax
	inc	ax			; reset zero flag
	pop	ax

bdbcs_exit:

	pop	ds
	pop	si
	ret

bdbcs_notfound:

	push	ax
	xor	ax,ax			; set zero flag
	pop	ax
	jmp	short bdbcs_exit

bdbcs_next:

	add	si,2			; points next lead byte table
	jmp	short bdbcs_do

	endif  ; DBCS

mapcase	endp

;
;----------------------------------------------------------------------------
;
; procedure : round
;
; round the values in memlo and memhi to paragraph boundary.
; perform bounds check.
;
;----------------------------------------------------------------------------
;

round	proc	near

	push	ax
	mov	ax,[memlo]

	call	pararound		; para round up

	add	[memhi],ax
	mov	[memlo],0
	mov	ax,memhi		; ax = new memhi
	cmp	ax,[alloclim]		; if new memhi >= alloclim, error
	jae	mem_err
	test	cs:[setdevmarkflag], for_devmark
	jz	skip_set_devmarksize
	push	es
	push	si
	mov	si, cs:[devmark_addr]
	mov	es, si
	sub	ax, si
	dec	ax
	mov	es:[devmark_size], ax	; paragraph
	and	cs:[setdevmarkflag], not_for_devmark
	pop	si
	pop	es
skip_set_devmarksize:
	pop	ax
	clc				;clear carry
	ret

mem_err:
	mov	dx,offset badmem
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badmem2
@@:
endif
	push	cs
	pop	ds
	call	print
	jmp	stall

round	endp

;
;----------------------------------------------------------------------------
;
; procedure : calldev
;
;----------------------------------------------------------------------------
;
calldev	proc	near

	mov	ds,word ptr cs:[DevEntry+2]
	add	bx,word ptr cs:[DevEntry]	;do a little relocation
	mov	ax,ds:[bx]

	push	word ptr cs:[DevEntry]
	mov	word ptr cs:[DevEntry],ax
	mov	bx,offset packet
	call	[DevEntry]
	pop	word ptr cs:[DevEntry]
	ret

calldev	endp

;
;----------------------------------------------------------------------------
;
; procedure : todigit
;
;----------------------------------------------------------------------------
;
todigit	proc	near
	sub	al,'0'
	jb	notdig
	cmp	al,9
	ja	notdig
	clc
	ret
notdig:
	stc
	ret
todigit	endp

;
;----------------------------------------------------------------------------
;
; procedure : getnum
;
; getnum parses a decimal number.
; returns it in ax, sets zero flag if ax = 0 (may be considered an
; error), if number is bad carry is set, zero is set, ax=0.
;
;----------------------------------------------------------------------------
;

getnum	proc	near

	push	bx
	xor	bx,bx			; running count is zero

b2:
	call	todigit 		; do we have a digit
	jc	badnum			; no, bomb

	xchg	ax,bx			; put total in ax
	push	bx			; save digit
	mov	bx,10			; base of arithmetic
	mul	bx			; shift by one decimal di...
	pop	bx			; get back digit
	add	al,bl			; get total
	adc	ah,0			; make that 16 bits
	jc	badnum			; too big a number

	xchg	ax,bx			; stash total

	call	getchr			;get next digit
	jc	b1			; no more characters
	cmp	al, ' ' 		; space?
	jz	b15			; then end of digits
	cmp	al, ',' 		; ',' is a seperator!!!
	jz	b15			; then end of digits.
	cmp	al, tab 		; tab
	jz	b15
	cmp	al,sepchr		; allow 0 or special separators
	jz	b15
	cmp	al,'/'			; see if another switch follows
	nop				; cas - remnant of old bad code
	nop
	jz	b15
	cmp	al,lf			; line-feed?
	jz	b15
	cmp	al,cr			; carriage return?
	jz	b15
	or	al,al			; end of line separator?
	jnz	b2			; no, try as a valid char...

b15:
	inc	count			; one more character to s...
	dec	chrptr			; back up over separator
b1:
	mov	ax,bx			; get proper count
	or	ax,ax			; clears carry, sets zero accordingly
	pop	bx
	ret
badnum:
	mov	sepchr,0
	xor	ax,ax		; set zero flag, and ax = 0
	pop	bx
	stc			; and carry set
	ret

getnum	endp

;*****************************************************************

setdoscountryinfo	proc	near

;input: es:di -> pointer to dos_country_cdpg_info
;	ds:0  -> buffer.
;	si = 0
;	ax = country id
;	dx = code page id. (if 0, then use ccsyscodepage as a default.)
;	bx = file handle
;	this routine can handle maxium 438 country_data entries.
;
;output: dos_country_cdpg_info set.
;	 carry set if any file read failure or wrong information in the file.
;	 carry set and cx = -1 if cannot find the matching country_id, codepage
;	 _id in the file.

	push	di
	push	ax
	push	dx

	xor	cx,cx
	xor	dx,dx
	mov	ax,512			;read 512 bytes
	call	readincontrolbuffer	;read the file header
	jc	setdosdata_fail

	push	es
	push	si

	push	cs
	pop	es

	mov	di,offset country_file_signature
	mov	cx,8			;length of the signature
	repz	cmpsb

	pop	si
	pop	es
	jnz	setdosdata_fail 	;signature mismatch

	add	si,18			;si -> county info type
	cmp	byte ptr ds:[si],1	;only accept type 1 (currently only 1 header type)
	jne	setdosdata_fail 	;cannot proceed. error return

	inc	si			;si -> file offset
	mov	dx,word ptr ds:[si]	;get the info file offset.
	mov	cx,word ptr ds:[si+2]
	mov	ax,6144			;read 6144 bytes.
	call	readincontrolbuffer	;read info
	jc	setdosdata_fail

	mov	cx, word ptr ds:[si]	;get the # of country, codepage combination entries
	cmp	cx, 438			;cannot handle more than 438 entries.
					;	
	ja	setdosdata_fail

	inc	si
	inc	si			;si -> entry information packet
	pop	dx			;restore code page id
	pop	ax			;restore country id
	pop	di

setdoscntry_find:			;search for desired country_id,codepage_id.
	cmp	ax, word ptr ds:[si+2]	;compare country_id
	jne	setdoscntry_next

	cmp	dx, 0			;no user specified code page ?
	je	setdoscntry_any_codepage;then no need to match code page id.
	cmp	dx, word ptr ds:[si+4]	;compare code page id
	je	setdoscntry_got_it

setdoscntry_next:
	add	si, word ptr ds:[si]	;next entry
	inc	si
	inc	si			;take a word for size of entry itself
	loop	setdoscntry_find

	mov	cx, -1			;signals that bad country id entered.
setdoscntry_fail:
	stc
	ret

setdosdata_fail:
	pop	si
	pop	cx
	pop	di
	jmp	short setdoscntry_fail

setdoscntry_any_codepage:		;use the code_page_id of the country_id found.
	mov	dx, word ptr ds:[si+4]

setdoscntry_got_it:			;found the matching entry
	mov	cs:cntrycodepage_id, dx ;save code page id for this country.
	mov	dx, word ptr ds:[si+10] ;get the file offset of country data
	mov	cx, word ptr ds:[si+12]
	mov	ax, 512 		;read 512 bytes
	call	readincontrolbuffer
	jc	setdoscntry_fail

	mov	cx, word ptr ds:[si]	;get the number of entries to handle.
	inc	si
	inc	si			;si -> first entry

setdoscntry_data:
	push	di			;es:di -> dos_country_cdpg_info
	push	cx			;save # of entry left
	push	si			;si -> current entry in control buffer

	mov	al, byte ptr ds:[si+2]	;get data entry id
	call	getcountrydestination	;get the address of destination in es:di
	jc	setdoscntry_data_next	;no matching data entry id in dos

	mov	dx, word ptr ds:[si+4]	;get offset of data
	mov	cx, word ptr ds:[si+6]
	mov	ax,4200h
	stc
	int	21h			;move pointer
	jc	setdosdata_fail

	mov	dx,512			;start of data buffer
	mov	cx,20			;read 20 bytes only. we only need to
	mov	ah,3fh			;look at the length of the data in the file.
	stc
	int	21h			;read the country.sys data
	jc	setdosdata_fail 	;read failure

	cmp	ax,cx
	jne	setdosdata_fail

	mov	dx,word ptr ds:[si+4]	;get offset of data again.
	mov	cx,word ptr ds:[si+6]
	mov	ax,4200h
	stc
	int	21h			;move pointer back again
	jc	setdosdata_fail

	push	si
	mov	si,(512+8)		;get length of the data from the file
	mov	cx,word ptr ds:[si]
	pop	si
	mov	dx,512			;start of data buffer
	add	cx,10			;signature + a word for the length itself
	mov	ah,3fh			;read the data from the file.
	stc
	int	21h
	jc	setdosdata_fail

	cmp	ax, cx
	jne	setdosdata_fail

	mov	al,byte ptr ds:[si+2]	;save data id for future use.
	mov	si,(512+8)		;si-> data buffer + id tag field
	mov	cx,word ptr ds:[si]	;get the length of the file
	inc	cx			;take care of a word for lenght of tab
	inc	cx			;itself.
	cmp	cx,(2048 - 512 - 8)	;fit into the buffer?
	ja	setdosdata_fail

	if	bugfix
	call	setdbcs_before_copy
	endif

	cmp	al, setcountryinfo	;is the data for setcountryinfo table?
	jne	setdoscntry_mov 	;no, don't worry

	push	word ptr es:[di+ccmono_ptr-cccountryinfolen]	;cannot destroy ccmono_ptr address. save them.
	push	word ptr es:[di+ccmono_ptr-cccountryinfolen+2]	;at this time di -> cccountryinfolen
	push	di			;save di

	push	ax
	mov	ax,cs:cntrycodepage_id	;do not use the code page info in country_info
	mov	ds:[si+4], ax		;use the saved one for this !!!!
	pop	ax

setdoscntry_mov:
	rep	movsb			;copy the table into dos
	cmp	al, setcountryinfo	;was the ccmono_ptr saved?
	jne	setdoscntry_data_next

	pop	di			;restore di
	pop	word ptr es:[di+ccmono_ptr-cccountryinfolen+2]	 ;restore
	pop	word ptr es:[di+ccmono_ptr-cccountryinfolen]

setdoscntry_data_next:
	pop	si			;restore control buffer pointer
	pop	cx			;restore # of entries left
	pop	di			;restore pointer to dso_country_cdpg
	add	si, word ptr ds:[si]	;try to get the next entry
	inc	si
	inc	si			;take a word of entry length itself
	dec	cx
	cmp	cx,0
	je	setdoscntry_ok
	jmp	setdoscntry_data

setdoscntry_ok:
	ret
setdoscountryinfo	endp

	if	bugfix
setdbcs_before_copy	proc	near

	cmp	al,setdbcs		; dbcs vector set?
	jnz	@f			; jump if not
	cmp	word ptr es:[di], 0	; zero byte data block?
	jz	@f			; jump if so

	push	di
	push	ax
	push	cx
	mov	cx,es:[di]		; load block length
	add	di,2			; points actual data
	xor	al,al			; fill bytes
	rep	stosb			; clear data block
	pop	cx
	pop	ax
	pop	di
@@:
	ret
setdbcs_before_copy	endp
	endif

getcountrydestination	proc	near

;get the destination address in the dos country info table.
;input: al - data id
;	es:di -> dos_country_cdpg_info
;on return:
;	es:di -> destination address of the matching data id
;	carry set if no matching data id found in dos.

	push	cx
	add	di,ccnumber_of_entries	;skip the reserved area, syscodepage etc.
	mov	cx,word ptr es:[di]	;get the number of entries
	inc	di
	inc	di			;si -> the first start entry id

getcntrydest:
	cmp	byte ptr es:[di],al
	je	getcntrydest_ok
	cmp	byte ptr es:[di],setcountryinfo ;was it setcountryinfo entry?
	je	getcntrydest_1

	add	di,5			;next data id
	jmp	short getcntrydest_loop

getcntrydest_1:
	add	di,new_country_size + 3 ;next data id
getcntrydest_loop:
	loop	getcntrydest
	stc
	jmp	short getcntrydest_exit

getcntrydest_ok:
	cmp	al,setcountryinfo	;select country info?
	jne	getcntrydest_ok1

	inc	di			;now di -> cccountryinfolen
	jmp	short getcntrydest_exit

getcntrydest_ok1:
	les	di,dword ptr es:[di+1]	;get the destination in es:di

getcntrydest_exit:
	pop	cx
	ret
getcountrydestination	endp


readincontrolbuffer	proc	near

;move file pointer to cx:dx
;read ax bytes into the control buffer. (should be less than 2 kb)
;si will be set to 0 hence ds:si points to the control buffer.
;entry:  cx,dx offset from the start of the file where the read/write pointer
;	 be moved.
;	 ax - # of bytes to read
;	 bx - file handle
;	 ds - buffer seg.
;return: the control data information is read into ds:0 - ds:0200.
;	 cx,dx value destroyed.
;	 carry set if error in reading file.

	push	ax			;# of bytes to read
	mov	ax, 4200h
	stc
	int	21h			;move pointer
	pop	cx			;# of bytes to read
	jc	ricb_exit

	xor	dx,dx			;ds:dx -> control buffer
	xor	si,si
	mov	ah,3fh			;read into the buffer
	stc
	int	21h			;should be less than 1024 bytes.

ricb_exit:
	ret
readincontrolbuffer	endp


set_country_path	proc	near

;in:  ds - sysinitseg, es - confbot, si -> start of the asciiz path string
;     dosinfo_ext, cntry_drv, cntry_root, cntry_path
;     assumes current directory is the root directory.
;out: ds:di -> full path (cntry_drv).
;     set the cntry_drv string from the country=,,path command.
;     ds, es, si value saved.

	push	si

	push	ds			;switch ds, es
	push	es
	pop	ds
	pop	es			;now ds -> confbot, es -> sysinitseg

	call	chk_drive_letter	;current ds:[si] is a drive letter?
	jc	scp_default_drv 	;no, use current default drive.

	mov	al, byte ptr ds:[si]
	inc	si
	inc	si			;si -> next char after ":"
	jmp	short scp_setdrv

scp_default_drv:
	mov	ah, 19h
	int	21h
	add	al, "A"			;convert it to a character.

scp_setdrv:
	mov	cs:cntry_drv, al	;set the drive letter.
	mov	di, offset cntry_path
	mov	al, byte ptr ds:[si]
	cmp	al, "\"
	je	scp_root_dir

	cmp	al,"/"			;let's accept "/" as an directory delim
	je	scp_root_dir

	jmp	short scp_path

scp_root_dir:
	dec	di			;di -> cntry_root
scp_path:
	call	move_asciiz		;copy it

	mov	di, offset cntry_drv
scpath_exit:

	push	ds			;switch ds, es
	push	es
	pop	ds
	pop	es			;ds, es value restored

	pop	si
	ret
set_country_path	endp


chk_drive_letter	proc	near
;check if ds:[si] is a drive letter followed by ":".
;assume that every alpha charater is already converted to upper case.
;carry set if not.

	push	ax
	cmp	byte ptr ds:[si], "A"
	jb	cdletter_no
	cmp	byte ptr ds:[si], "Z"
	ja	cdletter_no
	cmp	byte ptr ds:[si+1], ":"
	jne	cdletter_no

	jmp	short cdletter_exit

cdletter_no:
	stc

cdletter_exit:
	pop	ax
	ret
chk_drive_letter	endp


move_asciiz	proc	near
;in: ds:si -> source es:di -> target
;out: copy the string until 0.
;assumes there exists a 0.

masciiz_loop:
	movsb
	cmp	byte ptr ds:[si-1],0	;was it 0?
	jne	masciiz_loop
	ret
move_asciiz	endp

;
;	ds:dx points to string to output (asciz)
;
;	prints <badld_pre> <string> <badld_post>

badfil:
	push	cs
	pop	es

	mov	si,dx
badload:
	mov	dx,offset badld_pre	;want to print config error
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badld_pre2
@@:
endif
	mov	bx, offset crlfm

prnerr:
	push	cs
	pop	ds
	call	print

prn1:
	mov	dl,es:[si]
	or	dl,dl
	jz	prn2
	mov	ah,std_con_output
	int	21h
	inc	si
	jmp	prn1

prn2:
	mov	dx,bx
	call	print
	cmp	donotshownum,1		; suppress line number when handling command.com
	je	prnexit
	call	error_line
prnexit:
	ret

print:
        cmp     cs:bEchoConfig, 0      ; NTVDM skip print call, Jonle
        je      prnexit

	mov	ah,std_con_string_output
        int     21h

        ret

	if	noexec

; load non exe file called [ds:dx] at memory location es:bx

ldfil:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	ds
	push	bx

	xor	ax,ax			;open the file
	mov	ah,open
	stc				;in case of int 24
	int	21h
	pop	dx			;clean stack in case jump
	jc	ldret

	push	dx
	mov	bx,ax			;handle in bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	stc				;in case of int 24
	int	21h			; get file size in dx:ax
	jc	ldclsp

	or	dx,dx
	jnz	lderrp			; file >64k
	pop	dx

	push	dx
	mov	cx,es			; cx:dx is xaddr
	add	dx,ax			; add file size to xaddr
	jnc	dosize
	add	cx,1000h		; ripple carry
dosize:
	mov	ax,dx
	call	pararound
	mov	dx,ax

	add	cx,dx
	cmp	cx,[alloclim]
	jb	okld
	jmp	mem_err

okld:
	xor	cx,cx
	xor	dx,dx
	mov	ax,lseek shl 8		;reset pointer to beginning of file
	stc				;in case of int 24
	int	21h
	jc	ldclsp

	pop	dx

	push	es			;read the file in
	pop	ds			;trans addr is ds:dx

	mov	cx,0ff00h		; .com files arn't any bigger than
					; 64k-100h
	mov	ah,read
	stc				;in case of int 24
	int	21h
	jc	ldcls

	mov	si,dx			;check for exe file
	cmp	word ptr [si],"ZM"
	clc				; assume ok
	jnz	ldcls			; only know how to do .com files

	stc
	jmp	short ldcls

lderrp:
	stc
ldclsp:
	pop	dx			;clean stack
ldcls:
	pushf
	mov	ah,close		;close the file
	stc
	int	21h
	popf

ldret:	pop	ds
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
	endif

;
;  open device pointed to by dx, al has access code
;   if unable to open do a device open null device instead
;
open_dev:
	call	open_file
	jnc	open_dev3

open_dev1:
	mov	dx,offset nuldev
	call	open_file
of_ret:
	ret

open_dev3:
	mov	bx,ax			; handle from open to bx
	xor	ax,ax			; get device info
	mov	ah,ioctl
	int	21h
	test	dl,10000000b
	jnz	of_ret

	mov	ah,close
	int	21h
	jmp	open_dev1

open_file:
	mov	ah,open
	stc
	int	21h
	ret

; test int24. return back to dos with the fake user response of "fail"

int24:
	mov	al, 3			; fail the system call
	iret				; return back to dos.

include copyrigh.inc			; copyright statement

nuldev	db	"NUL",0
condev	db	"CON",0
auxdev	db	"AUX",0
prndev  db      "PRN",0
MseDev  db      "MOUSE",0               ; NTVDM for internal spc mouse




; NTVDM we use a temp file for config.sys 23-Nov-1992 Jonle
; config  db      "C:\CONFIG.SYS",0
config  db       64 dup (0)

cntry_drv   db	  "A:"
cntry_root  db	  "\"
cntry_path  db	  "COUNTRY.SYS",0
	    db	  52 dup (0)

country_file_signature db 0ffh,'COUNTRY'

cntrycodepage_id dw ?

commnd	db	"\COMMAND.COM",0
	db	51 dup (0)

pathstring db	64 dup (0)

comtab	label	byte

;            cmd len    command       cmd code
;            -------    -------       --------
;
	db	7,	"BUFFERS",	'B'
	db	5,	"BREAK",	'C'
	db	6,	"DEVICE",	'D'
	db	10,	"DEVICEHIGH",	'U'
	db	5,	"FILES",	'F'
	db	4,	"FCBS", 	'X'
	db	9,	"LASTDRIVE",	'L'
	db	10,	"MULTITRACK",	'M'
	db	8,	"DRIVPARM",	'P'
if     stacksw
	db	6,	"STACKS",	'K'
endif
	db	7,	"COUNTRY",	'Q'
	db	5,	"SHELL",	'S'
	db	7,	"INSTALL",	'I'
	db	7,	"COMMENT",	'Y'
	db	3,	"REM",		'0'
	db	8,	"SWITCHES",	'1'
        db      3,      "DOS",          'H'
        db      10,     "ECHOCONFIG",   'E'  ; NTVDM 14-Aug-1992 Jonle
        db      11,     "NTCMDPROMPT",  'T'  ; NTVDM 06-May-1993 sudeepb
        db      7,      "DOSONLY",      'O'  ; NTVDM 06-May-1993 sudeepb
	db	0

ifdef NEC_98
public deviceparameters
deviceparameters a_deviceparameters <0,dev_3inch720kb,0,80>
endif   ;NEC_98
hlim	    dw	    2
slim        dw      9

public bEchoConfig       ; NTVDM - 14-Aug-1992 Jonle
bEchoConfig db  0

public drive
drive       db  ?

public switches
switches    dw	0


ifdef NEC_98
; the following are the recommended bpbs for the media that we know of so
; far.

; 48 tpi diskettes

bpb48t	dw	512
	db	2
	dw	1
	db	2
	dw	112
	dw	2*9*40
	db	0fdh
	dw	2
	dw	9
	dw	2
	dd	0
	dd	0

; 96tpi diskettes

bpb96t	dw	512
	db	1
	dw	1
	db	2
	dw	224
	dw	2*15*80
	db	0f9h
	dw	7
	dw	15
	dw	2
	dd	0
	dd	0

; 3 1/2 inch diskette bpb

bpb35	dw	512
	db	2
	dw	1
	db	2
	dw	70h
	dw	2*9*80
	db	0f9h
	dw	3
	dw	9
	dw	2
	dd	0
	dd	0

bpb35h	dw	0200h
	db	01h
	dw	0001h
	db	02h
	dw	0e0h
	dw	0b40h
	db	0f0h
	dw	0009h
	dw	0012h
	dw	0002h
	dd	0
	dd	0

;
; m037 - BEGIN
;
bpb288	dw	0200h
	db	02h
	dw	0001h
	db	02h
	dw	240
	dw	2*36*80
	db	0f0h
	dw	0009h
	dw	36
	dw	0002h
	dd	0
	dd	0
;
; m037 - END
;
bpbtable    dw	    bpb48t		; 48tpi drives
	    dw	    bpb96t		; 96tpi drives
	    dw	    bpb35		; 3.5" drives
; the following are not supported, so default to 3.5" media layout
	    dw	    bpb35		; not used - 8" drives
	    dw	    bpb35		; not used - 8" drives
	    dw	    bpb35		; not used - hard files
	    dw	    bpb35		; not used - tape drives
	    dw	    bpb35h		; 3-1/2" 1.44mb drive
	    dw	    bpb35		; ERIMO 			m037
	    dw	    bpb288		; 2.88 MB diskette drives	m037

endif   ;NEC_98
switchlist  db	8,"FHSTDICN"	     ; preserve the positions of n and c.

; the following depend on the positions of the various letters in switchlist

;switchnum	equ 11111000b		; which switches require number

flagec35	equ 00000100b		; electrically compatible 3.5 inch disk drive
flagdrive	equ 00001000b
flagcyln	equ 00010000b
flagseclim	equ 00100000b
flagheads	equ 01000000b
flagff		equ 10000000b

sysinitseg	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\sysinit1.asm ===
page	,160
	title	bios	system initialization
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

break	macro	; dummy empty macro
	endm
	include version.inc
	include biosseg.inc
ifdef NEC_98
	include bpb.inc
	include dpb.inc
endif   ;NEC_98
	include sysvar.inc
	include curdir.inc
	include pdb.inc
	include exe.inc
	include sf.inc
	include arena.inc
	include syscall.inc
	include devsym.inc
	include ioctl.inc
	include biostruc.inc
	include dossym.inc
	include	dosmac.inc
	include	mult.inc
        include dossvc.inc
        include dbgsvc.inc
        include cmdsvc.inc
        include xmssvc.inc
        include vint.inc

Bios_Code	segment
	extrn	BCode_start:near
	extrn	BCode_end:near
	extrn	seg_reinit:far

Bios_Code	ends

	include devmark.inc
	include cputype.inc


true	equ	0ffffh
false	equ	0
cr	equ	13
lf	equ	10
tab	equ	9

;multMULT		equ	4ah
multMULTGETHMAPTR	equ	1
multMULTALLOCHMA	equ	2


ifndef NEC_98
stacksw equ     true                    ;include switchable hardware stacks
else    ;NEC_98
stacksw equ	false			;include switchable hardware stacks
endif   ;NEC_98

ifdef JAPAN
; CDS structure has 88 bytes size each drive with Real DOS
; Ichitaro ver5 checks drive type of each drive
; It should be assigned to other bit
mycds_size equ	88			; size of curdir_list_jpn.
else ; !JAPAN
mycds_size equ	71			; size of curdir_list. if it is not
					;the same, then will generate compile error.
endif ; !JAPAN

if DEBUG				; BUGBUG - Jeez, remove this!
  dossize equ	0b200h
else
  dossize equ	0a000h
endif

	if	ibmjapver
noexec	equ	   true
	else
noexec	equ	   false
	endif

;     if mycds_size <> curdirlen,then force a compilatiaon error.

ifdef JAPAN
	if	mycds_size ne curdirlen_JPN
	%out	!!! sysinit1 compilation failed. different cds size !!!
	.errne	mycds_size eq curdirlen_JPN
	endif
else
	if	mycds_size ne curdirlen
	%out	!!! sysinit1 compilation failed. different cds size !!!
	.errne	mycds_size eq curdirlen
	endif
endif

	if	not ibmjapver
	extrn	 re_init:far
	endif

	ifdef	xxTAIWANxx ; no needed to TAIWAN, gchang 06/22/94
	extrn	cdosinit:near
	endif

;---------------------------------------

Bios_Data	segment

;equates for main stack and stack initialization program

	if	stacksw

	extrn	NextStack:dword		; Win386 Instance table stuff
	extrn	IT_StackLoc:dword	;  we have to plug in so that our
	extrn	IT_StackSize:word	;  stacks can be instanced

entrysize   equ     8

mincount    equ     8
defaultcount equ    9
maxcount    equ     64

minsize     equ     32
defaultsize equ     128
maxsize     equ     512

allocbyte   equ     0
intlevel    equ     1
savedsp     equ     2
savedss     equ     4
newsp	    equ     6

free	    equ     0
allocated   equ     1
overflowed  equ     2
clobbered   equ     3






;	 external variables in ibmbio for int19h handling rouitne.

	extrn	 int19sem:byte

	irp	   aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
	extrn	 int19old&aa:dword
	endm
	endif


;---------------------------------------
; external variable defined in ibmbio module for multi-track
multrk_on equ	10000000b		;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
multrk_off1 equ 00000000b		;initial value. no "multitrack=" command entered.
multrk_off2 equ 00000001b		;user specified multitrack=off.

	extrn	multrk_flag:word
;
;SR; Win386 present flag
;
	extrn	IsWin386:BYTE
;
;SR; Added for SetFocus routine for WIN386 support
;
         extrn	V86_Crit_SetFocus:far

	extrn	xms:dword		; entry point for xms driver
	extrn	inHMA:byte		; flag meaning we're running high

	extrn	FreeHMAPtr:word
	extrn	MoveDOSIntoHMA:dword
	extrn	SysinitPresent:byte
        extrn   DemInfoFlag:byte
ifndef NEC_98
	extrn	spc_mse_int10:dword
	extrn	int29Perf:dword

	extrn	outchr:near
endif   ;NEC_98
Bios_Data       ends

ifndef NEC_98
; NTVDM 16-Sep-1992 Jonle
; Softpc Kbd, mouse, emm drivers
SpcKbdSeg  segment
        extrn   InstSpcKbd:near
        extrn   SpcKbdBeg:byte
        extrn   SpcKbdEnd:byte
	extrn	int10h_vector:near
SpcKbdSeg  ends

SpcMseSeg  segment
        extrn   InstSpcMse:near
        extrn   SpcMseBeg:byte
        extrn   SpcMseEnd:byte
SpcMseSeg  ends
endif   ;NEC_98

SpcEmmSeg  segment
        extrn   InitSpcEmm:near
        extrn   SpcEmmBeg:byte
        extrn   SpcEmmEnd:byte
	extrn	SI_end:byte
SpcEmmSeg  ends




sysinitseg segment
        assume  cs:sysinitseg, ds:nothing,es:nothing,ss:nothing

	extrn	badcom:byte
        extrn   condev:byte
	extrn	auxdev:byte
        extrn   prndev:byte
        extrn   commnd:byte
	extrn	devmark_addr:word
	extrn	setdevmarkflag:byte
	extrn	pathstring:byte

	extrn	print:near
	extrn	int24:near
	extrn	mem_err:near
	extrn	doconf:near
        extrn   multi_pass:near

	extrn	badload:near
	extrn	error_line:near

	extrn	ShrinkUMB:near
	extrn	UnlinkUMB:near					;M002
	extrn	AllocUMB:near
        extrn   toomanydrivesmsg:byte                           ; M029

ifdef	JAPAN
	extrn	badcom2:byte,toomanydrivesmsg2:byte
	extrn	IsDBCSCodePage:near
endif
ifdef NEC_98
	extrn	SI_end:byte
	extrn	deviceparameters:byte
endif   ;NEC_98

        ;NTVDM
        extrn   MseDev:byte              ; internal mouse driver name
        extrn   AllocUMBLow:near         ; mem alloc for new internal drivers
        extrn   bEchoConfig:byte
        extrn   config:byte

        public  current_dos_location
	public	device_list
	public	sysi_country
	public	memory_size
	public	default_drive
	public	buffers
	public	files
	public	num_cds
	public	sysinit
	public	cntryfilehandle
	public	command_line

	if	stacksw 		; internal stack information
	public	stack_count
	public	stack_size
	public	stack_addr
	endif

	public	dosinfo
	public	fcbs
	public	keep
	public	confbot
	public	alloclim
	public	zero
	public	sepchr
	public	count
	public	chrptr
	public	org_count
	public	bufptr
	public	memlo
	public	prmblk
	public	memhi
	public	ldoff
	public	area
	public	packet
	public	unitcount
	public	break_addr
        public  bpb_addr
	public	drivenumber
	public	config_size
	public	install_flag
	public	com_level
	public	cmmt
	public	cmmt1
	public	cmmt2
	public	cmd_indicator
	public	linecount
	public	showcount
	public	buffer_linenum
	public	donotshownum
	public	h_buffers
	public	configmsgflag
	public	do_install_exec
	public	multi_pass_id
	public	temp_bcode_seg
	public	seg_reinit_ptr

        public toomanydrivesflag			; M029

sysinit$:
	if	stacksw
.sall

;	interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - at level)
;	should follow the standard interrupt sharing scheme which has
;	a standard header structure.
;	fyi, the following shows the relations between
;	the interrupt vector and interrupt level.
; vec(hex)    2  8  9  a  b  c	d  e  70  72  73  74  76  77
; lvl(deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
;	msstack module modifies the following interrupt vectors
;	to meet the standard interrupt sharing standard;
;	  a, b, c, d, e, 72, 73, 74, 76, 77.
;	also, for interrupt level 7 and 15, the firstflag in a standard header
;	should be initialized to indicat whether this interrupt handler is
;	the first (= 80h) or not.  the firstflag entry of int77h's
;	program header is initialized in this module.
;	firstflag is only meaningful for interrupt level 7 and 15.
;

;  user specifies the number of stack elements - default = 9
;						 minimum = 8
;						 maximum = 64
;
;  intercepts asynchronous hardware interrupts only
;
;  picks a stack from pool of stacks and switches to it
;
;  calls the previously saved interrupt vector after pushing flags
;
;  on return, returns the stack to the stack pool
;


; this is a modification of stacks:
; 1. to fix a bug which was causing the program to take up too much space.
; 2. to dispense stack space from hi-mem first rather than low-mem first.
;    . clobbers the stack that got too big instead of innocent stack
;    . allows system to work if the only stack that got too big was the most
;      deeply nested one
; 3. disables nmi interrupts while setting the nmi vector.
; 4. double checks that a nested interrupt didn't get the same stack.
; 5. intercepts ints 70, 72-77 for pc-ats and other future products

		even
		dw	0	; spare field but leave these in order
stackcount	dw	0
stackat 	dw	0
stacksize	dw	0
stacks		dw	0
		dw	0

firstentry	dw	stacks
lastentry	dw	stacks+(defaultcount*entrysize)-entrysize
nextentry	dw	stacks+(defaultcount*entrysize)-entrysize


; these are the individual interrupt handlers

	assume	ds:nothing,es:nothing,ss:nothing

public	int02
public	old02
	old02	dd	0
int02	proc	far

;; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;;
;; *********************************************************************
;;
;; this is special support for the pc convertible / nmi handler
;;
;;       on the pc convertible, there is a situation where an nmi can be
;;       caused by using the "out" instructions to certain ports.  when this
;;       occurs, the pc convertible hardware *guarantees* that **nothing**
;;       can stop the nmi or interfere with getting to the nmi handler.  this
;;       includes other type of interrupts (hardware and software), and
;;       also includes other type of nmi's.  when any nmi has occured,
;;       no other interrtupt (hardware, software or nmi) can occur until
;;       the software takes specific steps to allow further interrupting.
;;
;;       for pc convertible, the situation where the nmi is generated by the
;;       "out" to a control port requires "fixing-up" and re-attempting.  in
;;       otherwords, it is actually a "restartable exception".  in this
;;       case, the software handler must be able to get to the stack in
;;       order to figure out what instruction caused the problem, where
;;       it was "out"ing to and what value it was "out"ing.  therefore,
;;       we will not switch stacks in this situation.  this situation is
;;       detected by interrogating port 62h, and checking for a bit value
;;       of 80h.  if set, *****do not switch stacks*****.
;;
;; *********************************************************************
;
;        push    ax
;        push    es
;        mov     ax,0f000h
;        mov     es,ax
;        cmp     byte ptr es:[0fffeh],mdl_convert        ;check if convertible
;        pop     es
;        jne     normal02
;
;        in      al,62h
;        test    al,80h
;        jz      normal02
;
;special02:
;        pop     ax
;        jmp     dword ptr old02
;
;normal02:
;        pop     ax
;

        call    do_int_stacks
        dw      old02

int02	endp

public	int08
public	old08
old08	dd	0
int08	proc	far
	call	do_int_stacks
	dw	old08
int08	endp

public	int09
public	old09
old09	dd	0
int09	proc	far

; keyboard interrupt must have a three byte jump, a nop and a zero byte
; as its first instruction for compatibility reasons

	ifidn	<09>,<09>
	jmp	short keyboard_lbl
	nop
	db	0
keyboard_lbl	label	near
	endif

	call	do_int_stacks
	dw	old09
int09	endp

public	int70
public	old70
old70	dd	0
int70	proc	far
	call	do_int_stacks
	dw	old70
int70	endp

	irp	a,<0a,0b,0c,0d,0e,72,73,74,76,77>
public	int&a
public	old&a
public	firstflag&a
int&a	proc	far
	jmp	short entry_int&a&_stk
old&a	dd	  0		;forward pointer
	dw	  424bh 	;compatible signature for int. sharing
firstflag&a db   0		;the firstly hooked.
	jmp	short intret_&a	;reset routine. we don't care this.
	db	7 dup (0)	;reserved for future.
entry_int&a&_stk:
	call	do_int_stacks
	dw	old&a
intret_&a:
        jmp     DOIRET
int&a	endp
        endm


ifndef NEC_98
DOCLI:
    FCLI
    ret
DOSTI:
    FSTI
    ret
DOIRET:
    FIRET
endif   ;NEC_98


;********************************************************************
;common routines

;	do interrupt stack switching.  the fake return address holds
;	  a pointer to the far-pointer of the actual interrupt
;	  service routine

do_int_stacks:
	push	ax
	push	bp
	push	es
	mov	es, cs:[stacks+2]	; get segment of stacks

	mov	bp,nextentry		; get most likely candidate
	mov	al,allocated
	xchg	es:byte ptr allocbyte[bp],al		; grab the entry
	cmp	al,free 		; still avail?
	jne	notfree02

	sub	nextentry,entrysize	; set for next interrupt

found02:
	mov	es:word ptr savedsp[bp],sp		; save sp value
	mov	es:word ptr savedss[bp],ss		; save ss also

	mov	ax,bp			; temp save of table offset


	mov	bp,es:word ptr newsp[bp]		; get new sp value
	cmp	es:[bp],ax		; check for offset into table
	jne	foundbad02

	push	bp
	mov	bp,sp
	mov	ax,8[bp]		; get offset of interrupt vector
	pop	bp

	push	es			; ss:sp = new stack
	pop	ss
	mov	sp,bp

	mov	bp,ax			; get pointer to interrupt vector
	mov	bp,cs:[bp]
	pushf				; go execute the real interrupt handler
	call	cs:dword ptr [bp]	; call the old interrupt vector

	mov	bp,sp			; retrieve the table offset for us
	mov	bp,es:[bp]		;  but leave it on the stack
	mov	ss,es:word ptr savedss[bp]		; get old stack back
	mov	sp,es:word ptr savedsp[bp]


	mov	es:byte ptr allocbyte[bp],free		; free the entry
	mov	nextentry,bp		; setup to use next time

newerror02:
	pop	es
	pop	bp			; saved on entry
	pop	ax			; saved on entry
	add	sp,2			; lose the fake return address

intret_02:
        jmp     DOIRET                  ; done with this interrupt

notfree02:
	cmp	al,allocated		; error flag
	je	findnext02		;  no, continue
	xchg	es:byte ptr allocbyte[bp],al		;  yes, restore error value

findnext02:
	call	longpath
	jmp	found02

foundbad02:
	cmp	bp,firstentry
	jc	findnext02
	mov	bp,ax			; flag this entry
	mov	es:byte ptr allocbyte[bp],clobbered
	jmp	findnext02		; keep looking
longpath:
	mov	bp,lastentry		; start with last entry in table

lploopp:
	cmp	es:byte ptr allocbyte[bp],free		; is entry free?
	jne	inuse			;  no, try next one

	mov	al,allocated
	xchg	es:byte ptr allocbyte[bp],al		; allocate entry
	cmp	al,free 		; is it still free?
	je	found			;  yes, go use it

	cmp	al,allocated		; is it other than allocated or free?
	je	inuse			;  no, check the next one

	mov	es:byte ptr allocbyte[bp],al		;  yes, put back the error state

inuse:
	cmp	bp,firstentry
	je	fatal
	sub	bp,entrysize
	jmp	lploopp

found:
	ret

fatal   proc    near

; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;
;        push    ds
;        mov     ax, 0f000h              ;look at the model byte
;        mov     ds, ax
;        cmp     ds:byte ptr [0fffeh], mdl_convert ;convertible?
;        pop     ds
;        jne     skip_nmis
;
;        mov     al,07h                          ; disable pc convertible nmis
;        out     72h,al
;
;skip_nmis:

        call    DOCLI                           ; disable and mask
	mov	al,0ffh 			;   all other ints
	out	021h,al
	out	0a1h,al

	mov	si,cs
	mov	ds,si
	mov	si,offset fatal_msg
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	si,offset fatal_msg2
@@:
endif

;SR;
;   We set all foci to this VM to issue the stack failure message
;
	push	ax
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume 	ds:Bios_Data

	test	ds:[IsWin386],1
	pop	ds
	pop	ax
	assume	ds:nothing
	jz	fatal_loop	;win386 not present, continue

	call	V86_Crit_SetFocus	;set focus to this VM
;
;SR; We do not bother about the returned status of this call.
;

fatal_loop:
	lodsb
	cmp	al,'$'
	je	fatal_done

	mov	bl,7
	mov	ah,14
	int	010h			; whoops, this enables ints
	jmp	fatal_loop

fatal_done:
	jmp	fatal_done
fatal	endp

	include msbio.cl5		;fatal stack error message
.xall
	public	endstackcode
endstackcode label  byte
	endif

sysinit:
	jmp	goinit
;
;----------------------------------------------------------------------------
;
DDHighInfo	struc
 ddhigh_CSegPtr	dd	?		; pointer to code segment to be relocated
 ddhigh_CSegLen	dw	?		; length of code segment to be relocated
 ddhigh_CallBak	dd	?		; pointer to the call back routine
DDHighInfo	ends

		public	runhigh
runhigh		db	0h


dosinfo	dd	0		; address of the DOS Sysini Variables

dos_temp_location label	dword
dosinit	dw	0
current_dos_location dw 0

device_list dd	0

sysi_country dd	0			; pointer to country table in dos

dos_segreinit	dw	0,0		; room for dword

lo_doscod_size	dw	0		; dos code size when in low mem
hi_doscod_size	dw	0		; dos code size when in HMA

def_php		dw	0


; M022--
; pointer for calling into Bios_Code for re-initializing segment values.
;  call with ax = new segment for Bios_Code.  Notice that we'll
;  call it in its temporary home, cuz seg_reinit won't get moved to
;  the new home.

seg_reinit_ptr	label dword

		dw	offset Bios_Code:seg_reinit
temp_bcode_seg	dw	Bios_Code

ifdef NEC_98
fake_floppy_drv db 0			;set to 1 if this machine
					;does not have any floppies!!!
endif   ;NEC_98

;variables for stack initialization program.

	if	stacksw
stack_count dw	    defaultcount
stack_size  dw	    defaultsize
stack_addr  dd	    0
	endif

; various default values

memory_size	dw	1
RPLMemTop	dw	0
default_drive	db	0		;initialized by ibminit.
buffers 	dw	-1		; initialized during buffer allocation
h_buffers	dw	0		; # of the heuristic buffers. initially 0.
singlebuffersize dw	?		; maximum sector size + buffer header

files	db	8			; enough files for pipe
fcbs	db	4			; performance for recycling
keep	db	0			; keep original set
ifndef NEC_98
num_cds db	1			; minimum needed is 1, so that initialization does'nt have a problem
else    ;NEC_98
num_cds db	5			; 5 net drives
endif   ;NEC_98
confbot dw	?
alloclim dw	?
DirStrng db	"A:\",0                 ; string for the root directory of a drive
command_line db 2,0,"P" 		;default command.com args
	db	125 dup (0)
zero	db	0
sepchr	db	0
linecount dw	0			;  line count in config.sys
showcount db	'     ',cr,lf,'$'	;  used to convert linecount to ascii.
buffer_linenum dw 0			; line count for "buffers=" command if entered.

ifdef NEC_98
sys_model_byte db 0ffh			;model byte used in sysinit
sys_scnd_model_byte db 0		;secondary model byte used in sysinit
endif   ;NEC_98

buf_prev_off dw 0

	if	not noexec
comexe	exec0	 <0,command_line,default_drive,zero>
	endif

;------------------------------------------------------------------
;	variables for install= command.

multi_pass_id	db	0		; parameter passed to multi_pass
					;  indicating the pass number
					; 0 - do scan for DOS=HIGH/LOW
					; 1 - load device drivers
					; 2 - was to load IFS
					;      now it is unused
					; 3 - do install=
					; >3 - nop
install_flag	dw	0

have_install_cmd equ	00000001b	; config.sys has install= commands
has_installed	equ	00000010b	; sysinit_base installed.

config_size	dw	0		; size of config.sys file. set by sysconf.asm
sysinit_base_ptr dd	0		; pointer to sysinit_base
sysinit_ptr	dd	0		; returning addr. from sysinit_base
checksum	dw	0		; used by sum_up

ldexec_fcb	db	20 dup (' ')	;big enough
ldexec_line	db	0		;# of parm characters
ldexec_start	db	' '
ldexec_parm	db	80 dup (0)

instexe exec0	<0,ldexec_line,ldexec_fcb,ldexec_fcb>

;------------------------------------------------------------------
;variables for comment=

com_level	db	0		;level of " " in command line
cmmt		db	0		;length of comment string token
cmmt1		db	0		;token
cmmt2		db	0		;token
cmd_indicator	db	?
donotshownum	db	0

;------------------------------------------------------------------
count		dw	0
org_count	dw	0
chrptr		dw	0
cntryfilehandle dw	0
old_area	dw	0
impossible_owner_size dw 0		; paragraph
;------------------------------------------------------------------

bucketptr label dword
bufptr	label	dword			;leave this stuff in order!
memlo	dw	0
prmblk	label	word
memhi	dw	0
ldoff	dw	0
area	dw	0

packet	db	24			; was 22
	db	0
	db	0			;initialize code
	dw	0
	db	8 dup (?)

unitcount	db	0
break_addr	dd	0
bpb_addr	dd	0
drivenumber	db	0
configmsgflag	dw	0		; used to control "error in config.sys line #" message

toomanydrivesflag db    0               ;>24 fixed disk partitions flag   ; M029

BCodeSeg        dw      Bios_Code




;SR;
; This is the communication block between the DOS and the BIOS. It starts at
;the SysinitPresent flag. Any other data that needs to be communicated
;to the DOS should be added after SysinitPresent. The pointer to this block
;is passed to DOS as part of the DOSINIT call.
;

BiosComBlock	dd	Bios_Data:SysinitPresent

tempstack db	80h dup (?)

goinit:

ifndef NEC_98
	cld

;; Before we installed spckbd.asm (we hook a lot of vectors there),
;; we shouldn't invoke any interrupt calls directly to bios(they will
;; go directly to ROM bios). Since we do know what exactly those ROM
;; bios(s) do, a safer manner is to issue bop to our 32 bits side.
;;	int	12h			; Get Memory in 1k
	BOP	12h
	mov	cl,6
	shl	ax,cl			;convert to 16-byte blocks(segment no.)
	mov	cx,ax
	dec	cx			; one para for an arena at end of mem
					; in case of UMBs
	mov	memory_size,cx

	push	cs
	pop	ds
	xor	si,si
	mov	di,si
else    ;NEC_98
move_myself:
	cld			; set up move
	xor	si,si
	mov	di,si

	if	msver
	mov	cx,cs:[memory_size]
	cmp	cx,1		; 1 means do scan
	jnz	noscan
	mov	cx,2048 	; start scanning at 32k boundary
	xor	bx,bx

memscan:inc	cx
	jz	setend
	mov	ds,cx
	mov	al,[bx]
	not	al
	mov	[bx],al
	cmp	al,[bx]
	not	al
	mov	[bx],al
	jz	memscan
setend:
	mov	cs:[memory_size],cx
	endif

	if	ibmver or ibmjapver
	mov	cx,cs:[memory_size]
	endif

noscan: 				; cx is mem size in para
;
;	cas -- a) if we got our memory size from the ROM, we should test it
;		  before we try to run.
;	       b) in any case, we should check for sufficient memory and give
;		  an appropriate error diagnostic if there isn't enough
;
	push	cs
	pop	ds

;	cas note:  It would be better to put dos + bios_code BELOW sysinit
;	  that way it would be easier to slide them down home in a minimal
;	  memory system after sysinit.	As it is, you need room to keep
;	  two full non-overlapping copies, since sysinit sits between the
;	  temporary home and the final one.  the problem with doing that
;	  is that sys*.asm are filled with "mov ax,cs, sub ax,11h" type stuff.

	dec	cx			; one para for an arena at end of mem
					; in case of UMBs
endif   ;NEC_98
        mov     ax, offset sysinitgrp:SI_end   ; need this much room for sysinit
	call	off_to_para
	sub	cx,ax

; we need to leave room for the DOS and for the BIOS
; code above sysinit in memory
;
	sub	cx,dossize/16		; leave this much room for DOS

	mov	ax,offset BCode_end
	call	off_to_para		; leave this much room for BIOS code
	sub	cx,ax

	mov	es,cx			; offset where sysinit will be located
        mov     cx,offset sysinitgrp:SI_end
	shr	cx,1			;divide by 2 to get words
	rep	movsw			;relocate sysinit

	push	es			; push relocated segment
	mov	ax,offset sysin
	push	ax			; push relocated entry point

	retf				; far jump to relocated sysinit


;	move the dos to its proper location

sysin:
	assume	ds:nothing,es:nothing,ss:nothing

	mov	ax, Bios_Data		; point DS to BIOS data
	mov	ds, ax

	assume	ds:Bios_Data

	mov	word ptr MoveDOSIntoHMA+2, cs	; set seg of routine to move DOS
	mov	SysinitPresent, 1	; flag that MoveDOSIntoHMA can be called

        SVC     SVC_ISDEBUG
        mov     DemInfoFlag, al

        test    al,ISDBG_DEBUGGEE
        je      @f
        SAVEREG <bx,dx,es>
        mov     bx, cs                  ; current base of BIOS
        xor     cx, cx
        mov     dx, current_dos_location; get offset of end of code
        sub     dx, bios_data           ; add in length of data segment
        REPT    4
        shl     dx, 1
        rcl     cx, 1
        endm

        mov     ax, SYMOP_LOAD SHL 8 + ID_NTIO
        SVC     SVC_DEMSYSTEMSYMBOLOP

        mov     bx, 1                   ; bugbug: Hardcoded segment number
        mov     ax, ds                  ; low segment location
        mov     es, ax                  ; relocated segment

        mov     ax, SYMOP_MOVE SHL 8 + ID_NTIO
        SVC     SVC_DEMSYSTEMSYMBOLOP

        RESTOREREG <es,dx,bx>
@@:

; first move the MSDOS.SYS image up to a harmless place
; on top of our new sysinitseg

        mov     ax,offset sysinitgrp:SI_end        ; how big is sysinitseg?
	call	off_to_para
	mov	cx,cs			; pick a buffer for msdos above us
	add	ax,cx
	mov	es,ax
	xor	si,si
	mov	di,si

	mov	ds,[current_dos_location] ; where it is (set by msinit)

	assume	ds:nothing

	mov	cx,dossize/2
	rep	movsw
	mov	[current_dos_location],es

; The DOS code is ORGed at a non-zero value to allow it to be located in
; HIMEM.  Thus, the DOS segment location must be adjusted accordingly.

	mov	ax,ds:word ptr 3	; get offset of dos
	mov	[dosinit],ax		; that's the entry point offset
	call	off_to_para		; subtract this much from segment
	sub	[current_dos_location],ax


; BIOS code is moved to the top of memory
; until it is determined whether it will be running in HIMEM or not.


; now put Bios_Code up on top of that.  Assume Bios_Code + dossize < 64k

	mov	ax,es
	add	ax,dossize/16		; get paragraph of end of dos
	mov	es,ax
	xchg	ax,temp_bcode_seg	; swap with original home of Bios_Code
	mov	ds,ax			; point to loaded image of Bios_Code

	assume	ds:nothing

	mov	si,offset BCode_start
	mov	di,si
	mov	cx,offset BCode_end
	sub	cx,si
	shr	cx,1
	rep	movsw			; move Bios_Code into place

	mov	ax,es			; tell it what segment it's in
	call	[seg_reinit_ptr]	; far call to seg_reinit in Bios_Code (M022)


;	now call dosinit while it's in its temporary home

	les	di,cs:[BiosComBlock]	; ptr to BIOS communication block
	lds	si,cs:[device_list]	; set for call to dosinit

	assume	ds:nothing, es:nothing

	mov	dx,cs:[memory_size]	; set for call to dosinit

        call    DOCLI
	mov	ax,cs
	mov	ss,ax
ifndef NEC_98
	align	2		; assembler wouldn't let me do an "and 0fffeh"
locstack label	byte		;  on the mov sp,offset locstack
	mov	sp,offset locstack	; set stack
else    ;NEC_98
;M069 start
locstack =	(offset $ - offset sysinit$) and 0FFFEh
	mov	sp, locstack		; set stack
	
;M069 - ensure no NMI window exists here
;	align	2		; assembler wouldn't let me do an "and 0fffeh"
;locstack label byte		;  on the mov sp,offset locstack
;	mov	sp,offset locstack	; set stack

endif   ;NEC_98

        call    DOSTI


; This call to DOSINIT will relocate the DOS data from its present location
; at the top of memory, to its final location in low memory just above the
; BIOS data.  It will then build important DOS data structures in low
; memory following the DOS data.  It returns (among many other things) the
; new starting address of free memory.

	call	[dos_temp_location]	; call dosinit
					;es:di -> sysinitvars_ext

	mov	[def_php],ds		; save pointer to PSP
	mov	[hi_doscod_size],ax	; size of doscode (including exepatch)
	mov	[lo_doscod_size],cx	; (not including exepatch)
	mov	[dos_segreinit],dx	; save offset of segreinit

	mov	ax,word ptr es:[di.sysi_initvars]
	mov	word ptr dosinfo,ax
	mov	ax,word ptr es:[di.sysi_initvars+2]
	mov	word ptr [dosinfo+2],ax ;set the sysvar pointer

	mov	ax,word ptr es:[di.sysi_country_tab]
	mov	word ptr [sysi_country],ax
	mov	ax,word ptr es:[di.sysi_country_tab+2]
	mov	word ptr [sysi_country+2],ax ;set the sysi_country pointer

	mov	es,[current_dos_location]	; give dos its temporary loc.
	mov	[dos_segreinit+2],es
;
	les	di,dosinfo		;es:di -> dosinfo

	clc				;get the extended memory size

;	execute the get extended memory size subfunction in the bios int 15h
;	if the function reports an error do nothing else store the extended
;	memory size reported at the appropriate location in the dosinfo buffer
;	currently pointed to by es:di.	use the offsets specified in the
;	definition of the sysinitvars struct in inc\sysvar.inc

ifndef NEC_98
	mov	ah,88h
;; IBM ps/2 90 int 15(ah = 88h) read a coms byte(0B6h) which we don't support.
;; it returns 0 on this query.
;; we issue a bop to 32bits to get the real extended memeory size
;;	int	15h			;check extended memory size
	BOP	15h
;;	jc	no_ext_memory
	mov	es:[di].sysi_ext_mem,ax ;save extended memory size
;;	or	ax, ax
else    ;NEC_98
;----------------------------------------------------------- NEC 91/05/10 -----
	push	ds
	xor	ax,ax
	mov	ds,ax
	mov	al,byte ptr ds:[401h]
	pop	ds
	shl	ax,1
	shl	ax,1
	shl	ax,1
	shl	ax,1
	shl	ax,1
	shl	ax,1
	shl	ax,1
	mov	es:[di].sysi_ext_mem,ax ;save extended memory size
endif   ;NEC_98
no_ext_memory:
	mov	ax,es:[di.sysi_maxsec]	; get the sector size
	add	ax,bufinsiz		; size of buffer header
	mov	[singlebuffersize],ax	; total size for a buffer

	SVC	SVC_DEMGETBOOTDRIVE
	mov	[default_drive],al
	mov	es:[di.sysi_boot_drive],al ; set sysi_boot_drive

; determine if 386 system...
if 1
        get_cpu_type                    ; macro to determine cpu type
        cmp     ax,2                    ; is it a 386?
        jne     not_386_system          ; no: don't mess with flag
endif

	mov	es:[di.sysi_dwmove],1
not_386_system:
	mov	al,es:[di.sysi_numio]
	mov	drivenumber,al		; save start of installable block drvs

	mov	ax,cs
	sub	ax,11h			; room for PSP we will copy shortly
	mov	cx,[singlebuffersize]	; temporary single buffer area
	shr	cx,1			
	shr	cx,1			; divide size by 16...
	shr	cx,1
	shr	cx,1			; ...to get paragraphs...
	inc	cx			; ... and round up

;	cas note:  this unorthodox paragraph rounding scheme wastes a byte if
;	  [singlebuffersize] ever happens to be zero mod 16.  Could this
;	  ever happen?  Only if the buffer overhead was zero mod 16, since
;	  it is probably safe to assume that the sector size always will be.
;
;	 mohans also found a bug in CONFIG.SYS processing where it replaces
;	  EOF's with cr,lf's, without checking for collision with [confbot].
;	  perhaps the extra byte this code guarantees is what has kept that
;	  other code from ever causing a problem???

	sub	ax,cx
	mov	[confbot],ax		; temp "unsafe" location
ifndef NEC_98
;	push	es			; preserve pointer to DOSINFO data
;	push	di

; setup and initialize the temporary buffer

;	les	di,es:[di.sysi_buf]	;get the buffer chain entry pointer
;	mov	word ptr es:[di.Dirty_Buff_Count],0
;	mov	word ptr es:[di.Buff_Queue],0
;	mov	word ptr es:[di.Buff_Queue+2],ax
;	mov	es,ax
;	xor	ax,ax
;	mov	di,ax			;es:di -> single buffer

;	mov	es:[di.buf_next],ax	;points to itself
;	mov	es:[di.buf_prev],ax	;points to itself

;	mov	word ptr es:[di.buf_id],00ffh ;free buffer,clear flag
;	mov	word ptr es:[di.buf_sector],0
;	mov	word ptr es:[di.buf_sector+2],0

;	pop	di			; restore pointer to DOSINFO data
;	pop	es
else    ;NEC_98
        push    es                      ; preserve pointer to DOSINFO data
        push    di

; setup and initialize the temporary buffer

        les     di,es:[di.sysi_buf]     ;get the buffer chain entry pointer
        mov     word ptr es:[di.Dirty_Buff_Count],0
        mov     word ptr es:[di.Buff_Queue],0
        mov     word ptr es:[di.Buff_Queue+2],ax
        mov     es,ax
        xor     ax,ax
        mov     di,ax                   ;es:di -> single buffer

        mov     es:[di.buf_next],ax     ;points to itself
        mov     es:[di.buf_prev],ax     ;points to itself

        mov     word ptr es:[di.buf_id],00ffh ;free buffer,clear flag
        mov     word ptr es:[di.buf_sector],0
        mov     word ptr es:[di.buf_sector+2],0

        pop     di                      ; restore pointer to DOSINFO data
        pop     es
endif   ;NEC_98

	push	cs
	pop	ds

	assume	ds:sysinitseg

	call	tempcds 		; set up cdss so re_init and sysinit
					;   can make disk system calls
	assume	ds:nothing		; tempcds trashes ds

	mov	ds,[def_php]		; retreive pointer to PSP returned by DOSINIT

	if	not ibmjapver
	call	re_init			; re-call the bios
	endif

        call    DOSTI                   ; ints ok
	cld				; make sure

; dosinit has set up a default "process" (php) at ds:0. we will move it out
; of the way by putting it just below sysinit at end of memory.

	mov	bx,cs
	sub	bx,10h
	mov	es,bx
	xor	si,si
	mov	di,si
	mov	cx,80h
	rep	movsw

	mov	word ptr es:[pdb_jfn_pointer + 2],es ; relocate
	mov	ah,set_current_pdb
	int	21h			; tell dos we moved it

	push	ds			; preserve DS returned by DOSINIT
	push	cs
	pop	ds			; point DS to sysinitseg

	assume	ds:sysinitseg

	; set up temp. critical error handler
	mov	dx,offset int24 	;set up int 24 handler
	mov	ax,(set_interrupt_vector shl 8) or 24h
	int	21h

        cmp     byte ptr [TooManyDrivesFlag],0  ;Q: >24 partitions? M029
        je      no_err                          ;  N: continue      M029
        mov     dx,offset TooManyDrivesMsg      ;  Y: print error message M029
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset TooManyDrivesMsg2
@@:
endif
        call	print                           ;		    M029
no_err:						;		    M029

	pop	ds			; start of free memory

	assume	ds:nothing

	mov	dl,[default_drive]
	or	dl,dl
	jz	nodrvset		; bios didn't say
	dec	dl			; a = 0
	mov	ah,set_default_drive
	int	21h			;select the disk

nodrvset:

;
; Process the CONFIG.SYS file
;

ProcessConfig:

;
; NTVDM store temp file name for config.sys, 23-Nov-1992 Jonle
;
        push    ds
        push    cs
        pop     ds
        assume  ds:sysinitseg
        mov     dx,offset config        ; ds:dx points file description
        CMDSVC  SVC_GETCONFIGSYS
        pop     ds
        assume  ds:nothing


ifndef  xxTAIWANxx

	call	doconf			;do pre-scan for dos=high/low

else	; xxTAIWANxx ; no needed to TAIWAN, gchang 06/22/94

	call	chkoemlocaldrv
	mov	cs:oemdriverinst,ax
	call	cdosinit
	push	es
	push	bx

	pop	bx
	pop	es
	call	maketempvector		;make dummy int service routine

	call	doconf			;do pre-scan for dos=high/low

	call	chklocalexist		;check if local dev drv exist
					;if not found,system halt
	call	recovercsiint		;recover csi interrupt vector
endif	; xxTAIWANxx ; no needed to TAIWAN, gchang 06/22/94



; Now, we decide what to do with the DOS code.
; It will either be relocated to low memory, above the DOS data structures,
; or else it will be located in HiMem, in which case a stub with the DOS
; code entry points will be located in low memory.  Dos_segreinit is used
; to tell the DOS data where the code has been placed, and to install the
; low memory stub if necessary.  If the DOS is going to go into HiMem, we
; must first initialize it in its present location and load the installable
; device drivers.  Then, if a HiMem driver has been located, we can actually
; relocate the DOS code into HiMem.
;

; M025 begin

	cmp	runhigh, 0		; Did user choose to run low ?
	je	dont_install_stub	; yes, don't install dos low mem stub
;
;------ user chose to load high
;


	mov	es,[current_dos_location]	; give dos its temporary loc.

	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit
	jmp	short do_multi_pass
	
;
;------ User chose to load dos low
;
dont_install_stub:

	xor	bx, bx			; M012
					;  don't use int 21 call to alloc mem

	call	MovDOSLo		; move it !


	mov	ax, 1			; dont install stub
	mov	es, current_dos_location; set_dos_final_position set it up
	call	dword ptr dos_segreinit	; inform dos about new seg


do_multi_pass:

	call	AllocFreeMem		; allocate all the free mem
					;  & update [memhi] & [area]
					; start of free memory.

; M025 end



; NTVDM
; Copy softpc keyboard driver resident code to start of free mem
; Install Softpc IVT hooks
ifndef NEC_98
        mov     al,devmark_spc
        call    setdevmark
        mov     es, cs:[devmark_addr]
        mov     word ptr es:[arena_name], 'BK'
        mov     word ptr es:[arena_name+2], 'D'

        cld
	mov	ax,[memhi]
        push    ds
        mov     cx,Bios_Data
	mov	ds,cx
	assume	ds:Bios_Data
	mov	word ptr spc_mse_int10,offset int10h_vector
	mov	word ptr spc_mse_int10+2,ax
	mov	word ptr int29Perf,offset outchr    ; sudeepb 03-Nov-1992
	mov	word ptr int29Perf+2,ds 	    ; added for int10 performance
	pop	ds
        assume  ds:nothing

        mov     es,ax           ;es dest seg. for SpcKbd
        push    es
        push    cs
        pop     ds              ;ds src seg for SpcKbd
        mov     si,offset sysinitgrp:SpcKbdBeg
        mov     cx,offset sysinitgrp:SpcKbdEnd
        sub     cx,si
        xor     di,di
        mov     [memlo],cx
        or      [setdevmarkflag],for_devmark
        call    round
        rep     movsb
        pop     ds
        call    sysinitgrp:InstSpcKbd

        ; save value of int09 for int 09 hardware stack disable
        xor     ax,ax
        mov     ds,ax
        mov     si, 09h*4
        lodsw
        mov     word ptr cs:old09, ax
        lodsw
        mov     word ptr cs:old09+2, ax

        ; save value of int08 for int 08 hardware stack disable
        mov     si, 08h*4
        lodsw
        mov     word ptr cs:old08, ax
        lodsw
        mov     word ptr cs:old08+2, ax
else    ;NEC_98
	 bop   5fh
endif   ;NEC_98


; NTVDM
; Attempt to init emm memory manager. if we have emm
; then load internal emm stub device driver.
;
        ; check if emm memory is available
        mov    ax, [memhi]
        inc    ax                              ;1 para for arena header
        mov    ds, ax                          ;expected seg for emm drv
        call   sysinitgrp:InitSpcEmm
        cmp    ax, 0
        jne    NoEmmServices

        ; fill in the arena name
        mov     al, devmark_device
        call    setdevmark
        mov     es, cs:[devmark_addr]
        mov     word ptr es:[arena_name], 'ME'
        mov     word ptr es:[arena_name+2], 'M'

        ; copy in emm stub driver code
        cld
	mov	ax,[memhi]
        mov     es,ax
        push    es                              ;save for diddling devheader
        push    cs
        pop     ds
        mov     si,offset sysinitgrp:SpcEmmBeg
        mov     cx,offset sysinitgrp:SpcEmmEnd
        sub     cx,si
        xor     di,di
        mov     [memlo],cx
        or      [setdevmarkflag],for_devmark
        call    round
        rep     movsb

        ; link in emm stub driver
        ; so apps can find emm driver
        pop     ds
        xor     si, si                          ;ds:si = device header
        les     di, cs:[dosinfo]                ;es:di = to dos info
        mov     cx,word ptr es:[di.sysi_dev]    ;dx:cx = head of list
        mov     dx,word ptr es:[di.sysi_dev+2]
        mov     word ptr es:[di.sysi_dev],si    ;set head of list in dos
        mov     word ptr es:[di.sysi_dev+2],ds
        mov     word ptr ds:[si],  cx           ;link in the driver
        mov     word ptr ds:[si+2], dx

NoEmmServices:


; Now, process config.sys some more.
; Load the device drivers and install programs
        inc     cs:multi_pass_id        ; multi_pass_id = 1
        call    multi_pass              ; load device drivers


; NTVDM
; Install Softpc Mouse driver in UMB if can else in LOW memory
; This must be done after himem.sys is loaded for umb support
;
ifndef NEC_98
        mov     cx, offset sysinitgrp:SpcMseEnd
        sub     cx, offset sysinitgrp:SpcMseBeg  ; cx,    size of SpceMse
        mov     di, offset MseDev
        push    cs
        pop     es                      ; es:di,  dest
        push    cx                      ; preserve cx
        call    AllocUMBLow
        pop     cx
        push    es                      ; save to pass to InstSpcMse

        mov     si, offset sysinitgrp:SpcMseBeg
        push    cs
        pop     ds                      ; ds:si, Source of SpcMse code
        rep     movsb

        pop     ds
        call    sysinitgrp:InstSpcMse

endif   ;NEC_98


        call    ShrinkUMB
	call	UnlinkUMB		; unlink all UMBs	;M002
	inc	cs:multi_pass_id	; multi_pass_id = 2
        call    multi_pass              ; was load ifs (now does nothing)
        call    endfile                 ; setup fcbs, files, buffers etc

;
;Reset SysinitPresent flag here. This is needed for the special fix for lying
;to device drivers. This has been moved up to this point to avoid problems
;with overlays called from installed programs
;
	mov	ax,Bios_Data
	mov	es,ax			; point ES to bios data

	assume	es:Bios_Data

	mov	es:SysinitPresent,0	; clear SysinitPresent flag

	test	install_flag,have_install_cmd ; are there install commands?
	jz	dolast			; no, no need for further processing
	inc	cs:multi_pass_id	; mult_pass_id = 3
	call	multi_pass		; execute install= commands
dolast:
	assume	es:nothing

; [area] has the segment address for the allocated memory of sysinit, confbot.
;  free the confbot area used for config.sys and sysinit itself.


; Now if DOS is supposed to run high, we actually move it into high memory
; (if HiMem manager is available).
;
; There is also this little hack for CPM style DOS calls that needs to
; be done when A20 is set...

	cmp	runhigh, 0ffh		; are we still waiting to be moved?
	jne	@f			; no, our job is over
	call	LoadDOSHiOrLo
@@:

	cmp	runhigh, 0		; are we running low
	je	@f			; yes, no CPM hack needed
ifndef NEC_98
	call	CPMHack			; make ffff:d0 same as 0:c0
endif   ;NEC_98
@@:


; We are now done with CONFIG.SYS processing

ConfigDone:
;; let NTVDM knows that we have done config.sys processing
	xor	al, al			;config.sys done
	BOP	BOP_NOTIFICATION	;
	call	AllocUMB		; allocate remaining UMBs if there are any
        mov     cs:[donotshownum],1     ; done with config.sys. do not show line number message.
	mov	es,[area]

	assume	es:nothing

	mov	ah,49h			; free allocated memory for command.com
	int	21h

	test	cs:[install_flag],has_installed ; sysinit_base installed?
	jz	skip_free_sysinitbase	; no.

;set block from the old_area with impossible_owner_size.
;this will free the unnecessary sysinit_base that had been put in memory to
;handle install= command.

	push	es
	push	bx
	mov	es,cs:[old_area]
	mov	bx,cs:[impossible_owner_size]
	mov	ah,setblock
	int	21h
	mov	ax,es
	dec	ax
	mov	es,ax			;point to arena
	mov	es:[arena_owner],8	;set impossible owner
	mov	word ptr es:[arena_name], 'DS'	; System Data
	pop	bx
	pop	es

skip_free_sysinitbase:

ifdef NEC_98
	cmp	runhigh, 0
	je	@f
;----------------------------------------------------------- NEC 91/05/10 -----
;	call	InstVDiskHeader 	; Install VDISK header (allocates some mem from DOS)
;------------------------------------------------------------------------------
@@:
endif   ;NEC_98
if	noexec
	mov	bp,ds			;save command.com segment
	push	ds
	pop	es
	mov	bx,cs
	sub	bx,10h			; point to current php
	mov	ds,bx
	xor	si,si
	mov	di,si
	mov	cx,80h
	rep	movsw			; copy it to new location for shell
	mov	word ptr es:[pdb_jfn_pointer + 2],es ; relocate
	mov	bx,es
	mov	ah,set_current_pdb
	int	21h			; tell dos we moved it
	mov	es:[pdb_parent_pid],es	;we are the root
endif ; noexec

	push	cs
	pop	ds			; point DS to sysinitseg

	assume	ds:sysinitseg

; set up the parameters for command

	mov	si,offset command_line+1

if	noexec
	mov	di,81h
else
	push	ds
	pop	es
	mov	di,si
endif

	mov	cl,-1
comtranlp:				;find length of command line
	inc	cl
	lodsb
	stosb				;copy command line in
	or	al,al
	jnz	comtranlp
	dec	di
	mov	al,cr			; cr terminate
	stosb

if	noexec
	mov	es:[80h],cl		; set up header
	mov	al,[default_drive]
	mov	es:[5ch],al
else
	mov	[command_line],cl	;count
endif

	mov	dx,offset commnd	;now pointing to file description


if	noexec
	mov	es,bp		;set load address
	mov	bx,100h
	call	dfil		;read in command
	jc	comerr
	mov	ds,bp
	mov	dx,80h
	mov	ah,set_dma	;set disk tranfer address
	int	21h
        call    DOCLI
	mov	ss,bp
	mov	sp,dx
        call    DOSTI
	xor	ax,ax		;push a word of zeros
	push	ax
	push	bp		;set high part of jump address
	mov	ax,100h
	push	ax		;set low part of jump address
	retf			;crank up command!

else ; not noexec

; we are going to open the command interpreter and size it as is done in
; ldfil.  the reason we must do this is that sysinit is in free memory.  if
; there is not enough room for the command interpreter,exec will probably
; overlay our stack and code so when it returns with an error sysinit won't be
; here to catch it.  this code is not perfect (for instance .exe command
; interpreters are possible) because it does its sizing based on the
; assumption that the file being loaded is a .com file.  it is close enough to
; correctness to be usable.

	push	dx		; save pointer to name

; first, find out where the command interpreter is going to go.

	mov	bx,0ffffh
	mov	ah,alloc
	int	21h		;get biggest piece
	mov	ah,alloc
	int	21h		; second time gets it
	jc	memerrjx	; oooops

	mov	es,ax
	mov	ah,dealloc
	int	21h		; give it right back
	mov	bp,bx

; es:0 points to block,and bp is the size of the block
;   in para.

; we will now adjust the size in bp down by the size of sysinit. we
;   need to do this because exec might get upset if some of the exec
;   data in sysinit is overlayed during the exec.

	mov	bx,[memory_size] ; get location of end of memory
	mov	ax,cs		; get location of beginning of sysinit
	sub	bx,ax		; bx is size of sysinit in para
	add	bx,11h		; add the sysinit php
	sub	bp,bx		; sub sysinit size from amount of free memory
	jc	memerrjx	; if there isn't even this much memory, give up

	mov	ax,(open shl 8)	;open the file being execed
	stc			;in case of int 24
	int	21h
	jc	comerr		; ooops

	mov	bx,ax		;handle in bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	stc			;in case of int 24
	int	21h		; get file size in dx:ax
	jc	comerr
				; convert size in dx:ax to para in ax
	add	ax,15		; round up size for conversion to para
	adc	dx,0
	call	off_to_para
	mov	cl,12
	shl	dx,cl		; low nibble of dx to high nibble
	or	ax,dx		; ax is now # of para for file
	add	ax,10h		; 100h byte php
	cmp	ax,bp		; will command fit in available mem?
	jb	okld		; jump if yes.
memerrjx:
	jmp	mem_err

okld:
	mov	ah,close
	int	21h		; close file

	pop	dx		; recover pointer to name
	push	cs		; point es to sysinitseg
	pop	es
	mov	bx,offset comexe ; point to exec block
	mov	word ptr [bx.exec0_com_line+2],cs ; set segments
	mov	word ptr [bx.exec0_5c_fcb+2],cs
	mov	word ptr [bx.exec0_6c_fcb+2],cs
	xor	ax,ax		;load and go
	mov	ah,exec
	stc			;in case of int 24
	int	21h		;go start up command
	endif

; note fall through if exec returns (an error)

comerr:
	mov	dx,offset badcom ;want to print command error
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset badcom2
@@:
endif
	extrn	badfil:near
	call	badfil
	public	stall
stall:	SVC	SVC_DEMEXITVDM		; Will Kill The VDM

;
;----------------------------------------------------------------------------
; procedure : AllocFreeMem
;
; Allocate Max memory from DOS to find out where to load DOS.
; DOS is at temporary location when this call is being made
;
; Inputs : None
; Outputs: The biggest chunk of memory is allocated (all mem at init time)
;	   [area] & [memhi] set to the para value of the start of the
;	   free memory.
;
; Uses   : AX, BX
;
;----------------------------------------------------------------------------
;
AllocFreeMem	proc	near

	assume	es:nothing, ds:nothing
	mov	bx,0ffffh
	mov	ah,alloc
	int	21h			;first time fails
	mov	ah,alloc
	int	21h			;second time gets it
	mov	[area],ax
	mov	[memhi],ax		; memhi:memlo now points to
	ret
					; start of free memory
AllocFreeMem	endp

;	start M000
	include	msbio.cl6
;	end M000

;
;----------------------------------------------------------------------------
;
; procedure : LoadDOSHiOrLo
;
;		Tries to move DOS into HMA. If it fails then loads
;		DOS into Low memory.
;
;----------------------------------------------------------------------------
;

LoadDOSHiOrLo	proc	near
	call	TryToMovDOSHi			; Try moving it into HMA (M024)
	jc	LdngLo				; If that don't work...
	ret
LdngLo:
	push	cs
	pop	ds
	mov	ah, 9
	mov	dx, offset DOSLOMSG		; inform user that we are
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f
	mov	dx, offset DOSLOMSG2
@@:
endif
	int	21h				;  loading low

	; actually move the dos, and reinitialize it.

	mov	bx, 1				; M012
						;  use int 21 alloc for mem
	call	MovDOSLo
	mov	es,[current_dos_location]	; give dos its temporary loc.
	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit

	mov	runhigh, 0			; mark that we are running lo
	ret
LoadDOSHiOrLo	endp


;
;----------------------------------------------------------------------------
;
; procedure : TryToMovDOSHi
;
;		This tries to move DOS into HMA.
;		Returns CY if it failed.
;		If it succeeds returns with carry cleared.
;
;
;----------------------------------------------------------------------------
;

		public	TryToMovDOSHi

TryToMovDOSHi	proc	near
	call	MovDOSHi
	jc	ttldhx


	mov	es,[current_dos_location]	; give dos its temporary loc.

	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit

	mov	runhigh, 1
	clc
ttldhx:
	ret
TryToMovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOSHi
;
;		Tries to allocate HMA and Move DOS/BIOS code into HMA
;
;		Returns : CY if it failed
;
;----------------------------------------------------------------------------
;

MovDOSHi	proc	near
	call	AllocHMA
	jc	mdhx				; did we get HMA?
	mov	ax, 0ffffh			; yes, HMA seg = 0ffffh
	mov	es, ax

	; actually move the BIOS and DOS

	call	MovBIOS				; First move BIOS into HMA

	; ES:DI points to free HMA after BIOS

	mov	cx, hi_doscod_size		; pass the code size of DOS
						;  when it is in HMA
	call	MovDOS				; and move it

	; ES:DI points to free HMA after DOS

	call	SaveFreeHMAPtr			; Save the Free HMA ptr
	clc
mdhx:
	ret
MovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOSLo
;
;		Allocates memory from DOS and moves BIOS/DOS code into it
;
;----------------------------------------------------------------------------
;


MovDOSLo	proc	near
	call	AllocMemForDOS			; 
	mov	es, ax				; pass the segment to MovBIOS
	call	MovBIOS
;
;------ ES:DI points memory immediately after BIOS
;
	mov	cx, lo_doscod_size		; DOS code size when loaded
						;  low
	call	MovDOS
	ret
MovDOSLo	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovBIOS
;
;		Moves BIOS code into requested segment
;
;	In : ES - segment to which BIOS is to be moved
;		  ( it moves always into offset BCode_Start)
;
;	Out : ES:DI - pointer to memory immediately after BIOS
;
;----------------------------------------------------------------------------
;


MovBIOS	proc	near
	mov	ds, temp_bcode_seg		; current BIOS code seg
	mov	si, offset BCode_Start
	mov	di, si
	mov	cx, offset BCode_End
	sub	cx, si				; size of BIOS
	shr	cx, 1				; Both the labels are para
						;  aligned
	rep	movsw
	push	es
	push	di				; save end of BIOS
	mov	ax, es
	mov	BCodeSeg, ax			; save it for later use
	call	[seg_reinit_ptr]		; far call to seg_reinit (M022)
	pop	di
	pop	es				; get back end of BIOS
	ret
MovBIOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOS
;
;		Moves DOS code into requested area
;
;	In : ES:DI - pointer to memory where DOS is  to be moved
;	     CX    - size of DOS code to be moved
;
;	Out : ES:DI - pointer to memory immediately after DOS
;
;----------------------------------------------------------------------------
;


MovDOS	proc	near
	push	es
	push	di
	lds	si, dos_temp_location		; current location of DOS
	rep	movsb
	pop	bx				; get back offset into which
						;  DOS was moved
	mov	ax, dosinit			; get the offset at which DOS
						;  wants to run
	sub	ax, bx
	call	off_to_para
	pop	bx				; get the segment at which
						;  we moved DOS into
	sub	bx, ax				; Adjust segment
	mov	current_dos_location, bx	; and save it
	ret
MovDOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : AllocMemForDOS
;
;		Allocate memory for DOS/BIOS code from DOS !!!
;
;	Out : AX - seg of allocated memoryblock
;
;----------------------------------------------------------------------------
;


AllocMemForDOS	proc	near
	mov	ax, offset BCode_end
	sub	ax, offset BCode_start		; BIOS code size
	add	ax, lo_doscod_size		; + DOS code size
	add	ax, 15
	call	off_to_para			; convert to para
	or	bx, bx				; M012
						;  can we use int 21 for alloc
	mov	bx, ax
	jz	update_arena			; M012
	mov	ah, 48h				; request DOS
	int	21h
	jc	FatalErr			; IF ERR WE ARE HOSED
	sub	ax, 3				; Take care ORG 30h of
						;  BIOS code
	mov	es, ax
	mov	word ptr es:[20h+arena_owner], 08h	; mark it as system
	mov	word ptr es:[20h+arena_name], 'CS'	;  code area
	ret

;
; M012 : BEGIN
;
update_arena:
	push	ds
	push	di
	push	cx
	push	dx
	lds	di, dosinfo			; get ptr to DOS var
	dec	di
	dec	di				; Arena head is immediately
						;  before sysvar
	mov	es, ds:[di]			; es = arena head
	mov	cx, es:[arena_size]		; cx = total low mem size
	cmp	cx, bx				; is it sufficient ?
	jb	FatalErr			; no, fatal error
	mov	dl, es:[arena_signature]
	mov	ax, es
	add	ax, bx				; ax = new arena head
	mov	ds:[di], ax			; store it in DOS data area
	mov	ds, ax
	mov	byte ptr ds:[arena_signature], dl	; type of arena
	mov	word ptr ds:[arena_owner], 0		; free
	sub	cx, bx				; size of the new block
	mov	word ptr ds:[arena_size], cx	; store it in the arena
	mov	ax, es				; return seg to the caller
	sub	ax, 3				; Take care ORG 30h of
						;  BIOS code
	pop	dx
	pop	cx
	pop	di
	pop	ds
	ret
;
; M012 : END
;
FatalErr:
	push	cs
	pop	ds
	mov	dx, offset FEMsg
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f			; if Kanji mode
	mov	dx, offset FEMsg2
@@:
endif
	mov	ah, 9h
	int	21h
        cli
	hlt
AllocMemForDOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : AllocHMA
;
;	grab_the_hma tries to enable a20 and make sure there is memory
;	  up there.  If it gets any sort of error, it will return with
;	  carry set so that we can resort to running low.
;
;	It also returns ES: -> 0ffffh if it returns success
;
;----------------------------------------------------------------------------
;

AllocHMA	proc near
	assume	ds:nothing,es:nothing
;
;	cas note:  The pre-286 check is no longer needed here since the
;		   presence of XMS is sufficient.  However, this code hasn't
;		   been deleted because it can be recycled for skipping the
;		   extra pass of CONFIG.SYS and assuming we're running low
;		   in the case of a pre-286.

;
;;	see if we're running on a pre-286.  If not, force low.
;
;	xor	ax,ax
;	pushf			; save flags (like int)
;	push	ax
;	popf
;	pushf
;	pop	ax
;	popf			; restore original flags (like int)
;	and	ax,0f000h
;	cmp	ax,0f000h	; 8088/8086?
;	jz	grab_hma_error
;
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume 	ds:Bios_Data

	call	IsXMSLoaded
	jnz	grabhma_error

	mov	ax,4310h
	int	2fh		; get the vector into es:bx
	mov	word ptr xms,bx
	mov	word ptr xms+2,es

	mov	ah,1		; request HMA
	mov	dx,0ffffh
	call	xms
	dec	ax
	jz	@f		; error if not able to allocate HMA

ifndef NEC_98
;
;------ Himem may be lying because it has allocated mem for int 15
;
	mov	ah, 88h
	int	15h
else    ;NEC_98
	push	ds
	xor	ax,ax
	mov	ds,ax
	mov	al,byte ptr ds:[401h]
	pop	ds
	shl	ax,1
	shl	ax,1
	shl	ax,1
	shl	ax,1
	shl	ax,1
	shl	ax,1
	shl	ax,1
endif   ;NEC_98
	cmp	ax, 64		; less than 64 K of hma ?
	jb	grabhma_error

@@:	mov	ah,5		; localenableA20
	call	xms
	dec	ax
	jnz	grabhma_error	; error if couldn't enable A20

	mov	ax,0ffffh
	mov	es,ax
	mov	es:word ptr 10h,1234h	; see if we can really read/write there
	cmp	es:word ptr 10h,1234h
	jnz	grabhma_error	; don't try to load there if XMS lied

	clc
	pop	ds
	ret

grabhma_error:
	stc
	pop	ds
	assume	ds:nothing
	ret

AllocHMA	endp

;
;----------------------------------------------------------------------------
;
; procedure : IsXMSLoaded
;
;             Checks whether a XMS driver is loaded
;
; Returns : Z flag set if XMS driver loaded
;           Z flag reset if no XMS drivers are present
;
;----------------------------------------------------------------------------
;
		public	IsXMSLoaded

IsXMSLoaded	proc	near
		mov	ax,4300h
		int	2fh
		cmp	al,80h		; XMS installed?
		ret
IsXMSLoaded	endp

;
;
;----------------------------------------------------------------------------
; procedure : FTryToMovDOSHi
;
;		Called from HMA suballoc calls
;	
;----------------------------------------------------------------------------
;
;

		public	FTryToMovDOSHi
FTryToMovDOSHi	proc	far

		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	ds
		push	es
		cmp	runhigh, 0ffh
		jne	@f

		call	TryToMovDOSHi
@@:
		pop	es
		pop	ds
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax

		ret
FTryToMovDOSHi	endp


ifdef NEC_98
;
;----------------------------------------------------------------------------
;
; following piece of code will be moved into a para boundary. And the para
; address posted in seg of int 19h vector. Offset of int 19h will point to
; VDint19. This is to protect HMA from apps which use VDISK header method
; to determine free extended memory.
;
; For more details read "power programming" column by Ray Duncan in the
; May 30 1989 issue of PC Magazine (pp 377-388) [USING EXTENDED MEMORY,PART 1]
;
;----------------------------------------------------------------------------
;
StartVDHead	label	byte
;
;-------------- what follows is a dummy device driver header (not used by DOS)
;
		dd	0		; link to next device driver
		dw	8000h		; device attribute
		dw	0		; strategy routine offset
		dw	0		; interrupt routine offset
		db	1		; number of units
		db	7 dup(0)	; reserved area
VDiskSig1	db	'VDISK'

VLEN1		equ	($-offset VDiskSig1)

		db	'  V3.3'	; vdisk label
		db	15 dup (0)	; pad
		dw	0		; bits 0-15 of free HMA
		db	11h		; bits 16-23 of free HMA (1M + 64K)

VDInt19:
		db	0eah		; jmp to old vector
OldVDInt19	dd	?		; Saved int 19 vector

EndVDHead	label	byte
;
;
VDiskHMAHead	db	0,0,0		; non-bootable disk
VDiskSig2	db	'VDISK'

VLEN2		equ	($-offset VDiskSig2)

		db	'3.3'		; OEM - signature
		dw	128		; number of bytes/sector
		db	1		; sectors/cluster
		dw	1		; reserved sectors
		db	1		; number of FAT copies
		dw	64		; number of root dir entries
		dw	512		; number of sectors
		db	0feh		; media descriptor
		dw	6		; number of sectors/FAT
		dw	8		; sectors per track
		dw	1		; number of heads
		dw	0		; number of hodden sectors
		dw	440h		; Start of free HMA in K (1M+64K)
EndVDiskHMAHead label	byte
;
;
;----------------------------------------------------------------------------
;
; procedure : InstVDiskHeader
;
;	      Installs the VDISK header to reserve the 64k of HMA
;	      It puts a 32 byte header at 10000:0 and
;	      another header at (seg of int19):0
;
; Inputs : None
;
; Outputs : None
;
; USES : DS,SI,AX,CX,DX
;
;----------------------------------------------------------------------------
;
		assume	ds:nothing

InstVDiskHeader proc	near

		xor	ax, ax
		mov	ds, ax			; seg of int vect table
;
;-------------- save old int 19 vector
;
		mov	ax, word ptr ds:[19h*4]
		mov	word ptr OldVDint19, ax
		mov	ax, word ptr ds:[19h*4+2]
		mov	word ptr OldVDint19+2, ax
;
;-------------- calculate seg of new int 19 handler
;
		mov	ah, 48h 		; allocate memory
		mov	bx, (offset EndVDHead - offset StartVDHead + 15) shr 4
		int	21h

;	if carry, fatal hanging error!!!!!

		dec	ax			; point to arena
		mov	es, ax
		mov	word ptr es:[arena_owner], 8	; owner = System
		mov	word ptr es:[arena_name], 'CS'	; System Code
		inc	ax
		mov	es, ax			; get back to allocated memory
;
;-------------- install new int 19 vector
;
		cli				; no reboots at this time
		mov	word ptr ds:[19h*4], (offset VDint19 - offset StartVDHead)
		mov	word ptr ds:[19h*4+2], ax
;
;-------------- move the code into proper place
;
		mov	cx, (offset EndVDHead - offset StartVDHead)
		mov	si, offset StartVDHead
		xor	di, di
		push	cs
		pop	ds
		cld
		rep	movsb
		sti				; BUGBUG is sti OK now?
;
;-------------- mov the HMA VDisk head into HMA
;
		push	di
		push	es

		mov	ax, 0ffffh
		mov	es, ax
		mov	di, 10h
		mov	cx, (offset EndVDiskHMAHead - offset VDiskHMAHead)
		mov	si, offset VDiskHMAHead
		rep	movsb			; ds already set to cs

		pop	di
		pop	es

		ret

InstVDiskHeader endp
endif   ;NEC_98
;
;----------------------------------------------------------------------------
;
; procedure : SaveFreeHMAPtr
;
;		Save the Free HMA pointer in BIOS variable for later use.
;		(INT 2f ax==4a01 call returns pointer to free HMA)
;		Normalizes the pointer to ffff:xxxx format and stores only
;		the offset.
;
; Inputs : ES:DI - pointer to free HMA
; Output : FreeHMAPtr in BIOS data segment updated
;
;----------------------------------------------------------------------------
;
SaveFreeHMAPtr	proc	near
		mov	bx, es
		mov	ax, 0ffffh		; HMA segment
		sub	ax, bx
		add	di, 15			; para round
		and	di, 0fff0h
		mov	cl, 4
		shl	ax, cl
		sub	di, ax
		push	ds
		mov	ax, Bios_Data
		mov	ds, ax
		assume	ds:Bios_Data
		mov	FreeHMAPtr, di
		mov	inHMA, 0ffh
		pop	ds
		assume	ds:nothing
		ret
SaveFreeHMAPtr	endp
ifdef NEC_98
;----------------------------------------------------------------------------
;
; procedure : IsVDiskInstalled
;
;		Checks for the presence of VDISK header at 1MB boundary
;		& INT 19 vector
;
; Inputs  : A20 flag should be ON
; Outputs : Zero set if VDISK header found else Zero cleared
;
;----------------------------------------------------------------------------
;
IsVDiskInstalled proc	near
		xor	ax, ax
		mov	ds, ax
		mov	ds, word ptr ds:[19*4+2]
		mov	si, offset VDiskSig1 - offset StartVDHead
		mov	cx, VLEN1
		push	cs
		pop	es
		mov	di, offset VDiskSig1
		rep	cmpsb
		je	@f
		mov	ax, 0ffffh
		mov	ds, ax
		mov	si, 10h+(offset VDiskSig2 - offset VDiskHMAHead)
		mov	di, offset VDiskSig2
		mov	cx, VLEN2
		rep	cmpsb
@@:
		ret			; returns the Zero flag
IsVDiskInstalled endp
endif   ;NEC_98
;
;
;----------------------------------------------------------------------------
;
; procedure : CPMHack
;
;		Copies the code from 0:c0 into ffff:0d0h
;		for CPM comatibilty
;
;----------------------------------------------------------------------------
;
CPMHack		proc	near
		push	ds
		mov	cx, 0ffffH
		mov	es, cx		; ES = FFFF
		xor	cx, cx
		mov	ds, cx		; DS = 0
		mov	si, 0c0h
		mov	di, 0d0h
		mov	cx, 5
		cld
		rep	movsb		; move 5 bytes from 0:C0 to FFFF:D0
		pop	ds
		ret
CPMHack		endp
	
;
;----------------------------------------------------------------------------
;
; procedure : off_to_para
;
;----------------------------------------------------------------------------
;

off_to_para proc near
	shr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	ret
off_to_para endp


;**	TempCDS - Create (Temporary?) CDS
;
;	ENTRY	?? BUGBUG
;		(DS) = SysInitSeg
;	EXIT	?? BUGBUG
;	USES	?? BUGBUG

	public	tempcds
Procedure TempCDS

    assume ds:sysinitseg
	les	di,dosinfo
	mov	cl,byte ptr es:[di.sysi_numio]
	xor	ch,ch			; (cx) = # of block devices
	mov	es:[di.sysi_ncds],cl	; one CDS per device
	mov	al,cl
ifdef JAPAN
	mov	ah,size curdir_list_JPN
else
	mov	ah,size curdir_list
endif
	mul	ah			; (ax) = byte size for those CDSs
	call	pararound		; (ax) = paragraph size for CDSs
	mov	si,[confbot]
;	BUGBUG - we don't update confbot - won't someone else use it?
	sub	si,ax
	mov	[alloclim],si		; can't alloc past here!
	mov	word ptr es:[di.sysi_cds + 2],si
	mov	ax,si
	mov	word ptr es:[di.sysi_cds],0	; set address of CDS list
ifdef NEC_98
	lds	si,es:[di.sysi_dpb]	; (ds:si) = address of first DPB
endif   ;NEC_98
	assume	ds:nothing
	mov	es,ax
	xor	di,di			; (es:di) = address of 1st CDS



;*	Initialize our temporary CDSs.
;
;	(cx) = count of CDSs left to process
;	(si) = 0 based drive being processed
;	(es:di) = address of next CDS

fooset:
        xor     dx,dx                   ; indicator to stop removable checks
foogo:
        mov     ax,word ptr DirStrng
	.errnz	CURDIR_TEXT		; setup the root as the curdir
	stosw
	mov	ax,word ptr DirStrng+2
	stosw
	xor	ax,ax
	push	cx
	.errnz	CURDIR_FLAGS - CURDIR_TEXT - size CURDIR_TEXT
	mov	cx,curdir_flags - 4
	rep	stosb			; zero out rest of CURDIR_TEXTs

; Here es:di points to CURDIR_FLAGS

        or      dx,dx                   ; have we found one fixed drive?
        jnz     fixed_drv2              ; NZ -> yes dont do IOCTL check

ifndef NEC_98
        cmp     byte ptr DirStrng, 'B'
        jbe     not_fixed               ; 'A' and 'B' are always removable

endif   ;NEC_98
        push    bx
        mov     bl,byte ptr DirStrng
        sub     bl,'A'
        inc     bl                      ; C is 3
        mov     ax,4408h
        int     21h                     ; Is drive removable
        pop     bx
        jc      fixed_drv               ; Could'nt find means NET hence fixed
        or      ax,ax
        jnz     fixed_drv

not_fixed:
        mov     ax,CURDIR_LOCAL OR CURDIR_INUSE
        jmp     short fill_in


fixed_drv:
        inc     dx
fixed_drv2:
        mov     ax,CURDIR_LOCAL OR CURDIR_INUSE OR CURDIR_NT_FIX

fill_in:

	FOLLOWS CURDIR_FLAGS,CURDIR_TEXT,2
	stosw				; Save Flags

	mov	ax,2
	FOLLOWS CURDIR_END,CURDIR_FLAGS,2
	stosw				; Save CURDIR_END
ifdef JAPAN
; CDS structure has 88 bytes size each drive with Real DOS
; Ichitaro ver5 checks drive type of each drive
; It should be had the same size
        add     di,size curdirJPN_reserve  ; skip until next CDS
endif ; !JAPAN

	inc	byte ptr DirStrng
	pop	cx
        loop    foogo
	mov	byte ptr DirStrng,"A"
	ret

EndProc TempCDS


;**	EndFile - Build DOS structures
;
; This procedure is called after the config.sys has been processed and
; installable device drivers have been loaded (but before "install="
; programs are loaded) to create the dos structures such as SFTs, buffers,
; FCBs, CDSs, etc.  It also loads the sysinit_base module in low memory
; to allow for the safe EXECing of "install=" programs.  All memory
; above these structures is deallocated back to DOS.
;
;	ENTRY	?? BUGBUG
;	EXIT	?? BUGBUG
;	USES	?? BUGBUG


;------------------------------------------------------------------------------
; allocate files
;------------------------------------------------------------------------------

endfile:

; we are now setting up final cdss,buffers,files,fcss strings etc.  we no
; longer need the space taken by the temp stuff below confbot,so set alloclim
; to confbot.

;	if this procedure has been called to take care of install= command,
;	    then we have to save es,si registers.

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data

	cmp	multrk_flag,multrk_off1 ;=0,multrack= command entered?
	jne	multrk_flag_done
	or	multrk_flag,multrk_on	; default will be on.
multrk_flag_done:

	pop	ds
	assume	ds:nothing

	mov	ax,[confbot]
	mov	[alloclim],ax

	push	cs
	pop	ds
	extrn	round:near
	call	round
	mov	al,[files]
	sub	al,5
	jbe	dofcbs

	push	ax
	mov	al,devmark_files
	call	setdevmark		; set devmark for sfts (files)
	pop	ax
	xor	ah,ah			; do not use cbw instruction!!!!!
					;  it does sign extend.
	mov	bx,[memlo]
	mov	dx,[memhi]
	lds	di,dosinfo		;get pointer to dos data
	lds	di,[di+sysi_sft]	;ds:bp points to sft
	mov	word ptr [di+sflink],bx
	mov	word ptr [di+sflink+2],dx ;set pointer to new sft

	push	cs
	pop	ds

	les	di,dword ptr [memlo]	;point to new sft
	mov	word ptr es:[di+sflink],-1
	mov	es:[di+sfcount],ax
	mov	bl,size sf_entry
	mul	bl			;ax = number of bytes to clear
	mov	cx,ax
	add	[memlo],ax		;allocate memory
	mov	ax,6
	add	[memlo],ax		;remember the header too
	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before the stosb
	add	di,ax
	xor	ax,ax
	rep	stosb			;clean out the stuff

;------------------------------------------------------------------------------
; allocate fcbs
;------------------------------------------------------------------------------

dofcbs:
	push	cs
	pop	ds
	call	round
	mov	al,devmark_fcbs		;='x'
	call	setdevmark
	mov	al,[fcbs]
	xor	ah,ah			; do not use cbw instruction!!!!!
					;  it does sign extend.
	mov	bx,[memlo]
	mov	dx,[memhi]
	lds	di,dosinfo		;get pointer to dos data
	assume	ds:nothing

	mov	word ptr [di+sysi_fcb],bx
	mov	word ptr [di+sysi_fcb+2],dx ;set pointer to new table
	mov	bl,cs:keep
	xor	bh,bh
	mov	[di+sysi_keep],bx

	push	cs
	pop	ds
	assume	ds:sysinitseg

	les	di,dword ptr [memlo]	;point to new table
	mov	word ptr es:[di+sflink],-1
	mov	es:[di+sfcount],ax
	mov	bl,size sf_entry
	mov	cx,ax
	mul	bl			;ax = number of bytes to clear
	add	[memlo],ax		;allocate memory
	mov	ax,size sf-2
	add	[memlo],ax		;remember the header too
	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before the stosb
	add	di,ax			;skip over header
	mov	al,"A"
fillloop:
	push	cx			; save count
	mov	cx,size sf_entry	; number of bytes to fill
	cld
	rep	stosb			; filled

	mov	word ptr es:[di-(size sf_entry)+sf_ref_count],0
	mov	word ptr es:[di-(size sf_entry)+sf_position],0
	mov	word ptr es:[di-(size sf_entry)+sf_position+2],0

	pop	cx
	loop	fillloop

;------------------------------------------------------------------------------
; allocate cdss
;------------------------------------------------------------------------------
buf1:
	call	round

	push	ax
	mov	ax,devmark_cds		;='l'
	call	setdevmark
	pop	ax

	les	di,dosinfo
        mov     cl,byte ptr es:[di.sysi_numio]

;NTVDM Ignore the lastdrive command. There exists only one cds for all
;      network drives and dos has already set sysi_numio to be
;      num real drives + 1 for all network drives 17-Aug-1992 Jonle
;
;        cmp     cl,[num_cds]
;        jae     gotncds                 ; user setting must be at least numio
;        mov     cl,[num_cds]
;gotncds:
;
	xor	ch,ch
	mov	es:[di.sysi_ncds],cl
	mov	ax,[memhi]
	mov	word ptr es:[di.sysi_cds + 2],ax
	mov	ax,[memlo]
	mov	word ptr es:[di.sysi_cds],ax
	mov	al,cl
ifdef JAPAN
	mov	ah,size curdir_list_JPN
else
	mov	ah,size curdir_list
endif
	mul	ah
	call	pararound
	add	[memhi],ax

	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before initializing
ifdef NEC_98
	lds	si,es:[di.sysi_dpb]
endif   ;NEC_98
	assume	ds:nothing
	les	di,es:[di.sysi_cds]
	call	fooset

;------------------------------------------------------------------------------
; allocate space for internal stack
;------------------------------------------------------------------------------

	if	stacksw

	push	cs
	pop	ds
	assume	ds:sysinitseg

ifdef NEC_98
	cmp	word ptr [stack_addr],-1 ;has the user entered "stacks=" command?
	je	doinstallstack		;then install as specified by the user
	cmp	[sys_scnd_model_byte],0 ;pc1,xt has the secondary model byte = 0
	jne	doinstallstack		;other model should have default stack of 9,128
	cmp	[sys_model_byte],0feh	;pc1, pc/xt or pc portable ?
	jae	skipstack
endif   ;NEC_98
doinstallstack:
	mov	ax,[stack_count]	; stack_count = 0?
	or	ax,ax			;then,stack size must be 0 too.
	jz	skipstack		;don't install stack.

;	dynamic relocation of stack code.

	call	round			;[memhi] = seg. for stack code
					;[memlo] = 0

; set devmark block into memory for mem command
; devmark_id = 's' for stack

	mov	al,devmark_stk	;='s'
	call	setdevmark

	mov	ax,[memhi]
	mov	es,ax		;es -> seg. the stack code is going to move.
	assume	es:nothing
	push	cs
	pop	ds
	xor	si,si		;!!we know that stack code is at the beginning of sysinit.
	xor	di,di
	mov	cx,offset endstackcode
	mov	[memlo],cx
	call	round		;have enough space for relocation?
	rep	movsb

	push	ds		; stick the location of the NextStack entry
	mov	ax,Bios_Data	; into the Win386 Instance Data tables
	mov	ds,ax
	assume	ds:Bios_Data
	mov	word ptr NextStack,offset nextentry
	mov	word ptr NextStack+2,es

	mov	ax,[memlo]
	mov	word ptr [stack_addr],ax ;set for stack area initialization
	mov	word ptr IT_StackLoc,ax	; pass it as Instance Data, too
	mov	ax,[memhi]	;this will be used by stack_init routine.
	mov	word ptr [stack_addr+2],ax
	mov	word ptr IT_StackLoc+2,ax

;	space for internal stack area = stack_count(entrysize + stack_size)

	mov	ax,entrysize
	add	ax,[stack_size]
	mul	[stack_count]

	mov	IT_StackSize,ax		; pass through to Instance Tables

	pop	ds			; no more need to access Instance Table
	assume	ds:nothing

	call	pararound	; convert size to pargraphs
	add	[memhi],ax
	or	[setdevmarkflag],for_devmark ;to set the devmark_size for stack by round routine.
	call	round		; check for memory error before
				; continuing
	call	stackinit	; initialize hardware stack. cs=ds=sysinitseg,es=relocated stack code & data

skipstack:
	endif

	push	cs
	pop	ds
	assume	ds:sysinitseg

	mov	al,[files]
	xor	ah,ah		; do not use cbw instruction!!!!!
				;  it does sign extend.
	mov	cx,ax
	xor	bx,bx		;close standard input
	mov	ah,close
	int	21h
;; go directly to the handle table; donot close any invalid handles
	push	si
	mov	ah, Get_Current_PDB	;
	int	21h
	les	si, es:[pdb_jfn_pointer]
	mov	bx, 2
rcclloop:
	cmp	byte ptr es:[bx][si], 0FFh	;skip invalid handle
	je	skip_the_handle
	mov	ah,close	; need output so we can print message
	int	21h		; in case we can't get new one open.
skip_the_handle:
	inc	bx
	loop	rcclloop
	pop	si

	mov	dx,offset condev
	mov	al,2
	mov	ah,open 	;open con for read/write
	stc			; set for possible int 24
	int	21h
	jnc	goaux
	call	badfil
	jmp	short goaux2

goaux:	push	ax
	mov	bx,1		;close standard output
	mov	ah,close
	int	21h
	pop	ax

	mov	bx,ax		;new device handle
	mov	ah,xdup
	int	21h		;dup to 1,stdout
	mov	ah,xdup
	int	21h		;dup to 2,stderr

goaux2: mov	dx,offset auxdev
	mov	al,2		;read/write access
	extrn	open_dev:near
	call	open_dev

	mov	dx,offset prndev
	mov	al,1		;write only
	call	open_dev

;global rearm command for shared interrupt devices attached in the system;
;shared interrupt attachment has some problem when it issues interrupt
;during a warm reboot.	once the interrupt is presented by the attachment,
;no further interrupts on that level will be presented until a global rearm
;is issued.  by the request of the system architecture group, msbio will
;issue a global rearm after every device driver is loaded.
;to issue a global rearm:	;for pc1,xt,palace
;
;			  out 02f2h,xx  ; interrupt level 2
;			  out 02f3h,xx  ; interrupt level 3
;			  out 02f4h,xx  ; interrupt level 4
;			  out 02f5h,xx  ; interrupt level 5
;			  out 02f6h,xx  ; interrupt level 6
;			  out 02f7h,xx  ; interrupt level 7
;
;	for pc at,in addition to the above commands,
;	need to handle the secondary interrupt handler
;
;			  out 06f2h,xx  ; interrupt level 10
;			  out 06f3h,xx  ; interrupt level 11
;			  out 06f4h,xx  ; interrupt level 12
;			  out 06f6h,xx  ; interrupt level 14
;			  out 06f7h,xx  ; interrupt level 15
;
;	for round-up machine
;
;			  none.

; where xx stands for any value.
;
; for your information,after naples level machine,the system service bios
; call (int 15h),function ah=0c0h returns the system configuration parameters
;
;
; Sudeepb 31-Dec-1991 Commented out for NT
if 0
	push	ax
	push	bx
	push	dx
	push	es

	mov	al,0ffh 		;reset h/w by writing to port
	mov	dx,2f2h 		;get starting address
	out	dx,al			; out 02f2h,0ffh
	inc	dx
	out	dx,al			; out 02f3h,0ffh
	inc	dx
	out	dx,al			; out 02f4h,0ffh
	inc	dx
	out	dx,al			; out 02f5h,0ffh
	inc	dx
	out	dx,al			; out 02f6h,0ffh
	inc	dx
	out	dx,al			; out 02f7h,0ffh

;sb secondary global rearm

	mov	ax,0f000h		;get machine type
	mov	es,ax
	cmp	byte ptr es:[0fffeh],0fch ;q:is it a at type machine
	je	startrearm		; *if at no need to check

	mov	ah,0c0h 		;get system configuration
	int	15h			; *
	jc	finishrearm		; *jmp if old rom

; test feature byte for secondary interrupt controller

	test	es:[bx.bios_sd_featurebyte1],scndintcontroller
	je	finishrearm		;jmp if it is there

startrearm:
	mov	al,0ffh 		;write any pattern to port
	mov	dx,6f2h 		;get starting address
	out	dx,al			;out 06f2h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f3h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f4h,0ffh
	inc	dx			;bump address
	inc	dx			;bump address
	out	dx,al			;out 06f6h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f7h,0ffh

finishrearm:
	pop	es
	pop	dx
	pop	bx
	pop	ax
endif

;    global rearm end *******************

;------------------------------------------------------------------------------
; allocate sysinit_base for install= command
;------------------------------------------------------------------------------
; sysinit_base allocation.
;   check if endfile has been called to handle install= command.

set_sysinit_base:

;--------------------------------------------------------------------------
;sysinit_base will be established in the secure area of
;lower memory when it handles the first install= command.
;sysinit_base is the place where the actual exec function will be called and
;will check sysinit module in high memory if it is damaged by the application
;program.  if sysinit module has been broken,then "memory error..." message
;is displayed by sysinit_base.
;--------------------------------------------------------------------------

	push	ax			; set devmark for mem command
	mov	ax,[memhi]
	sub	ax,[area]
	mov	[impossible_owner_size],ax ;remember the size in case.
	mov	al,devmark_inst
	call	setdevmark
	pop	ax

	mov	di,[memhi]
	mov	es,di
	assume	es:nothing
	mov	word ptr [sysinit_base_ptr+2],di ; save this entry for the next use.
	xor	di,di
	mov	word ptr [sysinit_base_ptr],di ; es:di -> destination.
	mov	si,offset sysinit_base	;ds:si -> source code to be relocated.
	mov	cx,(offset end_sysinit_base) - (offset sysinit_base)
	add	[memlo],cx
	or	cs:[setdevmarkflag],for_devmark
	call	round			; check mem error. also,readjust memhi for the next use.
	rep	movsb			; reallocate it.

	mov	word ptr [sysinit_ptr],offset sysinitptr ; returing address from
	mov	word ptr [sysinit_ptr+2],cs ;	sysinit_base back to sysinit.
	or	[install_flag],has_installed ; set the flag.

;------------------------------------------------------------------------------
; free the rest of the memory from memhi to confbot.  still from confbot to
; the top of the memory will be allocated for sysinit and config.sys if
; have_install_cmd.
;------------------------------------------------------------------------------

	call	round
	mov	bx,[memhi]
	mov	ax,[area]
	mov	[old_area],ax		; save [area]
	mov	es,ax			;calc what we needed
	sub	bx,ax
	mov	ah,setblock
	int	21h			;give the rest back

	push	es
	mov	ax,es
	dec	ax
	mov	es,ax			;point to arena
	mov	es:[arena_owner],8	;set impossible owner
	mov	word ptr es:[arena_name], 'DS'	; System Data
	pop	es

	mov	bx,0ffffh
	mov	ah,alloc
	int	21h
	mov	ah,alloc
	int	21h			; allocate the rest of the memory

	mov	[memhi],ax		; start of the allocated memory
	mov	[memlo],0		;   to be used next.

;;;; at this moment,memory from [memhi]:0 to top-of-the memory is
;;;; allocated.
;;;; to protect sysinit,confbot module (from confbot (or =alloclim at
;;;; this time) to the top-of-the memory),here we are going to
;;;; 1). "setblock" from memhi to confbot.
;;;; 2). "alloc" from confbot to the top of the memory.
;;;; 3). "free alloc memory" from memhi to confbot.

;memory allocation for sysinit,confbot module.

	mov	es,ax
	mov	bx,[confbot]
	sub	bx,ax			; confbot - memhi
	dec	bx			; make a room for the memory block id.
	dec	bx			; make sure!!!.
	mov	ah,setblock
	int	21h			; this will free (confbot to top of memory)
	mov	bx,0ffffh
	mov	ah,alloc
	int	21h
	mov	ah,alloc
	int	21h			; allocate (confbot to top of memory)
	mov	[area],ax		; save allocated memory segment.
					; need this to free this area for command.com.
	mov	es,[memhi]
	mov	ah,49h			; free allocated memory.
	int	21h			; free (memhi to confbot(=area))

endfile_ret:
	ret

; End of "EndFile" DOS structure configuration.


;-------------------------------------------------------------------------
; Do_Install_Exec
;
; This procedure is used to EXEC a program being loaded via the
; "install=" mechanism in config.sys.  It does this by setting up
; the parameters, and then jumping to sysinit_base, which has been
; setup in low memory.  When complete, sysinit_base will jump back
; up to this procedure (if sysinit remains uncorrupted by the installed
; program).

do_install_exec proc near		; now,handles install= command.

	push	si			; save si for config.sys again.

; we are going to call load/exec function.
; set es:bx to the parameter block here;;;;;;;
; set ds:dx to the asciiz string. remember that we already has 0
; after the filename. so parameter starts after that. if next
; character is a line feed (i.e. 10),then assume that the 0
; we already encountered used to be a carrage return. in this
; case,let's set the length to 0 which will be followed by
; carridge return.

; es:si -> command line in config.sys. points to the first non blank
;character after =.

	push	es
	push	ds
	pop	es
	pop	ds			; es->sysinitseg,ds->confbot seg
	assume	ds:nothing
	mov	dx,si			; ds:dx->file name,0 in config.sys image.

	xor	cx,cx
	cld
	mov	cs:ldexec_start,' '	; clear out the parm area
	mov	di,offset ldexec_parm
installfilename:			;  skip the file name
	lodsb				;  al = ds:si; si++
	cmp	al,0
	je	got_installparm
	jmp	installfilename
got_installparm:			;  copy the parameters to ldexec_parm
	lodsb
	mov	es:[di],al
	cmp	al,lf			;  line feed?
	je	done_installparm
	inc	cl			;  # of char. in the parm.
	inc	di
	jmp	got_installparm
done_installparm:
	mov	byte ptr cs:[ldexec_line],cl ;	length of the parm.
	cmp	cl,0			;if no parm,then
	jne	install_seg_set 	; let the parm area
	mov	byte ptr cs:[ldexec_start],cr ;	starts with cr.
install_seg_set:
	mov	word ptr cs:0,0		; make a null environment segment
	mov	ax,cs			; by overlap jmp instruction of sysinitseg.

;hkn; the environment pointer is made 0. so the current environment ptr.
;hkn; will be the same as pdb_environ which after dosinit is 0.

ifndef NEC_98
	mov	cs:[instexe.exec0_environ],0 ; set the environment seg.
else    ;NEC_98
	mov	cs:[instexe.exec0_environ],ax ; set the environment seg.
endif   ;NEC_98


	mov	word ptr cs:[instexe.exec0_com_line+2],ax ; set the seg.
	mov	word ptr cs:[instexe.exec0_5c_fcb+2],ax
	mov	word ptr cs:[instexe.exec0_6c_fcb+2],ax
	call	sum_up
	mov	es:checksum,ax		; save the value of the sum
	xor	ax,ax
	mov	ah,exec			; load/exec
	mov	bx,offset instexe	; es:bx -> parm block.
	push	es			; save es,ds for load/exec
	push	ds			; these registers will be restored in sysinit_base.
	jmp	cs:dword ptr sysinit_base_ptr ; jmp to sysinit_base to execute
					; load/exec function and check sum.

;j.k. this is the returning address from sysinit_base.

sysinitptr:				; returning far address from sysinit_base
	pop	si			; restore si for config.sys file.
	push	es
	push	ds
	pop	es
	pop	ds			; now ds - sysinitseg,es - confbot
	jnc	exec_exit_code


	push	si			; error in loading the file for install=.
	call	badload 		; es:si-> path,filename,0.
	pop	si
	jmp	short install_exit_ret

exec_exit_code:
	mov	ah,4dh
	int	21h
	cmp	ah,3			;only accept "stay resident" prog.
	je	install_exit_ret
	call	error_line		;inform the user

	stc

install_exit_ret:
	ret

do_install_exec endp



;**	ParaRound - Round Up length to paragraph multiple
;
;	ParaRound rounds a byte count up to a multiple of 16, then divides
;	by 16 yielding a "length in paragraphs" value.
;
;	ENTRY	(ax) = byte length
;	EXIT	(ax) = rounded up length in paragraphs
;	USES	ax, flags

Procedure ParaRound

	add	ax,15
	rcr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	ret

EndProc   ParaRound


;------------------------------------------------------------------------------
; sysinit_base module.
;
; This module is relocated by the routine EndFile to a location in low
; memory.  It is then called by SYSINIT to perform the EXEC of programs
; that are being loaded by the "install=" command.  After the EXEC call
; completes, this module performs a checksum on the SYSINIT code (at the
; top of memory) to be sure that the EXECed program did not damage it.
; If it did, then this module will print an error message and stop the
; system.  Otherwise, it returns control to SYSINIT.
;
;
;in: after relocation,
;    ax = 4b00h - load and execute the program dos function.
;    ds = confbot. segment of config.sys file image
;    es = sysinitseg. segment of sysinit module itself.
;    ds:dx = pointer to asciiz string of the path,filename to be executed.
;    es:bx = pointer to a parameter block for load.
;    SI_end (byte) - offset vaule of end of sysinit module label
;    bigsize (word) - # of word from confbot to SI_end.
;    chksum (word) - sum of every byte from confbot to SI_end in a
;			word boundary moduler form.
;    sysinit_ptr (dword ptr) - return address to sysinit module.
;
;note: sysinit should save necessary registers and when the control is back

	public	sysinit_base
sysinit_base:
	mov	word ptr cs:sysinit_base_ss,ss	; save stack
	mov	word ptr cs:sysinit_base_sp,sp
	int	21h				; load/exec dos call.
	mov	ss,word ptr cs:sysinit_base_ss	; restore stack
	mov	sp,word ptr cs:sysinit_base_sp
	pop	ds				; restore confbot seg
	pop	es				; restore sysinitseg
	jc	sysinit_base_end		; load/exec function failed.
						; at this time,i don't have to worry about
						; that sysinit module has been broken or not.
	call	sum_up				; otherwise,check if it is good.
	cmp	es:checksum,ax
	je	sysinit_base_end

;	memory broken. show "memory allocation error" message and stall.

	mov	ah,9
	push	cs
	pop	ds
ifdef	JAPAN
	call	IsDBCSCodePage
endif
	mov	dx,offset mem_alloc_err_msgx - sysinit_base
ifdef JAPAN
	jz	sb_next			; if Kanji mode
	mov	si,dx
@@:
	lodsb
	or	al,al
	jnz	@b
	mov	dx,si
sb_next:
endif
	int	21h
	jmp	$			; hang here!!!!

sysinit_base_end: jmp es:sysinit_ptr	;return back to sysinit module

sum_up:

;in:   es - sysinitseg.
;out:  ax - result
;
;remark: since this routine will only check starting from "locstack" to the end of
;	 sysinit segment,the data area, and the current stack area are not
;	 coverd.  in this sense,this check sum routine only gives a minimal
;	 gaurantee to be safe.
;
;first sum up confbot seg.

	push	ds
	mov	ax,es:confbot
	mov	ds,ax
	xor	si,si
	xor	ax,ax
	mov	cx,es:config_size	; if config_size has been broken,then this
					;whole test better fail.
	shr	cx,1			; make it a word count
	jz	sum_sys_code		; when config.sys file not exist.
sum1:
	add	ax,ds:word ptr [si]
	inc	si
	inc	si
	loop	sum1
;now,sum up sysinit module.
sum_sys_code:
ifndef NEC_98
	mov	si,offset locstack	; starting after the stack.
else    ;NEC_98
	mov	si, locstack		; starting after the stack.  M069
endif   ;NEC_98
					;  this does not cover the possible stack code!!!
        mov     cx,offset sysinitgrp:SI_end    ; SI_end is the label at the end of sysinit
	sub	cx,si			;  from after_checksum to SI_end
	shr	cx,1
sum2:
	add	ax,es:word ptr [si]
	inc	si
	inc	si
	loop	sum2
	pop	ds
	ret

sysinit_base_ss equ $-sysinit_base
	dw	?
sysinit_base_sp equ $-sysinit_base
	dw	?
mem_alloc_err_msgx:

	include msbio.cl4		; memory allocation error message

end_sysinit_base label byte

ifdef NEC_98
;-------------------------------------------------------------------------
; Set_Buffer
;
;function: set buffers in the real memory.				
;	   lastly set the memhi,memlo for the next available free address.
;
;input:    ds:bx -> buffinfo.
;	   [memhi]:[memlo = 0] = available space for the hash bucket.	
;	   singlebuffersize = buffer header size + sector size		
;
;output:   buffers Queue established.					
;	   [memhi]:[memlo] = address of the next available free space.	
;

set_buffer proc near

	assume	ds:nothing
	xor	dl, dl				; assume buffers not in HMA
	call	GetBufferAddr
	je	@f
	mov	dl, 1				; buffers in HMA
@@:
	mov	word ptr ds:[bx].Buff_Queue,di	; head of Buff Q
	mov	word ptr ds:[bx].Buff_Queue[2],es
	mov	word ptr ds:[bx.Dirty_Buff_Count],0 ;set dirty_count to 0.

	mov	ax, di
	mov	cx, [buffers]
	push	di				; remember first buffer

;	for each buffer

nxt_buff:
	call	set_buffer_info 		;set buf_link,buf_id...
	mov	di, ax
	loop	nxt_buff

	sub	di, [singlebuffersize]		; point to last buffer

	pop	cx				; get first buffer
	mov	word ptr es:[di].buf_next, cx	; last->next = first
	xchg	cx, di
	mov	word ptr es:[di].buf_prev, cx	; first->prev = last

	or	dl, dl				; In HMa ?
	jz	@f				; no
	mov	byte ptr ds:[bx].Buff_In_HMA, 1
	mov	ax, memhi			; seg of scratch buff
	mov	word ptr ds:[bx].Lo_Mem_Buff, 0 ; offset of sctarch buff is 0
	mov	word ptr ds:[bx].Lo_Mem_Buff[2], ax
	mov	ax, singlebuffersize		; size of scratch buff
	sub	ax, bufinsiz			; buff head not reqd
@@:
	add	memlo, ax
	or	[setdevmarkflag], for_devmark
	call	round
	ret
set_buffer endp

;;---------------------------------------------------------------------------
;
; procedure : GetBufferAddr
;
;		Gets the buffer address either in HMA or in Lo Mem
;
; returns in es:di the buffer adress
; returns NZ if allocated in HMA
;
;;---------------------------------------------------------------------------

GetBufferAddr	proc	near
		push	bx
		push	dx
		mov	ax, singlebuffersize
		mul	buffers
		add	ax, 15
		and	ax, not 15		; para round
		mov	bx, ax
		mov	ax, ((multMULT shl 8)+multMULTALLOCHMA)
		int	2fh
		cmp	di, 0ffffh
		jne	got_hma
		mov	di, 0			; dont xor di,di Z flag needed
		mov	es, [memhi]
got_hma:
		pop	dx
		pop	bx
		ret
GetBufferAddr	endp


set_buffer_info proc

;function: set buf_link,buf_id,buf_sector
;
;in: es:di -> buffer header to be set.
;    ax = di
;
;out:
;    above entries set.

	push	[buf_prev_off]
	pop	es:[di.buf_prev]
	mov	buf_prev_off,ax
	add	ax,[singlebuffersize]		;adjust ax
	mov	word ptr es:[di.buf_next],ax
	mov	word ptr es:[di.buf_id],00ffh	;new buffer free
	mov	word ptr es:[di.buf_sector],0	;to compensate the masm 3 bug
	mov	word ptr es:[di.buf_sector+2],0 ;to compensate the masm 3 bug
	ret
set_buffer_info endp
endif   ;NEC_98
;------------------------------------------------------------------------------
; ibmstack initialization routine.
	if	stacksw
.sall
;
;	to follow the standard interrupt sharing scheme, msstack.asm
;	has been modified.  this initialization routine also has to
;	be modified because for the interrupt level 7 and 15, firstflag
;	should be set to signal that this interrupt handler is the
;	first handler hooked to this interrupt vector.
;	we determine this by looking at the instruction pointed by
;	this vector.  if it is iret, then this handler should be the
;	first one.  in our case, only the interrupt vector 77h is the
;	interrupt level 15. (we don't hook interrupt level 7.)
;
;	the followings are mainly due to m.r.t; ptm fix of p886 12/3/86
;	some design changes are needed to the above interrupt sharing
;	method.  the above sharing scheme assumes that 1). interrupt
;	sharing is never done on levels that have bios support. 2). "phantom"
;	interrupts would only be generated on levels 7 and 15.
;	these assumptions are not true any more. we have to use the firstflag
;	for every level of interrupt.  we will set the firstflag on the following
;	conditions:
;
;	 a.	 if the cs portion of the vector is 0000, then "first"
;	 b. else if cs:ip points to valid shared header, then not "first"
;	 c. else if cs:ip points to an iret, then "first"
;	 d. else if cs:ip points to dummy, then "first"
;
;	where dummy is - the cs portion must be f000, and the ip portion must
;	be equal to the value at f000:ff01. this location is the initial value
;	from vector_table for interrupt 7, one of the preserved addresses in all
;	the bioses for all of the machines.
;
;	system design group requests bios to handle the phantom interrupts.
;
;	the "phantom" interrupt is an illegal interrupt such as an interrupt
;	produced by the bogus adapter card even without interrupt request is
;	set.  more specifically, 1). the 8259 has a feature when running in
;	edge triggered mode to latch a pulse and present the interrupt when
;	the processor indicates interrupt acknowledge (inta).  the interrupt
;	pulse was exist at the time of inta to get a "phantom" interrupt.
;	2). or, this is caused by adapter cards placing a glitch on the
;	interrupt line.
;
;	to handle those "phantom" interrupts, the main stack code will check
;	the own firstflag, and if it is not "first" (which means the forward
;	pointer points to the legal shared interrupt handler), then pass the
;	control.  if it is the first, then the following action should be
;	taken.	we don't have to implement skack logic in this case.
;
;	to implement this logic, we rather choose a simple method.
;	if ont of the above "firstflag" conditions is met, we are not
;	going to hook this interrupt vector.  the reason is if the original
;	vector points to "iret" and do nothing, we don't need
;	to implement the stack logic for it.  this will simplify implementation
;	while maintaining compatibility with the old version of dos.
;	this implies that in the main stack code, there might be a stack code
;	that will never be used, a dead code.
;
;in - cs, ds -> sysinitseg, es -> relocated stack code & data.

	page
	assume	ds:sysinitseg
stackinit	proc near

	push	ax
	push	ds
	push	es
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	push	bp

;currently es -> stack code area

	mov	ax, cs:[stack_count]		;defined in cs
	mov	es:[stackcount], ax		;defined in stack code area
	mov	ax, [stack_size]		;in cs
	mov	es:[stacksize], ax
	mov	ax, word ptr cs:[stack_addr]	; offset
	mov	word ptr es:[stacks], ax
	mov	ax, word ptr cs:[stack_addr+word] ; segment
	mov	word ptr es:[stacks+word], ax

; initialize the data fields with the parameters

; "firstentry" will always be at stacks

	mov	bp, word ptr es:stacks		; get offset of stack
	mov	es:firstentry,bp

; the stacks will always immediately follow the table entries

	mov	ax,entrysize
	mov	cx,es:stackcount
	mul	cx
	add	ax,bp
	mov	es:stackat,ax
	mov	bx,ax
	sub	bx,2

; zero the entire stack area to start with

	mov	di,es:stackat
	mov	ax,es:stacksize
	mul	cx
	mov	cx,ax
	xor	ax,ax
	push	es
	pop	ds				;ds = relocated stack code seg.
	assume	ds:nothing

;now, ds -> stack code area

	mov	es, word ptr ds:[stacks+2]	; get segment of stack area.
	cld
	rep	stosb

	mov	cx, ds:stackcount

; loop for "count" times, building a table entry
;  cs = sysinitseg, ds = relocated stack code seg , es = segment of stack space
;  cx = number of entries
;  es:bp => base of stacks - 2
;  es:bx => first table entry

buildloop:
	mov	es:byte ptr allocbyte[bp],free
	mov	es:byte ptr intlevel[bp],al	;ax = 0
	mov	es:word ptr savedsp[bp],ax
	mov	es:word ptr savedss[bp],ax
	add	bx,ds:stacksize
	mov	es:word ptr newsp[bp],bx
	mov	es:[bx],bp
	add	bp,entrysize

	loop	buildloop

	sub	bp,entrysize
	mov	ds:lastentry,bp
	mov	ds:nextentry,bp

; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;        push    ds
;        mov     ax, 0f000h                      ;look at the model byte
;        mov     ds, ax
;        cmp     ds:byte ptr [0fffeh], mdl_convert ;convertible?
;        pop     ds
;        jne     skip_disablenmis
;
;        mov     al,07h                          ; disable convertible nmis
;        out     72h,al
;
;skip_disablenmis:

	xor	ax,ax
	mov	es,ax				;es - segid of vector table at 0
	assume	es:nothing			;ds - relocated stack code segment

        call    DOCLI

        irp     aa,<02,70>

	mov	si,aa&h*4		;pass where vector is to be adjusted
	mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
	mov	bx,offset old&aa	;pass where to save original owner pointer
	mov	dx,offset int&aa	;pass where new handler is
	call	new_init_loop		;adjust the vector to new handler,
					;  saving pointer to original owner
        endm


        ; NTVDM int 08, 09, special handling 24-Jan-1993 Jonle
        ;
        ; These Ints are  usually done in the macro above with int 02,70
        ; However, we don't need stack swapping as long as no device
        ; driver has hooked it. These ints are also left alone so that
        ; softpc will know if they have been hooked by an app.

        mov     si, 09h*4
        mov     ax, word ptr es:[si+0]
        cmp     word ptr old09, ax
        jne     do_I9StkSwap
        mov     ax, word ptr es:[si+2]
        cmp     word ptr old09+2, ax
        je      skip_I9StkSwap
do_I9StkSwap:
        mov     di, offset int19old09
        mov     bx,offset old09
        mov     dx,offset int09
        call    new_init_loop
skip_I9StkSwap:

        mov     si, 08h*4
        mov     ax, word ptr es:[si+0]
        cmp     word ptr old08, ax
        jne     do_I8StkSwap
        mov     ax, word ptr es:[si+2]
        cmp     word ptr old08+2, ax
        je      skip_I8StkSwap
do_I8StkSwap:
        mov     di, offset int19old08
        mov     bx,offset old08
        mov     dx,offset int08
        call    new_init_loop
skip_I8StkSwap:


        irp     aa,<0a,0b,0c,0d,0e,72,73,74,76,77>      ;shared interrupts

	mov	si,aa&h*4		;pass where vector is to be adjusted
	push	ds			;save relocated stack code segment
	lds	bx, es:[si]		;ds:bx -> original interrupt handler
	push	ds
	pop	dx			;dx = segment value

	cmp	dx,0
	jz	int&aa&_first

	cmp	byte ptr ds:[bx],0cfh	;does vector point to an iret?
	jz	int&aa&_first

	cmp	word ptr ds:[bx.6],424bh ;magic offset (see int&aa, msstack.inc)
	jz	int&aa&_not_first

	cmp	dx,0f000h		;rom bios segment
	jnz	int&aa&_not_first

	push	es
	push	dx
	mov	dx,0f000h
	mov	es,dx
	cmp	bx,word ptr es:0ff01h
       	pop	dx
	pop	es
	jz	int&aa&_first

int&aa&_not_first:			;not the first. we are going to hook vector.
	pop	ds
	mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
	mov	bx, offset old&aa	;pass where to save original owner pointer
	mov	dx, offset int&aa	;pass where new handler is
	call	new_init_loop		;adjust the vector to new handler, saving
					;pointer to original owner.
	jmp	short int&aa&_end
int&aa&_first:				 ;the first. don't have to hook stack code.
	pop	ds
int&aa&_end:

        endm

; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;        push    ds
;        mov     ax, 0f000h              ;loook at the model byte
;        mov     ds, ax
;        cmp     ds:byte ptr [0fffeh], mdl_convert       ;pc convertible?
;        pop     ds
;        jne     skip_enablenmis
;
;        mov     al,27h                          ; enable convertible nmis
;        out     72h,al
;
; skip_enablenmis:

        call    DOSTI
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data


	mov	[int19sem],1		; indicate that int 19
					; initialization is complete

	pop	bp			; restore all
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx

	pop	es
	pop	ds
	assume	ds:sysinitseg

	pop	ax
	ret
stackinit	endp

new_init_loop proc near

;input: si=ofset into vector table of the particular int vector being adjusted
;	bx=ds:offset of oldxx, where will be saved the pointer to original owner
;	dx=ds:offset of intxx, the new interrupt handler
;	di=offset value of int19old&aa variable in bios.
;	es=zero, segid of vector table
;	ds=relocated stack code segment

	mov	ax,es:[si+0]		;remember offset in vector
	mov	word ptr ds:[bx],ax	; to original owner in ds
	mov	ax,es:[si+2]		;remember segid in vector
	mov	word ptr ds:[bx]+2,ax	; to original owner in ds

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax			;set int19oldxx value in bios for
	mov	ax,es:[si+0]		;int 19 handler
	mov	word ptr ds:[di],ax
	mov	ax,es:[si+2]
	mov	word ptr ds:[di]+2,ax
	pop	ds

	mov	word ptr es:[si+0],dx  ;set vector to point to new int handler
	mov	es:[si+2],ds
	ret
new_init_loop endp


.xall
	endif
;------------------------------------------------------------------------------
	public	setdevmark
setdevmark proc

;set the devmark for mem command.
;in: [memhi] - the address to place devmark
;    [memlo] = 0
;    al = id for devmark_id
;out: devmark established.
;     the address saved in cs:[devmark_addr]
;     [memhi] increase by 1.

	push	es
	push	cx

	mov	cx,cs:[memhi]
	mov	cs:[devmark_addr],cx
	mov	es,cx
	mov	es:[devmark_id],al
	inc	cx
	mov	es:[devmark_seg],cx

	pop	cx
	pop	es
	inc	cs:[memhi]
	ret
setdevmark endp


	ifdef	xxTAIWANxx ; no needed to TAIWAN, gchang 06/22/94

;---------------------
; entry : none
; exit : ax = 0  --> oem local driver not found
;	    = 1  --> oem local driver found
; destore : ds,es,bx,cx,dx,si,di
; description :
;  search config.sys to find oem local driver.
;  oem local driver should in \csi\driver\ directory .
;  if (found oem local driver in config.sys)
;	ax=1;
;  else
;	ax=0;
;  return;
;  ps. please see state diagram for state description.
;---------------------

chkoemlocaldrv proc near
	push	es
	push	ds
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	call	chkconfig
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ds
	pop	es
	ret
chkoemlocaldrv endp

ifndef NEC_98
config_sys db	"C:\CONFIG.SYS",0
else    ;NEC_98
config_sys db	"\CONFIG.SYS",0
endif   ;NEC_98
sizeofconfig dw 0
filehandle dw	0
workingmemptr dw 0
deviceid db	"DEVICE"
csidrvid db	"CSI\DRIVER\"
localdrvname dw 0
chkconfig proc	near
	call	preprocess
	jnc	initstate
	jmp	notfoundret

;
; processing config.sys
;
; state 0
; ds:si --> current line ( end of line is oah or 0dh )

initstate:
	mov	si,dx
state_0:
	push	cs
	pop	es
	mov	di,offset deviceid
	mov	cx,3
	repz	cmpsw
	jz	state_1
	mov	ax,0ffffh
	jmp	state_10
state_1:
	lodsb
	cmp	al,' '
	jz	state_1
	cmp	al,'='
	jz	state_2
state_10a:
	jmp	state_10
state_2:
	lodsb
	cmp	al,' '
	jz	state_2
	cmp	al,'\'
	jz	state_5
	cmp	al,'A'
	jb	state_10a
	cmp	al,'z'
	ja	state_10a
state_3:
	dec	si
	mov	cs:[localdrvname],si
	inc	si
state_4:
	lodsb
	cmp	al,':'
	jz	state_6
	jmp	state_10
state_5:
	dec	si
	mov	cs:[localdrvname],si
	inc	si
	jmp	state_7
state_6:
	lodsb
	cmp	al,'\'
	jz	state_7
	cmp	al,'c'
	jne	state_10a
	inc	si
state_7:
	mov	di,offset csidrvid
	mov	cx,11
	repz	cmpsb
	jnz	state_10a
state_8:
	lodsb
	cmp	al,'1'
	jb	state_10
	cmp	al,'z'
	ja	state_10
state_9:
tryopenlocaldrv:
	mov	dx,cs:[localdrvname]
	mov	si,dx
chknextbyte:
	lodsb
	cmp	al,0h
	jz	openfile
	cmp	al,' '
	jne	chknextbyte
	dec	si
	mov	byte ptr ds:[si],0
openfile:
	mov	ax,3d00h		; open config.sys
	stc
	int	21h
	jc	notfoundret
	mov	bx,ax			; bx = file handle
	mov	ah,3eh
	int	21h			; close local driver
	jc	notfoundret
	jmp	foundret

state_10:
	cmp	al,1ah			; look current char. == eof ?
	jz	notfoundret
	lodsb
	cmp	al,0
	jz	newlinestate
	cmp	al,1ah
	jz	notfoundret
	jmp	state_10
newlinestate:
	lodsb
	cmp	al,1ah
	jz	notfoundret
	cmp	al,0
	jz	newlinestate
	dec	si
	jmp	state_0
notfoundret:
	mov	ax,0
	jmp	freemem
foundret:
	mov	ax,1
freemem:
	push	ax
	call	freememory
	pop	ax
	ret

chkconfig endp

preprocess proc near
	push	cs
	pop	ds
	mov	dx,offset config_sys
	mov	ax,3d00h		; open config.sys
	stc
	int	21h
	jc	errorfile

; get size of config.sys

	mov	bx,ax			; bx = file handle
	mov	cs:[filehandle],bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,4202h		; move file ptr
	int	21h
	mov	cs:[sizeofconfig],ax	; ax == size of config.sys
	xor	dx,dx			; ignore more than 64k of config
	mov	ax,4200h		; mov file ptr to beginning of file
	int	21h

; allocate for config.sys

	mov	ax,cs:[sizeofconfig]
	add	ax,15			; change to para
	rcr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	add	ax,20h
	mov	bx,ax			; size of memory in para
	mov	ah,48h
	int	21h
	jc	memerr
					; ax --> free memory
	mov	cs:[workingmemptr],ax

; read config.sys

	mov	bx,cs:[filehandle]	; file handle
	mov	cx,cs:[sizeofconfig]	; byte count of reading
	xor	dx,dx
	mov	ds,ax			; ds:dx --> buffer
	mov	ah,3fh
	int	21h
	jc	errorfile

; translate to upper case

	call	transtoupper
	clc
	ret
errorfile:
memerr:
	stc
	ret
preprocess endp

; entry : ds:dx --> buffer
; exit : none
; description : translate all letter in buffer to upper type
;	ps ,don't change ds:dx

transtoupper proc near
	cld
	mov	cx,cs:[sizeofconfig]
	mov	si,dx
transnext:
	lodsb
	cmp	al,'A'
	jb	chklfcr
	cmp	al,'z'
	ja	chkcounter
	sub	al,'a'-'A'
	mov	ds:[si-1],al
	jmp	chkcounter
chklfcr:
	cmp	al,0dh
	jz	setzero
	cmp	al,0ah
	jz	setzero
	jmp	chkcounter
setzero:
	mov	al,0
	mov	ds:[si-1],al
chkcounter:
	loop	transnext
	ret
transtoupper endp

;entry : none ( free memory block ptr in [workingmem] )
;exit : none

freememory proc near
	mov	ax,cs:[workingmemptr]
	mov	es,ax
	mov	ah,49h
	int	21h
	ret
freememory endp


; name : maketempvector
; entry : es:bx -->
;		dd	original int 9 vector	  ( offfset ,segment )
;		dd	original int 10h vector   ( offfset ,segment )
;		dd	original int 16h vector   ( offfset ,segment )
;
; exit : none
; description : 1. save local driver table in static area
;		2. make temp. vector for int9 ,10h ,16h
;
oemdriverinst dw 0
orgvectblptr dd 0

	db	0eah
dummyint9 dd	0
	db	0eah
dummyint10h dd	0
	db	0eah
dummyint16h dd	0

csiint9 dd	0
csiint10h dd	0
csiint16h dd	0

maketempvector proc near
	push	ds
	push	ax
	push	di
	push	si
	push	cx

; save table ptr

	mov	word ptr cs:[orgvectblptr],bx
	mov	word ptr cs:[orgvectblptr+2],es
	cmp	cs:oemdriverinst,0
	jnz	ignoreint9

; make temp. vector for int 9 ,

	mov	bx,9			; int #
	push	cs
	pop	es
	mov	di,offset csiint9	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint9	; ds:si --> dummy int service
	call	dummyvector

ignoreint9:

; make temp. vector for int 10h

	mov	bx,10h			; int #
	push	cs
	pop	es
	mov	di,offset csiint10h	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint10h	; ds:si --> dummy int service
	call	dummyvector

; make temp. vector for  int 16h

	mov	bx,16h			; int #
	push	cs
	pop	es
	mov	di,offset csiint16h	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint16h	; ds:si --> dummy int service
	call	dummyvector
	pop	cx
	pop	si
	pop	di
	pop	ax
	pop	ds
	ret


maketempvector endp

;name	: dummyvector
; entey : ds:si --> dummy int sevice routine
;	  es:di --> point to  csi vector store area
;	  bx  == int number
; exit : none
; description :
;		setting dummy vector of int 9 ,10h,16h
;		for recover csi vector
;		/* phase 1*/
;		[ds:si]=[0:bx*4]
;		[ds:si+2]=[0:bx*4+2]
;		/* phase 2*/
;		[es:di]=[0:bx*4]
;		[es:di+2]=[0:bx*4+2]
;		/* phase 2*/
;		[0:bx*4]=si-1;
;		[0:bx*4+2]=ds;

dummyvector proc near
	shl	bx,1			; bx <- bx*4
	shl	bx,1			; ie ,get offset of vector

; phase 1
; es --> 0
; es:bx --> cpu int vector table

	xor	ax,ax
	push	es
	mov	es,ax
	mov	ax,es:[bx]		; get offset  ds-->0
	mov	ds:[si],ax		; store  offset
	mov	ax,es:[bx+2]		; get offset  ds-->0
	mov	ds:[si+2],ax		; store segment
	pop	es

; phase 2
; ds --> 0
; ds:bx --> cpu int vector table

	xor	ax,ax
	push	ds
	mov	ds,ax
	mov	ax,ds:[bx]		; get offset
	mov	es:[di],ax		; store  offset
	mov	ax,ds:[bx+2]		; get offset
	mov	es:[di+2],ax		; store segment
	pop	ds

; phase 3
; es --> 0
; es:bx --> cpu int vector table

	xor	ax,ax
	push	es
	mov	es,ax
	dec	si
	mov	es:[bx],si
	mov	ax,ds
	mov	es:[bx+2],ax
	pop	es
	ret
dummyvector endp

; name : recovercsiint
; entry : none
; exit :none
; description :
;	recover int 9 ,10h,16h ,for csi vector

recovercsiint proc near
	push	es
	push	ds
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di

;recover int 9

	cmp	cs:oemdriverinst,0
	jnz	ignoreint9recover

	push	cs
	pop	ds
	mov	si,offset dummyint9
	push	cs
	pop	es

	mov	di,offset csiint9
	mov	bx,9
	mov	ax,0
	call	recoverint
ignoreint9recover:

; recover int 10h

	push	cs
	pop	ds
	mov	si,offset dummyint10h
	push	cs
	pop	es
	mov	di,offset csiint10h
	mov	bx,10h
	mov	ax,0+4
	call	recoverint

;recover int 16h

	push	cs
	pop	ds
	mov	si,offset dummyint16h
	push	cs
	pop	es
	mov	di,offset csiint16h
	mov	bx,16h
	mov	ax,0+4+4
	call	recoverint
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	ds
	pop	es
	ret
recovercsiint endp

; name : recoverint
; entey : ds:si --> dummy int sevice routine
;	  es:di --> point to  csi vector store area
;	  bx  == int number
;	  ax  == 0	; int 9
;		 4	; int 10h
;		 4+4	; int 16h
; exit : none
; description :
;	  1. if( [0:bx*4] == si-1  .and.  [es:bx*4+2] == ds )
;	     {
;		 [0:bx*4]   = [es:di];
;		 [0:bx*4+2] = [es:di+2];
;	     }
;	     else
;	     {
;		 /* phase 1 */
;		 [ds:si]  = [(*orgvectblptr)+ax]
;		 [ds:si+2]= [(*orgvectblptr)+ax+2];
;		 /* phase 2 */
;		 [orgvectblptr+ax) ]=[0:bx*4] ;
;		 [orgvectblptr+ax+2 ]=[0:bx*4+2] ;
;		 /* phase 3 */
;		 [0:bx*4]   = [es:di];
;		 [0:bx*4+2] = [es:di+2];
;
;
;	     }

;

recoverint proc near
;chek vector change ?
; es --> 0

	push	es
	mov	cx,ax
	xor	ax,ax
	mov	es,ax
	shl	bx,1
	shl	bx,1			; es:bx --> cpu int vector
	mov	ax,si
	dec	ax
	cmp	es:[bx],ax		; offset same ?
	jne	vectorbechanged

	mov	ax,ds
	cmp	es:[bx+2],ax		; segmnet same ?
	jne	vectorbechanged
	pop	es

; vector not be changed
; ds --> 0

	xor	ax,ax
	mov	ds,ax			; ds:bx --> cpu int vector
	mov	ax,es:[di]
	mov	ds:[bx],ax
	mov	ax,es:[di+2]
	mov	ds:[bx+2],ax
	ret

vectorbechanged:

;phase 1
; di:es --> addres of local driver

	pop	es
	push	di
	push	es
	mov	di,word ptr cs:[orgvectblptr]
	mov	es,word ptr cs:[orgvectblptr+2]
	add	di,cx
	mov	ax,es:[di]
	mov	ds:[si],ax
	mov	ax,es:[di+2]
	mov	ds:[si+2],ax

;phase2
; di:es --> addres of local driver
; ds --> 0

	push	ds
	xor	ax,ax
	mov	ds,ax
	mov	ax,ds:[bx]		; ds:bx --> cpu int vector
	mov	es:[di],ax
	mov	ax,ds:[bx+2]
	mov	es:[di+2],ax
	pop	ds
	pop	es
	pop	di

;phase3
; ds --> 0

	xor	ax,ax
	push	ds
	mov	ds,ax
	mov	cx,es:[di]
	mov	ds:[bx],cx		; ds:bx --> cpu int vector
	mov	cx,es:[di+2]
	mov	ds:[bx+2],cx
	pop	ds
	ret

recoverint endp

;name : chklocalexist
;entry : none
;exit :none
; descriptin : check local driver exist ?
;		if not exist system halt !
;		otherwise null return

chklocalexist proc near
	push	ax
	push	cx
	push	dx
	mov	ah,0dbh
	mov	al,80h			; module_extsysutil
	mov	cx,01			; syscmd_extquerysysmode
	int	16h
	test	ax,8000h		; bit 15 on
	jnz	csisystemerror		; no,system halt
					; yes ,dx == country id
	push	dx			; save current id
	mov	dx,58h
	mov	ah,0dbh
	mov	al,80h			; module_extsysutil
	mov	cx,02			; syscmd_extsetsysmode
	int	16h
	test	ax,8000h		; bit 15 on
	jnz	localdrvnotfound	; no ,local driver error

	pop	cx
	cmp	cx,dx			; current id == previous id ?
	jnz	localdrvnotfound	; no ,local driver error

	pop	dx
	pop	cx
	pop	ax
	ret

localdrvnotfound:
csisystemerror:
	push	cs
	pop	ds
	mov	dx,offset bootfailmsg
ifdef	JAPAN
	call	IsDBCSCodePage
	jz	@f			; if Kanji mode
	mov	dx,offset bootfailmsg2
@@:
endif
	mov	ah,9
	int	21h
	cli
	hlt
	ret

ifdef NEC_98
	include msbio.cl7		; bootfailmsg
endif   ;NEC_98
chklocalexist endp
        endif

ifdef NEC_98
DOCLI:
    FCLI
    ret
DOSTI:
    FSTI
    ret
DOIRET:
    FIRET
endif   ;NEC_98
sysinitseg ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\time.asm ===
PAGE    109,132

        TITLE   MS-DOS 5.0 TIME.ASM

;************************************************************************
;*                                                                      *
;*                                                                      *
;*              MODULE: TIME.ASM                                        *
;*                                                                      *
;*                                                                      *
;*              COPYRIGHT (C) NEC CORPORATION 1990                      *
;*                                                                      *
;*              NEC CONFIDENTIAL AND PROPRIETARY                        *
;*                                                                      *
;*              All rights reserved by NEC Corporation.                 *
;*              this program must be used solely for                    *
;*              the purpose for which it was furnished                  *
;*              by NEC Corporation.  No past of this program            *
;*              may be reproduced or disclosed to others,               *
;*              in any form, without the prior written                  *
;*              permission of NEC Corporation.                          *
;*              Use of copyright notice does not evidence               *
;*              publication of this program.                            *
;*                                                                      *
;************************************************************************

;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.

datagrp group   Bios_Data,Bios_Data_Init

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

Bios_Data_Init  segment word public 'Bios_Data_Init'
Bios_Data_Init  ends

Filler          segment para public 'Filler'
Filler          ends

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Filler2         segment para public 'Filler2'
Filler2         ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Bios_Data       segment word public 'Bios_Data'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        EXTRN   BIOS_FLAG:BYTE

        EXTRN   CAL_TBL:ABS
        EXTRN   T_YEAR:BYTE,T_MONTH:BYTE,T_DAY:BYTE
        EXTRN   T_HOUR:BYTE,T_MIN:BYTE,T_SEC:BYTE
        EXTRN   MONTH_TBL:BYTE
        EXTRN   YEAR:WORD,MONTH:WORD,DAY:WORD

Bios_Data       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP
        EXTRN   STOP_CHK:NEAR
Bios_Code       ends

Bios_Code       segment word public 'Bios_Code'
                ASSUME  CS:BIOS_CODE,DS:DATAGRP

        PUBLIC  TIME_CODE_START
        PUBLIC  TIME_CODE_END
        PUBLIC  TIME_END

        PUBLIC  SETDATE,SETTIME,GETDATE

TIME_CODE_START:

        PAGE
;
;TIME AND DATE
;
GETDATE:
        PUSH    ES                      ; SAVE ES
        PUSH    DS                      ;                               @DOS5
        POP     ES                      ; ES <- DS
        PUSH    BX                      ;SAVE BX
        MOV     BIOS_FLAG,1
        MOV     BX,OFFSET CAL_TBL
        XOR     AH,AH                   ;SET GET COMMAND
        INT     1CH                     ;GET DATE FROM ROM BIO
        MOV     AL,T_YEAR               ;GET YEAR (BCD)
        CALL    S_HEX
        CMP     AX,80                   ;AX >= 80 ?
        JAE     SKP_T                   ;JUMP IF SO
        ADD     AX,100
SKP_T:
        ADD     AX,1900                 ;COMPUTE YEAR
        MOV     YEAR,AX                 ;SAVE YEAR
        XOR     AH,AH
        MOV     AL,T_MONTH              ;GET MONTH (HEX OF HIGH 4BITS)
        MOV     CL,4
        SHR     AL,CL                   ;GET MONTH
        MOV     MONTH,AX                ;SAVE MONTH
        MOV     AL,T_DAY                ;GET DATE (BCD)
        CALL    S_HEX
        MOV     DAY,AX                  ;SAVE DATE
;COMPUTE NUMBER OF DAYS FROM 1/1/80
        MOV     BX,1980                 ;SET STARTING YEAR
        XOR     AX,AX
LOOP1:
        CALL    YEAR_CHK                ;CHECK LEAP-YEAR
        CMP     BX,YEAR                 ;SAME YEAR?
        JE      G_MONTH                 ;JUMP IF SO
        ADD     AX,DX                   ;COMPUTE NUMBER OF DAYS
        INC     BX                      ;INCREASE YEAR
        JMP     SHORT   LOOP1
G_MONTH:
        XOR     BX,BX                   ;CLEAR TABLE'S POINTER
        XOR     CH,CH
        DEC     WORD PTR MONTH
LOOP2:
        CMP     BX,MONTH                ;SAME MONTH?
        JE      G_DAY                   ;JUMP IF SO
        MOV     CL,MONTH_TBL[BX]        ;GET DAYS OF A MONTH
        ADD     AX,CX                   ;COMPUTE DAYS
        INC     BX                      ;INCREASE POINTER
        JMP     SHORT   LOOP2
G_DAY:
        ADD     AX,DAY
        DEC     AX                      ;GET NUMBER OF DAYS
        PUSH    AX                      ;SAVE AX
        MOV     AL,T_HOUR               ;GET HOUR (BCD)
        CALL    S_HEX
        MOV     CH,AL                   ;SET HOUR
        MOV     AL,T_MIN                ;GET MINUTE (BCD)
        CALL    S_HEX
        MOV     CL,AL                   ;SET MINUTE
        MOV     AL,T_SEC                ;GET SECOND (BCD)
        CALL    S_HEX
        MOV     DH,AL                   ;SET SECOND
        XOR     DL,DL                   ;SET 0 FOR SEC/100
        POP     AX                      ;RESTORE AX
        POP     BX                      ;RESTORE BX
        POP     ES                      ; RESTORE ES
        CALL    STOP_CHK
        RET

SETTIME:
        MOV     BIOS_FLAG,1
        MOV     AL,CH                   ;GET HOUR
        CALL    CONV_BCD                ;CONVERT TO BCD
        MOV     T_HOUR,AL               ;SET HOUR
        MOV     AL,CL                   ;GET MINUTE
        CALL    CONV_BCD                ;CONVERT TO BCD
        MOV     T_MIN,AL                ;SET MINUTE
        MOV     AL,DH                   ;GET SECOND
        CALL    CONV_BCD                ;CONVERT TO BCD
        MOV     T_SEC,AL                ;SET SECOND
        PUSH    ES                      ;SAVE ES
        PUSH    BX                      ;SAVE BX
        MOV     AX,ds
        MOV     ES,AX                   ;ES <= ds                       @dos5
        MOV     BX,OFFSET CAL_TBL
        MOV     AH,01H                  ;SET SET COMMAND
        INT     1CH                     ;SET TIME
        CALL    STOP_CHK
        POP     BX                      ;RESTORE BX
        POP     ES                      ;RESTORE ES
        RET

SETDATE:
        PUSH    ES
        PUSH    DS                                              ;       @DOS5
        POP     ES                      ;ES <- DS
        PUSH    CX
        PUSH    DX
        PUSH    BX
        PUSH    AX
        CALL    GETDATE
        POP     AX
        MOV     BIOS_FLAG,1
        PUSH    AX
        MOV     BX,1980                 ;SET STARTING YEAR
        MOV     WORD PTR MONTH,1        ;SET STARTING MONTH
LOOP3:
        CALL    YEAR_CHK                ;CHECK LEAP-YEAR
        CMP     AX,DX
        JB      S_YEAR                  ;JUMP IF AX < DX
        INC     BX                      ;INCREASE YEAR
        SUB     AX,DX
        JMP     SHORT   LOOP3
S_YEAR:
        XCHG    AX,BX
        SUB     AX,1900
        CMP     AX,100
        JB      NOT_SUB
        SUB     AX,100
NOT_SUB:
        CALL    CONV_BCD                ;CONVERT TO BCD
        MOV     T_YEAR,AL
        MOV     AX,BX
        XOR     BX,BX                   ;CLEAR TABLE'S POINTER
        XOR     CH,CH
LOOP4:
        MOV     CL,MONTH_TBL[BX]        ;GET DAYS OF A MONTH
        CMP     AX,CX
        JB      S_MD                    ;JUMP IF AX < CX
        INC     WORD PTR MONTH          ;INCREASE MONTH
        SUB     AX,CX
        INC     BX                      ;INCREASE POINTER
        JMP     SHORT   LOOP4
S_MD:
        INC     AL
        CALL    CONV_BCD                ;CONVERT TO BCD
        MOV     T_DAY,AL                ;SET DAY
        MOV     AX,MONTH
        MOV     CL,4
        SHL     AL,CL
        MOV     T_MONTH,AL              ;SET MONTH
        MOV     BX,OFFSET CAL_TBL
        MOV     AH,01H                  ;SET SET COMMAND
        INT     1CH                     ;SET DATE
        CALL    STOP_CHK
        POP     AX                      ;RESTORE AX
        POP     BX                      ;RESTORE BX
        POP     DX                      ;RESTORE DX
        POP     CX                      ;RESTORE CX
        POP     ES
        RET

YEAR_CHK:
        PUSH    AX                      ;SAVE AX
        PUSH    BX                      ;SAVE BX
        XOR     DX,DX
        MOV     AX,BX
        MOV     CX,4
        DIV     CX
        OR      DX,DX
        JNZ     COMN_Y                  ;JUMP IF COMMON-YEAR
        MOV     AX,BX
        MOV     CX,100
        DIV     CX
        OR      DX,DX
        JNZ     LEAP_Y                  ;JUMP IF LEAP-YEAR
        MOV     AX,BX
        MOV     CX,400
        DIV     CX
        OR      DX,DX
        JNZ     COMN_Y                  ;JUMP IF COMMON-YEAR
LEAP_Y:
        MOV     DX,366                  ;SET DAYS OF YEAR
        MOV     AL,29                   ;SET DAYS OF FEB.
        JMP     SHORT   S_FEB
COMN_Y:
        MOV     DX,365                  ;SET DAYS OF YEAR
        MOV     AL,28                   ;SET DAYS OF FEB.
S_FEB:
        MOV     BX,1
        MOV     MONTH_TBL[BX],AL        ;SET FEB.
        POP     BX                      ;RESTORE BX
        POP     AX                      ;RESTORE AX
        RET
CONV_BCD:
        PUSH    CX                      ;SAVE CX
        AAM                             ;CONVERT TO UNPACK BCD
        MOV     CL,4
        SHL     AL,CL
        SHR     AX,CL
        POP     CX                      ;RESTORE CX
        RET
S_HEX:
        PUSH    CX
        XOR     AH,AH
        MOV     CL,4
        SHL     AX,CL
        SHR     AL,CL
        AAD
        XOR     AH,AH
        POP     CX
        RET

;
;DATA OF TIME ROUTINE
;
;CAL_TBL        EQU     $
;T_YEAR DB      0
;T_MONTH        DB      0
;T_DAY  DB      0
;T_HOUR DB      0
;T_MIN  DB      0
;T_SEC  DB      0
;MONTH_TBL DB   31,28,31,30,31,30,31,31,30,31,30,31
;       EVEN
;YEAR   DW      0
;MONTH  DW      0
;DAY    DW      0

TIME_CODE_END:
TIME_END:
BIOS_CODE       ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC" LANGID=804
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC" LANGID=804
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN" LANGID=404
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN" LANGID=411
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

msbio.skl : ..\usa\msbio.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA" LANGID=412
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\bios\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98" LANGID=411
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\crit.asm ===
TITLE CRIT - Critical Section Routines
	NAME  CRIT

;**	CRIT.ASM - Critical Section Routines
;
;	Critical section handlers
;
;	Modification history:
;
;	Sudeepb 15-Mar-1991 Ported for NT DOSEm

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	include int2a.inc
	include vector.inc
	include bugtyp.inc
	.cref
	.list

	I_need  User_In_AX,WORD
	i_need  CurrentPDB,WORD

	I_need 	redir_patch,BYTE

DOSCODE SEGMENT
	ASSUME  SS:NOTHING,CS:DOSCODE

	allow_getdseg

	Break	<Critical section handlers>

;
;   Each handler must leave everything untouched; including flags!
;
;   Sleaze for time savings:  first instruction is a return.  This is patched
;   by the sharer to be a PUSH AX to complete the correct routines.


Procedure   EcritDisk,NEAR
	public  EcritMem
	public  EcritSFT
ECritMEM    LABEL   NEAR
ECritSFT    LABEL   NEAR
ifdef NEC_98
;
;SR; Check if critical section is to be entered
;
	pushf
	cmp	ss:[redir_patch],0
	jz	@f
	popff

        PUSH    AX
if	DEBUG
	SAVE	<ds>
	GETDSEG DS
	fmt	TypSect,LevReq,<"PDB $x entering DISK">,<CurrentPDB>
	RESTORE <ds>
    ASSUME DS:nothing
endif
	MOV     AX,8000h+critDisk
	INT     int_ibm
	POP     AX
	return
@@:
	popff
endif   ;NEC_98
	ret


EndProc EcritDisk


Procedure   LcritDisk,NEAR
	public  LcritMem
	public  LcritSFT
LCritMEM    LABEL   NEAR
LCritSFT    LABEL   NEAR
ifdef NEC_98
;
;SR; Check if critical section is to be entered
;
	pushf
	cmp	ss:[redir_patch],0
	jz	@f
	popff

        PUSH    AX
if	DEBUG
	SAVE	<ds>
	GETDSEG DS
	fmt	TypSect,LevReq,<"PDB $x leaving DISK">,<CurrentPDB>
	RESTORE <ds>
    ASSUME DS:nothing
endif
	MOV     AX,8100h+critDisk
	INT     int_ibm
	POP     AX
	return
@@:
	popff
endif   ;NEC_98
	ret


EndProc LcritDisk


Procedure   EcritDevice,NEAR
ifdef NEC_98
;SR; Check if critical section is to be entered
;
	pushf
	cmp	ss:[redir_patch],0
	jz	@f
	popff

        PUSH    AX
if	DEBUG
	SAVE	<ds>
	GETDSEG DS
	fmt	TypSect,LevReq,<"PDB $x entering DEV">,<CurrentPDB>
	RESTORE <ds>
    ASSUME DS:nothing
endif
	MOV     AX,8000h+critDevice
	INT     int_ibm
	POP     AX
	return
@@:
	popff
endif   ;NEC_98
	ret


EndProc EcritDevice

Procedure   LcritDevice,NEAR
ifdef NEC_98
;
;SR; Check if critical section is to be entered
;
	pushf
	cmp	ss:[redir_patch],0
	jz	@f
	popff

        PUSH    AX
if	DEBUG
	SAVE	<ds>
	GETDSEG DS
	fmt	TypSect,LevReq,<"PDB $x leaving DEV">,<CurrentPDB>
	RESTORE <ds>
    ASSUME DS:nothing
endif
	MOV     AX,8100h+critDevice
	INT     int_ibm
	POP     AX
	return
@@:
	popff
endif   ;NEC_98
	ret


EndProc LcritDevice

DOSCODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\alloc.asm ===
TITLE ALLOC.ASM - memory arena manager	NAME Alloc

;**	Memory related system calls and low level routines
;
;	$ALLOC
;	$SETBLOCK
;	$DEALLOC
;	$AllocOper
;	arena_free_process
;	arena_next
;	check_signature
;	Coalesce
;
;	Modification history:
;	sudeepb 11-Mar-1991 Ported for NT DOSEm
;

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include arena.inc

	.cref
	.list

	BREAK	<memory allocation utility routines>

	i_need  arena_head,WORD         ; seg address of start of arena
	i_need  CurrentPDB,WORD         ; current process data block addr
	i_need  FirstArena,WORD         ; first free block found
	i_need  BestArena,WORD          ; best free block found
	i_need  LastArena,WORD          ; last free block found
	i_need  AllocMethod,BYTE        ; how to alloc first(best)last
	I_need  EXTERR_LOCUS,BYTE       ; Extended Error Locus


	I_need	umb_head,WORD		; seg address of start of umb arenas
	I_need	start_arena,WORD	; seg address of arena from which to 
					; start alloc scan
	I_need 	umbflag,BYTE		; bit 0 indicates link state

	I_need  A20OFF_COUNT,BYTE	; M016, M068
	I_need	DOS_FLAG, BYTE		; M068

DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE

	BREAK	<Arena_Free_Process - Free a processes memory>


;**	Arena_Free_Process
;
;	Free all arena blocks allocated to a pricess
;
;	ENTRY	(bx) = PID of process
;	EXIT	none
;	USES	????? BUGBUG

procedure   arena_free_process,NEAR

	MOV     AX,[arena_head]

arena_free_process_start:
	MOV     DI,arena_signature
	CALL    Check_Signature         ; ES <- AX, check for valid block

arena_free_process_loop:
	jc	ret_label		; return if carry set

	PUSH    ES
	POP     DS
	CMP     DS:[arena_owner],BX     ; is block owned by pid?
	JNZ     arena_free_next         ; no, skip to next
	MOV     DS:[arena_owner],DI     ; yes... free him

arena_free_next:
	CMP     BYTE PTR DS:[DI],arena_signature_end
					; end of road, Jack?

	jz	arena_chk_umbs		; M010: let's check umb arenas

	CALL    arena_next              ; next item in ES/AX carry set if trash
	JMP     arena_free_process_loop

arena_chk_umbs:				; M010 - Start
	mov	ax, [umb_head]		; ax = umb_head
	cmp	ax, 0ffffh		; Q: is umb_head initialized
	je	ret_label		; N: we're done

	mov	di, ds			; di = last arena
	cmp	di, ax			; Q: is last arena above umb_head
	jae	ret_label		; Y: we've scanned umbs also. done.
	jmp	short arena_free_process_start
					; M010 - End

EndProc arena_free_process

	BREAK	<Arena Helper Routines>

;**	Arena_Next - Find Next item in Arena
;
;	ENTRY	DS - pointer to block head
;		(di) = 0
;	EXIT	AX,ES - pointers to next head
;		'C' set iff arena damaged

procedure   arena_next,NEAR

	MOV     AX,DS                   ; AX <- current block
	ADD     AX,DS:[arena_size]      ; AX <- AX + current block length
	INC     AX                      ; remember that header!

;       fall into check_signature and return
;
;       CALL    check_signature         ; ES <- AX, carry set if error
;       RET
;	BUGBUG - put fallthru here

EndProc arena_next




;**	Check_Signature - Check Memory Block Signature
;
;	ENTRY	(AX) = address of block header
;		(di) = 0
;	EXIT	 ES = AX
;		'C' clear if signature good
;		'C' set if signature bad
;	USES	ES, Flags

;align	2		BUGBUG - put me in
procedure   check_signature,NEAR

	MOV     ES,AX                   ; ES <- AX
	CMP     BYTE PTR ES:[DI],arena_signature_normal
					; IF next signature = not_end THEN
	jz	ret_label		;   GOTO OK (ret if Z)

	CMP     BYTE PTR ES:[DI],arena_signature_end
					; IF next signature = end then
	jz	ret_label		;   GOTO ok (ret if Z)
	STC                             ; set error

ret_label:
	return

EndProc Check_signature



;**	Coalesce - Combine free blocks ahead with current block
;
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	ENTRY	(ds) = pointer to the head of a free block
;		(di) = 0
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	(cx)

procedure   Coalesce,NEAR

	CMP     BYTE PTR DS:[DI],arena_signature_end
					; IF current signature = END THEN
	retz                            ;   GOTO ok
	CALL    arena_next              ; ES, AX <- next block, Carry set if error
	retc                            ; IF no error THEN GOTO check

coalesce_check:
	CMP     ES:[arena_owner],DI
	retnz                           ; IF next block isnt free THEN return
	MOV     CX,ES:[arena_size]      ; CX <- next block size
	INC     CX                      ; CX <- CX + 1 (for header size)
	ADD     DS:[arena_size],CX      ; current size <- current size + CX
	MOV     CL,ES:[DI]              ; move up signature
	MOV     DS:[DI],CL
	JMP     coalesce                ; try again

EndProc Coalesce

	BREAK  <$Alloc - allocate space in memory>

;**	$Alloc - Allocate Memory Space
;
;	$Alloc services the INT21 that allocates memory space to a program.
;	Alloc returns	a  pointer  to	a  free  block of
;       memory that has the requested  size  in  paragraphs.
;
;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
;	scanned from umb_head if not from arena_head. If the strategy is
; 	HIGH_FIRST the scan is continued from arena_head if a block of 
;	appropriate size is not found in the UMBs. If the strategy is 
;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
;
;	In either case if bit 0 of UmbFlag is not initialized then the scan
;	starts from arena_head.
;
;	Assembler usage:
;           MOV     BX,size
;           MOV     AH,Alloc
;           INT     21h
;
;	BUGBUG - a lot can be done to improve performance.  We can set marks
;	so that we start searching the arena at it's first non-trivial free
;	block, we can peephole the code, etc.  (We can move some subr calls
;	inline, etc.)  I assume that this is called rarely and that the arena
;	doesn't have too many memory objects in it beyond the first free one.
;	verify that this is true; if so, this can stay as is
;
;	ENTRY	(bx) = requested size, in bytes
;		(DS) = (ES) = DOSGROUP
;	EXIT	'C' clear if memory allocated
;		  (ax:0) = address of requested memory
;		'C' set if request failed
;		  (AX) = error_not_enough_memory
;		    (bx) = max size we could have allocated
;		  (ax) = error_arena_trashed
;	USES	All

procedure   $ALLOC,NEAR

	EnterCrit   critMem

					; M000 - start
	mov	ax, [arena_head]
	mov	[start_arena], ax	; assume LOW_FIRST
				
	test	byte ptr [AllocMethod], HIGH_FIRST+HIGH_ONLY
					; Q: should we start scanning from 
					;    UMB's
	jz	norm_alloc		; N: scan from arena_head

;	cmp	[umb_head], -1		; Q: Has umb_head been initialized
;	je	norm_alloc		; N: scan from arena_head
	test	[UmbFlag], LINKSTATE	; Q: are umb's linked
	jz	norm_alloc		; N: scan from arena_head

	mov	ax, [umb_head]
	mov	[start_arena], ax	; start_arena = umb_head
	
					; M000 - end

norm_alloc:

	XOR     AX,AX
	MOV     DI,AX

					; SS override for next First/Best/Last 
					; Arena
	MOV     [FirstArena],AX         ; init the options
	MOV     [BestArena],AX
	MOV     [LastArena],AX

	PUSH    AX                      ; alloc_max <- 0

start_scan:
	MOV     AX,[start_arena]        ; M000: AX <- beginning of arena
;	MOV     AX,[arena_head]         ; M000: AX <- beginning of arena


	CALL    Check_signature         ; ES <- AX, carry set if error
	JC      alloc_err               ; IF error THEN GOTO err

alloc_scan:
	PUSH    ES
	POP     DS                      ; DS <- ES
	CMP     DS:[arena_owner],DI
	JZ      alloc_free              ; IF current block is free THEN examine

alloc_next:
					; M000 - start 

	test	[UmbFlag], LINKSTATE	; Q: are umb's linked
	jz	norm_strat		; N: see if we reached last arena

	test	byte ptr [AllocMethod], HIGH_FIRST
					; Q: is alloc strategy high_first
	jz	norm_strat		; N: see if we reached last arena
	mov	ax, [start_arena]
	cmp	ax, [arena_head]	; Q: did we start scan from 
					;    arena_head
	jne	norm_strat		; N: see if we reached last arena
	mov	ax, ds			; ax = current block
	cmp	ax, [umb_head]		; Q: check against umb_head 
	jmp	short alloc_chk_end
	
norm_strat:				; M000 - end
					; check against last sig '5A'
	CMP     BYTE PTR DS:[DI],arena_signature_end

alloc_chk_end:				; M000
					; IF current block is last THEN
	JZ      alloc_end               ;   GOTO end
	CALL    arena_next              ; AX, ES <- next block, Carry set if error
	JNC     alloc_scan              ; IF no error THEN GOTO scan

alloc_err:
	POP     AX

alloc_trashed:
	LeaveCrit   critMem
	error   error_arena_trashed

alloc_end:
	CMP     [FirstArena],0
	LJNZ    alloc_do_split
					; M000 - start
	mov	ax, [arena_head]
	cmp	ax, [start_arena]	; Q: started scanning from arena_head
	je	alloc_fail		; Y: not enough memory
					; N:
					; Q: is the alloc strat HIGH_ONLY
	test 	byte ptr [AllocMethod], HIGH_ONLY
	jnz	alloc_fail		; Y: return size of largest UMB

	mov	[start_arena], ax	; N: start scanning from arena_head
	jmp	short start_scan
					; M000 - end
					
alloc_fail:
	invoke  get_user_stack
	POP     BX
	MOV     [SI].user_BX,BX
	LeaveCrit   critMem
	error   error_not_enough_memory

alloc_free:
	CALL    coalesce                ; add following free block to current
	JC      alloc_err               ; IF error THEN GOTO err
	MOV     CX,DS:[arena_size]

	POP     DX                      ; check for max found size
	CMP     CX,DX
	JNA     alloc_test
	MOV     DX,CX

alloc_test:
	PUSH    DX
	CMP     BX,CX                   ; IF BX > size of current block THEN
	JA      alloc_next              ;   GOTO next
	CMP     [FirstArena],0
	JNZ     alloc_best
	MOV     [FirstArena],DS         ; save first one found
alloc_best:
	CMP     [BestArena],0
	JZ      alloc_make_best         ; initial best
	PUSH    ES
	MOV     ES,[BestArena]
	CMP     ES:[arena_size],CX      ; is size of best larger than found?
	POP     ES
	JBE     alloc_last
alloc_make_best:
	MOV     [BestArena],DS          ; assign best
alloc_last:
	MOV     [LastArena],DS          ; assign last
	JMP     alloc_next

;
; split the block high
;
alloc_do_split_high:
	MOV     DS,[LastArena]
	MOV     CX,DS:[arena_size]
	SUB     CX,BX
	MOV     DX,DS
	JE      alloc_set_owner         ; sizes are equal, no split
	ADD     DX,CX                   ; point to next block
	MOV     ES,DX                   ; no decrement!
	DEC     CX
	XCHG    BX,CX                   ; bx has size of lower block
	JMP     short alloc_set_sizes   ; cx has upper (requested) size

;
; we have scanned memory and have found all appropriate blocks
; check for the type of allocation desired; first and best are identical
; last must be split high
;
alloc_do_split:
					; M000 - start
	xor	cx, cx
	mov	cl, byte ptr [AllocMethod]
	and	cx, STRAT_MASK		; mask off bit 7
	cmp	cx, BEST_FIT		; Q; is the alloc strategy best_fit

;	CMP     BYTE PTR [AllocMethod], BEST_FIT
					; M000 - end	

					; Q: is the alloc strategy best_fit
	JA      alloc_do_split_high	; N: it is last fit
	MOV     DS,[FirstArena]		; assume first_fit
	JB      alloc_get_size		; it is first_fit
	MOV     DS,[BestArena]		; it is last_fit
alloc_get_size:
	MOV     CX,DS:[arena_size]
	SUB     CX,BX                   ; get room left over
	MOV     AX,DS
	MOV     DX,AX                   ; save for owner setting
	JE      alloc_set_owner         ; IF BX = size THEN (don't split)
	ADD     AX,BX
	INC     AX                      ; remember the header
	MOV     ES,AX                   ; ES <- DS + BX (new header location)
	DEC     CX                      ; CX <- size of split block
alloc_set_sizes:
	MOV     DS:[arena_size],BX      ; current size <- BX
	MOV     ES:[arena_size],CX      ; split size <- CX
	MOV     BL,arena_signature_normal
	XCHG    BL,DS:[DI]              ; current signature <- 4D
	MOV     ES:[DI],BL              ; new block sig <- old block sig
	MOV     ES:[arena_owner],DI

alloc_set_owner:
	MOV     DS,DX

					
	MOV     AX,[CurrentPDB]		; SS override
	MOV     DS:[arena_owner],AX
	MOV     AX,DS
	INC     AX
	POP     BX
	LeaveCrit   critMem
	transfer    SYS_RET_OK

EndProc $alloc

	BREAK $SETBLOCK - change size of an allocated block (if possible)

;**	$SETBLOCK - Change size of an Alocated Block
;
;	Setblock changes the size of an allocated block.  First, we coalesce
;	any following free space onto this block; then we try to trim the
;	block down to the size requested.
;
;	Note that if the guy wants to grow the block but that growth fails,
;	we still go ahead and coalesce any trailing free blocks onto it.
;	Thus the maximum-size-possible value that we return has already
;	been allocated!  This is a bug, dare we fix it?  BUGBUG
;
;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
;		finish it's work.  FOr this reason we build the allocsf
;		structure on the frame, to make us compatible with $ALLOCs
;		code.
;
;	ENTRY	(es) = segment of old block
;		(bx) = newsize
;		(ah) = SETBLOCK
;
;	EXIT	'C' clear if OK
;		'C' set if error
;		  (ax) = error_invalid_block
;		       = error_arena_trashed
;		       = error_not_enough_memory
;		       = error_invalid_function
;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
;	USES	???? BUGBUG

procedure   $SETBLOCK,NEAR

	EnterCrit   critMem
	MOV     DI,arena_signature
	MOV     AX,ES
	DEC     AX
	CALL    check_signature
	JNC     setblock_grab

setblock_bad:
	JMP     alloc_trashed

setblock_grab:
	MOV     DS,AX
	CALL    coalesce
	JC      setblock_bad
	MOV     CX,DS:[arena_size]
	PUSH    CX
	CMP     BX,CX
	JBE     alloc_get_size
	JMP     alloc_fail

EndProc $setblock

	BREAK $DEALLOC - free previously allocated piece of memory

;**	$DEALLOC - Free Heap Memory
;
;	ENTRY	(es) = address of item
;
;	EXIT	'C' clear of OK
;		'C' set if error
;		  (AX) = error_invalid_block
;	USES	???? BUGBUG

procedure   $DEALLOC,NEAR

	EnterCrit   critMem

					; M016, M068 - Start
	test	[DOS_FLAG], EXECA20OFF
					; Q: was the previous call an int 21
					;    exec call
	jz	@f			; N: continue
	cmp	[A20OFF_COUNT], 0	; Q: is count 0
	jne	@f			; N: continue
	mov	[A20OFF_COUNT], 1	; Y: set count to 1
@@:					; M016, M068 - End
	

	MOV     DI,arena_signature
	MOV     AX,ES
	DEC     AX
	CALL    check_signature
	JC      dealloc_err
	MOV     ES:[arena_owner],DI
	LeaveCrit   critMem
	transfer    SYS_RET_OK

dealloc_err:
	LeaveCrit   critMem
	error   error_invalid_block

EndProc $DEALLOC

	BREAK $AllocOper - get/set allocation mechanism

;**	$AllocOper - Get/Set Allocation Mechanism
;
;	Assembler usage:
;           MOV     AH,AllocOper
;           MOV     BX,method
;           MOV     AL,func
;           INT     21h
;
;	ENTRY	
;		(al) = 0
;		  Get allocation Strategy in (ax)
;
;		(al) = 1, (bx) = method = zw0000xy
;		  Set allocation strategy.
;		   w  = 1  => HIGH_ONLY
;		   z  = 1  => HIGH_FIRST
;		   xy = 00 => FIRST_FIT
;		      = 01 => BEST_FIT
;		      = 10 => LAST_FIT
;
;		(al) = 2
;		  Get UMB link state in (al)
;
;		(al) = 3
;		  Set UMB link state
;		   (bx) = 0 => Unlink UMBs
;		   (bx) = 1 => Link UMBs
;
;
;	EXIT	'C' clear if OK
;
;		 if (al) = 0
;		  (ax) = existing method
;		 if (al) = 1
;		  Sets allocation strategy
;		 if (al) = 2
;		  (al) = 0 => UMBs not linked
;		  (al) = 1 => UMBs linked in
;		 if (al) = 3
;		  Links/Unlinks the UMBs into DOS chain
;
;		'C' set if error
;		  AX = error_invalid_function
;
;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
;		    umbhead has'nt been initialized by sysinit and 'trashed
;		    arena' if an arena sig is damaged.
;


procedure   $AllocOper,NEAR

	or	al, al
	jz	AllocGetStrat
	cmp	al, 1
	jz	AllocSetStrat
	cmp	al, 2
	jz	AllocGetLink
	cmp	al, 3
	jz	AllocSetLink
	     
AllocOperError:
					; SS override
	MOV     EXTERR_LOCUS,errLoc_mem ; Extended Error Locus
	error   error_invalid_function

AllocArenaError:

	MOV     EXTERR_LOCUS,errLoc_mem ; M009: Extended Error Locus
	error   error_arena_trashed	; M009:


AllocGetStrat:
					; SS override
	MOV     AL,BYTE PTR [AllocMethod]
	XOR     AH,AH
	transfer SYS_RET_OK

AllocSetStrat:

	push	bx			; M000 - start
	and	bx, STRAT_MASK 		; M064: mask off bit 6 & 7
	cmp	bx,2			; BX must be 0-2
	pop	bx			; M000 - end
	ja	AllocOperError

	MOV     [AllocMethod],BL
	transfer    SYS_RET_OK

AllocGetLink:

	mov	al, [UmbFlag]		; return link state in al
	and 	al, LINKSTATE		
	transfer SYS_RET_OK

AllocSetLink:

					; M009 - start
	mov	cx, [umb_head]		; cx = umb_head
	cmp	cx, 0ffffh		; Q: has umb_head been initialized
	je	AllocOperError		; N: error
					; Y: continue
					; M009 - end

	cmp	bx, 1			
	jb	UnlinkUmbs
	jz	LinkUmbs

	jmp	short AllocOperError

UnlinkUmbs:
	
	test	[UmbFlag], LINKSTATE	; Q: umbs unlinked?
	jz	unlinked		; Y: return 

	call	GetLastArena		; get arena before umb_head in DS
	jc	AllocArenaError		; M009: arena trashed

					; make it last
	mov	byte ptr ds:[0], arena_signature_end

	and	[UmbFlag], NOT LINKSTATE; indicate unlink'd state in umbflag

unlinked:
	transfer SYS_RET_OK

LinkUmbs:

	test	[UmbFlag], LINKSTATE	; Q: umbs linked?
	jnz	linked			; Y: return

	call	GetLastArena		; get arena before umb_head
	jc	AllocArenaError		; M009: arena trashed

					; make it normal. M061: ds points to
					; arena before umb_head
	mov	byte ptr ds:[0], arena_signature_normal

	or	[UmbFlag], LINKSTATE	; indicate link'd state in umbflag
linked:
	transfer SYS_RET_OK

EndProc $AllocOper


;--------------------------------------------------------------------------
;
; Procedure Name : GetLastArena		-  M003
;
; Inputs	 : cx = umb_head
;
;
; Outputs	 : If UMBs are linked
;			ES = umb_head
;			DS = arena before umb_head
;		   else
;			DS = last arena
;			ES = next arena. will be umb_head if NC.
;
;		   CY if error
;
; Uses		 : DS, ES, DI, BX
;
;--------------------------------------------------------------------------
	
Procedure	GetLastArena, NEAR


	push	ax			; save ax

	mov	ax, [arena_head]
	mov	es, ax			; es = arena_head
	xor	di, di

	cmp     byte ptr es:[di],arena_signature_end
					; Q: is this the last arena
	je	GLA_done		; Y: return last arena in ES		
					

GLA_next:
	mov	ds, ax
	call	arena_next		; ax, es -> next arena
	jc	GLA_err

	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
	jnz	GLA_chkumb		; Y: terminating condition is 
					;    umb_head
					; N: terminating condition is 05Ah

	cmp     byte ptr es:[di],arena_signature_end
					; Q: is this the last arena
	jmp	short @f
GLA_chkumb:
	cmp	ax, cx			; Q: is this umb_head
@@:
	jne	GLA_next		; N: get next arena

GLA_done:
					; M061 - Start
	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
	jnz	GLA_ret			; Y: we're done
					; N: let us confirm that the next 
					;    arena is umb_head
	mov	ds, ax
	call	arena_next		; ax, es -> next arena
	jc	GLA_err
	cmp	ax, cx			; Q: is this umb_head
	jne	GLA_err			; N: error
					; M061 - End

GLA_ret:				
	clc
	pop	ax			; M061
	ret				; M061

GLA_err:
	stc				; M061
	pop	ax
	ret

EndProc GetLastArena

DOSCODE ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\cpmio2.asm ===
TITLE	CPMIO2 - device IO for MSDOS
	NAME	CPMIO2

;**	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input
;	$Std_Con_Output
;	OUTT
;	TAB
;	BUFOUT
;	$Std_Aux_Input
;	$Std_Aux_Output
;	$Std_Printer_Output
;	$Std_Con_Input_Status
;	$Std_Con_Input_Flush
;
;	Revision History:
;
;	  AN000	 version 4.00 - Jan. 1988

	.xcref
	.xlist
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	.list
	.cref

; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

    i_need  CARPOS,BYTE
    i_need  CHARCO,BYTE
    i_need  PFLAG,BYTE
    i_need  CurrentPDB,WORD			 ;AN000;
    i_need  InterCon,BYTE			 ;AN000;
    i_need  SaveCurFlg,BYTE			 ;AN000;


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


;hkn; 	All the variables use SS override or DS. Therefore there is
;hkn;	no need to specifically set up any seg regs unless SS assumption is
;hkn;	not valid. 


	BREAK	<$STD_CON_INPUT - System Call 1>
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT - System Call 1
;
;	Input character from console, echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	ALL
;
;----------------------------------------------------------------------------
;

procedure   $STD_CON_INPUT,NEAR   ;System call 1
 IFDEF  DBCS					;AN000;
	push	word ptr [InterCon]		;AN000;
	mov	[InterCon],01H			;AN000;
	invoke	INTER_CON_INPUT_NO_ECHO 	;AN000;
	pop	word ptr [InterCon]		;AN000;
	pushf					;AN000;
	push	AX				;AN000;
	mov	[SaveCurFlg],0			;AN000;
	jnz	sj0				;AN000;
	mov	[SaveCurFlg],1			;AN000;
sj0:						;AN000;
	invoke	OUTT				;AN000;
	mov	[SaveCurFLg],0			;AN000;
	pop	AX				;AN000;
	popf					;AN000;
	jz	$STD_CON_INPUT			;AN000;
 ELSE						;AN000;
	invoke	$STD_CON_INPUT_NO_ECHO
	PUSH	AX
	invoke	OUTT
	POP	AX
 ENDIF						;AN000;
	return
EndProc $STD_CON_INPUT


	BREAK	<$STD_CON_OUTPUT - System Call 2>
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_OUTPUT - System Call 2
;
;	Output character to console
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

	public	OUTCHA			       ;AN000;
procedure   $STD_CON_OUTPUT,NEAR   ;System call 2

	MOV	AL,DL

	entry	OUTT
	CMP	AL,20H
	JB	CTRLOUT
	CMP	AL,c_DEL
	JZ	OUTCH
OUTCHA: 				   ;AN000;
	INC	BYTE PTR [CARPOS]
OUTCH:
	PUSH	DS
	PUSH	SI
	INC	BYTE PTR [CHARCO]		;invoke  statchk...
	AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
	JNZ	OUTSKIP
	PUSH	AX
	invoke	STATCHK
	POP	AX
OUTSKIP:
	invoke	RAWOUT				;output the character
	POP	SI
	POP	DS
 IFDEF  DBCS				;AN000;
	TESTB	[SaveCurFlg],01H	;AN000;print but no cursor adv? 2/13/KK
	retnz				;AN000;if so then do not send to prt2/13/KK
 ENDIF
	TEST	BYTE PTR [PFLAG],-1
	retz
	PUSH	BX
	PUSH	DS
	PUSH	SI
	MOV	BX,1
	invoke	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI 
					;hkn; to sft entry
	JC	TRIPOPJ
	MOV	BX,[SI].SF_FLAGS
	TESTB	BX,sf_isnet			; output to NET?
	JNZ	TRIPOPJ 			; if so, no echo
	TESTB	BX,devid_device 		; output to file?
	JZ	TRIPOPJ 			; if so, no echo
	MOV	BX,4
	invoke	GET_IO_SFT
	JC	TRIPOPJ
	TESTB	[SI].SF_FLAGS,sf_net_spool	; StdPrn redirected?
	JZ	LISSTRT2J			; No, OK to echo
	MOV	BYTE PTR [PFLAG],0		; If a spool, NEVER echo
TRIPOPJ:
	JMP	TRIPOP

LISSTRT2J:
	JMP	LISSTRT2

CTRLOUT:
	CMP	AL,c_CR
	JZ	ZERPOS
	CMP	AL,c_BS
	JZ	BACKPOS
	CMP	AL,c_HT
	JNZ	OUTCH
	MOV	AL,[CARPOS]
	OR	AL,0F8H
	NEG	AL

	entry	TAB

	PUSH	CX
	MOV	CL,AL
	MOV	CH,0
	JCXZ	POPTAB
TABLP:
	MOV	AL," "
	invoke	OUTT
	LOOP	TABLP
POPTAB:
	POP	CX
	return

ZERPOS:
	MOV	BYTE PTR [CARPOS],0
	JMP	OUTCH
OUTJ:	JMP	OUTT

BACKPOS:
	DEC	BYTE PTR [CARPOS]
	JMP	OUTCH

	entry	BUFOUT
	CMP	AL," "
	JAE	OUTJ		;Normal char
	CMP	AL,9
	JZ	OUTJ		;OUT knows how to expand tabs

ifdef	DBCS				; MSKK01 07/14/89
ifdef	JAPAN				; MSKK01 07/14/89

; convert CONTROL-U and CONTROL-T to ^U ^T in KANJI DOS

else

;DOS 3.3  7/14/86
	CMP	AL,"U"-"@"      ; turn ^U to section symbol
	JZ	CTRLU
	CMP	AL,"T"-"@"      ; turn ^T to paragraph symbol
	JZ	CTRLU
endif
else
;DOS 3.3  7/14/86
	CMP	AL,"U"-"@"      ; turn ^U to section symbol
	JZ	CTRLU
	CMP	AL,"T"-"@"      ; turn ^T to paragraph symbol
	JZ	CTRLU
endif
NOT_CTRLU:
;DOS 3.3  7/14/86

	PUSH	AX
	MOV	AL,"^"
	invoke	OUTT		;Print '^' before control chars
	POP	AX
	OR	AL,40H		;Turn it into Upper case mate
CTRLU:
	invoke	OUTT
	return
EndProc $STD_CON_OUTPUT

	BREAK	<$STD_AUX_INPUT - System Call 3>

;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_INPUT - System Call 3
;
;	$STD_AUX_INPUT returns a character from Aux Input
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_AUX_INPUT,NEAR   ;System call 3

	invoke	STATCHK
	MOV	BX,3
	invoke	GET_IO_SFT
	retc
	JMP	SHORT TAISTRT
AUXILP:
	invoke	SPOOLINT
TAISTRT:
	MOV	AH,1
	invoke	IOFUNC
	JZ	AUXILP
	XOR	AH,AH
	invoke	IOFUNC
	return
EndProc $STD_AUX_INPUT


	BREAK	<$STD_AUX_OUTPUT, $STD_PRINTER_OUTPUT, fcn 4,5>
;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_OUTPUT - Output character to AUX
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_AUX_OUTPUT,NEAR   ;System call 4

	PUSH	BX
	MOV	BX,3
	JMP	SHORT SENDOUT

EndProc $STD_AUX_OUTPUT


;
;----------------------------------------------------------------------------
;
;**	$STD_PRINTER_OUTPUT - Output character to printer
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_PRINTER_OUTPUT,NEAR   ;System call 5

	PUSH	BX
	MOV	BX,4

SENDOUT:
	MOV	AL,DL
	PUSH	AX
	invoke	STATCHK
	POP	AX
	PUSH	DS
	PUSH	SI
LISSTRT2:
	invoke	RAWOUT2
TRIPOP:
	POP	SI
	POP	DS
	POP	BX
	return
EndProc $STD_PRINTER_OUTPUT

	BREAK	<$STD_CON_INPUT_STATUS - System Call 11>
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_STATUS - System Call 11
;
;	Check console input status
;
;	ENTRY	none
;	EXIT	AL = -1 character available, = 0 no character
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_CON_INPUT_STATUS,NEAR	 ;System call 11

	invoke	STATCHK
	MOV	AL,0			; no xor!!
	retz
	OR	AL,-1
	return
EndProc $STD_CON_INPUT_STATUS

	BREAK	<$STD_CON_INPUT_FLUSH - System call 12>
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_FLUSH - System Call 12
;
;	Flush console input buffer and perform call in AL
;
;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
;		return arguments for the fcn supplied in (AL)
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_CON_INPUT_FLUSH,NEAR	;System call 12

	PUSH	AX
	PUSH	DX
	XOR	BX,BX
	invoke	GET_IO_SFT
	JC	BADJFNCON
	MOV	AH,4
	invoke	IOFUNC

BADJFNCON:
	POP	DX
	POP	AX
	MOV	AH,AL
	CMP	AL,1
	JZ	REDISPJ
	CMP	AL,6
	JZ	REDISPJ
	CMP	AL,7
	JZ	REDISPJ
	CMP	AL,8
	JZ	REDISPJ
	CMP	AL,10
	JZ	REDISPJ
	MOV	AL,0
	return

REDISPJ:
 IFDEF  DBCS			  ;AN000;
	mov	ds,[CurrentPDB]   ;AN000;
				  ;AN000; set DS same as one from COMMAND entry
 ENDIF
        invoke      DOCLI
	transfer    REDISP
EndProc $STD_CON_INPUT_FLUSH

DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\dev.asm ===
TITLE	DEV - Device call routines
	NAME	Dev


;**	Misc Routines to do 1-12 low level I/O and call devices
;
;	IOFUNC
;	DEVIOCALL
;	SETREAD
;	SETWRITE
;	DEVIOCALL2
;	DEV_OPEN_SFT
;	DEV_CLOSE_SFT
;	RW_SC
;	IN_SC
;	INVALIDATE_SC
;	VIRREAD
;	SC2BUF
;
;	Revision history:
;	    sudeepb 12-Mar-1991 Ported for NT DOSEm

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
ifdef NEC_98
	include dpb.inc
endif   ;NEC_98
	include sf.inc
	include dossvc.inc
	.cref
	.list

	i_need	IOXAD,DWORD
	i_need	IOSCNT,WORD
	i_need	DEVIOBUF,4
	i_need	IOCALL,BYTE
	i_need	IOMED,BYTE
	i_need	IORCHR,BYTE
	i_need	CALLSCNT,WORD
	i_need	DMAAdd,DWORD
	i_need	CallDevAd,DWORD
	i_need	CallXAD,DWORD
ifdef NEC_98
	i_need	DPBHead,DWORD
	i_need	ThisDPB,DWORD
endif   ;NEC_98
	i_need	ThisSFT,DWORD
	i_need	DevCall,DWORD
	i_need	VerFlg,BYTE
	i_need	HIGH_SECTOR,WORD	       ;AN000;
	i_need	CALLSSEC,WORD		       ;AN000;
	i_need	CALLNEWSC,DWORD 	       ;AN000;
	i_need	SC_CACHE_COUNT,WORD	       ;AN000;
	i_need	SC_CACHE_PTR,DWORD	       ;AN000;
	i_need	CURSC_SECTOR,WORD	       ;AN000;
	i_need	SEQ_SECTOR,DWORD	       ;AN000;
	i_need	SC_SECTOR_SIZE,WORD	       ;AN000;
	i_need	CURSC_DRIVE,BYTE	       ;AN000;
	i_need	SC_DRIVE,BYTE		       ;AN000;
	i_need	SC_STATUS,WORD		       ;AN000;
	i_need	SC_FLAG,BYTE		       ;AN000;
	i_need	TEMP_VAR,WORD		       ;AN000;
	i_need	TEMP_VAR2,WORD		       ;AN000;
	i_need	InterChar,BYTE	;AN000; interim character flag 2/13/KK
	i_need	InterCon,BYTE	;AN000; Console mode flag(1:interim mode) 2/13/KK
	i_need	SaveCurFlg,BYTE ;AN000; Console out mode(1:print & don't adv cursor) 2 /13/KK
	i_need	DDMOVE,BYTE	;AN000; flag for DWORD move
	i_need	DOS34_FLAG,WORD ;AN000;
	i_need	fshare,BYTE	;AN010; share flag

	i_need 	IoStatFail,BYTE	;SR; set if user failed on I24 in IOFUNC


DOSCODE	Segment

	ASSUME	CS:DOSCODE

Public DEV001S, DEV001E 		; Pathgen labels
DEV001s:
;		length of packets
LenTab	DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL,DRDWRHL

;		Error	Function

CmdTab	DB	86h,	DEVRD		; 0 input
	DB	86h,	DEVRDND 	; 1 input status
	DB	87h,	DEVWRT		; 2 output
	DB	87h,	DEVOST		; 3 output status
	DB	86h,	DEVIFL		; 4 input flush
	DB	86H,	DEVRDND 	; 5 input status with system WAIT
	DB	87H,	DEVWRT		; 6 output string
DEV001E:

	ASSUME	CS:DOSCODE, SS:DOSDATA

Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
;----------------------------------------------------------------------------
;
; Procedure Name : IOFUNC
;
; Inputs:
;	DS:SI Points to SFT
;	AH is function code
;		= 0 Input
;		= 1 Input Status
;		= 2 Output
;		= 3 Output Status
;		= 4 Flush
;		= 5 Input Status - System WAIT invoked for K09 if no char
;				   present.
;		= 6 Output String (sudeepb 28-Jul-1992 added for NT console
;				   performance)
;	AL = character if output
;	ES:DI - string pointer if function 6
;	CX - count of characters in string for function 6
; Function:
;	Perform indicated I/O to device or file
; Outputs:
;	AL is character if input
;	If a status call
;		zero set if not ready
;		zero reset if ready (character in AL for input status)
; For regular files:
;	Input Status
;		Gets character but restores position
;		Zero set on EOF
;	Input
;		Gets character advances position
;		Returns ^Z on EOF
;	Output Status
;		Always ready
; AX altered, all other registers preserved
;----------------------------------------------------------------------------

procedure   IOFUNC,NEAR

	Assert	ISSFT,<DS,SI>,"IOFUNC"

	cmp	ah,6
	jne	io_old
	MOV	WORD PTR [IOXAD+2],ES	; DS:DX is the string
	MOV	WORD PTR [IOXAD],DI
	MOV	WORD PTR [IOSCNT],cx	; char count
	jmp	short io_com

io_old:
	MOV	WORD PTR [IOXAD+2],SS	; SS override for IOXAD, IOSCNT,
					; DEVIOBUF

					; DEVIOBUF is in DOSDATA
	MOV	WORD PTR [IOXAD],OFFSET DOSDATA:DEVIOBUF
	MOV	WORD PTR [IOSCNT],1
	MOV	WORD PTR [DEVIOBUF],AX

io_com:
	TESTB	[SI].SF_FLAGS,devid_device
	JNZ	IOTo33								;AN000;
	JMP	IOTOFILE							;AN000;
IOTO33:
	save_world
	MOV	DX,DS
	MOV	BX,SS
	MOV	DS,BX
	MOV	ES,BX

	ASSUME	DS:DOSDATA

	XOR	BX,BX
	cmp	ah,5		    ; system wait enabled?
	jnz	no_sys_wait
	or	bx,0400H	    ; Set bit 10 in status word for driver
				    ; It is up to device driver to carry out
				    ; appropriate action.
no_sys_wait:
	MOV	[IOCALL.REQSTAT],BX
	XOR	BX,BX
	MOV	BYTE PTR [IOMED],BL

	MOV	BL,AH			; get function
	MOV	AH,LenTab[BX]
	SHL	BX,1
	MOV	CX,WORD PTR CmdTab[BX]
	MOV	BX,OFFSET DOSDATA:IOCALL; IOCALL is in DOSDATA
	MOV	[IOCALL.REQLEN],AH
	MOV	[IOCALL.REQFUNC],CH
 IFDEF  DBCS				;AN000;
;----------------------------- Start of DBCS 2/13/KK
	PUSH	CX			;AN000;
	MOV	CL, [InterCon]		;AN000;
	CMP	CH, DEVRD		;AN000; 0 input
	JZ	SETIN			;AN000;
	CMP	CH, DEVRDND		;AN000; 1(5) input status without(with) system WAIT
	JZ	SETIN			;AN000;
	MOV	CL, [SaveCurflg]	;AN000;
	CMP	CH, DEVWRT		;AN000; 2 output
	JZ	CHKERROUT		;AN000;
	XOR	CL,CL			;AN000; else, do normal
SETIN:					;AN000;
	MOV	BYTE PTR [IoMed], CL	;AN000; set interim I/O indication
	POP	CX			;AN000;
;----------------------------- End of DBCS 2/13/KK
 ENDIF					;AN000;
	MOV	DS,DX
ASSUME	DS:NOTHING
	CALL	DEVIOCALL
	MOV	DI,[IOCALL.REQSTAT]	; SS override
	.errnz	STERR-8000h
	and	di,di
	js	DevErr
OkDevIO:
	MOV	AX,SS
	MOV	DS,AX

	ASSUME	DS:DOSDATA

 IFDEF  DBCS			;AN000;
	MOV	[InterChar],0	;AN000; reset interim character flag  2/13/KK
	TEST	DI,Ddkey	;AN000; is this a dead key (interim char)? 2/13/KK
	JZ	NotInterim	;AN000; no, flag already reset...	   2/13/KK
	INC	[InterChar]	;AN000; yes, set flag for future	   2/13/KK
NotInterim:			;AN000; 				   2/13/KK
 ENDIF				;AN000;
	CMP	CH,DEVRDND
	JNZ	DNODRD
	MOV	AL,BYTE PTR [IORCHR]
	MOV	[DEVIOBUF],AL

DNODRD: MOV	AH,BYTE PTR [IOCALL.REQSTAT+1]
	NOT	AH			; Zero = busy, not zero = ready
	AND	AH,STBUI SHR 8

QuickReturn:				;AN000; 2/13/KK
	restore_world
ASSUME	DS:NOTHING

	; We return ax = -1 if the user failed on I24. This is the case if 
	; IoStatFail = -1 (set after return from the I24)
	;

	pushf
	mov	al,ss:IoStatFail	;assume fail error
	cbw				;sign extend to word
	cmp	ax,-1
	jne	not_fail_ret
	inc	ss:IoStatFail
	popf
	ret
not_fail_ret:

	MOV	AX,WORD PTR [DEVIOBUF]	;ss override
	popf
	return

 IFDEF  DBCS				;AN000;
;------------------------------ Start of DBCS 2/13/KK
CHKERROUT:				;AN000;
	MOV	DS, DX			;AN000;
	TESTB	[SI].SF_FLAGS, devid_device_con_out	;AN000; output to console ?
	JNZ	GOOD			;AN000; yes
	CMP	CL, 01			;AN000; write interim ?
	JNZ	GOOD			;AN000; no,
	POP	CX			;AN000;
	JMP	SHORT QuickReturn	;AN000; avoid writting interims to other than
					;AN000; console device
GOOD:					;AN000;
	PUSH	SS			;AN000;
	POP	DS			;AN000;
	JMP	SETIN			;AN000;
;------------------------------ End of DBCS 2/13/KK
 ENDIF					;AN000;
DevErr:
	MOV	AH,CL
	invoke	CHARHARD
	CMP	AL,1
	JNZ	NO_RETRY
	restore_world			;hkn; use macro
	JMP	IOFUNC

NO_RETRY:
	
	;
	; Know user must have wanted Ignore OR Fail.	Make sure device shows ready
	; ready so that DOS doesn't get caught in a status loop when user 
	; simply wants to ignore the error.
	;
	; SR; If fail wanted by user set ax to special value (ax = -1). This 
	; should be checked by the caller on return
	;

					; SS override
	AND	BYTE PTR [IOCALL.REQSTAT+1], NOT (STBUI SHR 8)

	; SR;
	; Check if user failed
	;

	cmp	al,3
	jnz	not_fail
	dec	IoStatFail		;set flag indicating fail on I24
not_fail:
	JMP	OKDevIO

IOTOFILE:
	SAVE <BX,CX,DX,SI,DI,DS,ES,BP>

ASSUME  DS:NOTHING

	push	ds
	pop	es
	MOV	CX,WORD PTR [IOXAD+2]
	MOV	DS,CX
	MOV	DX,WORD PTR [IOXAD]	; DS;DX -> buffer
	mov	cx,1

	OR	AH,AH
        JZ      IOIN_Wrap
	DEC	AH
	JZ	IOIST
	DEC	AH
	JZ	IOUT
        jmp     res_file                ; NON ZERO FLAG FOR OUTPUT STATUS

	; Input Status case, read without seeking
IOIST:
        push    si
        CALL    IOIN
        pop     si
	jz	ioist_ret		; ZF set if EOF
        push    ax
        lahf
        push    ax
	call	GET_NT_HANDLE
	mov	bl,1
	mov	dx,-1
	mov	cx,dx
        HRDSVC  SVC_DEMCHGFILEPTR       ; LSEEK back 1
        pop     ax
        sahf
	pop	ax
ioist_ret:
        jmp     res_file

	; Output case
IOUT:
        call    GET_NT_HANDLE
	cmp	al, al			; set zero flag so demwrite won't do lseek
        HRDSVC  SVC_DEMWRITE
        jmp     res_file                ; Zero flag does'nt matter

GET_NT_HANDLE:				; AX:BP is NT handle
	mov	bp,word ptr es:[si].sf_NTHandle
	mov	ax,word ptr es:[si].sf_NTHandle+2
	ret
IOIN:
	call	GET_NT_HANDLE
	OR	[DOS34_FLAG],Disable_EOF_I24
	cmp	al, al			; set zero flag so demread won't do lseek
        HRDSVC  SVC_DEMREAD
	AND	[DOS34_FLAG],NO_Disable_EOF_I24
ioin_1:
	OR	AX,AX			; Check EOF
	MOV	AL,[DEVIOBUF]		; Get byte from trans addr
        jnz     ioin_2
        MOV     AL,1AH                  ; ^Z if no bytes
ioin_2:
        return

	; Input Case
IOIN_Wrap:
        call    IOIN
	jnz	res_file
;; eof, check for piping
	test	ES:[DI.SF_FLAGS], sf_nt_pipe_in ;;the handle is a pipe?
	jz	res_file			;; no, do the normal thing
;;Can not return EOF even though we read nothing from the file.
;;This loop can not be done in 32bits because it blocks h/w interrupts
wait_pipe_data_eof:
	call	GET_NT_HANDLE
	SVC	SVC_DEMPIPEFILEDATAEOF
	jz	wait_pipe_data_eof		;;nothing, continue to wait
	jnc	pipe_wait_done			;;we got something, go read it
;; EOF encountered				;; real EOF
	and	WORD PTR ES:[DI.SF_FLAGS], NOT(sf_nt_pipe_in); turn it off
	mov	WORD PTR ES:[DI.SF_SIZE], BP	;; assign righ file size to sft
	mov	WORD PTR ES:[DI.SF_SIZE + 2], AX
	; fall through because new data could be available
pipe_wait_done:
	call	IOIN
res_file:
	RESTORE <BP,ES,DS,DI,SI,DX,CX,BX>
	return

EndProc IOFUNC

Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>


;**	Dev_Open_SFT - Open the Device for an SFT
;
;	Dev_Open_SFT issues an open call to the device associated with
;	the SFT.
;
;	ENTRY	(ES:DI) = SFT
;	EXIT	none
;	USES	all

procedure   DEV_OPEN_SFT,NEAR

	Assert	ISSFT,<ES,DI>,"Dev_Open_SFT"

	Save_World			; use macro
	MOV	AL,DEVOPN
	JMP	SHORT DO_OPCLS

EndProc DEV_OPEN_SFT

;---------------------------------------------------------------------------
;
; Procedure Name : DEV_CLOSE_SFT
;
; Inputs:
;	ES:DI Points to SFT
; Function:
;	Issue a CLOSE call to the correct device
; Outputs:
;	None
; ALL preserved
;
;---------------------------------------------------------------------------

procedure   DEV_CLOSE_SFT,NEAR

	Assert	ISSFT,<ES,DI>,"Dev_Close_SFT"

	Save_World			; use macro

	MOV	AL,DEVCLS

	;
	; Main entry for device open and close.  AL contains the function 
	; requested. Subtlety:  if Sharing is NOT loaded then we do NOT issue 
	; open/close to block devices.  This allows networks to function but 
	; does NOT hang up with bogus change-line code.
	;

	entry	DO_OPCLS

	; Is the SFT for the net?  If so, no action necessary.

	TESTB	es:[di].sf_Flags, SF_ISNET
	JNZ	OPCLS_DONE		; NOP on net SFTs
	XOR	AH,AH			; Unit
	TESTB	ES:[DI].SF_FLAGS,devid_device
	LES	DI,ES:[DI.sf_devptr]	; Get DPB or device
	JZ	OPCLS_DONE

	; We are about to call device open/close on a block driver.  If no 
	; sharing then just short circuit to done.

GOT_DEV_ADDR:				; ES:DI -> device
	TESTB	ES:[DI.SDEVATT],DEVOPCL
	JZ	OPCLS_DONE		; Device can't
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> device
OPCLS_RETRY:
	Context ES

					; DEVCALL is in DOSDATA
	MOV	DI,OFFSET DOSDATA:DEVCALL

	MOV	BX,DI
	PUSH	AX
	MOV	AL,DOPCLHL
	STOSB				; Length
	POP	AX
	XCHG	AH,AL
	STOSB				; Unit
	XCHG	AH,AL
	STOSB				; Command
	MOV	WORD PTR ES:[DI],0	; Status
	PUSH	AX			; Save Unit,Command
	invoke	DEVIOCALL2
	MOV	DI,ES:[BX.REQSTAT]
	.errnz	STERR-8000h
	and	di,di
	Jns	OPCLS_DONEP		; No error
	TESTB	[SI.SDEVATT],DEVTYP
	JZ	BLKDEV
	MOV	AH,86H			; Read error in data, Char dev
	JMP	SHORT HRDERR

BLKDEV:
	MOV	AL,CL			; Drive # in AL
	MOV	AH,6			; Read error in data, Blk dev
HRDERR:
	invoke	CHARHARD
	CMP	AL,1
	JNZ	OPCLS_DONEP		; IGNORE or FAIL
					;  Note that FAIL is essentually IGNORED
	POP	AX			; Get back Unit, Command
	JMP	OPCLS_RETRY

OPCLS_DONEP:
	POP	AX			; Clean stack
OPCLS_DONE:

	Restore_World			;hkn; use macro
	return

EndProc DEV_CLOSE_SFT

Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>


;**	DevIoCall  - Call Device
;
;	ENTRY	DS:SI Points to device SFT
;		ES:BX Points to request data
;	EXIT	DS:SI -> Device driver
;	USES	DS:SI,AX

;**	DevIoCall2 - Call Device
;
;	ENTRY	DS:SI Points to Device Header
;		ES:BX Points to request data
;	EXIT	DS:SI -> Device driver
;	USES	DS:SI,AX

procedure   DEVIOCALL,NEAR

					; SS override for CALLSSEC, 
					; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
	Assert	ISSFT,<DS,SI>,"DevIOCall"
	LDS	SI,[SI.sf_devptr]

entry	DEVIOCALL2

ifdef NEC_98
	EnterCrit   critDevice

	TESTB	[SI.SDEVATT],DevTyp    ;AN000; >32mb   block device ?
	JNZ	chardev2	       ;AN000; >32mb   no
	CMP	ES:[BX.REQFUNC],DEVRD  ;AN000; >32mb   read ?
	JZ	chkext		       ;AN000; >32mb   yes
	CMP	ES:[BX.REQFUNC],DEVWRT ;AN000; >32mb   write ?
	JZ	chkext		       ;AN000; >32mb   yes
	CMP	ES:[BX.REQFUNC],DEVWRTV;AN000; >32mb   write/verify ?
	JNZ	chardev2	       ;AN000; >32mb   no
chkext:
	CALL	RW_SC		       ;AN000;LB. use secondary cache if there
	JC	dev_exit	       ;AN000;LB. done

	TESTB	[SI.SDEVATT],EXTDRVR   ;AN000;>32mb   extended driver?
	JZ	chksector	       ;AN000;>32mb   no
	ADD	BYTE PTR ES:[BX],8     ;AN000;>32mb   make length to 30
	MOV	AX,[CALLSSEC]	       ;AN000;>32mb
	MOV	[CALLSSEC],-1	       ;AN000;>32mb   old sector  =-1
	MOV	WORD PTR [CALLNEWSC],AX   ;AN000;>32mb	 new sector  =
	MOV	AX,[HIGH_SECTOR]       ;AN000; >32mb   low sector,high sector
	MOV	WORD PTR [CALLNEWSC+2],AX  ;AN000; >32mb
	JMP	short chardev2	       ;AN000; >32mb
chksector:			       ;AN000; >32mb
	CMP	[HIGH_SECTOR],0        ;AN000; >32mb   if >32mb
	JZ	chardev2	       ;AN000; >32mb   then fake error
	MOV	ES:[BX.REQSTAT],STERR+STDON+ERROR_I24_NOT_DOS_DISK  ;AN000; >32mb
	JMP	SHORT dev_exit	       ;AN000; >32mb

chardev2:			       ;AN000;

	;
	; As above only DS:SI points to device header on entry, and DS:SI is
	; preserved
	;
endif 	;NEC_98

	MOV	AX,[SI.SDEVSTRAT]
	MOV	WORD PTR [CALLDEVAD],AX
	MOV	WORD PTR [CALLDEVAD+2],DS
	CALL	DWORD PTR [CALLDEVAD]
	MOV	AX,[SI.SDEVINT]
	MOV	WORD PTR [CALLDEVAD],AX
	CALL	DWORD PTR [CALLDEVAD]
ifdef NEC_98
	CALL	VIRREAD 	;AN000;LB. move data from SC to buffer
	JC	chardev2	;AN000;LB. bad sector or exceeds max sec
dev_exit:
	LeaveCrit   critDevice
endif   ;NEC_98
	return
EndProc DEVIOCALL

Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : SETREAD, SETWRITE
;
; Inputs:
;	DS:BX = Transfer Address
;	CX = Record Count
;	DX = Starting Record
;	AH = Media Byte
;	AL = Unit Code
; Function:
;	Set up the device call header at DEVCALL
; Output:
;	ES:BX Points to DEVCALL
; No other registers effected
;
;---------------------------------------------------------------------------

procedure   SETREAD,NEAR

	PUSH	DI
	PUSH	CX
	PUSH	AX
	MOV	CL,DEVRD
SETCALLHEAD:
	MOV	AL,DRDWRHL
	PUSH	SS
	POP	ES

					; DEVCALL is in DOSDATA
	MOV	DI,OFFSET DOSDATA:DEVCALL

	STOSB				; length
	POP	AX
	STOSB				; Unit
	PUSH	AX
	MOV	AL,CL
	STOSB				; Command code
	XOR	AX,AX
	STOSW				; Status
	ADD	DI,8			; Skip link fields
	POP	AX
	XCHG	AH,AL
	STOSB				; Media byte
	XCHG	AL,AH
	PUSH	AX
	MOV	AX,BX
	STOSW
	MOV	AX,DS
	STOSW				; Transfer addr
	POP	CX			; Real AX
	POP	AX			; Real CX
	STOSW				; Count
	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
	STOSW				; Start
	XCHG	AX,CX
	XCHG	DX,CX
	POP	DI
					; DEVCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DEVCALL
	return

	entry	SETWRITE
ASSUME	DS:NOTHING,ES:NOTHING

; Inputs:
;	DS:BX = Transfer Address
;	CX = Record Count
;	DX = Starting Record
;	AH = Media Byte
;	AL = Unit Code
; Function:
;	Set up the device call header at DEVCALL
; Output:
;	ES:BX Points to DEVCALL
; No other registers effected

	PUSH	DI
	PUSH	CX
	PUSH	AX
	MOV	CL,DEVWRT
	ADD	CL,[VERFLG]		; SS override
	JMP	SHORT SETCALLHEAD
EndProc SETREAD

ifdef NEC_98
Break	<RW_SC -- Read Write Secondary Cache>
;---------------------------------------------------------------------------
;
; Procedure Name : RW_SC
;
; Inputs:
;	 [SC_CACHE_COUNT]= secondary cache count
;	 [SC_STATUS]= SC validity status
;	 [SEQ_SECTOR]= last sector read
; Function:
;	Read from or write through secondary cache
; Output:
;	ES:BX Points to DEVCALL
;	carry clear, I/O is not done
;		     [SC_FLAG]=1 if continuos sectors will be read
;	carry set, I/O is done
;
;----------------------------------------------------------------------------


procedure   RW_SC,NEAR		;AN000;

	; SS override for all variables used.

	CMP	[SC_CACHE_COUNT],0	;AN000;LB. secondary cache exists?
	JZ	scexit4 		;AN000;LB. no, do nothing
	CMP	[CALLSCNT],1		;AN000;LB. sector count = 1 (buffer I/O)
	JNZ	scexit4 		;AN000;LB. no, do nothing
	PUSH	CX			    ;AN000;;LB.
	PUSH	DX			    ;AN000;;LB. yes
	PUSH	DS			    ;AN000;;LB. save registers
	PUSH	SI			    ;AN000;;LB.
	PUSH	ES			    ;AN000;;LB.
	PUSH	DI			    ;AN000;;LB.
	MOV	DX,WORD PTR [CALLSSEC]	    ;AN000;;LB.  starting sector
	CMP	BYTE PTR [DEVCALL.REQFUNC],DEVRD ;AN000;LB. read ?		      ;AN000;
	JZ	doread			;AN000;LB. yes				      ;AN000;
	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC		      ;AN000;
	JMP	scexit2 		    ;AN000;LB. back to normal		      ;AN000;
scexit4:				    ;AN000;				       ;AN000;
	CLC				    ;AN000;LB. I/O not done yet 	  ;AN000;
	return				    ;AN000;LB.				  ;AN000;
doread: 				    ;AN000;				       ;AN000;
	CALL	SC2BUF			    ;AN000;LB. check if in SC		      ;AN000;
	JC	readSC			    ;AN000;LB.					  ;AN000;
	MOV	[DEVCALL.REQSTAT],STDON     ;AN000;LB. fake done and ok 	  ;AN000;
	STC				    ;AN000;LB. set carry		  ;AN000;
	JMP	short saveseq		    ;AN000;LB. save seq. sector #	  ;AN000;
readSC: 				    ;AN000;
	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
	MOV	CX,WORD PTR [CALLSSEC]	    ;AN000;;LB. saved sequential sector
	SUB	CX,WORD PTR [SEQ_SECTOR]    ;AN000;;LB. number
	SBB	AX,WORD PTR [SEQ_SECTOR+2]  ;AN000;;LB.
	CMP	AX,0			    ;AN000;;LB. greater than 64K
	JNZ	saveseq2		    ;AN000;;LB. yes,save seq. sector #
chklow: 									;AN000;
	CMP	CX,1			    ;AN000;;LB. <= 1
	JA	saveseq2		    ;AN000;;LB. no, not sequential
	MOV	[SC_STATUS],-1		    ;AN000;;LB. prsume all SC valid
	MOV	AX,[SC_CACHE_COUNT]	    ;AN000;;LB. yes, sequential
	MOV	[CALLSCNT],AX		    ;AN000;;LB. read continuous sectors
readsr:
	MOV	AX,WORD PTR [CALLXAD+2]     ;AN000;;LB. save buffer addr
	MOV	[TEMP_VAR2],AX		    ;AN000;;LB. in temp vars
	MOV	AX,WORD PTR [CALLXAD]	    ;AN000;;LB.
	MOV	[TEMP_VAR],AX		    ;AN000;;LB.
										;AN000;
	MOV	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;LB. use SC cache addr as	      ;AN000;
	MOV	WORD PTR [CALLXAD],AX	    ;AN000;LB. transfer addr		      ;AN000;
	MOV	AX,WORD PTR [SC_CACHE_PTR+2]  ;AN000;LB.			      ;AN000;
	MOV	WORD PTR [CALLXAD+2],AX       ;AN000;LB.			      ;AN000;
	MOV	[SC_FLAG],1		      ;AN000;LB. flag it for later	      ;AN000;
	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
	MOV	[CURSC_DRIVE],AL	    ;AN000;;LB. set current drive
	MOV	AX,WORD PTR [CALLSSEC]	    ;AN000;;LB. current sector
	MOV	[CURSC_SECTOR],AX	    ;AN000;;LB. set current sector
	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB.
	MOV	[CURSC_SECTOR+2],AX	    ;AN000;;LB.
saveseq2:				    ;AN000;
	CLC				    ;AN000;LB. clear carry		      ;AN000;
saveseq:				    ;AN000;				       ;AN000;
	MOV	AX,[HIGH_SECTOR]	    ;AN000;LB. save current sector #	  ;AN000;
	MOV	WORD PTR [SEQ_SECTOR+2],AX  ;AN000;LB. for access mode ref.	  ;AN000;
	MOV	AX,[CALLSSEC]		    ;AN000;LB.				  ;AN000;
	MOV	WORD PTR [SEQ_SECTOR],AX    ;AN000;LB.				  ;AN000;
	JMP	short scexit		    ;AN000;LB.				  ;AN000;
										;AN000;
scexit2:				    ;AN000;LB.				      ;AN000;
	CLC				    ;AN000;LB.	       clear carry	      ;AN000;
scexit: 				    ;AN000;				       ;AN000;
	POP	DI			    ;AN000;;LB.
	POP	ES			    ;AN000;;LB. restore registers
	POP	SI			    ;AN000;;LB.
	POP	DS			    ;AN000;;LB.
	POP	DX			    ;AN000;;LB.
	POP	CX			    ;AN000;;LB.
	return				    ;AN000;;LB.
										;AN000;
EndProc RW_SC				    ;AN000;

Break	<IN_SC -- check if in secondary cache>
;--------------------------------------------------------------------------
;
; Procedure Name : IN_SC
;
; Inputs:  [SC_DRIVE]= requesting drive
;	   [CURSC_DRIVE]= current SC drive
;	   [CURSC_SECTOR] = starting scetor # of SC
;	   [SC_CACHE_COUNT] = SC count
;	   [HIGH_SECTOR]:DX= sector number
; Function:
;	Check if the sector is in secondary cache
; Output:
;	carry clear, in SC
;	   CX= the index in the secondary cache
;	carry set, not in SC
;
;---------------------------------------------------------------------------

procedure   IN_SC,NEAR		    ;AN000;

	; SS override for all variables used

	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
	CMP	AL,[CURSC_DRIVE]	    ;AN000;;LB. same as SC drive
	JNZ	outrange2		    ;AN000;;LB. no
	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
	SUB	CX,WORD PTR [CURSC_SECTOR]    ;AN000;;LB. number
	SBB	AX,WORD PTR [CURSC_SECTOR+2]  ;AN000;;LB.
	CMP	AX,0			    ;AN000;;LB. greater than 64K
	JNZ	outrange2		    ;AN000;;LB. yes
	CMP	CX,[SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
	JAE	outrange2		    ;AN000;;LB. yes
	CLC				    ;AN000;;LB. clear carry
	JMP	short inexit		    ;AN000;;LB. in SC
outrange2:				    ;AN000;;LB. set carry
	STC				    ;AN000;;LB.
inexit: 				    ;AN000;;LB.
	return				    ;AN000;;LB.

EndProc IN_SC				    ;AN000;

Break	<INVALIDATE_SC - invalide secondary cache>
;---------------------------------------------------------------------------
;
; Procedure Name : Invalidate_Sc
;
; Inputs:  [SC_DRIVE]= requesting drive
;	   [CURSC_DRIVE]= current SC drive
;	   [CURSC_SECTOR] = starting scetor # of SC
;	   [SC_CACHE_COUNT] = SC count
;	   [SC_STAUS] = SC status word
;	   [HIGH_SECTOR]:DX= sceotor number
;
; Function:
;	invalidate secondary cache if in there
; Output:
;	[SC_STATUS] is updated
;---------------------------------------------------------------------------

procedure   INVALIDATE_SC,NEAR	    ;AN000;

	; SS override for all variables used

	CALL	IN_SC			    ;AN000;;LB. in secondary cache
	JC	outrange		    ;AN000;;LB. no
	MOV	AX,1			    ;AN000;;LB. invalidate the sector
	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
	NOT	AX			    ;AN000;;LB.
	AND	[SC_STATUS],AX		    ;AN000;;LB. save the status
outrange:				    ;AN000;;LB.
	return				    ;AN000;;LB.

EndProc INVALIDATE_SC			    ;AN000;


Break	<VIRREAD- virtually read data into buffer>
;--------------------------------------------------------------------------
;
; Procedure Name : SC_FLAG
;
; Inputs:  SC_FLAG = 0 , no sectors were read into SC
;		     1, continous sectors were read into SC
; Function:
;	   Move data from SC to buffer
; Output:
;	 carry clear, data is moved to buffer
;	 carry set, bad sector or exceeds maximum sector
;	   SC_FLAG =0
;	   CALLSCNT=1
;	   SC_STATUS= -1 if succeeded
;
;		       0 if failed
;--------------------------------------------------------------------------

procedure   VIRREAD,NEAR	    ;AN000;

	; SS override for all variables used

	CMP	[SC_FLAG],0		    ;AN000;;LB.  from SC fill
	JZ	sc2end			    ;AN000;;LB.  no
	MOV	AX,[TEMP_VAR2]		    ;AN000;;LB. restore buffer addr
	MOV	WORD PTR [CALLXAD+2],AX     ;AN000;;LB.
	MOV	AX,[TEMP_VAR]		    ;AN000;;LB.
	MOV	WORD PTR [CALLXAD],AX	    ;AN000;;LB.
	MOV	[SC_FLAG],0		    ;AN000;;LB.  reset sc_flag
	MOV	[CALLSCNT],1		    ;AN000;;LB.  one sector transferred

	TESTB	[DEVCALL.REQSTAT],STERR     ;AN000;;LB.  error?
	JNZ	scerror 		    ;AN000;;LB. yes
	PUSH	DS			    ;AN000;;LB.
	PUSH	SI			    ;AN000;;LB.
	PUSH	ES			    ;AN000;;LB.
	PUSH	DI			    ;AN000;;LB.
	PUSH	DX			    ;AN000;;LB.
	PUSH	CX			    ;AN000;;LB.
	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buffer
	POP	CX			    ;AN000;;LB.
	POP	DX			    ;AN000;;LB.
	POP	DI			    ;AN000;;LB.
	POP	ES			    ;AN000;;LB.
	POP	SI			    ;AN000;;LB.
	POP	DS			    ;AN000;;LB.
	JMP	SHORT sc2end		    ;AN000;;LB. return

scerror:				    ;AN000;
	MOV	[CALLSCNT],1		    ;AN000;;LB. reset sector count to 1
	MOV	[SC_STATUS],0		    ;AN000;;LB. invalidate all SC sectors
	MOV	[CURSC_DRIVE],-1	    ;AN000;;LB. invalidate drive
	STC				    ;AN000;;LB. carry set
	return				    ;AN000;;LB.

sc2end: 				    ;AN000;
	CLC				    ;AN000;;LB. carry clear
	return				    ;AN000;;LB.

EndProc VIRREAD 			    ;AN000;

Break	<SC2BUF- move data from SC to buffer>
;----------------------------------------------------------------------------
;
; Procedure Name : SC2BUF
;
; Inputs:  [SC_STATUS] = SC validity status
;	   [SC_SECTOR_SIZE] = request sector size
;	   [SC_CACHE_PTR] = pointer to SC
; Function:
;	   Move data from SC to buffer
; Output:
;	   carry clear, in SC  and data is moved
;	   carry set, not in SC and data is not moved
;---------------------------------------------------------------------------

procedure   SC2BUF,NEAR 	    ;AN000;

	; SS override for all variables used

	CALL	IN_SC			    ;AN000;;LB. in secondary cache
	JC	noSC			    ;AN000;;LB. no
	MOV	AX,1			    ;AN000;;LB. check if valid sector
	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
	TEST	[SC_STATUS],AX		    ;AN000;;LB.
	JZ	noSC			    ;AN000;;LB. invalid
entry SC2BUF2				    ;AN000;
	MOV	AX,CX			    ;AN000;;LB. times index with
	MUL	[SC_SECTOR_SIZE]	    ;AN000;;LB. sector size
	ADD	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;;LB. add SC starting addr
	ADC	DX,WORD PTR [SC_CACHE_PTR+2];AN000;;LB.
	MOV	DS,DX			    ;AN000;    ;LB. DS:SI-> SC sector addr
	MOV	SI,AX			    ;AN000;    ;LB.
	MOV	ES,WORD PTR [CALLXAD+2]     ;AN000;    ;LB. ES:DI-> buffer addr
	MOV	DI,WORD PTR [CALLXAD]	    ;AN000;    ;LB.
	MOV	CX,[SC_SECTOR_SIZE]	    ;AN000;    ;LB. count= sector size
	SHR	CX,1			    ;AN000;    ;LB. may use DWORD move for 386
entry MOVWORDS				    ;AN000;
	CMP	[DDMOVE],0		    ;AN000;    ;LB. 386 ?
	JZ	nodd			    ;AN000;    ;LB. no
	SHR	CX,1			    ;AN000;    ;LB. words/2
	DB	66H			    ;AN000;    ;LB. use double word move
nodd:
	REP	MOVSW			    ;AN000;    ;LB. move to buffer
	CLC				    ;AN000;    ;LB. clear carry
	return				    ;AN000;    ;LB. exit
noSC:					    ;AN000;
	STC				    ;AN000;    ;LB. set carry
sexit:					    ;AN000;
	return				    ;AN000;    ;LB.

EndProc SC2BUF
endif   ;NEC_98

DOSCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\dir2.asm ===
TITLE	DIR2 - Directory and path cracking
	NAME	Dir2

;**	Main Path cracking routines, low level search routines and device
;	  name detection routines
;
;	GETPATH
;	GetPathNoSet
;	CHKDEV
;	ROOTPATH
;	FINDPATH
;	StartSrch
;	MatchAttributes
;	DEVNAME
;	Build_device_ent
;	Validate_CDS
;	CheckThisDevice
;
;	Revision history:
;
;		A000  version 4.00  Jan. 1988
;		A001  PTM 3564 -- search using fastopen
;
; 		M026 - set Attrib before invoking devname. 9/17/90

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include fastopen.inc
	include curdir.inc
	include dossvc.inc
ifdef NEC_98
	include dpb.inc
endif   ;NEC_98
	.cref
	.list


	i_need	NoSetDir,BYTE
	i_need	EntFree,WORD
	i_need	DirStart,WORD
	i_need	LastEnt,WORD
	i_need	WFP_START,WORD
	i_need	CURR_DIR_END,WORD
	i_need	CurBuf,DWORD
	i_need	THISCDS,DWORD
	i_need	Attrib,BYTE
	i_need	SAttrib,BYTE
	i_need	VolID,BYTE
	i_need	Name1,BYTE
	i_need	ThisDPB,DWORD
	i_need	EntLast,WORD
	i_need	Creating,BYTE
	i_need	NULDEV,DWORD
	i_need	DEVPT,DWORD
	i_need	DEVFCB,BYTE
	i_need	ALLOWED,BYTE
	i_need	EXTERR_LOCUS,BYTE
	I_need	FastOpenFlg,BYTE	  ;DOS 3.3
	I_need	FastOpenTable,BYTE	  ;DOS 3.3
	I_need	Dir_Info_Buff,BYTE	  ;DOS 3.3
	I_need	FastOpen_Ext_Info,BYTE	  ;DOS 3.3
	I_need	CLUSNUM,WORD		  ;DOS 3.3
	I_need	Next_Element_Start,WORD   ;DOS 3.3
	I_need	HIGH_SECTOR,WORD	  ;AN000;>32mb
	I_need	DOS34_FLAG,WORD 	  ;AN000;>32mb
	I_need	CURDRV, BYTE


DOSCODE	Segment
	ASSUME	SS:DOSDATA,CS:DOSCODE

Break	<GETPATH -- PARSE A WFP>

;----------------------------------------------------------------------------
;
; Procedure Name : GETPATH
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
;		terminated; d:/ (note forward slash) indicates a real device).
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;	[SATTRIB] Is attribute of search, determines what files can be found
;	[NoSetDir] set
;	[THISDPB] set to DPB if disk otherwise garbage.
; Function:
;	Crack the path
; Outputs:
;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
;	Sets EXTERR_LOCUS = errLOC_Unk if char device
;	ID1 field of [THISCDS] updated appropriately
;	[ATTRIB] = [SATTRIB]
;	ES:BP Points to DPB
;	Carry set if bad path
;	   SI Points to path element causing failure
;	   Zero set
;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;	      start a search on the last directory
;	      CL is zero if there is a bad name in the path
;	      CL is non-zero if the name was simply not found
;		 [ENTFREE] may have free spot in directory
;		 [NAME1] is the name.
;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
;	   Zero reset
;	      File in middle of path or bad name in path or attribute mismatch
;		or path too long or malformed path
;	ELSE
;	   [CurBuf] = -1 if root directory
;	   [CURBUF] contains directory record with match
;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
;	   AH = device ID
;	      bit 7 of AH set if device SI and BX
;	      will point DOSGROUP relative The firclus
;	      field of the device entry contains the device pointer
;	   [NAME1] Has name looked for
;	   If last element is a directory zero is set and:
;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;	      are set up to start a search on it.
;	      unless [NoSetDir] is non zero in which case the return is
;	      like that for a file (except for zero flag)
;	   If last element is a file zero is reset
;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
;	      [LASTENT], [ENTLAST] are set to continue search of last
;	      directory for furthur matches on NAME1 via the NEXTENT
;	      entry point in FindEntry (or GETENT entry in GETENTRY in
;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
; DS preserved, Others destroyed
;---------------------------------------------------------------------------

;hkn; called from delete.asm , finfo.asm, mknode.asm and rename.asm. DS
;hkn; already set up at this point.

ifdef 0
procedure   GETPATH,near
	DOSAssume   <DS>,"GetPath"

	MOV	WORD PTR CREATING,DIRFREE*256+0	; Not Creating, not DEL *.*

; Same as GetPath only CREATING and DELALL already set

entry	GetPathNoSet
	MOV	[EXTERR_LOCUS],errLOC_Disk
	MOV	WORD PTR CurBuf,-1	; initial setting

; See if the input indicates a device that has already been detected.  If so,
; go build the guy quickly.  Otherwise, let findpath find the device.

	MOV	DI,Wfp_Start		; point to the beginning of the name
	CMP	WORD PTR [DI+1],'\' SHL 8 + ':'
	JZ	CrackIt

; Let ChkDev find it in the device list

	ADD	DI,3
	MOV	SI,DI			; let CHKDEV see the original name
	CALL	CHKDEV
	JC	InternalError
Build_devJ:
	MOV	AL,SAttrib
	MOV	Attrib,AL
	MOV	[EXTERR_LOCUS],errLOC_Unk ; In the particular case of
					; "finding" a char device
					; set LOCUS to Unknown. This makes
					; certain problems reported
					; by a certain 3 letter OEM go away.

; Take name in name1 and pack it back into where wfp_start points.  This
; guarantees wfp_start pointing to a canonical representation of a device.
; We are allowed to do this as GetPath is *ALWAYS* called before entering a
; wfp into the share set.
;
; We copy chars from name1 to wfp_start remembering the position of the last
; non-space seen +1.  This position is kept in DX.


;hkn; SS is DOSDATA
	Context ES

;hkn; NAME1 is in DOSDATA
	mov	si,offset DOSDATA:Name1

	mov	di,wfp_start
	mov	dx,di
	mov	cx,8			; 8 chars in device name
MoveLoop:
	lodsb
	stosb
	cmp	al," "
	jz	nosave
 IFDEF  DBCS				;AN000;;
;	cmp	al,81h			;AN000;; 2/23/KK
;	jne	notKanji		;AN000;; 2/23/KK
;	cmp	cx,1			;AN000; 2/23/KK
;	je	notKanji		;AN000; 2/23/KK
;	cmp	byte ptr [si],40h	;AN000; 2/23/KK
;	jne	notKanji		;AN000;; 2/23/KK
;	lodsb				;AN000;; 2/23/KK
;	stosb				;AN000;; 2/23/KK
;	dec	cx			;AN000;; 2/23/KK
;	jmp	nosave			;AN000;; 2/23/KK
;notKanji:				;AN000;; 2/23/KK
 ENDIF
	mov	dx,di
NoSave:
	loop	MoveLoop
;
; DX is the position of the last seen non-space + 1.  We terminate the name
; at this point.
;
	mov	di,dx
	mov	byte ptr [di],0 	; end of string
	invoke	Build_device_ent	; Clears carry sets zero
	INC	AL			; reset zero
	return

	assume	es:nothing

InternalError:
	JMP	InternalError		; freeze


; Start off at the correct spot.  Optimize if the current dir part is valid.

CrackIt:
	MOV	SI,[CURR_DIR_END]	; get current directory pointer
	CMP	SI,-1			; valid?
	JNZ	LOOK_SING		; Yes, use it.
	LEA	SI,[DI+3]		; skip D:\
LOOK_SING:
	Assert	ISDPB,<<WORD PTR THISDPB+2>,<WORD PTR THISDPB>>,"Crackit"
	MOV	Attrib,attr_directory+attr_system+attr_hidden
					; Attributes to search through Dirs
	LES	DI,THISCDS
	MOV	AX,-1
	MOV	BX,ES:[DI.curdir_ID]
	MOV	SI,[CURR_DIR_END]

; AX = -1
; BX = cluster number of current directory.  THis number is -1 if the media
;      has been uncertainly changed.
; SI = offset in DOSGroup into path to end of current directory text.  This
;      may be -1 if no current directory part has been used.

	CMP	SI,AX			; if Current directory is not part
	JZ	NO_CURR_D		; then we must crack from root
	CMP	BX,AX			; is the current directory cluster valid

; DOS 3.3  6/25/86
	JZ	NO_CURR_D		; no, crack form the root
	TEST	[FastOpenFlg],FastOpen_Set     ; for fastopen ?
	JZ	GOT_SEARCH_CLUSTER	       ; no
	PUSH	ES			; save registers
	PUSH	DI
	PUSH	CX
	PUSH	[SI-1]			; save \ and 1st char of next element
	PUSH	SI
	PUSH	BX

	MOV	BYTE PTR [SI-1],0	; call fastopen to look up cur dir info
	MOV	SI,[Wfp_Start]

;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
	MOV	BX,OFFSET DOSDATA:FastOpenTable
	MOV	DI,OFFSET DOSDATA:Dir_Info_Buff
	MOV	CX,OFFSET DOSDATA:FastOpen_Ext_Info
	MOV	AL,FONC_look_up
	PUSH	DS
	POP	ES
	CALL	DWORD PTR [BX.FASTOPEN_NAME_CACHING]
	JC	GO_Chk_end1			;fastopen not installed, or wrong drive. Go to Got_Srch_cluster
	CMP	BYTE PTR [SI],0 		;fastopen has current dir info?
	JE	GO_Chk_end			;yes. Go to got_serch_cluster
	stc
	jmp	short GO_Chk_end		;Go to No_Curr_D
GO_Chk_end1:
	clc
GO_Chk_end:					; restore registers
	POP	BX
	POP	SI
	POP	[SI-1]
	POP	CX
	POP	DI
	POP	ES
	JNC	GOT_SEARCH_CLUSTER		; crack based on cur dir

; DOS 3.3  6/25/86
;
; We must cract the path beginning at the root.  Advance pointer to beginning
; of path and go crack from root.

NO_CURR_D:
	MOV	SI,[WFP_START]
	LEA	SI,[SI+3]		; Skip "d:/"
	LES	BP,[THISDPB]		; Get ES:BP
	JMP	short ROOTPATH

; We are able to crack from the current directory part.  Go set up for search
; of specified cluster.

GOT_SEARCH_CLUSTER:
	LES	BP,[THISDPB]		; Get ES:BP
	invoke	SETDIRSRCH
	JC	SETFERR
	JMP	short FINDPATH

SETFERR:
	XOR	CL,CL			; set zero
	STC
	Return

EndProc GETPATH
endif

;---------------------------------------------------------------------------
;
; Procedure Name : ChkDev
;
; Check to see if the name at DS:DI is a device.  Returns carry set if not a
;   device.
; Blasts CX,SI,DI,AX,BX
;---------------------------------------------------------------------------

Procedure   ChkDev,NEAR

	MOV	SI,DI
	MOV	DI,SS
	MOV	ES,DI

;hkn;	ASSUME	ES:DOSGroup		; Now here is where ES is DOSGroup
	ASSUME	ES:DOSDATA		; Now here is where ES is DOSDATA


;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1
	MOV	CX,9
TESTLOOP:
	invoke	GETLET
 IFDEF  DBCS				;AN000;
	invoke	Testkanj		;AN000;; 2/13/KK
	jz	Notkanja		;AN000;; 2/13/KK
	stosb				;AN000;; Skip second byte   2/13/KK
	dec	cx			;AN000;; 2/13/KK
	jcxz	notdev			;AN000;; 2/13/KK
	lodsb				;AN000;; 2/13/KK
	jmp	short stowit		;AN000;; 2/13/KK
Notkanja:				;AN000;
 ENDIF					;AN000;
	CMP	AL,'.'
	JZ	TESTDEVICE
	invoke	PATHCHRCMP
	JZ	NOTDEV
	OR	AL,AL
	JZ	TESTDEVICE
stowit:
	STOSB
	LOOP	TESTLOOP
NOTDEV:
	STC
	return

TESTDEVICE:
	ADD	CX,2
	MOV	AL,' '
	REP	STOSB
	MOV	AX,SS
	MOV	DS,AX
	invoke	DEVNAME
	return
EndProc ChkDev

ifdef 0
Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
;----------------------------------------------------------------------------
;
; Procedure Name : ROOTPATH,FINDPATH
;
; Inputs:
;	Same as FINDPATH but,
;	SI Points to asciz string of path which is assumed to start at
;		the root (no leading '/').
; Function:
;	Search from root for path
; Outputs:
;	Same as FINDPATH but:
;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
;	[NoSetDir] is ignored.
;----------------------------------------------------------------------------

procedure   ROOTPATH,near
	DOSAssume   <DS>,"RootPath"

	invoke	SETROOTSRCH
	CMP	BYTE PTR [SI],0
	JNZ	FINDPATH

; Root dir specified
	MOV	AL,SAttrib
	MOV	Attrib,AL
	XOR	AH,AH			; Sets "device ID" byte, sets zero
					; (dir), clears carry.
	return

; Inputs:
;	[ATTRIB] Set to get through directories
;	[SATTRIB] Set to find last element
;	ES:BP Points to DPB
;	SI Points to asciz string of path (no leading '/').
;	[SECCLUSPOS] = 0
;	[DIRSEC] = Phys sec # of first sector of directory
;	[CLUSNUM] = Cluster # of next cluster
;	[CLUSFAC] = Sectors per cluster
;	[NoSetDir] set
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;	[CREATING] and [DELALL] set
; Function:
;	Parse path name
; Outputs:
;	ID1 field of [THISCDS] updated appropriately
;	[ATTRIB] = [SATTRIB]
;	ES:BP Points to DPB
;	[THISDPB] = ES:BP
;	Carry set if bad path
;	   SI Points to path element causing failure
;	   Zero set
;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;	      start a search on the last directory
;	      CL is zero if there is a bad name in the path
;	      CL is non-zero if the name was simply not found
;		 [ENTFREE] may have free spot in directory
;		 [NAME1] is the name.
;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
;	   Zero reset
;	      File in middle of path or bad name in path
;		or path too long or malformed path
;	ELSE
;	   [CURBUF] contains directory record with match
;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
;	   [NAME1] Has name looked for
;	   AH = device ID
;	      bit 7 of AH set if device SI and BX
;	      will point DOSGROUP relative The firclus
;	      field of the device entry contains the device pointer
;	   If last element is a directory zero is set and:
;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;	      are set up to start a search on it,
;	      unless [NoSetDir] is non zero in which case the return is
;	      like that for a file (except for zero flag)
;	   If last element is a file zero is reset
;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
;	      [LASTENT], [ENTLAST] are set to continue search of last
;	      directory for furthur matches on NAME1 via the NEXTENT
;	      entry point in FindEntry (or GETENT entry in GETENTRY in
;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
; Destroys all other registers

    entry   FINDPATH
	DOSAssume   <DS>,"FindPath"
	ASSUME	ES:NOTHING

	Assert	ISDPB,<ES,BP>,"FindPath"
	PUSH	ES			; Save ES:BP
	PUSH	SI
	MOV	DI,SI
	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
	CMP	[CURR_DIR_END],-1
	JZ	NOIDS			; No current dir part
	CMP	DI,[CURR_DIR_END]
	JNZ	NOIDS			; Not to current dir end yet
	LES	DI,THISCDS
	MOV	ES:[DI.curdir_ID],CX	; Set current directory currency
NOIDS:

; Parse the name off of DS:SI into NAME1.  AL = 1 if there was a meta
; character in the string.  CX,DI  may be destroyed.
;
;	invoke	NAMETRANS
;	MOV	CL,AL
;
; The above is the slow method.  The name has *already* been munged by
; TransPath so no special casing needs to be done.  All we do is try to copy
; the name until ., \ or 0 is hit.

	MOV	AX,SS
	MOV	ES,AX

;hkn; Name1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:Name1
	MOV	AX,'  '
	STOSB
	STOSW
	STOSW
	STOSW
	STOSW
	STOSW

;hkn; Name1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:Name1
	XOR	AH,AH			; bits for CL
 IFDEF  DBCS				;AN000;
;-------------------------- Start of DBC;AN000;S 2/13/KK
	XOR	CL,CL			;AN000;; clear count for volume id
	LODSB				;AN000;;IBMJ fix 9/04/86
	CMP	AL,05h			;AN000;;IBMJ fix 9/04/86
	JNE	GetNam2 		;AN000;;IBMJ fix 9/04/86
	PUSH	AX			;AN000;        ;IBMJ fix 9/04/86
	MOV	AL,0E5h 		;AN000;;IBMJ fix 9/04/86
	Invoke	TestKanj		;AN000;;IBMJ fix 9/04/86
	POP	AX			;AN000;        ;IBMJ fix 9/04/86
	JZ	Notkanjb		;AN000;        ;IBMJ fix 9/04/86
	JMP	SHORT GetNam3		;AN000;;IBMJ fix 9/04/86
;-------------------------- End of DBCS ;AN000;2/13/KK
 ENDIF
GetNam:
	INC	CL			;AN000; KK incrment volid count
	LODSB
 IFDEF  DBCS				;AN000;
GetNam2:				;AN000;; 2/13/KK
	invoke	Testkanj		;AN000;; 2/13/KK
	jz	Notkanjb		;AN000;; 2/13/KK
GetNam3:				;AN000;; 2/13/KK
	STOSB				;AN000;; 2/13/KK
	INC	CL			;AN000;; KK incrment volid count
	LODSB				;AN000;; 2/13/KK
	TEST	[DOS34_FLAG],DBCS_VOLID ;AN000;; 2/13/KK
	JZ	notvol			;AN000;; 2/13/KK
	CMP	CL,8			;AN000;; 2/13/KK
	JNZ	notvol			;AN000;; 2/13/KK
	CMP	AL,'.'                  ;AN000;; 2/13/KK
	JNZ	notvol			;AN000;; 2/13/KK
	LODSB				;AN000;; 2/13/KK
notvol: 				;AN000;
	jmp	short StoNam		;AN000;; 2/13/KK
Notkanjb:				;AN000;; 2/13/KK
 ENDIF					;AN000;
	CMP	AL,'.'
	JZ	setExt
	OR	AL,AL
	JZ	GetDone
	CMP	AL,'\'
	JZ	GetDone
	CMP	AL,'?'
	JNZ	StoNam
	OR	AH,1
StoNam: STOSB
	JMP	GetNam
SetExt:

;hkn; Name1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:Name1+8
GetExt:
	LODSB
 IFDEF  DBCS				;AN000;
	invoke	TestKanj		;AN000;; 2/13/KK
	jz	Notkanjc		;AN000;; 2/13/KK
	STOSB				;AN000;; 2/13/KK
	LODSB				;AN000;; 2/13/KK
	jmp	short StoExt		;AN000;; 2/13/KK
Notkanjc:				;AN000;; 2/13/KK
 ENDIF					;AN000;
	OR	AL,AL
	JZ	GetDone
	CMP	AL,'\'
	JZ	GetDone
	CMP	AL,'?'
	JNZ	StoExt
	OR	AH,1
StoExt: STOSB
	JMP	GetExt
GetDone:
	DEC	SI
	MOV	CL,AH


	OR	CL,80H
	POP	DI			; Start of this element
	POP	ES			; Restore ES:BP
	CMP	SI,DI
	JNZ	check_device
	JMP	BADPATH 		; NUL parse (two delims most likely)
check_device:
	PUSH	SI			; Start of next element
	MOV	AL,BYTE PTR [SI]
	OR	AL,AL
	JNZ	NOT_LAST


; for last element of the path switch to the correct search attributes

	MOV	BH,SAttrib
	MOV	Attrib,BH
NOT_LAST:


; check name1 to see if we have a device...

	PUSH	ES			; Save ES:BP

;hkn; SS is DOSDATA
	context ES
	invoke	DevName 		; blast BX
	POP	ES			; Restore ES:BP
	ASSUME	ES:NOTHING
	JC	FindFile		; Not a device
	OR	AL,AL			; Test next char again
	JZ	GO_BDEV
	JMP	FileInPath		; Device name in middle of path

GO_BDEV:
	POP	SI			; Points to NUL at end of path
	JMP	Build_devJ

FindFile:
	ASSUME	ES:NOTHING
;;;; 7/28/86
	CMP	BYTE PTR [NAME1],0E5H	; if 1st char = E5
	JNZ	NOE5			; no
	MOV	BYTE PTR [NAME1],05H	; change it to 05
NOE5:

;;;; 7/28/86
	PUSH	DI			; Start of this element
	PUSH	ES			; Save ES:BP
	PUSH	CX			; CL return from NameTrans
;DOS 3.3 FastOPen 6/12/86 F.C.

	CALL	LookupPath		; call fastopen to get dir entry
	JNC	DIR_FOUND		; found dir entry

;DOS 3.3 FastOPen 6/12/86 F.C.
	invoke	FINDENTRY
DIR_FOUND:
	POP	CX
	POP	ES
	POP	DI
	JNC	LOAD_BUF
	JMP	BADPATHPOP

LOAD_BUF:
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	TEST	BYTE PTR [BX+dir_attr],attr_directory
	JNZ	GO_NEXT 		; DOS 3.3
	JMP	FileInPath		; Error or end of path

; if we are not setting the directory, then check for end of string

GO_NEXT:

;hkn; SS override
	CMP	BYTE PTR [NoSetDir],0
	JZ	SetDir
	MOV	DX,DI			; Save pointer to entry
	MOV	CX,DS

;hkn; SS is DOSDATA
	context DS
	POP	DI			; Start of next element
	TEST   [FastOpenFlg],FastOpen_Set     ;only DOSOPEN can take advantage of
	JZ     nofast			      ; the FastOpen
	TEST   [FastOpenFlg],Lookup_Success   ; Lookup just happened
	JZ     nofast			      ; no
	MOV    DI,[Next_Element_Start]	      ; no need to insert it again
nofast:
	CMP	BYTE PTR [DI],0
	JNZ	NEXT_ONE		; DOS 3.3
	JMP	SetRet			; Got it
NEXT_ONE:
	PUSH	DI			; Put start of next element back on stack
	MOV	DI,DX
	MOV	DS,CX			; Get back pointer to entry
ASSUME	DS:NOTHING

SetDir:
	MOV	DX,[SI] 		; Dir_first

;DOS 3.3 FastOPen 6/12/86 F.C.

	PUSH	DS		      ; save [curbuf+2]

;hkn; SS is DOSDATA
	context DS		      ; set DS Dosgroup
	TEST	[FastOpenFlg],Lookup_Success   ;
	JZ	DO_NORMAL	      ; fastopen not in memory or path not
	MOV	BX,DX		      ; not found
	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
	PUSH	AX		      ; save device id (AH)
	invoke	SETDIRSRCH
	POP	AX		      ; restore device id (AH)
	ADD	SP,2		      ; pop ds in stack
	JMP	short FAST_OPEN_SKIP

DO_NORMAL:
ASSUME	DS:NOTHING
	POP	DS			; DS = [curbuf + 2]
;DOS 3.3 FastOPen 6/12/86 F.C.

	SUB	BX,DI			; Offset into sector of start of entry
	SUB	SI,DI			; Offset into sector of dir_first
	PUSH	BX
	PUSH	AX
	PUSH	SI
	PUSH	CX
	PUSH	WORD PTR [DI.buf_sector]     ;AN000;>32mb
	PUSH	WORD PTR [DI.buf_sector+2]   ;AN000;>32mb
	MOV	BX,DX

;hkn; SS is DOSDATA
	context DS
	invoke	SETDIRSRCH		; This uses UNPACK which might blow
					; the entry sector buffer
	POP	[HIGH_SECTOR]
	POP	DX
	JC	SKIP_GETB
	MOV	[ALLOWED],allowed_RETRY + allowed_FAIL
	XOR	AL,AL
	invoke	GETBUFFR		; Get the entry buffer back
SKIP_GETB:
	POP	CX
	POP	SI
	POP	AX
	POP	BX
	JNC	SET_THE_BUF
	POP	DI			; Start of next element
	MOV	SI,DI			; Point with SI
	JMP	SHORT BADPATH

SET_THE_BUF:
	invoke	SET_BUF_AS_DIR
	MOV	DI,WORD PTR [CURBUF]
	ADD	SI,DI			; Get the offsets back
	ADD	BX,DI
; DOS 3.3 FasOpen 6/12/86  F.C.

FAST_OPEN_SKIP:

	POP	DI			; Start of next element
	CALL   InsertPath	     ; insert dir entry info

; DOS 3.3 FasOpen 6/12/86  F.C.


	MOV	AL,[DI]
	OR	AL,AL
	JZ	SETRET			; At end
	INC	DI			; Skip over "/"
	MOV	SI,DI			; Point with SI
	invoke	PATHCHRCMP
	JNZ	find_bad_name		; oops
	JMP	FINDPATH		; Next element

find_bad_name:
	DEC	SI			; Undo above INC to get failure point
BADPATH:
	XOR	CL,CL			; Set zero
	JMP	SHORT BADPRET

FILEINPATH:
	POP	DI			; Start of next element

;hkn; SS is DOSDATA
	context DS			; Got to from one place with DS gone
; DOS 3.3 FastOpen

	TEST	[FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
	JZ	NO_FAST 		    ; device info to fastopen
	TEST	[FastOpenFlg],Lookup_Success
	JZ	NO_FAST
	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
					 ; success
NO_FAST:

; DOS 3.3 FastOpen

	MOV	AL,[DI]
	OR	AL,AL
	JZ	INCRET
	MOV	SI,DI			; Path too long
	JMP	SHORT BADPRET

INCRET:
; DOS 3.3 FasOpen 6/12/86  F.C.

	CALL   InsertPath	     ; insert dir entry info

; DOS 3.3 FasOpen 6/12/86  F.C.
	INC	AL			; Reset zero
SETRET:
	return

BADPATHPOP:
	POP	SI			; Start of next element
	MOV	AL,[SI]
	MOV	SI,DI			; Start of bad element
	OR	AL,AL			; zero if bad element is last, non-zero if path too long
BADPRET:
	MOV	AL,SAttrib
	MOV	Attrib,AL		; Make sure return correct
	STC
	return
EndProc ROOTPATH

Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
;---------------------------------------------------------------------------
;
; Procedure Name : STARTDRCH
;
; Inputs:
;	[THISDPB] Set
; Function:
;	Set up a search for GETENTRY and NEXTENTRY
; Outputs:
;	ES:BP = Drive parameters
;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
; Destroys ES,BP,AX
;--------------------------------------------------------------------------

procedure   StartSrch,NEAR
	DOSAssume   <DS>,"StartSrch"

	Assert	ISDPB,<<WORD PTR THISDPB+2>,<WORD PTR THISDPB>>,"StartSrch"
	LES	BP,[THISDPB]
	XOR	AX,AX
	MOV	[LASTENT],AX
	MOV	BYTE PTR [VOLID],AL	; No volume ID found
	DEC	AX
	MOV	[ENTFREE],AX
	MOV	[ENTLAST],AX
	return
EndProc StartSrch
endif

BREAK <MatchAttributes - the final check for attribute matching>
;----------------------------------------------------------------------------
; Procedure Name : MatchAttributes
;
; Input:    [Attrib] = attribute to search for
;	    CH = found attribute
; Output:   JZ <match>
;	    JNZ <nomatch>
; Registers modified: noneski
;----------------------------------------------------------------------------

procedure MatchAttributes,near
	PUSH	AX

;hkn; SS override
	MOV	AL,Attrib		; AL <- SearchSet
	NOT	AL			; AL <- SearchSet'
	AND	AL,CH			; AL <- SearchSet' and FoundSet
	AND	AL,attr_all		; AL <- SearchSet' and FoundSet and Important
;
; the result is non-zero if an attribute is not in the search set
; and in the found set and in the important set. This means that we do not
; have a match.  Do a JNZ <nomatch> or JZ <match>
;
	POP	AX
	return
EndProc MatchAttributes

Break <DevName - Look for name of device>
;---------------------------------------------------------------------------
;
; Procedure Name : DevName
;
; Inputs:
;	DS,ES:DOSDATA
;	Filename in NAME1
;	ATTRIB set so that we can error out if looking for Volume IDs
; Function:
;	Determine if file is in list of I/O drivers
; Outputs:
;	Carry set if not a device
;	ELSE
;	Zero flag set
;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
;	     bits 0-4 set from low byte of attribute word
;	DEVPT = DWORD pointer to Device header of device
; BX destroyed, others preserved
;---------------------------------------------------------------------------

procedure   DEVNAME,NEAR
	DOSAssume   <ES,DS>,"DevName"

	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX

; E5 special code
	PUSH	WORD PTR [NAME1]
	CMP	[NAME1],5
	JNZ	NOKTR
	MOV	[NAME1],0E5H
NOKTR:

	TEST	Attrib,attr_volume_id	; If looking for VOL id don't find devs
	JNZ	RET31

;hkn; NULDEV is in DOSDATA
	MOV	SI,OFFSET DOSDATA:NULDEV
LOOKIO:
ASSUME	DS:NOTHING
	TEST	[SI.SDEVATT],DEVTYP
	JZ	SKIPDEV 		; Skip block devices (NET and LOCAL)
	MOV	AX,SI
	ADD	SI,SDEVNAME

;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1
	MOV	CX,4			; All devices are 8 letters
	REPE	CMPSW			; Check for name in list
	MOV	SI,AX
	JZ	IOCHK			; Found it?
SKIPDEV:
	LDS	SI,DWORD PTR [SI]	; Get address of next device
	CMP	SI,-1			; At end of list?
	JNZ	LOOKIO
RET31:	STC				; Not found
RETNV:	MOV	CX,SS
	MOV	DS,CX

;hkn;	ASSUME	DS:DOSGroup
	ASSUME	DS:DOSDATA

	POP	WORD PTR [NAME1]
	POP	AX
	POP	CX
	POP	DI
	POP	SI
	RET

IOCHK:
ASSUME	DS:NOTHING

;hkn; SS override for DEVPT
	MOV	WORD PTR [DEVPT+2],DS	; Save pointer to device
	MOV	BH,BYTE PTR [SI.SDEVATT]
	OR	BH,0C0H
	AND	BH,NOT 020H		; Clears Carry
	MOV	WORD PTR [DEVPT],SI
	JMP	RETNV
EndProc DevName

BREAK <Build_device_ent - Make a Directory entry>
;---------------------------------------------------------------------------
; Procedure Name : Build_device_ent
;
; Inputs:
;	[NAME1] has name
;	BH is attribute field (supplied by DEVNAME)
;	[DEVPT] points to device header (supplied by DEVNAME)
; Function:
;	Build a directory entry for a device at DEVFCB
; Outputs:
;	BX points to DEVFCB
;	SI points to dir_first field
;	AH = input BH
;	AL = 0
;	dir_first = DEVPT
;	Zero Set, Carry Clear
; DS,ES,BP preserved, others destroyed
;--------------------------------------------------------------------------

procedure Build_device_ent,near
	DOSAssume   <ES,DS>,"Build_Device_Ent"

	MOV	AX,"  "

;hkn; DEVFCB is in DOSDATA
	MOV	DI,OFFSET DOSDATA:DEVFCB+8 ; Point to extent field

;	Fill dir_ext	BUGBUG - use ERRNZs for this stuff!

	STOSW
	STOSB				; Blank out extent field
	MOV	AL,attr_device

;	Fill Dir_attr

	STOSB				; Set attribute field
	XOR	AX,AX
	MOV	CX,10

; Fill dir_pad

	REP	STOSW			; Fill rest with zeros
;	invoke	DATE16

;hkn; DEVFCB is in DOSDATA
	MOV	DI,OFFSET DOSDATA:DEVFCB+dir_time
	XCHG	AX,DX

; Fill dir_time

	STOSW
	XCHG	AX,DX

; Fill dir_date

	STOSW
	MOV	SI,DI			; SI points to dir_first field
	MOV	AX,WORD PTR [DEVPT]

; Fill dir_first

	STOSW				; Dir_first points to device
	MOV	AX,WORD PTR [DEVPT+2]
;
; Fill dir_size_l
;
	STOSW
	MOV	AH,BH			; Put device atts in AH

;hkn; DEVFCB is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DEVFCB
	XOR	AL,AL			; Set zero, clear carry
	return
EndProc Build_device_ent

Break	<ValidateCDS - given a CDS, validate the media and the current directory>
;----------------------------------------------------------------------------
;
;   ValidateCDS - Get current CDS.  Splice it.	Call FatReadCDS to check
;   media.  If media has been changed, do DOS_Chdir to validate path.  If
;   invalid, reset original CDS to root.
;
;   Inputs:	ThisCDS points to CDS of interest
;		SS:DI points to temp buffer
;   Outputs:	The current directory string is validated on the appropriate
;		    drive
;		ThisDPB changed
;		ES:DI point to CDS
;		Carry set if error (currently user FAILed to I 24)
;   Registers modified: all
;----------------------------------------------------------------------------

Procedure   ValidateCDS,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	clc
	return
ifndef NEC_98
ifdef NTDOS
Public DIR2001S,DIR2001E
DIR2001S:
	LocalVar    Temp,WORD
	LocalVar    SaveCDS,DWORD
DIR2001E:
	Enter
	MOV	Temp,DI

;hkn; SS override
	LDS	SI,ThisCDS
	MOV	SaveCDSL,SI
	MOV	SaveCDSH,DS
	EnterCrit   critDisk
	TEST	[SI].curdir_flags,curdir_isnet	; Clears carry
	JZ	DoSplice
	JMP	FatFail
DoSplice:
	XOR	DL,DL
	XCHG	DL,NoSetDir

;hkn; SS is DOSDATA
	Context ES
	Invoke	FStrcpy
	MOV	SI,Temp

;hkn; SS is DOSDATA
	Context DS
	Invoke	Splice
	ASSUME	DS:NOTHING

 ;hkn; SS is DOSDATA
	Context DS			;   FatReadCDS (ThisCDS);
	MOV	NoSetDir,DL
	LES	DI,ThisCDS
	SAVE	<BP>
	Invoke	FatRead_CDS
	RESTORE <BP>
	JC	FatFail
	LDS	SI,ThisCDS		;   if (ThisCDS->ID == -1) {
	ASSUME	DS:NOTHING
	CMP	[SI].curdir_ID,-1
	JNZ	RestoreCDS

;hkn; SS is DOSDATA
	Context ES

;hkn; SS override
	SAVE	<wfp_Start>		;	t = wfp_Start;
	CMP	SI,SaveCDSL		; if not spliced
	JNZ	DoChdir
	MOV	DI,Temp

;hkn; SS override
	MOV	wfp_Start,DI		;	wfp_start = d;
	Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
DoChdir:

;hkn; SS is DOSDATA
	Context DS
	SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
	Invoke	DOS_ChDir
	RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
	MOV	SAttrib,BL
	LDS	SI,SaveCDS
	ASSUME	DS:NOTHING
	JNC	SetCluster		;	if (c == -1) {

;hkn; SS override for THISCDS
	MOV	WORD PTR ThisCDS,SI	;	    ThisCDS = TmpCDS;
	MOV	WORD PTR ThisCDS+2,DS
	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
	MOV	[SI+3],CL		;	    }
SetCluster:
	MOV	[SI].curdir_ID,-1	;	TmpCDS->ID = -1;
	LDS	SI,ThisCDS		;	ThisCDS->ID = c;
	TEST	[SI].curdir_flags,curdir_splice      ;AN000;;MS.  for Join and Subst
	JZ	setdirclus			     ;AN000;;MS.
	MOV	CX,-1				     ;AN000;;MS.
setdirclus:
	MOV	[SI].curdir_ID,CX	;	}
RestoreCDS:

	LES	DI,SaveCDS
	MOV	WORD PTR ThisCDS,DI
	MOV	WORD PTR ThisCDS+2,ES
	CLC
FatFail:
	LeaveCrit   critDisk

	LES	DI,SaveCDS
	Leave
	return
endif
endif   ;NEC_98
EndProc ValidateCDS

Break	<CheckThisDevice - Check for being a device>
;---------------------------------------------------------------------------
;
;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
;   device specified.  We will return carry if there is a device present.  The
;   forms of devices we will recognize are:
;
;	[path]device
;
;   Note that the drive letter has *already* been removed.  All other forms
;   are not considered to be devices.  If such a device is found we change the
;   source pointer to point to the device component.
;
;   Inputs:	ES is DOSDATA
;		DS:SI contains name
;   Outputs:	ES is DOSDATA
;		DS:SI point to name or device
;		Carry flag set if device was found
;		Carry flag reset otherwise
;   Registers Modified: all except ES:DI, DS
;----------------------------------------------------------------------------
Procedure   CheckThisDevice,NEAR
	DOSAssume <ES>,"CheckThisDevice"

	mov	dx, ax

	SAVE	<DI,SI>
;
; Advance to after the final path character.
;
	MOV	DI,SI			; remember first character
Y_PathSkip:
	LODSB
	OR	AL,AL
	JZ	Y_FoundEnd
IFDEF  DBCS			;AN000;
	invoke	Testkanj	;AN000;; 2/13/KK
	jz	Y_Notkanje	;AN000;; 2/13/KK
	lodsb			;AN000;; 2/13/KK
	or	al,al		;AN000;; Skip second byte 2/13/KK  removed
	jz	Y_FoundEnd	;AN000;; 2/13/KK		   removed
	jmp	Short Y_Pathskip	;AN000;; Ignore missing second byte for now.
Y_NotKanje:			;AN000;
  ENDIF 			;AN000;
;kanji load of next char too	  2/13/KK
IFDEF DBCS
;kanji load of next char too
ENDIF
	invoke	PathChrCmp		; is it a path char?
	JNZ	Y_PathSkip
	MOV	DI,SI
	JMP	Y_PathSkip
Y_FoundEnd:
	MOV	SI,DI
;
; Parse the name
;
	SAVE	<DS,SI> 		; preserve the source pointer
	push	dx
	invoke	NameTrans		; advance DS:SI
	pop	dx
	CMP	BYTE PTR [SI],0 	; parse entire string?
	STC				; simulate a Carry return from DevName
	JNZ	Y_SkipSearch		; no parse.  simulate a file return.

;hkn; SS is DOSDATA
	Context DS
	push	dx
	Invoke	DevName
	pop	dx
	ASSUME	DS:NOTHING
Y_SkipSearch:
	RESTORE <SI,DS>
;
; DS:SI points to the beginning of the potential device.  If we have a device
; then we do not change SI.  If we have a file, then we reset SI back to the
; original value.  At this point Carry set indicates FILE.
;
	RESTORE <DI>		; get original SI

	JC	Y_Check		; if not device
	cmp	SI, DI
	jnz	CheckCont1
	xor	dx, dx
	jmp	short Y_CheckDone

CheckCont1:
	MOV	AL, BYTE PTR DS:[SI]
	push	ax
	MOV	BYTE PTR DS:[SI],0
	SAVE	<SI>

	mov	si, di
	cmp	dl, 0
	jnz	DO_SVC
	mov	dl, [CURDRV]
DO_SVC:

	HRDSVC	SVC_DEMCHECKPATH

	RESTORE <SI>
	pop	ax
	MOV	BYTE PTR DS:[SI],al

	jnc	Y_CheckDone
	inc	dx
	clc
Y_Check:
	MOV	SI,DI
Y_CheckDone:
	RESTORE <DI>

	CMC
	return
EndProc CheckThisDevice

ifdef NEC_98
BREAK <LookupPath - call fastopen to get dir entry info>
;-----------------------------------------------------------------------------
;
; Procedure Name : LookupPath
;
; Output  DS:SI -> path name,
;	  ES:DI -> dir entry info buffer
;	  ES:CX -> extended dir info buffer
;
;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
;			     FastOpen, DS:SI points to char just one after
;			     the last char of path name which is fully or
;			     partially found in FastOPen
;	  carry flag set : FastOpen not in memory or path name not found
;
;----------------------------------------------------------------------------

procedure LookupPath,NEAR

;	PUSH	AX

;hkn; SS override
	TEST	[FastOpenFlg],FastOpen_Set	    ; flg is set in DOSPEN
	JNZ	FASTINST			    ; and this routine is
NOLOOK:
	JMP	NOLOOKUP			    ; executed once
FASTINST:

;hkn; SS override
	TEST	[FastOpenFlg],No_Lookup 	    ; no more lookup?
	JNZ	NOLOOK				    ; yes

	MOV	BX,OFFSET DOSDATA:FastOpenTable    ; get fastopen related tab

;hkn; SS override
	MOV	SI,[Wfp_Start]			    ; si points to path name
	MOV	DI,OFFSET DOSDATA:Dir_Info_Buff
	MOV	CX,OFFSET DOSDATA:FastOpen_Ext_Info
	MOV	AL,FONC_look_up 		    ; al = 1
	PUSH	DS
	POP	ES

;hkn; SS override
	CALL	DWORD PTR [BX.FASTOPEN_NAME_CACHING] ;call fastopen
	JC	NOTFOUND			    ; fastopen not in memory

	LEA	BX,[SI-2]

;hkn; SS override
	CMP	BX,[Wfp_Start]			    ; path found ?
	JZ	NOTFOUND			    ; no
						    ; fully or partially found
	CMP	BYTE PTR [SI],0 		    ;AN000;FO.
	JNZ	parfnd				    ;AN000;FO.; partiallyfound
	PUSH	CX				    ;AN000;FO.; is attribute matched ?

;hkn; SS override for attrib/sattrib
	MOV	CL,Attrib			    ;AN000;FO.;
	MOV	CH,Sattrib			    ;AN000;FO.; attrib=sattrib
	MOV	Attrib,CH			    ;AN000;FO.;
	MOV	CH,ES:[DI.dir_attr]		    ;AN000;FO.;
	invoke	Matchattributes 		    ;AN000;FO.;
;;;	MOV	Attrib,CL			    ;AN001;FO.; retore attrib
	POP	CX				    ;AN000;FO.;
	JNZ	NOLOOKUP			    ;AN000;FO.; not matched
parfnd:

;hkn; SS override
	MOV	[Next_Element_Start],SI 		   ; save si
	MOV	BX,CX
	MOV	AX,[BX.FEI_lastent]		    ;AN000;;FO. restore lastentry

;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
	MOV	[LASTENT],AX			    ;AN000;;FO.
	MOV	AX,[BX.FEI_dirstart]		    ;AN001;;FO. restore dirstart
	MOV	[DIRSTART],AX			    ;AN001;;FO.
	MOV	AX,[BX.FEI_clusnum]		    ; restore next cluster num
	MOV	[CLUSNUM],AX			    ;

	PUSH	ES				    ; save ES

;hkn; SS override
	LES	BX,[THISDPB]			    ; put drive id
	MOV	AH,ES:[BX.dpb_drive]		    ; in AH for DOOPEN
	POP	ES				    ; pop ES
;SR;
; We cannot have a root dir if we have come here. So, we zero out CurBuf to
;indicate it is not a root dir
;
	mov	word ptr CurBuf,0			;indicate not root dir

	MOV	WORD PTR [CURBUF+2],ES		    ; [curbuf+2].bx points to
	MOV	BX,DI				    ; start of entry
	LEA	SI,[DI.dir_first]		    ; [curbuf+2]:si points to
						    ; dir_first field in the
						    ; dir entry

;hkn; SS override for FastOpenFlg
	OR	[FastOpenFlg],Lookup_Success + set_for_search
;	POP	AX
	RET
NOTFOUND:
	CMP	AX,-1				    ; not in memory ?
	JNZ	Partial_Success 		    ; yes, in memory
	MOV	[FastOpenFlg],0 		    ; no more fastopen
Partial_Success:
	AND	[FastOpenFlg],Special_Fill_Reset
NOLOOKUP:
;	POP	AX
	STC
	RET
EndProc LookupPath

BREAK <InsertPath - call fastopen to insert dir entry info>
;-----------------------------------------------------------------------------
;
; Procedure Name : InsertPath
; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
;	  Lookup_Success flag set when got dir entry info from FASTOPEN
;	  DS = DOSDATA
; Output: FastOPen_Ext_Info is set and path dir info is inserted
;
;-----------------------------------------------------------------------------
procedure InsertPath,NEAR

	PUSHF

;hkn; SS override for FastOpenFlag
	TEST   [FastOpenFlg],FastOpen_Set     ;only DOSOPEN can take advantage of
	JZ     GET_NEXT_ELEMENT 	      ; the FastOpen
	TEST   [FastOpenFlg],Lookup_Success   ; Lookup just happened
	JZ     INSERT_DIR_INFO		      ; no
	AND    [FastOpenFlg],Lookup_Reset     ; we got dir info from fastopen so
	MOV    DI,[Next_Element_Start]	      ; no need to insert it again
	JMP    short GET_NEXT2
INSERT_DIR_INFO:			      ; save registers
	PUSH   DS
	PUSH   ES
	PUSH   BX
	PUSH   SI
	PUSH   DI
	PUSH   CX
	PUSH   AX

;hkn; SS override
	LDS    DI,[CURBUF]		; DS:DI -> buffer header
ASSUME DS:NOTHING
	MOV    SI,OFFSET DOSDATA:FastOpen_Ext_Info
	MOV    AX,WORD PTR [DI.buf_sector]  ; get directory sector
	MOV    WORD PTR SS:[SI.FEI_dirsec],AX ;AN000; >32mb save dir sector
	MOV    AX,WORD PTR [DI.buf_sector+2]  ;AN000; >32mb

;hkn; SS is DOSDATA
	context DS
	MOV    WORD PTR [SI.FEI_dirsec+2],AX  ;AN000;>32mb save high dir sector
	MOV    AX,[CLUSNUM]		; save next cluster number
	MOV    [SI.FEI_clusnum],AX
	MOV    AX,[LASTENT]		;AN000;FO. save lastentry for search first
	MOV    [SI.FEI_lastent],AX	;AN000;FO.
	MOV    AX,[DIRSTART]		;AN001;FO. save  for search first
	MOV    [SI.FEI_dirstart],AX	;AN001;FO.

	MOV    AX,BX
	ADD    DI,BUFINSIZ		; DS:DI -> start of data in buffer
	SUB    AX,DI			; AX=BX relative to start of sector
	MOV    CL,SIZE dir_entry
;invoke debug_DOS
	DIV    CL
	MOV    [SI.FEI_dirpos],AL	; save directory entry # in buffer

	PUSH   DS
	POP    ES

	MOV    DS,WORD PTR [CURBUF+2]
	MOV    DI,BX			; DS:DI -> dir entry info
ASSUME DS:NOTHING
	CMP    DS:[DI.dir_first],0	; never insert info when file is empty
	JZ     SKIP_INSERT		; e.g. newly created file

	PUSH   SI			; ES:BX -> extended info
	POP    BX

	MOV    AL,FONC_insert		; call fastopen insert operation
	MOV    SI,OFFSET DOSDATA:FastOpenTable
	CALL   DWORD PTR ES:[SI.FASTOPEN_NAME_CACHING]

	CLC
SKIP_INSERT:
	POP    AX
	POP    CX			; restore registers
	POP    DI
	POP    SI
	POP    BX
	POP    ES
	POP    DS
GET_NEXT2:
	OR     [FastOpenFlg],No_Lookup	      ; we got dir info from fastopen so
GET_NEXT_ELEMENT:
	POPF
	RET
EndProc InsertPath
endif   ;NEC_98

DOSCODE	ENDS
    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\abort.asm ===
TITLE   DOS_ABORT - Internal SFT close all files for proc call for MSDOS
NAME    DOS_ABORT

; Internal Abort call closes all handles and FCBs associated with a process.
;
;   DOS_ABORT
;
;   Modification history:
;
;   sudeepb 11-Mar-1991 Ported For NT DOSEm.


;
; get the appropriate segment definitions
;


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include pdb.inc
	include mult.inc
	include dossvc.inc
	.cref
	.list

Installed = TRUE

	I_Need  PROC_ID,WORD            ; current process ID
	I_Need  USER_ID,WORD            ; current user ID
	i_need  CurrentPDB,WORD
	i_need  sft_addr,DWORD
	i_need  THISSFT,DWORD
	i_need  JSHARE,DWORD
	I_need  sftFCB,DWORD            ; pointer to SFTs for FCB cache

DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE


Break   <DOS_ABORT -- CLOSE all files for process>
;--------------------------------------------------------------------------
;
; Procedure Name : DOS_ABORT
;
; Inputs:
;	[CurrentPDB] points to aborting process
; Function:
;	Close all files and free all SFTs for this PDB
; Returns:
;       None
; All destroyed except stack
;---------------------------------------------------------------------------

	Procedure   DOS_ABORT,NEAR
	ASSUME  DS:NOTHING,ES:NOTHING

	MOV     ES,[CurrentPDB]		; SS override
	MOV     CX,ES:[PDB_JFN_Length]  ; Number of JFNs
reset_free_jfn:
	MOV     BX,CX
	PUSH    CX
	DEC     BX                      ; get jfn (start with last one)

	invoke  $close
	POP     CX
	LOOP    reset_free_jfn          ; and do 'em all
;
; Note:  We do need to explicitly close FCBs.  Reasons are as follows:  If we
; are running in the no-sharing no-network environment, we are simulating the
; 2.0 world and thus if the user doesn't close the file, that is his problem
; BUT...  the cache remains in a state with garbage that may be reused by the
; next process.  We scan the set and blast the ref counts of the FCBs we own.
;
; If sharing is loaded, then the following call to close process will
; correctly close all FCBs.  We will then need to walk the list AFTER here.
;
; Finally, the following call to NET_Abort will cause an EOP to be sent to all
; known network resources.  These resources are then responsible for cleaning
; up after this process.
;
; Sleazy, eh?
;

	context DS			; SS is DOSDATA
ifdef NEC_98
	CallInstall Net_Abort, multNet, 29
if installed
	call    JShare + 4 * 4
else
	call    mftCloseP
endif
endif   ;NEC_98
	assume  ds:nothing
;
; Scan the FCB cache for guys that belong to this process and zap their ref
; counts.
;

					; SS override
	les     di,sftFCB               ; grab the pointer to the table
	mov     cx,es:[di].sfCount
	jcxz    FCBScanDone
	LEA     DI,[DI].sfTable         ; point at table
	mov     ax,proc_id		; SS override
FCBTest:
	cmp     es:[di].sf_PID,ax       ; is this one of ours
        jnz     FCBNext                 ; no, skip it
        call    Close_NT_Handle
FCBNext:
	add     di,size sf_Entry
	loop    FCBTest
FCBScanDone:

;
; Walk the SFT to eliminate all busy SFT's for this process.
;
	XOR     BX,BX
Scan:
	push    bx
	invoke  SFFromSFN
	pop     bx
	retc
	cmp     es:[di].sf_ref_count,sf_busy	; Is Sft busy? ;M038
	jnz      next
;
; we have a SFT that is busy.  See if it is for the current process
;

	mov     ax,proc_id		; SS override
	cmp     es:[di].sf_pid,ax
	jnz     next
;
; This SFT is labelled as ours.
;
        call    Close_NT_Handle
next:
        inc     bx
        jmp     scan

;
; This call releases all LFN resources associated with this
; process
;
;
        mov ax, 0h        ; set fn to 0
        HRDSVC  SVC_DEMLFNENTRY

EndProc DOS_Abort

Close_NT_Handle:
        push    bp
        push    ax
	mov	bp,word ptr es:[di].sf_NTHandle
	mov	ax,word ptr es:[di].sf_NTHandle+2
        HRDSVC  SVC_DEMCLOSE
        pop     ax
	pop	bp
        mov     es:[di].sf_ref_count,0
        ret

DOSCODE    ENDS
    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\cpmio.asm ===
;**	Standard device IO for MSDOS (first 12 function calls)
;

	TITLE	IBMCPMIO - device IO for MSDOS
	NAME	IBMCPMIO

;**	CPMIO.ASM - Standard device IO for MSDOS (first 12 function calls)
;
;
;	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input_No_Echo
;	$Std_Con_String_Output
;	$Std_Con_String_Input
;	$RawConIO
;	$RawConInput
;	RAWOUT
;	RAWOUT2
;
;	Revision history:
;
;	    A000     version 4.00 - Jan 1988
;	    A002     PTM    -- dir >lpt3 hangs

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	include sf.inc
	include vector.inc
	INCLUDE DEVSYM.INC
	include doscntry.inc
	.list
	.cref


; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

    i_need  CARPOS,BYTE
    i_need  STARTPOS,BYTE
    i_need  INBUF,128
    i_need  INSMODE,BYTE
    i_need  user_SP,WORD
    EXTRN   OUTCHA:NEAR 		;AN000 char out with status check 2/11/KK
    i_need  Printer_Flag,BYTE
    i_need  SCAN_FLAG,BYTE
    i_need  DATE_FLAG,WORD
    i_need  Packet_Temp,WORD		; temporary packet used by readtime
    i_need  DEVCALL,DWORD
    i_need  InterChar,BYTE		;AN000;interim char flag ( 0 = regular char)
    i_need  InterCon,BYTE		;AN000;console flag ( 1 = in interim mode )
    i_need  SaveCurFlg,BYTE		;AN000;console out ( 1 = print and do not advance)
    i_need  COUNTRY_CDPG,byte		;AN000; 	2/12/KK
    i_need  TEMP_VAR,WORD		;AN000; 	2/12/KK
    i_need  DOS34_FLAG,WORD             ;AN000;         2/12/KK
ifdef DBCS
    i_need  LOOKSIZ,BYTE
endif

NT_WAIT_BOP	equ	5Ah

bop MACRO callid
    db 0c4h,0c4h,callid
endm

DOSCODE SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	EXTRN	Get_IO_SFT:Near
	EXTRN	IOFunc:near

	EXTRN	EscChar:BYTE		; lead byte for function keys
	EXTRN	CanChar:BYTE		; Cancel character


Break
IFDEF  DBCS							  ;AN000;
;
;----------------------------------------------------------------------------
;
; Procedure : $Std_Con_Input_No_Echo
;
;----------------------------------------------------------------------------
;

;--- Start of Korean Support 2/11/KK
procedure   $STD_CON_INPUT_NO_ECHO,NEAR   ;System call 8  ;AN000;

StdCILop:							  ;AN000;
	invoke	INTER_CON_INPUT_NO_ECHO 			  ;AN000;
	jmp	InterApRet		; go to return fuction	  ;AN000;

EndProc $STD_CON_INPUT_NO_ECHO					  ;AN000;
;
;----------------------------------------------------------------------------
;
; Procedure : Inter_Con_Input_No_Echo
;
;
;----------------------------------------------------------------------------
;
procedure   INTER_CON_INPUT_NO_ECHO,NEAR		  ;AN000;
;--- End of Korean Support 2/11/KK

; Inputs:
;	None
; Function:
;	Same as $STD_CON_INPUT_NO_ECHO but uses interim character read from
;	the device.
; Returns:
;	AL = character
;	Zero flag SET if interim character, RESET otherwise
ELSE								  ;AN000;
;
; Inputs:
;	None
; Function:
;	Input character from console, no echo
; Returns:
;	AL = character

procedure   $STD_CON_INPUT_NO_ECHO,NEAR   ;System call 8

ENDIF
	PUSH	DS
        PUSH    SI
        push    cx

INTEST:
        mov  cx, 10h

InTest1:
        push    cx
        invoke  STATCHK
        pop     cx
        JNZ     Get
        loop    InTest1

        ; extra idling for full screen
        xor     ax,ax                   ; with AX = 0 for WaitIfIdle
        bop     NT_WAIT_BOP

;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	JMP	Intest
Get:
        XOR     AH,AH
        call    IOFUNC
        pop     cx
	POP	SI
	POP	DS
;;; 7/15/86

;hkn; SS override
	MOV	BYTE PTR [SCAN_FLAG],0
	CMP	AL,0	    ; extended code ( AL )
	JNZ	noscan

;hkn; SS override
	MOV	BYTE PTR [SCAN_FLAG],1	; set this flag for ALT_Q key

noscan:
;;; 7/15/86
 IFDEF  DBCS			    ;AN000;

;hkn; InterChar is in DOSDATA. use SS override.
	cmp	[InterChar],1    ;AN000; set the zero flag if the character3/31/KK ;AN000;
 ENDIF				    ;AN000;
	return
 IFDEF  DBCS			    ;AN000;
EndProc INTER_CON_INPUT_NO_ECHO     ;AN000;  ;2/11/KK				      ;AN000;
 ELSE				    ;AN000;
EndProc $STD_CON_INPUT_NO_ECHO
 ENDIF				    ;AN000;

	BREAK	<$STD_CON_STRING_OUTPUT - Console String Output>

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_STRING_OUTPUT - Console String Output
;
;
;	ENTRY	(DS:DX) Point to output string '$' terminated
;	EXIT	none
;	USES	ALL
;
;----------------------------------------------------------------------------
;

procedure   $STD_CON_STRING_OUTPUT,NEAR   ;System call 9

	MOV	SI,DX
STRING_OUT1:
	LODSB
; IFDEF  DBCS				;AN000;
;	invoke	TESTKANJ		;AN000; 	      2/11/KK		 ;AN000;
;	jz	SBCS00			;AN000; 	      2/11/KK		 ;AN000;
;	invoke	OUTT			;AN000; 	      2/11/KK		 ;AN000;
;	LODSB				;AN000; 	      2/11/KK		 ;AN000;
;	JMP	NEXT_STR1		;AN000; 	      2/11/KK		 ;AN000;
;SBCS00: 				;AN000; 	      2/11/KK		 ;AN000;
; ENDIF					;AN000;
	CMP	AL,'$'
	retz
NEXT_STR1:
	invoke	OUTT
	JMP	STRING_OUT1

EndProc $STD_CON_STRING_OUTPUT

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

IFDEF  DBCS

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

	include kstrin.asm

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ELSE	; Not double byte characters

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;       SCCSID = @(#)strin.asm  1.2 85/04/18

	BREAK	<$STD_CON_STRING_INPUT - Input Line from Console>


;**	$STD_CON_STRING_INPUT - Input Line from Console
;
;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
;
;	ENTRY	(ds:dx) = input buffer
;	EXIT	none
;	USES	ALL

	ASSUME	DS:NOTHING,ES:NOTHING
procedure	 $STD_CON_STRING_INPUT,NEAR	;System call 10

        MOV     AX,SS
        MOV     ES,AX
        MOV     SI,DX
        XOR     CH,CH
        LODSW

;	(AL) = the buffer length
;	(AH) = the template length

        OR      AL,AL
        retz                    ;Buffer is 0 length!!?
        MOV     BL,AH           ;Init template counter
        MOV     BH,CH           ;Init template counter

;	(BL) = the number of bytes in the template

        CMP     AL,BL
        JBE     NOEDIT          ;If length of buffer inconsistent with contents
        CMP     BYTE PTR [BX+SI],c_CR
        JZ      EDITON          ;If CR correctly placed EDIT is OK

; The number of chars in the template is >= the number of chars in buffer or
; there is no CR at the end of the template.  This is an inconsistant state
; of affairs.  Pretend that the template was empty:
;

noedit:	MOV	BL,CH		 ;Reset buffer
editon: MOV	DL,AL
        DEC     DX              ;DL is # of bytes we can put in the buffer

;	Top level.  We begin to read a line in.

;hkn; SS override
newlin: MOV	AL,[CARPOS]
        MOV     [STARTPOS],AL   ;Remember position in raw buffer
        PUSH    SI

;hkn; INBUF is in DOSDATA
        MOV     DI,OFFSET DOSDATA:INBUF        ;Build the new line here

;hkn; SS override
        MOV     [INSMODE],CH    ;Insert mode off
        MOV     BH,CH           ;No chars from template yet
        MOV     DH,CH           ;No chars to new line yet
        invoke  $STD_CON_INPUT_NO_ECHO          ;Get first char
        CMP     AL,c_LF         ;Linefeed
        JNZ     GOTCH           ;Filter out LF so < works

;	This is the main loop of reading in a character and processing it.
;
;	(BH) = the index of the next byte in the template
;	(BL) = the length of the template
;	(DH) = the number of bytes in the buffer
;	(DL) = the length of the buffer

entry	GETCH
        invoke  $STD_CON_INPUT_NO_ECHO
GOTCH:
;
; Tim Patterson ignored ^F in case his BIOS did not flush the
; input queue.
;
        CMP     AL,"F"-"@"
        JZ      GETCH

;	If the leading char is the function-key lead byte


;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)
        CMP     AL,[ESCCHAR]
        JZ      ESCape          ;change reserved keyword DBM 5-7-87

;	Rubout and ^H are both destructive backspaces.

        CMP     AL,c_DEL
        JZ      BACKSPJ
        CMP     AL,c_BS
        JZ      BACKSPJ

;	^W deletes backward once and then backs up until a letter is before the
;	cursor

        CMP     AL,"W" - "@"

;	The removal of the comment characters before the jump statement will
;	cause ^W to backup a word.

;***    JZ      WordDel
        NOP
        NOP
        CMP     AL,"U" - "@"

;	The removal of the comment characters before the jump statement will
;	cause ^U to clear a line.

;***    JZ      LineDel
        NOP
        NOP


;	CR terminates the line.

        CMP     AL,c_CR
        JZ      ENDLIN

;	LF goes to a new line and keeps on reading.

        CMP     AL,c_LF
        JZ      PHYCRLF

;	^X (or ESC) deletes the line and starts over


;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override
        CMP     AL,[CANCHAR]
        JZ      KILNEW

; Otherwise, we save the input character.

savch:	CMP	DH,DL
        JAE     BUFFUL                  ; buffer is full.
        STOSB
        INC     DH                      ; increment count in buffer.
        invoke  BUFOUT                  ;Print control chars nicely

;hkn; SS override
        CMP     BYTE PTR [INSMODE],0
        JNZ     GETCH                   ; insertmode => don't advance template
        CMP     BH,BL
        JAE     GETCH                   ; no more characters in template
        INC     SI                      ; Skip to next char in template
        INC     BH                      ; remember position in template
        JMP     SHORT GETCH

BACKSPJ: JMP    SHORT BACKSP

bufful: MOV	AL,7			; Bell to signal full buffer
        invoke  OUTT
        JMP     SHORT GETCH

ESCape: transfer    OEMFunctionKey	; let the OEM's handle the key dispatch

ENDLIN:
        STOSB                           ; Put the CR in the buffer
        invoke  OUTT                    ; Echo it
        POP     DI                      ; Get start of user buffer
        MOV     [DI-1],DH               ; Tell user how many bytes
        INC     DH                      ; DH is length including CR
COPYNEW:
	SAVE	<DS,ES>
	RESTORE <DS,ES>		    ; XCHG ES,DS

;hkn; INBUF is in DOSDATA
        MOV     SI,OFFSET DOSDATA:INBUF
        MOV     CL,DH                   ; set up count
        REP     MOVSB                   ; Copy final line to user buffer
        return

;	Output a CRLF to the user screen and do NOT store it into the buffer

PHYCRLF:
        invoke  CRLF
        JMP     GETCH

;
; Delete the previous line
;
LineDel:
        OR      DH,DH
        JZ      GetCh
        Call    BackSpace
        JMP     LineDel

;
; delete the previous word.
;
WordDel:
WordLoop:
        Call    BackSpace               ; backspace the one spot
        OR      DH,DH
        JZ      GetChJ
        MOV     AL,ES:[DI-1]
        cmp     al,'0'
        jb      GetChj
        cmp     al,'9'
        jbe     WordLoop
        OR      AL,20h
        CMP     AL,'a'
        JB      GetChJ
        CMP     AL,'z'
        JBE     WordLoop
getchj: JMP	GetCh

; The user wants to throw away what he's typed in and wants to start over.  We
; print the backslash and then go to the next line and tab to the correct spot
; to begin the buffered input.

        entry   KILNEW
        MOV     AL,"\"
        invoke  OUTT            ;Print the CANCEL indicator
        POP     SI              ;Remember start of edit buffer
PUTNEW:
        invoke  CRLF            ;Go to next line on screen

;hkn; SS override
        MOV     AL,[STARTPOS]
        invoke  TAB             ;Tab over
        JMP     NEWLIN          ;Start over again



;	Destructively back up one character position

entry   BackSp
        Call    BackSpace
        JMP     GetCh

BackSpace:
        OR      DH,DH
        JZ      OLDBAK          ;No chars in line, do nothing to line
        CALL    BACKUP          ;Do the backup
        MOV     AL,ES:[DI]      ;Get the deleted char
        CMP     AL," "
        JAE     OLDBAK          ;Was a normal char
        CMP     AL,c_HT
        JZ      BAKTAB          ;Was a tab, fix up users display
;; 9/27/86 fix for ctrl-U backspace
        CMP     AL,"U"-"@"      ; ctrl-U is a section symbol not ^U
        JZ      OLDBAK
        CMP     AL,"T"-"@"      ; ctrl-T is a paragraphs symbol not ^T
        JZ      OLDBAK
;; 9/27/86 fix for ctrl-U backspace
        CALL    BACKMES         ;Was a control char, zap the '^'
OLDBAK:

;hkn; SS override
        CMP     BYTE PTR [INSMODE],0
        retnz                   ;In insert mode, done
        OR      BH,BH
        retz                    ;Not advanced in template, stay where we are
        DEC     BH              ;Go back in template
        DEC     SI
        return

BAKTAB:
        PUSH    DI
        DEC     DI              ;Back up one char
        STD                     ;Go backward
        MOV     CL,DH           ;Number of chars currently in line
        MOV     AL," "
        PUSH    BX
        MOV     BL,7            ;Max
        JCXZ    FIGTAB          ;At start, do nothing
FNDPOS:
        SCASB                   ;Look back
        JNA     CHKCNT
        CMP     BYTE PTR ES:[DI+1],9
        JZ      HAVTAB          ;Found a tab
        DEC     BL              ;Back one char if non tab control char
CHKCNT:
        LOOP    FNDPOS
FIGTAB:
;hkn; SS override
        SUB     BL,[STARTPOS]
HAVTAB:
        SUB     BL,DH
        ADD     CL,BL
        AND     CL,7            ;CX has correct number to erase
        CLD                     ;Back to normal
        POP     BX
        POP     DI
        JZ      OLDBAK          ;Nothing to erase
TABBAK:
        invoke  BACKMES
        LOOP    TABBAK          ;Erase correct number of chars
        JMP     SHORT OLDBAK

BACKUP:
        DEC     DH              ;Back up in line
        DEC     DI
BACKMES:
        MOV     AL,c_BS         ;Backspace
        invoke  OUTT
        MOV     AL," "          ;Erase
        invoke  OUTT
        MOV     AL,c_BS         ;Backspace
        JMP     OUTT            ;Done

;User really wants an ESC character in his line
        entry   TwoEsc

;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
        MOV     AL,[ESCCHAR]
        JMP     SAVCH

;Copy the rest of the template
        entry   COPYLIN
        MOV     CL,BL           ;Total size of template
        SUB     CL,BH           ;Minus position in template, is number to move
        JMP     SHORT COPYEACH

        entry   CopyStr
        invoke  FINDOLD         ;Find the char
        JMP     SHORT COPYEACH  ;Copy up to it

;Copy one char from template to line
        entry   COPYONE
        MOV     CL,1
;Copy CX chars from template to line
COPYEACH:
;hkn; SS override
        MOV     BYTE PTR [INSMODE],0    ;All copies turn off insert mode
        CMP     DH,DL
        JZ      GETCH2                  ;At end of line, can't do anything
        CMP     BH,BL
        JZ      GETCH2                  ;At end of template, can't do anything
        LODSB
        STOSB
        invoke  BUFOUT
        INC     BH                      ;Ahead in template
        INC     DH                      ;Ahead in line
        LOOP    COPYEACH
GETCH2:
        JMP     GETCH

;Skip one char in template
        entry   SKIPONE
        CMP     BH,BL
        JZ      GETCH2                  ;At end of template
        INC     BH                      ;Ahead in template
        INC     SI
        JMP     GETCH

        entry   SKIPSTR
        invoke  FINDOLD                 ;Find out how far to go
        ADD     SI,CX                   ;Go there
        ADD     BH,CL
        JMP     GETCH

;Get the next user char, and look ahead in template for a match
;CX indicates how many chars to skip to get there on output
;NOTE: WARNING: If the operation cannot be done, the return
;       address is popped off and a jump to GETCH is taken.
;       Make sure nothing extra on stack when this routine
;       is called!!! (no PUSHes before calling it).
FINDOLD:
        invoke  $STD_CON_INPUT_NO_ECHO

;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
        CMP     AL,[ESCCHAR]            ; did he type a function key?
        JNZ     FindSetup               ; no, set up for scan
        invoke  $STD_CON_INPUT_NO_ECHO  ; eat next char
        JMP     short NotFnd            ; go try again
FindSetup:
        MOV     CL,BL
        SUB     CL,BH           ;CX is number of chars to end of template
        JZ      NOTFND          ;At end of template
        DEC     CX              ;Cannot point past end, limit search
        JZ      NOTFND          ;If only one char in template, forget it
        PUSH    ES
        PUSH    DS
        POP     ES
        PUSH    DI
        MOV     DI,SI           ;Template to ES:DI
        INC     DI
        REPNE   SCASB           ;Look
        POP     DI
        POP     ES
        JNZ     NOTFND          ;Didn't find the char
        NOT     CL              ;Turn how far to go into how far we went
        ADD     CL,BL           ;Add size of template
        SUB     CL,BH           ;Subtract current pos, result distance to skip
        return

NOTFND:
        POP     BP              ;Chuck return address
        JMP     GETCH

entry   REEDIT
        MOV     AL,"@"          ;Output re-edit character
        invoke  OUTT
        POP     DI
        PUSH    DI
        PUSH    ES
        PUSH    DS
        invoke  COPYNEW         ;Copy current line into template
        POP     DS
        POP     ES
        POP     SI
        MOV     BL,DH           ;Size of line is new size template
        JMP     PUTNEW          ;Start over again

        entry   EXITINS
        entry   ENTERINS

;hkn; SS override
        NOT     BYTE PTR [INSMODE]
        JMP     GETCH

;Put a real live ^Z in the buffer (embedded)
        entry   CTRLZ
        MOV     AL,"Z"-"@"
        JMP     SAVCH

;Output a CRLF
        entry   CRLF
        MOV     AL,c_CR
        invoke  OUTT
        MOV     AL,c_LF
        JMP     OUTT

EndProc $STD_CON_STRING_INPUT

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ENDIF

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
	BREAK	<$RAW_CON_IO - Do Raw Console I/O>
;
;----------------------------------------------------------------------------
;
;**	$RAW_CON_IO - Do Raw Console I/O
;
;	Input or output raw character from console, no echo
;
;	ENTRY	DL = -1 if input
;		   =  output character if output
;	EXIT	(AL) = input character if input
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $RAW_CON_IO,NEAR   ; System call 6

	MOV	AL,DL
	CMP	AL,-1
	LJNE	RAWOUT			; is output

;hkn; SS override
	LES	DI,DWORD PTR [user_SP]		      ; Get pointer to register save area
	XOR	BX,BX
	call	GET_IO_SFT
	retc
 IFDEF  DBCS				;AN000;

;hkn; SS override
	push	word ptr [Intercon]	;AN000;
	mov	[Intercon],0		;AN000; disable interim characters
 ENDIF					;AN000;
	MOV	AH,1
	call	IOFUNC
	JNZ	RESFLG
 IFDEF  DBCS				;AN000;

;hkn; SS override
	pop	word ptr [InterCon]	;AN000; restore interim flag
 ENDIF					;AN000;
	invoke	SPOOLINT
	OR	BYTE PTR ES:[DI.user_F],40H ; Set user's zero flag
	XOR	AL,AL
	return

RESFLG:
	AND	BYTE PTR ES:[DI.user_F],0FFH-40H    ; Reset user's zero flag
 IFDEF  DBCS				;AN000;
	XOR	AH,AH			;AN000;
	call	IOFUNC			;AN000; get the character

;hkn; SS override
	pop	word ptr [InterCon]	;AN000;
	return				;AN000;
 ENDIF					;AN000; 				;AN000;


;
;----------------------------------------------------------------------------
;
;**	$Raw_CON_INPUT - Raw Console Input
;
;	Input raw character from console, no echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;


rci0:	invoke	SPOOLINT

entry	$RAW_CON_INPUT	      ; System call 7

	PUSH	BX
	XOR	BX,BX
	call	GET_IO_SFT
	POP	BX
	retc
	MOV	AH,1
	call	IOFUNC
        JNZ     rci5

; We don't do idling here for NTVDM because softpc's
; idle detection requires a hi num polls/ tic to be
; activated
;
; 04-Aug-1992 Jonle
;
;        MOV     AH,84h
;        INT     int_IBM

	JMP	rci0

rci5:	XOR	AH,AH
	call	IOFUNC
 IFDEF  DBCS				;AN000;

;hkn; SS override
	cmp	[InterChar],1		;AN000;    2/11/KK
;								2/11/KK
;	Sets the application zero flag depending on the 	2/11/KK
;	zero flag upon entry to this routine. Then returns	2/11/KK
;	from system call.					2/11/KK
;								2/11/KK
entry	InterApRet			;AN000; 		2/11/KK 	;AN000;
	pushf				;AN000; 3/16/KK
;hkn;	push	ds			;AN000; 3/16/KK
	push	bx			;AN000; 3/16/KK

;hkn; SS is DOSDATA
;hkn;	Context DS			;AN000; 3/16/KK

;hkn; COUNTRY_CDPG is in DOSCODE;smr;NO in DOSDATA
	MOV	BX,offset DOSDATA:COUNTRY_CDPG.ccDosCodePage
	cmp	word ptr ss:[bx],934	;AN000; 3/16/KK       korean code page ?; bug fix. use SS
	pop	bx			;AN000; 3/16/KK
;hkn;	pop	ds			;AN000; 3/16/KK
	je	do_koren		;AN000; 3/16/KK
	popf				;AN000; 3/16/KK
	return				;AN000; 3/16/KK
do_koren:				;AN000; 3/16/KK
	popf				;AN000;

;hkn; SS override
	LES	DI,DWORD PTR [user_SP]	;AN000; Get pointer to register save area KK
	jnz	sj0			;AN000; 		      2/11/KK
	OR	BYTE PTR ES:[DI.user_F],40H	;AN000; Set user's zero flag  2/11/KK
	return				;AN000; 		2/11/KK
sj0:					;AN000; 		2/11/KK
	AND	BYTE PTR ES:[DI.user_F],0FFH-40H ;AN000; Reset user's zero flag 2/KK
 ENDIF						 ;AN000;
	return					 ;AN000;
;
;	Output the character in AL to stdout
;
	entry	RAWOUT

	PUSH	BX
	MOV	BX,1

	call	GET_IO_SFT
	JC	RAWRET1

	MOV	BX,[SI.sf_flags]	;hkn; DS set up by get_io_sft

 ;
 ; If we are a network handle OR if we are not a local device then go do the
 ; output the hard way.
 ;

	AND	BX,sf_isNet + devid_device
	CMP	BX,devid_device
	JNZ	RawNorm
 IFDEF  DBCS					;AN000;

;hkn; SS override
	TEST	[SaveCurFlg],01H		;AN000; print but no cursor adv?
	JNZ	RAWNORM 			;AN000;    2/11/KK
 ENDIF						;AN000;

;	TEST	BX,sf_isnet			; output to NET?
;	JNZ	RAWNORM 			; if so, do normally
;	TEST	BX,devid_device 		; output to file?
;	JZ	RAWNORM 			; if so, do normally

	PUSH	DS
	LDS	BX,[SI.sf_devptr]		; output to special?
	TEST	BYTE PTR [BX+SDEVATT],ISSPEC
	POP	DS
ifndef NEC_98
	JZ	RAWNORM 			; if not, do normally
	INT	int_fastcon			; quickly output the char
else    ;NEC_98
;93/03/25 MVDM DOS5.0A---------------------------- NEC 93/01/07 ---------------
;<patch>
	extrn	patch_fastcon:near
	public	RAWRET,RAWNORM

	jmp	patch_fastcon
	db	90h
;------------------------------------------------------------------------------
endif   ;NEC_98
RAWRET:
	CLC
RAWRET1:
	POP	BX
	return
RAWNORM:
	CALL	RAWOUT3
	JMP	RAWRET

;
;	Output the character in AL to handle in BX
;
	entry	RAWOUT2

	call	GET_IO_SFT
	retc
RAWOUT3:
	PUSH	AX
	JMP	SHORT RAWOSTRT
ROLP:
	invoke	SPOOLINT

;hkn; SS override
	OR	[DOS34_FLAG],CTRL_BREAK_FLAG ;AN002; set control break
	invoke	DSKSTATCHK		     ;AN002; check control break
RAWOSTRT:
	MOV	AH,3
	call	IOFUNC
	JZ	ROLP
;SR;
; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
;the user failed. We do not send a char if this happens. We however return 
;to the caller with carry clear because this DOS call does not return any
;status. 
;
	inc	ax			;fail on I24 if ax = -1
	POP	AX
	jz	nosend			;yes, do not send char

	MOV	AH,2
	call	IOFUNC
nosend:
	CLC			; Clear carry indicating successful
	return
EndProc $RAW_CON_IO

;
;----------------------------------------------------------------------------
;
; Inputs:
;	AX=0 save the DEVCALL request packet
;	  =1 restore the DEVCALL request packet
; Function:
;	save or restore the DEVCALL packet
; Returns:
;	none
;
;----------------------------------------------------------------------------
;

procedure   Save_Restore_Packet,NEAR

	PUSH	DS
	PUSH	ES
	PUSH	SI
	PUSH	DI
	CMP	AX,0		; save packet
	JZ	save_packet
restore_packet:
	MOV	SI,OFFSET DOSDATA:Packet_Temp	 ;sourec
	MOV	DI,OFFSET DOSDATA:DEVCALL	 ;destination
	JMP	short set_seg
save_packet:
	MOV	DI,OFFSET DOSDATA:Packet_Temp	 ;destination
	MOV	SI,OFFSET DOSDATA:DEVCALL	 ;source
set_seg:
	MOV	AX,SS		; set DS,ES to DOSDATA
	MOV	DS,AX
	MOV	ES,AX
	MOV	CX,11		; 11 words to move
	REP	MOVSW

	POP	DI
	POP	SI
	POP	ES
	POP	DS
	return
EndProc Save_Restore_Packet

DOSCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\divmes.inc ===
; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
	PUBLIC	DIVMES
ifdef	JAPAN
	PUBLIC	DIVMES2
endif
Public DIVM001S,DIVM001E
DIVM001S	label byte

include msdos.cl1

ifdef JAPAN
	PUBLIC	DivMesLen
DivMesLen   DW	DivMes2-DivMes	; Length of the above message in bytes
	PUBLIC	DivMesLen2
DivMesLen2  DW	DivMesLen-DivMes2

else
	PUBLIC	DivMesLen
DivMesLen   DW	$-DivMes	; Length of the above message in bytes
endif

DIVM001E	label byte

;M018
; Add VxD not found error message
;
	Public	NoVxDErrMsg		;M018
ifdef JAPAN
	Public	NoVxDErrMsg2		;M018
endif
include msdos.cl4			;M018

ifdef JAPAN
	Public	VXDMESLEN		;M018
VxDMesLen       equ     NoVxDErrMsg2 - NoVxDErrMsg ;M018
	Public	VXDMESLEN2		;M018
VxDMesLen2      equ     $ - NoVxDErrMsg2
else
	Public	VXDMESLEN		;M018
VxDMesLen       equ     $ - NoVxDErrMsg ;M018
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\disk.asm ===
TITLE	DISK - Disk utility routines
	NAME	Disk

;**	Low level Read and write routines for local SFT I/O on files and devs
;
;	SWAPCON
;	SWAPBACK
;	DOS_READ
;	DOS_WRITE
;	get_io_sft
;
;	Revision history:
;
;	sudeepb 07-Mar-1991 Ported for DOSEm

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include mult.inc
	include filemode.inc
	.cref
	.list

Installed = TRUE

	I_Need	CONSft,DWORD		; SFT for swapped console In/Out
	i_need	CONSWAP,BYTE
	i_need	THISSFT,DWORD
	i_need	DMAADD,DWORD
	i_need	DEVCALL,BYTE
	i_need	CALLSCNT,WORD
	i_need	CALLXAD,DWORD
	i_need	CONTPOS,WORD
	i_need	NEXTADD,WORD
	i_need	CONBUF,BYTE
	i_need	ReadOp,BYTE
	i_need	EXTERR_LOCUS,BYTE
	i_need	PFLAG,BYTE
	i_need	CHARCO,BYTE
	i_need	CARPOS,BYTE

;
;Flag to indicate WIN386 presence
;
	I_need	IsWin386,BYTE


DOSCODE	Segment
	ASSUME	SS:DOSDATA,CS:DOSCODE

	EXTRN	CharHard:near
	EXTRN	DevIoCall:near
	EXTRN	DevIoCall2:near
	EXTRN	Outt:near


Break	<SwapCon, Swap Back - Old-style I/O to files>
; * * * * Drivers for file input from devices * * * *
;----------------------------------------------------------------------------
;   Indicate that ther is no more I/O occurring through another SFT outside of
;   handles 0 and 1
;
;   Inputs:	DS is DOSDATA
;   Outputs:	CONSWAP is set to false.
;   Registers modified: none
;----------------------------------------------------------------------------

procedure   SWAPBACK,NEAR

	DOSAssume   <DS>,"SwapBack"
	MOV	BYTE PTR [CONSWAP],0	; signal no conswaps
	return

EndProc SWAPBACK

;----------------------------------------------------------------------------
;
; Procedure Name : SWAPCON
;
;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
;
;   Inputs:	ThisSFT as the sft of the desired file
;		DS is DOSDATA
;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
;   Registers modified: none
;--------------------------------------------------------------------------

procedure   SWAPCON,NEAR
	DOSAssume   <DS>,"SwapCon"

	mov	byte ptr [ConSwap], 1		; ConSwap = TRUE

	push	ax
	mov	ax, word ptr ThisSFT
	mov	word ptr ConSFT, ax
	mov	ax, word ptr ThisSFT+2
	mov	word ptr ConSFT+2, ax
	pop	ax

	return

EndProc SWAPCON

Break	<DOS_READ -- DEVICE Read Routine>
;-----------------------------------------------------------------------------
;
; Inputs:
;	ThisSFT set to the SFT for the file being used
;	[DMAADD] contains transfer address
;	CX = No. of bytes to read
;	DS = DOSDATA
; Function:
;	Perform read operation
; Outputs:
;    Carry clear
;	CX = No. of bytes read
;	ES:DI point to SFT
;    Carry set
;	AX is error code
;	CX = 0
;	ES:DI point to SFT
; DS preserved, all other registers destroyed
;
;-----------------------------------------------------------------------------


procedure   DOS_READ,NEAR
	DOSAssume   <DS>,"DOS_Read"

	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"DOS_Read"

; We are reading from a device.  Examine the status of the device to see if we
; can short-circuit the I/O.  If the device in the EOF state or if it is the
; null device, we can safely indicate no transfer.

READDEV:
	DOSAssume   <DS>,"ReadDev"
	ASSUME	ES:NOTHING
	MOV	ExtErr_Locus,errLOC_SerDev
	MOV	BL,BYTE PTR ES:[DI].SF_FLAGS
	LES	DI,[DMAADD]
	test	BL,devid_device_EOF	; End of file?
	JZ	ENDRDDEVJ3
	test	BL,devid_device_null	; NUL device?
	JZ	TESTRAW 		; NO
	XOR	AL,AL			; Indicate EOF by setting zero
ENDRDDEVJ3:
	JMP	ENDRDDEVJ2

;
; We need to hit the device.  Figure out if we do a raw read or we do the
; bizarre std_con_string_input.
;
TESTRAW:
	test	BL,devid_device_raw	; Raw mode?
	JNZ	DVRDRAW 		; Yes, let the device do all local editing
	test	BL,devid_device_con_in	; Is it console device?
	JZ	NOTRDCON
	JMP	READCON

DVRDRAW:
	DOSAssume   <DS>,"DvRdRaw"	; BUGBUG - wasted DOSASSUME?
	PUSH	ES
	POP	DS			; Xaddr to DS:DI
    ASSUME DS:NOTHING


;
; NTVDM We don't do idling in ntdos we let softpc handle everything
; thus NO support polled read for win386
;
; 04-Aug-1992 Jonle
;
;
;;Check for win386 presence -- if present, do polled read of characters
;
;
;        test    [IsWIN386],1
;        jz      ReadRawRetry            ;not present
;        test    bl,devid_device_con_in  ;is it console device
;        jz      ReadRawRetry            ;no, do normal read
;        jmp     do_polling              ;yes, do win386 polling loop

ReadRawRetry:
	MOV	BX,DI			; DS:BX transfer addr
	XOR	AX,AX			; Media Byte, unit = 0
	MOV	DX,AX			; Start at 0
	invoke	SETREAD
	PUSH	DS			; Save Seg part of Xaddr

	LDS	SI,ThisSFT
	Assert	ISSFT,<DS,SI>,"DvRdRawR"
	call	DEVIOCALL
	MOV	DX,DI			; DS:DX is preserved by INT 24
	MOV	AH,86H			; Read error

	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	jns	crdrok			; no errors
	call	CHARHARD
	MOV	DI,DX			; DS:DI is Xaddr

	add	di, callscnt		; update ptr and count to reflect the	M065
	sub	cx, callscnt		; number of chars xferred		M065

	OR	AL,AL
	JZ	CRDROK			; Ignore
	CMP	AL,3
	JZ	CRDFERR 		; fail.
	POP	DS			; Recover saved seg part of Xaddr
	JMP	ReadRawRetry		; Retry

;
; We have encountered a device-driver error.  We have informed the user of it
; and he has said for us to fail the system call.
;
CRDFERR:
	POP	DI			; Clean stack
DEVIOFERR:

	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"DEVIOFERR"
	transfer    SET_ACC_ERR_DS

CRDROK:
	POP	DI			; Chuck saved seg of Xaddr
	MOV	DI,DX

	ADD	DI,[CALLSCNT]		; Amount transferred
IF	DEBUG
        JMP     ENDRDDEVJ2
ELSE
        JMP     SHORT ENDRDDEVJ2
ENDIF


; We are going to do a cooked read on some character device.  There is a
; problem here, what does the data look like?  Is it a terminal device, line
; CR line CR line CR, or is it file data, line CR LF line CR LF?  Does it have
; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
; going to do this:  Read in pieces up to CR (CRs included in data) or ^z (^z
; included in data).  this "simulates" the way con works in cooked mode
; reading one line at a time.  With file data, however, the lines will look
; like, LF line CR.  This is a little weird.

NOTRDCON:
	MOV	AX,ES
	MOV	DS,AX
ASSUME	DS:NOTHING
	MOV	BX,DI
	XOR	DX,DX
	MOV	AX,DX
	PUSH	CX
	MOV	CX,1
	invoke	SETREAD
	POP	CX

	LDS	SI,ThisSFT
	Assert	ISSFT,<DS,SI>,"/NotRdCon"
	LDS	SI,[SI.sf_devptr]
DVRDLP:
	invoke	DSKSTATCHK
	call	DEVIOCALL2
	PUSH	DI		; Save "count" done
	MOV	AH,86H

	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	jns	CRDOK
	call	CHARHARD
	POP	DI

	MOV	[CALLSCNT],1
	CMP	AL,1
	JZ	DVRDLP			;Retry
	CMP	AL,3
	JZ	DEVIOFERR		; FAIL
	XOR	AL,AL			; Ignore, Pick some random character
	JMP	SHORT DVRDIGN

CRDOK:
	POP	DI

	CMP	[CALLSCNT],1
	JNZ	ENDRDDEVJ2
	PUSH	DS

	MOV	DS,WORD PTR [CALLXAD+2]
	MOV	AL,BYTE PTR [DI]	; Get the character we just read
	POP	DS
DVRDIGN:

	INC	WORD PTR [CALLXAD]	; Next character
	MOV	[DEVCALL.REQSTAT],0
	INC	DI			; Next character
	CMP	AL,1AH			; ^Z?
	JZ	ENDRDDEVJ2		; Yes, done zero set (EOF)
	CMP	AL,c_CR 		; CR?
	LOOPNZ	DVRDLP			; Loop if no, else done
	INC	AX			; Resets zero flag so NOT EOF, unless
					;  AX=FFFF which is not likely
ENDRDDEVJ2:
        JMP     SHORT ENDRDDEV



;
; NTVDM We don't do idling in ntdos we let softpc handle everything
; thus NO support polled read for win386
;
; 04-Aug-1992 Jonle
;
;;Polling code for raw read on CON when WIN386 is present
;;
;;At this point -- ds:di is transfer address
;;                 cx is count
;;
;
;do_polling:
;        mov     bx,di                   ;ds:bx is Xfer address
;        xor     ax,ax
;        mov     dx,ax
;        call    setread                 ;prepare device packet
;
;do_io:
;;
;;Change read to a NON-DESTRUCTIVE READ, NO WAIT
;;
;        mov     byte ptr es:[bx+2],DEVRDND      ;Change command code
;        push    ds
;        lds     si,[THISSFT]            ;get device header
;        call    deviocall               ;call device driver
;        pop     ds
;
;        test    es:[bx.REQSTAT],STERR   ;check if error
;        jz      check_busy              ;no
;
;        push    ds
;        mov     dx,di
;        invoke  charhard                ;invoke int 24h handler
;        mov     di,dx
;        or      al,al
;        jz      pop_done_read           ;ignore by user, assume read done
;        cmp     al,3
;        jz      devrderr                ;user asked to fail
;        pop     ds
;        jmp     do_io                   ;user asked to retry
;
;check_busy:
;        test    es:[bx.REQSTAT],0200h   ;see if busy bit set
;        jnz     no_char                 ;yes, no character available
;;
;;Character is available. Read in 1 character at a time until all characters
;;are read in or no character is available
;
;        mov     byte ptr es:[bx+2],DEVRD        ;command code is READ now
;        mov     word ptr es:[bx+18],1           ;change count to 1 character
;        push    ds
;        lds     si,[THISSFT]
;        call    deviocall
;
;        mov     dx,di
;        mov     ah,86h
;        mov     di,es:[bx.REQSTAT]      ;get returned status
;        test    di,STERR                ;was there an error during read?
;        jz      next_char               ;no,read next character
;
;        invoke  charhard                ;invoke int 24h handler
;        mov     di,dx                   ;restore di
;        or      al,al                   ;
;        jz      pop_done_read           ;ignore by user,assume read is done
;        cmp     al,3
;        jz      devrderr                ;user issued a 'fail',indicate error
;        pop     ds
;        jmp     do_io                   ;user issued a retry
;
;next_char:
;        pop     ds
;        mov     di,dx
;        dec     cx                      ;decrement count
;        jcxz    done_read               ;all characters read in
;        inc     word ptr es:[bx+14]     ;update transfer address
;        jmp     do_io                   ;read next character in
;
;devrderr:
;        pop     di                      ;discard segment address
;        les     di,[THISSFT]
;        transfer SET_ACC_ERR_DS         ;indicate error
;
;no_char:
;
;
;;
;;Since no character is available, we let win386 switch the VM out
;;
;        push    ax
;        mov     ah,84h
;        int     2ah                     ;indicate idle to WIN386
;;
;;When control returns  from WIN386, we continue the raw read
;;
;        pop     ax
;
;        jmp     do_io
;
;pop_done_read:
;        pop     ds
;done_read:
;        add     di,[CALLSCNT]
;        jmp     ENDRDDEVJ3      ;jump back to normal DOS raw read exit
;


ASSUME	DS:NOTHING,ES:NOTHING

TRANBUF:
	LODSB
	STOSB
	CMP	AL,c_CR 	; Check for carriage return
	JNZ	NORMCH
	MOV	BYTE PTR [SI],c_LF
NORMCH:
	CMP	AL,c_LF
	LOOPNZ	TRANBUF
	JNZ	ENDRDCON
	XOR	SI,SI		; Cause a new buffer to be read
	call	OUTT		; Transmit linefeed
	OR	AL,1		; Clear zero flag--not end of file
ENDRDCON:

	Context DS
	CALL	SWAPBACK
	MOV	[CONTPOS],SI
ENDRDDEV:

	Context DS

	MOV	[NEXTADD],DI
	JNZ	SETSFTC 	; Zero set if Ctrl-Z found in input
	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"EndRdDev"
	AND	BYTE PTR ES:[DI].SF_FLAGS,NOT devid_device_EOF ; Mark as no more data available
SETSFTC:
	call	SETSFT
	return

ASSUME	DS:NOTHING,ES:NOTHING

READCON:
	DOSAssume   <DS>,"ReadCon"
	CALL	SWAPCON
	MOV	SI,[CONTPOS]
	OR	SI,SI
	JNZ	TRANBUF
	CMP	BYTE PTR [CONBUF],128
	JZ	GETBUF
	MOV	WORD PTR [CONBUF],0FF80H	; Set up 128-byte buffer with no template
GETBUF:
	PUSH	CX
	PUSH	ES
	PUSH	DI

	MOV	DX,OFFSET DOSDATA:CONBUF

	invoke	$STD_CON_STRING_INPUT		; Get input buffer
	POP	DI
	POP	ES
	POP	CX

	MOV	SI,2 + OFFSET DOSDATA:CONBUF

	CMP	BYTE PTR [SI],1AH	; Check for Ctrl-Z in first character
	JNZ	TRANBUF
	MOV	AL,1AH
	STOSB
	DEC	DI
	MOV	AL,c_LF
	call	OUTT		; Send linefeed
	XOR	SI,SI
	JMP	ENDRDCON

EndProc DOS_READ

Break	<DOS_WRITE -- DEVICE Write Routine>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_WRITE
;
; Inputs:
;	ThisSFT set to the SFT for the file being used
;	[DMAADD] contains transfer address
;	CX = No. of bytes to write
; Function:
;	Perform write operation
;	NOTE: If CX = 0 on input, file is truncated or grown
;		to current sf_position
; Outputs:
;    Carry clear
;	CX = No. of bytes written
;	ES:DI point to SFT
;    Carry set
;	AX is error code
;	CX = 0
;	ES:DI point to SFT
; DS preserved, all other registers destroyed
;---------------------------------------------------------------------------

procedure   DOS_WRITE,NEAR
	DOSAssume   <DS>,"DOS_Write"

	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"DosWrite"
; BUGBUG sudeepb 12-Mar-1991 Take care of this RO stuff of FCBS in
; appropriate FCB routines.
;
; NOTE: The following check for writting to a Read Only File is performed
;	    ONLY on FCBs!!!!
;	We ALLOW writes to Read Only files via handles to allow a CREATE
;	    of a read only file which can then be written to.
;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
;	    CREATing a NEW RO file, or RE-CREATing an existing file which
;	    is NOT RO to be RO, via handles are the only times we can write
;	    to a read-only file.
;
;Check_FCB_RO:
;	TESTB	ES:[DI.sf_mode],sf_isfcb
;	JZ	WRITE_NO_MODE		; Not an FCB
;	TESTB	ES:[DI].sf_attr,attr_read_only
;	JNZ	BadMode 		; Can't write to Read_Only files via FCB
;WRITE_NO_MODE:
;	call	SETUP
;	invoke	IsSFTNet
;	JZ	LOCAL_WRITE

	JMP	WRTDEV

DVWRTRAW:
ASSUME	DS:NOTHING
	XOR	AX,AX			; Media Byte, unit = 0
	invoke	SETWRITE
	PUSH	DS			; Save seg of transfer

;hkn; SS override
	LDS	SI,ThisSFT
	Assert	ISSFT,<DS,SI>,"DosWrite/DvWrtRaw"
	call	DEVIOCALL		; DS:SI -> DEVICE


	MOV	DX,DI			; Offset part of Xaddr saved in DX
	MOV	AH,87H

;hkn; SS override
	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	jns	CWRTROK
	call	CHARHARD

	sub	cx, callscnt		; update ptr & count to reflect	M065
	mov	bx, dx			; number of chars xferred	M065
	add	bx, callscnt		;				M065
	mov	di, bx			;				M065

;	MOV	BX,DX			; Recall transfer addr		M065

	OR	AL,AL
	JZ	CWRTROK 		; Ignore
	CMP	AL,3
	JZ	CWRFERR
	POP	DS			; Recover saved seg of transfer
	JMP	DVWRTRAW		; Try again

CWRFERR:
	POP	AX			; Chuck saved seg of transfer
	JMP	CRDFERR 		; Will pop one more stack element

CWRTROK:
	POP	AX			; Chuck saved seg of transfer
	POP	DS
	DOSAssume   <DS>,"DISK/CWrtOK"
	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
ENDWRDEV:
	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"DosWrite/EndWrDev"
	MOV	CX,AX
	call	ADDREC
	return

WRTNUL:
	MOV	DX,CX			;Entire transfer done
WrtCookJ:
	JMP	WRTCOOKDONE

WRTDEV:
	DOSAssume   <DS>,"DISK/WrtDev"
	MOV	ExtErr_Locus,errLOC_SerDev
	OR	BYTE PTR ES:[DI].SF_FLAGS,devid_device_EOF  ; Reset EOF for input
	MOV	BL,BYTE PTR ES:[DI].SF_FLAGS
	XOR	AX,AX
	JCXZ	ENDWRDEV		; problem of creating on a device.
	PUSH	DS
	MOV	AL,BL
	LDS	BX,[DMAADD]		; Xaddr to DS:BX
ASSUME	DS:NOTHING
	MOV	DI,BX			; Xaddr to DS:DI
	XOR	DX,DX			; Set starting point
	test	AL,devid_device_raw	; Raw?
	JZ	TEST_DEV_CON
	JMP	DVWRTRAW

TEST_DEV_CON:
	test	AL,devid_device_con_out ; Console output device?
	DLJNZ	WRITECON
	test	AL,devid_device_null
	JNZ	WRTNUL
	MOV	AX,DX
	CMP	BYTE PTR [BX],1AH	; ^Z?
	JZ	WRTCOOKJ		; Yes, transfer nothing
	PUSH	CX
	MOV	CX,1
	invoke	SETWRITE
	POP	CX

;hkn; SS override
	LDS	SI,ThisSFT
;
;SR; Removed X25 support from here
;
	LDS	SI,[SI.sf_devptr]
DVWRTLP:
	invoke	DSKSTATCHK
	call	DEVIOCALL2
	PUSH	DI
	MOV	AH,87H

;hkn; SS override
	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	jns	CWROK
	call	CHARHARD
	POP	DI

;hkn; SS override
	MOV	[CALLSCNT],1
	CMP	AL,1
	JZ	DVWRTLP 	; Retry
	OR	AL,AL
	JZ	DVWRTIGN	; Ignore
	JMP	CRDFERR 	; Fail, pops one stack element

CWROK:
	POP	DI

;hkn; SS override
	CMP	[CALLSCNT],0
	JZ	WRTCOOKDONE
DVWRTIGN:
	INC	DX

;hkn; SS override for CALLXAD
	INC	WORD PTR [CALLXAD]
	INC	DI
	PUSH	DS
	MOV	DS,WORD PTR [CALLXAD+2]
	CMP	BYTE PTR [DI],1AH	; ^Z?
	POP	DS
	JZ	WRTCOOKDONE

;hkn; SS override
	MOV	[DEVCALL.REQSTAT],0
	LOOP	DVWRTLP
WRTCOOKDONE:
	MOV	AX,DX
	POP	DS
	JMP	ENDWRDEV

WRITECON:
	PUSH	DS

;hkn; SS is DOSDATA
	Context DS
	CALL	SWAPCON
	POP	DS
	ASSUME	DS:NOTHING
;  Find possible CTRL-Z in the user's string
	push	ds
	pop	es
	mov	dx,bx			; ds:dx string, also es:di is pointing
					; to the same string
        mov     bx,cx                   ; save passed byte count
        mov     al,'Z'-'@'              ; (AL) = CTRL-Z
	repne	scasb
	jnz	no_ctrlz
	inc	 cx			; adjust for having passed CTRL-Z
no_ctrlz:
        neg     cx                      ; (CX) = -(count remaining)
	add	cx,bx			; (CX) = original - (count remaining)
	push	cx
	call	Cons_String_Output	; ds:dx = string cx = count
CONEOF:
	POP	AX			; Count
	SUB	AX,CX			; Amount actually written
	POP	DS
	DOSAssume   <DS>,"DISK/ConEOF"
	CALL	SWAPBACK
	JMP	ENDWRDEV

EndProc DOS_WRITE

;---------------------------------------------------------------------------
;
; Procedure Name : get_io_sft
;
;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
;   CONSWAP is FALSE or if the handle desired is 2 or more.  Otherwise, we
;   retrieve the sft from ConSFT which is set by SwapCon.
;
;---------------------------------------------------------------------------

procedure   get_io_sft,near
	cmp	ConSwap,0					;smr;SS Override
	JNZ	GetRedir
GetNormal:

;hkn; SS is DOSDATA
	Context DS

	PUSH	ES
	PUSH	DI
	invoke	SFFromHandle
	JC	RET44P
	MOV	SI,ES
	MOV	DS,SI
ASSUME	DS:NOTHING
	MOV	SI,DI
RET44P:
	POP	DI
	POP	ES
	return
GetRedir:
	CMP	BX,1
	JA	GetNormal

;hkn; SS override
	LDS	SI,ConSFT
	Assert	ISSFT,<DS,SI>,"GetIOSft"
	CLC
	return
EndProc get_io_sft

Procedure SETSFT,near
	DOSAssume   <DS>,"SetSFT"
	ASSUME	ES:NOTHING

	LES	DI,[THISSFT]

	ASSUME	ES:NOTHING

	MOV	CX,[NEXTADD]
	SUB	CX,WORD PTR DMAAdd	 ; Number of bytes transfered

entry	AddRec
	DOSAssume   <DS>,"AddRec"

	Assert	ISSFT,<ES,DI>,"AddRec"

	JCXZ	RET28		; If no records read,  don't change position
	ADD	WORD PTR ES:[DI.sf_position],CX  ; Update current position
	ADC	WORD PTR ES:[DI.sf_position+2],0
RET28:	CLC
	return
endproc SETSFT

Procedure SET_ACC_ERR_DS,near
ASSUME	DS:NOTHING,ES:NOTHING

	Context DS

entry	SET_ACC_ERR
	DOSAssume   <DS>,"SET_ACC_ERR"

	XOR	CX,CX
	MOV	AX,error_access_denied
	STC
	return
endproc SET_ACC_ERR_DS

; Sudeepb 28-Jul-1992:	Following is the new routine to speed-up the DOS
; console output. We are maintaining the absolute compatibility with
; carpos,^p and the checking of ^c etc. We try to find as big a string
; as possible without any Control characters. Then this string is
; outputted in a shot. The control character still goes through outt
; to maintain all sort of compatibility problems.

csoMaxChars	equ  255		; maximum chars to output at one time in
SCHK_COUNT	equ  64			; number of OUTs before a StatChk

;**     Cons_String_Output - print string given length
;
;       Print the string on the console device
;
;       ENTRY   DS:DX   Point to output string
;		CX	number of characters in string
;
;       EXIT    None
;
;       USES    All

Procedure Cons_String_Output,near
ASSUME	DS:NOTHING,ES:NOTHING
        jcxz    cso9                    ; nothing to do?
        MOV     SI,DX                   ; get pointer to string
        xor     bx,bx                   ; zero character counter
cso1:
        LODSB
        cmp     al,' '                  ; ASCII graphic?
        jb      cso3                    ; no, write current string
        cmp     al,c_del
        je      cso3
        cmp     bx, csoMaxChars         ; Is strlen at maximum block size
        je      cso3                    ; Yes, output this block.
        inc     bx                      ; bump character counter
cso2:
        loop    cso1                    ; look at next
cso3:
        xchg    bx,cx                   ; CX=char. count, BX=number remaining
        jcxz    cso7                    ; no chars in string
        SaveReg <ds,si,bx,ax>
	TEST	BYTE PTR [PFLAG],-1	; printer echo on?
        jnz     cso4                    ; yes, do it one char. at a time
        push    ds
        invoke  StatChk
        mov     bx,1
	invoke	Get_IO_SFT		; ds:si is CONSFT
	pop	es
	mov	di,dx			; es:di is the string
        jc      cso6
        add     CarPos,cl               ; update position on line
	mov	ah,6			; 6 = output string
	invoke	IOFunc			; print the string in ES:DI; CX = count
        or      CharCo,SCHK_COUNT-1     ; force a StatChk
    ASSUME      DS:NOTHING
        jmp     short cso6
cso4:
        mov     si,dx                   ; Pflag set, let OUT to printer output
cso5:   lodsb
	CALL	OUTT
        loop    cso5
cso6:
        RestoreReg <ax,bx,si,ds>
cso7:
        xchg    bx,cx
        jcxz    cso9                    ; are we done?
	push	cx
	push	si
	CALL	OUTT
	pop	si
        pop     cx
        mov     dx,si                   ; update start of string
        xor     bx,bx
        jmp     cso2
cso9:
        xor     ax,ax
	ret
Endproc   Cons_String_Output

DOSCODE	ENDS
    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\dosmes.inc ===
;	SCCSID = @(#)dosmes.asm 1.7 85/10/23
;	SCCSID = @(#)dosmes.asm 1.7 85/10/23
;
; Message file for Internationalized messages.	There is
; only one message here available for translation.
;
;
;    Revision history
;	  A000	  version 4.00  Jan. 1988
;

; -------- M I C R O S O F T   K K ---------------------------------------------
;
;  DOSMES.ASM - MODIFICATION LOG
;
;
;	Note: For more detailed information, see "MS-DOS 4.00 SOURCE CODE
;		MODIFICATION LOG"
;
; ------------------------------------------------------------------------------
;
; 01/11/89:MSKK01:yukini:dos-2:
;	default country information changed to JAPAN (from USA).
;
; -------- M I C R O S O F T   K K ---------------------------------------------



IFNDEF	Rainbow
Rainbow EQU FALSE
ENDIF

	.xlist
	.xcref
include dossym.inc
include dosmac.inc
include doscntry.inc
	.cref
	.list


;hkn; moved to bottom of const2.asm to maintain offsets. previously in 
;hkn; CONSTANTS segment.
;hkn; 
;hkn; CONSTANTS	SEGMENT WORD PUBLIC 'CONST'
;hkn; 
;hkn;     PUBLIC  UserNum, OEMNum
;hkn;     Public DMES001S,DMES001E
;hkn; DMES001S Label byte
;hkn; USERNUM DW	?			; 24 bit user number
;hkn; 	DB	?
;hkn; IF	IBM
;hkn; 	IF	IBMCOPYRIGHT
;hkn; 	OEMNUM	DB	0			; 8 bit OEM number
;hkn; 	ELSE
;hkn; 	OEMNUM	DB	0FFH			; 8 bit OEM number
;hkn; 	ENDIF
;hkn; ELSE
;hkn; OEMNUM	DB	0FFH
;hkn; ENDIF
;hkn; 
;hkn; 
;hkn; DMES001E label byte
;hkn; CONSTANTS	ENDS

DOSCODE	Segment

	Public DMES002S
DMES002S  label byte


include divmes.inc
include yesno.asm

SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
PAGE
; The following two tables implement the current buffered input editing
; routines.  The tables are pairwise associated in reverse order for ease
; in indexing.	That is; The first entry in ESCTAB corresponds to the last
; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.


;hkn; TABLE	SEGMENT
	PUBLIC	CANCHAR
CANCHAR DB	CANCEL			;Cancel line character
	PUBLIC	ESCCHAR
ESCCHAR DB	ESCCH			;Lead-in character for escape sequences
	IF	NOT Rainbow
ESCTAB	LABEL BYTE
	IF	NOT IBM
	IF	WANG
	DB	0C0h			; ^Z inserter
	DB	0C1H			; Copy one char
	DB	0C1H			; Copy one char
	DB	0C7H			; Skip one char
	DB	08AH			; Copy to char
	DB	088H			; Skip to char
	DB	09AH			; Copy line
	DB	0CBH			; Kill line (no change in template)
	DB	08BH			; Reedit line (new template)
	DB	0C3H			; Backspace
	DB	0C6H			; Enter insert mode
	DB	0D6H			; Exit insert mode
	DB	0C6H			; Escape character
	DB	0C6H			; End of table
	ELSE
					; VT52 equivalences
	DB	"Z"                     ; ^Z inserter
	DB	"S"                     ; F1 Copy one char
	DB	"S"                     ; F1 Copy one char
	DB	"V"                     ; F4 Skip one char
	DB	"T"                     ; F2 Copy to char
	DB	"W"                     ; F5 Skip to char
	DB	"U"                     ; F3 Copy line
	DB	"E"                     ; SHIFT ERASE Kill line (no change in template)
	DB	"J"                     ; ERASE Reedit line (new template)
	DB	"D"                     ; LEFT Backspace
	DB	"P"                     ; BLUE Enter insert mode
	DB	"Q"                     ; RED Exit insert mode
	DB	"R"                     ; GRAY Escape character
	DB	"R"                     ; End of table
	ENDIF
	ENDIF
	IF	IBM
	DB	64			; Ctrl-Z - F6
	DB	77			; Copy one char - -->
	DB	59			; Copy one char - F1
	DB	83			; Skip one char - DEL
	DB	60			; Copy to char - F2
	DB	62			; Skip to char - F4
	DB	61			; Copy line - F3
	DB	61			; Kill line (no change to template ) - Not used
	DB	63			; Reedit line (new template) - F5
	DB	75			; Backspace - <--
	DB	82			; Enter insert mode - INS (toggle)
	DB	82			; Exit insert mode - INS (toggle)
	DB	65			; Escape character - F7
	DB	65			; End of table
	ENDIF
ESCEND LABEL BYTE
ESCTABLEN EQU	ESCEND-ESCTAB

ESCFUNC LABEL	WORD
	short_addr  GETCH		; Ignore the escape sequence
	short_addr  TWOESC
	short_addr  EXITINS
	short_addr  ENTERINS
	short_addr  BACKSP
	short_addr  REEDIT
	short_addr  KILNEW
	short_addr  COPYLIN
	short_addr  SKIPSTR
	short_addr  COPYSTR
	short_addr  SKIPONE
	short_addr  COPYONE
	short_addr  COPYONE
	short_addr  CTRLZ
	ENDIF
;hkn; TABLE	ENDS

;
; OEMFunction key is expected to process a single function
;   key input from a device and dispatch to the proper
;   routines leaving all registers UNTOUCHED.
;
; Inputs:   CS, SS are DOSGROUP
; Outputs:  None. This function is expected to JMP to one of
;	    the following labels:
;
;	    GetCh	- ignore the sequence
;	    TwoEsc	- insert an ESCChar in the buffer
;	    ExitIns	- toggle insert mode
;	    EnterIns	- toggle insert mode
;	    BackSp	- move backwards one space
;	    ReEdit	- reedit the line with a new template
;	    KilNew	- discard the current line and start from scratch
;	    CopyLin	- copy the rest of the template into the line
;	    SkipStr	- read the next character and skip to it in the template
;	    CopyStr	- read next char and copy from template to line until char
;	    SkipOne	- advance position in template one character
;	    CopyOne	- copy next character in template into line
;	    CtrlZ	- place a ^Z into the template
; Registers that are allowed to be modified by this function are:
;	    AX, CX, BP

ASSUME	CS:DOSCODE
Procedure   OEMFunctionKey,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 IFDEF  DBCS				;AN000;
extrn	IntCNE0:near			;AN000; 2/17/KK
	CALL	IntCNE0 		;AN000; 2/17/KK
 ELSE					;AN000;
	invoke	$std_con_input_no_echo	; Get the second byte of the sequence
 ENDIF					;AN000;
	IF NOT Rainbow
	MOV	CL,ESCTABLEN		; length of table for scan
	PUSH	DI			; save DI (cannot change it!)

;hkn; ESCTAB is in TABLE seg (DOSCODE)
	MOV	DI,OFFSET DOSCODE:ESCTAB   ; offset of second byte table

;hkn; ES should point to DOSCODE for the string scan
;
	push	es
	push	cs
	pop	es

	REPNE	SCASB			; Look it up in the table
;
;hkn;Restore es 
	pop	es

	POP	DI			; restore DI
	SHL	CX,1			; convert byte offset to word
	MOV	BP,CX			; move to indexable register

;hkn; ESCFUNC is in TABLE seg (DOSCODE)
;hkn;Use CS override since bp contains an address in DOSCODE

	JMP	CS:[BP+OFFSET DOSCODE:ESCFUNC]	; Go to the right routine
	ENDIF
	IF Rainbow

TransferIf  MACRO   value,address
	local	a
	CMP	AL,value
	JNZ	a
	transfer    address
a:
ENDM

	CMP	AL,'['                  ; is it second lead char
	JZ	EatParm 		; yes, go walk tree
GoGetCh:
	transfer    GetCh		; no, ignore sequence
EatParm:
	invoke	$std_con_input_no_echo	; get argument
	CMP	AL,'A'                  ; is it alphabetic arg?
	JAE	EatAlpha		; yes, go snarf one up
	XOR	BP,BP			; init digit counter
	JMP	InDigit 		; jump into internal eat digit routine
EatNum:
	invoke	$std_con_input_no_echo	; get next digit
InDigit:
	CMP	AL,'9'                  ; still a digit?
	JA	CheckNumEnd		; no, go check for end char
	SUB	AL,'0'                  ; turn into potential digit
	JL	GoGetCh 		; oops, not a digit, ignore
	MOV	CX,BP			; save BP for 10 multiply
	CBW				; make AL into AX
	SHL	BP,1			; 2*BP
	SHL	BP,1			; 4*BP
	ADD	BP,CX			; 5*BP
	SHL	BP,1			; 10*BP
	ADD	BP,AX			; 10*BP + digit
	JMP	EatNum			; continue with number
CheckNumEnd:
	CMP	AL,7Eh			; is it end char ~
	JNZ	GoGetCh 		; nope, ignore key sequence
	MOV	AX,BP
	transferIf  1,SkipStr		; FIND key
	transferIf  2,EnterIns		; INSERT HERE key
	transferIf  3,SkipOne		; REMOVE
	transferIf  4,CopyStr		; SELECT
	transferIf  17,TwoEsc		; INTERRUPT
	transferIf  18,ReEdit		; RESUME
	transferIf  19,KilNew		; CANCEL
	transferIf  21,CtrlZ		; EXIT
	transferIf  29,CopyLin		; DO
	JMP	GoGetCh
EatAlpha:
	CMP	AL,'O'                  ; is it O?
	JA	GoGetCh 		; no, after assume bogus
	JZ	EatPQRS 		; eat the rest of the bogus key
	transferIf  'C',CopyOne         ; RIGHT
	transferIf  'D',BackSp          ; LEFT
	JMP	GoGetCh
EatPQRS:
	invoke	$std_con_input_no_echo	; eat char after O
	JMP	GoGetCh
	ENDIF

EndProc OEMFunctionKey

DOSCODE		ENDS

	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\dup.asm ===
TITLE	DOS_DUP - Internal SFT DUP (for network SFTs)
	NAME	DOS_DUP

;**	Low level DUP routine for use by EXEC when creating a new process. Exports
;	  the DUP to the server machine and increments the SFT ref count
;
;	DOS_DUP
;
;	Modification history:
;
;	  Created: ARR 30 March 1983

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	.cref
	.list

	i_need	THISSFT,DWORD


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	allow_getdseg

BREAK <DOS_DUP -- DUP SFT across network>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_DUP
;
; Inputs:
;	[THISSFT] set to the SFT for the file being DUPed
;		(a non net SFT is OK, in this case the ref
;		 count is simply incremented)
; Function:
;	Signal to the devices that alogical open is occurring
; Returns:
;	ES:DI point to SFT
;    Carry clear
;	SFT ref_count is incremented
; Registers modified: None.
; NOTE:
;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
;	time with SS NOT DOSGROUP. There will be no Network handles at
;	that time.

procedure   DOS_DUP,NEAR

	ASSUME	SS:NOTHING

	getdseg	<es>			; es -> dosdata
	LES	DI,ThisSFT
	assume	es:nothing	

	Entry	Dos_Dup_Direct
	Assert	ISSFT,<ES,DI>,"DOSDup"
	invoke	IsSFTNet
	JNZ	DO_INC
	invoke	DEV_OPEN_SFT
DO_INC:
	Assert	ISSFT,<ES,DI>,"DOSDup/DoInc"
	INC	ES:[DI.sf_ref_count]	; Clears carry (if this ever wraps
					;   we're in big trouble anyway)
	return

EndProc DOS_DUP

DOSCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\dostab.asm ===
;
;	Revision History
;	================
;
;	Sudeepb 12-Mar-1991 Ported for NTDOSEm
;				 

IFNDEF	Rainbow
Rainbow EQU FALSE
ENDIF

	.xlist
	.xcref
include dosmac.inc
	.cref
	.list

DOSDATA	Segment


;
; upper case table
;
UCASE_TAB    label   byte
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
		dw	128
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
else
		    dw	128
		    db	128,154,144,065,142,065,143,128
		    db	069,069,069,073,073,073,142,143
		    db	144,146,146,079,153,079,085,085
		    db	089,153,154,155,156,157,158,159
		    db	065,073,079,085,165,165,166,167
		    db	168,169,170,171,172,173,174,175
		    db	176,177,178,179,180,181,182,183
		    db	184,185,186,187,188,189,190,191
		    db	192,193,194,195,196,197,198,199
		    db	200,201,202,203,204,205,206,207
		    db	208,209,210,211,212,213,214,215
		    db	216,217,218,219,220,221,222,223
		    db	224,225,226,227,228,229,230,231
		    db	232,233,234,235,236,237,238,239
		    db	240,241,242,243,244,245,246,247
		    db	248,249,250,251,252,253,254,255
; ----------------------------------<MSKK01>----------------------
endif

;
; file upper case table
;
FILE_UCASE_TAB	label  byte
; ----------------------------------<MSKK01>----------------------
ifdef	DBCS
		dw	128
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
else
		dw  128
		db  128,154,069,065,142,065,143,128                  ;M075
		db  069,069,069,073,073,073,142,143
		db  144,146,146,079,153,079,085,085
		db  089,153,154,155,156,157,158,159                  ;M075
		db  065,073,079,085,165,165,166,167
		db  168,169,170,171,172,173,174,175
		db  176,177,178,179,180,181,182,183
		db  184,185,186,187,188,189,190,191
		db  192,193,194,195,196,197,198,199
		db  200,201,202,203,204,205,206,207
		db  208,209,210,211,212,213,214,215
		db  216,217,218,219,220,221,222,223
		db  224,225,226,227,228,229,230,231
		db  232,233,234,235,236,237,238,239
		db  240,241,242,243,244,245,246,247
		db  248,249,250,251,252,253,254,255

endif
; ---------------------------------<MSKK01>----------------------

;
; file char list
;
FILE_CHAR_TAB  label  byte
		dw	22				; length
		db	1,0,255 			; include all
		db	0,0,20h 			; exclude 0 - 20h
		db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
		db	24 dup (?)			; reserved
;
; collate table
;
COLLATE_TAB    label   byte
; ---------------------------------<MSKK01>----------------------
ifdef	DBCS
  ifdef	  JAPAN
		dw	256
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	128,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	129,130,131,132,133,189,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,190,191,192
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
  endif
  ifdef	  TAIWAN
		dw	256
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255

  endif
  ifdef	  PRC		 ; Added for PRC, 95/07/26
		dw	256
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255

  endif
  ifdef   KOREA							;Keyl/MSCH
                dw      256
                db      0,1,2,3,4,5,6,7
                db      8,9,10,11,12,13,14,15
                db      16,17,18,19,20,21,22,23
                db      24,25,26,27,28,29,30,31
                db      " ","!",'"',"#","$","%","&","'"
                db      "(",")","*","+",",","-",".","/"
                db      "0","1","2","3","4","5","6","7"
                db      "8","9",":",";","<","=",">","?"
                db      "@","A","B","C","D","E","F","G"
                db      "H","I","J","K","L","M","N","O"
                db      "P","Q","R","S","T","U","V","W"
                db      "X","Y","Z","[","\","]","^","_"
                db      "`","A","B","C","D","E","F","G"
                db      "H","I","J","K","L","M","N","O"
                db      "P","Q","R","S","T","U","V","W"
                db      "X","Y","Z","{","|","}","~",127
                db      128,190,191,192,193,194,195,196
                db      197,198,199,200,201,202,203,204
                db      205,206,207,208,209,210,211,212
                db      213,214,215,216,217,218,219,220
                db      221,222,223,224,225,226,227,228
                db      229,230,231,232,233,234,235,236
                db      237,238,239,240,241,242,243,244
                db      245,246,247,248,249,250,251,252
                db      129,130,131,132,133,134,135,136
                db      137,138,139,140,141,142,143,144
                db      145,146,147,148,149,150,151,152
                db      153,154,155,156,157,158,159,160
                db      161,162,163,164,165,166,167,168
                db      169,170,171,172,173,174,175,176
                db      177,178,179,180,181,182,183,184
                db      185,186,187,188,189,253,254,255
  endif
else
		dw	256
	db	0,1,2,3,4,5,6,7
	db	8,9,10,11,12,13,14,15
	db	16,17,18,19,20,21,22,23
	db	24,25,26,27,28,29,30,31
	db	" ","!",'"',"#","$","%","&","'"
	db	"(",")","*","+",",","-",".","/"
	db	"0","1","2","3","4","5","6","7"
	db	"8","9",":",";","<","=",">","?"
	db	"@","A","B","C","D","E","F","G"
	db	"H","I","J","K","L","M","N","O"
	db	"P","Q","R","S","T","U","V","W"
	db	"X","Y","Z","[","\","]","^","_"
	db	"`","A","B","C","D","E","F","G"
	db	"H","I","J","K","L","M","N","O"
	db	"P","Q","R","S","T","U","V","W"
	db	"X","Y","Z","{","|","}","~",127
	db	"C","U","E","A","A","A","A","C"
	db	"E","E","E","I","I","I","A","A"
	db	"E","A","A","O","O","O","U","U"
	db	"Y","O","U","$","$","$","$","$"
	db	"A","I","O","U","N","N",166,167
	db	"?",169,170,171,172,"!",'"','"'
	db	176,177,178,179,180,181,182,183
	db	184,185,186,187,188,189,190,191
	db	192,193,194,195,196,197,198,199
	db	200,201,202,203,204,205,206,207
	db	208,209,210,211,212,213,214,215
	db	216,217,218,219,220,221,222,223
	db	224,"S"
	db	226,227,228,229,230,231
	db	232,233,234,235,236,237,238,239
	db	240,241,242,243,244,245,246,247
	db	248,249,250,251,252,253,254,255
endif


; -------------------------------<MSKK01>----------------------

;
; dbcs is not supported in DOS 3.3
;		   DBCS_TAB	    CC_DBCS <>
;
; DBCS for DOS 4.00			   2/12/KK
   PUBLIC    DBCS_TAB
DBCS_TAB	label byte		;AN000;  2/12/KK
; -------------------------------<MSKK01>----------------------
ifdef	DBCS
  ifdef	  JAPAN
		dw	6		; <MSKK01>
		db	081h,09fh	; <MSKK01>
		db	0e0h,0fch	; <MSKK01>
		db	0,0		; <MSKK01>

		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
  endif
  ifdef	  TAIWAN
		dw	4		; <TAIWAN>
                db      081h,0FEh       ; <TAIWAN>
		db	0,0		; <TAIWAN>

		db	0,0,0,0,0,0,0,0,0,0,0,0
  endif
  ifdef   KOREA                         ; Keyl
                dw      4               ; <KOREA>
                db      0A1h,0FEh       ; <KOREA>
                db      0,0             ; <KOREA>

		db	0,0,0,0,0,0,0,0,0,0,0,0
  endif
  ifdef	  PRC				; Added for PRC, 95/07/26
  		dw	4      			; <PRC>
		db  081h, 0FEh 	        ; <PRC>
		db  0,0                 ; <PRC>

		db	0,0,0,0,0,0,0,0,0,0,0,0
  endif
else
		dw	0		;AN000;  2/12/KK      max number
		db	16 dup(0)	;AN000;  2/12/KK

;		dw	6		;  2/12/KK
;		db	081h,09fh	;  2/12/KK
;		db	0e0h,0fch	;  2/12/KK
;		db	0,0		;  2/12/KK
;
;
endif
; ---------------------------------<MSKK01>----------------------

ASSUME	CS:DOSDATA,DS:NOTHING,ES:NOTHING,SS:NOTHING

;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
;     ENTRY: AL = Character to map
;     EXIT:  AL = The converted character
; Alters no registers except AL and flags.
; The routine should do nothing to chars below 80H.
;
; Example:

Procedure   MAP_CASE,FAR
	CMP	AL,80H
	JAE	Map1		;Map no chars below 80H ever
	RET
Map1:
	SUB	AL,80H		;Turn into index value
	PUSH	DS
	PUSH	BX
	MOV	BX,OFFSET DOSDATA:UCASE_TAB + 2
FINISH:

	PUSH	CS		;Move to DS
	POP	DS
	XLAT	ds:[bx] 	;Get upper case character
	POP	BX
	POP	DS
L_RET:	RET
EndProc MAP_CASE



;
; The following pieces of data have been moved from the DOS 4 TABLE/CODE 
; segment and added at the end of the DOS data area.
;


; Moved from the TABLE segment in getset.asm

	IF	ALTVECT
VECIN:
; INPUT VECTORS
Public GSET001S,GSET001E
GSET001S  label byte
	DB	22H			; Terminate
	DB	23H			; ^C
	DB	24H			; Hard error
	DB	28H			; Spooler
LSTVEC	DB	?			; ALL OTHER

VECOUT:
; GET MAPPED VECTOR
	DB	int_terminate
	DB	int_ctrl_c
	DB	int_fatal_abort
	DB	int_spooler
LSTVEC2 DB	?			; Map to itself

NUMVEC	=	VECOUT-VECIN
GSET001E label byte
	ENDIF

; Moved from TABLE segment in ms_table.asm

;---------------------------------------Start of Korean support  2/11/KK
;
; The varialbes for ECS version are moved here for the same data alignments
; as IBM-DOS and MS-DOS.
;

        I_AM    InterChar, byte         ; Interim character flag ( 1= interim)  ;AN000;
                                                                                ;AN000;
;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! ---------------------
DUMMY   LABEL   WORD                                                            ;AN000;
        PUBLIC  InterCon                ; Console in Interim mode ( 1= interim) ;AN000;
InterCon        db      0                                                       ;AN000;
        PUBLIC  SaveCurFlg              ; Print, do not advance cursor flag     ;AN000;
SaveCurFlg      db      0                                                       ;AN000;
;-----------------------------------------End of Korean support  2/11/KK


	I_am	TEMPSEG,WORD		;hkn; used to store ds.

public	redir_patch
redir_patch	db	0

public Mark1
	Mark1 label byte


IF2
	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
	ENDIF
ENDIF

;###########################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
; 
; The redir requires the following:
;
;	MSVERS	offset D12H
;	YRTAB	offset D14H
; 	MONTAB	offset D1CH
;
; WARNING! WARNING!
; 
; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
;
; CURRENTLY MARK1 = 0D0DH
;
;##########################################################################

ifndef NEC_98
ifndef JAPAN
; WARNING! WARNING!
; MSVERSION's offset is not kept due to DummyCDS size's increment
; redir.exe does not use these DOS-Data area
; CURRENTLY MARK1 = 0D1FH
	ORG	0d12h
endif ; !JAPAN
else    ;NEC_98
	ORG	0d12h
endif   ;NEC_98

PUBLIC	MSVERSION
MSVERSION	LABEL BYTE	
	DB      MAJOR_VERSION
	DB      MINOR_VERSION

; YRTAB & MONTAB moved from TABLE segment in ms_table.asm

	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 


;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------

; SYS init extended table,   DOS 3.3   F.C. 5/29/86
;
	PUBLIC	SysInitTable

SysInitTable  	label  byte
	dw      OFFSET DOSDATA:SYSINITVAR	; pointer to sysinit var
        dw      0                             	; segment
        dw      OFFSET DOSDATA:COUNTRY_CDPG   	; pointer to country tabl
        dw      0                            	; segment of pointer


;
; DOS 3.3 F.C. 6/12/86
; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
;
	PUBLIC	FastOpenTable
	PUBLIC  FastTable               ; a better name
	EXTRN   FastRet:FAR             ; defined in misc2.asm

FastTable	label  byte		; a better name
FastOpenTable  	label  byte
	dw      2                       ; number of entries
	dw      OFFSET DOSCODE:FastRet	; pointer to ret instr.
	dw      0                       ; and will be modified by
	dw      OFFSET DOSCODE:FastRet  ; FASTxxx when loaded in
	dw      0                       
;
; DOS 3.3 F.C. 6/12/86
;

	PUBLIC	FastFlg                 ; flags
FastFlg         label  byte             ; don't change the foll: order
        I_am    FastOpenFlg,BYTE,<0>     
;  RMFS I_am	FastSeekFlg,BYTE,<0>	 


       PUBLIC   FastOpen_Ext_Info

; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
; and clusnum  which are filled by DOS 3.ncwhen calling FastOpen Insert
; or filled by FastOPen when calling FastOpen Lookup

FastOpen_Ext_Info  label  byte		;dirpos
	db	SIZE FASTOPEN_EXTENDED_INFO dup(0) 

; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
; when calling FastOpen Lookup

	PUBLIC  Dir_Info_Buff

Dir_Info_Buff  	label  byte
	db   	SIZE dir_entry dup (0)


	I_am	Next_Element_Start,WORD	; save next element start offset

	I_am    Del_ExtCluster,WORD     ; for dos_delete                       


; The following is a stack and its pointer for interrupt 2F which is uesd
; by NLSFUNC.  There is no significant use of this stack, we are just trying
; not to destroy the INT 21 stack saved for the user.


	PUBLIC	USER_SP_2F

USER_SP_2F      LABEL  WORD
	dw    	OFFSET DOSDATA:FAKE_STACK_2F

	PUBLIC  Packet_Temp
Packet_Temp     label  word		; temporary packet used by readtime
	PUBLIC  DOS_TEMP                ; temporary word
DOS_TEMP        label  word
FAKE_STACK_2F   dw   14 dup (0)         ; 12 register temporary storage

	PUBLIC  Hash_Temp              	; temporary word
Hash_Temp	label  word              
		dw    4 dup (0)		; temporary hash table during config.sys

	PUBLIC  SCAN_FLAG              	; flag to indicate key ALT_Q
SCAN_FLAG      	label  byte
               	db     0

	PUBLIC  DATE_FLAG
DATE_FLAG      	label  word 		; flag to
               	dw     0                ; to update the date

FETCHI_TAG	label  word		; OBSOLETE - no longer used
		dw     0		; formerly part of IBM's piracy protection


      PUBLIC    MSG_EXTERROR 		; for system message addr              
MSG_EXTERROR    label  DWORD                                                     
                dd     0                ; for extended error                   
                dd     0                ; for parser                           
               	dd     0                ; for critical errror                  
               	dd     0                ; for IFS                              
              	dd     0                ; for code reduction                   

      PUBLIC   	SEQ_SECTOR              ; last sector read                     
SEQ_SECTOR     	label  DWORD                                                     
               	dd     -1                                                        

;;      I_am    ACT_PAGE,WORD,<-1>      ; active EMS page                       
	I_am    SC_SECTOR_SIZE,WORD     ; sector size for SC                 
        I_am    SC_DRIVE,BYTE           ; drive # for secondary cache        
        I_am    CurSC_DRIVE,BYTE,<-1>   ; current SC drive                   
        I_am    CurSC_SECTOR,DWORD      ; current SC starting sector         
        I_am    SC_STATUS,WORD,<0>      ; SC status word                     
        I_am    SC_FLAG,BYTE,<0>        ; SC flag                            
        I_am    AbsDskErr,WORD,<0>	; Storage for Abs dsk read/write err

	PUBLIC 	NO_NAME_ID                                                           
NO_NAME_ID      label byte                                                           
                db   'NO NAME    '	; null media id                      

;hkn; moved from TABLE segment in kstrin.asm

Public	KISTR001S,KISTR001E,LOOKSIZ	; 2/17/KK
KISTR001S	label	byte		; 2/17/KK
LOOKSIZ DB	0			; 0 if byte, NZ if word	2/17/KK
KISTR001E	label	byte		; 2/17/KK



; the nul device driver used to be part of the code.  However, since the 
; header is in the data, and the entry points are only given as an offset,
; the strategy and interrupt entry points must also be in the data now.
;

procedure   snuldev,far
assume ds:nothing,es:nothing,ss:nothing, cs:dosdata
 	or	es:[bx.reqstat],stdon	; set done bit
entry inuldev
	ret				; must not be a return!
endproc snuldev

;M044
; Second part of save area for saving last para of Windows memory
;
public WinoldPatch2
WinoldPatch2	db	8 dup (?)	; M044

public	UmbSave2, UmbSaveFlag		; M062
UmbSave2	db	5 dup (?)	; M062
UmbSaveFlag	db	0		; M062

public Mark2
	Mark2	label byte

IF2
	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
	ENDIF
ENDIF


;###########################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
; 
; The redir requires the following:
;
;	ERR_TABLE_21	offset DDBH
;	ERR_TABLE_24	offset E5BH
; 	ErrMap24	offset EABH
;
; WARNING! WARNING!
;
; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
;
; CURRENTLY MARK2 = 0DD0H
;
;##########################################################################



ifndef NEC_98
ifndef JAPAN
; WARNING! WARNING!
; MSVERSION's offset is not kept due to DummyCDS size's increment
; redir.exe does not use these DOS-Data area
; CURRENTLY MARK2 = 0DE8H
	ORG	0ddbh
endif ; !JAPAN
else    ;NEC_98
	ORG	0ddch			;NEC NT PROT
endif   ;NEC_98
;**
;
; The following table defines CLASS ACTION and LOCUS info for the INT 21H
; errors.  Each entry is 4 bytes long:
;
;       Err#,Class,Action,Locus
;
; A value of 0FFh indicates a call specific value (ie.  should already
; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
;

ErrTab  Macro   err,class,action,locus
ifidn <locus>,<0FFh>
    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
ELSE
    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
ENDIF
ENDM

PUBLIC  ERR_TABLE_21
ERR_TABLE_21    LABEL   BYTE
    ErrTab  invalid_function,       Apperr,     Abort,      0FFh
    ErrTab  file_not_found,         NotFnd,     User,       Disk
    ErrTab  path_not_found,         NotFnd,     User,       Disk
    ErrTab  too_many_open_files,    OutRes,     Abort,      Unk
    ErrTab  access_denied,          Auth,       User,       0FFh
    ErrTab  invalid_handle,         Apperr,     Abort,      Unk
    ErrTab  arena_trashed,          Apperr,     Panic,      Mem
    ErrTab  not_enough_memory,      OutRes,     Abort,      Mem
    ErrTab  invalid_block,          Apperr,     Abort,      Mem
    ErrTab  bad_environment,        Apperr,     Abort,      Mem
    ErrTab  bad_format,             BadFmt,     User,       Unk
    ErrTab  invalid_access,         Apperr,     Abort,      Unk
    ErrTab  invalid_data,           BadFmt,     Abort,      Unk
    ErrTab  invalid_drive,          NotFnd,     User,       Disk
    ErrTab  current_directory,      Auth,       User,       Disk
    ErrTab  not_same_device,        Unk,        User,       Disk
    ErrTab  no_more_files,          NotFnd,     User,       Disk
    ErrTab  file_exists,            Already,    User,       Disk
    ErrTab  sharing_violation,      Locked,     DlyRet,     Disk
    ErrTab  lock_violation,         Locked,     DlyRet,     Disk
    ErrTab  out_of_structures,      OutRes,     Abort,      0FFh
    ErrTab  invalid_password,       Auth,       User,       Unk
    ErrTab  cannot_make,            OutRes,     Abort,      Disk
    ErrTab  Not_supported,          BadFmt,     User,       Net
    ErrTab  Already_assigned,       Already,    User,       Net
    ErrTab  Invalid_Parameter,      BadFmt,     User,       Unk
    ErrTab  FAIL_I24,               Unk,        Abort,      Unk
    ErrTab  Sharing_buffer_exceeded,OutRes,     Abort,      Mem
    ErrTab  Handle_EOF,             OutRes,     Abort,      Unk     ;AN000;
    ErrTab  Handle_DISK_FULL,       OutRes,     Abort,      Unk     ;AN000;
    ErrTab  sys_comp_not_loaded,    Unk,        Abort,      Disk    ;AN001;
    DB      0FFh,                   0FFH,       0FFH,       0FFh

;
; The following table defines CLASS ACTION and LOCUS info for the INT 24H
; errors.  Each entry is 4 bytes long:
;
;       Err#,Class,Action,Locus
;
; A Locus value of 0FFh indicates a call specific value (ie.  should already
; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
; THE END.

PUBLIC  ERR_TABLE_24
ERR_TABLE_24    LABEL   BYTE
    ErrTab  write_protect,          Media,      IntRet,     Disk
    ErrTab  bad_unit,               Intrn,      Panic,      Unk
    ErrTab  not_ready,              HrdFail,    IntRet,     0FFh
    ErrTab  bad_command,            Intrn,      Panic,      Unk
    ErrTab  CRC,                    Media,      Abort,      Disk
    ErrTab  bad_length,             Intrn,      Panic,      Unk
    ErrTab  Seek,                   HrdFail,    Retry,      Disk
    ErrTab  not_DOS_disk,           Media,      IntRet,     Disk
    ErrTab  sector_not_found,       Media,      Abort,      Disk
    ErrTab  out_of_paper,           TempSit,    IntRet,     SerDev
    ErrTab  write_fault,            HrdFail,    Abort,      0FFh
    ErrTab  read_fault,             HrdFail,    Abort,      0FFh
    ErrTab  gen_failure,            Unk,        Abort,      0FFh
    ErrTab  sharing_violation,      Locked,     DlyRet,     Disk
    ErrTab  lock_violation,         Locked,     DlyRet,     Disk
    ErrTab  wrong_disk,             Media,      IntRet,     Disk
    ErrTab  not_supported,          BadFmt,     User,       Net
    ErrTab  FCB_unavailable,        Apperr,     Abort,      Unk
    ErrTab  Sharing_buffer_exceeded,OutRes,     Abort,      Mem
    DB      0FFh,                   errCLASS_Unk, errACT_Panic, 0FFh

;
; We need to map old int 24 errors and device driver errors into the new set
; of errors.  The following table is indexed by the new errors
;
Public  ErrMap24
ErrMap24    Label   BYTE
    DB  error_write_protect             ;   0
    DB  error_bad_unit                  ;   1
    DB  error_not_ready                 ;   2
    DB  error_bad_command               ;   3
    DB  error_CRC                       ;   4
    DB  error_bad_length                ;   5
    DB  error_Seek                      ;   6
    DB  error_not_DOS_disk              ;   7
    DB  error_sector_not_found          ;   8
    DB  error_out_of_paper              ;   9
    DB  error_write_fault               ;   A
    DB  error_read_fault                ;   B
    DB  error_gen_failure               ;   C
    DB  error_gen_failure               ;   D   RESERVED
    DB  error_gen_failure               ;   E   RESERVED
    DB  error_wrong_disk                ;   F

Public  ErrMap24End
ErrMap24End LABEL   BYTE



        I_am	FIRST_BUFF_ADDR,WORD            ; first buffer address               
        I_am    SPECIAL_VERSION,WORD,<0>        ;AN006; used by INT 2F 47H
        I_am    FAKE_COUNT,<255>                ;AN008; fake version count

        I_am    OLD_FIRSTCLUS,WORD              ;AN011; save old first cluster for fastopen

;----------------------------------------------------------------------------

;SR;
; WIN386 instance table for DOS
;
public	Win386_Info
Win386_Info	db	3, 0
		dd	0, 0, 0
		dw	offset dosdata:Instance_Table, 0


public	Instance_Table
ifndef NEC_98
Instance_Table	dw	offset dosdata:contpos, 0, 2
		dw	offset dosdata:bcon, 0, 4
		dw	offset dosdata:carpos, 0, 106h
		dw	offset dosdata:charco, 0, 1
		dw	offset dosdata:exec_init_sp, 0, 24
		dw	offset dosdata:umbflag,0,1		; M019
		dw	offset dosdata:umb_head,0,2		; M019
		dw	0, 0
else    ;NEC_98
Instance_Table	dw	offset dosdata:contpos, 0, 2
		dw	offset dosdata:bcon, 0, 4
		dw	offset dosdata:carpos, 0, 106h
		dw	offset dosdata:charco, 0, 1
		dw	offset dosdata:exec_init_sp, 0, 34      ; M074
		dw	offset dosdata:umbflag,0,1		; M019
		dw	offset dosdata:umb_head,0,2		; M019
;93/03/25 MVDM DOS5.0A---------------------------------------------------------
;;;		dw	offset dosdata:sftabl+4,0,127h		; NEC
		dw	offset dosdata:sftabl+6,0,0b1h		; NEC 92/05/15
;------------------------------------------------------------------------------
		dw	0, 0
endif   ;NEC_98

; M001; SR;
; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of 
; M001; some DOS variables. Note that the only really important variable in 
; M001; this is User_Id. The other variables are needed only to patch stuff 
; M001; which does not need to be done in DOS 5.0. 
; M001; 
public	Win386_DOSVars
Win386_DOSVars	db	5		;Major version 5 ; M001
		db	0		;Minor version 0 ; M001
		dw	offset dosdata:SaveDS	; M001
		dw	offset dosdata:SaveBX	; M001
		dw	offset dosdata:Indos	; M001
		dw	offset dosdata:User_id	; M001
		dw	offset dosdata:CritPatch ; M001
		dw	offset dosdata:UMB_Head	; M012

;SR;
; Flag to indicate whether WIN386 is running or not
;
public	IsWin386
IsWin386		db	0

;M018
; This variable contains the path to the VxD device needed for Win386
;
public 	VxDpath					;M018
VxDpath		db	'c:\wina20.386',0		;M018

;
;End WIN386 support
;

;SR;
; These variables have been added for the special lie support for device
;drivers.
;
	public	DriverLoad
	public	BiosDataPtr
DriverLoad	db	1	;initialized to do special handling
BiosDataPtr	dd	?


;------------------------------------------------------------------------
; Patch for Sidekick
;
; A documented method for finding the offset of the Errormode flag in the 
; dos swappable data area if for the app to scan in the dos segment (data) 
; for the following sequence of instructions.
;
; Ref: Part C, Artice 11, pg 356 of MSDOS Encyclopedia
;
; The Offset of Errormode flag is 0320h
;
;------------------------------------------------------------------------


	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
	db	075h, 0ch			 ; jnz  NearLabel
	db	036h, 0ffh, 036h, 058h, 03h	 ; push ss:[NearWord]
	db	0cdh, 028h			 ; int  28h

;--------------------------------------------------------------------------
; Patch for PortOfEntry - M036
;
; PortOfEntry by Sector Technology uses an un documented way of determining
; the offset of Errormode flag. The following patch is to support them in 
; DOS 5.0. The corresponding code is actually in msdisp.asm
;
;---------------------------------------------------------------------------

	db 	080h, 03eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
	db	075h, 037h			 ; jnz	NearLabel
	db 	0bch, 0a0h, 0ah		  	 ; mov	sp, dosdata:iostack

;
;*** New FCB Implementation
; This variable is used as a cache in the new FCB implementation to remember
;the address of a local SFT that can be recycled for a regenerate operation
;

public	LocalSFT
LocalSFT		dd	0	;0 to indicate invalid pointer

DOSDATA	ENDS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\dosprint.asm ===
TITLE   DOSPRINT - PRINTF at DOS level
        NAME    DOSPRINT

;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1991
;       All Rights Reserved.
;

;**     DOSPRINT.ASM - Debug Print Support
;
;       Modification history:
;
;         Created: MZ 16 June 1984

        .xlist
        .xcref
        include version.inc
        include dosseg.inc
        INCLUDE DOSSYM.INC
        INCLUDE DEVSYM.INC
        .cref
        .list

DOSCODE SEGMENT
        ASSUME  SS:DOSDATA,CS:DOSCODE

        I_Need  Proc_ID,WORD
        I_Need  User_ID,WORD
        allow_getdseg

BREAK   <debugging output>

if DEBUG



;       PFMT - formatted output.  Calling sequence:
;         PUSH    BP
;         PUSH    fmtstr
;         MOV     BP,SP
;         PUSH    args
;         CALL    PFMT
;         ADD     SP,n
;         POP     BP
;
; The format string contains format directives and normal output characters
; much like the PRINTF for C.  We utilize NO format widths.  Special chars
; and strings are:
;
;       $x      output a hex number
;       $s      output an offset string
;       $c      output a character
;       $S      output a segmented string
;       $p      output userid/processid
;       \t      output a tab
;       \n      output a CRLF
;
; The format string must be addressable via CS
;

Procedure PFMT,NEAR
        ASSUME  SS:nothing
        SAVE    <AX,BX,DS,SI>
        MOV     AX,8007h
        INT     2Ah
        GETDSEG DS
        SUB     BP,2
        Call    FMTGetArg
        MOV     SI,AX
FmtLoop:
        LODSB
        OR      AL,AL
        JZ      FmtDone
        CMP     AL,'$'
        JZ      FmtOpt
        CMP     AL,'\'
        JZ      FmtChr
FmtOut:
        CALL    fOut
        JMP     FmtLoop

fOut:
        call    putch                   ; put character on serial port
        return

FmtDone:
        MOV     AX,8107h
        INT     2Ah
        RESTORE <SI,DS,BX,AX>
        RET
;
; \ leads in a special character. See what the next char is.
;
FmtChr: LODSB
        OR      AL,AL                   ; end of string
        JZ      fmtDone
        CMP     AL,'n'                  ; newline
        JZ      FmtCRLF
        CMP     AL,'t'                  ; tab
        JNZ     FmtOut
        MOV     AL,9
        JMP     FmtOut
FmtCRLF:MOV     AL,13
        CALL    fOut
        MOV     AL,10
        JMP     FmtOut
;
; $ leads in a format specifier.
;
FmtOpt: LODSB
        CMP     AL,'x'                  ; hex number
        JZ      FmtX
        CMP     AL,'c'                  ; single character
        JZ      FmtC
        CMP     AL,'s'                  ; offset string
        JZ      FmtSoff
        CMP     AL,'S'                  ; segmented string
        JZ      FmtSseg
        CMP     AL,'p'
        JZ      FmtUPID
        JMP     FmtOut
FmtX:
        Call    FMTGetArg
        MOV     BX,AX
        CALL    MNUM
        JMP     FmtLoop
FmtC:
        Call    FmtGetArg
        CALL    fOut
        JMP     FmtLoop
FmtSoff:
        SAVE    <SI>
        Call    FmtGetArg
        MOV     SI,AX
        CALL    fmtsout
        RESTORE <SI>
        JMP     FmtLoop
FmtSSeg:
        SAVE    <DS,SI>
        CALL    FMTGetArg
        MOV     DS,AX
        CALL    FMTGetArg
        MOV     SI,AX
        CALL    fmtsout
        RESTORE <SI,DS>
        JMP     FmtLoop
FmtUPID:
        INTTEST
        SAVE    <DS>
        MOV     BX,0
        MOV     DS,BX
        INTTEST                 ; what is this 82h?
        MOV     DS,DS:[82h]
    ASSUME DS:DOSDATA
        MOV     BX,User_ID
        CALL    MNUM
        MOV     AL,':'
        CALL    fOUT
        MOV     BX,Proc_ID
        CALL    MNUM
        RESTORE <DS>
    Assume DS:NOTHING
        JMP     FmtLoop
EndProc PFMT

Procedure   FMTGetArg,NEAR
        MOV     AX,[BP]
        SUB     BP,2
        return
EndProc FMTGetArg

Procedure   FmtSOut,NEAR
        LODSB
        OR      AL,AL
        retz
        CALL    fOUT
        JMP     FmtSOut
EndProc FMTSout

;**     MOut - output a message via serial port
;
;       ENTRY   (cs:bx) = message
;       USES    bx

Procedure   MOut,Near
        ASSUME  ES:NOTHING
        PUSHF
        Save    <ds, si, AX>
        PUSH    CS
        POP     DS
        MOV     SI,BX
        Call    FMTSout
        Restore <AX,SI,DS>
        POPF
        return
EndProc MOut

;   MNum - output a number in BX
;   Inputs:     BX contains a number
;   Outputs:    number in hex appears on screen
;   Registers modified: BX

Procedure   MNum,NEAR
        ASSUME  SS:NOTHING
        PUSHF
        SAVE    <ES,DI,AX,BX,CX,SI,DS>
        PUSH    SS
        POP     ES
        SUB     SP,6
        MOV     DI,SP                   ;   p = MNumBuf;
        SAVE    <DI>
        MOV     CX,4                    ;   for (i=0; i < 4; i++)
DLoop:  SAVE    <CX>
        MOV     CX,4                    ;       rotate(n, 4);
        ROL     BX,CL
        RESTORE <CX>
        MOV     AL,BL
        AND     AL,0Fh
        ADD     AL,'0'
        CMP     AL,'9'
        JBE     Nok
        ADD     AL,'A'-'0'-10
Nok:    STOSB                           ;       *p++ = "0123456789ABCDEF"[n];
        LOOP    DLoop
        XOR     AL,AL
        STOSB                           ;   *p++ = 0;
        RESTORE <SI>
        PUSH    ES
        POP     DS
        CALL    FMTSOUT                 ;   mout (mNumBuf);
        ADD     SP,6
        RESTORE <DS,SI,CX,BX,AX,DI,ES>
        POPF
        return
EndProc MNum


comport EQU     03f8h   ; default to COM1

;**     putch - put character
;
;       (al) = character to output


        Public  putch
putch   PROC    near
        push    dx

        cmp     al,7
        je      putch1
        cmp     al,0ah          ; filter out some garbage characters
        je      putch1          ; that %s can produce when we don't
        cmp     al,0dh          ; have a null terminated string
        je      putch1
        cmp     al,20h
        jae     pch0
        mov     al,'.'
        jmp     putch1

pch0:   cmp     al,07fh
        jb      putch1
        mov     al,'.'

putch1:
        cmp     al,0ah
        jne     putch2
        call    putraw
        mov     al,0dh
putch2: call    putraw
        pop     dx
        ret

putch   ENDP


        DPUBLIC putraw
putraw  PROC    near

        mov     dx, comport + 03fdh-3f8h
        mov     ah,al
putr5:  in      al,dx
        and     al,020h
        jz      putr5
        mov     al,ah
        mov     dx, comport
        out     dx,al
        ret

putraw  ENDP



 DPUBLIC <FmtLoop, FmtOut, fOut, FmtDone, FmtChr, FmtCRLF, FmtOpt, FmtX>
 DPUBLIC <FmtC, FmtSoff, FmtSSeg, FmtUPID, DLoop, Nok, pch0, putch1, putch2, putr5>

endif

DOSCODE ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\emsmnt.asm ===
TITLE   EMS MAINTENANCE - Maintainance B0 bank status when EMS are in use
NAME	EMSMNT

;**
;
; Reset B0 bank status to abailable for VRAM when a process ends.
;  This function will work only if EMS are inuse.
;
;   EMSMNT
;
;   Modification history:
;
;       Created: ?
;
;			04/23/91	Ver 5.0
;
	PAGE	85,125

	.xlist
	.xcref
include dosseg.inc
	.cref
	.list

AUTO_FLAG	equ	30h
KBKNJ_FLG	equ	0b6h


DOSCODE SEGMENT
	ASSUME  CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

	public	EMS_MNT
EMS_MNT:
	PUSHF
	PUSH	DS
	PUSH	ES
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	SI
	PUSH	DI
	MOV	AX,60H
	MOV	DS,AX			; DS <- 60H
	CMP	BYTE PTR DS:[AUTO_FLAG],00H	; AUTO FLAG (IO.SYS) ON ?
	JE	EMS_MNT_10		; YES
	JMP	SHORT EMS_MNT_EXIT
EMS_MNT_10:
	XOR	AX,AX
	MOV	DS,AX			; DS <- 00H
	MOV	DS,DS:[67H*4+2]		; DS <- EMM driver segment
	MOV	SI,0AH
	MOV	AX,CS
	MOV	ES,AX			; ES <- CS
	MOV	DI,OFFSET EMS_NAME
	MOV	CX,8
	CLD
	REPE	CMPSB			; EMS EXIST ?

	JE	EMS_MNT_20		; YES
	JMP	SHORT EMS_MNT_EXIT
EMS_MNT_20:
	MOV	SI,3BH			;
	MOV	DI,OFFSET EMS_ID
	MOV	CX,3
	REPE	CMPSB			; NEC EMS ?
	JE	EMS_MNT_30		; YES
	JMP	SHORT EMS_MNT_EXIT
EMS_MNT_30:
	MOV	AX,7000H
	INT	67H			; GET EMS PAGEFRAME STATUS
	CMP	AH,00H			; OK ?
	JE	EMS_MNT_40		; YES
	JMP	SHORT EMS_MNT_EXIT	; NG
EMS_MNT_40:
	CMP	AL,01H			; GVRAM ?
	JE	EMS_MNT_EXIT		; YES
	XOR	AX,AX
	MOV	DS,AX			; DS <- 00H
	MOV	DS,DS:[0DCH*4+2]	; DS <- INT 220 segment
	MOV	SI,0AH
	MOV	DI,OFFSET NECAI
	MOV	CX,8
	REPE	CMPSB			; NECAI ?
	JNE	EMS_MNT_50		; NO
	MOV	AX,60H
	MOV	DS,AX			; DS <- 60H
	TEST	BYTE PTR DS:[KBKNJ_FLG],10000000B	; JAPANESE INPUT ?
	JNZ	EMS_MNT_EXIT		; YES
EMS_MNT_50:
	MOV	AX,7001H
	MOV	BL,01H
	INT	67H			; CHANGE GVRAM
EMS_MNT_EXIT:
	POP	DI
	POP	SI
	POP	CX
	POP	BX
	POP	AX
	POP	ES
	POP	DS
	POPF
	RET

	public	EMS_NAME
EMS_NAME	DB	'EMMXXXX0'
EMS_ID		DB	'NEC'
NECAI		DB	'$AIC#NEC'

	public	PATCH_CODE
PATCH_CODE:
	; patch will be here

;------------------------------------------------- NEC 93/01/07 ---------------
;<patch>

	public	patch_fastcon
	extrn	RAWRET:near,RAWNORM:near

patch_fastcon:
	jnz	@f
	jmp	RAWNORM 			; if not, do normally
@@:
	push	ds
	push	ax
db	31h,0c0h				;xor	ax,ax
	mov	ds,ax
	pop	ax
	pushf
	cli
db	3eh,0ffh,1eh,0a4h,00h			;call	dword ptr ds:[29h*4]
	pop	ds
	jmp	RAWRET

;------------------------------------------------------------------------------

RES_CODE:
	DB	200 - (RES_CODE - PATCH_CODE) DUP(0cch)


DOSCODE    ENDS



DOSDATA    SEGMENT WORD PUBLIC 'DATA'
	ASSUME  CS:DOSDATA,DS:NOTHING,ES:NOTHING,SS:NOTHING
;**
;
;   XMMerr
;
;       This routine is called by XMMerror in LMSTUB.ASM  when a20 error occur.
;
;	ENTRY	DS:SI points message data
;		DI=0
;
;
	public	XMMerr

XMMerr:
	mov	ax,0a00h		;
	int	18H			; CRT Mode set

	mov	ah,16h
	mov	dx,0e120h
	int	18H			; init VRAM

	mov	ah,0ch
	int	18H			; Display Start

	push	cs
	pop	ds			; DS <-  DOSDATA segment
	mov	si, offset XMMERRMSG
	xor	di,di			; VRAM offset
	call	display

	mov	al,06H
	out	37H,al
	xor	cx,cx
	mov	bx,5
INT_BUZZ:
	loop	INT_BUZZ
	dec	bx
	jnz	INT_BUZZ
	mov	al,07H
	out	37H,al
	hlt
INT_HLT:
	jmp	SHORT	INT_HLT


display:
	xor	ax,ax			;
	mov	es,ax			; ax = BIOS Area Segment
	mov	bx,0a000h		; bx = VRAM Segment (N mode)
	test	byte ptr es:[0501h],08h ; If N mode
	jz	display_010		;	then jump
	mov	bx,0e000h		; bx = VRAM Segment (H mode)
display_010:
	mov	es,bx			; es = VRAM Segment

	cld
display_020:
	lods	word ptr ds:[si]	; ax = Message Data (shift JIS)
	cmp	al,"$"
	je	display_ret

	sub	al,71h			; convert JIS to shift JIS
	cmp	al,9fh-71h
	jae	display_030
	sub	al,0b1h-71h
display_030:
	shl	al,1
	inc	al
	cmp	ah,7fh
	jbe	display_040
	dec	ah
display_040:
	cmp	ah,9eh
	jb	display_050
	sub	ah,7dh
	inc	al
	jmp	short display_060
display_050:
	sub	ah,1fh
display_060:
	sub	al,20h			; ax = message data (H/W code)

	stos	word ptr es:[di]
	or	al,80h
	stos	word ptr es:[di]
	loop	display_020

display_ret:
	ret

;---------------------------------------------------------- DOS50A 92/04/28 ---
	public	JMP_Oem_Handler
	extrn	Oem_Handler:dword
JMP_Oem_Handler:
	pop	ax
	pop	es
	jmp	dword ptr cs:[Oem_Handler]


XMMERRMSG DB    "n[hEFAG[","$"
;---------------
;XMMERRMSG DB    "`QOnhG[","$"
;------------------------------------------------------------------------------

	public	PATCH_DATA
PATCH_DATA:
	; patch will be here
RES_DATA:
	DB	100 - (RES_DATA - PATCH_DATA) DUP(0cch)

DOSDATA    ENDS

    END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\fcb.asm ===
TITLE	FCB - FCB parse calls for MSDOS
	NAME	FCB


;**	FCB.ASM -  Low level routines for parsing names into FCBs and analyzing
;		   filename characters
;
;	MakeFcb
;	NameTrans
;	PATHCHRCMP
;	GetLet
;	UCase
;	GetLet3
;	GetCharType
;	TESTKANJ
;	NORMSCAN
;	DELIM
;
;	Revision history:
;
;	Sudeep Bharati 19-Nov-1991 Ported for NT
.xlist
.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include doscntry.inc			;AN000; 	2/12/KK
.cref
.list

	i_need	Name1,BYTE
	i_need	Attrib,BYTE
	i_need	SpaceFlag,BYTE
	i_need	FILE_UCASE_TAB,byte	   ;DOS 3.3
	i_need	COUNTRY_CDPG,byte	;AN000; 	2/12/KK
	i_need	DrvErr,BYTE		;AN000; 	2/12/KK
	i_need	DOS34_FLAG,WORD 	;AN000; 	2/12/KK

TableLook	equ -1

SCANSEPARATOR	EQU	1
DRVBIT		EQU	2
NAMBIT		EQU	4
EXTBIT		EQU	8


DOSCODE	SEGMENT

	allow_getdseg

;
;----------------------------------------------------------------------------
;
; Procedure : MakeFcb
;
;----------------------------------------------------------------------------
;

	ASSUME	SS:DOSDATA,CS:DOSCODE


procedure   MakeFcb,NEAR

;hkn; SS override
	MOV	BYTE PTR [SpaceFlag],0
	XOR	DL,DL		; Flag--not ambiguous file name
	test	AL,DRVBIT	; Use current drive field if default?
	JNZ	DEFDRV
	MOV	BYTE PTR ES:[DI],0	; No - use default drive
DEFDRV:
	INC	DI
	MOV	CX,8
	test	AL,NAMBIT	; Use current name fields as defualt?
	XCHG	AX,BX		; Save bits in BX
	MOV	AL," "
	JZ	FILLB		; If not, go fill with blanks
	ADD	DI,CX
	XOR	CX,CX		; Don't fill any
FILLB:
	REP	STOSB
	MOV	CL,3
	test	BL,EXTBIT	; Use current extension as default
	JZ	FILLB2
	ADD	DI,CX
	XOR	CX,CX
FILLB2:
	REP	STOSB
	XCHG	AX,CX		; Put zero in AX
	STOSW
	STOSW			; Initialize two words after to zero
	SUB	DI,16		; Point back at start
	test	BL,SCANSEPARATOR; Scan off separators if not zero
	JZ	SKPSPC
	CALL	SCANB		; Peel off blanks and tabs
	CALL	DELIM		; Is it a one-time-only delimiter?
	JNZ	NOSCAN
	INC	SI		; Skip over the delimiter
SKPSPC:
	CALL	SCANB		; Always kill preceding blanks and tabs
NOSCAN:
	CALL	GETLET
	JBE	NODRV		; Quit if termination character
 IFDEF  DBCS			;AN000;
	CALL	TESTKANJ	;AN000;; 2/18/KK
	JNE	NODRV		;AN000;; 2/18/KK
 ENDIF				;AN000;
	CMP	BYTE PTR[SI],":"        ; Check for potential drive specifier
	JNZ	NODRV
	INC	SI		; Skip over colon
	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
	JBE	BADDRV		; Drive letter out of range

	PUSH	AX
	Invoke	GetVisDrv
	POP	AX
	JNC	HavDrv

;hkn; SS override
	CMP	[DrvErr],error_not_DOS_disk  ; if not FAt drive 		;AN000;
	JZ	HavDrv			     ; assume ok			;AN000;
BADDRV:
	MOV	DL,-1
HAVDRV:
	STOSB			; Put drive specifier in first byte
	INC	SI
	DEC	DI		; Counteract next two instructions
NODRV:
	DEC	SI		; Back up
	INC	DI		; Skip drive byte

	entry	NORMSCAN

	MOV	CX,8
	CALL	GETWORD 	; Get 8-letter file name
	CMP	BYTE PTR [SI],"."
	JNZ	NODOT
	INC	SI		; Skip over dot if present

;hkn; SS override
	TESTB	[DOS34_FLAG],DBCS_VOLID2					;AN000;
	JZ	VOLOK								;AN000;
	MOVSB			; 2nd byte of DBCS				;AN000;
	MOV	CX,2								;AN000;
	JMP	SHORT contvol							;AN000;
VOLOK:
	MOV	CX,3		; Get 3-letter extension
contvol:
	CALL	MUSTGETWORD
NODOT:
	MOV	AL,DL

	and	[DOS34_FLAG],not DBCS_VOLID2	; ### BUG FIX ###

	return

NONAM:
	ADD	DI,CX
	DEC	SI
	return

GETWORD:
	CALL	GETLET
	JBE	NONAM		; Exit if invalid character
	DEC	SI

;	UGH!!! Horrible bug here that should be fixed at some point:
;	If the name we are scanning is longer than CX, we keep on reading!

MUSTGETWORD:
	CALL	GETLET

;	If spaceFlag is set then we allow spaces in a pathname

IF NOT TABLELOOK
	JB	FILLNAM
ENDIF
	JNZ	MustCheckCX

;hkn; SS override
	test	BYTE PTR [SpaceFlag],0FFh
	JZ	FILLNAM
	CMP	AL," "
	JNZ	FILLNAM

MustCheckCX:
	JCXZ	MUSTGETWORD
	DEC	CX
	CMP	AL,"*"          ; Check for ambiguous file specifier
	JNZ	NOSTAR
	MOV	AL,"?"
	REP	STOSB
NOSTAR:
	STOSB

 IFDEF   DBCS							  ;AN000;
	CALL	TESTKANJ					  ;AN000;
	JZ	NOTDUAL3					  ;AN000;
	JCXZ	BNDERR		; Attempt to straddle boundry	  ;AN000;
	MOVSB			; Transfer second byte		  ;AN000;
	DEC	CX						  ;AN000;
	JMP	MUSTGETWORD					  ;AN000;
BNDERR: 							  ;AN000;

;hkn; SS override for DOS34_FLAG
	TESTB	[DOS34_FLAG],DBCS_VOLID 			  ;AN000;
	JZ	notvolumeid					  ;AN000;
	TESTB	[DOS34_FLAG],DBCS_VOLID2			  ;AN000;
	JNZ	notvolumeid					  ;AN000;
	OR	[DOS34_FLAG],DBCS_VOLID2			  ;AN000;
	JMP	MUSTGETWORD					  ;AN000;

notvolumeid:
;;	INC	CX		; Undo the store of the first byte
	DEC	DI
	MOV	AL," "          ;PTM.                              ;AN000;
	STOSB			;PTM.				   ;AN000;
	INC	SI		;PTM.				   ;AN000;
	JMP	MUSTGETWORD	;PTM.				   ;AN000;

NOTDUAL3:							   ;AN000;
  ENDIF 							   ;AN000;

	CMP	AL,"?"
	JNZ	MUSTGETWORD
	OR	DL,1		; Flag ambiguous file name
	JMP	MUSTGETWORD
FILLNAM:
	MOV	AL," "
	REP	STOSB
	DEC	SI
	return

SCANB:
	LODSB
	CALL	SPCHK
	JZ	SCANB
 IFDEF  DBCS			;AN000; 						;AN000;
	CMP	AL,DB_SP_HI	;AN000;; 1ST BYTE OF DBCS BLANK 2/18/KK 		;AN000;
	JNE	SCANB_EXIT	;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
	CALL	TESTKANJ	;AN000;; 2/23/KK  3/31/KK revoved			;AN000;
	JE	SCANB_EXIT	;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
	CMP	BYTE PTR [SI],DB_SP_LO;AN000;H ; 2ND BYTE OF DBCS BLANK 2/18/KK 3/31/KK revove;AN000;
	JNE	SCANB_EXIT	;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
	INC	SI		;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
	JMP	SCANB		;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
    SCANB_EXIT: 		;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
 ENDIF				;AN000;
	DEC	SI
	return
EndProc MakeFCB

;----------------------------------------------------------------------------
;
; Procedure Name : NameTrans
;
; NameTrans is used by FindPath to scan off an element of a path.  We must
; allow spaces in pathnames
;
;   Inputs:	DS:SI points to start of path element
;   Outputs:	Name1 has unpacked name, uppercased
;		ES = DOSGroup
;		DS:SI advanced after name
;   Registers modified: DI,AX,DX,CX
;
;----------------------------------------------------------------------------

procedure   NameTrans,near
	ASSUME	SS:DOSDATA

;hkn; SS override
	MOV	BYTE PTR [SpaceFlag],1
	context ES

;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1
	PUSH	DI
	MOV	AX,'  '
	MOV	CX,5
	STOSB
	REP	STOSW		; Fill "FCB" at NAME1 with spaces
	XOR	AL,AL		; Set stuff for NORMSCAN
	MOV	DL,AL
	STOSB
	POP	DI

	CALL	NORMSCAN

;hkn; SS override for NAME1
IFDEF DBCS 			;AN000;;KK.
	MOV	AL,[NAME1]	;AN000;;KK. check 1st char
	call	testkanj	;AN000;;KK. dbcs ?
	JZ	notdbcs 	;AN000;;KK. no
	return			;AN000;;KK. yes
notdbcs:			;AN000;
ENDIF				;AN000;
	CMP	[NAME1],0E5H
	retnz
	MOV	[NAME1],5	; Magic name translation
	return

EndProc nametrans

Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>

If TableLook

;hkn; Table	SEGMENT
	PUBLIC	CharType

; Character type table for file name scanning
; Table provides a mapping of characters to validity bits.
; Four bits are provided for each character.  Values 7Dh and above
; have all bits set, so that part of the table is chopped off, and
; the translation routine is responsible for screening these values.
; The bit values are defined in DOSSYM.INC

	      ; ^A and NUL
CharType db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^C and ^B
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^E and ^D
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^G and ^F
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; TAB and BS
	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^K and ^J
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^M and ^L
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^O and ^N
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^Q and ^P
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^S and ^R
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^U and ^T
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^W and ^V
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^Y and ^X
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ESC and ^Z
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^] and ^\
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^_ and ^^
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ! and SPACE
	 db   LOW (NOT FCHK+FDELIM+FSPCHK)

	      ; # and "
	 db   LOW (NOT FFCB+FCHK)

	      ; $ - )
	 db   3 dup (0FFh)

	      ; + and *
	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh

	      ; - and '
	 db   NOT (FFCB+FCHK+FDELIM)

	      ; / and .
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh

	      ; 0 - 9
	 db   5 dup (0FFh)

	      ; ; and :
	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh

	      ; = and <
	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh

	      ; ? and >
	 db   NOT FFCB+FCHK+FDELIM

	      ; A - Z
	 db   13 dup (0FFh)

	      ; \ and [
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh

	      ; ^ and ]
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; _ - {
	 db   15 dup (0FFh)

	      ; } and |
	 db   NOT FFCB+FCHK+FDELIM

CharType_last equ ($ - CharType) * 2	; This is the value of the last
					; character in the table

;hkn; Table	ENDS

ENDIF

;----------------------------------------------------------------------------
;
; Procedure Names : GetLet, UCase, GetLet3
;
; These routines take a character, convert it to upper case, and check
; for delimiters.  Three different entry points:
;	GetLet -  DS:[SI] = character to convert
;	UCase  -  AL = character to convert
;	GetLet3 - AL = character
;		  [BX] = translation table to use
;
;	Exit (in all cases) : AL = upper case character
;			      CY set if char is control char other than TAB
;			      ZF set if char is a delimiter
;	Uses : AX, flags
;
; NOTE: This routine exists in a fast table lookup version, and a slow
; inline version.  Return with carry set is only possible in the inline
; version.  The table lookup version is the one in use.
;
;----------------------------------------------------------------------------


; This entry point has character at [SI]

procedure   GetLet,NEAR
	assume	CS:DOSCODE,SS:DOSDATA
	LODSB

; This entry point has character in AL

entry UCase
	PUSH	BX
	MOV	BX,OFFSET DOSDATA:FILE_UCASE_TAB+2

; Convert the character in AL to upper case

gl_0:
	CMP	AL,"a"
	JB	gl_2		; Already upper case, go check type
	CMP	AL,"z"
	JA	gl_1
	SUB	AL,20H		; Convert to upper case

; Map European character to upper case

gl_1:
	CMP	AL,80H
	JB	gl_2		; Not EuroChar, go check type
	SUB	AL,80H		; translate to upper case with this index

	; M048 - Start 
	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
	; preserve it.
	;

	push	ds
	getdseg	<ds>

	XLAT	BYTE PTR [BX]	; ds as file_ucase_tab is in DOSDATA

	pop	ds
	assume	ds:nothing

	; M048 - End

; Now check the type

If TableLook

gl_2:
	PUSH	AX
	CALL	GetCharType	; returns type flags in AL
	TEST	AL,FCHK 	; test for normal character
	POP	AX
	POP	BX
	RET

; This entry has character in AL and lookup table in BX

entry GetLet3
	PUSH	BX
	JMP	short gl_0

ELSE

gl_2:
	POP	BX
	CMP	AL,"."
	retz
	CMP	AL,'"'
	retz
	CALL	PATHCHRCMP
	retz
	CMP	AL,"["
	retz
	CMP	AL,"]"
	retz
ENDIF

;---------------------------------------------------------------------
;
; DELIM - check if character is a delimiter
;	Entry : AX = character to check
;	Exit  : ZF set if character is not a delimiter
;	Uses  : Flags
;
;--------------------------------------------------------------------

entry	DELIM

IF TableLook
	PUSH	AX

	CALL	GetCharType
	TEST	AL,FDELIM
	POP	AX
	RET
ELSE
	CMP	AL,":"
	retz

	CMP	AL,"<"
	retz
	CMP	AL,"|"
	retz
	CMP	AL,">"
	retz

	CMP	AL,"+"
	retz
	CMP	AL,"="
	retz
	CMP	AL,";"
	retz
	CMP	AL,","
	retz
ENDIF

;-------------------------------------------------------------------------
;
;  SPCHK - checks to see if a character is a space or equivalent
;	Entry : AL = character to check
;	Exit  : ZF set if character is a space
;	Uses  : flags
;
;-------------------------------------------------------------------------

entry SPCHK

IF  TableLook
	PUSH	AX
	CALL	GetCharType
	TEST	AL,FSPCHK
	POP	AX
	RET
ELSE
	CMP	AL,9		; Filter out tabs too
	retz
; WARNING! " " MUST be the last compare
	CMP	AL," "
	return
ENDIF
EndProc GetLet


;-------------------------------------------------------------------------
;
;  GetCharType - return flag bits indicating character type
;	Bits are defined in DOSSYM.INC.  Uses lookup table
;	defined above at label CharType.
;
;	Entry : AL = character to return type flags for
;	Exit  : AL = type flags
;	Uses  : AL, flags
;
;-------------------------------------------------------------------------

Procedure	GetCharType, Near

	cmp	al,CharType_last	; beyond end of table?
	jae	gct_90			; return standard value

	push	bx
	mov	bx, offset DOSCODE:CharType ; load lookup table
	shr	al,1			; adjust for half-byte table entry size
	xlat	cs:[bx] 		; get flags
	pop	bx

; carry clear from previous shift means we want the low nibble.  Otherwise
; we have to shift the flags down to the low nibble

	jnc	gct_80			; carry clear, no shift needed

	shr	al,1			; we want high nibble, shift it down
	shr	al,1
	shr	al,1
	shr	al,1

gct_80:
	and	al,0Fh			; clear the unused nibble
	ret

gct_90:
	mov	al,0Fh			; set all flags
	ret

EndProc GetCharType


;----------------------------------------------------------------------------
;
; Procedure : PATHCHRCMP
;
;----------------------------------------------------------------------------
;

Procedure   PATHCHRCMP,NEAR
	CMP	AL,'/'
	JBE	PathRet
	CMP	AL,'\'
	return
GotFor:
	MOV	AL,'\'
	return
PathRet:
	JZ	GotFor
	return
EndProc PathChrCMP


 IFDEF  DBCS
;---------------------	2/12/KK	 ------------------------------------------
;
; Procedure Name : TESTKANJ
;
; Function: Check if an input byte is in the ranges of DBCS vectors.
;
;   Input:   AL ; Code to be examined
;
;  Output:   ZF = 1 :  AL is SBCS      ZF = 0 : AL is a DBCS leading byte
;
;  Register:  All registers are unchanged except FL
;
;--------------------------------------------------------------------------

procedure   TESTKANJ,NEAR							;AN000;
	call	Chk_DBCS							;AN000;
	jc	TK_DBCS 							;AN000;
	cmp	AL,AL		; set ZF					;AN000;
	return									;AN000;
TK_DBCS:
	PUSH	AX								;AN000;
	XOR	AX,AX		;Set ZF 					;AN000;
	INC	AX		;Reset ZF					;AN000;
	POP	AX								;AN000;
	return									;AN000;
EndProc TESTKANJ								;AN000;
;
Chk_DBCS	PROC								;AN000;
	PUSH	DS								;AN000;
	PUSH	SI								;AN000;
	PUSH	BX								;AN000;

;hkn; SS is DOSDATA
IFDEF	JAPAN
	getdseg <ds>
ELSE
	Context DS  
ENDIF
     
;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	BX,offset DOSDATA:COUNTRY_CDPG.ccSetDBCS			;AN000;
	LDS	SI,[BX+1]		; set EV address to DS:SI		;AN000;
	ADD	SI,2			; Skip length				;AN000;
DBCS_LOOP:
	CMP	WORD PTR [SI],0 	; terminator ?				;AN000;
	JE	NON_DBCS		; if yes, no DBCS			;AN000;
	CMP	AL,[SI] 		; else					;AN000;
	JB	DBCS01			; check if AL is			;AN000;
	CMP	AL,[SI+1]		; in a range of Ev			;AN000;
	JA	DBCS01			; if yes, DBCS				;AN000;
	STC				; else					;AN000;
	JMP	DBCS_EXIT		; try next DBCS Ev			;AN000;
DBCS01:
	ADD	SI,2								;AN000;
	JMP	DBCS_LOOP							;AN000;
NON_DBCS:
	CLC									;AN000;
DBCS_EXIT:
	POP	BX								;AN000;
	POP	SI								;AN000;
	POP	DS								;AN000;
	RET									;AN000;
Chk_DBCS	ENDP								;AN000;
 ENDIF										;AN000;
DOSCODE	ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\fcbio.asm ===
TITLE	FCBIO - FCB system calls
	NAME	FCBIO

;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
;
;	$GET_FCB_POSITION
;	$FCB_DELETE
;	$GET_FCB_FILE_LENGTH
;	$FCB_CLOSE
;	$FCB_RENAME
;	SaveFCBInfo
;	ResetLRU
;	SetOpenAge
;	LRUFCB
;	FCBRegen
;	BlastSFT
;	CheckFCB
;	SFTFromFCB
;	FCBHardErr
;
;	Revision history:
;
;	Sudeep Bharati 19-Nov-1991 Ported for NT

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include cpmfcb.inc
	include syscall.inc
	include filemode.inc
	include mult.inc
	include bugtyp.inc
	include dossvc.inc
	.cref
	.list


	I_need	OpenBuf,128		; buffer for translating paths
	I_need	RenBuf,128		; buffer for rename paths
	i_need	THISDPB,DWORD
	i_need	EXTERR,WORD
	i_need	ALLOWED,BYTE
	I_need	ThisSFT,DWORD		; SFT in use
	I_need	WFP_start,WORD		; pointer to canonical name
	I_need	Ren_WFP,WORD		; pointer to canonical name
	I_need	Attrib,BYTE		; Attribute for match attributes
	I_need	sftFCB,DWORD		; pointer to SFTs for FCB cache
	I_need	FCBLRU,WORD		; least recently used count
	I_need	Proc_ID,WORD		; current process ID
	I_Need	Name1,14		; place for device names
	I_need	DEVPT,DWORD		; device pointer
	I_need	OpenLRU,WORD		; open age
	I_need	KeepCount,WORD		; number of fcbs to keep
	I_need	User_In_AX,WORD 	; user input system call.
	I_need	JShare,DWORD		; share jump table
	I_need	FastOpenTable,BYTE	; DOS 3.3 fastopen
	I_need	ExtFCB,BYTE		; flag for extended FCBs
	I_need	Sattrib,BYTE		; attribute of search

        I_need  LocalSFT,DWORD          ;added for new FCB implementation
        i_need  EXTERR_LOCUS,BYTE


DOSCODE	SEGMENT
	ASSUME	CS:DOSCODE

;	extrn	CheckShare:near
;	extrn	GetExtended:near
ifdef DBCS
	extrn	TestKanj:near
endif
	extrn	TransFCB:near
	extrn	GetExtended:near
	extrn	UCase:near

	allow_getdseg


Break <$Get_FCB_Position - set random record fields to current pos>
;
;----------------------------------------------------------------------------
;
;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
;	extent and next record field and set the random record field to point
;	to that record
;
;   Inputs:	DS:DX point to a possible extended FCB
;   Outputs:	The random record field of the FCB is set to the current record
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure $Get_FCB_Position,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	call	GetExtended		; point to FCB
	invoke	GetExtent		; DX:AX is current record
	MOV	WORD PTR [SI.fcb_RR],AX ; drop in low order piece
	MOV	[SI+fcb_RR+2],DL	; drop in high order piece
	CMP	[SI.fcb_RECSIZ],64
	JAE	GetFCBBye
	MOV	[SI+fcb_RR+2+1],DH	; Set 4th byte only if record size < 64
GetFCBBye:
	transfer    FCB_Ret_OK
EndProc $GET_FCB_POSITION


	Break <$FCB_Delete - remove several files that match the input FCB>
;
;----------------------------------------------------------------------------
;
;**	$FCB_Delete - Delete from FCB Template
;
;	given an FCB, remove all directory entries in the current
;	directory that have names that match the FCB's ?  marks.
;
;	ENTRY	(DS:DX) = address of FCB
;	EXIT	entries matching the FCB are deleted
;		(al) = ff iff no entries were deleted
;	USES	all
;
;----------------------------------------------------------------------------
;

Procedure $FCB_Delete,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	MOV	DI,OFFSET DOSDATA:OpenBuf  

	call	TransFCB		; convert FCB to path
	JC	BadPath 		; signal no deletions

	mov	si,OFFSET DOSDATA:OpenBuf
	push	es
	push	ds
	invoke	ChkDev			; Check if its a device
	pop	ds
	pop	es
	jc	short fdsvc
	mov	ax,error_access_denied
	transfer    FCB_Ret_Err 	; let someone else signal the error

fdsvc:
	mov	al,[ExtFCB]
	mov	dl,[Sattrib]
	mov	di,OFFSET DOSDATA:OpenBuf

	HRDSVC	SVC_DEMDELETEFCB	; es:di fcb,al IsExt, dl Sattrib

	JC	BadPath
GoodPath:
	transfer    FCB_Ret_OK		; do a good return
BadPath:

	;
	; Error code is in AX
	;

	transfer    FCB_Ret_Err 	; let someone else signal the error

EndProc $FCB_DELETE

Break <$Get_FCB_File_Length - return the length of a file>
;
;----------------------------------------------------------------------------
;
;   $Get_FCB_File_Length - set the random record field to the length of the
;	file in records (rounded up if partial).
;
;   Inputs:	DS:DX - point to a possible extended FCB
;   Outputs:	Random record field updated to reflect the number of records
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure   $Get_FCB_File_Length,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	call	GetExtended		; get real FCB pointer
					; DX points to Input FCB

					; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer

	SAVE	<DS,SI> 		; save pointer to true FCB
	call	TransFCB		; Trans name DS:DX, sets SATTRIB
	RESTORE <SI,DS>
	JC	BadPath
	SAVE	<DS,SI> 		; save pointer

	Context DS			; SS is DOSDATA
	mov	si,WFP_START

	HRDSVC	SVC_DEMGETFILEINFO	; invoke get_file_info
	RESTORE <SI,DS>			; get pointer back
	JC	BadPath 		; invalid something
	MOV	DX,BX			; get high order size
	MOV	AX,DI			; get low order size
	MOV	BX,[SI.fcb_RECSIZ]	; get his record size
	OR	BX,BX			; empty record => 0 size for file
	JNZ	GetSize 		; not empty
	MOV	BX,128
GetSize:
	MOV	DI,AX			; save low order word
	MOV	AX,DX			; move high order for divide
	XOR	DX,DX			; clear out high
	DIV	BX			; wham
	PUSH	AX			; save dividend
	MOV	AX,DI			; get low order piece
	DIV	BX			; wham
	MOV	CX,DX			; save remainder
	POP	DX			; get high order dividend
	JCXZ	LengthStore		; no roundup
	ADD	AX,1
	ADC	DX,0			; 32-bit increment
LengthStore:
	MOV	WORD PTR [SI.FCB_RR],AX ; store low order
	MOV	[SI.FCB_RR+2],DL	; store high order
	OR	DH,DH
	JZ	GoodPath		; not storing insignificant zero
	MOV	[SI.FCB_RR+3],DH	; save that high piece
GoodRet:
	transfer    FCB_Ret_OK
EndProc $GET_FCB_FILE_LENGTH

Break <$FCB_Close - close a file>

;
;----------------------------------------------------------------------------
;
;   $FCB_Close - given an FCB, look up the SFN and close it.  Do not free it
;	as the FCB may be used for further I/O
;
;   Inputs:	DS:DX point to FCB
;   Outputs:	AL = FF if file was not found on disk
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure $FCB_Close,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	XOR	AL,AL			; default search attributes
	call	GetExtended		; DS:SI point to real FCB
	JZ	NoAttr			; not extended
	MOV	AL,[SI-1]		; get attributes

	cmp	al, 08H 		; Set Label?
	jz	GoodRet

NoAttr:
					; SS override
	MOV	[Attrib],AL		; stash away found attributes

	invoke	SFTFromFCB
	JC	GoodRet 		; MZ 16 Jan Assume death

	;
	; If the sharer is present, then the SFT is not regenable.  Thus, 
	; there is no need to set the SFT's attribute.
	;

	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
	;;; done

	MOV	AL,ES:[DI].sf_attr
	XOR	AH,AH
	PUSH	AX

	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
	;;; done

;	call	CheckShare
;	JNZ	NoStash
	MOV	AL,Attrib
	MOV	ES:[DI].sf_attr,AL	; attempted attribute for close
NoStash:
	MOV	AX,[SI].FCB_FDATE	; move in the time and date
	MOV	ES:[DI].sf_date,AX
	MOV	AX,[SI].FCB_FTIME
	MOV	ES:[DI].sf_time,AX
	MOV	AX,[SI].FCB_FilSiz
	MOV	WORD PTR ES:[DI].sf_size,AX
	MOV	AX,[SI].FCB_FilSiz+2
	MOV	WORD PTR ES:[DI].sf_size+2,AX
	OR	ES:[DI].sf_Flags,sf_close_nodate
	push	si
	mov	si,word ptr es:[di].sf_NTHandle
	mov	ax,word ptr es:[di].sf_NTHandle+2
	mov	word ptr es:[di].sf_NTHandle,0
	mov	word ptr es:[di].sf_NTHandle+2,0

					; SS is DOSDATA
	Context DS			; let Close see variables

	HRDSVC	SVC_DEMCLOSEFCB		; ax:si is NT handle
	pop	si
;	LES	DI,ThisSFT

	;;; 9/8/86 F.C. restore SFT attribute

	POP	CX
	MOV	ES:[DI].sf_attr,CL

	DEC	ES:[DI].sf_ref_count

	;;; 9/8/86 F.C. restore SFT attribute

	PUSH	AX
        lahf
        push    ax
	cmp	ES:[DI.sf_ref_count],0	; zero ref count gets blasted
	JNZ	CloseOK
	MOV	AL,'M'
	call	BlastSFT
CloseOK:
	POP	AX
        sahf
        pop     ax
	JC	fc_10a
	jmp	GoodRet
fc_10a:
	CMP	AL,error_invalid_handle
	JNZ	fc_10
	JMP	GoodRet
fc_10:
	MOV	AL,error_file_not_found
	transfer    FCB_Ret_Err
EndProc $FCB_CLOSE

;
;----------------------------------------------------------------------------
;
;**	$FCB_Rename - Rename a File
;
;	$FCB_Rename - rename a file in place within a directory.  Renames
;	multiple files copying from the meta characters.
;
;	ENTRY	DS:DX point to an FCB.	The normal name field is the source
;		    name of the files to be renamed.  Starting at offset 11h
;		    in the FCB is the destination name.
;	EXIT	AL = 0 -> no error occurred and all files were renamed
;		AL = FF -> some files may have been renamed but:
;			rename to existing file or source file not found
;	USES	ALL
;
;----------------------------------------------------------------------------
;

Procedure $FCB_Rename,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	call	GetExtended		; get pointer to real FCB
	SAVE	<DX>
	MOV	AL,[SI] 		; get drive byte
	ADD	SI,10h			; point to destination

					; RenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:RenBuf   ; point to destination buffer

	SAVE	<<WORD PTR DS:[SI]>,DS,SI>  ; save source pointer for TransFCB
	MOV	DS:[SI],AL		; drop in real drive
	MOV	DX,SI			; let TransFCB know where the FCB is
	call	TransFCB		; munch this pathname
	RESTORE <SI,DS,<WORD PTR DS:[SI]>>	; get path back
	RESTORE <DX>			; Original FCB pointer
	JC	fren90			; bad path -> error

	or	ax, ax
	jnz	cont1
	mov	al, error_access_denied
	jmp	short fren90

cont1:
					; SS override for WFP_Start & Ren_WFP
	MOV	SI,WFP_Start		; get pointer
	MOV	Ren_WFP,SI		; stash it

					; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate spot
	call	TransFCB		; wham
					; NOTE that this call is pointing
					;  back to the ORIGINAL FCB so
					;  SATTRIB gets set correctly
	JC	fren90			; error

	or	ax, ax
	jnz	cont2
	mov	al, error_access_denied
	jmp	short fren90

cont2:
        invoke  DOS_Rename

        JC      fren90
	transfer    FCB_Ret_OK

fren90:	transfer    FCB_Ret_Err 	; al = error code

EndProc $FCB_RENAME


;----------------------------------------------------------------------------
;
; Procedure Name : DOS_RENAME
;
; Inputs:
;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
;		chars, NUL terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
;		chars, NUL terminated)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Rename the specified file(s)
;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
; Outputs:
;	CARRY CLEAR
;	    OK
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			No match for source, or dest path invalid
;		error_not_same_device
;			Source and dest are on different devices
;		error_access_denied
;			Directory specified (not simple rename),
;			Device name given, Destination exists.
;			NOTE: In third case some renames may have
;			 been done if metas.
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;			SOURCE ONLY
;		error_bad_curr_dir
;			Bad path in current directory part of path
;			SOURCE ONLY
;		error_sharing_violation
;			Deny both access required, generates an INT 24.
; DS preserved, others destroyed
;
;----------------------------------------------------------------------------

	procedure   DOS_RENAME,NEAR

;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
;hkn; at this point to DOSDATA.

	DOSAssume   <DS>,"DOS_Rename"
	ASSUME	ES:NOTHING

LOCAL_RENAME:
	MOV	[EXTERR_LOCUS],errLOC_Disk
	MOV	SI,[WFP_START]
	MOV	DI,[REN_WFP]
	MOV	AL,BYTE PTR [SI]
	MOV	AH,BYTE PTR [DI]
	OR	AX,2020H		; Lower case
	CMP	AL,AH
	JZ	SAMEDRV
	MOV	AX,error_not_same_device
	STC
	return

SAMEDRV:
        Context ES
        HRDSVC  SVC_DEMRENAMEFCB
        return

EndProc DOS_RENAME




Break <Misbehavior fixers>

;
;   FCBs suffer from several problems.	First, they are maintained in the
;   user's space so he may move them at will.  Second, they have a small
;   reserved area that may be used for system information.  Third, there was
;   never any "rules for behavior" for FCBs; there was no protocol for their
;   usage.
;
;   This results in the following misbehavior:
;
;	infinite opens of the same file:
;
;	While (TRUE) {			While (TRUE) {
;	    FCBOpen (FCB);		    FCBOpen (FCB);
;	    Read (FCB); 		    Write (FCB);
;	    }				    }
;
;	infinite opens of different files:
;
;	While (TRUE) {			While (TRUE) {
;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
;	    Read (FCB); 		    Write (FCB);
;	    }				    }
;
;	multiple closes of the same file:
;
;	FCBOpen (FCB);
;	while (TRUE)
;	    FCBClose (FCB);
;
;	I/O after closing file:
;
;	FCBOpen (FCB);
;	while (TRUE) {
;	    FCBWrite (FCB);
;	    FCBClose (FCB);
;	    }
;
;   The following is am implementation of a methodology for emulating the
;   above with the exception of I/O after close.  We are NOT attemptin