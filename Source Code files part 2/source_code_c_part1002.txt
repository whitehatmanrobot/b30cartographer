ror = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, lArraylength*1, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = E_FAIL;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
		break;
		case CIM_UINT16:
		case CIM_SINT16:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// Get the number of child elements - this should be the lenght of the array required
				LONG lArraylength = 0;
				pValueList->get_length (&lArraylength);

				// Allocate the array
				SHORT *pszValue = NULL;
				if(pszValue = new SHORT[lArraylength])
				{
					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;

					LONG lIndex = 0;
					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									pszValue[lIndex] = 0;
									pszValue[lIndex++] = (SHORT) wcstol (bsValue, NULL, 0);
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								error = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, lArraylength*2, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = E_FAIL;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
		break;
		case CIM_UINT32:
		case CIM_SINT32:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// Get the number of child elements - this should be the lenght of the array required
				LONG lArraylength = 0;
				pValueList->get_length (&lArraylength);

				// Allocate the array
				LONG *pszValue = NULL;
				if(pszValue = new LONG[lArraylength])
				{
					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;

					LONG lIndex = 0;
					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									pszValue[lIndex] = 0;
									pszValue[lIndex++] = (LONG) wcstol (bsValue, NULL, 0);
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								error = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, lArraylength*4, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = E_FAIL;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
		break;
		case CIM_UINT64:
		case CIM_SINT64:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// Get the number of child elements - this should be the lenght of the array required
				LONG lArraylength = 0;
				pValueList->get_length (&lArraylength);

				// Allocate the array
				__int64 *pszValue = NULL;
				if(pszValue = new __int64[lArraylength])
				{
					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;

					LONG lIndex = 0;
					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									pszValue[lIndex] = 0;
									swscanf(bsValue, L"%I64d", &pszValue[lIndex]);
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								error = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, lArraylength*8, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = E_FAIL;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
		break;
		case CIM_CHAR16:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// Get the number of child elements - this should be the lenght of the array required
				LONG lArraylength = 0;
				pValueList->get_length (&lArraylength);

				// Allocate the array
				SHORT *pszValue = NULL;
				if(pszValue = new SHORT[lArraylength])
				{
					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;

					LONG lIndex = 0;
					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									pszValue[lIndex] = 0;
									if(_wcsnicmp(bsValue, L"\\x", 2) == 0)
										// It is an escaped value
										swscanf (bsValue+2, L"%x", &(pszValue[lIndex]));
									else
										// It is a normal value
										swscanf (bsValue, L"%c", &(pszValue[lIndex]));
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								error = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, lArraylength*2, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = E_FAIL;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
		break;
		case CIM_REAL32:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// Get the number of child elements - this should be the lenght of the array required
				LONG lArraylength = 0;
				pValueList->get_length (&lArraylength);

				// Allocate the array
				float *pszValue = NULL;
				if(pszValue = new float[lArraylength])
				{
					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;

					LONG lIndex = 0;
					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									pszValue[lIndex] = 0;
									pszValue[lIndex] = (float) wcstod (bsValue, NULL);
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								error = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, lArraylength*4, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = E_FAIL;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
		break;
		case CIM_REAL64:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// Get the number of child elements - this should be the lenght of the array required
				LONG lArraylength = 0;
				pValueList->get_length (&lArraylength);

				// Allocate the array
				double *pszValue = NULL;
				if(pszValue = new double[lArraylength])
				{
					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;

					LONG lIndex = 0;
					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									pszValue[lIndex] = 0;
									pszValue[lIndex] = (double) wcstod (bsValue, NULL);
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								error = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, lArraylength*8, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = WBEM_E_INVALID_SYNTAX;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
	}
	return hr;
}


HRESULT CXml2Wmi::CreateArrayProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool lFlag)
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;
	BSTR strType = NULL;
	// Get the Type of the property
	if(SUCCEEDED(hr = GetBstrAttribute(pXML, g_strType, &strType)))
	{
		// Get the Value (VALUE.ARRAY) of the Property - this value is optional
		// Hence we dont check for return values
		IXMLDOMElement *pValueArrayNode = NULL;
		GetFirstImmediateElement(pXML, &pValueArrayNode, VALUEARRAY_TAG);

		if(_wcsicmp(strType, L"boolean") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_BOOLEAN, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"string") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_STRING, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"char16") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_CHAR16, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"uint8") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_UINT8, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"sint8") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_SINT8, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"uint16") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_UINT16, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"sint16") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_SINT16, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"uint32") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_UINT32, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"sint32") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_SINT32, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"uint64") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_UINT64, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"sint64") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_SINT64, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"datetime") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_DATETIME, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"real32") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_REAL32, pszClassOrigin, lFlag);
		else if(_wcsicmp(strType, L"real64") == 0)
			hr = MapStringArrayValue(pszName, pObj, pValueArrayNode, CIM_REAL64, pszClassOrigin, lFlag);
		else
			hr = WBEM_E_INVALID_PROPERTY;

		// Release he optional VALUE.ARRAY node
		if(pValueArrayNode)
			pValueArrayNode->Release();

		SysFreeString(strType);
	}
	else
		hr = WBEM_E_INVALID_SYNTAX;
	return hr;
}

HRESULT CXml2Wmi::CreateReferenceProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance)
{
	HRESULT hr = E_FAIL;
	IXMLDOMNodeList *pNodeList = NULL;
	long lFlag = (bMakeInstance) ? WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE : 0;

	// We will be getting a PROPERTY.REFERENCE into this function
	// Besides having the optional REFERENCECLASS attribute which identifies the
	// class whose reference it is, it can also have a VALUE.REFERENCE sub element
	// As per the free form object interfaces, we can add a reference property only
	// as a weak-reference and later we have to use IWbemClassObject to get the qualifiers
	// and set the correct reference class name to make it a strog type

	// See if there is a VALUE.REFERENCE child element
	IXMLDOMElement *pValueRef = NULL;
	if(SUCCEEDED(hr = GetFirstImmediateElement(pXML, &pValueRef, L"VALUE.REFERENCE")))
	{
		BSTR strRefValue = NULL;
		BOOL bUseSysFreeString = FALSE;
		if(SUCCEEDED(GetSingleRefValue(pValueRef, &strRefValue, bUseSysFreeString)))
		{
			hr = pObj->AddProperty(pszName, lFlag, wcslen(strRefValue)*2 + 1, 1, CIM_REFERENCE, strRefValue);

			// Only in the MapClassName() case a BSTR is allocated. In the others it is an LPWSTR
			if (bUseSysFreeString)
				SysFreeString(strRefValue);
			else
				delete [] strRefValue;
		}
		pValueRef->Release();
	}
	else // Add the property without a default value
		hr = pObj->AddProperty(pszName, lFlag, 0, 0, CIM_REFERENCE, NULL);


	return hr;
}

// In this function, we expect to get a VALUE.REFERENCE element
// and will convert it to a WMI Objectpath or objectname
HRESULT CXml2Wmi::GetSingleRefValue(IXMLDOMElement *pValueRef, BSTR *pstrValue, BOOL &bUseSysFreeString)
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;
	bUseSysFreeString = FALSE;
	// Check the child nodes of this to see if it is a CLASSPATH, LOCALCLASSPATH,
	// INSTANCEPATH, LOCALINSTANCEPATH, CLASSNAME or INSTANCENAME
	// or even a VALUE (for Scoped and UMI paths)
	IXMLDOMNodeList *pNodeList = NULL;
	if (pValueRef && SUCCEEDED(pValueRef->get_childNodes (&pNodeList)) && pNodeList)
	{
		long length = 0;
		if (SUCCEEDED(pNodeList->get_length (&length)) && (1 == length))
		{
			IXMLDOMNode *pValue = NULL;
			if (SUCCEEDED(pValueRef->get_firstChild (&pValue)))
			{
				// Next node could be a CLASSPATH, LOCALCLASSPATH, INSTANCEPATH,
				// LOCALINSTANCEPATH, CLASSNAME or INSTANCENAME or even a VALUE (for Scoped and UMI paths)
				BSTR strNodeName = NULL;
				if(SUCCEEDED(pValue->get_nodeName(&strNodeName)))
				{
					*pstrValue = NULL;
					if (_wcsicmp(strNodeName, CLASSNAME_TAG) == 0)
					{
						hr = MapClassName (pValue, pstrValue);
						bUseSysFreeString = TRUE;
					}
					else if (_wcsicmp(strNodeName, LOCALCLASSPATH_TAG) == 0)
					{
						hr = MapLocalClassPath (pValue, pstrValue);
					}
					else if (_wcsicmp(strNodeName, CLASSPATH_TAG) == 0)
					{
						hr = MapClassPath (pValue, pstrValue);
					}
					else if (_wcsicmp(strNodeName, INSTANCENAME_TAG) == 0)
					{
						hr = MapInstanceName (pValue, pstrValue);
					}
					else if (_wcsicmp(strNodeName, LOCALINSTANCEPATH_TAG) == 0)
					{
						hr = MapLocalInstancePath (pValue, pstrValue);
					}
					else if (_wcsicmp(strNodeName, INSTANCEPATH_TAG) == 0)
					{
						hr = MapInstancePath (pValue, pstrValue);
					}
					else if (_wcsicmp(strNodeName, VALUE_TAG) == 0)
					{
						// Just get its contents
						// RAJESHR - what if it is escaped CDATA? We need to unescape it
						hr = pValue->get_text(pstrValue);
					}

					SysFreeString(strNodeName);
				}
				pValue->Release ();
			}
		}
		pNodeList->Release ();
	}
	return hr;
}

HRESULT CXml2Wmi::CreateRefArrayProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance)
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;
	IXMLDOMNodeList *pNodeList = NULL;
	long lFlag = (bMakeInstance) ? WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE : 0;

	// We will be getting a PROPERTY.REFARRAY into this function
	// Besides having the optional REFERENCECLASS attribute which identifies the
	// class whose reference it is, it can also have a VALUE.REFARRAY sub element
	// As per the free form object interfaces, we can add a reference property only
	// as a weak-reference and later we have to use IWbemClassObject to get the qualifiers
	// and set the correct reference class name to make it a strog type

	// See if there is a VALUE.REFARRAY child element
	IXMLDOMElement *pValueRefArray = NULL;
	if(SUCCEEDED(GetFirstImmediateElement(pXML, &pValueRefArray, L"VALUE.REFARRAY")))
	{
		// GO thru each of its children looking for a VALUE.REFERENCE element
		IXMLDOMNodeList *pNodeList = NULL;
		if (SUCCEEDED(hr = pXML->get_childNodes (&pNodeList)))
		{
			// We need to create here, a single BSTR with NULL separated values,
			// as required by the free-form object
			// Allocate the string, we assume that the maximum length required is less
			// than the length of the XML under this element
			BSTR strTotalValue = NULL;
			if(SUCCEEDED(hr = pXML->get_xml(&strTotalValue)))
			{
				UINT uLen = SysStringLen(strTotalValue);
				SysFreeString(strTotalValue); // Free it immediately - we just wanted its length
				LPWSTR pszFinalValue = NULL;
				if(pszFinalValue = new WCHAR[uLen])
				{
					UINT uNextStart = 0;
					pszFinalValue[0] = NULL;

					IXMLDOMNode *pNode = NULL;
					int i=0;
					while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) && pNode )
					{
						BSTR strNodeName = NULL;
						if (SUCCEEDED(hr = pNode->get_nodeName (&strNodeName)))
						{
							if(_wcsicmp(strNodeName, L"VALUE.REFERENCE") == 0)
							{
								IXMLDOMElement *pValueElement = NULL;
								if(SUCCEEDED(hr = pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pValueElement)))
								{
									BSTR strRefValue = NULL;
									BOOL bUseSysFreeString = FALSE;
									if(SUCCEEDED(hr = GetSingleRefValue(pValueElement, &strRefValue, bUseSysFreeString)))
									{
										// Concatenate it to the string of null-separated values we are building up
										wcscat(pszFinalValue+uNextStart, strRefValue);

										// Add a NULL separator
										uNextStart += wcslen(strRefValue);
										pszFinalValue[uNextStart++] = NULL;

										// Only in the MapClassName() case a BSTR is allocated. In the others it is an LPWSTR
										if (bUseSysFreeString)
											SysFreeString(strRefValue);
										else
											delete [] strRefValue;
									}
									pValueElement->Release();
								}
							}
							SysFreeString(strNodeName);
						}
						pNode->Release();
						pNode = NULL;
					}

					if(SUCCEEDED(hr))
						hr = pObj->AddProperty(pszName, lFlag, uNextStart, 1, CIM_REFERENCE|CIM_FLAG_ARRAY, pszFinalValue);
					else
						hr = WBEM_E_INVALID_SYNTAX;

				}
				else
					hr = E_OUTOFMEMORY;
			}
			pNodeList->Release();
		}
		pValueRefArray->Release();
	}
	else // Add the property without a default value
		hr = pObj->AddProperty(pszName, lFlag, 0, 0, CIM_REFERENCE | CIM_FLAG_ARRAY, NULL);


	return hr;
}

HRESULT CXml2Wmi::GetSingleObject(IXMLDOMElement *pValueObject, _IWmiObject **ppEmbeddedObject)
{
	HRESULT hr = E_FAIL;
	if (pValueObject)
	{
		// Check the child nodes of this to see if it is a CLASS or INSTANCE
		IXMLDOMNode *pValue = NULL;
		if (SUCCEEDED(hr = pValueObject->get_firstChild (&pValue)))
		{
			// Get the IXMLDOMElement interface
			IXMLDOMElement *pElement = NULL;
			if(SUCCEEDED(hr = pValue->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pElement)))
			{
				// Next node could be a CLASS or INSTANCE
				BSTR strNodeName = NULL;
				if(SUCCEEDED(hr = pElement->get_nodeName(&strNodeName)))
				{
					IWbemClassObject *pWmiObject = NULL;
					if (_wcsicmp(strNodeName, CLASS_TAG) == 0)
						hr = MapClass (pElement, &pWmiObject, NULL, NULL, false, true);
					else if (_wcsicmp(strNodeName, INSTANCE_TAG) == 0)
						hr = MapInstance (pElement, &pWmiObject, NULL, NULL, true);
					else
						hr = WBEM_E_INVALID_SYNTAX;
					if(SUCCEEDED(hr))
					{
						*ppEmbeddedObject = NULL;
						hr = pWmiObject->QueryInterface(IID__IWmiObject, (LPVOID *)ppEmbeddedObject);
						pWmiObject->Release();
					}
					
					SysFreeString(strNodeName);
				}
				pElement->Release();
			}
			pValue->Release ();
		}
	}
	return hr;
}

HRESULT CXml2Wmi::CreateObjectProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance)
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;
	IXMLDOMNodeList *pNodeList = NULL;
	long lFlag = (bMakeInstance) ? WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE : 0;

	// We will be getting a PROPERTY.OBJECT into this function
	// Besides having the optional REFERENCECLASS attribute which identifies the
	// class whose embedded object it is, it can also have a VALUE.OBJECT sub element
	// As per the free form object interfaces, we can add an embedded object property property only
	// as a weak-reference and later we have to use IWbemClassObject to get the qualifiers
	// and set the correct class name to make it a strong type

	// See if there is a VALUE.OBJECT child element
	IXMLDOMElement *pValueObject = NULL;
	if(SUCCEEDED(hr = GetFirstImmediateElement(pXML, &pValueObject, L"VALUE.OBJECT")))
	{
		_IWmiObject *pEmbeddedObject = NULL;
		if(SUCCEEDED(hr = GetSingleObject(pValueObject, &pEmbeddedObject)))
		{
			// Set the Property
			hr = pObj->AddProperty(pszName, lFlag, sizeof(_IWmiObject *), 1, CIM_OBJECT, &pEmbeddedObject);
			pEmbeddedObject->Release();
		}
		pValueObject->Release();
	}
	else // Add the property without a default value
		hr = pObj->AddProperty(pszName, lFlag, 0, 0, CIM_OBJECT, NULL);

	return hr;
}

HRESULT CXml2Wmi::CreateObjectArrayProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance)
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;
	IXMLDOMNodeList *pNodeList = NULL;
	long lFlag = (bMakeInstance) ? WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE : 0;

	// We will be getting a PROPERTY.OBJECTARRAY into this function
	// Besides having the optional REFERENCECLASS attribute which identifies the
	// class whose reference it is, it can also have a VALUE.OBJECTARRAY sub element
	// As per the free form object interfaces, we can add an object property only
	// as a weak-reference and later we have to use IWbemClassObject to get the qualifiers
	// and set the correct reference class name to make it a strong type

	// See if there is a VALUE.OBJECTARRAY child element
	IXMLDOMElement *pValueObjArray = NULL;
	if(SUCCEEDED(hr = GetFirstImmediateElement(pXML, &pValueObjArray, L"VALUE.OBJECTARRAY")))
	{
		// GO thru each of its children looking for a VALUE.OBJECT element
		IXMLDOMNodeList *pNodeList = NULL;
		if (SUCCEEDED(pValueObjArray->get_childNodes (&pNodeList)))
		{
			// As per the free-form interface, at this point, we need to Create an
			// array of _IWmiFreeFormObject here, so we need to know the array length
			// Get the number of child elements - this should be the lenght of the array required
			LONG lArraylength = 0;
			pNodeList->get_length (&lArraylength);

			_IWmiObject **ppObjects = NULL;
			if(ppObjects = new _IWmiObject *[lArraylength])
			{
				IXMLDOMNode *pNode = NULL;
				LONG i=0;
				while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
				{
					BSTR strNodeName = NULL;
					if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
					{
						if(_wcsicmp(strNodeName, L"VALUE.OBJECT") == 0)
						{
							IXMLDOMElement *pValueElement = NULL;
							if(SUCCEEDED(hr = pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pValueElement)))
							{
								if(SUCCEEDED(hr = GetSingleObject(pValueElement, &ppObjects[i])))
									i++;
								pValueElement->Release();
							}
						}
						SysFreeString(strNodeName);
					}
					pNode->Release();
					pNode = NULL;
				}

				// Add the property to the object
				if(SUCCEEDED(hr))
					hr = pObj->AddProperty(pszName, lFlag, sizeof(_IWmiObject *)*lArraylength, lArraylength, CIM_OBJECT|CIM_FLAG_ARRAY, *ppObjects);
				else
					hr = WBEM_E_INVALID_SYNTAX;
				
				// Release all the objects in the array
				for(LONG j=0; j<i; j++)
					ppObjects[j]->Release();
				delete [] ppObjects;

			}
			else 
				hr = E_OUTOFMEMORY;
			pNodeList->Release();
		}
		pValueObjArray->Release();
	}
	else // Add the property without a default value
		hr = pObj->AddProperty(pszName, lFlag, 0, 0, CIM_OBJECT|CIM_FLAG_ARRAY, NULL);
	return hr;

}


HRESULT CXml2Wmi::GetBstrAttribute(IXMLDOMNode *pNode, const BSTR strAttributeName, BSTR *pstrAttributeValue)
{
	HRESULT result = E_FAIL;
	*pstrAttributeValue = NULL;

	IXMLDOMElement *pElement = NULL;
	if(SUCCEEDED(result = pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pElement)))
	{
		VARIANT var;
		VariantInit(&var);
		if(SUCCEEDED(result = pElement->getAttribute(strAttributeName, &var)))
		{
			if(var.bstrVal)
			{
				*pstrAttributeValue = var.bstrVal;
				var.bstrVal = NULL;
				// No need to clear the variant since we took over its memory
			}
			else
				result = E_FAIL;
		}
		pElement->Release();
	}
	return result;
}

HRESULT CXml2Wmi::GetFirstImmediateElement(IXMLDOMNode *pParent, IXMLDOMElement **ppChildElement, LPCWSTR pszName)
{
	HRESULT hr = E_FAIL;

	// Now cycle thru the children
	IXMLDOMNodeList *pNodeList = NULL;
	BOOL bFound = FALSE;
	if (SUCCEEDED(hr = pParent->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bFound && SUCCEEDED(pNodeList->nextNode (&pNode)) && pNode)
		{
			// Get the name of the child
			BSTR strNodeName = NULL;
			if (SUCCEEDED(hr = pNode->get_nodeName (&strNodeName)))
			{
				// We're interested only in PROPERTIES at this point
				if(_wcsicmp(strNodeName, pszName) == 0)
				{
					*ppChildElement = NULL;
					hr = pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)ppChildElement);
					bFound = TRUE;
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}

	if(bFound)
		return hr;
	return E_FAIL;
}


HRESULT CXml2Wmi::MapClassName (IXMLDOMNode *pNode, BSTR *pstrXML)
{
	*pstrXML = NULL;
	return GetBstrAttribute(pNode, g_strName, pstrXML);
}


HRESULT CXml2Wmi::MapLocalClassPath (IXMLDOMNode *pNode, LPWSTR *ppszClassPath)
{
	HRESULT hr = WBEM_E_FAILED;

	// We expect a LOCALNAMESPACEPATH followed by CLASSNAME
	IXMLDOMNodeList *pNodeList = NULL;
	if (pNode && SUCCEEDED(hr = pNode->get_childNodes (&pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pLocalNSPathNode = NULL;
		// Next node should be a LOCALNAMESPACEPATH
		if (SUCCEEDED(hr = pNodeList->nextNode (&pLocalNSPathNode)) && pLocalNSPathNode)
		{
			BSTR strNSNodeName = NULL;
			if (SUCCEEDED(hr = pLocalNSPathNode->get_nodeName(&strNSNodeName)) &&
				strNSNodeName )
			{
				if(_wcsicmp(strNSNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					LPWSTR pszLocalNamespace = NULL;
					if(SUCCEEDED(hr = ParseLocalNamespacePath(pLocalNSPathNode, &pszLocalNamespace)))
					{
						// Next node should be the classname
						IXMLDOMNode *pClassNameNode = NULL;
						if (SUCCEEDED(hr = pNodeList->nextNode (&pClassNameNode)) && pClassNameNode)
						{
							BSTR strNSClassName = NULL;
							if (SUCCEEDED(hr = pClassNameNode->get_nodeName(&strNSClassName)) &&
									strNSClassName )
							{
								if (_wcsicmp(strNSClassName, CLASSNAME_TAG) == 0)
								{
									BSTR strClassName = NULL;
									if (SUCCEEDED(hr = GetBstrAttribute (pClassNameNode,
														g_strName, &strClassName)))
									{
										// Phew - finally we have all the info!

										*ppszClassPath = NULL;
										if((*ppszClassPath) = new WCHAR [wcslen(pszLocalNamespace)
												+ wcslen(strClassName) + 2])
										{
											wcscpy (*ppszClassPath, pszLocalNamespace);
											wcscat (*ppszClassPath, L":");
											wcscat (*ppszClassPath, strClassName);
											hr = S_OK;
										}
										else
											hr = E_OUTOFMEMORY;

										SysFreeString (strClassName);
									}
								}
								else
									hr = WBEM_E_INVALID_SYNTAX;

								SysFreeString (strNSClassName);
							}
							pClassNameNode->Release ();
						}
						delete [] pszLocalNamespace;
					}
				}
				else
					hr = WBEM_E_INVALID_SYNTAX;
				SysFreeString (strNSNodeName);
			}
			pLocalNSPathNode->Release ();
		}

		pNodeList->Release ();
	}
	return hr;
}

HRESULT CXml2Wmi::MapClassPath (IXMLDOMNode *pNode, LPWSTR *ppszClassPath)
{
	HRESULT hr = WBEM_E_FAILED;

	// We expect a NAMESPACEPATH followed by CLASSNAME
	IXMLDOMNodeList *pNodeList = NULL;
	if (pNode && SUCCEEDED(pNode->get_childNodes (&pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pNSPathNode = NULL;

		// Next node should be a NAMESPACEPATH
		if (SUCCEEDED(pNodeList->nextNode (&pNSPathNode)) && pNSPathNode)
		{
			BSTR strNSNodeName = NULL;

			if (SUCCEEDED(pNSPathNode->get_nodeName(&strNSNodeName)) &&	strNSNodeName)
			{
				if(_wcsicmp(strNSNodeName, NAMESPACEPATH_TAG) == 0)
				{
					BSTR strHost = NULL;
					LPWSTR pszNamespace = NULL;

					if (SUCCEEDED (hr = ParseNamespacePath(pNSPathNode, &strHost, &pszNamespace)))
					{
						// Next node should be the CLASSNAME
						IXMLDOMNode *pClassNameNode = NULL;

						if (SUCCEEDED(pNodeList->nextNode (&pClassNameNode)) && pClassNameNode)
						{
							BSTR strNSClassName = NULL;

							if (SUCCEEDED(pClassNameNode->get_nodeName(&strNSClassName)) &&	strNSClassName)
							{
								if (_wcsicmp(strNSClassName, CLASSNAME_TAG) == 0)
								{
									BSTR strClassName = NULL;

									if (SUCCEEDED(GetBstrAttribute (pClassNameNode,
													g_strName, &strClassName)))
									{
										// Phew - finally we have all the info!

										*ppszClassPath = NULL;
										if((*ppszClassPath) = new WCHAR [wcslen(strHost)
												+ wcslen(pszNamespace) + wcslen(strClassName) + 5])
										{
											wcscpy (*ppszClassPath, L"\\\\");
											wcscat (*ppszClassPath, strHost);
											wcscat (*ppszClassPath, L"\\");
											wcscat (*ppszClassPath, pszNamespace);
											wcscat (*ppszClassPath, L":");
											wcscat (*ppszClassPath, strClassName);

											hr = S_OK;
										}
										else
											hr = E_OUTOFMEMORY;
										SysFreeString (strClassName);
									}
								}
								else
									hr = WBEM_E_INVALID_SYNTAX;

								SysFreeString (strNSClassName);
							}

							pClassNameNode->Release ();
						}

						SysFreeString (strHost);
						delete [] pszNamespace;
					}
				}
				else
					hr = WBEM_E_INVALID_SYNTAX;

				SysFreeString (strNSNodeName);
			}
			pNSPathNode->Release ();
		}
		pNodeList->Release ();
	}
	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::MapInstanceName
//
//  DESCRIPTION:
//
//  Maps an XML INSTANCENAME element into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		pNode			XML element node
//		curValue		Placeholder for new value (set on return)
//
//  RETURN VALUES:
//
//
//***************************************************************************
HRESULT CXml2Wmi::MapInstanceName (IXMLDOMNode *pNode, LPWSTR *ppszInstanceName)
{
	return ParseInstanceName(pNode, ppszInstanceName);
}

HRESULT CXml2Wmi::MapLocalInstancePath (IXMLDOMNode *pNode, LPWSTR *ppszInstancePath)
{
	HRESULT hr = WBEM_E_FAILED;

	// Expecting (LOCALNAMESPACEPATH followed by INSTANCENAME
	IXMLDOMNodeList *pNodeList = NULL;

	if (pNode && SUCCEEDED(pNode->get_childNodes (&pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pLocalNSPathNode = NULL;

		// Next node should be a LOCALNAMESPACEPATH
		if (SUCCEEDED(pNodeList->nextNode (&pLocalNSPathNode)) && pLocalNSPathNode)
		{
			BSTR strNSNodeName = NULL;

			if (SUCCEEDED(pLocalNSPathNode->get_nodeName(&strNSNodeName)) && strNSNodeName )
			{
				if (_wcsicmp(strNSNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					LPWSTR pszLocalNamespace = NULL;
					if(SUCCEEDED(ParseLocalNamespacePath(pLocalNSPathNode, &pszLocalNamespace)))
					{
						// Next node should be the INSTANCENAME
						IXMLDOMNode *pInstanceNameNode = NULL;
						if (SUCCEEDED(pNodeList->nextNode (&pInstanceNameNode)) && pInstanceNameNode)
						{
							BSTR strNSInstanceName = NULL;
							if (SUCCEEDED(pInstanceNameNode->get_nodeName(&strNSInstanceName)) &&
									strNSInstanceName && (_wcsicmp(strNSInstanceName, INSTANCENAME_TAG) == 0))
							{
								LPWSTR pszInstanceName = NULL;
								if (SUCCEEDED(hr = ParseInstanceName (pInstanceNameNode,
													&pszInstanceName)))
								{
									// Phew - finally we have all the info!

									*ppszInstancePath = NULL;
									if((*ppszInstancePath) = new WCHAR [wcslen(pszLocalNamespace)
											+ wcslen(pszInstanceName) + 2])
									{
										wcscpy (*ppszInstancePath, pszLocalNamespace);
										wcscat (*ppszInstancePath, L":");
										wcscat (*ppszInstancePath, pszInstanceName);
										hr = S_OK;
									}
									else
										hr = E_OUTOFMEMORY;
									delete [] pszInstanceName;
								}

								SysFreeString (strNSInstanceName);
							}
							pInstanceNameNode->Release ();
						}
						delete [] pszLocalNamespace;
					}
				}
				else
					hr = WBEM_E_INVALID_SYNTAX;
				SysFreeString (strNSNodeName);
			}

			pLocalNSPathNode->Release ();
		}
		pNodeList->Release ();
	}

	return hr;
}

HRESULT CXml2Wmi::MapInstancePath (IXMLDOMNode *pNode, LPWSTR *ppXML)
{
	HRESULT hr = WBEM_E_FAILED;

	// Expecting NAMESPACEPATH followed by INSTANCENAME
	IXMLDOMNodeList *pNodeList = NULL;
	if (pNode && SUCCEEDED(pNode->get_childNodes (&pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pNSPathNode = NULL;
		// Next node should be a NAMESPACEPATH
		if (SUCCEEDED(pNodeList->nextNode (&pNSPathNode)) && pNSPathNode)
		{
			BSTR strNSNodeName = NULL;
			if (SUCCEEDED(pNSPathNode->get_nodeName(&strNSNodeName)) &&	strNSNodeName )
			{
				if (_wcsicmp(strNSNodeName, NAMESPACEPATH_TAG) == 0)
				{
					BSTR strHost = NULL;
					LPWSTR pszNamespace = NULL;

					if (SUCCEEDED (ParseNamespacePath(pNSPathNode, &strHost, &pszNamespace)))
					{
						// Next node should be the INSTANCENAME
						IXMLDOMNode *pInstanceNameNode = NULL;
						if (SUCCEEDED(pNodeList->nextNode (&pInstanceNameNode)) && pInstanceNameNode)
						{
							BSTR strNSInstanceName = NULL;
							if (SUCCEEDED(pInstanceNameNode->get_nodeName(&strNSInstanceName)) && strNSInstanceName )
							{
								if (_wcsicmp(strNSInstanceName, INSTANCENAME_TAG) == 0)
								{
									LPWSTR pszInstanceName = NULL;

									if (SUCCEEDED(ParseInstanceName (pInstanceNameNode,
													&pszInstanceName)))
									{
										// Phew - finally we have all the info!

										*ppXML = NULL;
										if((*ppXML) = new WCHAR [wcslen(strHost)
												+ wcslen(pszNamespace) + wcslen(pszInstanceName) + 5])
										{
											wcscpy (*ppXML, L"\\\\");
											wcscat (*ppXML, strHost);
											wcscat (*ppXML, L"\\");
											wcscat (*ppXML, pszNamespace);
											wcscat (*ppXML, L":");
											wcscat (*ppXML, pszInstanceName);
											hr = S_OK;
										}
										else
											hr = E_OUTOFMEMORY;
										delete [] pszInstanceName;
									}
								}
								else
									hr = WBEM_E_INVALID_SYNTAX;
								SysFreeString (strNSInstanceName);
							}

							pInstanceNameNode->Release ();
						}

						SysFreeString (strHost);
						delete [] pszNamespace;
					}
				}
				else
					hr = WBEM_E_INVALID_SYNTAX;
				SysFreeString (strNSNodeName);
			}
			pNSPathNode->Release ();
		}
		pNodeList->Release ();
	}

	return hr;
}

HRESULT CXml2Wmi::ParseLocalNamespacePath(IXMLDOMNode *pLocalNamespaceNode, LPWSTR *ppLocalNamespacePath)
{
	// Go thru the children collecting the NAME attribute and concatenating
	// This requires 2 passes since we dont know the length
	//=============================================================

	DWORD dwLength=0;
	*ppLocalNamespacePath = NULL;
	HRESULT result = E_FAIL;

	IXMLDOMNodeList *pChildren = NULL;
	if(SUCCEEDED(result = pLocalNamespaceNode->get_childNodes(&pChildren)))
	{
		IXMLDOMNode *pNextChild = NULL;
		while(SUCCEEDED(pChildren->nextNode(&pNextChild)) && pNextChild)
		{
			BSTR strAttributeValue = NULL;
			if(SUCCEEDED(GetBstrAttribute(pNextChild, g_strName, &strAttributeValue)) && strAttributeValue)
			{
				dwLength += wcslen(strAttributeValue);
				dwLength ++; // For the back slash
				SysFreeString(strAttributeValue);
			}
			pNextChild->Release();
			pNextChild = NULL;
		}

		// Allocate memory
		if(*ppLocalNamespacePath = new WCHAR[dwLength + 1])
		{
			(*ppLocalNamespacePath)[0] = 0;

			// Once more, we make a pass thru the child nodes
			pNextChild = NULL;
			pChildren->reset();
			while(SUCCEEDED(pChildren->nextNode(&pNextChild)) && pNextChild)
			{
				BSTR strAttributeValue = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextChild, g_strName, &strAttributeValue)) && strAttributeValue)
				{
					wcscat(*ppLocalNamespacePath, strAttributeValue);
					wcscat(*ppLocalNamespacePath, L"\\");
					SysFreeString(strAttributeValue);
				}

				pNextChild->Release();
				pNextChild = NULL;
			}

			// Remove the last back slash
			(*ppLocalNamespacePath)[dwLength-1] = NULL;
			result = S_OK;
		}
		else
			result = E_OUTOFMEMORY;
		pChildren->Release();
	}

	return result;
}

// Parse an instance name
HRESULT CXml2Wmi::ParseInstanceName(IXMLDOMNode *pNode, LPWSTR *ppszInstanceName)
{
	HRESULT result = E_FAIL;

	// First get the class name
	BSTR strClassName = NULL;
	if(SUCCEEDED(GetBstrAttribute(pNode, g_strClassName, &strClassName)))
	{
		// See if the child is a KEYBINDING or KEYVALUE 
		IXMLDOMNode *pChildNode = NULL;
		if(SUCCEEDED(pNode->get_firstChild(&pChildNode)) && pChildNode)
		{
			BSTR strNodeName = NULL;
			if(SUCCEEDED(result = pChildNode->get_nodeName(&strNodeName)))
			{
				// Look ahead
				if(_wcsicmp(strNodeName, KEYBINDING_TAG) == 0)
				{
					result = ParseKeyBinding(pNode, strClassName, ppszInstanceName);
				}
				else if (_wcsicmp(strNodeName, KEYVALUE_TAG) == 0)
				{
					// This is case where a class has a single key property
					LPWSTR pszValue = NULL;
					if(SUCCEEDED(result = ParseKeyValue(pNode, &pszValue)))
					{
						*ppszInstanceName = NULL;
						if((*ppszInstanceName) = new WCHAR[wcslen(strClassName) + wcslen(pszValue) + 2])
						{
							wcscpy(*ppszInstanceName, strClassName);
							wcscat(*ppszInstanceName, EQUALS_SIGN);
							wcscat(*ppszInstanceName, pszValue);
							result = S_OK;
						}
						else
							result = E_OUTOFMEMORY;
						delete [] pszValue;
					}
				}
				SysFreeString(strNodeName);
			}
			pChildNode->Release();
		}
		SysFreeString(strClassName);
	}
	return result;
}


// Parse one KEYVALUE element
// 
HRESULT CXml2Wmi::ParseKeyValue(IXMLDOMNode *pNode, LPWSTR *ppszValue)
{
	HRESULT result = E_FAIL;
	BSTR strType = NULL;
	*ppszValue = NULL;

	// There is the possibility of the optioanl VALUE_TYPE attribute
	// The absence of this indicates a string value
	BOOLEAN isString = FALSE;
	if(SUCCEEDED(GetBstrAttribute(pNode, g_strValueType, &strType)))
	{
		if(_wcsicmp(strType, L"string") == 0) // Enclose it in double-quotes
			isString = TRUE;
		SysFreeString(strType);
	}
	else // It's a string by default
	{
		isString = TRUE;
	}

	if(isString) // Escape the appropriate characters and enclose it in double-quotes
	{
		// RAJESHR - What if there is a CDATA section here?
		// In that case, we need to unescape the CDATA encoding before anything
		BSTR strTemp = NULL;
		if(SUCCEEDED(pNode->get_text(&strTemp)))
		{
			LPWSTR pszEscapedTemp = NULL;
			if(pszEscapedTemp = EscapeSpecialCharacters(strTemp))
			{
				if((*ppszValue) = new WCHAR[wcslen(pszEscapedTemp) + 3])
				{
					wcscpy(*ppszValue, QUOTE_SIGN);
					wcscat(*ppszValue, pszEscapedTemp);
					wcscat(*ppszValue, QUOTE_SIGN);
					result = S_OK;
				}
				else
					result = E_OUTOFMEMORY;
				delete [] pszEscapedTemp;
			}
			else
				result = E_OUTOFMEMORY;
			SysFreeString(strTemp);
		}
	}
	else // BOOLEAN or Numeric
	{
		BSTR bstrVal = NULL;
		if(SUCCEEDED(result = pNode->get_text(&bstrVal)))
		{
			if(*ppszValue = new WCHAR[wcslen(bstrVal) + 1])
				wcscpy(*ppszValue, bstrVal);
			else
				result = E_OUTOFMEMORY;
			SysFreeString(bstrVal);
		}
	}
	return result;
}

// Parse one key binding. Return <propName>=<value>
HRESULT CXml2Wmi::ParseOneKeyBinding(IXMLDOMNode *pNode, LPWSTR *ppszValue)
{
	HRESULT result = E_FAIL;
	*ppszValue = NULL;

	// First get the property name
	BSTR strPropertyName = NULL;
	if(SUCCEEDED(GetBstrAttribute(pNode, g_strName, &strPropertyName)))
	{
		// See if the child is a KEYVALUE or VALUE.REFERENCE
		IXMLDOMNode *pChildNode = NULL;
		if(SUCCEEDED(pNode->get_firstChild(&pChildNode)) && pChildNode)
		{
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pChildNode->get_nodeName(&strNodeName)))
			{
				// Look ahead
				if(_wcsicmp(strNodeName, KEYVALUE_TAG) == 0)
				{
					LPWSTR pszValue = NULL;
					if(SUCCEEDED(ParseKeyValue(pChildNode, &pszValue)))
					{
						// COncatenate them with an '=' inbetween
						if(*ppszValue = new WCHAR [ wcslen(strPropertyName) + wcslen(pszValue) + 2])
						{
							wcscpy(*ppszValue, strPropertyName);
							wcscat(*ppszValue, EQUALS_SIGN);
							wcscat(*ppszValue, pszValue);
							result = S_OK;
						}
						else
							result = E_OUTOFMEMORY;
						delete [] pszValue;
					}
				}
				else if (_wcsicmp(strNodeName, VALUEREFERENCE_TAG) == 0)
				{
					IXMLDOMElement * pChildElement = NULL;
					if(SUCCEEDED(pChildNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pChildElement)))
					{
						BSTR strRefValue = NULL;
						BOOL bUseSysFreeString = FALSE;
						if(SUCCEEDED(GetSingleRefValue(pChildElement, &strRefValue, bUseSysFreeString)))
						{
							if(SUCCEEDED(FormRefValueKeyBinding(ppszValue, strPropertyName, strRefValue)))
								result = S_OK;

							// Only in the MapClassName() case a BSTR is allocated. In the others it is an LPWSTR
							if (bUseSysFreeString)
								SysFreeString(strRefValue);
							else
								delete [] strRefValue;
						}
						pChildElement->Release();
					}
				}
				SysFreeString(strNodeName);
			}
			pChildNode->Release();
		}
		SysFreeString(strPropertyName);
	}
	return result;
}

// Parse a KEY binding
HRESULT CXml2Wmi::ParseKeyBinding(IXMLDOMNode *pNode, BSTR strClassName, LPWSTR *ppszInstanceName)
{
	HRESULT result = E_FAIL;

	*ppszInstanceName = NULL;
	if(!((*ppszInstanceName) = new WCHAR [ wcslen(strClassName) + 2]))
		return E_OUTOFMEMORY;

	wcscpy(*ppszInstanceName, strClassName);
	wcscat(*ppszInstanceName, DOT_SIGN);

	// Go thru each of the key  bindings
	//=======================================================
	IXMLDOMNodeList *pBindings = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pBindings)))
	{
		IXMLDOMNode *pNextBinding = NULL;
		BOOL bError = FALSE;
		while(!bError && SUCCEEDED(pBindings->nextNode(&pNextBinding)) && pNextBinding)
		{
			LPWSTR pszNextValue = NULL;
			if(SUCCEEDED(ParseOneKeyBinding(pNextBinding, &pszNextValue)))
			{
				LPWSTR pTemp = NULL;
				if(pTemp = new WCHAR [wcslen(*ppszInstanceName) + wcslen(pszNextValue) + 2])
				{
					wcscpy(pTemp, *ppszInstanceName);
					wcscat(pTemp, pszNextValue);
					wcscat(pTemp, COMMA_SIGN);

					delete [] (*ppszInstanceName);
					*ppszInstanceName = pTemp;
				}
				else
				{
					result = E_OUTOFMEMORY;
					bError = TRUE;
				}

				delete [] pszNextValue;
			}
			else
				bError = TRUE;

			pNextBinding->Release();
			pNextBinding = NULL;
		}

		if(!bError)
			result = S_OK;
		pBindings->Release();
	}

	if(SUCCEEDED(result))
	{
		// Get rid of the last comma
		(*ppszInstanceName)[wcslen(*ppszInstanceName) - 1] = NULL;
	}
	else
	{
		delete [] (*ppszInstanceName);
		*ppszInstanceName = NULL;
	}
	return result;

}


HRESULT CXml2Wmi::ParseNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrHost,  LPWSTR *ppszLocalNamespace)
{
	HRESULT result = E_FAIL;

	*pstrHost = NULL;
	*ppszLocalNamespace = NULL;

	// Get the HOST name first
	IXMLDOMNode *pFirstNode = NULL, *pSecondNode = NULL;
	if(SUCCEEDED(pLocalNamespaceNode->get_firstChild(&pFirstNode)) && pFirstNode)
	{
		// Get the Namespace part
		if(SUCCEEDED (pFirstNode->get_text(pstrHost)))
		{
			if(SUCCEEDED(pLocalNamespaceNode->get_lastChild(&pSecondNode)))
			{
				// Get the instance path
				if(SUCCEEDED(ParseLocalNamespacePath(pSecondNode, ppszLocalNamespace)))
				{
					result = S_OK;
				}
				pSecondNode->Release();
			}
		}
		pFirstNode->Release();
	}

	// In case the failure was in pasring the namespace,
	// we need to make sure that the allocation for the host name 
	// is released
	if(FAILED(result) && *pstrHost)
	{
		SysFreeString(*pstrHost);
		*pstrHost = NULL;
	}

	return result;
}

// A function to escape newlines, tabs etc. from a property value
LPWSTR CXml2Wmi::EscapeSpecialCharacters(LPCWSTR strInputString)
{
	// Escape all the quotes - This code taken from winmgmt\common\var.cpp
	// ====================================================================

	int nStrLen = wcslen(strInputString);
	LPWSTR wszValue = NULL;
	if(wszValue = new WCHAR[nStrLen*2+10])
	{
		LPWSTR pwc = wszValue;
		for(int i = 0; i < (int)nStrLen; i++)
		{
			switch(strInputString[i])
			{
				case L'\n':
					*(pwc++) = L'\\';
					*(pwc++) = L'n';
					break;
				case L'\t':
					*(pwc++) = L'\\';
					*(pwc++) = L't';
					break;
				case L'"':
				case L'\\':
					*(pwc++) = L'\\';
					*(pwc++) = strInputString[i];
					break;
				default:
					*(pwc++) = strInputString[i];
					break;
			}
		}
		*pwc = 0;
	}
	return wszValue;
}


HRESULT CXml2Wmi::AddObjectQualifiers (
	bool bAllowWMIExtensions,
	IXMLDOMElement *pXml,
	IWbemClassObject *pObject
)
{
	HRESULT hr = E_FAIL;

	// Get the object qualifeir set
	IWbemQualifierSet *pQuals = NULL;
	if(FAILED(hr = pObject->GetQualifierSet(&pQuals)))
		return hr;

	// Add the object qualifiers and the property/Method qualifiers
	// Cycle thru the child nodes looking for QUALIFIER, PROPERTY* or METHOD nodes

	IXMLDOMNodeList *pNodeList = NULL;
	if (SUCCEEDED(pXml->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		bool bError = false;
		while (!bError && SUCCEEDED(pNodeList->nextNode (&pNode)) && pNode)
		{
			BSTR strNodeName = NULL;
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				// This one is an object qualifier
				if(_wcsicmp(strNodeName, L"QUALIFIER") == 0)
				{
					if(FAILED(hr = AddQualifier(pNode, pQuals, true)))
						bError = TRUE;
				}

				// This one is a property qualifier
				// No need to add method qualifiers - we have already done them
				else if(_wcsicmp(strNodeName, L"PROPERTY") == 0 ||
						_wcsicmp(strNodeName, L"PROPERTY.ARRAY") == 0 ||
						_wcsicmp(strNodeName, L"PROPERTY.REFERENCE") == 0 ||
						_wcsicmp(strNodeName, L"PROPERTY.REFARRAY") == 0 ||
						(_wcsicmp(strNodeName, L"PROPERTY.OBJECT") == 0  && bAllowWMIExtensions) ||
						(_wcsicmp(strNodeName, L"PROPERTY.OBJECTARRAY") == 0 && bAllowWMIExtensions))
				{
					// Get the property name
					BSTR strPropertyName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNode, g_strName, &strPropertyName)))
					{
						if(_wcsnicmp(strPropertyName, L"__", 2) == 0)
						{
							// Ignore other system properties
						}
						else
						{
							IWbemQualifierSet *pPropSet = NULL;
							if(SUCCEEDED(pObject->GetPropertyQualifierSet(strPropertyName, &pPropSet)))
							{
								if(FAILED(hr = AddElementQualifiers(pNode, pPropSet)))
									bError = TRUE;
								pPropSet->Release();
							}
							else
								bError = TRUE;
						}
						SysFreeString(strPropertyName);
					}
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}

		if(bError)
		{
			// If hr does not indicate a failure, then we indicate 
			// a generic failure
			if(SUCCEEDED(hr))
				hr = WBEM_E_FAILED;
		}
		else
			hr = S_OK;
		pNodeList->Release();
	}
	pQuals->Release();
	return hr;
}


HRESULT CXml2Wmi::AddElementQualifiers (
	IXMLDOMNode* pXml,
	IWbemQualifierSet *pQuals
)
{
	HRESULT hr = E_FAIL;

	// Cycle thru the child nodes looking for QUALIFIER nodes
	IXMLDOMNodeList *pNodeList = NULL;
	if (SUCCEEDED(pXml->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		bool bError = false;
		while (!bError && SUCCEEDED(pNodeList->nextNode (&pNode)) && pNode)
		{
			BSTR strNodeName = NULL;
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				// Check if this is a node we're interested in - A QUALIFIER node
				if(_wcsicmp(strNodeName, L"QUALIFIER") == 0)
				{
					if(FAILED(hr = AddQualifier(pNode, pQuals)))
						bError = TRUE;
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}

		if(bError)
		{
			// If hr does not indicate a failure, then we indicate 
			// a generic failure
			if(SUCCEEDED(hr))
				hr = WBEM_E_FAILED;
		}
		else
			hr = S_OK;
		pNodeList->Release();
	}
	return hr;
}

HRESULT CXml2Wmi::CreateParametersInstance(IWbemClassObject **pParamObject)
{
	HRESULT hr = E_FAIL;
		// Create a Free Form Object
	_IWmiFreeFormObject *pObj = NULL;
	*pParamObject = NULL;
	if(SUCCEEDED(hr = g_pObjectFactory->Create(NULL, 0, CLSID__WmiFreeFormObject, IID__IWmiFreeFormObject, (LPVOID *)&pObj)))
	{
		// Set the class name on it
		if(SUCCEEDED(hr = pObj->SetClassName(0, L"__Parameters")))
		{
			// if(SUCCEEDED(hr = pObj->MakeInstance(0)))
				hr = pObj->QueryInterface(IID_IWbemClassObject, (LPVOID *)pParamObject);
		}
		pObj->Release();
	}
	return hr;
}

// Creates all the Methods in a class
HRESULT CXml2Wmi::CreateWMIMethods(bool bAllowWMIExtensions, IWbemClassObject *pObj, IXMLDOMElement *pXML)
{
	HRESULT hr = S_OK;

	// Now cycle thru the properties
	IXMLDOMNodeList *pNodeList = NULL;
	bool bError = false;
	if (SUCCEEDED(pXML->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bError && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
		{
			BSTR strNodeName = NULL;
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				if(_wcsicmp(strNodeName, L"METHOD") == 0 )
				{
					IXMLDOMElement *pMethodElement = NULL;
					if(SUCCEEDED(pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pMethodElement)))
					{
						if(FAILED(hr = CreateAWMIMethod(bAllowWMIExtensions, pObj, pMethodElement)))
							bError = true;
						pMethodElement->Release();
					}
					else
						bError = true;
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}

	return hr;
}

// Creates a Methods in a class
HRESULT CXml2Wmi::CreateAWMIMethod(bool bAllowWMIExtensions, IWbemClassObject *pObj, IXMLDOMElement *pMethod)
{
	HRESULT hr = WBEM_E_FAILED;

	if (pMethod)
	{
		BSTR strName = NULL;
		BSTR strType = NULL;

		// Get the attributes we need for the mapping
		GetBstrAttribute (pMethod, g_strName, &strName);
		GetBstrAttribute (pMethod, g_strType, &strType);

		// The method should atleast have a name
		if (strName)
		{
			// Put a provisional version of the method
			// so we can get the qualifier set
			if (SUCCEEDED(hr = pObj->PutMethod(strName, 0, NULL, NULL)))
			{
				IWbemQualifierSet *pQualSet = NULL;
				IWbemClassObject *pInParameters = NULL;
				IWbemClassObject *pOutParameters = NULL;

				if (SUCCEEDED(hr = pObj->GetMethodQualifierSet (strName, &pQualSet)))
				{
					// If we have a return value, set that
					if (strType && (0 < wcslen (strType)))
					{
						CIMTYPE cimtype = CIM_ILLEGAL;

						if (CIM_ILLEGAL == (cimtype = CimtypeFromString (strType)))
							hr = WBEM_E_FAILED;
						else if (SUCCEEDED(hr = CreateParametersInstance(&pOutParameters)))
							hr = pOutParameters->Put (L"ReturnValue", 0, NULL, cimtype);
					}


					// The content of this element should be 0 or
					// more QUALIFIER elements followed by 0 or more
					// PARAMETER.* elements.
					VARIANT_BOOL bHasChildNodes;

					if (SUCCEEDED(pMethod->hasChildNodes (&bHasChildNodes)) &&
						(VARIANT_TRUE == bHasChildNodes))
					{
						IXMLDOMNodeList *pNodeList = NULL;
						// We can be in one of 3 states whilst iterating
						// this list - parsing qualifiers or parsing the value
						enum {
							parsingQualifiers,
							parsingParameters
						} parseState = parsingQualifiers;

						if (SUCCEEDED(pMethod->get_childNodes (&pNodeList)))
						{
							IXMLDOMNode *pNode = NULL;
							ULONG paramId = 0;

							while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
							{
								BSTR strNodeName = NULL;

								if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
								{
									if (parsingQualifiers == parseState)
									{
										if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
											hr = AddQualifier (pNode, pQualSet);
										else
											parseState = parsingParameters;
									}

									if (parsingParameters == parseState)
									{
										if (0 == _wcsicmp(strNodeName, PARAMETER_TAG))
										{
											hr = MapParameter (pNode, &pInParameters,
													&pOutParameters,
													paramId, false);
											paramId++;
										}
										else if (0 == _wcsicmp(strNodeName,
													PARAMETERARRAY_TAG))
										{
											hr = MapParameter (pNode,
													&pInParameters, &pOutParameters,
													paramId, true);
										 	paramId++;
										}
										else if (0 == _wcsicmp(strNodeName,
													PARAMETERREFERENCE_TAG))
										{
											hr = MapReferenceOrObjectParameter (pNode,
													&pInParameters, &pOutParameters,
													paramId, false, true);
											paramId++;
										}
										else if (0 == _wcsicmp(strNodeName,
													PARAMETERREFARRAY_TAG))
										{
											hr = MapReferenceOrObjectParameter (pNode,
													&pInParameters, &pOutParameters,
													paramId, true, true);
											paramId++;
										}
										else if (0 == _wcsicmp(strNodeName,
													PARAMETEROBJECT_TAG) && bAllowWMIExtensions)
										{
											hr = MapReferenceOrObjectParameter (pNode,
													&pInParameters, &pOutParameters,
													paramId, false, false);
											paramId++;
										}
										else if (0 == _wcsicmp(strNodeName,
													PARAMETEROBJECTARRAY_TAG) && bAllowWMIExtensions)
										{
											hr = MapReferenceOrObjectParameter (pNode,
													&pInParameters, &pOutParameters,
													paramId, true, false);
											paramId++;
										}
										else
											hr = WBEM_E_FAILED;	// Parse error
									}

									SysFreeString (strNodeName);
								}

								pNode->Release ();
								pNode = NULL;
							}

							pNodeList->Release ();
						}
					}

					pQualSet->Release ();
				}

				// Put it all together
				if (SUCCEEDED (hr))
					hr = pObj->PutMethod (strName, 0, pInParameters, pOutParameters);

				if (pInParameters)
					pInParameters->Release ();

				if (pOutParameters)
					pOutParameters->Release ();
			}
		}
		else
			hr = WBEM_E_INVALID_METHOD;

		SysFreeString (strName);
		SysFreeString (strType);
	}
	return hr;
}

HRESULT CXml2Wmi::MapParameter (
	IXMLDOMNode *pParameter,
	IWbemClassObject **ppInParameters,
	IWbemClassObject **ppOutParameters,
	ULONG paramId,
	bool bIsArray
)
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;
	bool bIsInParameter = false;
	bool bIsOutParameter = false;
	BSTR bsName = NULL;
	CIMTYPE cimtype = CIM_ILLEGAL;
	long iArraySize = 0;

	if (DetermineParameterCharacteristics (pParameter, bIsArray, bIsInParameter,
					bIsOutParameter, bsName, cimtype, iArraySize, false, NULL))
	{
		if (bIsInParameter)
		{
			if (!(*ppInParameters))
				hr = CreateParametersInstance (ppInParameters);

			if (*ppInParameters)
			{
				if (SUCCEEDED(hr = (*ppInParameters)->Put (bsName, 0, NULL, cimtype)))
				{
					// Now do the qualifiers
					IWbemQualifierSet *pQualSet = NULL;
					if (SUCCEEDED(hr = (*ppInParameters)->GetPropertyQualifierSet
												(bsName, &pQualSet)))
					{
						hr = MapParameterQualifiers (pParameter, pQualSet, paramId,
														bIsArray, iArraySize, true);
						pQualSet->Release ();
					}
				}
			}
		}

		if (bIsOutParameter)
		{
			if (!(*ppOutParameters))
				CreateParametersInstance(ppOutParameters);

			if (*ppOutParameters)
			{
				if (SUCCEEDED(hr = (*ppOutParameters)->Put (bsName, 0, NULL, cimtype)))
				{
					// Now do the qualifiers
					IWbemQualifierSet *pQualSet = NULL;

					if (SUCCEEDED(hr = (*ppOutParameters)->GetPropertyQualifierSet
												(bsName, &pQualSet)))
					{
						hr = MapParameterQualifiers (pParameter, pQualSet, paramId,
														bIsArray, iArraySize, false);
						pQualSet->Release ();
					}
				}
			}
		}

		SysFreeString (bsName);
	}

	return hr;
}

bool CXml2Wmi::DetermineParameterCharacteristics (
	IXMLDOMNode *pParameter,
	bool bIsArray,
	bool &bIsInParameter,
	bool &bIsOutParameter,
	BSTR &bsName,
	CIMTYPE &cimtype,
	long &iArraySize,
	bool bIsReference,
	BSTR *pbsReferenceClass)
{
	bool result = false;
	bIsInParameter = false;
	bIsOutParameter = false;

	// Get name
	GetBstrAttribute (pParameter, g_strName, &bsName);

	if (bsName)
	{
		if (bIsArray)
		{
			// Get the arraysize (if any)
			BSTR bsArraySize = NULL;
			GetBstrAttribute (pParameter, g_strArraySize, &bsArraySize);
			if (bsArraySize)
				iArraySize = wcstol (bsArraySize, NULL, 0);
			SysFreeString (bsArraySize);
		}

		// Now get the cimtype
		if (bIsReference)
		{
			cimtype = CIM_REFERENCE;
			if (pbsReferenceClass)
				GetBstrAttribute (pParameter, g_strReferenceClass, pbsReferenceClass);
		}
		else
		{
			BSTR bsCimtype = NULL;
			GetBstrAttribute (pParameter, g_strType, &bsCimtype);
			cimtype = CimtypeFromString (bsCimtype);
			SysFreeString (bsCimtype);
		}

		if (CIM_ILLEGAL != cimtype)
		{
			if (bIsArray)
				cimtype |= CIM_FLAG_ARRAY;

			result = true;

			// Now find out if the method is an in or out
			// (or both) parameter - need to go through
			// qualifier list
			IXMLDOMNodeList *pNodeList = NULL;
			if (SUCCEEDED(pParameter->get_childNodes (&pNodeList)))
			{
				IXMLDOMNode *pNode = NULL;
				HRESULT hr = S_OK;

				while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
				{
					BSTR strNodeName = NULL;
					if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
					{
						if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
						{
							BSTR bsName = NULL;
							GetBstrAttribute (pNode, g_strName, &bsName);
							if (bsName)
							{
								bool bCandidate = false;
								bool bsIn = true;

								if (0 == _wcsicmp (bsName, L"IN"))
									bCandidate = true;
								else if (0 == _wcsicmp (bsName, L"OUT"))
								{
									bCandidate = true;
									bsIn = false;
								}

								if (bCandidate)
								{
									BSTR bsType = NULL;
									GetBstrAttribute (pNode, g_strType, &bsType);
									if (bsType && (0 == _wcsicmp (bsType, L"boolean")))
									{
										BSTR bsValue = NULL;
										if (SUCCEEDED(pNode->get_text(&bsValue)) &&
											bsValue && (0 == _wcsicmp (bsValue, L"TRUE")))
										{
											if (bsIn)
												bIsInParameter = true;
											else
												bIsOutParameter = true;
										}
										SysFreeString(bsValue);
									}
									SysFreeString (bsType);
								}

								SysFreeString (bsName);
							}
						}

						SysFreeString (strNodeName);
					}

					pNode->Release ();
					pNode = NULL;
				}

				pNodeList->Release ();
			}
		}
	}

	if (!result)
	{
		SysFreeString (bsName);
		bsName = NULL;
	}

	return result;
}

HRESULT CXml2Wmi::MapParameterQualifiers (
	IXMLDOMNode *pParameter,
	IWbemQualifierSet *pQualSet,
	ULONG paramId,
	bool bIsArray,
	long iArraySize,
	bool bIsInParameter
)
{
	HRESULT hr = S_OK;

	IXMLDOMNodeList *pNodeList = NULL;
	if (SUCCEEDED(pParameter->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;

		while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
		{
			BSTR strNodeName = NULL;
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
				{
					// We must only add the IN qualifier to an In parameter,
					// and the OUT parameter to an Out parameter
					BSTR bsName = NULL;
					GetBstrAttribute (pNode, g_strName, &bsName);
					if (bsName)
					{
						if (0 == _wcsicmp (bsName, L"IN"))
						{
							if (bIsInParameter)
								hr = AddQualifier (pNode, pQualSet);
						}
						else if (0 == _wcsicmp (bsName, L"OUT"))
						{
							if (!bIsInParameter)
								hr = AddQualifier (pNode, pQualSet);
						}
						else
							hr = AddQualifier (pNode, pQualSet);
						SysFreeString (bsName);
					}
				}
				SysFreeString (strNodeName);
			}

			pNode->Release ();
			pNode = NULL;
		}

		if (SUCCEEDED(hr))
		{
			long flavor = WBEM_FLAVOR_NOT_OVERRIDABLE |
										WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
			// Add in the parameter id
			VARIANT var;
			VariantInit (&var);
			var.vt = VT_I4;
			var.lVal = paramId;
			hr = pQualSet->Put (L"ID", &var, flavor);
			VariantClear (&var);

			if (SUCCEEDED(hr) && bIsArray && (0 < iArraySize))
			{
				// Add in MIN and MAX qualifiers
				var.vt = VT_I4;
				var.lVal = iArraySize;

				if (SUCCEEDED(hr = pQualSet->Put (L"MAX", &var, flavor)))
					hr = pQualSet->Put (L"MIN", &var, flavor);
			}
		}

		pNodeList->Release ();
	}

	return hr;
}

HRESULT CXml2Wmi::MapReferenceOrObjectParameter (
	IXMLDOMNode *pParameter,
	IWbemClassObject **ppInParameters,
	IWbemClassObject **ppOutParameters,
	ULONG paramId,
	bool bIsArray,
	bool bIsReference
)
{
	HRESULT hr = WBEM_E_FAILED;
	bool bIsInParameter = false;
	bool bIsOutParameter = false;
	BSTR bsName = NULL;
	BSTR bsReferenceClass = NULL;
	long iArraySize = 0;
	CIMTYPE cimtype = CIM_ILLEGAL;

	if (DetermineParameterCharacteristics (pParameter, bIsArray, bIsInParameter,
					bIsOutParameter, bsName, cimtype, iArraySize,
					true, &bsReferenceClass))
	{
		// The above function always returns CIM_REFERENCE for both references
		// and embedded objects - but we know better
		if(!bIsReference)
			cimtype = CIM_OBJECT;

		if (bIsInParameter)
		{
			if (!(*ppInParameters))
				CreateParametersInstance(ppInParameters);

			if (*ppInParameters)
			{
				if (SUCCEEDED(hr = (*ppInParameters)->Put (bsName, 0, NULL, cimtype)))
				{
					// Now do the qualifiers
					IWbemQualifierSet *pQualSet = NULL;

					if (SUCCEEDED(hr = (*ppInParameters)->GetPropertyQualifierSet
												(bsName, &pQualSet)))
					{
						hr = MapParameterQualifiers (pParameter, pQualSet, paramId,
										bIsArray, iArraySize, true);

						// If a strong reference, add it now
						if (bsReferenceClass)
							SetReferenceOrObjectClass (pQualSet, bsReferenceClass, bIsReference);

						pQualSet->Release ();
					}
				}
			}
		}

		if (bIsOutParameter)
		{
			if (!(*ppOutParameters))
				hr = CreateParametersInstance (ppOutParameters);

			if (*ppOutParameters)
			{
				if (SUCCEEDED(hr = (*ppOutParameters)->Put (bsName, 0, NULL, cimtype)))
				{
					// Now do the qualifiers
					IWbemQualifierSet *pQualSet = NULL;

					if (SUCCEEDED(hr = (*ppOutParameters)->GetPropertyQualifierSet
												(bsName, &pQualSet)))
					{
						hr = MapParameterQualifiers (pParameter, pQualSet, paramId,
														bIsArray, iArraySize, false);
						// If a strong reference, add it now
						if (bsReferenceClass)
							SetReferenceOrObjectClass (pQualSet, bsReferenceClass, bIsReference);

						pQualSet->Release ();
					}
				}
			}
		}

		SysFreeString(bsReferenceClass);
		SysFreeString (bsName);
	}

	return hr;
}

HRESULT CXml2Wmi::SetReferenceOrObjectClass (
	IWbemQualifierSet *pQualSet,
	BSTR strReferenceClass,
	bool bIsReference
)
{
	HRESULT hr = WBEM_E_FAILED;
	int strLen = (bIsReference)? wcslen(REF_WSTR) : wcslen(OBJECT_WSTR);
	bool bIsStrongReference = (strReferenceClass && (0 < wcslen(strReferenceClass)));

	if (bIsStrongReference)
		strLen += wcslen(strReferenceClass) + 1;	// 1 for the ":" separator

	WCHAR *pRef = NULL;
	if(pRef = new WCHAR [strLen + 1])
	{
		(bIsReference)? wcscpy (pRef, REF_WSTR) : wcscpy(pRef, OBJECT_WSTR);
		if (bIsStrongReference)
		{
			wcscat (pRef, L":");
			wcscat (pRef, strReferenceClass);
		}

		VARIANT curValue;
		VariantInit (&curValue);
		curValue.vt = VT_BSTR;
		curValue.bstrVal = NULL;
		if(curValue.bstrVal = SysAllocString (pRef))
		{
			hr = pQualSet->Put(L"CIMTYPE", &curValue,
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS|
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE|
							WBEM_FLAVOR_NOT_OVERRIDABLE);
		}
		else
			hr = E_OUTOFMEMORY;
		VariantClear (&curValue);
		delete [] pRef;
	}
	else
		hr = E_OUTOFMEMORY;

	return hr;
}


HRESULT CXml2Wmi::FixRefsAndEmbeddedObjects(IXMLDOMElement *pMethod, IWbemClassObject *pObj)
{
	// In this function we've to go thru all the reference and embedded properties (and arrays of those kind)
	// and convert them to strong references if applicable, by adding appropriate qualifiers
	// The reason we do this is that the Free-Form object interfaces do not allow you to add qualifers,
	// but allow only properties. Hence we initially added these properties as weak references.
	// Now we have to add qualifiers to make them strong references in those cases where applicable

	// Go thru all the properties of the class
	IXMLDOMNodeList *pNodeList = NULL;
	bool bError = false;
	if (SUCCEEDED(pMethod->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bError && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
		{
			BSTR strNodeName = NULL;
			// We work only on 4 kinds of properties in this functions
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				if(	_wcsicmp(strNodeName, L"PROPERTY.REFERENCE") == 0 ||
					_wcsicmp(strNodeName, L"PROPERTY.OBJECT") == 0 ||
					_wcsicmp(strNodeName, L"PROPERTY.OBJECTARRAY") == 0 ||
					_wcsicmp(strNodeName, L"PROPERTY.REFARRAY") == 0 )
				{
					IXMLDOMElement *pPropElement = NULL;
					if(SUCCEEDED(pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pPropElement)))
					{
						bool bIsRef = false;
						if(	_wcsicmp(strNodeName, L"PROPERTY.REFERENCE") == 0 ||
							_wcsicmp(strNodeName, L"PROPERTY.REFARRAY") == 0 )
							bIsRef = true;

						// Fix the property
						if(FAILED(FixRefOrEmbeddedProperty(pPropElement, pObj, bIsRef)))
							bError = true;
						pPropElement->Release();
					}
					else
						bError = true;
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}
	if(bError)
		return E_FAIL;
	return S_OK;
}


HRESULT CXml2Wmi::FixRefOrEmbeddedProperty(IXMLDOMElement *pProperty, IWbemClassObject *pObj, bool bIsRef)
{
	// In this, we have a PROPERTY.REFERENCE or PROPERTY.OBJECT
	HRESULT hr = E_FAIL;
	// Get the name of the property
	BSTR strName = NULL;
	if(SUCCEEDED(hr = GetBstrAttribute (pProperty, g_strName, &strName)))
	{
		BSTR strReferenceClass = NULL;
		// Get the strong type (if any) of the reference/embedded object
		if(SUCCEEDED(GetBstrAttribute (pProperty, g_strReferenceClass, &strReferenceClass)))
		{
			// Set the qualifier on the property
			hr = FixAProperty(pObj, strName, strReferenceClass, bIsRef);
			SysFreeString(strReferenceClass);
		}
		else
			hr = S_OK; // This is an anonymous reference/object - No qualifier required
		SysFreeString(strName);
	}
	return hr;
}

HRESULT CXml2Wmi::FixAProperty(IWbemClassObject *pObj, BSTR strPropName, BSTR strRefClass, bool bIsRef)
{
	// Get the Property Qualifier Set
	IWbemQualifierSet *pSet = NULL;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(pObj->GetPropertyQualifierSet(strPropName, &pSet)))
	{
		VARIANT vQualValue;
		VariantInit(&vQualValue);

		LPWSTR pszQualValue = NULL;
		if(pszQualValue = new WCHAR[6 + 1 + wcslen(strRefClass) + 1])
		{
			if(bIsRef)
				wcscpy(pszQualValue, L"ref:");
			else
				wcscpy(pszQualValue, L"object:");
			wcscat(pszQualValue, strRefClass);
			BSTR strQualValue = NULL;
			if(strQualValue = SysAllocString(pszQualValue))
			{
				vQualValue.vt = VT_BSTR;
				vQualValue.bstrVal = strQualValue;

				hr = pSet->Put(L"CIMTYPE", &vQualValue,
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS|
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE|
					WBEM_FLAVOR_NOT_OVERRIDABLE);

				VariantClear(&vQualValue);
			}
			else
				hr = E_OUTOFMEMORY;
			delete [] pszQualValue;
		}
		else
			hr = E_OUTOFMEMORY;
		pSet->Release();
	}
	return hr;
}

HRESULT CXml2Wmi::DecorateObject(_IWmiFreeFormObject *pObj, BSTR strServer, BSTR strNamespace)
{
	// We need to set the __SERVER and and _NAMESPACE properties
	bool bFreeServer = false;
	if(!strServer)
	{
		bFreeServer = true;
		strServer = SysAllocString(L".");
	}

	_IWmiObject *pWmiObj = NULL;
	if(SUCCEEDED(pObj->QueryInterface(IID__IWmiObject, (LPVOID *)&pWmiObj)))
	{
		// It is OK to fail
		pWmiObj->SetDecoration(strServer, strNamespace);
		pWmiObj->Release();
	}
	
	if(bFreeServer)
		SysFreeString(strServer);

	// It is OK if we cant decorate every object 
	return S_OK;
}


// Forms a string of the form pszPropertyName="pszRefValue"
// That is, adds double quotes around the value and also
// escapes any double quotes in the pszRefValue
HRESULT CXml2Wmi::FormRefValueKeyBinding(LPWSTR *ppszValue, LPCWSTR pszPropertyName, LPCWSTR pszRefValue)
{
	HRESULT result = S_OK;
	LPWSTR pszEscapedStringValue = NULL;
	if(pszEscapedStringValue = EscapeSpecialCharacters(pszRefValue))
	{
		// Add suffucuent memory for the '=' and the 2 double-quotes
		if((*ppszValue) = new WCHAR[wcslen(pszPropertyName) + wcslen(pszEscapedStringValue) + 4])
		{
			wcscpy(*ppszValue, pszPropertyName);
			wcscat(*ppszValue, EQUALS_SIGN);
			wcscat(*ppszValue, QUOTE_SIGN);
			wcscat(*ppszValue, pszEscapedStringValue);
			wcscat(*ppszValue, QUOTE_SIGN);
			result = S_OK;
		}
		else
			result = E_OUTOFMEMORY;
		delete [] pszEscapedStringValue;
	}
	else
		result = E_OUTOFMEMORY;
	return result;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\tests\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <objbase.h>
#include <wbemcli.h>



void FillUpContext(IWbemContext *pContext)
{
	VARIANT vValue;

	// IncludeQualifiers
	VariantInit(&vValue);
	vValue.vt = VT_BOOL;
	vValue.boolVal = VARIANT_FALSE;
	pContext->SetValue(L"IncludeQualifiers", 0, &vValue);
	VariantClear(&vValue);

	// PathLevel
	// 
	// pathLevelAnonymous = 0
	// pathLevelNamed,
	// pathLevelLocal,
	// pathLevelFull		

	VariantInit(&vValue);
	vValue.vt = VT_I4;
	vValue.lVal = 0;
	pContext->SetValue(L"PathLevel", 0, &vValue);
	VariantClear(&vValue);

	// ExcludeSystemProperties
	VariantInit(&vValue);
	vValue.vt = VT_BOOL;
	vValue.boolVal = VARIANT_TRUE;
	pContext->SetValue(L"ExcludeSystemProperties", 0, &vValue);
	VariantClear(&vValue);

}

int _cdecl main(int argc, char * argv[])
{
	if(FAILED(CoInitialize(NULL)))
		return 1;
	HRESULT hr = E_FAIL;
	IWbemObjectTextSrc *pSrc = NULL;

	IWbemLocator *pL = NULL;
	if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
												IID_IWbemLocator, (void**) &pL)))
	{
		// Create a context object
		IWbemContext *pContext = NULL;
		if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER,
													IID_IWbemContext, (void**) &pContext)))
		{
			FillUpContext(pContext);
			IWbemServices *pConnection = NULL;
			BSTR strNs = SysAllocString(L"root\\cimv2");
			BSTR strText = NULL;
			if(SUCCEEDED(hr = pL->ConnectServer(strNs, NULL, NULL, NULL, 0, NULL, NULL, &pConnection)))
			{
				IWbemClassObject *pClass = NULL;
				//BSTR strObj = SysAllocString(L"MethCLass.KeyProp=\"abc\"");
				// BSTR strObj = SysAllocString(L"MethCLass");
				BSTR strObj = SysAllocString(L"Win32_LogicalDisk");

				
				if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER,
															IID_IWbemObjectTextSrc, (void**) &pSrc)))
				{
					// Test for GetObject
					if(SUCCEEDED(hr = pConnection->GetObject(strObj, 0, NULL, &pClass, NULL)))
					{
						if(SUCCEEDED(hr = pSrc->GetText(0, pClass, WMI_OBJ_TEXT_CIM_DTD_2_0, pContext, &strText)))
						{
							printf("GETOBJECT SUCCEEDED\n");
							printf("================================================\n");
							wprintf(strText);
						}
						else
							printf("GetText failed with %x\n", hr);
						pClass->Release();
					}
					else
						printf("GetObject  failed with %x\n", hr);

				}
				else
					printf("CoCreateInstance on WbemObjectTextSrc failed with %x\n", hr);


				// Test for PutClass
				
				strText = SysAllocString(
					L"<CLASS NAME=\"abc\"><PROPERTY NAME=\"__PATH\" TYPE=\"string\"><VALUE>\\\\CALVINIDS\\root\\DEFAULT:abc</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__NAMESPACE\" TYPE=\"string\"><VALUE>root\\DEFAULT</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__SERVER\" TYPE=\"string\"><VALUE>CALVINIDS</VALUE></PROPERTY><PROPERTY.ARRAY NAME=\"__DERIVATION\" TYPE=\"string\"><VALUE.ARRAY></VALUE.ARRAY></PROPERTY.ARRAY>"
					L"<PROPERTY NAME=\"__PROPERTY_COUNT\" TYPE=\"sint32\"><VALUE>1</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__RELPATH\" TYPE=\"string\"><VALUE>abc</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__DYNASTY\" TYPE=\"string\"><VALUE>abc</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__SUPERCLASS\" TYPE=\"string\"></PROPERTY>"
					L"<PROPERTY NAME=\"__CLASS\" TYPE=\"string\"><VALUE>abc</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__GENUS\" TYPE=\"sint32\"><VALUE>1</VALUE></PROPERTY>"
					L"<PROPERTY.ARRAY NAME=\"__SECURITY_DESCRIPTOR\" TYPE=\"uint8\"></PROPERTY.ARRAY>"
					L"<PROPERTY NAME=\"__TCREATED\" TYPE=\"uint64\"></PROPERTY>"
					L"<PROPERTY NAME=\"__TEXPIRATION\" TYPE=\"uint64\"></PROPERTY>"
					L"<PROPERTY NAME=\"__TMODIFIED\" TYPE=\"uint64\"></PROPERTY>"
					L"<PROPERTY NAME=\"ssad\" TYPE=\"string\"></PROPERTY></CLASS>");

				IWbemClassObject *pNewObj = NULL;
				/* strText = SysAllocString(L"<INSTANCE CLASSNAME=\"BLUESCREEN\">"\
					L"<PROPERTY NAME=\"STOPCODE\" TYPE=\"string\"><VALUE>e2</VALUE></PROPERTY>"\
					L"<PROPERTY.ARRAY NAME=\"IPADDRESS\" TYPE=\"string\">"\
					L"<VALUE.ARRAY>"\
					L"<VALUE>\"192.168.0.10\"</VALUE>"\
					L"</VALUE.ARRAY>"\
					L"</PROPERTY.ARRAY>"\
					L"</INSTANCE>");*/
				// strText = SysAllocString(L"<CLASS NAME='test'><PROPERTY></PROPERTY></CLASS>");

				if(SUCCEEDED(hr = pSrc->CreateFromText(0, strText, WMI_OBJ_TEXT_CIM_DTD_2_0, NULL, &pNewObj)))
				{
					wprintf(L"\n\nCREATEFROMTEXT() SUCCEEDED FOR %s\n\n", strText); 
					// Test to get the RELPATH
					VARIANT var;
					VariantInit(&var);
					if(FAILED(pNewObj->Get (L"__RELPATH", 0, &var, NULL, NULL)))
						exit(0);

					BSTR strXML = NULL;
					if(SUCCEEDED(hr = pSrc->GetText(0, pNewObj, WMI_OBJ_TEXT_WMI_DTD_2_0, NULL, &strXML)))
					{
						printf("PutClass Succeeded: Result is\n");
						wprintf(strXML);
					}
					else
						printf("GetText on new class failed!\n");
				}
				else
					printf("\n\nCREATEFROMTEXT() FAILED with %x\n\n", hr); 
				


				// Test for ExecQuery
				//BSTR strQuery = SysAllocString(L"Select GroupName, Name, UserName from Win32_ProgramGroup");
				BSTR strQuery = SysAllocString(L"Select * from Win32_ProgramGroup");
				BSTR strQueryLang = SysAllocString(L"WQL");
				IEnumWbemClassObject *pEnum = NULL;
				if(FAILED(hr = CoSetProxyBlanket(pConnection, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, NULL,
					RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_DEFAULT)))
				{
					printf("Failed to set proxy blanket\n");
					exit(1);
				}

				if(SUCCEEDED(hr = pConnection->ExecQuery(strQueryLang, strQuery, 0, NULL, &pEnum)))
				{
					IWbemClassObject *pNextObject = NULL;
					DWORD dwCount = 1;
					while(SUCCEEDED(pEnum->Next(WBEM_INFINITE , 1, &pNextObject, &dwCount)) && dwCount == 1)
					{
						BSTR strText = NULL;
						if(SUCCEEDED(hr = pSrc->GetText(0, pNextObject, WMI_OBJ_TEXT_WMI_DTD_2_0, pContext, &strText)))
						{
							printf("EXECQUERY SUCCEEDED\n");
							printf("================================================\n");
							wprintf(strText);
							SysFreeString(strText);
						}
						else
							printf("GetText failed with %x\n", hr);
						pNextObject->Release();
					}
					pEnum->Release();
				}
				else
					printf("ExecQuery  failed with %x\n", hr);
			
			
			}
			else
				printf("ConnectServer on root\\cimv2 failed with %x\n", hr);
		}
	}
	else
		printf("CoCreateInstance on Locator failed with %x\n", hr);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmiisapi\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\xmltowmi.h ===
/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 


// ***************************************************************************
//	
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  XMLTOWMI.H
//
//  rajesh  3/25/2000   Created.
//
// Contains the class definition of the component that implements the IXMLWbemConvertor
// interface
//
// ***************************************************************************


#ifndef XML_TEST_TO_WMI_H
#define XML_TEST_TO_WMI_H

class CXml2Wmi : public IXMLWbemConvertor
{
	long					m_cRef; // COM Ref count

public:
	CXml2Wmi();
	virtual ~CXml2Wmi();

    //Non-delegating object IUnknown
public:
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// These are functions from the IXMLWbemConvertor interface
public:
	HRESULT STDMETHODCALLTYPE MapObjectToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags,  BSTR strNamespace, BSTR strServer, IWbemClassObject **ppObject);
	HRESULT STDMETHODCALLTYPE MapPropertyToWMI(IUnknown *pXmlDOMNode, IWbemClassObject *pObject, BSTR strPropertyName, IWbemContext *pInputFlags);
	HRESULT STDMETHODCALLTYPE MapInstanceNameToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags, BSTR *pstrInstanceName);
	HRESULT STDMETHODCALLTYPE MapClassNameToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags, BSTR *pstrClassName);
	HRESULT STDMETHODCALLTYPE MapInstancePathToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags, BSTR *pstrInstancePath);
	HRESULT STDMETHODCALLTYPE MapClassPathToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags, BSTR *pstrClassPath);

	// These are functions for the encoder
public:
	 static HRESULT MapClass (
		IXMLDOMElement *pXML,
		IWbemClassObject **ppClass,
		BSTR strNamespace, BSTR strServer,
		bool bMakeInstance,
		bool bAllowWMIExtensions);
	 static HRESULT MapInstance (
		IXMLDOMElement *pXML,
		IWbemClassObject **ppClass,
		BSTR strNamespace, BSTR strServer,
		bool bAllowWMIExtensions);

private:
	// Functions for mapping properties
	static HRESULT SetDerivationAndClassName(_IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, bool bMakeInstance);
	static HRESULT CreateWMIProperties(bool bAllowWMIExtensions, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, bool bMakeInstance, BSTR *pstrServer, BSTR *pstrNamespace, IXMLDOMNode **ppAbstractQualifierNode);
	static HRESULT CreateAWMIProperty(BSTR strNodeName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, BSTR strName, bool bMakeInstance);
	static HRESULT CreateSimpleProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance);
	static HRESULT MapStringValue (LPCWSTR pszName, _IWmiFreeFormObject *pObj, BSTR bsValue, CIMTYPE cimtype, LPCWSTR pszClassOrigin, bool bMakeInstance);
	static HRESULT MapStringArrayValue (
		LPCWSTR pszName, 
		_IWmiFreeFormObject *pObj,
		IXMLDOMElement *pValueArrayNode, 
		CIMTYPE cimtype,
		LPCWSTR pszClassOrigin, 
		bool bMakeInstance);
	static HRESULT CreateArrayProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance);
	static HRESULT CreateReferenceProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance);
	static HRESULT GetSingleRefValue(IXMLDOMElement *pValueRef, BSTR *pstrValue, BOOL &bUseSysFreeString);
	static HRESULT GetSingleObject(IXMLDOMElement *pValueObject, _IWmiObject **ppEmbeddedObject);
	static HRESULT CreateRefArrayProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance);
	static HRESULT CreateObjectProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance);
	static HRESULT CreateObjectArrayProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance);
	static HRESULT GetFirstImmediateElement(IXMLDOMNode *pParent, IXMLDOMElement **ppChildElement, LPCWSTR pszName);

	static HRESULT MapInstancePath (IXMLDOMNode *pNode, LPWSTR *ppszInstancePath);
	static HRESULT MapLocalInstancePath (IXMLDOMNode *pNode, LPWSTR *ppszInstancePath);
	static HRESULT MapInstanceName (IXMLDOMNode *pNode, LPWSTR *ppszInstanceName);
	static HRESULT MapClassPath (IXMLDOMNode *pNode, LPWSTR *ppszClassPath);
	static HRESULT MapLocalClassPath (IXMLDOMNode *pNode, LPWSTR *ppszClassPath);
	static HRESULT MapClassName (IXMLDOMNode *pNode, BSTR *pstrXML);
	static HRESULT ParseNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrHost, LPWSTR *ppszLocalNamespace);
	static HRESULT ParseLocalNamespacePath(IXMLDOMNode *pLocalNamespaceNode, LPWSTR *ppszLocalNamespacePath);	
	static HRESULT ParseInstanceName(IXMLDOMNode *pNode, LPWSTR *ppszInstanceName);
	static HRESULT ParseKeyValue(IXMLDOMNode *pNode, LPWSTR *ppszValue);
	static HRESULT ParseOneKeyBinding(IXMLDOMNode *pNode, LPWSTR *ppszValue);
	static HRESULT ParseKeyBinding(IXMLDOMNode *pNode, BSTR strClassName, LPWSTR *ppszInstanceName);
	static HRESULT FormRefValueKeyBinding(LPWSTR *ppszValue, LPCWSTR pszPropertyName, LPCWSTR pszRefValue);	
	static HRESULT FixRefsAndEmbeddedObjects(IXMLDOMElement *pProperty, IWbemClassObject *pObj);
	static HRESULT FixRefOrEmbeddedProperty(IXMLDOMElement *pProperty, IWbemClassObject *pObj, bool bIsRef);
	static HRESULT FixAProperty(IWbemClassObject *pObj, BSTR strPropName, BSTR strRefClass, bool bIsRef);
	
	//Functions to map Methods
	static HRESULT CreateWMIMethods(bool bAllowWMIExtensions, IWbemClassObject *pObj, IXMLDOMElement *pMethod);
	static HRESULT CreateAWMIMethod(bool bAllowWMIExtensions, IWbemClassObject *pObj, IXMLDOMElement *pMethod);
	static HRESULT MapParameter (
		IXMLDOMNode *pParameter,
		IWbemClassObject **ppInParameters,
		IWbemClassObject **ppOutParameters,
		ULONG paramId,
		bool bIsArray);
	static bool DetermineParameterCharacteristics (
		IXMLDOMNode *pParameter, 
		bool bIsArray,
		bool &bIsInParameter,
		bool &bIsOutParameter, 
		BSTR &bsName, 
		CIMTYPE &cimtype,
		long &iArraySize,
		bool bIsReference,
		BSTR *pbsReferenceClass);
	static HRESULT MapParameterQualifiers (
		IXMLDOMNode *pParameter,
		IWbemQualifierSet *pQualSet,
		ULONG paramId,
		bool bIsArray,
		long iArraySize,
		bool bIsInParameter	);
	static HRESULT MapReferenceOrObjectParameter (
		IXMLDOMNode *pParameter,
		IWbemClassObject **ppInParameters,
		IWbemClassObject **ppOutParameters,
		ULONG paramId,
		bool bIsArray,
		bool bIsReference);

	// SOme utility functions
	static HRESULT GetBstrAttribute(IXMLDOMNode *pNode, const BSTR strAttributeName, BSTR *pstrAttributeValue);
	static LPWSTR EscapeSpecialCharacters(LPCWSTR pszInputString);
	static HRESULT CreateParametersInstance(IWbemClassObject **pParamObject);
	static HRESULT SetReferenceOrObjectClass (
		IWbemQualifierSet *pQualSet, 
		BSTR strReferenceClass,
		bool bIsReference);
	static HRESULT DecorateObject(_IWmiFreeFormObject *pObj, BSTR strServer, BSTR strNamespace);
	static HRESULT MakeObjectAbstract(IWbemClassObject *pObj, IXMLDOMNode *pAbstractQualifierNode);

	// These functions deal with mapping of Qualifiers and are in quals.cpp
	static HRESULT AddObjectQualifiers (
		bool bAllowWMIExtensions,
		IXMLDOMElement *pXml,
		IWbemClassObject *pObj);
	static HRESULT AddElementQualifiers (
		IXMLDOMNode *pXml,
		IWbemQualifierSet *pQuals);
	static HRESULT AddQualifier (
		IXMLDOMNode *pNode,
		IWbemQualifierSet *pQualSet,
		bool bIsObjectQualifier = false);
	static HRESULT MapStringQualiferValue (BSTR bsValue, VARIANT &curValue, CIMTYPE cimtype);
	static HRESULT MapStringArrayQualiferValue (
		IXMLDOMNode *pValueNode, 
		VARIANT &curValue, 
		CIMTYPE cimtype);
	static HRESULT MapStringQualiferValueIntoArray (
		BSTR bsValue, 
		SAFEARRAY *pArray, 
		long *ix, 
		VARTYPE vt,
		CIMTYPE cimtype);
	static VARTYPE VTFromCIMType (CIMTYPE cimtype);
	static CIMTYPE CimtypeFromString (BSTR bsType);

	// Some string constants
	static LPCWSTR VALUE_TAG;
	static LPCWSTR VALUEARRAY_TAG;
	static LPCWSTR VALUEREFERENCE_TAG;
	static LPCWSTR CLASS_TAG;
	static LPCWSTR INSTANCE_TAG;
	static LPCWSTR CLASSNAME_TAG;
	static LPCWSTR LOCALCLASSPATH_TAG;
	static LPCWSTR CLASSPATH_TAG;
	static LPCWSTR INSTANCENAME_TAG;
	static LPCWSTR LOCALINSTANCEPATH_TAG;
	static LPCWSTR INSTANCEPATH_TAG;
	static LPCWSTR LOCALNAMESPACEPATH_TAG;
	static LPCWSTR NAMESPACEPATH_TAG;
	static LPCWSTR KEYBINDING_TAG;
	static LPCWSTR KEYVALUE_TAG;
	static LPCWSTR QUALIFIER_TAG;
	static LPCWSTR PARAMETER_TAG;
	static LPCWSTR PARAMETERARRAY_TAG;
	static LPCWSTR PARAMETERREFERENCE_TAG;
	static LPCWSTR PARAMETERREFARRAY_TAG;
	static LPCWSTR PARAMETEROBJECT_TAG;
	static LPCWSTR PARAMETEROBJECTARRAY_TAG;
	static LPCWSTR REF_WSTR;
	static LPCWSTR OBJECT_WSTR;
	static LPCWSTR EQUALS_SIGN;
	static LPCWSTR QUOTE_SIGN;
	static LPCWSTR DOT_SIGN;
	static LPCWSTR COMMA_SIGN;
};

#endif

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlidl\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\wmi2xml.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  WMI2XML.H
//
//  rajesh  3/25/2000   Created.
//
// Contains the class definition of the component that implements the IWbemXMLConvertor
// interface
//
//***************************************************************************

#ifndef _WBEM2XML_H_
#define _WBEM2XML_H_

// Use this to protect features that rely on MSXML fixes
#define	WAITING_FOR_MSXML_FIX	0

// These macros are used to write BSTRs, special characters etc. to the IStream
#define WRITEBSTR(X)	pOutputStream->Write ((void const *)X, wcslen (X) * sizeof (OLECHAR), NULL);
#define WRITEWSTR(X)	pOutputStream->Write ((void const *)X, wcslen (X) * sizeof (OLECHAR), NULL);
#define WRITEWSTRL(X,L) pOutputStream->Write ((void const *)X, L * sizeof (OLECHAR), NULL);
#define WRITECDATASTART		WRITEBSTR(CDATASTART)
#define WRITECDATAEND		WRITEBSTR(CDATAEND)
#define WRITEAMP	        WRITEBSTR(AMPERSAND)
#define WRITELT		        WRITEBSTR(LEFTCHEVRON)
#define WRITEGT		        WRITEBSTR(RIGHTCHEVRON)

// TODO : Make sure this is disabled before release
#ifdef WMIXML_DONL	
#define WRITENEWLINE			pOutputStream->Write (XMLNEWLINE, 4, NULL);
#else
#define WRITENEWLINE
#endif



// Filter for deciding the level of naming information in the output XML
typedef enum PathLevel
{
	// No name - corresponds to CLASS|INSTANCE
	pathLevelAnonymous, 
	// namespace-relative name - Corresponds to CLASS|(INSTANCENAME, INSTANCE)
	pathLevelNamed,
	// host-relative name - Corresponds to (LOCALCLASSPATH,CLASS)|(LOCALINSTANCEPATH,INSTANCE)
	pathLevelLocal,
	// Full name with host, namespace, classname and keyvalue bindings for an instance - Corresponds to (CLASSPATH,CLASS)|(INSTANCEPATH,INSTANCE)
	pathLevelFull		
}	PathLevel;

// Filter for Qualifiers
typedef enum WmiXMLQualifierFilterEnum
{
    wmiXMLQualifierFilterNone = 0x0,
	wmiXMLQualifierFilterLocal = 0x1,
    wmiXMLQualifierFilterPropagated = 0x2,
	wmiXMLQualifierFilterAll = 0x3
} WmiXMLQualifierFilterEnum;

// Controls the amount of class origin information in the output
typedef enum WmiXMLClassOriginFilterEnum
{
    wmiXMLClassOriginFilterNone = 0x0,
	wmiXMLClassOriginFilterClass = 0x1,
	wmiXMLClassOriginFilterInstance = 0x2,
	wmiXMLClassOriginFilterAll = 0x3
} WmiXMLClassOriginFilterEnum;

//***************************************************************************
//
//  CLASS NAME:
//
//  CWmiToXml
//
//  DESCRIPTION:
//
//  Performs conversion from WMI to XML.
//
//***************************************************************************

class CWmiToXml : public IWbemXMLConvertor
{
private:

	// This is the enumeration of the names of properties that the control
	// looks for in an IWbemContext object for modifying its output
	enum
	{
		WMI_EXTENSIONS_ARG,
		PATH_LEVEL_ARG,
		QUALIFIER_FILTER_ARG,
		CLASS_ORIGIN_FILTER_ARG,
		LOCAL_ONLY_ARG,
		EXCLUDE_SYSTEM_PROPERTIES_ARG
	};
	static const LPCWSTR s_wmiToXmlArgs[];

	
	long					m_cRef; // COM Ref count

	// Flags that modify the output
	// These are filled up from the IWbemContext object
	// that is passed for most function calls
	PathLevel						m_iPathLevel;
	VARIANT_BOOL					m_bAllowWMIExtensions;
	WmiXMLQualifierFilterEnum		m_iQualifierFilter;
	WmiXMLClassOriginFilterEnum		m_iClassOriginFilter;
	VARIANT_BOOL					m_bLocalOnly;
	VARIANT_BOOL					m_bExcludeSystemProperties;

	BOOL				PropertyDefinedForClass (IWbemClassObject *pObject, BSTR bsPropertyName, BSTR strClassBasis);

	STDMETHODIMP		MapClass (IStream *pOutputStream, IWbemClassObject *pObject, IWbemQualifierSet *pQualSet, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis);
	STDMETHODIMP		MapClassName (IStream *pOutputStream, BSTR bsClassName);
	STDMETHODIMP		MapClassPath (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapLocalClassPath (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapInstance (IStream *pOutputStream, IWbemClassObject *pObject, IWbemQualifierSet *pQualSet, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis);
	STDMETHODIMP		MapInstancePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapLocalInstancePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapInstanceName (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapNamespacePath (IStream *pOutputStream, BSTR bsNamespacePath);
	STDMETHODIMP		MapNamespacePath (IStream *pOutputStream, ParsedObjectPath *pObjectPath);
	STDMETHODIMP		MapLocalNamespacePath (IStream *pOutputStream, BSTR bsNamespacePath);
	STDMETHODIMP		MapLocalNamespacePath (IStream *pOutputStream, ParsedObjectPath *pObjectPath);
	STDMETHODIMP		MapQualifiers (IStream *pOutputStream, IWbemQualifierSet *pQualSet, IWbemQualifierSet *pQualSet2 = NULL);
	STDMETHODIMP		MapQualifier (IStream *pOutputStream, BSTR name, long flavor, VARIANT &var);
	STDMETHODIMP		MapProperties (IStream *pOutputStream, IWbemClassObject *pObject, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis, bool bIsClass);
	STDMETHODIMP		MapProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, CIMTYPE cimtype,
										BOOL isArray, long flavor, bool bIsClass);
	STDMETHODIMP		MapObjectProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, BOOL isArray, long flavor, bool bIsClass);
	STDMETHODIMP		MapReferenceProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, bool isArray, long flavor, bool bIsClass);
	void				MapArraySize (IStream *pOutputStream, IWbemQualifierSet *pQualSet);
	STDMETHODIMP		MapMethods (IStream *pOutputStream, IWbemClassObject *pObject);
	void				MapMethod (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, IWbemClassObject *pInParams, IWbemClassObject *pOutParams);
	void				MapParameter (IStream *pOutputStream, BSTR paramName, IWbemQualifierSet *pQualSet, 
								CIMTYPE cimtype, IWbemQualifierSet *pQualSet2 = NULL);
	void				MapReturnParameter(IStream *pOutputStream, BSTR strParameterName, VARIANT &variant);

	STDMETHODIMP		MapType (IStream *pOutputStream, CIMTYPE cimtype);
	STDMETHODIMP		MapValue (IStream *pOutputStream, VARIANT &var);
	STDMETHODIMP		MapValue (IStream *pOutputStream, CIMTYPE cimtype, BOOL isArray, VARIANT &var);
	STDMETHODIMP		MapEmbeddedObjectValue (IStream *pOutputStream, BOOL isArray, VARIANT &var);
	STDMETHODIMP		MapKeyValue (IStream *pOutputStream, VARIANT &var);
	void				MapStrongType (IStream *pOutputStream, IWbemQualifierSet *pQualSet);
	void				MapLocal (IStream *pOutputStream, long flavor);
	void				MapClassOrigin (IStream *pOutputStream, BSTR &classOrigin, bool bIsClass);
	STDMETHODIMP		MapMethodReturnType(IStream *pOutputStream, VARIANT *pValue, CIMTYPE returnCimType, IWbemClassObject *pOutputParams);

	// Primitive functions to map individual values
	void				MapLongValue (IStream *pOutputStream, long val);
	void				MapShortValue (IStream *pOutputStream, short val);
	void				MapDoubleValue (IStream *pOutputStream, double val);
	void				MapFloatValue (IStream *pOutputStream, float val);
	void				MapBoolValue (IStream *pOutputStream, BOOL val);
	void				MapByteValue (IStream *pOutputStream, unsigned char val);
	void				MapCharValue (IStream *pOutputStream, long val);
	void				MapStringValue (IStream *pOutputStream, BSTR &val);
	STDMETHODIMP		MapReferenceValue (IStream *pOutputStream, bool isArray, VARIANT &var);
	void				MapReferenceValue (IStream *pOutputStream, ParsedObjectPath *pObjectPath, BSTR strPath);

	bool IsReference (VARIANT &var, ParsedObjectPath **ppObjectPath);
	void GetFlagsFromContext(IWbemContext  *pInputFlags);

public:

	CWmiToXml();
    virtual ~CWmiToXml();

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


	// Functions of the IWbemXMLConvertor interface
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapObjectToXML( 
        /* [in] */ IWbemClassObject  *pObject,
		/* [in] */ BSTR *ppPropertyList, DWORD dwNumProperties,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream,
		/* [in[ */ BSTR strClassBasis);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPropertyToXML( 
        /* [in] */ IWbemClassObject  *pObject,
		/* [in] */ BSTR strPropertyName,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapInstanceNameToXML( 
        /* [in] */ BSTR  strInstanceName,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapClassNameToXML( 
        /* [in] */ BSTR  strClassName,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapInstancePathToXML( 
        /* [in] */ BSTR  strInstancePath,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapClassPathToXML( 
        /* [in] */ BSTR  strClassPath,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapMethodResultToXML( 
        /* [in] */ IWbemClassObject  *pMethodResult,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmiisapi\cim2xml.h ===
#ifndef CIM2XML
#define CIM2XML

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the CIM2XML_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// CIM2XML_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef CIM2XML_EXPORTS
#define CIM2XML_API __declspec(dllexport)
#else
#define CIM2XML_API __declspec(dllimport)
#endif

// A table of protocol handlers
typedef CMap <BSTR, BSTR, IWbemXMLOperationsHandler *, IWbemXMLOperationsHandler *> CProtocolHandlersMap;
UINT AFXAPI HashKey(BSTR key);
BOOL AFXAPI CompareElements(const BSTR* pElement1, const BSTR* pElement2);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmiisapi\cim2xml.cpp ===
//
// Create 2/25/2000 : rajeshr
// cim2xml.cpp : Defines the entry point for the ISAPI Extension DLL 
//

#include <windows.h>
#include <httpext.h>
#include <mshtml.h>
#include <msxml.h>

#include <objbase.h>
#include <initguid.h>

#include "provtempl.h"
#include "wmixmlop.h"
#include "cim2xml.h"


// Wrap up the XML String into a Stream and put it in VARIANT
static HRESULT EncodeRequestIntoStream(LPEXTENSION_CONTROL_BLOCK pECB, VARIANT *pVariant);

// This function processes an HTTP Operation
// If the HTTP verb is OPTIONS, then the pDocument argument can be NULL, since it is unused
static void HandleOperation(LPEXTENSION_CONTROL_BLOCK pECB, IXMLDOMDocument *pDocument);

static CProtocolHandlersMap g_protocolHandlerMap;

static HRESULT GetProtocolVersion(LPEXTENSION_CONTROL_BLOCK pECB, BSTR *pstrVersion);
static HRESULT GetProtocolHandler(BSTR strVersion, IWbemXMLOperationsHandler *&pProtocolHandler);
static HRESULT UnloadProtocolHandlers();
static HRESULT LoadProtocolHandlers();

static BOOLEAN CheckManHeader (
	const char *pszReceivedManHeader,
	const char *pszRequiredManHeader,
	DWORD &dwNs);
static LPSTR GetExtensionHeader (char *pszName, BOOLEAN bIsMpostRequest, DWORD dwNs);
static LPCSTR HTTP_MAN_HEADER = "http://www.dmtf.org/cim/mapping/http/v1.0";
static LPCSTR MICROSOFT_MAN_HEADER = "http://www.microsoft.com/wmi";
static LPCSTR HTTP_NS = "ns=";

// Globals
static BSTR WMI_XML_PROTOCOL_VERSION = NULL;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  
//
//  PARAMETERS:
//
//		hModule           instance handle
//		ulReason          why we are being called
//		pvReserved        reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************
BOOL WINAPI DllMain( HINSTANCE hModule, 
                       DWORD  ulReason, 
                       LPVOID lpReserved
					 )
{
    switch (ulReason)
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls (hModule);
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;

		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}

//***************************************************************************
//
//  BOOL WINAPI GetExtensionVersion
//
//  DESCRIPTION:
//
//  Called once by IIS to get version information.  Of little consequence.
//
//  PARAMETERS:
//
//		pVer			pointer to a HSE_VERSION_INFO structure that
//						will hold the version info.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pVer)
{
	// Initialize the COM Library as multi-threaded
	if (FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))		
		return FALSE;

	if(FAILED(LoadProtocolHandlers()))
		return FALSE;

	if(!(WMI_XML_PROTOCOL_VERSION = SysAllocString(L"1.0")))
		return FALSE;

    pVer->dwExtensionVersion = MAKELONG(1, 0);
    strcpy(pVer->lpszExtensionDesc, "WMI XML/HTTP ISAPI Extension"); 
	return TRUE;
}

//***************************************************************************
//
//  BOOL WINAPI HttpExtensionProc
//
//  DESCRIPTION:
//
//  Called once by IIS to service a single HTTP request.
//
//  PARAMETERS:
//
//		pECB			pointer to a EXTENSION_CONTROL_BLOCK structure that
//						will hold the request.
//
//  RETURN VALUE:
//
//		HSE_STATUS_SUCCESS	request has been processed
//
//	NOTES:
//		
//		Status codes are set in the dwHttpStatusCode field of the ECB
//
//***************************************************************************
DWORD WINAPI HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pECB)
{
	// RAJESHR - The below 2 lines are debugging code that need to be removed 
	TCHAR szUserName[500];
	DWORD dwUserLength = 500;
	GetUserName(szUserName, &dwUserLength);

	// If the method is OPTIONS, then we dont check the body of the request
	if (0 == _stricmp(pECB->lpszMethod, "OPTIONS"))
	{
		HandleOperation(pECB, NULL);
	}
	else
	{
		// Create an XML document for the body of the request
		//==============================
		IXMLDOMDocument *pDocument = NULL;
		if(SUCCEEDED(CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
									IID_IXMLDOMDocument, (LPVOID *)&pDocument)))
		{
			VARIANT_BOOL bResult = VARIANT_TRUE;

			// Put the XML String in an IStream and wrap it up in a VARIANT
			//=============================================================
			VARIANT xmlVariant;
			VariantInit (&xmlVariant);

			if(SUCCEEDED(EncodeRequestIntoStream(pECB, &xmlVariant)))
			{
				if(SUCCEEDED(pDocument->put_async(VARIANT_FALSE)) &&
					SUCCEEDED(pDocument->put_resolveExternals(VARIANT_FALSE)) &&
					SUCCEEDED(pDocument->put_validateOnParse(VARIANT_FALSE)))
				{
					if(SUCCEEDED(pDocument->load(xmlVariant, &bResult)))
					{
						if(bResult == VARIANT_TRUE)
						{
							HandleOperation(pECB, pDocument);
						}
						else
						{
							// Return a "400 - Bad Request" 
							HSE_SEND_HEADER_EX_INFO sendHeader;
							sendHeader.pszHeader = "CIMError: request-not-valid";
							sendHeader.cchHeader = strlen(sendHeader.pszHeader);
							sendHeader.fKeepConn = FALSE;
							sendHeader.pszStatus = "400 - Bad Request";
							sendHeader.cchStatus = strlen (sendHeader.pszStatus);
							pECB->ServerSupportFunction (pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER_EX,
															&sendHeader, 0, 0);

							IXMLDOMParseError *pError = NULL;
							if(SUCCEEDED(pDocument->get_parseError(&pError)))
							{
								LONG errorCode = 0;
								pError->get_errorCode(&errorCode);
								LONG line=0, linepos=0;
								BSTR reason=NULL, srcText = NULL;
								if(SUCCEEDED(pError->get_line(&line)) &&
									SUCCEEDED(pError->get_linepos(&linepos)) &&
									SUCCEEDED(pError->get_reason(&reason)) &&
									SUCCEEDED(pError->get_srcText(&srcText)))
								{
								}
								pError->Release();
								if(reason)
									SysFreeString(reason);
								if(srcText)
									SysFreeString(srcText);
							}
						}
					}
				}

				VariantClear (&xmlVariant);
			}
			
			pDocument->Release();
		}
	}

	return HSE_STATUS_SUCCESS;
}
	
//***************************************************************************
//
//  BOOL WINAPI TerminateExtension
//
//  DESCRIPTION:
//
//		Called once by IIS to unload the extension.
//
//  PARAMETERS:
//
//		dwFlags		determines nature of request (advisory or mandatory) 
//
//  RETURN VALUE:
//
//		TRUE (always agree to an unload for now)
//
//***************************************************************************
BOOL WINAPI TerminateExtension(DWORD dwFlags  )
{
	SysFreeString(WMI_XML_PROTOCOL_VERSION);

	// Unload all the protocol handlers that we have in out table
	UnloadProtocolHandlers();

	// We need to unload the COM DLLs that we loaded in this extension
	CoFreeUnusedLibraries();
	CoUninitialize();
	return TRUE;
}

//***************************************************************************
//
//  BOOL EncodeRequestIntoStream
//
//  Description: 
//
//		Takes an XML document in byte format and encodes it within an
//		IStream.
//
//  Parameters:
//
//		pECB		Pointer to the extension control block
//		pVariant	Pointer to hold wrapped XML document on return. This needs to 
//					cleared by the client
//
//	Return Value:
//
//		TRUE if successful, FALSE otherwise
//
//***************************************************************************

HRESULT EncodeRequestIntoStream(LPEXTENSION_CONTROL_BLOCK pECB, VARIANT *pVariant)
{
	HRESULT result = E_FAIL;
	IStream *pStream = NULL;

	if (SUCCEEDED(result = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
	{
#if 0
		FILE *f = fopen ("c:\\temp\\xmllog.xml", "a");
		fprintf (f, "%s", pszXmlString);
		fflush (f);
#endif
		// Not all of the request may be present in the ECB; need to
		// keep reading from the input stream

		if(SUCCEEDED(result = pStream->Write(pECB->lpbData, pECB->cbAvailable, NULL)))
		{
			DWORD cbDataRead = pECB->cbAvailable;
			
			// Is there more data than was in the ECB?
			if (cbDataRead < pECB->cbTotalBytes)
			{
#define XML_BUFSIZ	1024
				DWORD dwBufSiz = XML_BUFSIZ;
				BYTE  pDataBuffer[XML_BUFSIZ];
			
				while ((cbDataRead < pECB->cbTotalBytes) &&
					   pECB->ReadClient (pECB->ConnID, (LPVOID) pDataBuffer, &dwBufSiz) &&
					   (0 < dwBufSiz))
				{
					if (FAILED(result = pStream->Write ((LPVOID) pDataBuffer, dwBufSiz, NULL)))
						break;

					cbDataRead += dwBufSiz;
					dwBufSiz = XML_BUFSIZ;
				}
#undef XML_BUFSIZ
			}
		}

		if (SUCCEEDED (result))
		{
			LARGE_INTEGER	offset;
			offset.LowPart = offset.HighPart = 0;
			pStream->Seek (offset, STREAM_SEEK_SET, NULL);
			VariantInit(pVariant);
			pVariant->vt = VT_UNKNOWN;
			pVariant->punkVal = pStream;
		}
		else
			pStream->Release ();
	}

	return result;
}

/* 
 * This function processes an HTTP Operation
 * If the HTTP verb is OPTIONS, then the pDocument argument can be NULL, since it is unused
 * No Status is returned, since any CIM error goes back in the body of the response, and
 * any HTTP Header error is communicated to IIS thry the pECB argument
 */
void HandleOperation(LPEXTENSION_CONTROL_BLOCK pECB, IXMLDOMDocument *pDocument)
{
	// We first look at the 
	// If this is an OPTIONs request, then pDocument will be NULL
	// We always return the 
	// Create a protocol handler based on the CIMPROTOCOL version# and call ProcessHTTPRequest() on it.
	// Peek into the XML Document to get the version# of the protocol
	// Then we use the version# to get the CLSID of the protocol handler
	BSTR strVersion = NULL;
	bool bAssumeDefaultVersion = false;
	if(FAILED(GetProtocolVersion(pECB, &strVersion)))
		bAssumeDefaultVersion = true;

	IWbemXMLOperationsHandler *pProtocolHandler = NULL;
	if(SUCCEEDED(GetProtocolHandler((bAssumeDefaultVersion)? WMI_XML_PROTOCOL_VERSION : strVersion, pProtocolHandler)))
	{
		pProtocolHandler->ProcessHTTPRequest(pECB, pDocument);
		// No need to Release() it since the CMap::Lookup() does not addref it,
		// and we keep it for the duration of our ISAPI extension
		// pProtocolHandler->Release();
	}
	else
	{
		// Return a "501 - Not implemented" - RAJESHR include the CIMError header here as per the spec above
		HSE_SEND_HEADER_EX_INFO sendHeader;
		sendHeader.pszHeader = "CIMError: unsupported-protocol-version";
		sendHeader.cchHeader = strlen(sendHeader.pszHeader);
		sendHeader.fKeepConn = FALSE;
		sendHeader.pszStatus = "501 Not Implemented";
		sendHeader.cchStatus = strlen (sendHeader.pszStatus);
		pECB->ServerSupportFunction (pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER_EX,
										&sendHeader, 0, 0);
	}
	SysFreeString(strVersion);
}


static HRESULT GetProtocolVersion(LPEXTENSION_CONTROL_BLOCK pECB, BSTR *pstrVersion)
{
	// We first check to see if there is a a MicrosoftWMIProtocolVersion header
	// Then, we check for the CIMProtocolVersionHeader
	// Lastly, we assume 1.0 as the version
	// ===============================================

	// Start by getting the Man Header in case of an M-POST request
	bool bIsMpost = false;
	CHAR szTempBuffer [1024];
	DWORD dwBufferSize = 1024;
	if (0 == _stricmp(pECB->lpszMethod, "M-POST"))
		bIsMpost = true;

	DWORD dwMicrosoftNs = 0;
	DWORD dwDMTFNs = 0;
	// Get the namespace identifiers for DMTF and Microsoft namespaces
	if(bIsMpost)
	{
		dwBufferSize = 1024;
		if (pECB->GetServerVariable (pECB->ConnID, "HTTP_MAN", szTempBuffer, &dwBufferSize))
		{
			// Get the Microsoft Man header number
			CheckManHeader(szTempBuffer, MICROSOFT_MAN_HEADER, dwMicrosoftNs);
			CheckManHeader(szTempBuffer, HTTP_MAN_HEADER, dwDMTFNs);
		}
	}

	// Get the MicorosoftWMIProtocolVersion header
	dwBufferSize = 1024;
	LPSTR pCIMHeader = GetExtensionHeader ("MicorosoftWMIProtocolVersion", bIsMpost, dwMicrosoftNs);
	if (pCIMHeader && pECB->GetServerVariable (pECB->ConnID, pCIMHeader, szTempBuffer, &dwBufferSize) && szTempBuffer)
	{
		WCHAR wTemp[24];
		int len = 0;
		if(len = MultiByteToWideChar(CP_ACP, 0, szTempBuffer, strlen(szTempBuffer), wTemp, 24))
		{
			*pstrVersion = SysAllocStringLen(wTemp, len);
			return S_OK;
		}
	}
	delete pCIMHeader;

	// Get the CIMProtocolVersion header
	dwBufferSize = 1024;
	pCIMHeader = NULL;
	pCIMHeader = GetExtensionHeader ("CIMProtocolVersion", bIsMpost, dwDMTFNs);
	if (pCIMHeader && pECB->GetServerVariable (pECB->ConnID, pCIMHeader, szTempBuffer, &dwBufferSize) && szTempBuffer)
	{
		WCHAR wTemp[24];
		int len = 0;
		if(len = MultiByteToWideChar(CP_ACP, 0, szTempBuffer, strlen(szTempBuffer), wTemp, 24))
		{
			*pstrVersion = SysAllocStringLen(wTemp, len);
			return S_OK;
		}
	}
	delete pCIMHeader;


	return E_FAIL;
}

// A Macro to skip white spaces - useful in header parsing
#define SKIPWS(x)	while (x && isspace (*x)) x++;

static BOOLEAN CheckManHeader (
	const char *pszReceivedManHeader,
	const char *pszRequiredManHeader,
	DWORD &dwNs
)
{
	BOOLEAN result = FALSE;

	LPCSTR ptr = NULL;

	// Get the location of the Man header in the string
	if (ptr = strstr(pszReceivedManHeader, pszRequiredManHeader))
	{
		// Look for the "; ns=XX" string
		SKIPWS(ptr)

		if (ptr && (ptr = strchr (ptr, ';')) && *(++ptr))
		{
			SKIPWS(ptr)

			if (ptr && (0 == _strnicmp (ptr, HTTP_NS, strlen (HTTP_NS))))
			{
				// Now we should find ourselves a NS value
				ptr += strlen (HTTP_NS);

				if (ptr)
				{
					dwNs = strtol (ptr, NULL, 0);
					result = TRUE;
				}
			}
		}
	}

	return result;
}

static LPSTR GetExtensionHeader (char *pszName, BOOLEAN bIsMpostRequest, DWORD dwNs)
{
	LPSTR pszHeader = NULL;
	if (bIsMpostRequest)
	{
		if(pszHeader = new char [strlen("HTTP") + strlen(pszName) + 4])
			sprintf (pszHeader, "%s_%02d_%s", "HTTP", dwNs, pszName);
	}
	else
	{
		if(pszHeader = new char [strlen("HTTP") + strlen (pszName) + 2])
			sprintf (pszHeader, "%s_%s", "HTTP", pszName);
	}
	return pszHeader;
}

static HRESULT GetProtocolHandler(BSTR strVersion, IWbemXMLOperationsHandler *&pProtocolHandler)
{
	if(g_protocolHandlerMap.Lookup(strVersion, pProtocolHandler))
		return S_OK;
	return E_FAIL;
}

static HRESULT LoadProtocolHandlers()
{
	// Go thru the registry key looking for protocol handlers
	HKEY hHandlers = NULL;
	if(RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\Microsoft\\WBEM\\xml\\ProtocolHandlers"), &hHandlers) == ERROR_SUCCESS)
	{
		DWORD dwIndex = 0;
		WCHAR pszValueName[24];
		DWORD dwValueNameLen = 24;
		WCHAR pszValue[128];
		DWORD dwValueLen = 128*2;

		while(RegEnumValue(hHandlers, dwIndex, pszValueName, &dwValueNameLen, NULL, NULL, (LPBYTE)pszValue, &dwValueLen) == ERROR_SUCCESS)
		{
			BSTR strValueName = NULL;
			if(strValueName = SysAllocString(pszValueName))
			{
				GUID oNextGUID;
				if(UuidFromString(pszValue, (UUID *)(&oNextGUID)) == RPC_S_OK)
				{
					IWbemXMLOperationsHandler *pNextHandler = NULL;
					if(SUCCEEDED(CoCreateInstance(oNextGUID, 
						0, 
						CLSCTX_INPROC_SERVER,
						IID_IWbemXMLOperationsHandler, (LPVOID *) &pNextHandler)))
					{
						// Add it to our table
						g_protocolHandlerMap.SetAt(strValueName, pNextHandler);

					}
				}
			}
			dwIndex ++;
		}
		RegCloseKey(hHandlers);
	}

	// We always succeed
	return S_OK;
}

static HRESULT UnloadProtocolHandlers()
{
	// Go thru our table and release the key and values of the handlers
	POSITION p = g_protocolHandlerMap.GetStartPosition();
	while(p)
	{
		BSTR strKey = NULL;
		IWbemXMLOperationsHandler *pNextHandler = NULL;
		g_protocolHandlerMap.GetNextAssoc(p, strKey, pNextHandler);
		SysFreeString(strKey);
		pNextHandler->Release();

	}
	return S_OK;
}

// A hashing function for a BSTR
UINT AFXAPI HashKey(BSTR key)
{
	UINT nHash = 0;
	while (*key)
		nHash = (nHash<<5) + nHash + *key++;
	return nHash;
}

BOOL AFXAPI CompareElements(const BSTR* pElement1, const BSTR* pElement2)
{
	return ! _wcsicmp(*pElement1, *pElement2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmifilt\wmifilt.cpp ===
//***************************************************************************
// Created 2/5/2000: rajeshr
// wmifilt.cpp : This is the main file for the WMI ISAPI Filter 
// The purpose of this filter is to map URLs of the requests coming to the URI
// "/cimom" to the actual path to the ISAPI Extension "/cimhttp/wmiisapi.dll"
//***************************************************************************

#include <windows.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <httpfilt.h>

//
// Forward Declarations
//
// This function is used to do the mapping of the URI described above
static DWORD OnPreprocHeaders (PHTTP_FILTER_CONTEXT pFC, 
							   PHTTP_FILTER_PREPROC_HEADERS pHeaderInfo);
// This function handles OPTIONS request coming to the '*' URI
static void SendOptionResponse (PHTTP_FILTER_CONTEXT pFC);

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  
//
//  PARAMETERS:
//
//		hModule           instance handle
//		ulReason          why we are being called
//		pvReserved        reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************
BOOL WINAPI DllMain( HINSTANCE hModule, 
                       DWORD  ulReason, 
                       LPVOID lpReserved
					 )
{
    switch (ulReason)
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls (hModule);
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;

		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}

//***************************************************************************
//
//  BOOL WINAPI GetFilterVersion
//
//  DESCRIPTION:
//
//  Called once by IIS to get version information.  
//
//  PARAMETERS:
//
//		pVer			pointer to a HSE_FILTER_VERSION structure that
//						will hold the version info.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI GetFilterVersion(HTTP_FILTER_VERSION *pVer)
{
    pVer->dwFilterVersion = MAKELONG(1, 0);
    strcpy(pVer->lpszFilterDesc, "WMI XML/HTTP ISAPI Filter"); 
	
	/*
	 * We intercept SF_NOTIFY_PREPROC_HEADERS to ensure
	 * 1. we add our CIM response headers to an OPTIONS response
	 * 2. to munge the URL from cimom to cimhttp/cim2xml.dll.
	 */
	pVer->dwFlags = SF_NOTIFY_PREPROC_HEADERS;

	// Generate a pseudo-random number with the current time as seed
	// For use later
	srand( (unsigned) time (NULL) );

	return TRUE;
}

//***************************************************************************
//
//  BOOL WINAPI HttpFilterProc
//
//  DESCRIPTION:
//
//  Called once by IIS to notify this filter of interesting conditions.
//
//  PARAMETERS:
//
//		pFC					pointer to a HTTP_FILTER_CONTEXT structure
//		dwNotificationType	what sort of notification this is
//		pvData				more notification-specific data
//
//  RETURN VALUE:
//
//		HSE_STATUS_SUCCESS	request has been processed
//
//	NOTES:
//		
//		Status codes are set in the dwHttpStatusCode field of the ECB
//
//***************************************************************************
DWORD WINAPI HttpFilterProc(
	PHTTP_FILTER_CONTEXT pFC,
	DWORD dwNotificationType,
	LPVOID pvData)
{
	DWORD dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;

	if (SF_NOTIFY_PREPROC_HEADERS == dwNotificationType)
		dwRet = OnPreprocHeaders (pFC, (PHTTP_FILTER_PREPROC_HEADERS) pvData);

	return dwRet;
}

//***************************************************************************
//
//  DWORD OnPreprocHeaders
//
//  DESCRIPTION:
//
//		Handler for SF_NOTIFY_PREPROC_HEADERS events
//
//  PARAMETERS:
//
//		pFC					pointer to a HTTP_FILTER_CONTEXT structure
//		pHeaderInfo			pointer to a HTTP_FILTER_PREPROC_HEADERS structure
//
//  RETURN VALUE:
//
//		SF_STATUS_REQ_NEXT_NOTIFICATION	request has been processed
//
//***************************************************************************

DWORD OnPreprocHeaders (
	PHTTP_FILTER_CONTEXT pFC, 
	PHTTP_FILTER_PREPROC_HEADERS pHeaderInfo)
{
	DWORD dwStringLength = 1024;
	char lpszUrlString [1024];

	if(pHeaderInfo->GetHeader(pFC, "url", lpszUrlString, &dwStringLength))
	{
		// Check to see if it is "/cimom", if so we need to modify it to the physical path
		//********************************************************************************
		if (0 == _stricmp(lpszUrlString, "/cimom")) 
		{
			// Modify the URL
			pHeaderInfo->SetHeader(pFC, "url", "/cimhttp/wmiisapi.dll");
		}
		// Check if it is "*" and the method is OPTIONS - if so we need to send an OPTIONS response
		//******************************************************************************************
		else if (0 == _stricmp(lpszUrlString, "/*"))
		{
			// See it the method is OPTIONS
			dwStringLength = 1024;
			char lpszMethodString [1024];
			if(pHeaderInfo->GetHeader(pFC, "method", lpszMethodString, &dwStringLength))
			{
				if(0 == _stricmp(lpszMethodString, "OPTIONS"))
				{
					SendOptionResponse(pFC);
				}
			}
		}
	}
	
	return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


void SendOptionResponse (PHTTP_FILTER_CONTEXT pFC)
{

	// Generate a random number
	// Make sure result is in the range 0 to 99
	int i = (100 * rand () / RAND_MAX);
	if (100 == i)
		i--;

	DWORD dwHeaderSize = 1024;
	char szTempBuffer [1024];

	char szOpt [10];
	sprintf (szOpt, "%02d", i);

	// Add the Opt header
	sprintf (szTempBuffer, "Opt: http://www.dmtf.org/cim/mapping/http/v1.0 ; ns=");
	strcat (szTempBuffer, szOpt);
	strcat (szTempBuffer, "\r\n");
	pFC->AddResponseHeaders(pFC, szTempBuffer, 0);


	// Add the CIMOM header
	strcpy (szTempBuffer, szOpt);
	strcat (szTempBuffer, "-CIMOM: /cimhttp/cim2xml.dll\r\n");
	pFC->AddResponseHeaders(pFC, szTempBuffer, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\cimerr.h ===
#ifndef CIM_ERRORS
#define CIM_ERRORS

typedef enum
{
		CIM_NO_ERROR = 0,
		CIM_ERR_FAILED,
		CIM_ERR_ACCESS_DENIED,
		CIM_ERR_INVALID_NAMESPACE,
		CIM_ERR_INVALID_PARAMETER,
		CIM_ERR_INVALID_CLASS,
		CIM_ERR_NOT_FOUND,
		CIM_ERR_NOT_SUPPORTED,
		CIM_ERR_CLASS_HAS_CHILDREN,
		CIM_ERR_CLASS_HAS_INSTANCES,
		CIM_ERR_INVALID_SUPERCLASS,
		CIM_ERR_ALREADY_EXISTS,
		CIM_ERR_NO_SUCH_PROPERTY,
		CIM_ERRTYPE_MISMATCH,
		CIM_ERR_QUERY_LANGUAGE_NOT_SUPPORTED,
		CIM_ERR_INVALID_QUERY

} CIM_ERRORS;

extern LPCWSTR cimErrorStrings[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\classfac.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CLASSFAC.H
//
//  rajesh  3/25/2000   Created.
//
//  Class factory interface.
//
//***************************************************************************

#ifndef _WMIXMLOP_CLASSFAC_H_
#define _WMIXMLOP_CLASSFAC_H_


// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;
extern CRITICAL_SECTION g_StaticsCreationDeletion;

//***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTFactory
//
//  DESCRIPTION:
//
//  Class factory for the CLocator class.
//
//***************************************************************************

class CWmiXmlOpFactory : public IClassFactory
{
protected:
	long           m_cRef;

public:

    CWmiXmlOpFactory(void);
    ~CWmiXmlOpFactory(void);
    
    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\classfac.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  XMLTOWMI.CPP
//
//  rajesh  3/25/2000   Created.
//
//
//  Contains the class factory that creates implementation of the 
//	WMI XML Protocol Handler
//
//***************************************************************************
#include <windows.h>
#include <stdio.h>
#include <objbase.h>

#include <httpext.h>
#include <wbemidl.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "maindll.h"
#include "strings.h"
#include "classfac.h"
#include "wmixmlop.h"
#include "cwmixmlop.h"

static HRESULT InitializeWmixmlopDLLResources();

//***************************************************************************
//
// CWmiXmlOpFactory::CWmiXmlOpFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWmiXmlOpFactory::CWmiXmlOpFactory()
{
    m_cRef=0L;
    InterlockedIncrement(&g_cObj);
	return;
}

//***************************************************************************
//
// CWmiXmlOpFactory::~CWmiXmlOpFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWmiXmlOpFactory::~CWmiXmlOpFactory(void)
{
    InterlockedDecrement(&g_cObj);
	return;
}

//***************************************************************************
//
// CWmiXmlOpFactory::QueryInterface
// CWmiXmlOpFactory::AddRef
// CWmiXmlOpFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CWmiXmlOpFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiXmlOpFactory::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CWmiXmlOpFactory::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CWmiXmlOpFactory::CreateInstance
//
//  Description:
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CWmiXmlOpFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid,
    OUT LPVOID *ppvObj
)
{
    IUnknown *   pObj  = NULL;
    HRESULT      hr = E_FAIL;

    *ppvObj=NULL;

    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);


	// Check to see if the static members have been initialized
	if(SUCCEEDED(hr = InitializeWmixmlopDLLResources()))
	{
		// Now create an instance of the component
		pObj = new CWmiXmlOpHandler;

		if (NULL == pObj)
			return ResultFromScode(E_OUTOFMEMORY);;

		hr = pObj->QueryInterface(riid, ppvObj);

	}

    //Kill the object if initial creation or Init failed.
    if ( FAILED(hr) )
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CWmiXmlOpFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
//
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CWmiXmlOpFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}



static HRESULT InitializeWmixmlopDLLResources()
{
	HRESULT hr = E_FAIL;
	EnterCriticalSection(&g_StaticsCreationDeletion);
	if(!ARRAYSIZE_ATTRIBUTE)
	{
		// Various Attributes we need
		ARRAYSIZE_ATTRIBUTE			= SysAllocString(L"ARRAYSIZE");
		CIMVERSION_ATTRIBUTE		= SysAllocString(L"CIMVERSION");
		CLASS_NAME_ATTRIBUTE		= SysAllocString(L"CLASSNAME");
		CLASS_ORIGIN_ATTRIBUTE		= SysAllocString(L"CLASSORIGIN");
		DTDVERSION_ATTRIBUTE		= SysAllocString(L"DTDVERSION");
		ID_ATTRIBUTE				= SysAllocString(L"ID");
		NAME_ATTRIBUTE				= SysAllocString(L"NAME");
		PROTOVERSION_ATTRIBUTE		= SysAllocString(L"PROTOCOLVERSION");
		VALUE_TYPE_ATTRIBUTE		= SysAllocString(L"VALUETYPE");
		SUPERCLASS_ATTRIBUTE		= SysAllocString(L"SUPERCLASS");
		TYPE_ATTRIBUTE				= SysAllocString(L"TYPE");
		OVERRIDABLE_ATTRIBUTE		= SysAllocString(L"OVERRIDABLE");
		TOSUBCLASS_ATTRIBUTE		= SysAllocString(L"TOSUBCLASS");
		TOINSTANCE_ATTRIBUTE		= SysAllocString(L"TOINSTANCE");
		AMENDED_ATTRIBUTE			= SysAllocString(L"AMENDED");
		REFERENCECLASS_ATTRIBUTE	= SysAllocString(L"REFERENCECLASS");
		VTTYPE_ATTRIBUTE			= SysAllocString(L"VTTYPE");
		WMI_ATTRIBUTE				= SysAllocString(L"WMI");


		if(ARRAYSIZE_ATTRIBUTE &&
			CIMVERSION_ATTRIBUTE &&
			CLASS_NAME_ATTRIBUTE &&
			CLASS_ORIGIN_ATTRIBUTE &&
			DTDVERSION_ATTRIBUTE &&
			ID_ATTRIBUTE &&
			NAME_ATTRIBUTE &&
			PROTOVERSION_ATTRIBUTE &&
			VALUE_TYPE_ATTRIBUTE &&
			SUPERCLASS_ATTRIBUTE &&
			TYPE_ATTRIBUTE &&
			OVERRIDABLE_ATTRIBUTE &&
			TOSUBCLASS_ATTRIBUTE &&
			TOINSTANCE_ATTRIBUTE &&
			AMENDED_ATTRIBUTE &&
			REFERENCECLASS_ATTRIBUTE &&
			VTTYPE_ATTRIBUTE &&
			WMI_ATTRIBUTE )
			hr = S_OK;
		else
		{
			UninitializeWmixmlopDLLResources();
			hr = E_OUTOFMEMORY;
		}
	}
	LeaveCriticalSection(&g_StaticsCreationDeletion);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\cimerr.cpp ===
#include <windows.h>

LPCWSTR cimErrorStrings[] = 
{
	L"CIM2XML: The operation was successful",
	L"CIM2XML: An unknown error occured",
	L"CIM2XML: Access is denied",
	L"CIM2XML: Target Namespace does not exist",
	L"CIM2XML: One or more parameters passed to the method are not valid",
	L"CIM2XML: The specified class does not exist",
	L"CIM2XML: The requested object could not be found",
	L"CIM2XML: The requested operation is not supported",
	L"CIM2XML: Operation cannot be carried out on this class since it has subclasses",
	L"CIM2XML: Operation cannot be carried out on this class since it has instances",
	L"CIM2XML: Operation cannot be carried out since the specified superclass does not exist",
	L"CIM2XML: Operation cannot be carried out because an object already exists",
	L"CIM2XML: The specified property does not exist",
	L"CIM2XML: The Value supplied is incompatible with the type",
	L"CIM2XML: The Query Language is not recognized or supported",
	L"CIM2XML: The query is not valid for the specified query language"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlidl\myext.h ===
#ifdef __midl

#define   HSE_LOG_BUFFER_LEN         80
typedef   LPVOID          HCONN;
typedef		BYTE *		LPBYTE;

//
// structure passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHttpStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (* GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (* WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (* ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (* ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\common.cpp ===
#include <windows.h>
#include <objbase.h>
#include <ole2.h>

#include "wbemcli.h"
#include "provexpt.h"
#include "provtempl.h"
#include "common.h"

// A hashing function for a BSTR
UINT AFXAPI HashKey(BSTR key)
{
	UINT nHash = 0;
	while (*key)
		nHash = (nHash<<5) + nHash + *key++;
	return nHash;
}

// A hashing function for a GUID
UINT AFXAPI HashKey(GUID *pKey)
{
	UINT nHash = 0;
	if(pKey)
		nHash = pKey->Data1 + pKey->Data2 + pKey->Data3 + 
				pKey->Data4[0] +
				pKey->Data4[1] +
				pKey->Data4[2] +
				pKey->Data4[3];
	return nHash;
}

BOOL AFXAPI CompareElements(const BSTR* pElement1, const BSTR* pElement2)
{
	return ! _wcsicmp(*pElement1, *pElement2);
}

// Compare 2 GUID structures
BOOL AFXAPI CompareElements(const GUID ** pElement1, const GUID ** pElement2)
{
	BOOL bReturn = FALSE;
	if(pElement1 && pElement2)
	{
		if(*pElement1 && *pElement2)
		{
			// Check to see if the elements of the guid are equal
			if(	((*pElement1)->Data1 == (*pElement2)->Data1) &&
				((*pElement1)->Data2 == (*pElement2)->Data2) &&
				((*pElement1)->Data3 == (*pElement2)->Data3) )
			{
				const BYTE *p1 = (*pElement1)->Data4;
				const BYTE *p2 = (*pElement2)->Data4;

				if(p1[0]==p2[0] && p1[1]==p2[1] && p1[2]==p2[2] && p1[3]==p2[3])
					bReturn = TRUE;
			}
		}
	}
	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\concache.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CONCACHE.H
//
//  rajesh  3/25/2000   Created.
//
// This file implements a class that holds a cache of IWbemServices pointers
//
//***************************************************************************

#ifndef WMI_XML_CONCACHE_H_
#define WMI_XML_CONCACHE_H_

class CXMLConnectionCache  
{
private:
	IWbemLocator		*m_pLocator;
	DWORD				m_dwCapabilities;

	HRESULT GetNt4ConnectionByPath (BSTR pszNamespace, IWbemServices **ppService);
	HRESULT GetWin2kConnectionByPath (BSTR pszNamespace, IWbemServices **ppService);
public:
	CXMLConnectionCache();
	virtual ~CXMLConnectionCache();

	HRESULT	GetConnectionByPath (BSTR namespacePath, IWbemServices **ppService);
	void	SecureWmiProxy (IUnknown *pProxy);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\cwmixmlop.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CWMIXMLOP.H
//
//  rajesh  3/25/2000   Created.
//
// This file defines a class that is used for handling WMI protocol
// operations over XML/HTTP
//
//***************************************************************************

#ifndef WMI_XML_WBEMXMLOP_H_
#define WMI_XML_WBEMXMLOP_H_


//***************************************************************************
//
//  CLASS NAME:
//
//  CWmiXmlOpHandler
//
//  DESCRIPTION:
//
//  Performs conversion .
//
//***************************************************************************

class CWmiXmlOpHandler : public IWbemXMLOperationsHandler
{
private:
	
	long					m_cRef; // COM Ref count

public:

	CWmiXmlOpHandler();
    ~CWmiXmlOpHandler();

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


	// Functions of the IWbemXMLOperationsHandler interface
    virtual HRESULT STDMETHODCALLTYPE ProcessHTTPRequest( 
        /* [in] */ LPEXTENSION_CONTROL_BLOCK pECB,
        /* [in] */ IUnknown  *pDomDocument);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\common.h ===
#ifndef COMMON_WMI_XML_H
#define COMMON_WMI_XML_H

// We need a structure for holding an IWbemServices and IWbemTransaction together

#ifdef WMIXMLTRANSACT
class CServicesTransaction
{

public:
	IWbemTransaction *m_pTrans;
	IWbemServices *m_pServices;
	long m_cRef;
	CServicesTransaction(IWbemTransaction *pTrans, IWbemServices *pServices)
	{
		if(m_pTrans = pTrans)
			m_pTrans->AddRef();
		if(m_pServices = pServices)
			m_pServices->AddRef();
		m_cRef = 0;

	}

	virtual ~CServicesTransaction()
	{
		if(m_pTrans)
			m_pTrans->Release();
		if(m_pServices)
			m_pServices->Release();
	}

	STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}

	STDMETHODIMP_(ULONG) Release(void)
	{
		InterlockedDecrement(&m_cRef);
		if (0L!=m_cRef)
			return m_cRef;
		delete this;
		return 0;
	}
};

// The transaction GUID table and its template functions
typedef CMap <GUID *, GUID *, CServicesTransaction*, CServicesTransaction*> CTransactionGUIDTable;
UINT AFXAPI HashKey(GUID *pKey);
BOOL AFXAPI CompareElements(const GUID ** pElement1, const GUID ** pElement2);
#endif

// A table for managing extrinsic method parameters
typedef CMap <BSTR, BSTR, IXMLDOMNode *, IXMLDOMNode *> CParameterMap;
UINT AFXAPI HashKey(BSTR key);
BOOL AFXAPI CompareElements(const BSTR* pElement1, const BSTR* pElement2);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\concache.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CONCACHE.CPP
//
//  rajesh  3/25/2000   Created.
//
// This file implements a class that holds a cache of IWbemServices pointers
//
//***************************************************************************


// Note we assume DCOM platforms only.  This makes life easier
// cross-thread handling of IWbemXXX interfaces.
#define _WIN32_DCOM

#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <wbemidl.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <cominit.h>

#include <httpext.h>
#include <msxml.h>

#include "provtempl.h"
#include "maindll.h"
#include "common.h"
#include "wmixmlop.h"
#include "wmixmlst.h"
#include "concache.h"
#include "wmiconv.h"
#include "xml2wmi.h"
#include "wmixmlt.h"
#include "request.h"
#include "strings.h"
#include "xmlhelp.h"
#include "parse.h"
#include "service.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLConnectionCache::CXMLConnectionCache()
{
	m_pLocator = NULL;

	// Get OS info
	OSVERSIONINFO	osVersionInfo;
	osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	GetVersionEx (&osVersionInfo);
	m_dwCapabilities = EOAC_NONE;

	if ((VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId) &&
			(4 < osVersionInfo.dwMajorVersion))
		m_dwCapabilities |= EOAC_STATIC_CLOAKING;

#if 0
	m_pConnection = NULL;
	InitializeCriticalSection (&m_cs);
#endif
}

CXMLConnectionCache::~CXMLConnectionCache()
{
	if (m_pLocator)
		m_pLocator->Release ();

#if 0
	EnterCriticalSection (&m_cs);

	// Clean up the connection cache
	for (CXMLConnection *pConnection = m_pConnection; pConnection != NULL;)
	{
		CXMLConnection *pTemp = pConnection;
		pConnection = pTemp->Next;
		delete pTemp;
	}

	LeaveCriticalSection (&m_cs);
	DeleteCriticalSection (&m_cs);
#endif
}


HRESULT CXMLConnectionCache::GetConnectionByPath (BSTR pszNamespace, IWbemServices **ppService)
{
	*ppService = NULL;

	// Depending on the platform, get the correct kind of interface pointer.
	// For Win2k, we have cloaking, so we directly use the WMI APIs
	// For NT4.0, we go to the WMI XML transport that was loaded by WinMgmt
	//=================================================================
	if(g_platformType == WMI_XML_PLATFORM_NT_4)
		return GetNt4ConnectionByPath(pszNamespace, ppService);
	else if (g_platformType == WMI_XML_PLATFORM_WIN2K ||
			g_platformType == WMI_XML_PLATFORM_WHISTLER)
		return GetWin2kConnectionByPath(pszNamespace, ppService);
	return E_FAIL;
}

void CXMLConnectionCache::SecureWmiProxy (IUnknown *pProxy)
{
	if (pProxy)
	{
		// Ensure we have impersonation enabled
		// Ensure we do cloaking based on the kind of platform we are on
		DWORD dwAuthnLevel, dwImpLevel;
		GetAuthImp (pProxy, &dwAuthnLevel, &dwImpLevel);

		SetInterfaceSecurity (pProxy, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, 
								m_dwCapabilities);
	}
}

// Get a connection to the XML Transport loaded by WinMgmt
HRESULT CXMLConnectionCache::GetNt4ConnectionByPath (BSTR pszNamespace, IWbemServices **ppService)
{
	HRESULT result = WBEM_E_FAILED;

	IWmiXMLTransport *pWbemLocator = NULL;
	// Connect to the out-of-proc XML tranport that was loaded by WinMgmt
	if(SUCCEEDED(result = CoCreateInstance (CLSID_WmiXMLTransport , NULL ,
		CLSCTX_LOCAL_SERVER , 
			IID_IWmiXMLTransport,(void **)&pWbemLocator)))
	{
		// Create an handle for the current thread's token in Winmgtm
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
		}
		else // Try once more since WinMgmt might have been restarted and hence we have a stale value in m_dwWinMgmtPID
		{
			if(RefreshWinMgmtPID())
				result = DuplicateTokenInWinmgmt(&pNewToken);
		}

		// Get a services pointer
		if(SUCCEEDED(result))
		{
			IWmiXMLWbemServices *pInnerService = NULL;
			if(SUCCEEDED(result = pWbemLocator->ConnectUsingToken((DWORD_PTR)pNewToken, pszNamespace, 0, 0, NULL, NULL, &pInnerService)))
			{
				*ppService = NULL;
				if(*ppService = new CWMIXMLServices(pInnerService))
					(*ppService)->AddRef();
				else
					result = E_OUTOFMEMORY;
				pInnerService->Release();
			}
		}
		pWbemLocator->Release();

		// No need to close the duplicated token - it will be closed in WinMgmt by the XML transport
	}
	return result;
}


HRESULT CXMLConnectionCache::GetWin2kConnectionByPath (BSTR pszNamespace, IWbemServices **ppService)
{
	HRESULT hr = WBEM_E_FAILED;

	// If we don't have a locator yet, create one
	if (NULL == m_pLocator)
	{
		if (S_OK != CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemLocator, (LPVOID *) &m_pLocator))
			return WBEM_E_FAILED;
	}

	// Leave out caching for now as DCOM may timeout idle IWbemServices pointers
	// for us (yuck)

#if 0
	// Is our connection already in the cache?

	EnterCriticalSection (&m_cs);
	for (CXMLConnection *pConnection = m_pConnection; pConnection != NULL; 
					pConnection = pConnection->Next)
	{
		if (pConnection->MatchesNamespace (pszNamespace))
		{
			// Found it - just AddRef and return
			*ppService = pConnection->GetService ();
			(*ppService)->AddRef ();
			LeaveCriticalSection (&m_cs);
			return WBEM_S_NO_ERROR;
		}
	}

	// If we get here we didn't find an existing service
	if (WBEM_S_NO_ERROR == (hr = m_pLocator->ConnectServer 
			(pszNamespace, NULL, NULL, NULL, 0, NULL, NULL, ppService)))
	{
		// Success - add it into our cache
		(*ppService)->AddRef ();
		 CXMLConnection *pConnection = new CXMLConnection (*ppService, pszNamespace);
		 
		// Chain in at the front of the connection list
		if (m_pConnection)
		{
			pConnection->Next = m_pConnection->Next;
			m_pConnection->Prev = pConnection;
		}
		else
			pConnection->Next = NULL;

		m_pConnection = pConnection;
	}

	LeaveCriticalSection (&m_cs);

#else

	// Get an IWbemService pointer from WinMgmt
	IWbemServices *pService = NULL;
	if (SUCCEEDED (hr = m_pLocator->ConnectServer (pszNamespace, NULL, NULL, NULL, 0, NULL, NULL, &pService)))
	{
		SecureWmiProxy (pService);
		// Wrap it up
		*ppService = NULL;
		if(*ppService = new CWMIXMLServices(pService))
			(*ppService)->AddRef();
		else
			hr = E_OUTOFMEMORY;
		pService->Release();

	}
#endif

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\maindll.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "psapi.h"
#include <initguid.h>
#include <objbase.h>
#include <olectl.h>
#include <wbemidl.h>

#include "maindll.h"
#include "provtempl.h"
#include "common.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <httpext.h>
#include "wmixmlop.h"
#include "cwmixmlop.h"
#include "classfac.h"
#include "wmixmlst.h"
#include "request.h"
#include "whistler.h"

// {DB66408E-D355-11d3-93FC-00805F853771}
DEFINE_GUID(CLSID_WbemXMLOperationsHandler,
0xdb66408e, 0xd355, 0x11d3, 0x93, 0xfc, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);


// Count number of objects and number of locks.
long g_cObj = 0 ;
long g_cLock = 0 ;
HMODULE ghModule = NULL;


// WinMgmt's PID and a CriticalSection to protect it
DWORD g_dwWinMgmtPID = 0;
CRITICAL_SECTION g_WinMgmtPIDCritSec;

// Get Platform(OS) version information
WMI_XML_PLATFORM_TYPE g_platformType = WMI_XML_PLATFORM_INVALID;

// A critical section for accessing the Global transaction pointer table
CRITICAL_SECTION g_TransactionTableSection;

// Control-specific registry strings
LPCTSTR WMI_XML_DESCRIPTION	= __TEXT("WMI XML/HTTP  Protocol Handler");

// Standard registry key/value names
LPCTSTR INPROC32_STR			= __TEXT("InprocServer32");
LPCTSTR INPROC_STR				= __TEXT("InprocServer");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR BOTH_STR				= __TEXT("Both");
LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");
LPCTSTR XMLHANDLER_STR			= __TEXT("SOFTWARE\\Microsoft\\WBEM\\xml\\ProtocolHandlers");
LPCTSTR VERSION_1				= __TEXT("1.0");

/*********** The global variables ***********************************
********************************************************************/
// A critical section to create/delete statics
CRITICAL_SECTION g_StaticsCreationDeletion;

// Various Attribute names we need
BSTR ARRAYSIZE_ATTRIBUTE	= NULL;
BSTR CLASS_NAME_ATTRIBUTE	= NULL;
BSTR CLASS_ORIGIN_ATTRIBUTE	= NULL;
BSTR ID_ATTRIBUTE			= NULL;
BSTR NAME_ATTRIBUTE			= NULL;
BSTR PROTOVERSION_ATTRIBUTE = NULL;
BSTR VALUE_TYPE_ATTRIBUTE	= NULL;
BSTR SUPERCLASS_ATTRIBUTE	= NULL;
BSTR TYPE_ATTRIBUTE			= NULL;
BSTR OVERRIDABLE_ATTRIBUTE	= NULL;
BSTR TOSUBCLASS_ATTRIBUTE	= NULL;
BSTR TOINSTANCE_ATTRIBUTE	= NULL;
BSTR AMENDED_ATTRIBUTE		= NULL;
BSTR REFERENCECLASS_ATTRIBUTE = NULL;
BSTR CIMVERSION_ATTRIBUTE	= NULL;
BSTR DTDVERSION_ATTRIBUTE	= NULL;
BSTR VTTYPE_ATTRIBUTE		= NULL;
BSTR WMI_ATTRIBUTE			= NULL;

void CheckTheError()
{
	LPVOID lpMsgBuf;
	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL
	);

	// Free the buffer.
	LocalFree( lpMsgBuf );

}


//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.
//
//  PARAMETERS:
//
//		hModule           instance handle
//		ulReason          why we are being called
//		pvReserved        reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************
BOOL WINAPI DllMain( HINSTANCE hModule,
                       DWORD  ulReason,
                       LPVOID lpReserved
					 )
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
			DeleteCriticalSection(&g_StaticsCreationDeletion);
			DeleteCriticalSection(&g_WinMgmtPIDCritSec);
			DeleteCriticalSection(&g_TransactionTableSection);
			return TRUE;

		case DLL_PROCESS_ATTACH:
			ghModule = hModule;
			// Initialize the critical section to access the static initializer objects
			InitializeCriticalSection(&g_StaticsCreationDeletion);
			InitializeCriticalSection(&g_WinMgmtPIDCritSec);
			InitializeCriticalSection(&g_TransactionTableSection);
			if((g_platformType = GetPlatformInformation()) == WMI_XML_PLATFORM_INVALID)
				return FALSE;
	        return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr;
    CWmiXmlOpFactory *pObj = NULL;

    if (CLSID_WbemXMLOperationsHandler == rclsid)
	{
        if (NULL == (pObj = new CWmiXmlOpFactory()))
			return ResultFromScode(E_OUTOFMEMORY);
	}
	else
        return E_FAIL;

    hr=pObj->QueryInterface(riid, ppv);

    if ( FAILED ( hr ) )
	{
        delete pObj ;
	}

    return hr ;
}


//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	//It is OK to unload if there are no objects or locks on the
    // class factory. And if the transaction table is empty
	HRESULT hr = S_FALSE;

    if (0L==g_cObj && 0L==g_cLock)
	{

#ifdef WMIXMLTRANSACT
		// No transaction should be pending. This is because, even though the
		// object count has gone to zero, the transaction table might be non-empty
		// That means that a RollBack() or Commit() message hasnt still come on a 
		// currently running transaction. Hence we dont want to unload the DLL
		// and hence lose the transaction table and hence the transaction state
		if(CCimWhistlerHttpMethod::IsTransactionTableEmpty() == S_OK)
		{
			UninitializeWmixmlopDLLResources();
			hr = S_OK;
		}
#else

		UninitializeWmixmlopDLLResources();
		hr = S_OK;
#endif

	}
	return hr;
}


/***************************************************************************
 *
 * SetKeyAndValue
 *
 * Description: Helper function for DllRegisterServer that creates
 * a key, sets a value, and closes that key. If pszSubkey is NULL, then
 * the value is created for the pszKey key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValueName    LPTSTR to the value name to use
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteKey
 *
 * Description: Helper function for DllUnRegisterServer that deletes the subkey
 * of a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteValue
 *
 * Description: Helper function for DllUnRegisterServer that deletes a value
 * under a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszValue		LPTSTR to the name of a value under the key
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteValue(LPCTSTR pszKey, LPCTSTR pszValue)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteValue(hKey, pszValue))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}




//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
	TCHAR szModule[512];
	GetModuleFileName(ghModule, szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szWmiXmlClassID[128];
	TCHAR szWmiXmlCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WbemXMLOperationsHandler, szWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWmiXmlClassID[128];
	if(StringFromGUID2(CLSID_WbemXMLOperationsHandler, wszWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWmiXmlClassID, -1, szWmiXmlClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWmiXmlCLSIDClassID, CLSID_STR);
	_tcscat(szWmiXmlCLSIDClassID, szWmiXmlClassID);

	//
	// Create entries under CLSID for WMI XMl Protocol Handler
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, NULL, NULL, WMI_XML_DESCRIPTION))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, BOTH_STR))
		return SELFREG_E_CLASS;

	// We're done with the COM Entries. Now, we need to create our component specific entries.
	// Each WMI XML Protocol Handler is registered underneath the key HKLM/Software/Microsoft/WBEM/XML/ProtocolHandlers
	// For each handler (including this one), we will have to create a value with the protocol version as name
	// and a value of the CLSID of the component. So, here we go
	// Remove the braces from the string representation first
	szWmiXmlClassID[wcslen(szWmiXmlClassID)-1] = NULL;
	if (FALSE == SetKeyAndValue(XMLHANDLER_STR, NULL, VERSION_1, szWmiXmlClassID+1))
		return SELFREG_E_CLASS;


	return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	TCHAR szModule[512];
	GetModuleFileName(ghModule,szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szWmiXmlClassID[128];
	TCHAR szWmiXmlCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WbemXMLOperationsHandler, szWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWmiXmlClassID[128];
	if(StringFromGUID2(CLSID_WbemXMLOperationsHandler, wszWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWmiXmlClassID, -1, szWmiXmlClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWmiXmlCLSIDClassID, CLSID_STR);
	_tcscat(szWmiXmlCLSIDClassID, szWmiXmlClassID);

	//
	// Delete the keys for the COM obhect
	//
	if(FALSE == DeleteKey(szWmiXmlCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szWmiXmlClassID))
		return SELFREG_E_CLASS;

	if(FALSE == DeleteValue(XMLHANDLER_STR, VERSION_1))
		return SELFREG_E_CLASS;

    return NOERROR;
}

static WMI_XML_PLATFORM_TYPE GetPlatformInformation()
{
	OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(GetVersionEx(&os))
	{
		switch(os.dwMajorVersion)
		{
			case 4:
				return WMI_XML_PLATFORM_NT_4;
			case 5:
				if(os.dwMinorVersion == 1)
					return WMI_XML_PLATFORM_WHISTLER;
				else
					return WMI_XML_PLATFORM_WIN2K;
		}
	}

	return WMI_XML_PLATFORM_INVALID;
}

DWORD RefreshWinMgmtPID()
{
	EnterCriticalSection(&g_WinMgmtPIDCritSec);
	g_dwWinMgmtPID = 0;
	IWmiXMLTransport *pWbemLocator = NULL;
	// Connect to the out-of-proc XML tranport that was loaded by WinMgmt
	if(SUCCEEDED(CoCreateInstance (CLSID_WmiXMLTransport , NULL ,
		CLSCTX_LOCAL_SERVER ,
			IID_IWmiXMLTransport,(void **)&pWbemLocator)))
	{
		pWbemLocator->GetPID(&g_dwWinMgmtPID);
		pWbemLocator->Release();
	}
	LeaveCriticalSection(&g_WinMgmtPIDCritSec);
    return g_dwWinMgmtPID;

}

// Duplicate the current thread's token to the process of WinMgmt
HRESULT DuplicateTokenInWinmgmt(HANDLE *pDuplicateToken)
{
	HRESULT result = E_FAIL;
	HANDLE pToken = NULL;
	// First get the current thread's token
	if(OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY, TRUE, &pToken))
	{
		// Make sure you're not impersonating when you try to Duplicate the token
		if(RevertToSelf())
		{
			HANDLE hWinMgmt = NULL;
			if(hWinMgmt = OpenProcess(PROCESS_ALL_ACCESS,  FALSE, g_dwWinMgmtPID))
			{
				// Now Duplicate the token to the WinMgmt process
				if(DuplicateHandle(GetCurrentProcess(), pToken, hWinMgmt, pDuplicateToken, DUPLICATE_SAME_ACCESS, FALSE, DUPLICATE_SAME_ACCESS))
				{
					result = S_OK;
				}
				else
					CheckTheError();
				CloseHandle(hWinMgmt);
			}
			else
				CheckTheError();

			// Go back to impersonation mode
			if(!ImpersonateLoggedOnUser(pToken))
				result = E_FAIL;
		}
		else
			CheckTheError();
		CloseHandle(pToken);
	}
	else
		CheckTheError();
	return result;
}


void UninitializeWmixmlopDLLResources()
{
	// Delete the Initializer objects
	EnterCriticalSection(&g_StaticsCreationDeletion);
	SysFreeString(ARRAYSIZE_ATTRIBUTE);
	SysFreeString(CIMVERSION_ATTRIBUTE);
	SysFreeString(CLASS_NAME_ATTRIBUTE);
	SysFreeString(CLASS_ORIGIN_ATTRIBUTE);
	SysFreeString(DTDVERSION_ATTRIBUTE);
	SysFreeString(ID_ATTRIBUTE);
	SysFreeString(NAME_ATTRIBUTE);
	SysFreeString(PROTOVERSION_ATTRIBUTE);
	SysFreeString(VALUE_TYPE_ATTRIBUTE);
	SysFreeString(SUPERCLASS_ATTRIBUTE);
	SysFreeString(TYPE_ATTRIBUTE);
	SysFreeString(OVERRIDABLE_ATTRIBUTE);
	SysFreeString(TOSUBCLASS_ATTRIBUTE);
	SysFreeString(TOINSTANCE_ATTRIBUTE);
	SysFreeString(AMENDED_ATTRIBUTE);
	SysFreeString(REFERENCECLASS_ATTRIBUTE);
	SysFreeString(VTTYPE_ATTRIBUTE);
	SysFreeString(WMI_ATTRIBUTE);

	ARRAYSIZE_ATTRIBUTE		= NULL;
	CLASS_NAME_ATTRIBUTE	= NULL;
	CLASS_ORIGIN_ATTRIBUTE	= NULL;
	ID_ATTRIBUTE			= NULL;
	NAME_ATTRIBUTE			= NULL;
	PROTOVERSION_ATTRIBUTE	= NULL;
	VALUE_TYPE_ATTRIBUTE	= NULL;
	SUPERCLASS_ATTRIBUTE	= NULL;
	TYPE_ATTRIBUTE			= NULL;
	OVERRIDABLE_ATTRIBUTE	= NULL;
	TOSUBCLASS_ATTRIBUTE	= NULL;
	TOINSTANCE_ATTRIBUTE	= NULL;
	AMENDED_ATTRIBUTE		= NULL;
	REFERENCECLASS_ATTRIBUTE = NULL;
	CIMVERSION_ATTRIBUTE	= NULL;
	DTDVERSION_ATTRIBUTE	= NULL;
	VTTYPE_ATTRIBUTE		= NULL;
	WMI_ATTRIBUTE		= NULL;
	LeaveCriticalSection(&g_StaticsCreationDeletion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\maindll.h ===
#ifndef WMIXMLOP_MAINDLL_H
#define WMIXMLOP_MAINDLL_H

// List of Platforms
typedef enum 
{
	WMI_XML_PLATFORM_INVALID = 0,
	WMI_XML_PLATFORM_NT_4,
	WMI_XML_PLATFORM_WIN2K,
	WMI_XML_PLATFORM_WHISTLER
} WMI_XML_PLATFORM_TYPE;
extern WMI_XML_PLATFORM_TYPE g_platformType;

DWORD RefreshWinMgmtPID();
WMI_XML_PLATFORM_TYPE GetPlatformInformation();
HRESULT DuplicateTokenInWinmgmt(HANDLE *pDuplicateToken);

// A critical section for accessing the Global transaction pointer table
extern CRITICAL_SECTION g_TransactionTableSection;
void UninitializeWmixmlopDLLResources();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\errors.h ===
#ifndef WMI_XML_HTTP_ERRORS_H
#define WMI_XML_HTTP_ERRORS_H

// Everything OK
#define HTTP_STATUS_200	"200 OK"

// Client Errors
#define HTTP_ERR_400	"400 Bad Request"
#define HTTP_ERR_405	"405 Method Not Allowed"
#define HTTP_ERR_406	"406 Not Acceptable"
#define HTTP_ERR_415	"415 Unsupported Media Type"
#define	HTTP_ERR_416	"416 Requested Range Not Satisfiable"

// Server Errors
#define HTTP_ERR_501	"501 Not Implemented"

// CIM Errors - HTTP headers in case of errors
#define CIM_UNSUPPORTED_PROTOCOL_VERSION	"CIMError: unsupported-protocol-version"
#define CIM_UNSUPPORTED_CIM_VERSION			"CIMError: unsupported-cim-version"
#define CIM_UNSUPPORTED_DTD_VERSION			"CIMError: unsupported-dtd-version"
#define CIM_REQUEST_NOT_VALID				"CIMError: request-not-valid"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\cwmixmlop.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CWMIXMLOP.CPP
//
//  rajesh  3/25/2000   Created.
//
// This file defines a class that is used for handling WMI protocol
// operations over XML/HTTP
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <httpext.h>
#include <mshtml.h>
#include <msxml.h>
#include <time.h>

#include <wbemidl.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "maindll.h"
#include "provtempl.h"
#include "common.h"
#include "wmcomm.h"
#include "strings.h"
#include "wmixmlop.h"
#include "cwmixmlop.h"
#include "wmiconv.h"
#include "request.h"
#include "xmlhelp.h"
#include "parse.h"
#include "errors.h"

extern long g_cObj;


// Forward declarations
//==========================================

// Gets the HTTP Version# in a client request
static WMI_XML_HTTP_VERSION GetHTTPVersion(LPEXTENSION_CONTROL_BLOCK pECB);

// Service a CIM HTTP request (POST or M-POST)
static void ServiceCIMRequest(LPEXTENSION_CONTROL_BLOCK pECB, BOOLEAN bIsMpostRequest, IXMLDOMDocument *pDocument);

// Service an OPTIONS request
static void ServiceOptionsRequest (LPEXTENSION_CONTROL_BLOCK pECB);

// Send an HTTP Status and optionally, some headers
static void SendHeaders(LPEXTENSION_CONTROL_BLOCK pECB, LPCSTR pszHeaders, DWORD dwHttpStatus);
// Extract dynamic header names
LPSTR GetCIMHeader (char *pszName, BOOLEAN bIsMpostRequest, DWORD dwNs);

// Check content-type of request
static BOOLEAN ContentTypeSupported (LPCSTR pszContentType, char **ppCharset);

// Check mandatory extension header
static BOOLEAN CheckManHeader (char *pszManHeader,	DWORD &dwNs);

// Check CIM headers
static BOOLEAN CheckCIMOperationHeader (char *pszCIMOperationHeader);
static BOOLEAN CheckCIMProtocolVersionHeader (char *pszCIMProtocolVersionHeader, DWORD *pdwStatus);

// Check All Operation Request headers
BOOLEAN CheckRequestHeaders (LPEXTENSION_CONTROL_BLOCK pECB, BOOLEAN bIsMPostRequest,
	char **ppszCharset, char **ppszProtoVersion, char **ppszMethod,
	BOOLEAN &bIsBatch, char **ppszObject, BOOLEAN &bIsMicrosoftWMIClient);
BOOLEAN CheckAcceptHeader(LPCSTR pszAcceptValue);
BOOLEAN CheckAcceptEncodingHeader(LPCSTR pszAcceptValue);
BOOLEAN CheckAcceptCharsetHeader(LPCSTR pszAcceptValue);
BOOLEAN CheckAcceptLanguageHeader(LPCSTR pszAcceptValue);

extern BOOLEAN g_sRandom;

CWmiXmlOpHandler::CWmiXmlOpHandler()
{
	m_cRef = 0;
    InterlockedIncrement(&g_cObj);

}

//***************************************************************************
// HRESULT CWmiXmlOpHandler::QueryInterface
// long CWmiXmlOpHandler::AddRef
// long CWmiXmlOpHandler::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWmiXmlOpHandler::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWbemXMLOperationsHandler==riid)
		*ppv = reinterpret_cast<IWbemXMLOperationsHandler*>(this);

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiXmlOpHandler::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWmiXmlOpHandler::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}


//***************************************************************************
//
//  CWmiXmlOpHandler::~CWmiXmlOpHandler
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CWmiXmlOpHandler::~CWmiXmlOpHandler(void)
{
    InterlockedDecrement(&g_cObj);

}

HRESULT STDMETHODCALLTYPE CWmiXmlOpHandler::ProcessHTTPRequest(
    /* [in] */ LPEXTENSION_CONTROL_BLOCK pECB,
    /* [in] */ IUnknown  *pDomDocument)
{
	// Useful information extracted from the HTTP headers
	BOOLEAN	bIsMpostRequest = FALSE;
	BOOLEAN	bIsOptionsRequest = FALSE;

	Log (pECB, "Cim2Xml: Called");

	/*
	 * Check the requested METHOD
	 * POST, M-POST and OPTIONS are the only required methods to
	 * be supported.
	 */
	if (0 == _stricmp(pECB->lpszMethod, HTTP_MPOST_METHOD))
		bIsMpostRequest = TRUE;
	else if (0 == _stricmp(pECB->lpszMethod, HTTP_OPTIONS_METHOD))
		bIsOptionsRequest = TRUE;
	else if (0 != _stricmp(pECB->lpszMethod, HTTP_POST_METHOD))
	{
		// Send an 405 : Method Not ALlowed response with a list of methods
		// supported in the Allow header
		SendHeaders(pECB, "Allow: POST, M-POST", 405);
		LogError (pECB, "Cim2Xml: FAILED Unsupported HTTP method [501]", 501);
		return HSE_STATUS_SUCCESS;
	}

	if (bIsOptionsRequest)
		ServiceOptionsRequest (pECB);
	else
	{
		// Get the IXMLDomDocument interface pointer
		IXMLDOMDocument *pDocument = NULL;
		if(SUCCEEDED(pDomDocument->QueryInterface(IID_IXMLDOMDocument, (LPVOID *)&pDocument)))
		{
			ServiceCIMRequest(pECB, bIsMpostRequest, pDocument);
			pDocument->Release();
		}
	}

	return HSE_STATUS_SUCCESS;
}

LPSTR GetCIMHeader (char *pszName, BOOLEAN bIsMpostRequest, DWORD dwNs)
{
	LPSTR pszHeader = NULL;
	if (bIsMpostRequest)
	{
		if(pszHeader = new char [strlen("HTTP") + strlen(pszName) + 4])
			sprintf (pszHeader, "%s_%02d_%s", "HTTP", dwNs, pszName);
	}
	else
	{
		if(pszHeader = new char [strlen("HTTP") + strlen (pszName) + 2])
			sprintf (pszHeader, "%s_%s", "HTTP", pszName);
	}
	return pszHeader;
}

BOOLEAN CheckCIMOperationHeader (
	char *pszCIMOperationHeader
)
{
	return (pszCIMOperationHeader &&
			(0 == _stricmp (pszCIMOperationHeader, "MethodCall")));
}

BOOLEAN CheckCIMProtocolVersionHeader (
	char *pszCIMProtocolVersionHeader,
	DWORD *pdwStatus
)
{
	BOOLEAN result = FALSE;

	if (!pszCIMProtocolVersionHeader)
		*pdwStatus = 400;
	else if (0 != _stricmp (pszCIMProtocolVersionHeader, "1.0"))
		*pdwStatus = 501;
	else
		result = TRUE;

	return result;
}

BOOLEAN CheckManHeader (
	char *pszManHeader,
	DWORD &dwNs
)
{
	BOOLEAN result = FALSE;

	LPCSTR ptr = NULL;

	// Must be of the form "http://www.dmtf.org/cim/mapping/http/v1.0 ; ns=XX"
	if ((ptr = pszManHeader) &&
		(0 == _strnicmp (ptr, HTTP_MAN_HEADER, strlen (HTTP_MAN_HEADER))))
	{
		ptr += strlen (HTTP_MAN_HEADER);

		if (ptr)
		{
			// Look for the "; ns=XX" string
			SKIPWS(ptr)

			if (ptr && (ptr = strchr (pszManHeader, ';')) && *(++ptr))
			{
				SKIPWS(ptr)

				if (ptr && (0 == _strnicmp (ptr, HTTP_NS, strlen (HTTP_NS))))
				{
					// Now we should find ourselves a NS value
					ptr += strlen (HTTP_NS);

					if (ptr)
					{
						dwNs = strtol (ptr, NULL, 0);
						result = TRUE;
					}
				}
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  BOOLEAN ContentTypeSupported
//
//  Description:
//
//		Checks the value of the Content-Type header in the incoming
//		POST or M-POST request.
//
//	Conformance Reference:
//
//		4.2.13. Content-Type
//				CIM clients and CIM servers MUST specify (and accept) a
//				value for this header of either "text/xml" or
//				"application/xml" as defined in [18].
//
//  Parameters:
//
//		pszContentType	Content-Type header value in received request
//		ppCharset		Addresses pointer to hold parsed charset on return
//
//	Return Value:
//
//		TRUE if Content-Type is acceptable, FALSE otherwise
//
//***************************************************************************

BOOLEAN ContentTypeSupported (LPCSTR pszContentType, char **ppCharset)
{
	BOOLEAN status = FALSE;

	if (pszContentType)
	{
		LPCSTR ptr = NULL;

		if (0 == _strnicmp (pszContentType, HTTP_APPXML_CONTENTTYPE, strlen (HTTP_APPXML_CONTENTTYPE)))
		{
			ptr = pszContentType + strlen (HTTP_APPXML_CONTENTTYPE);
		}
		else if (0 == _strnicmp (pszContentType, HTTP_TEXTXML_CONTENTTYPE, strlen (HTTP_TEXTXML_CONTENTTYPE)))
		{
			ptr = pszContentType + strlen (HTTP_TEXTXML_CONTENTTYPE);
		}

		if (ptr)
		{
			status = TRUE;

			/*
			 * OK so far - now look for the charset parameter; note
			 * that HTTP 1.1 does not allow LWS between a parameter attribute
			 * and its value (section 3.7)
			 */
			SKIPWS(ptr)

			if (ptr && (ptr = strchr (pszContentType, ';')) && *(++ptr))
			{
				SKIPWS(ptr)

				if (ptr && (0 == _strnicmp (ptr, HTTP_PARAMETER_CHARSET, strlen (HTTP_PARAMETER_CHARSET))))
				{
					// Now we should find ourselves a charset value
					ptr += strlen (HTTP_PARAMETER_CHARSET);

					if (ptr)
					{
						*ppCharset = new char [strlen (ptr) + 1];
						strcpy (*ppCharset, ptr);
					}
				}
			}
		}
	}

	return status;
}

//***************************************************************************
//
//  void ServiceOptionsRequest
//
//  Description:
//
//		The main processing routine for every incoming OPTIONS request.
//
//  Parameters:
//
//		pECB			Pointer to EXTENSTION_CONTROL_BLOCK for this request
//		pszCharset		Charset extracted from Content-Type header (or NULL)
//		bIsMpostRequest	Whether the request was POST or M-POST
//
//***************************************************************************

void ServiceOptionsRequest (
	LPEXTENSION_CONTROL_BLOCK pECB
)
{
	// Generate a pseudo-random number with the current time as seed
	if (!g_sRandom)
	{
		srand( (unsigned) time (NULL) );
		g_sRandom = TRUE;
	}

	// Make sure result is in the range 0 to 99
	int i = (100 * rand () / RAND_MAX);
	if (100 == i)
		i--;

	DWORD dwHeaderSize = 1024;
	char szTempBuffer [1024];

	char szOpt [10];
	sprintf (szOpt, "%02d", i);

	// Generate the Opt header
	sprintf (szTempBuffer, "Opt: http://www.dmtf.org/cim/mapping/http/v1.0 ; ns=");
	strcat (szTempBuffer, szOpt);
	strcat (szTempBuffer, "\r\n");
	strcat (szTempBuffer, szOpt);
	strcat (szTempBuffer, "-CIMProtocolVersion: 1.0\r\n");
	strcat (szTempBuffer, szOpt);
	strcat (szTempBuffer, "-CIMSupportedFunctionalGroups: schema-manipulation, association-traversal, query-execution\r\n");
	strcat (szTempBuffer, szOpt);
	strcat (szTempBuffer, "-CIMSupportsMultipleOperations:\r\n");
	strcat (szTempBuffer, szOpt);
	strcat (szTempBuffer, "-CIMSupportedQueryLanguages: WQL\r\n");
	strcat (szTempBuffer, szOpt);
	strcat (szTempBuffer, "-CIMValidation: loosely-validating\r\n");

	if(g_platformType == WMI_XML_PLATFORM_WHISTLER)
		strcat (szTempBuffer, "MicrosoftWMI: Whistler\r\n");
	else
		strcat (szTempBuffer, "MicrosoftWMI: \r\n");
	strcat (szTempBuffer, "MicrosoftWMIProtocolVersion: 1.0\r\n");


	SendHeaders(pECB, szTempBuffer, 200);

}

//***************************************************************************
//
//  void ServiceCIMRequest
//
//  Description:
//
//		The main processing routine for every incoming (M-)POST request.
//
//  Parameters:
//
//		pECB			Pointer to EXTENSTION_CONTROL_BLOCK for this request
//		pszCharset		Charset extracted from Content-Type header (or NULL)
//		bIsMpostRequest	Whether the request was POST or M-POST
//
//***************************************************************************

void ServiceCIMRequest(
	LPEXTENSION_CONTROL_BLOCK pECB,
	BOOLEAN bIsMpostRequest,
	IXMLDOMDocument *pDocument
)
{
	// RAJESHR - use charset in content-type header to direct XML parser
	// RAJESHR - look at whether it's an M-POST to decide how to handle

	// Useful information to extract from headers
	char	*pszProtoVersion = NULL;
	char	*pszMethod = NULL;
	BOOLEAN	bIsBatch = FALSE;
	char	*pszObject = NULL;
	char	*pszCharset = NULL;
	BOOLEAN	bIsMicrosoftWMIClient = FALSE;

	if (CheckRequestHeaders (pECB, bIsMpostRequest, &pszCharset, &pszProtoVersion,
					&pszMethod, bIsBatch, &pszObject, bIsMicrosoftWMIClient))
	{
		// Get the HTTP version# of the request
		WMI_XML_HTTP_VERSION iHttpVersion = WMI_XML_HTTP_VERSION_INVALID;
		if( (iHttpVersion = GetHTTPVersion(pECB)) != WMI_XML_HTTP_VERSION_INVALID)
		{
			// Parse the XML body of the HTTP packet
			//=====================================
			IXMLDOMNode *pMessageNode = NULL;
			DWORD dwStatus = 0;
			LPSTR pszErrorHeaders = NULL;
			if (pMessageNode = GetMessageNode (pDocument, &dwStatus, &pszErrorHeaders))
			{
				// Check the version of the protocol
				BSTR bsProtocolVersion = NULL;
				GetBstrAttribute(pMessageNode, PROTOVERSION_ATTRIBUTE, &bsProtocolVersion);
				if (bsProtocolVersion && (0 == wcscmp (bsProtocolVersion, L"1.0")))
				{
					// Parse the XML body of the HTTP packet
					//=====================================
					CCimHttpMessage *pCimMessage = NULL;
					LPSTR pszCimStatusHeaders = NULL;

					if(ParseXMLIntoCIMOperation (pMessageNode, &pCimMessage, &dwStatus,
								bIsMpostRequest, bIsMicrosoftWMIClient, iHttpVersion, &pszCimStatusHeaders))
					{
						if(dwStatus == 200)
						{
							pCimMessage->EncodeNormalResponse(pECB);
							delete pCimMessage;
						}
						else
						{
							LogError (pECB, "ServiceCIMRequest: ParseXMLIntoCIMOperation() FAILED", dwStatus);

							// Send an HTTP Error to the client
							SendHeaders(pECB, pszCimStatusHeaders, dwStatus);
						}
					}
				}
				else
				{
					// Send an HTTP Error to the client
					SendHeaders(pECB, pszErrorHeaders, dwStatus);
				}

				pMessageNode->Release();
			}
			else
			{
				LogError (pECB, "ServiceCIMRequest: GetMessageNode() FAILED", dwStatus);

				// Send an HTTP Error to the client
				SendHeaders(pECB, pszErrorHeaders, dwStatus);
			}
		}
	}

	delete pszCharset;
	delete pszProtoVersion;
	delete pszMethod;
	delete pszObject;
}




//***************************************************************************
//
//  BOOLEAN CheckRequestHeaders
//
//  Description:
//
//		Checks all HTTP (and CIM) headers associated with an Operation Request
//
//  Parameters:
//
//		pECB		Pointer to the extension control block
//		pVariant	Pointer to hold wrapped XML document on return
//
//	Return Value:
//
//		TRUE if successful, FALSE otherwise
//
//***************************************************************************

BOOLEAN CheckRequestHeaders (
	LPEXTENSION_CONTROL_BLOCK pECB,
	BOOLEAN bIsMpostRequest,
	char **ppszCharset,
	char **ppszProtoVersion,
	char **ppszMethod,
	BOOLEAN &bIsBatch,
	char **ppszObject,
	BOOLEAN &bIsMicrosoftWMIClient
)
{
	/*
	 * Ignore the If-Range, Range headers
	 *
	 * No need to check the Authorization, Connection headers. IIS decides to process these headers and take
	 * appropriate action.
	 */

	DWORD dwNs;

#define	BUFLEN 1024  // This is undefed later
	CHAR szTempBuffer [BUFLEN];
	DWORD dwBufferSize = BUFLEN;

	//	Check the Accept header
	//============================================
	dwBufferSize = BUFLEN;
	if (pECB->GetServerVariable (pECB->ConnID, "Accept", szTempBuffer, &dwBufferSize))
	{
		/*
		*	A CIM server MUST accept any value for this header which states that "text/xml" or "application/xml"
		*	is an acceptable type for an response entity.  A server SHOULD return "406 Not Acceptable" if the
		*	Accept header indicates that neither of these content types are acceptable.
		*/
		if(!CheckAcceptHeader(szTempBuffer))
		{
			SendHeaders(pECB, NULL, 406);
			return FALSE;
		}
	}

	//	Check the Accept-Charset header
	//============================================
	dwBufferSize = BUFLEN;
	if (pECB->GetServerVariable (pECB->ConnID, "Accept-Charset", szTempBuffer, &dwBufferSize))
	{
		/*
		*	A CIM server MUST accept any value for this header which implies that "utf-8" is an
		*	acceptable character set for an response entity.  A server SHOULD return "406 Not Acceptable"
		*	if the Accept-Charset header indicates that this character set is not acceptable
		*/
		if(!CheckAcceptCharsetHeader(szTempBuffer))
		{
			SendHeaders(pECB, NULL, 406);
			return FALSE;
		}
	}

	//	Check the Accept-Encoding header
	//============================================
	dwBufferSize = BUFLEN;
	if (pECB->GetServerVariable (pECB->ConnID, "Accept-Encoding", szTempBuffer, &dwBufferSize))
	{
		/*
		*	A CIM Server MUST accept any value for this header which implies that "identity" is
		*	an acceptable encoding for the response entity.  A server MAY return "406 Not Acceptable"
		*	if the Accept-Encoding header indicates that the this encoding is not acceptable
		*/
		if(!CheckAcceptEncodingHeader(szTempBuffer))
		{
			SendHeaders(pECB, NULL, 406);
			return FALSE;
		}
	}

	//	Check the Accept-Language header
	//============================================
	dwBufferSize = BUFLEN;
	if (pECB->GetServerVariable (pECB->ConnID, "Accept-Language", szTempBuffer, &dwBufferSize))
	{
		/*
		*	CIM Spec does not say what the server should do if it doesnt understand the clients language
		*	For now, we check to see if it is '*' or is a is in the range than begins with "es" - examples
		*	are "es", "es-us", "es-gb" etc.
		*/
		if(!CheckAcceptLanguageHeader(szTempBuffer))
		{
			SendHeaders(pECB, NULL, 406);
			return FALSE;
		}
	}

	//	Check the Accept-Ranges header
	//============================================
	dwBufferSize = BUFLEN;
	if (pECB->GetServerVariable (pECB->ConnID, "Accept-Ranges", szTempBuffer, &dwBufferSize))
	{
		/*
		 * 4.2.5. Accept-Ranges
		 *	CIM clients MUST NOT include this header in a request. CIM Servers MUST
		 *	reject a request that includes an Accept-Ranges header with a status of "406
		 *	Not Acceptable".
		 */

		SendHeaders(pECB, NULL, 406);
		return FALSE;
	}

	//	Check the Content-Encoding header
	//============================================
	dwBufferSize = BUFLEN;
	if (pECB->GetServerVariable (pECB->ConnID, "Content-Encoding", szTempBuffer, &dwBufferSize))
	{
		/*
		 * 4.2.10. Content-Encoding
		 * If a CIM client includes a Content-Encoding header in a request,
		 * it SHOULD specify a value of "identity", unless it has good reason to believe
		 * that the Server can accept another encoding.
		 */
		 if(_stricmp(szTempBuffer, "identity") != 0)
		 {
			SendHeaders(pECB, NULL, 415);
			return FALSE;
		 }
	}

	//	Check the Content-Language header
	//============================================
	dwBufferSize = BUFLEN;
	if (pECB->GetServerVariable (pECB->ConnID, "Content-Language", szTempBuffer, &dwBufferSize))
	{
		// Ignore this since we dont care about its value
		// RAJESHR - Is this correct
	}

	//	Check the Content-Range header
	//============================================
	dwBufferSize = BUFLEN;
	if (pECB->GetServerVariable (pECB->ConnID, "HTTP_CONTENT_RANGE", szTempBuffer, &dwBufferSize))
	{
		/*
		 * 4.2.12. Content-Range
		 *	CIM clients and CIM Servers MUST NOT use this header.
		 */

		SendHeaders(pECB, NULL, 416);
		return FALSE;
	}

	//	Check for valid Content-Type and parse out the charset
	//============================================
	dwBufferSize = BUFLEN;
	if (!ContentTypeSupported (pECB->lpszContentType, ppszCharset))
	{
		// RAJESHR : Neither the HTTP RFC nor the CIM Operations spec tells what
		// error should be reported here. Hence for the moment, we send a 406
		SendHeaders(pECB, NULL, 406);
		return FALSE;
	}

	// Check the Man Header
	//============================================
	dwBufferSize = BUFLEN;
	if (bIsMpostRequest)
	{
		if (!pECB->GetServerVariable (pECB->ConnID, "HTTP_MAN", szTempBuffer, &dwBufferSize)
				|| !CheckManHeader (szTempBuffer, dwNs))
		{
			LogError (pECB, "Cim2Xml: FAILED Missing or bad Man Header [400]", 400);
			return FALSE;
		}
	}

	// Check the CIMOperation header - this is a Mandatory header
	// 3.3.4. CIMOperation : If a CIM Server receives CIM Operation request with this header,
	// but with a missing value or a value that is not "MethodCall", then it MUST fail the request
	// with status "400 Bad Request". The CIM Server MUST include a CIMError header in the response
	// with a value of unsupported-operation.
	// If a CIM Server receives a CIM Operation request without this header, it MUST NOT process it
	// as if it were a CIM Operation Request.  The status code returned by the CIM Server in response
	// to such a request is outside of the scope of this specification
	//========================================================================
	dwBufferSize = BUFLEN;
	LPSTR pCIMHeader = GetCIMHeader ("CIMOperation", bIsMpostRequest, dwNs);

	if (pCIMHeader && pECB->GetServerVariable (pECB->ConnID, pCIMHeader, szTempBuffer, &dwBufferSize))
	{
		if(!CheckCIMOperationHeader (szTempBuffer))
		{
			// Return a "400 Bad Request" - RAJESHR include the CIMError header here as per the spec above
			SendHeaders(pECB, NULL, 400);
			delete pCIMHeader;
			return FALSE;
		}
	}
	else
	{
		LogError (pECB, "Cim2Xml: FAILED Missing CIMOperation Header [400]", 400);
		delete pCIMHeader;
		return FALSE;
	}
	delete pCIMHeader;

	// Check the CIMProtocolVersion header - this is not a mandatory header
	// 4.3. Errors and Status Codes: "501 Not Implemented": One of the following occured:
	// The CIMProtocolVersion extension header specified in the request specifies a
	// version of the CIM Mapping onto HTTP which is not supported by this CIM Server.
	// The CIM Server MUST include a CIMError header in the response with a value of
	// unsupported-protocol-version.
	//==============================================================================
	dwBufferSize = BUFLEN;
	pCIMHeader = GetCIMHeader ("CIMProtocolVersion", bIsMpostRequest, dwNs);
	DWORD dwStatus;

	if (pCIMHeader && pECB->GetServerVariable (pECB->ConnID, pCIMHeader, szTempBuffer, &dwBufferSize))
	{
		if(!CheckCIMProtocolVersionHeader (szTempBuffer, &dwStatus))
		{
			// Return a "501 - Not implemented" - RAJESHR include the CIMError header here as per the spec above
			SendHeaders(pECB, NULL, 501);
			delete pCIMHeader;
			return FALSE;
		}
		else
			// Save this for later checking against the version in the <MESSAGE>
			// RAJESHR - must check this against version in XML payload
			*ppszProtoVersion = _strdup (szTempBuffer);
	}
	delete pCIMHeader;

	// Check the CIMMethod header
	// If a CIM Server receives a CIM Operation Request for which either:
	//		The CIMMethod header is present but has an invalid value, or;
	//		The CIMMethod header is not present but the Operation Request Message is a Simple Operation Request, or;
	//		The CIMMethod header is present but the Operation Request Message is not a Simple Operation Request, or;
	//		The CIMMethod header is present, the Operation Request Message is a Simple Operation Request, but
	//		the CIMIdentifier value (when unencoded) does not match the unique method name within the Simple
	//		Operation Request, then it MUST fail the request and return a status of "400 Bad Request"
	//		(and MUST include a CIMError header in the response with a value of header-mismatch), subject to the considerations specified in Errors.
	//  RAJESHR - The implementation below is not entirely accurate since it expects a CIMMethod header value
	// even for MULTIREQUESTS, which is not correct
	//=======================================================================================
	dwBufferSize = BUFLEN;
	pCIMHeader = GetCIMHeader ("CIMMethod", bIsMpostRequest, dwNs);

	if (pCIMHeader && (!pECB->GetServerVariable (pECB->ConnID, pCIMHeader, szTempBuffer, &dwBufferSize)
			|| !szTempBuffer || (0 == strlen (szTempBuffer))))
	{
		// Return a "400 Bad Request" - RAJESHR include the CIMError header here as per the spec above
		SendHeaders(pECB, NULL, 400);
		delete pCIMHeader;
		return FALSE;
	}
	else
		// Save this for later checking against the version in the <MESSAGE>
		// RAJESHR - must check this against version in XML payload
		*ppszMethod = _strdup (szTempBuffer);
	delete pCIMHeader;

	// Check the CIMObject header
	//============================================
	dwBufferSize = BUFLEN;
	pCIMHeader = GetCIMHeader ("CIMObject", bIsMpostRequest, dwNs);

	if (pCIMHeader && (!pECB->GetServerVariable (pECB->ConnID, pCIMHeader, szTempBuffer, &dwBufferSize)
			|| !szTempBuffer || (0 == strlen (szTempBuffer))))
	{
		LogError (pECB, "Cim2Xml: FAILED Missing or bad CIMObject Header [400]", 400);
		delete pCIMHeader;
		return FALSE;
	}
	else
		// Save this for later checking against the version in the <MESSAGE>
		// RAJESHR - must check this against version in XML payload
		*ppszObject = _strdup (szTempBuffer);
	delete pCIMHeader;


	// Check the MicrosoftWMI header - Save it for later use
	//============================================
	dwBufferSize = BUFLEN;
	pCIMHeader = GetCIMHeader ("MicrosoftWMI", bIsMpostRequest, dwNs);

	if (pCIMHeader && pECB->GetServerVariable (pECB->ConnID, pCIMHeader, szTempBuffer, &dwBufferSize))
	{
		bIsMicrosoftWMIClient = TRUE;
	}
	delete pCIMHeader;

#undef BUFLEN

	return TRUE;
}


static WMI_XML_HTTP_VERSION GetHTTPVersion(LPEXTENSION_CONTROL_BLOCK pECB)
{
	char pszHTTPVersion[100];
	DWORD dwBuffSize = 100;
	if (pECB->GetServerVariable(pECB->ConnID, SV_SERVER_PROTOCOL, pszHTTPVersion, &dwBuffSize))
	{
		if(_stricmp(pszHTTPVersion, SV_HTTP_1_0) == 0)
			return WMI_XML_HTTP_VERSION_1_0;
		else if ( _stricmp(pszHTTPVersion, SV_HTTP_1_1) == 0)
			return WMI_XML_HTTP_VERSION_1_1;
	}

	return WMI_XML_HTTP_VERSION_INVALID;
}

static BOOLEAN CheckAcceptHeader(LPCSTR pszAcceptValue)
{
	// Check to see if it begins with one of the following substrings
	//	1. */*
	//	2. text/*
	//	3. text/xml
	//	4. application/*
	//	5. application/xml
	//====================================================================================
	if(pszAcceptValue)
	{
		if(strcmp(pszAcceptValue, "*/*") == 0 ||
			strcmp(pszAcceptValue, "text/*") == 0 ||
			strcmp(pszAcceptValue, "text/xml") == 0 ||
			strcmp(pszAcceptValue, "application/*") == 0 ||
			strcmp(pszAcceptValue, "application/xml") == 0 )
			return TRUE;
	}

	// This is not a simple header, it probably contains a list of acceptable media types
	// with a qvalue for each of them.
	// So do the parsing
	//====================================================================================

	// Do the media-type matching.
	// All we do here is to see that there is atleast on of the above 4 media-type values
	// with a q-value greater than 0
	CAcceptHeaderIterator	ali;
	LPCSTR	pszMediaType = NULL;
	DOUBLE dbQValue = 0;
	HRESULT sc = ali.ScInit(pszAcceptValue);
	if (SUCCEEDED(sc))
	{
		// Get the media type from the iterator
		//
		while(SUCCEEDED(ali.ScGetNextAcceptToken(&pszMediaType, &dbQValue)))
		{
			// See if it one of the 4 types we're interested in
			if(strcmp(pszMediaType, "*/*") == 0 ||
				strcmp(pszMediaType, "text/*") == 0 ||
				strcmp(pszMediaType, "text/xml") == 0 ||
				strcmp(pszMediaType, "application/*") == 0 ||
				strcmp(pszMediaType, "application/xml") == 0 )
			{
				if(dbQValue > 0.0)
					return TRUE;
			}
		}
	}
	return FALSE;
}

static BOOLEAN CheckAcceptCharsetHeader(LPCSTR pszAcceptValue)
{
	// Check to see if it begins with one of the following substrings
	//	1. *
	//	2. utf-8
	//====================================================================================
	if(pszAcceptValue)
	{
		if(strcmp(pszAcceptValue, "*") == 0 ||
			strcmp(pszAcceptValue, "utf-8") == 0 )
			return TRUE;
	}

	// This is not a simple header, it probably contains a list of acceptable charset types
	// with a qvalue for each of them.
	// So do the parsing
	//====================================================================================

	// All we do here is to see that there is atleast on of the above 2 charset values
	// with a q-value greater than 0
	CAcceptHeaderIterator	ali;
	LPCSTR	pszCharset = NULL;
	DOUBLE dbQValue = 0;
	HRESULT sc = ali.ScInit(pszAcceptValue);
	if (SUCCEEDED(sc))
	{
		// Get the charset from the iterator
		//
		while(SUCCEEDED(ali.ScGetNextAcceptToken(&pszCharset, &dbQValue)))
		{
			// See if it one of the 2 types we're interested in
			if(strcmp(pszAcceptValue, "*") == 0 ||
				strcmp(pszAcceptValue, "utf-8") == 0 )
			{
				if(dbQValue > 0.0)
					return TRUE;
			}
		}
	}
	return FALSE;
}

static BOOLEAN CheckAcceptEncodingHeader(LPCSTR pszAcceptValue)
{
	// Check to see if it begins with one of the following substrings
	//	1. *
	//	2. identity
	//====================================================================================
	if(pszAcceptValue)
	{
		if(strcmp(pszAcceptValue, "*") == 0 ||
			strcmp(pszAcceptValue, "identity") == 0 )
			return TRUE;
	}

	// This is not a simple header, it probably contains a list of acceptable encodings
	// with a qvalue for each of them.
	// So do the parsing
	//====================================================================================

	// All we do here is to see that there is atleast one of the above 2 encoding values
	// with a q-value greater than 0
	CAcceptHeaderIterator	ali;
	LPCSTR	pszCharset = NULL;
	DOUBLE dbQValue = 0;
	HRESULT sc = ali.ScInit(pszAcceptValue);
	if (SUCCEEDED(sc))
	{
		// Get the encoding from the iterator
		//
		while(SUCCEEDED(ali.ScGetNextAcceptToken(&pszCharset, &dbQValue)))
		{
			// See if it one of the 2 types we're interested in
			if(strcmp(pszAcceptValue, "*") == 0 ||
				strcmp(pszAcceptValue, "identity") == 0 )
			{
				if(dbQValue > 0.0)
					return TRUE;
			}
		}
	}
	return FALSE;
}

static BOOLEAN CheckAcceptLanguageHeader(LPCSTR pszAcceptValue)
{
	/*
	*	CIM Spec does not say what the server should do if it doesnt understand the clients language
	*	For now, we check to see if it is '*' or is a is in the range than begins with "es" - examples
	*	are "es", "es-us", "es-gb" etc.
	*/

	// Check to see if it begins with one of the following substrings
	//	1. *
	//	2. en
	//====================================================================================
	if(pszAcceptValue)
	{
		if(strcmp(pszAcceptValue, "*") == 0 ||
			strcmp(pszAcceptValue, "en") == 0 )
			return TRUE;
	}

	// This is not a simple header, it probably contains a list of acceptable language
	// with a qvalue for each of them.
	// So do the parsing
	//====================================================================================

	// All we do here is to see that there is atleast on of the above 2 language values
	// with a q-value greater than 0
	CAcceptHeaderIterator	ali;
	LPCSTR	pszCharset = NULL;
	DOUBLE dbQValue = 0;
	HRESULT sc = ali.ScInit(pszAcceptValue);
	if (SUCCEEDED(sc))
	{
		// Get the charset from the iterator
		//
		while(SUCCEEDED(ali.ScGetNextAcceptToken(&pszCharset, &dbQValue)))
		{
			// See if it one of the 2 types we're interested in
			if(strcmp(pszAcceptValue, "*") == 0 ||
				strcmp(pszAcceptValue, "en") == 0 )
				{
					if(dbQValue > 0.0)
						return TRUE;
				}
		}
	}
	return FALSE;
}


void SendHeaders(LPEXTENSION_CONTROL_BLOCK pECB, LPCSTR pszHeaders, DWORD dwHttpStatus)
{

	// Send an 405 : Method Not ALlowed response with a list of methods
	// supported in the Allow header
	HSE_SEND_HEADER_EX_INFO sendHeader;
	sendHeader.pszHeader = pszHeaders;
	sendHeader.cchHeader = (pszHeaders)? strlen(pszHeaders) : 0;
	sendHeader.fKeepConn = FALSE;

	switch(dwHttpStatus)
	{
		case 200:
			sendHeader.pszStatus = HTTP_STATUS_200; break;
		case 400:
			sendHeader.pszStatus = HTTP_ERR_400; break;
		case 405:
			sendHeader.pszStatus = HTTP_ERR_405; break;
		case 406:
			sendHeader.pszStatus = HTTP_ERR_406; break;
		case 415:
			sendHeader.pszStatus = HTTP_ERR_415; break;
		case 416:
			sendHeader.pszStatus = HTTP_ERR_416; break;
		case 501:
			sendHeader.pszStatus = HTTP_ERR_501; break;
		default:
		{
			// Just convert the DWORD to a string
			char pszStatus[24];
			sprintf(pszStatus, "%d", dwHttpStatus);
			sendHeader.pszStatus = pszStatus; break;
		}
	}

	sendHeader.cchStatus = strlen (sendHeader.pszStatus);
	pECB->ServerSupportFunction (pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER_EX,
									&sendHeader, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\objsec.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  OBJSEC.H
//
//  rajesh  3/25/2000   Created.
//
// This file implements a class that implements the IWbemRawSdAccessor interface
// It is just a simple wrapper around a BYTE array
//
//***************************************************************************

#ifdef WMI_XML_WHISTLER

#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <wbemcli.h>

#include "objsec.h"

extern long g_cObj;
CWbemRawSdAccessor::CWbemRawSdAccessor()
{
	m_cRef = 0;
    InterlockedIncrement(&g_cObj);
	m_pValue = NULL;
	m_uValueLen = 0;
}

//***************************************************************************
// HRESULT CWbemRawSdAccessor::QueryInterface
// long CWbemRawSdAccessor::AddRef
// long CWbemRawSdAccessor::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWbemRawSdAccessor::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWbemRawSdAccessor==riid)
		*ppv = reinterpret_cast<IWbemRawSdAccessor*>(this);

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWbemRawSdAccessor::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWbemRawSdAccessor::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}


//***************************************************************************
//
//  CWbemRawSdAccessor::~CWbemRawSdAccessor
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CWbemRawSdAccessor::~CWbemRawSdAccessor(void)
{
	delete [] m_pValue;
    InterlockedDecrement(&g_cObj);
}


HRESULT CWbemRawSdAccessor::Get(
        long lFlags,
        ULONG uBufSize,
        ULONG *puSDSize,
        BYTE *pSD
        )
{
	// See if they're just asking for memory requirements
	if(pSD == NULL)
	{
		*puSDSize = m_uValueLen;
		return S_OK;
	}

	// Check if there's enough space in the input buffer
	if(uBufSize <= m_uValueLen)
		return E_INVALIDARG;

	// Fill in the out arguments
	for(ULONG i=0; i<m_uValueLen; i++)
		pSD[i] = m_pValue[i];
	*puSDSize = *puSDSize;

	return S_OK;
}

HRESULT CWbemRawSdAccessor::Put(
        long lFlags,
        ULONG uBufSize,
        BYTE *pSD
        )
{
	// Delete the contents of the old buffer;
	delete [] m_pValue;
	m_pValue = NULL;

	HRESULT hr = E_FAIL;
	if(uBufSize)
	{
		if(m_pValue = new BYTE[uBufSize])
		{
			// Copy the contents
			for(ULONG i=0; i<uBufSize; i++)
				m_pValue[i] = pSD[i];

			// Copy the lenght
			m_uValueLen = uBufSize;

			hr = S_OK;
		}
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\objsec.h ===
#ifdef WMI_XML_WHISTLER

//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  OBJSEC.H
//
//  rajesh  3/25/2000   Created.
//
// This file defines a class that implements the IWbemRawSdAccessor interface
// It is just a simple wrapper around a BYTE array
//
//***************************************************************************

#ifndef WMI_XML_OBJ_SEC_H
#define WMI_XML_OBJ_SEC_H

// Just a simple class that implements IWbemRawSdAccessor
class CWbemRawSdAccessor : public IWbemRawSdAccessor
{
	BYTE *m_pValue;
	ULONG m_uValueLen;
	long					m_cRef; // COM Ref count

public:
	CWbemRawSdAccessor();
	virtual ~CWbemRawSdAccessor();

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// Methods of IWbemRawSdAccessor
    STDMETHODIMP Get(
        long lFlags,
        ULONG uBufSize,
        ULONG *puSDSize,
        BYTE *pSD
        );

    STDMETHODIMP Put(
        long lFlags,
        ULONG uBufSize,
        BYTE *pSD
        );

};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\parse.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  PARSE.H
//
//  rajesh  3/25/2000   Created.
//
// Contains the functions for parsing XML Requests that conform to the CIM DTD or WMI (Nova and WHistler)
// DTDs
//
//***************************************************************************

#ifndef CIM_XML_PARSE_H
#define CIM_XML_PARSE_H


// Creates a CCimHttpMessage object from a parsed XML request
BOOLEAN ParseXMLIntoCIMOperation(IXMLDOMNode *pDocument, 
		CCimHttpMessage **ppOperation, DWORD *pdwStatus,
		BOOLEAN bIsMpostRequest, BOOLEAN bIsMicrosoftWMIClient, 
		WMI_XML_HTTP_VERSION iHttpVersion, LPSTR *ppszCimError);

// This takes in a NAMESPACEPATH node and splits it up into a host and a namespace
HRESULT ParseNamespacePath(IXMLDOMNode *pNamespaceNode, BSTR *pstrHost, BSTR *pstrLocalNamespace);
// This takes in a LOCALNAMESPACEPATH node and creates a namespace from it
HRESULT ParseLocalNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrLocalNamespacePath);
// This takes an INSTANCENAME node and creates a WMI Object path from it
HRESULT ParseInstanceName(IXMLDOMNode *pNode, BSTR *pstrInstanceName);
// Takes a LOCALINSTANCEPATH element and gives its WMI object path representation
HRESULT ParseLocalInstancePath (IXMLDOMNode *pNode, BSTR *pstrValue);
// Takes an INSTANCEPATH node and gets its WMI object path representation
HRESULT ParseInstancePath (IXMLDOMNode *pNode, BSTR *pstrValue);
// This takes a CLASSNAME element and creates a WMI CLass Name from it
HRESULT ParseClassName (IXMLDOMNode *pNode,  BSTR *pstrValue);
// Given a LOCALCLASSPATH element, gets its WMI object path representation
HRESULT ParseLocalClassPath (IXMLDOMNode *pNode, BSTR *pstrValue);
// Takes a CLASSPATH element and gets its WMI object path representation
HRESULT ParseClassPath (IXMLDOMNode *pNode, BSTR *pstrValue);
// Given a VALUE.REFERENCE element, it creates a string representation of the element
// The string representation is the WMI object path representation
HRESULT ParseOneReferenceValue (IXMLDOMNode *pValueRef, BSTR *pstrValue);


// This takes an XML Document and gets the MESSAGE node from it
IXMLDOMNode *GetMessageNode (IXMLDOMDocument *pDocument, DWORD *pdwStatus, LPSTR *ppszCimErrorHeaders);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\parse.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  PARSE.CPP
//
//  rajesh  3/25/2000   Created.
//
// Contains the functions for parsing XML Requests that conform to the CIM DTD or WMI (Nova and WHistler)
// DTDs
//
//***************************************************************************

#include <windows.h>
#include <httpext.h>
#include <mshtml.h>
#include <msxml.h>

#include <objbase.h>
#include <initguid.h>
#include <wbemcli.h>

#include "provtempl.h"
#include "common.h"
#include "strings.h"
#include "errors.h"
#include "wmixmlop.h"
#include "wmiconv.h"
#include "request.h"
#include "whistler.h"

#include "xmlhelp.h"
#include "parse.h"


// Forward declarations of parsers for smaller constructs
// These are static functions and are used only in this file
//============================================================
static BOOLEAN ParseMultiReq(IXMLDOMNodeList *pReqList, CCimHttpMultiMessage *pMultiRequest, BSTR strID, BOOLEAN bIsMpostRequest, BOOLEAN bIsMicrosoftWMIClient, WMI_XML_HTTP_VERSION iHttpVersion, DWORD dwNumSimpleRequests);
static CCimHttpMessage * ParseSimpleReq(IXMLDOMNode *pNode, BSTR strID, BOOLEAN bIsMpostRequest, BOOLEAN bIsMicrosoftWMIClient, WMI_XML_HTTP_VERSION iHttpVersion);
static CCimHttpMessage * ParseIMethodCall(IXMLDOMNode *pMethodNode, BSTR strID);
static CCimHttpMessage * ParseMethodCall(IXMLDOMNode *pMethodNode, BSTR strID);


HRESULT ParseLongArgument(IXMLDOMNode *pNode, long *plArgVal)
{
	HRESULT hr = E_FAIL;
	BSTR strStringVal = NULL;
	if(SUCCEEDED(hr = pNode->get_text(&strStringVal)))
	{
		// Convert it to a long value
		*plArgVal = (long) wcstol (strStringVal, NULL, 0);
		SysFreeString(strStringVal);
	}
	return hr;
}


// Parse one key value
HRESULT ParseKeyValue(IXMLDOMNode *pNode, BSTR *ppszValue)
{
	HRESULT result = E_FAIL;
	BSTR strType = NULL;
	*ppszValue = NULL;

	// This is an optional attribute and the default is "string"
	BOOLEAN isString = TRUE;
	if(SUCCEEDED(GetBstrAttribute(pNode, VALUE_TYPE_ATTRIBUTE, &strType)))
	{
		if(_wcsicmp(strType, STRING_TYPE) != 0)  
		{
			isString = FALSE;
			SysFreeString(strType);
		}
	}

	if(isString) // Escape the appropriate characters and enclose it in double-quotes
	{
		LPWSTR pszReturnValue = NULL;
		BSTR strTemp = NULL;
		if(SUCCEEDED(result = pNode->get_text(&strTemp)))
		{
			BSTR strEscapedTemp = NULL;
			if(strEscapedTemp = EscapeSpecialCharacters(strTemp))
			{
				if(pszReturnValue = new WCHAR[wcslen(strEscapedTemp) + 3])
				{
					wcscpy(pszReturnValue, QUOTE_SIGN);
					wcscat(pszReturnValue, strEscapedTemp);
					wcscat(pszReturnValue, QUOTE_SIGN);
					if(!(*ppszValue = SysAllocString(pszReturnValue)))
						result = E_OUTOFMEMORY;
					delete [] pszReturnValue;
				}
				else
					result = E_OUTOFMEMORY;
				SysFreeString(strEscapedTemp);
			}
			else
				result = E_OUTOFMEMORY;
			SysFreeString(strTemp);
		}
	}
	else // BOOLEAN or Numeric
	{
		result = pNode->get_text(ppszValue);
	}
	return result;
}

// Parse one value The only difference between this and ParseKeyValue is that strings are not enclsed in quotes
HRESULT ParseValue(IXMLDOMNode *pNode, BSTR *ppszValue)
{
	HRESULT result = E_FAIL;
	BSTR strType = NULL;
	*ppszValue = NULL;
	BOOLEAN isString = FALSE;
	if(SUCCEEDED(result = GetBstrAttribute(pNode, VALUE_TYPE_ATTRIBUTE, &strType)))
	{
		if(_wcsicmp(strType, STRING_TYPE) == 0) // Enclose it in double-quotes
			isString = TRUE;
		SysFreeString(strType);
	}
	else // It's a string by default
	{
		isString = TRUE;
	}

	if(isString) // Escape the appropriate characters and enclose it in double-quotes
	{
		LPWSTR pszReturnValue = NULL;
		BSTR strTemp = NULL;
		if(SUCCEEDED(result = pNode->get_text(&strTemp)))
		{
			if(!(*ppszValue = EscapeSpecialCharacters(strTemp)))
				result = E_OUTOFMEMORY;
			SysFreeString(strTemp);
		}
	}
	else // BOOLEAN or Numeric
	{
		result = pNode->get_text(ppszValue);
	}
	return result;
}

// Parse one key binding. Return <propName>=<value>
// The key binding is either a KEYVALUE or a VALUE.REFERENCE tag
HRESULT ParseOneKeyBinding(IXMLDOMNode *pNode, LPWSTR *ppszValue)
{

	HRESULT result = E_FAIL;
	*ppszValue = NULL;

	// First get the property name
	BSTR strPropertyName = NULL;
	if(SUCCEEDED(result = GetBstrAttribute(pNode, NAME_ATTRIBUTE, &strPropertyName)))
	{
		// See if the child is a KEYVALUE or VALUE.REFERENCE
		IXMLDOMNode *pChildNode = NULL;
		if(SUCCEEDED(pNode->get_firstChild(&pChildNode)) && pChildNode)
		{
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pChildNode->get_nodeName(&strNodeName)))
			{
				// Look ahead
				if(_wcsicmp(strNodeName, KEYVALUE_TAG) == 0)
				{
					BSTR strValue = NULL;
					if(SUCCEEDED(result = ParseKeyValue(pChildNode, &strValue)))
					{
						// COncatenate them with an '=' inbetween
						if(*ppszValue = new WCHAR [ wcslen(strPropertyName) + wcslen(strValue) + 2])
						{
							wcscpy(*ppszValue, strPropertyName);
							wcscat(*ppszValue, EQUALS_SIGN);
							wcscat(*ppszValue, strValue);
						}
						else
							result = E_OUTOFMEMORY;

						SysFreeString(strValue);
					}
				}
				else if (_wcsicmp(strNodeName, VALUEREFERENCE_TAG) == 0)
				{
					BSTR strValue = NULL;
					if(SUCCEEDED(result = ParseOneReferenceValue (pChildNode, &strValue)))
					{
						if(*ppszValue = new WCHAR [ wcslen(strValue) + 1])
							wcscpy(*ppszValue, strValue);
						else
							result = E_OUTOFMEMORY;
						SysFreeString(strValue);
					}
				}
				SysFreeString(strNodeName);
			}
			pChildNode->Release();
		}
		SysFreeString(strPropertyName);
	}
	return result;
}

HRESULT ParseClassName (IXMLDOMNode *pNode,  BSTR *pstrValue)
{
	HRESULT hr = WBEM_E_FAILED;

	*pstrValue = NULL;
	if(pNode && SUCCEEDED(GetBstrAttribute(pNode, NAME_ATTRIBUTE, pstrValue)))
		hr = S_OK;
	return hr;
}

// Given a VALUE.REFERENCE element, it creates a string representation of the element
// The string representation is the WMI object path representation
HRESULT ParseOneReferenceValue (IXMLDOMNode *pValueRef, BSTR *pstrValue)
{
	HRESULT hr = E_FAIL;

	// Let's look at the child of the VALUE.REFERENCE tag
	IXMLDOMNode *pChild = NULL;
	if (SUCCEEDED(pValueRef->get_firstChild (&pChild)) && pChild)
	{
		// Next node could be a CLASSPATH, LOCALCLASSPATH, INSTANCEPATH,
		// LOCALINSTANCEPATH, CLASSNAME or INSTANCENAME
		// or even a VALUE (for Scoped and UMI paths)
		BSTR strNodeName = NULL;

		if(SUCCEEDED(pChild->get_nodeName(&strNodeName)))
		{
			if (_wcsicmp(strNodeName, CLASSNAME_TAG) == 0)
			{
				hr = ParseClassName (pChild, pstrValue);
			}
			else if (_wcsicmp(strNodeName, LOCALCLASSPATH_TAG) == 0)
			{
				hr = ParseLocalClassPath (pChild, pstrValue);
			}
			else if (_wcsicmp(strNodeName, CLASSPATH_TAG) == 0)
			{
				hr = ParseClassPath (pChild, pstrValue);
			}
			else if (_wcsicmp(strNodeName, INSTANCENAME_TAG) == 0)
			{
				hr = ParseInstanceName (pChild, pstrValue);
			}
			else if (_wcsicmp(strNodeName, LOCALINSTANCEPATH_TAG) == 0)
			{
				hr = ParseLocalInstancePath (pChild, pstrValue);
			}
			else if (_wcsicmp(strNodeName, INSTANCEPATH_TAG) == 0)
			{
				hr = ParseInstancePath (pChild, pstrValue);
			}
			else if (_wcsicmp(strNodeName, VALUE_TAG) == 0)
			{
				// Just get its contents
				// RAJESHR - what if it is escaped CDATA? We need to unescape it
				hr = pChild->get_text(pstrValue);
			}

			SysFreeString(strNodeName);
		}
		pChild->Release();
	}

	return hr;
}


// Given a LOCALCLASSPATH element, gets its WMI object path representation
HRESULT ParseLocalClassPath (IXMLDOMNode *pNode, BSTR *pstrValue)
{
	HRESULT hr = WBEM_E_FAILED;

	// Expecting (LOCALNAMESPACEPATH followed by CLASSNAME
	IXMLDOMNodeList *pNodeList = NULL;

	if (pNode && SUCCEEDED(pNode->get_childNodes (&pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pLocalNSPathNode = NULL;

		// Next node should be a LOCALNAMESPACEPATH
		if (SUCCEEDED(pNodeList->nextNode (&pLocalNSPathNode)) && pLocalNSPathNode)
		{
			BSTR strNSNodeName = NULL;

			if (SUCCEEDED(pLocalNSPathNode->get_nodeName(&strNSNodeName)) &&
				strNSNodeName && (_wcsicmp(strNSNodeName, LOCALNAMESPACEPATH_TAG) == 0))
			{
				BSTR strLocalNamespace = NULL;
				ParseLocalNamespacePath(pLocalNSPathNode, &strLocalNamespace);

				// Next node should be the classname
				IXMLDOMNode *pClassNameNode = NULL;

				if (SUCCEEDED(pNodeList->nextNode (&pClassNameNode)) && pClassNameNode)
				{
					BSTR strNSClassName = NULL;

					if (SUCCEEDED(pClassNameNode->get_nodeName(&strNSClassName)) &&
							strNSClassName && (_wcsicmp(strNSClassName, CLASSNAME_TAG) == 0))
					{
						BSTR strClassName = NULL;

						if (SUCCEEDED(GetBstrAttribute (pClassNameNode,
											NAME_ATTRIBUTE, &strClassName)))
						{
							// Phew - finally we have all the info!

							LPWSTR pPath = NULL;
							if(pPath = new WCHAR [wcslen(strLocalNamespace)
									+ wcslen(strClassName) + 2])
							{
								wcscpy (pPath, strLocalNamespace);
								wcscat (pPath, L":");
								wcscat (pPath, strClassName);

								*pstrValue = NULL;
								if(*pstrValue = SysAllocString (pPath))
									hr = S_OK;
								else
									hr = E_OUTOFMEMORY;
								delete [] pPath;
							}
							else
								hr = E_OUTOFMEMORY;
							SysFreeString (strClassName);
						}
					}

					pClassNameNode->Release ();
					SysFreeString (strNSClassName);
				}

				SysFreeString (strLocalNamespace);
				SysFreeString (strNSNodeName);
			}

			pLocalNSPathNode->Release ();
		}

		pNodeList->Release ();
	}

	return hr;
}

// Takes a CLASSPATH element and gets its WMI object path representation
HRESULT ParseClassPath (IXMLDOMNode *pNode, BSTR *pstrValue)
{
	HRESULT hr = WBEM_E_FAILED;

	// Expecting (NAMESPACEPATH followed by CLASSNAME
	IXMLDOMNodeList *pNodeList = NULL;

	if (pNode && SUCCEEDED(pNode->get_childNodes (&pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pNSPathNode = NULL;

		// Next node should be a NAMESPACEPATH
		if (SUCCEEDED(pNodeList->nextNode (&pNSPathNode)) && pNSPathNode)
		{
			BSTR strNSNodeName = NULL;

			if (SUCCEEDED(pNSPathNode->get_nodeName(&strNSNodeName)) &&
					strNSNodeName && (_wcsicmp(strNSNodeName, NAMESPACEPATH_TAG) == 0))
			{
				BSTR strHost = NULL;
				BSTR strNamespace = NULL;

				if (SUCCEEDED (hr = ParseNamespacePath(pNSPathNode, &strHost, &strNamespace)))
				{
					// Next node should be the CLASSNAME
					IXMLDOMNode *pClassNameNode = NULL;

					if (SUCCEEDED(pNodeList->nextNode (&pClassNameNode)) && pClassNameNode)
					{
						BSTR strNSClassName = NULL;

						if (SUCCEEDED(pClassNameNode->get_nodeName(&strNSClassName)) &&
							strNSClassName && (_wcsicmp(strNSClassName, CLASSNAME_TAG) == 0))
						{
							BSTR strClassName = NULL;

							if (SUCCEEDED(GetBstrAttribute (pClassNameNode,
											NAME_ATTRIBUTE, &strClassName)))
							{
								// Phew - finally we have all the info!

								LPWSTR pPath = NULL;
								if(pPath = new WCHAR [wcslen(strHost)
										+ wcslen(strNamespace) + wcslen(strClassName) + 5])
								{
									wcscpy (pPath, L"\\\\");
									wcscat (pPath, strHost);
									wcscat (pPath, L"\\");
									wcscat (pPath, strNamespace);
									wcscat (pPath, L":");
									wcscat (pPath, strClassName);

									*pstrValue = NULL;
									if(*pstrValue = SysAllocString (pPath))
										hr = S_OK;
									else
										hr = E_OUTOFMEMORY;
									delete [] pPath;
								}
								else
									hr = E_OUTOFMEMORY;

								SysFreeString (strClassName);
							}
							SysFreeString (strNSClassName);
						}

						pClassNameNode->Release ();
					}

					SysFreeString (strHost);
					SysFreeString (strNamespace);
				}

				SysFreeString (strNSNodeName);
			}
			pNSPathNode->Release ();
		}
		pNodeList->Release ();
	}

	return hr;
}


// Parse an instance nameest
HRESULT ParseKeyBinding(IXMLDOMNode *pNode, BSTR strClassName, BSTR *pstrInstanceName)
{
	HRESULT result = E_FAIL;

	LPWSTR pszInstanceName = NULL;
	if(!(pszInstanceName = new WCHAR [ wcslen(strClassName) + 2]))
		return E_OUTOFMEMORY;

	wcscpy(pszInstanceName, strClassName);
	wcscat(pszInstanceName, DOT_SIGN);

	// Go thru each of the key  bindings
	//=======================================================
	IXMLDOMNodeList *pBindings = NULL;
	if(SUCCEEDED(result = pNode->get_childNodes(&pBindings)))
	{
		IXMLDOMNode *pNextBinding = NULL;

		while(SUCCEEDED(result = pBindings->nextNode(&pNextBinding)) && pNextBinding)
		{
			LPWSTR pszNextValue = NULL;
			if(result = SUCCEEDED(ParseOneKeyBinding(pNextBinding, &pszNextValue)))
			{
				LPWSTR pTemp = NULL;
				if(pTemp = new WCHAR [wcslen(pszInstanceName) + wcslen(pszNextValue) + 2])
				{
					wcscpy(pTemp, pszInstanceName);
					wcscat(pTemp, pszNextValue);
					wcscat(pTemp, COMMA_SIGN);

					delete [] pszInstanceName;
					delete [] pszNextValue;
					pszInstanceName = pTemp;
				}
				else
					result = E_OUTOFMEMORY;
			}
			pNextBinding->Release();
			pNextBinding = NULL;

			if(FAILED(result))
				break;
		}
		pBindings->Release();
	}

	if(SUCCEEDED(result))
	{
		// Get rid of the last comma
		pszInstanceName[wcslen(pszInstanceName) - 1] = NULL;
		if(!(*pstrInstanceName = SysAllocString(pszInstanceName)))
			result = E_OUTOFMEMORY;
	}
	else
		*pstrInstanceName = NULL;

	delete [] pszInstanceName;
	return result;

}

HRESULT ParseLocalNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrLocalNamespacePath)
{
	// Go thru the children collecting the NAME attribute and concatenating
	// This requires 2 passes since we dont know the length
	//=============================================================

	DWORD dwLength=0;
	*pstrLocalNamespacePath = NULL;
	HRESULT result = E_FAIL;

	IXMLDOMNodeList *pChildren = NULL;
	if(SUCCEEDED(result = pLocalNamespaceNode->get_childNodes(&pChildren)))
	{
		IXMLDOMNode *pNextChild = NULL;
		while(SUCCEEDED(pChildren->nextNode(&pNextChild)) && pNextChild)
		{
			BSTR strAttributeValue = NULL;
			if(SUCCEEDED(GetBstrAttribute(pNextChild, NAME_ATTRIBUTE, &strAttributeValue)))
			{
				dwLength += wcslen(strAttributeValue);
				dwLength ++; // For the back slash
				SysFreeString(strAttributeValue);
			}

			pNextChild->Release();
			pNextChild = NULL;
		}

		// Allocate memory
		LPWSTR pszNamespaceValue = NULL;
		if(pszNamespaceValue = new WCHAR[dwLength + 1])
		{
			pszNamespaceValue[0] = 0;

			// Once more
			pNextChild = NULL;
			pChildren->reset();
			while(SUCCEEDED(pChildren->nextNode(&pNextChild)) && pNextChild)
			{
				BSTR strAttributeValue = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextChild, NAME_ATTRIBUTE, &strAttributeValue)))
				{
					wcscat(pszNamespaceValue, strAttributeValue);
					wcscat(pszNamespaceValue, BACK_SLASH_WSTR);
					SysFreeString(strAttributeValue);
				}

				pNextChild->Release();
				pNextChild = NULL;
			}

			// Remove the last back slash
			pszNamespaceValue[dwLength-1] = NULL;
			if(!(*pstrLocalNamespacePath = SysAllocString(pszNamespaceValue)))
				result = E_OUTOFMEMORY;

			delete [] pszNamespaceValue;
		}
		else
			result = E_OUTOFMEMORY;

		pChildren->Release();
	}

	return result;
}

HRESULT ParseNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrHost, BSTR *pstrLocalNamespace)
{
	HRESULT result = E_FAIL;

	*pstrHost = NULL;
	*pstrLocalNamespace = NULL;

	// Get the HOST name first
	IXMLDOMNode *pFirstNode = NULL, *pSecondNode = NULL;
	if(SUCCEEDED(pLocalNamespaceNode->get_firstChild(&pFirstNode)) && pFirstNode)
	{
		// Get the Namespace part
		if(SUCCEEDED (pFirstNode->get_text(pstrHost)))
		{
			if(SUCCEEDED(pLocalNamespaceNode->get_lastChild(&pSecondNode)))
			{
				// Get the instance path
				if(SUCCEEDED(ParseLocalNamespacePath(pSecondNode, pstrLocalNamespace)))
				{
					result = S_OK;
				}
				pSecondNode->Release();
			}
		}
		pFirstNode->Release();
	}

	if(FAILED(result))
	{
		SysFreeString(*pstrHost);
		*pstrHost = NULL;
	}

	return result;
}

// Parse an instance name
HRESULT ParseInstanceName(IXMLDOMNode *pNode, BSTR *pstrInstanceName)
{
	HRESULT result = E_FAIL;

	// First get the class name
	BSTR strClassName = NULL;
	if(SUCCEEDED(result = GetBstrAttribute(pNode, CLASS_NAME_ATTRIBUTE, &strClassName)))
	{
		// See if the child is a KEYBINDING or KEYVALUE or 
		IXMLDOMNode *pChildNode = NULL;
		if(SUCCEEDED(result = pNode->get_firstChild(&pChildNode)) && pChildNode)
		{
			BSTR strNodeName = NULL;
			if(SUCCEEDED(result = pChildNode->get_nodeName(&strNodeName)))
			{
				// Look ahead
				if(_wcsicmp(strNodeName, KEYBINDING_TAG) == 0)
				{
					result = ParseKeyBinding(pNode, strClassName, pstrInstanceName);
				}
				else if (_wcsicmp(strNodeName, KEYVALUE_TAG) == 0)
				{
					BSTR strKeyValue = NULL;
					if(SUCCEEDED(result = ParseKeyValue(pNode, &strKeyValue)))
					{
						LPWSTR pszInstanceName = NULL;
						if(pszInstanceName = new WCHAR[wcslen(strClassName) + wcslen(strKeyValue) + 2])
						{
							wcscpy(pszInstanceName, strClassName);
							wcscat(pszInstanceName, EQUALS_SIGN);
							wcscat(pszInstanceName, strKeyValue);
							if(!(*pstrInstanceName = SysAllocString(pszInstanceName)) )
								result = E_OUTOFMEMORY;

							delete [] pszInstanceName;
						}
						else
							result = E_OUTOFMEMORY;

						SysFreeString(strKeyValue);
					}
				}
				SysFreeString(strNodeName);
			}
			pChildNode->Release();
		}
		SysFreeString(strClassName);
	}
	return result;
}

// Takes a LOCALINSTANCEPATH element and gives its WMI object path representation
HRESULT ParseLocalInstancePath (IXMLDOMNode *pNode, BSTR *pstrValue)
{
	HRESULT hr = WBEM_E_FAILED;

	// Expecting (LOCALNAMESPACEPATH followed by INSTANCENAME
	IXMLDOMNodeList *pNodeList = NULL;

	if (pNode && SUCCEEDED(pNode->get_childNodes (&pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pLocalNSPathNode = NULL;

		// Next node should be a LOCALNAMESPACEPATH
		if (SUCCEEDED(pNodeList->nextNode (&pLocalNSPathNode)) && pLocalNSPathNode)
		{
			BSTR strNSNodeName = NULL;

			if (SUCCEEDED(pLocalNSPathNode->get_nodeName(&strNSNodeName)) &&
					strNSNodeName && (_wcsicmp(strNSNodeName, LOCALNAMESPACEPATH_TAG) == 0))
			{
				BSTR strLocalNamespace = NULL;
				ParseLocalNamespacePath(pLocalNSPathNode, &strLocalNamespace);

				// Next node should be the INSTANCENAME
				IXMLDOMNode *pInstanceNameNode = NULL;

				if (SUCCEEDED(pNodeList->nextNode (&pInstanceNameNode)) && pInstanceNameNode)
				{
					BSTR strNSInstanceName = NULL;

					if (SUCCEEDED(pInstanceNameNode->get_nodeName(&strNSInstanceName)) &&
							strNSInstanceName && (_wcsicmp(strNSInstanceName, INSTANCENAME_TAG) == 0))
					{
						BSTR strInstanceName = NULL;

						if (SUCCEEDED(hr = ParseInstanceName (pInstanceNameNode,
											&strInstanceName)))
						{
							// Phew - finally we have all the info!
							LPWSTR pPath = NULL;
							if(pPath = new WCHAR [wcslen(strLocalNamespace)
									+ wcslen(strInstanceName) + 2])
							{
								wcscpy (pPath, strLocalNamespace);
								wcscat (pPath, L":");
								wcscat (pPath, strInstanceName);

								*pstrValue = NULL;
								if(*pstrValue = SysAllocString (pPath))
									hr = S_OK;
								else
									hr = E_OUTOFMEMORY;

								delete [] pPath;
							}
							else
								hr = E_OUTOFMEMORY;
							SysFreeString (strInstanceName);
						}

						SysFreeString (strNSInstanceName);
					}
					pInstanceNameNode->Release ();
				}

				SysFreeString (strLocalNamespace);
				SysFreeString (strNSNodeName);
			}

			pLocalNSPathNode->Release ();
		}
		pNodeList->Release ();
	}

	return hr;
}
	
// Parse an instance name
HRESULT ParseLocalInstancePathIntoNsAndInstName(IXMLDOMNode *pNode, BSTR *pstrNamespace, BSTR *pstrInstanceName)
{
	HRESULT result = E_FAIL;

	// See if the child is a KEYBINDING or KEYVALUE or KEYREFERENCE
	IXMLDOMNode *pFirstNode, *pSecondNode = NULL;
	if(SUCCEEDED(result = pNode->get_firstChild(&pFirstNode)) && pFirstNode)
	{
		// Get the Namespace part
		if(SUCCEEDED(result = ParseLocalNamespacePath(pFirstNode, pstrNamespace)))
		{
			if(SUCCEEDED(result = pNode->get_lastChild(&pSecondNode)))
			{
				// Get the instance path
				if(SUCCEEDED(result = ParseInstanceName(pSecondNode, pstrInstanceName)))
				{
				}
				pSecondNode->Release();
			}

			if(FAILED(result))
			{
				SysFreeString(*pstrNamespace);
				*pstrNamespace = NULL;
			}
		}
		pFirstNode->Release();
	}

	return result;
}

// Takes an INSTANCEPATH node and gets its WMI object path representation
HRESULT ParseInstancePath (IXMLDOMNode *pNode, BSTR *pstrValue)
{
	HRESULT hr = WBEM_E_FAILED;

	// Expecting NAMESPACEPATH followed by INSTANCENAME
	IXMLDOMNodeList *pNodeList = NULL;

	if (pNode && SUCCEEDED(pNode->get_childNodes (&pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pNSPathNode = NULL;

		// Next node should be a NAMESPACEPATH
		if (SUCCEEDED(pNodeList->nextNode (&pNSPathNode)) && pNSPathNode)
		{
			BSTR strNSNodeName = NULL;

			if (SUCCEEDED(pNSPathNode->get_nodeName(&strNSNodeName)) &&
					strNSNodeName && (_wcsicmp(strNSNodeName, NAMESPACEPATH_TAG) == 0))
			{
				BSTR strHost = NULL;
				BSTR strNamespace = NULL;

				if (SUCCEEDED (hr = ParseNamespacePath(pNSPathNode, &strHost, &strNamespace)))
				{
					// Next node should be the INSTANCENAME
					IXMLDOMNode *pInstanceNameNode = NULL;

					if (SUCCEEDED(pNodeList->nextNode (&pInstanceNameNode)) && pInstanceNameNode)
					{
						BSTR strNSInstanceName = NULL;

						if (SUCCEEDED(pInstanceNameNode->get_nodeName(&strNSInstanceName)) &&
							strNSInstanceName && (_wcsicmp(strNSInstanceName, INSTANCENAME_TAG) == 0))
						{
							BSTR strInstanceName = NULL;

							if (SUCCEEDED(hr = ParseInstanceName (pInstanceNameNode,
											&strInstanceName)))
							{
								// Phew - finally we have all the info!

								LPWSTR pPath = NULL;
								if(pPath = new WCHAR [wcslen(strHost)
										+ wcslen(strNamespace) + wcslen(strInstanceName) + 5])
								{
									wcscpy (pPath, L"\\\\");
									wcscat (pPath, strHost);
									wcscat (pPath, L"\\");
									wcscat (pPath, strNamespace);
									wcscat (pPath, L":");
									wcscat (pPath, strInstanceName);

									*pstrValue = NULL;
									if(*pstrValue = SysAllocString (pPath))
										hr = S_OK;
									else
										hr = E_OUTOFMEMORY;

									delete [] pPath;
								}
								else
									hr = E_OUTOFMEMORY;

								SysFreeString (strInstanceName);
							}
							SysFreeString (strNSInstanceName);
						}

						pInstanceNameNode->Release ();
					}

					SysFreeString (strHost);
					SysFreeString (strNamespace);
				}

				SysFreeString (strNSNodeName);
			}
			pNSPathNode->Release ();
		}
		pNodeList->Release ();
	}

	return hr;
}
	
// Parse an class name
HRESULT ParseLocalClassPathAsNsAndClass(IXMLDOMNode *pNode, BSTR *pstrNamespace, BSTR *pstrClassPath)
{
	HRESULT result = E_FAIL;

	// See if the child is a KEYBINDING or KEYVALUE or KEYREFERENCE
	IXMLDOMNode *pFirstNode, *pSecondNode = NULL;
	if(SUCCEEDED(result = pNode->get_firstChild(&pFirstNode)) && pFirstNode)
	{
		// Get the Namespace part
		if(SUCCEEDED(result = ParseLocalNamespacePath(pFirstNode, pstrNamespace)))
		{
			if(SUCCEEDED(result = pNode->get_lastChild(&pSecondNode)))
			{
				// Get the class name
				if(SUCCEEDED(result = GetBstrAttribute(pSecondNode, NAME_ATTRIBUTE, pstrClassPath)))
				{
				}
				pSecondNode->Release();
			}

			if(FAILED(result))
			{
				SysFreeString(*pstrNamespace);
				*pstrNamespace = NULL;
			}
		}
		pFirstNode->Release();
	}

	return result;
}

// Parse an instance path
HRESULT ParseInstancePath(IXMLDOMNode *pNode, BSTR *pstrHostName, BSTR *pstrNamespace, BSTR *pstrInstancePath)
{
	HRESULT result = E_FAIL;

	// Get the Namespacepath followed by the instance name
	IXMLDOMNode *pFirstNode, *pSecondNode = NULL;
	if(SUCCEEDED(result = pNode->get_firstChild(&pFirstNode)) && pFirstNode)
	{
		// Get the Namespace part
		if(SUCCEEDED(result = ParseNamespacePath(pFirstNode, pstrHostName, pstrNamespace)))
		{
			if(SUCCEEDED(result = pNode->get_lastChild(&pSecondNode)))
			{
				// Get the instance path
				if(SUCCEEDED(result = ParseInstanceName(pSecondNode, pstrInstancePath)))
				{
				}
				pSecondNode->Release();
			}

			if(FAILED(result))
			{
				SysFreeString(*pstrHostName);
				SysFreeString(*pstrNamespace);
				*pstrHostName = NULL;
				*pstrNamespace = NULL;
			}
		}
		pFirstNode->Release();
	}

	return result;
}
	

// Parse a VALUE.ARRAY For now, assume that it's an array of strings
HRESULT ParseValueArray(IXMLDOMNode *pNode, BSTR **ppstrPropertyList, DWORD *pdwCount)
{
	HRESULT result = E_FAIL;
	*ppstrPropertyList = NULL;

	// Go thru each of the VALUE nodes
	//=======================================================
	IXMLDOMNodeList *pList = NULL;
	if(SUCCEEDED(result = pNode->get_childNodes(&pList)))
	{
		*pdwCount = 0;
		long lCount = 0;
		pList->get_length(&lCount);
		*pdwCount = lCount;

		// Allocate memory
		if(*ppstrPropertyList = new BSTR [*pdwCount])
		{
			DWORD i=0;
			IXMLDOMNode *pNextProperty = NULL;
			while(SUCCEEDED(pList->nextNode(&pNextProperty)) && pNextProperty)
			{
				// Get the string in the VALUE
				BSTR strNextName = NULL;
				if(SUCCEEDED(ParseValue(pNextProperty,&((*ppstrPropertyList)[i]))))
				{
				}
				else
					ppstrPropertyList[i] = NULL;

				pNextProperty->Release();
				pNextProperty = NULL;
				i++;
			}
		}
		else
			result = E_OUTOFMEMORY;

		pList->Release();
	}
	return result;
}

// Parse PARAMVALUE.ARRAY in a propertylist
HRESULT ParsePropertyList(IXMLDOMNode *pNode, BSTR **ppstrPropertyList, DWORD *pdwCount)
{
	// See if the child is a VALUE.ARRAY
	HRESULT result = E_FAIL;
	*ppstrPropertyList = NULL;

	// Get the Namespacepath followed by the instance name
	IXMLDOMNode *pFirstNode = NULL;
	if(SUCCEEDED(result = pNode->get_firstChild(&pFirstNode)) && pFirstNode)
	{
		// THis should be a VALUE.ARRAY
		if(SUCCEEDED(result = ParseValueArray(pFirstNode, ppstrPropertyList, pdwCount)))
		{
		}
		pFirstNode->Release();
	}

	return result;
}

// Parse PARAMVALUE - the result is the child of this tag in ppValue and the name
// attribute of PARAMVALUE in ppszParamName
HRESULT ParseParamValue(IXMLDOMNode *pNode, BSTR *ppszParamName, IXMLDOMNode **ppValue)
{
	HRESULT result = E_FAIL;
	*ppValue = NULL;
	// See if it has a child element which is 
	// (VALUE|VALUE.REFERENCE|VALUE.ARRAY|VALUE.REFARRAY|VALUE.OBJECT|VALUE.OBJECTARRAY)
	if(SUCCEEDED(result = pNode->get_firstChild(ppValue)) && (*ppValue))
	{
		BSTR strChildName = NULL;
		if(SUCCEEDED(result = (*ppValue)->get_nodeName(&strChildName)))
		{
			if(_wcsicmp(strChildName, VALUE_TAG) == 0 ||
				_wcsicmp(strChildName, VALUEARRAY_TAG) == 0 ||
				_wcsicmp(strChildName, VALUEOBJECT_TAG) == 0 ||
				_wcsicmp(strChildName, VALUEREFERENCE_TAG) == 0 ||
				_wcsicmp(strChildName, VALUEOBJECTARRAY_TAG) == 0 ||
				_wcsicmp(strChildName, VALUEREFARRAY_TAG) == 0 )
			{
				if(SUCCEEDED(result = GetBstrAttribute(pNode, NAME_ATTRIBUTE, ppszParamName)))
				{
					(*ppValue)->AddRef();
				}
			}
			SysFreeString(strChildName);
		}
		(*ppValue)->Release();
	}

	if(FAILED(result) && (*ppValue))
	{
		(*ppValue)->Release();
		*ppValue = NULL;
	}

	return result;
}

// Parse a PARAMVVALUE.INSTNAME
HRESULT ParseParamValueInstName(IXMLDOMNode *pNode, BSTR *pstrInstanceName)
{
	HRESULT result = E_FAIL;
	IXMLDOMNode *pChildNode = NULL;
	if(SUCCEEDED(result = pNode->get_firstChild(&pChildNode)) && pChildNode)
	{
		result = ParseInstanceName(pChildNode, pstrInstanceName);
		pChildNode->Release();
	}
	return result;
}

// Parse a Get Class request
CCimHttpGetClass * ParseGetClassMethod (
	IXMLDOMNode *pNode, 
	BSTR strID)
{
	CCimHttpGetClass *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a GetClass reques
	//=======================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		// String values of the parameters
		BSTR strLocalNamespace = NULL;
		BSTR strClassName = NULL;
		BSTR strLocalOnlyValue = NULL;
		BSTR strIncludeQualifiers = NULL;
		BSTR strIncludeClassOrigin = NULL;
		BSTR *strPropertyList = NULL;
		DWORD dwPropCount = 0;

		// Set the optional parameters to their defaults
		BOOLEAN bLocalsOnly = TRUE;
		BOOLEAN bIncludeQualifiers = TRUE;
		BOOLEAN bIncludeClassOrigin = FALSE;


		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;

					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, CLASS_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strClassName);
								pParamValue->Release ();
							}
						}
						else if(_wcsicmp(strParamName, LOCAL_ONLY_PARAM) == 0)
						{
							pNextParam->get_text(&strLocalOnlyValue);
						}
						else if(_wcsicmp(strParamName, INCLUDE_QUALIFIERS_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeQualifiers);
						}
						else if(_wcsicmp(strParamName, INCLUDE_CLASS_ORIGIN_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeClassOrigin);
						}
						else if(_wcsicmp(strParamName, PROPERTY_LIST_PARAM) == 0)
						{
							ParsePropertyList(pNextParam, &strPropertyList, &dwPropCount);
						}

						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		// Sort out the parameters created above
		if(strLocalOnlyValue && _wcsicmp(strLocalOnlyValue, FALSE_WSTR) == 0)
			bLocalsOnly = FALSE;
		if(strIncludeQualifiers && _wcsicmp(strIncludeQualifiers, FALSE_WSTR) == 0)
			bIncludeQualifiers = FALSE;
		if(strIncludeClassOrigin && _wcsicmp(strIncludeClassOrigin, TRUE_WSTR) == 0)
			bIncludeClassOrigin = TRUE;

		// We only free those that are not needed
		// The other pointers get copied by the contructor
		SysFreeString(strLocalOnlyValue);
		SysFreeString(strIncludeQualifiers);
		SysFreeString(strIncludeClassOrigin);
		pReturnValue = new CCimHttpGetClass(strClassName, strPropertyList, dwPropCount, bLocalsOnly, bIncludeQualifiers, bIncludeClassOrigin, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse a Create Class request
CCimHttpCreateClass * ParseCreateClassMethod (
	IXMLDOMNode *pNode, 
	BSTR strID,
	BOOLEAN bIsModify)
{
	CCimHttpCreateClass *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;
	LONG lFlags = 0;

	// Collect the list of parameters
	//===============================
	BSTR strLocalNamespace = NULL;
	IXMLDOMNodeList *pParameters = NULL;

	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		IXMLDOMNode *pClass = NULL;
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;

					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if( 0 == _wcsicmp(strParamName, (bIsModify)? MODIFIED_CLASS_PARAM : NEW_CLASS_PARAM) )
						{
							// This should be a CLASS element 
							IXMLDOMNode *pPutativeClass = NULL;

							if (SUCCEEDED (pNextParam->get_firstChild (&pPutativeClass)) && pPutativeClass)
							{
								BSTR strNodeName3 = NULL;

								if (SUCCEEDED(pPutativeClass->get_nodeName 
											(&strNodeName3)))
								{
									if (_wcsicmp(strNodeName3, CLASS_TAG) == 0)
									{
										// Yowzer - we have it
										pClass = pPutativeClass;
										pClass->AddRef ();
									}

									SysFreeString (strNodeName3);
								}

								pPutativeClass->Release ();
							}
						}
						else if( 0 == _wcsicmp(strParamName, LFLAGS_PARAM) )
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseLongArgument (pParamValue, &lFlags);
								pParamValue->Release ();
							}
						}
						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpCreateClass(pClass, strLocalNamespace, strID,
												bIsModify);
		if(pClass)
			pClass->Release();

		if(pReturnValue)
		{
			pReturnValue->SetContextObject(pContextObject);
			pReturnValue->SetFlags(lFlags);
		}

		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
		
	}
	return pReturnValue;
}


// Parse a Create Instance request
CCimHttpCreateInstance * ParseCreateInstanceMethod (
	IXMLDOMNode *pNode, 
	BSTR strID
)
{
	CCimHttpCreateInstance *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a CreateInstance request
	//============================================================
	BSTR strLocalNamespace = NULL;
	IXMLDOMNodeList *pParameters = NULL;
	LONG lFlags = 0;

	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		IXMLDOMNode *pInstance = NULL;
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;

					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, NEW_INSTANCE_PARAM) == 0)
						{
							// Should find a <INSTANCE> element now
							IXMLDOMNode *pPutativeInstance = NULL;

							if (SUCCEEDED (pNextParam->get_firstChild (&pPutativeInstance)) && pPutativeInstance)
							{
								BSTR strNodeName3 = NULL;

								if (SUCCEEDED(pPutativeInstance->get_nodeName 
											(&strNodeName3)))
								{
									if (_wcsicmp(strNodeName3, INSTANCE_TAG) == 0)
									{
										// Yowzer - we have it
										pInstance = pPutativeInstance;
										pInstance->AddRef ();
									}

									SysFreeString (strNodeName3);
								}

								pPutativeInstance->Release ();
							}
						}
						else if( 0 == _wcsicmp(strParamName, LFLAGS_PARAM) )
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseLongArgument (pParamValue, &lFlags);
								pParamValue->Release ();
							}
						}

						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		// We only free those that are not needed
		// The other pointers get copied by the contructor
		pReturnValue = new CCimHttpCreateInstance(pInstance, strLocalNamespace, strID);
		if(pInstance)
			pInstance->Release();
		if(pReturnValue)
		{
			pReturnValue->SetContextObject(pContextObject);
			pReturnValue->SetFlags(lFlags);
		}
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}


// Parse a Modify Instance request
CCimHttpModifyInstance * ParseModifyInstanceMethod (
	IXMLDOMNode *pNode, 
	BSTR strID
)
{
	CCimHttpModifyInstance *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a ModifyInstance request
	//============================================================
	BSTR strLocalNamespace = NULL;
	IXMLDOMNodeList *pParameters = NULL;
	BSTR strInstanceName = NULL;
	LONG lFlags = 0;

	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		IXMLDOMNode *pInstance = NULL;
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;

					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, MODIFIED_INSTANCE_PARAM) == 0)
						{
							// This should be a VALUE.NAMEDOBJECT element
							IXMLDOMNode *pValue = NULL;

							// RAJESHR must only be one node
							if (SUCCEEDED (pNextParam->get_firstChild (&pValue)) && pValue)
							{
								BSTR strNodeName2 = NULL;

								if(SUCCEEDED(pValue->get_nodeName(&strNodeName2)))
								{
									if(_wcsicmp(strNodeName2, VALUENAMEDOBJECT_TAG) == 0)
									{
										IXMLDOMNodeList *pInstNodeList = NULL;

										if (SUCCEEDED(pValue->get_childNodes (&pInstNodeList)))
										{
											// Should find an <INSTANCENAME>
											// and an <INSTANCE> element under here
											IXMLDOMNode *pInstNameNode = NULL;
											
											if (SUCCEEDED(pInstNodeList->nextNode (&pInstNameNode)) 
												    && pInstNameNode)
											{
												BSTR instNameNode = NULL;

												if(SUCCEEDED(pInstNameNode->get_nodeName(&instNameNode)))
												{
													if(_wcsicmp(instNameNode, INSTANCENAME_TAG) == 0)
													{
														// Parse into path
														ParseInstanceName (pInstNameNode, &strInstanceName);
													}

													SysFreeString (instNameNode);
												}

												pInstNameNode->Release ();
											}
																						
											if (SUCCEEDED (pInstNodeList->nextNode (&pInstance))
													&& pInstance)
											{
												BSTR strInstanceNodeName = NULL;

												if (SUCCEEDED(pInstance->get_nodeName 
															(&strInstanceNodeName)))
												{
													if (0 != _wcsicmp(strInstanceNodeName, INSTANCE_TAG))
													{
														// Error - get rid of it
														pInstance->Release ();
														pInstance = NULL;
													}

													SysFreeString (strInstanceNodeName);
												}
												else
												{
													// Error - get rid of it
													pInstance->Release ();
													pInstance = NULL;
												}
											}

											pInstNodeList->Release ();
										}		
									}

									SysFreeString (strNodeName2);
								}

								pValue->Release ();
							}
						}
						else if( 0 == _wcsicmp(strParamName, LFLAGS_PARAM) )
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseLongArgument (pParamValue, &lFlags);
								pParamValue->Release ();
							}
						}
						
						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		// We only free those that are not needed
		// The other pointers get copied by the contructor
		pReturnValue = new CCimHttpModifyInstance(pInstance, strInstanceName,
										strLocalNamespace, strID);
		if(pInstance)
			pInstance->Release();
		if(pReturnValue)
		{
			pReturnValue->SetContextObject(pContextObject);
			pReturnValue->SetFlags(lFlags);
		}
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse a Delete Class request
CCimHttpDeleteClass * ParseDeleteClassMethod (
	IXMLDOMNode *pNode, 
	BSTR strID)
{
	CCimHttpDeleteClass *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a DeleteClass reques
	//=======================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		// String values of the parameters
		BSTR strLocalNamespace = NULL;
		BSTR strClassName = NULL;
		
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, CLASS_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strClassName);
								pParamValue->Release ();
							}
						}

						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpDeleteClass(strClassName, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse an EnumerateInstance request
CCimHttpEnumerateInstances * ParseEnumerateInstancesMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpEnumerateInstances *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a Enumerate Instances request
	//=================================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strClassName = NULL;
		BSTR strLocalOnlyValue = NULL;
		BSTR strDeepInheritanceValue = NULL;
		BSTR strIncludeQualifiers = NULL;
		BSTR strIncludeClassOrigin = NULL;
		BSTR *strPropertyList = NULL;
		DWORD dwPropCount = 0;

		// Set the optional parameters to their defaults
		BOOLEAN bLocalsOnly = TRUE;
		BOOLEAN bDeepInheritance = TRUE;
		BOOLEAN bIncludeQualifiers = FALSE;
		BOOLEAN bIncludeClassOrigin = FALSE;



		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, CLASS_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strClassName);
								pParamValue->Release ();
							}						
						}
						else if(_wcsicmp(strParamName, LOCAL_ONLY_PARAM) == 0)
						{
							pNextParam->get_text(&strLocalOnlyValue);
						}
						else if(_wcsicmp(strParamName, DEEP_INHERITANCE_PARAM) == 0)
						{
							pNextParam->get_text(&strDeepInheritanceValue);
						}
						else if(_wcsicmp(strParamName, INCLUDE_QUALIFIERS_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeQualifiers);
						}
						else if(_wcsicmp(strParamName, INCLUDE_CLASS_ORIGIN_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeClassOrigin);
						}
						else if(_wcsicmp(strParamName, PROPERTY_LIST_PARAM) == 0)
						{
							ParsePropertyList(pNextParam, &strPropertyList, &dwPropCount);
						}

						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}
				
				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		// Sort out the parameters created above
		if(strLocalOnlyValue && _wcsicmp(strLocalOnlyValue, FALSE_WSTR) == 0)
			bLocalsOnly = FALSE;
		if(strDeepInheritanceValue && _wcsicmp(strDeepInheritanceValue, FALSE_WSTR) == 0)
			bDeepInheritance = FALSE;
		if(strIncludeQualifiers && _wcsicmp(strIncludeQualifiers, TRUE_WSTR) == 0)
			bIncludeQualifiers = TRUE;
		if(strIncludeClassOrigin && _wcsicmp(strIncludeClassOrigin, TRUE_WSTR) == 0)
			bIncludeClassOrigin = TRUE;

		SysFreeString(strLocalOnlyValue);
		SysFreeString(strIncludeQualifiers);
		SysFreeString(strIncludeClassOrigin);
		SysFreeString(strDeepInheritanceValue);
		pReturnValue = new CCimHttpEnumerateInstances(strClassName, strPropertyList, dwPropCount, bDeepInheritance, bLocalsOnly, bIncludeQualifiers, bIncludeClassOrigin, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse an EnumerateInstanceNames request
CCimHttpEnumerateInstanceNames * ParseEnumerateInstanceNamesMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpEnumerateInstanceNames *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a Enumerate InstanceNames request
	//=====================================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strClassName = NULL;
		
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, CLASS_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strClassName);
								pParamValue->Release ();
							}						
						}
						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpEnumerateInstanceNames(strClassName, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse an EnumerateClasses request
CCimHttpEnumerateClasses * ParseEnumerateClassesMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpEnumerateClasses *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a Enumerate Instances request
	//=================================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strClassName = NULL;
		BSTR strLocalOnlyValue = NULL;
		BSTR strDeepInheritanceValue = NULL;
		BSTR strIncludeQualifiers = NULL;
		BSTR strIncludeClassOrigin = NULL;
		BSTR *strPropertyList = NULL;
		DWORD dwPropCount = 0;

		// Set the optional parameters to their defaults
		BOOLEAN bLocalsOnly = TRUE;
		BOOLEAN bDeepInheritance = TRUE;
		BOOLEAN bIncludeQualifiers = FALSE;
		BOOLEAN bIncludeClassOrigin = FALSE;

		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, CLASS_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strClassName);
								pParamValue->Release ();
							}						
						}
						else if(_wcsicmp(strParamName, LOCAL_ONLY_PARAM) == 0)
						{
							pNextParam->get_text(&strLocalOnlyValue);
						}
						else if(_wcsicmp(strParamName, DEEP_INHERITANCE_PARAM) == 0)
						{
							pNextParam->get_text(&strDeepInheritanceValue);
						}
						else if(_wcsicmp(strParamName, INCLUDE_QUALIFIERS_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeQualifiers);
						}
						else if(_wcsicmp(strParamName, INCLUDE_CLASS_ORIGIN_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeClassOrigin);
						}
						else if(_wcsicmp(strParamName, PROPERTY_LIST_PARAM) == 0)
						{
							ParsePropertyList(pNextParam, &strPropertyList, &dwPropCount);
						}

						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		// Sort out the parameters created above
		if(strLocalOnlyValue && _wcsicmp(strLocalOnlyValue, FALSE_WSTR) == 0)
			bLocalsOnly = FALSE;
		if(strDeepInheritanceValue && _wcsicmp(strDeepInheritanceValue, FALSE_WSTR) == 0)
			bDeepInheritance = FALSE;
		if(strIncludeQualifiers && _wcsicmp(strIncludeQualifiers, TRUE_WSTR) == 0)
			bIncludeQualifiers = TRUE;
		if(strIncludeClassOrigin && _wcsicmp(strIncludeClassOrigin, TRUE_WSTR) == 0)
			bIncludeClassOrigin = TRUE;

		SysFreeString(strLocalOnlyValue);
		SysFreeString(strIncludeQualifiers);
		SysFreeString(strIncludeClassOrigin);
		SysFreeString(strDeepInheritanceValue);
		pReturnValue = new CCimHttpEnumerateClasses(strClassName, strPropertyList, dwPropCount, bDeepInheritance, bLocalsOnly, bIncludeQualifiers, bIncludeClassOrigin, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse an EnumerateClassNames request
CCimHttpEnumerateClassNames * ParseEnumerateClassNamesMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpEnumerateClassNames *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a EnumerateClassNames request
	//=================================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strClassName = NULL;
		BSTR strDeepInheritanceValue = NULL;
		BOOLEAN bDeepInheritance = FALSE;
		
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, CLASS_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strClassName);
								pParamValue->Release ();
							}						
						}
						else if(_wcsicmp(strParamName, DEEP_INHERITANCE_PARAM) == 0)
						{
							pNextParam->get_text(&strDeepInheritanceValue);
						}

						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		if(strDeepInheritanceValue && _wcsicmp(strDeepInheritanceValue, TRUE_WSTR) == 0)
			bDeepInheritance = TRUE;
		SysFreeString(strDeepInheritanceValue);

		pReturnValue = new CCimHttpEnumerateClassNames(strClassName, strLocalNamespace, 
						bDeepInheritance, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse a Get Instance request
CCimHttpGetInstance * ParseGetInstanceMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpGetInstance *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a GetInstance reques
	//=======================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strInstanceName = NULL;
		BSTR strLocalOnlyValue = NULL;
		BSTR strIncludeQualifiers = NULL;
		BSTR strIncludeClassOrigin = NULL;
		BSTR *strPropertyList = NULL;
		DWORD dwPropCount = 0;

		// Set the optional parameters to their defaults
		BOOLEAN bLocalsOnly = TRUE;
		BOOLEAN bIncludeQualifiers = FALSE;
		BOOLEAN bIncludeClassOrigin = FALSE;


		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, LOCAL_ONLY_PARAM) == 0)
						{
							pNextParam->get_text(&strLocalOnlyValue);
						}
						else if(_wcsicmp(strParamName, INCLUDE_QUALIFIERS_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeQualifiers);
						}
						else if(_wcsicmp(strParamName, INCLUDE_CLASS_ORIGIN_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeClassOrigin);
						}
						if(_wcsicmp(strParamName, INSTANCE_NAME_PARAM) == 0)
						{
							ParseParamValueInstName(pNextParam, &strInstanceName);
						}
						else if(_wcsicmp(strParamName, PROPERTY_LIST_PARAM) == 0)
						{
							ParsePropertyList(pNextParam, &strPropertyList, &dwPropCount);
						}

						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}


				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		// Sort out the parameters created above
		if(strLocalOnlyValue && _wcsicmp(strLocalOnlyValue, FALSE_WSTR) == 0)
			bLocalsOnly = FALSE;
		if(strIncludeQualifiers && _wcsicmp(strIncludeQualifiers, TRUE_WSTR) == 0)
			bIncludeQualifiers = TRUE;
		if(strIncludeClassOrigin && _wcsicmp(strIncludeClassOrigin, TRUE_WSTR) == 0)
			bIncludeClassOrigin = TRUE;

		SysFreeString(strLocalOnlyValue);
		SysFreeString(strIncludeQualifiers);
		SysFreeString(strIncludeClassOrigin);
		pReturnValue = new CCimHttpGetInstance(strInstanceName, strPropertyList, dwPropCount,
				bLocalsOnly, bIncludeQualifiers, bIncludeClassOrigin, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse a Delete Instance request
CCimHttpDeleteInstance * ParseDeleteInstanceMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpDeleteInstance *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a DeleteInstance request
	//============================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strInstanceName = NULL;
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						ParseParamValueInstName(pNextParam, &strInstanceName);
						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}
		
				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpDeleteInstance(strInstanceName, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse a Get Class request
CCimHttpExecQuery * ParseExecQueryMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpExecQuery *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a GetClass reques
	//=======================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strQuery = NULL;
		BSTR strQueryLanguage = NULL;


		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// Process the parameter
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, QUERY_LANGUAGE_PARAM) == 0)
						{
							pNextParam->get_text(&strQueryLanguage);							
						}
						else if(_wcsicmp(strParamName, QUERY_PARAM) == 0)
						{
							pNextParam->get_text(&strQuery);
						}

						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpExecQuery(strQuery, strQueryLanguage, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}


// Parse a Get Property request
CCimHttpGetProperty * ParseGetPropertyMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpGetProperty *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a GetInstance reques
	//=======================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strInstanceName = NULL;
		BSTR strPropertyName = NULL;
		
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, PROPERTY_NAME_PARAM) == 0)
						{
							pNextParam->get_text(&strPropertyName);
						}
						else if(_wcsicmp(strParamName, INSTANCE_NAME_PARAM) == 0)
						{
							ParseParamValueInstName(pNextParam, &strInstanceName);
						}
						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpGetProperty(strInstanceName, strPropertyName, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse a Set Property request
CCimHttpSetProperty * ParseSetPropertyMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpSetProperty *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a GetInstance reques
	//=======================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strInstanceName = NULL;
		BSTR strPropertyName = NULL;
		IXMLDOMNode *pPropertyValue = NULL;	
		
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, PROPERTY_NAME_PARAM) == 0)
						{
							pNextParam->get_text(&strPropertyName);
						}
						else if(_wcsicmp(strParamName, INSTANCE_NAME_PARAM) == 0)
						{
							ParseParamValueInstName(pNextParam, &strInstanceName);
						}
						else if(_wcsicmp(strParamName, NEW_VALUE_PARAM) == 0)
						{
							pNextParam->get_firstChild (&pPropertyValue);
						}
						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpSetProperty(strInstanceName, strPropertyName, 
								pPropertyValue, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();
		if (pPropertyValue)
			pPropertyValue->Release ();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse an Associators request
CCimHttpAssociators * ParseAssociatorsMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpAssociators *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a Enumerate Instances request
	//=================================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strObjectName = NULL;
		BSTR strAssocClass = NULL;
		BSTR strResultClass = NULL;
		BSTR strRole = NULL;
		BSTR strResultRole = NULL;
		BSTR strIncludeQualifiers = NULL;
		BSTR strIncludeClassOrigin = NULL;
		BSTR *strPropertyList = NULL;
		DWORD dwPropCount = 0;

		// Set the optional parameters to their defaults
		BOOLEAN bIncludeQualifiers = FALSE;
		BOOLEAN bIncludeClassOrigin = FALSE;

		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, OBJECT_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							// RAJESHR should only be one child
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								BSTR strNodeName2 = NULL;

								// CLASSNAME or INSTANCENAME expect
								if (SUCCEEDED (pParamValue->get_nodeName (&strNodeName2)))
								{
									if (_wcsicmp(strNodeName2, CLASS_NAME_PARAM) == 0)
									{
										GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strObjectName);
									}
									else if (_wcsicmp(strNodeName2, INSTANCE_NAME_PARAM) == 0)
									{
										ParseInstanceName (pParamValue, &strObjectName);
									}
									SysFreeString (strNodeName2);
								}
										
								pParamValue->Release ();
							}						
						}
						else if(_wcsicmp(strParamName, INCLUDE_QUALIFIERS_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeQualifiers);
						}
						else if(_wcsicmp(strParamName, INCLUDE_CLASS_ORIGIN_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeClassOrigin);
						}
						else if(_wcsicmp(strParamName, ASSOC_CLASS_PARAM) == 0)
						{
							pNextParam->get_text(&strAssocClass);
						}
						else if(_wcsicmp(strParamName, RESULT_CLASS_PARAM) == 0)
						{
							pNextParam->get_text(&strResultClass);
						}
						else if(_wcsicmp(strParamName, ROLE_PARAM) == 0)
						{
							pNextParam->get_text(&strRole);
						}
						else if(_wcsicmp(strParamName, RESULT_ROLE_PARAM) == 0)
						{
							pNextParam->get_text(&strResultRole);
						}
						else if(_wcsicmp(strParamName, PROPERTY_LIST_PARAM) == 0)
						{
							ParsePropertyList(pNextParam, &strPropertyList, &dwPropCount);
						}

						SysFreeString(strParamName);
					}
					else
					{
						// A nameless parameter - just ignore it since
						// we're doing loose validation
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}
				
				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		// Sort out the parameters created above
		if(strIncludeQualifiers && _wcsicmp(strIncludeQualifiers, TRUE_WSTR) == 0)
			bIncludeQualifiers = TRUE;
		if(strIncludeClassOrigin && _wcsicmp(strIncludeClassOrigin, TRUE_WSTR) == 0)
			bIncludeClassOrigin = TRUE;

		SysFreeString(strIncludeQualifiers);
		SysFreeString(strIncludeClassOrigin);
		pReturnValue = new CCimHttpAssociators(strObjectName, strPropertyList, dwPropCount, bIncludeQualifiers, bIncludeClassOrigin, 
							strAssocClass, strResultClass, strRole, strResultRole, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse an AssociatorNames request
CCimHttpAssociatorNames * ParseAssociatorNamesMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpAssociatorNames *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters for a Enumerate Instances request
	//=================================================================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strObjectName = NULL;
		BSTR strAssocClass = NULL;
		BSTR strResultClass = NULL;
		BSTR strRole = NULL;
		BSTR strResultRole = NULL;
		
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, OBJECT_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							// RAJESHR should only be one child
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								BSTR strNodeName2 = NULL;

								// CLASSNAME or INSTANCENAME expect
								if (SUCCEEDED (pParamValue->get_nodeName (&strNodeName2)))
								{
									if (_wcsicmp(strNodeName2, CLASS_NAME_PARAM) == 0)
									{
										GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strObjectName);
									}
									else if (_wcsicmp(strNodeName2, INSTANCE_NAME_PARAM) == 0)
									{
										ParseInstanceName (pParamValue, &strObjectName);
									}
									SysFreeString (strNodeName2);
								}
										
								pParamValue->Release ();
							}						
						}
						else if(_wcsicmp(strParamName, ASSOC_CLASS_PARAM) == 0)
						{
							pNextParam->get_text(&strAssocClass);
						}
						else if(_wcsicmp(strParamName, RESULT_CLASS_PARAM) == 0)
						{
							pNextParam->get_text(&strResultClass);
						}
						else if(_wcsicmp(strParamName, ROLE_PARAM) == 0)
						{
							pNextParam->get_text(&strRole);
						}
						else if(_wcsicmp(strParamName, RESULT_ROLE_PARAM) == 0)
						{
							pNextParam->get_text(&strResultRole);
						}
		
						SysFreeString(strParamName);
					}
					else
					{
						// A nameless parameter - just ignore it since
						// we're doing loose validation
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpAssociatorNames(strObjectName,  
							strAssocClass, strResultClass, strRole, 
							strResultRole, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse an Refrerences request
CCimHttpReferences * ParseReferencesMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpReferences *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters
	//===============================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strObjectName = NULL;
		BSTR strRole = NULL;
		BSTR strResultClass = NULL;
		BSTR strIncludeQualifiers = NULL;
		BSTR strIncludeClassOrigin = NULL;
		BSTR *strPropertyList = NULL;
		DWORD dwPropCount = 0;

		// Set the optional parameters to their defaults
		BOOLEAN bIncludeQualifiers = FALSE;
		BOOLEAN bIncludeClassOrigin = FALSE;

		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, OBJECT_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							// RAJESHR should only be one child
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								BSTR strNodeName2 = NULL;

								// CLASSNAME or INSTANCENAME expect
								if (SUCCEEDED (pParamValue->get_nodeName (&strNodeName2)))
								{
									if (_wcsicmp(strNodeName2, CLASS_NAME_PARAM) == 0)
									{
										GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strObjectName);
									}
									else if (_wcsicmp(strNodeName2, INSTANCE_NAME_PARAM) == 0)
									{
										ParseInstanceName (pParamValue, &strObjectName);
									}
									SysFreeString (strNodeName2);
								}
										
								pParamValue->Release ();
							}						
						}
						else if(_wcsicmp(strParamName, INCLUDE_QUALIFIERS_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeQualifiers);
						}
						else if(_wcsicmp(strParamName, INCLUDE_CLASS_ORIGIN_PARAM) == 0)
						{
							pNextParam->get_text(&strIncludeClassOrigin);
						}
						else if(_wcsicmp(strParamName, ROLE_PARAM) == 0)
						{
							pNextParam->get_text(&strRole);
						}
						else if(_wcsicmp(strParamName, RESULT_CLASS_PARAM) == 0)
						{
							pNextParam->get_text(&strResultClass);
						}
						else if(_wcsicmp(strParamName, PROPERTY_LIST_PARAM) == 0)
						{
							ParsePropertyList(pNextParam, &strPropertyList, &dwPropCount);
						}

						SysFreeString(strParamName);
					}
					else
					{
						// A nameless parameter - just ignore it since
						// we're doing loose validation
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}
				
				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		// Sort out the parameters created above
		if(strIncludeQualifiers && _wcsicmp(strIncludeQualifiers, TRUE_WSTR) == 0)
			bIncludeQualifiers = TRUE;
		if(strIncludeClassOrigin && _wcsicmp(strIncludeClassOrigin, TRUE_WSTR) == 0)
			bIncludeClassOrigin = TRUE;

		SysFreeString(strIncludeQualifiers);
		SysFreeString(strIncludeClassOrigin);
		pReturnValue = new CCimHttpReferences(strObjectName, strPropertyList, 
							dwPropCount, bIncludeQualifiers, bIncludeClassOrigin, 
							strResultClass, strRole, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse an ReferenceNames request
CCimHttpReferenceNames * ParseReferenceNamesMethod(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpReferenceNames *pReturnValue = NULL;
	IXMLDOMNode *pContextObject = NULL;

	// Collect the list of parameters
	//===============================
	IXMLDOMNodeList *pParameters = NULL;
	if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
	{
		BSTR strLocalNamespace = NULL;
		BSTR strObjectName = NULL;
		BSTR strRole = NULL;
		BSTR strResultClass = NULL;
		
		IXMLDOMNode *pNextParam = NULL;

		while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We dont want to process the LOCALNAMESPACEPATH child node in this loop, only params
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, OBJECT_NAME_PARAM) == 0)
						{
							IXMLDOMNode *pParamValue = NULL;

							// RAJESHR should only be one child
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								BSTR strNodeName2 = NULL;

								// CLASSNAME or INSTANCENAME expect
								if (SUCCEEDED (pParamValue->get_nodeName (&strNodeName2)))
								{
									if (_wcsicmp(strNodeName2, CLASS_NAME_PARAM) == 0)
									{
										GetBstrAttribute (pParamValue, NAME_ATTRIBUTE, &strObjectName);
									}
									else if (_wcsicmp(strNodeName2, INSTANCE_NAME_PARAM) == 0)
									{
										ParseInstanceName (pParamValue, &strObjectName);
									}
									SysFreeString (strNodeName2);
								}
										
								pParamValue->Release ();
							}						
						}
						else if(_wcsicmp(strParamName, ROLE_PARAM) == 0)
						{
							pNextParam->get_text(&strRole);
						}
						else if(_wcsicmp(strParamName, RESULT_CLASS_PARAM) == 0)
						{
							pNextParam->get_text(&strResultClass);
						}
		
						SysFreeString(strParamName);
					}
				}
				else if(_wcsicmp(strNodeName, LOCALNAMESPACEPATH_TAG) == 0)
				{
					ParseLocalNamespacePath(pNextParam, &strLocalNamespace);
				}
				else if(_wcsicmp(strNodeName, CONTEXTOBJECT_TAG) == 0)
				{
					pContextObject = pNextParam;pContextObject->AddRef();
				}
				
				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}

		pReturnValue = new CCimHttpReferenceNames(strObjectName,  
							strResultClass, strRole, strLocalNamespace, strID);
		if(pReturnValue)
			pReturnValue->SetContextObject(pContextObject);
		if(pContextObject)
			pContextObject->Release();

		pParameters->Release();
	}
	return pReturnValue;
}

// Parse a IMETHODCALL element
CCimHttpMessage * ParseIMethodCall(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpMessage *pReturnValue = NULL;
	bool bIsWhistlerMethod = false;

	// See if it is a Whistler Method
	BSTR  strWMIWhistlerMethod = NULL;
	if(SUCCEEDED(GetBstrAttribute(pNode, WMI_ATTRIBUTE, &strWMIWhistlerMethod)))
	{
		SysFreeString(strWMIWhistlerMethod);
		bIsWhistlerMethod = true;
	}

	BSTR strMethodName = NULL;
	if(SUCCEEDED(GetBstrAttribute(pNode, NAME_ATTRIBUTE, &strMethodName)))
	{
#ifdef WMI_XML_WHISTLER
		
		if(bIsWhistlerMethod)
		{
			if(_wcsicmp(strMethodName, GET_OBJECT_METHOD) == 0)
				pReturnValue = new CCimWhistlerGetObjectMethod(pNode, strID);
			else if(_wcsicmp(strMethodName, ENUMERATE_INSTANCES_METHOD) == 0)
				pReturnValue = new CCimWhistlerEnumerateInstancesMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, EXEC_QUERY_METHOD) == 0)
				pReturnValue = new CCimWhistlerExecQueryMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, ENUMERATE_CLASSES_METHOD) == 0)
				pReturnValue = new CCimWhistlerEnumerateClassesMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, DELETE_CLASS_METHOD) == 0)
				pReturnValue = new CCimWhistlerDeleteClassMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, DELETE_INSTANCE_METHOD) == 0)
				pReturnValue = new CCimWhistlerDeleteInstanceMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, CREATE_CLASS_METHOD) == 0)
				pReturnValue = new CCimWhistlerCreateClassMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, CREATE_INSTANCE_METHOD) == 0)
				pReturnValue = new CCimWhistlerCreateInstanceMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, ADD_METHOD) == 0)
				pReturnValue = new CCimWhistlerAddMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, REMOVE_METHOD) == 0)
				pReturnValue = new CCimWhistlerRemoveMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, RENAME_METHOD) == 0)
				pReturnValue = new CCimWhistlerRenameMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, GET_OBJECT_SECURITY_METHOD) == 0)
				pReturnValue = new CCimWhistlerGetObjectSecurityMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, PUT_OBJECT_SECURITY_METHOD) == 0)
				pReturnValue = new CCimWhistlerPutObjectSecurityMethod(pNode, strID);
		}
		else
#endif
		{
			if(_wcsicmp(strMethodName, GET_CLASS_METHOD) == 0)
				pReturnValue = ParseGetClassMethod(pNode, strID);
			else if(_wcsicmp(strMethodName, ENUMERATE_INSTANCES_METHOD) == 0)
				pReturnValue = ParseEnumerateInstancesMethod(pNode, strID);
			else if(_wcsicmp(strMethodName, GET_INSTANCE_METHOD) == 0)
				pReturnValue = ParseGetInstanceMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, EXEC_QUERY_METHOD) == 0)
				pReturnValue = ParseExecQueryMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, ENUMERATE_INSTANCENAMES_METHOD) == 0)
				pReturnValue = ParseEnumerateInstanceNamesMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, ENUMERATE_CLASSES_METHOD) == 0)
				pReturnValue = ParseEnumerateClassesMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, ENUMERATE_CLASSNAMES_METHOD) == 0)
				pReturnValue = ParseEnumerateClassNamesMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, GET_PROPERTY_METHOD) == 0)
				pReturnValue = ParseGetPropertyMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, SET_PROPERTY_METHOD) == 0)
				pReturnValue = ParseSetPropertyMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, ASSOCIATORS_METHOD) == 0)
				pReturnValue = ParseAssociatorsMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, ASSOCIATOR_NAMES_METHOD) == 0)
				pReturnValue = ParseAssociatorNamesMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, REFERENCES_METHOD) == 0)
				pReturnValue = ParseReferencesMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, REFERENCE_NAMES_METHOD) == 0)
				pReturnValue = ParseReferenceNamesMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, DELETE_CLASS_METHOD) == 0)
				pReturnValue = ParseDeleteClassMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, DELETE_INSTANCE_METHOD) == 0)
				pReturnValue = ParseDeleteInstanceMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, CREATE_CLASS_METHOD) == 0)
				pReturnValue = ParseCreateClassMethod(pNode, strID, FALSE);
			else if (_wcsicmp(strMethodName, CREATE_INSTANCE_METHOD) == 0)
				pReturnValue = ParseCreateInstanceMethod(pNode, strID);
			else if (_wcsicmp(strMethodName, MODIFY_CLASS_METHOD) == 0)
				pReturnValue = ParseCreateClassMethod(pNode, strID, TRUE);
			else if (_wcsicmp(strMethodName, MODIFY_INSTANCE_METHOD) == 0)
				pReturnValue = ParseModifyInstanceMethod(pNode, strID);
		}
		
		SysFreeString(strMethodName);
	}

	return pReturnValue;
}

// Parse a METHODCALL element
CCimHttpMessage * ParseMethodCall(IXMLDOMNode *pNode, BSTR strID)
{
	CCimHttpMethod *pReturnValue = NULL;
	BSTR strMethodName = NULL;
	CParameterMap *pParameterMap = NULL;
	BSTR strNamespace = NULL;
	BSTR strObjectPath = NULL;
	if(pParameterMap = new CParameterMap())
	{
		// Get the Method Name
		if(SUCCEEDED(GetBstrAttribute(pNode, NAME_ATTRIBUTE, &strMethodName)))
		{
			// Collect the list of parameters for a request
			//=======================================================
			IXMLDOMNodeList *pParameters = NULL;

			if(SUCCEEDED(pNode->get_childNodes(&pParameters)))
			{

				IXMLDOMNode *pNextParam = NULL;

				while(SUCCEEDED(pParameters->nextNode(&pNextParam)) && pNextParam)
				{
					// Get its name
					BSTR strNodeName = NULL;
					if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
					{
						if(_wcsicmp(strNodeName, LOCALINSTANCEPATH_TAG) == 0)
						{
							ParseLocalInstancePathIntoNsAndInstName(pNextParam, &strNamespace, &strObjectPath);
							pReturnValue = new CCimHttpMethod(strMethodName, FALSE, strNamespace, strObjectPath, strID);
						}
						else if(_wcsicmp(strNodeName, LOCALCLASSPATH_TAG) == 0)
						{
							ParseLocalClassPathAsNsAndClass(pNextParam, &strNamespace, &strObjectPath);
							pReturnValue = new CCimHttpMethod(strMethodName, TRUE, strNamespace, strObjectPath, strID);
						}
						else if(_wcsicmp(strNodeName, PARAMVALUE_TAG) == 0)
						{
							IXMLDOMNode *pParameterValue = NULL;
							BSTR strParamName = NULL;
							if(SUCCEEDED(ParseParamValue(pNextParam, &strParamName, &pParameterValue)) && pParameterValue && strParamName)
								pParameterMap->SetAt(strParamName, pParameterValue);
							// No need to release pParameterValue.
							// It gets released when the parameter map is destroyed
						}

						SysFreeString(strNodeName);
					}
					pNextParam->Release();
					pNextParam = NULL;
				}
				pParameters->Release();
			}
		}
	}

	if(pReturnValue)
	{
		pReturnValue->SetInputParameters(pParameterMap);
	}
	else
	{
		if(pParameterMap)
			CCimHttpMethod::DestroyParameterMap(pParameterMap);
		delete pParameterMap;
		SysFreeString(strNamespace);
		SysFreeString(strObjectPath);
	}
	return pReturnValue;
}


// Parse a SIMPLEREQ element
CCimHttpMessage * ParseSimpleReq(IXMLDOMNode *pNode, BSTR strID, BOOLEAN bIsMpostRequest, BOOLEAN bIsMicrosoftWMIClient, WMI_XML_HTTP_VERSION iHttpVersion)
{
	CCimHttpMessage *pReturnValue = NULL;

	// See if the child is an METHODCALL or IMETHODCALL
	IXMLDOMNode *pMethodNode = NULL;
	if(SUCCEEDED(pNode->get_firstChild(&pMethodNode)) && pMethodNode)
	{
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pMethodNode->get_nodeName(&strNodeName)))
		{
			if(_wcsicmp(strNodeName, IMETHODCALL_TAG) == 0)
			{
				pReturnValue = ParseIMethodCall(pMethodNode, strID);
			}
			else if(_wcsicmp(strNodeName, METHODCALL_TAG) == 0)
			{
				pReturnValue = ParseMethodCall(pMethodNode, strID);
			}
			SysFreeString(strNodeName);
		}
		pMethodNode->Release();
	}

	if (pReturnValue)
	{
		pReturnValue->SetIsMpost (bIsMpostRequest);
		pReturnValue->SetHttpVersion(iHttpVersion);
		pReturnValue->SetMicrosoftClient(bIsMicrosoftWMIClient);
	}

	return pReturnValue;
}

// Parse a MULTIREQ element
BOOLEAN ParseMultiReq(IXMLDOMNodeList *pReqList, CCimHttpMultiMessage *pMultiRequest, BSTR strID, BOOLEAN bIsMpostRequest, BOOLEAN bIsMicrosoftWMIClient, WMI_XML_HTTP_VERSION iHttpVersion, DWORD dwNumSimpleRequests)
{
	pMultiRequest->SetHttpVersion(iHttpVersion);
	pMultiRequest->SetMicrosoftClient(bIsMicrosoftWMIClient);

	// Allocate an array of pointers
	//===============================
	CCimHttpMessage **ppSimpleMessages = NULL;
	if(ppSimpleMessages = new CCimHttpMessage *[dwNumSimpleRequests])
	{
		// Initialize each of the pointers in the above array with a simple request object
		//================================================================================
		IXMLDOMNode *pSimpleReqNode = NULL;
		DWORD dwSimpleRequestCount = 0;
		BOOLEAN bAllSubNodesParsed = TRUE;
		CCimHttpMessage *pNextSimpleRequest = NULL;
		while (SUCCEEDED(pReqList->nextNode (&pSimpleReqNode)) 
				&& pSimpleReqNode && bAllSubNodesParsed)
		{
			// Parse the next simple request
			ppSimpleMessages[dwSimpleRequestCount] = NULL;
			if(ppSimpleMessages[dwSimpleRequestCount] = ParseSimpleReq(pSimpleReqNode, strID, bIsMpostRequest, bIsMicrosoftWMIClient, iHttpVersion))
			{
				dwSimpleRequestCount ++;
			}
			else
			{
				bAllSubNodesParsed = FALSE;
			}
			pSimpleReqNode->Release ();
			pSimpleReqNode = NULL;
			pNextSimpleRequest = NULL;
		}

		if(bAllSubNodesParsed)
		{
			// Set the MultiRequest object with this array of SimpleRequest objects
			pMultiRequest->SetSimpleRequests(ppSimpleMessages, dwNumSimpleRequests);
			return TRUE;

		}
		else // Deallocate all memory
		{
			for(DWORD i=0; i<dwSimpleRequestCount; i++)
				delete ppSimpleMessages[i];
			delete [] ppSimpleMessages;
		}
	}
	return FALSE;
}


//***************************************************************************
//
//  BOOLEAN ParseXMLIntoCIMOperation
//
//  Description: 
//
//		Take the XML Document describing the request and execute the
//		corresponding WMI operations.
//
//  Parameters:
//
//		pMessageNode	Pointer to the MESSAGE element
//		ppReturnObject	Holds response message 
//		pdwStatus		Holds HTTP response status on return
//		bIsMpostRequest	Whether this is M-POST or POST
//		bIsMicrosoftWMIClient Whether this is a Microsoft CLient (i.e, the bIsMicrosoftWMIClient header was set)
//
//	Return Value:
//
//		TRUE if operation executed, FALSE otherwise
//
//***************************************************************************

BOOLEAN ParseXMLIntoCIMOperation(
	IXMLDOMNode *pMessageNode,
	CCimHttpMessage **ppReturnObject,
	DWORD *pdwStatus,
	BOOLEAN bIsMpostRequest,
	BOOLEAN bIsMicrosoftWMIClient,
	WMI_XML_HTTP_VERSION iHttpVersion,
	LPSTR *ppszCimError)
{
	*ppReturnObject = NULL;
	*pdwStatus = 400; // Bad Request by default 
	*ppszCimError = NULL;
	BSTR strIDValue = NULL;


	// Get the ProtocolVersion attribute from the MESSAGE element
	BSTR bsProtocolVersion = NULL;
	if(SUCCEEDED(GetBstrAttribute(pMessageNode, PROTOVERSION_ATTRIBUTE, &bsProtocolVersion)))
	{
		if (!bsProtocolVersion || (0 != wcscmp (bsProtocolVersion, L"1.0")))
		{
			*pdwStatus = 501;
			*ppszCimError = CIM_UNSUPPORTED_PROTOCOL_VERSION;
		}
		else
		{
			// We need its ID attribute
			if(SUCCEEDED(GetBstrAttribute(pMessageNode, ID_ATTRIBUTE, &strIDValue)) && strIDValue)
			{
				// Look for (MULTIREQ|SIMPLEREQ)
				IXMLDOMNodeList *pNodeList = NULL;
				if (SUCCEEDED(pMessageNode->get_childNodes (&pNodeList)) && pNodeList)
				{
					// Before we execute anything, check that we have a correct document
					// of the form (MULTIREQ|SIMPLEREQ)
					IXMLDOMNode *pRequestNode = NULL;
					IXMLDOMNode *pCurNode = NULL;
					BOOLEAN bFoundReq = FALSE;
					BOOLEAN bError = FALSE;
					BOOLEAN bIsMultiReq = FALSE;

					// Get the Simple or Multi Request Node
					//========================================
					while (!bFoundReq && SUCCEEDED(pNodeList->nextNode (&pCurNode)) && pCurNode)
					{
						BSTR bsNodeName = NULL;
						if (SUCCEEDED(pCurNode->get_nodeName(&bsNodeName)))
						{
							if (0 == _wcsicmp(bsNodeName, MULTIREQ_TAG))
							{
								pRequestNode = pCurNode;
								pRequestNode->AddRef ();
								bIsMultiReq = TRUE;
								bFoundReq = TRUE;
							}
							else if (0 == _wcsicmp(bsNodeName, SIMPLEREQ_TAG))
							{
								pRequestNode = pCurNode;
								pRequestNode->AddRef ();
								bFoundReq = TRUE;
							}

							SysFreeString (bsNodeName);
						}

						pCurNode->Release ();
						pCurNode = NULL;
					}

					if (bFoundReq)
					{
						if (bIsMultiReq)
						{
							// Create a MULTIREQ object
							//============================
							IXMLDOMNodeList *pReqList = NULL;
							if (SUCCEEDED(pRequestNode->get_childNodes (&pReqList)) && pReqList)
							{
								// Pass 1 - Count the number of SIMPLEREQ elements in the multi request
								// We do loose validation
								IXMLDOMNode *pSimpleReqNode = NULL;
								DWORD dwSimpleReqCount = 0;
								
								while (SUCCEEDED(pReqList->nextNode (&pSimpleReqNode)) && pSimpleReqNode)
								{
									BSTR bsReqNodeName = NULL;
									if (SUCCEEDED(pSimpleReqNode->get_nodeName(&bsReqNodeName)))
									{
										if (0 == _wcsicmp(bsReqNodeName, SIMPLEREQ_TAG))
											dwSimpleReqCount++;
										SysFreeString (bsReqNodeName);
									}
									pSimpleReqNode->Release ();
									pSimpleReqNode = NULL;
								}
					
								// Pass 2 - now create a MULTIREQ object
								if (SUCCEEDED(pReqList->reset()))
								{
									if(*ppReturnObject = new
											CCimHttpMultiMessage (strIDValue, bIsMpostRequest))
									{
										if(!ParseMultiReq(pReqList, (CCimHttpMultiMessage *)*ppReturnObject, strIDValue, bIsMpostRequest, bIsMicrosoftWMIClient, iHttpVersion, dwSimpleReqCount))
										{
											delete *ppReturnObject;
											*ppReturnObject = NULL;
										}
										else
											*pdwStatus = 200;
									}
									else
										*pdwStatus = 500;
								}

								pReqList->Release ();
							}
						}
						else
						{
							// Create a SIMPLEREQ object
							//============================
							*ppReturnObject = ParseSimpleReq(pRequestNode, strIDValue,
													bIsMpostRequest, bIsMicrosoftWMIClient, iHttpVersion);
							if(*ppReturnObject)
								*pdwStatus = 200;
						}
					}
					
					if (pRequestNode)
						pRequestNode->Release ();					

					pNodeList->Release();
				}
			}
		}
		SysFreeString (bsProtocolVersion);
	}

	// If an object was not constructed, then strIDValue needs to be released
	// Note that the strIDValue becomes a property of the request object since
	// its constructor does not make a copy
	if(!(*ppReturnObject))
	{
		SysFreeString (strIDValue);
		if(*pdwStatus == 400)
			*ppszCimError =	CIM_REQUEST_NOT_VALID;
	}

	return TRUE;
}

//***************************************************************************
//
//  IXMLDOMNode *GetMessageNode
//
//  Description: 
//
//		Take the XML Document describing the request and extract the
//		unique MESSAGE node.
//
//  Parameters:
//
//		pDocument		Holds request in XML document form
//		pdwStatus		Holds HTTP response status on return
//
//	Return Value:
//
//		pointer to the node (or NULL if error)
//
//***************************************************************************
IXMLDOMNode *GetMessageNode(
	IXMLDOMDocument *pDocument,
	DWORD *pdwStatus,
	LPSTR *ppszErrorHeaders
)
{
	IXMLDOMNode *pMessage = NULL;
	BOOLEAN bError = FALSE;
	*ppszErrorHeaders = NULL;
	*pdwStatus = 500;

	// Get the XML Element at the top of the document
	IXMLDOMElement *pDocumentElement = NULL;
	if (SUCCEEDED(pDocument->get_documentElement(&pDocumentElement)) && pDocumentElement)
	{
		BSTR bsNodeName = NULL;
	
		// This root element should be the "CIM" Element 
		if (SUCCEEDED(pDocumentElement->get_nodeName(&bsNodeName)) &&
			(0 == _wcsicmp (CIM_TAG, bsNodeName)))
		{
			// We found the root element - check the attributes

			// CIM Version
			BSTR bsCIMVersion = NULL;
			GetBstrAttribute (pDocumentElement, CIMVERSION_ATTRIBUTE, &bsCIMVersion);
			if(bsCIMVersion && _wcsicmp(bsCIMVersion, L"2.0") == 0)
			{
				// DTD Version
				BSTR bsDTDVersion = NULL;
				GetBstrAttribute (pDocumentElement, DTDVERSION_ATTRIBUTE, &bsDTDVersion);
				if(bsDTDVersion && _wcsicmp(bsDTDVersion, L"2.0") == 0)
				{
					// Now look for the MESSAGE tag
					IXMLDOMNodeList *pNodeList2 = NULL;
					if (SUCCEEDED(pDocumentElement->get_childNodes(&pNodeList2)) && pNodeList2)
					{
						IXMLDOMNode *pMessageNode = NULL;
						bool bFoundMessage = false;
						while (!bFoundMessage && SUCCEEDED(pNodeList2->nextNode (&pMessageNode)) 
									&& pMessageNode)
						{
							BSTR bsNodeName2 = NULL;
							// Next node should be the <MESSAGE> tag
							if (SUCCEEDED(pMessageNode->get_nodeName(&bsNodeName2)) &&
								(0 == _wcsicmp (MESSAGE_TAG, bsNodeName2)))
							{		
								pMessage = pMessageNode;
								pMessage->AddRef ();
								bFoundMessage = true;
							}

							SysFreeString(bsNodeName2);
							pMessageNode->Release();
							pMessageNode = NULL;
						}

						pNodeList2->Release ();
					}
				}
				else
				{
					bError = TRUE;
					*pdwStatus = 501;
					*ppszErrorHeaders = CIM_UNSUPPORTED_DTD_VERSION;
				}
				SysFreeString(bsDTDVersion);
			}
			else
			{
				bError = TRUE;
				*pdwStatus = 501;
				*ppszErrorHeaders = CIM_UNSUPPORTED_CIM_VERSION;
			}

			SysFreeString(bsCIMVersion);
		}
		else
		{
			bError = TRUE;
			*pdwStatus = 400;
			*ppszErrorHeaders = CIM_REQUEST_NOT_VALID;
		}
		SysFreeString(bsNodeName);
		pDocumentElement->Release();
	}
	else
	{
		bError = TRUE;
		*pdwStatus = 400;
		*ppszErrorHeaders = CIM_REQUEST_NOT_VALID;
	}

	// If we had some error and still have a message node, then release it
	if (bError && pMessage)
	{
		pMessage->Release ();
		pMessage = NULL;
	}
	// If we found no error, but also no message node, then create an error
	else if(!bError && !pMessage)
	{
		*pdwStatus = 400;
		*ppszErrorHeaders = CIM_REQUEST_NOT_VALID;
	}

	return pMessage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\request.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  REQUEST.H
//
//  rajeshr  3/25/2000   Created.
//
// Contains the classes that model the various operations that can be done on
// a CIMOM using the XML/HTTP transport
//
//***************************************************************************

#ifndef CIM_HTTP_REQUEST_H
#define CIM_HTTP_REQUEST_H


// A Macro to write newlines in the XML stream for readability TODO - remove this before release
#ifdef WMIXML_DONL	
#define WRITENL(theStream)			theStream->Write (NEWLINE, 4, NULL);
#else
#define WRITENL(theStream)
#endif

/*
 * This is the base class of all XML/HTTP requests
 * It contains the HTTP Version of the request, the ID of the request
 * whether the client is a Microsoft one, whether the request is a
 * POST or M-POSTand so on
 */
class CCimHttpMessage
{
protected:
	WMI_XML_HTTP_VERSION m_iHttpVersion;	// The HTTP Version of the request
	BSTR	m_strID;						// The Message ID of the request
	IStream *m_pHeaderStream;				// The stream on to which any headers in the response  are written
	IStream *m_pTrailerStream;				// The stream on to which any trailers in the response are written
	CHAR	*m_httpStatus;					// The HTTP status after the request has been handled
	HRESULT m_WMIStatus;					// Any HRESULT that is returned after interacting with WMI
	BOOL	m_bIsMpostRequest;				// Whether this is an M-POST request
	IWbemContext *m_pFlagsContext;			// A Context object that holds the flags that must be passed to the WMI-XML convertor
	BOOL	m_bIsMicrosoftWMIClient;		// Whether this is a Microsoft client

	HRESULT	TalkToWinMgmtAndPrepareResponse(LPEXTENSION_CONTROL_BLOCK pECB);
	virtual HRESULT PrepareCommonHeaders();
	virtual HRESULT PrepareCommonTrailersAndWriteToSocket(LPEXTENSION_CONTROL_BLOCK pECB);
	virtual WCHAR	*GetMethodName() = 0;
	BOOL SendHTTPHeaders(LPEXTENSION_CONTROL_BLOCK pECB, 
		LPCSTR pszStatus, LPCSTR pszHeader);
	HRESULT SetBoolProperty(LPCWSTR pszName, BOOL bValue);

public:
	CCimHttpMessage(BSTR strID, BOOL bIsMpostRequest);
	virtual ~CCimHttpMessage();

	virtual HRESULT Initialize();
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB) = 0;
	virtual HRESULT EncodeErrorObject(HRESULT result);
	virtual void	WriteMethodHeader() = 0;
	virtual void	WriteMethodTrailer() = 0;

	const BSTR GetID() const
	{
		return m_strID;
	}

	void SetIsMpost (BOOL bIsMpostRequest)
	{
		m_bIsMpostRequest = bIsMpostRequest;
	}

	void SetHttpVersion(WMI_XML_HTTP_VERSION iHttpVersion)
	{
		m_iHttpVersion = iHttpVersion;
	}

	void SetMicrosoftClient(BOOL bIsMicrosoftWMIClient)
	{
		m_bIsMicrosoftWMIClient = bIsMicrosoftWMIClient;
	}

	virtual HRESULT CreateFlagsContext();
	virtual HRESULT EncodeNormalResponse(LPEXTENSION_CONTROL_BLOCK pECB);
};

// This class models a non-Whistler CIM HTTP request
class CCimDMTFOrNovaMessage : public CCimHttpMessage
{
protected:
	IXMLDOMNode *m_pContextNode;

public:
	CCimDMTFOrNovaMessage :: CCimDMTFOrNovaMessage(BSTR pszID, BOOL bIsMpostRequest = FALSE)
		: CCimHttpMessage(pszID, bIsMpostRequest)
	{
		m_pContextNode = NULL;
	}
	virtual ~CCimDMTFOrNovaMessage()
	{
		if(m_pContextNode)
			m_pContextNode->Release();
	}

	void SetContextObject(IXMLDOMNode *pContextNode)
	{
		if (m_pContextNode)
			m_pContextNode->Release();
		m_pContextNode = pContextNode;
		if (m_pContextNode)
			m_pContextNode->AddRef();
	}
};

// This class models a MULTIREQUEST
class CCimHttpMultiMessage : public CCimHttpMessage
{
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB) { return S_OK; }
	virtual WCHAR	*GetMethodName() { return NULL; }
	virtual void	WriteMethodHeader() {}
	virtual void	WriteMethodTrailer() {}
	CCimHttpMessage **m_ppSimpleMessages; // Array of pointers to CCimhttpMessage objects
	DWORD m_dwSimpleMessageCount; // Number of pointers in the above array
	
public:
	CCimHttpMultiMessage (BSTR strID, BOOL bIsMpostRequest);
	virtual ~CCimHttpMultiMessage ();
	void SetSimpleRequests(CCimHttpMessage **ppSimpleMessages, DWORD dwSimpleMessageCount);
	CCimHttpMessage **GetSimpleRequests(DWORD *pdwSimpleMessageCount);
	virtual HRESULT EncodeNormalResponse(LPEXTENSION_CONTROL_BLOCK pECB);
};

// This class models an Intrinsic method request
class CCimHttpIMethod : public CCimDMTFOrNovaMessage
{
protected:
	BSTR m_strNamespace;
	LONG	m_lFlags;

public:

	CCimHttpIMethod(BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpIMethod();

	const BSTR GetNamespace() const
	{
		return m_strNamespace;
	}
	
	virtual void	WriteMethodHeader();
	virtual void	WriteMethodTrailer ();
	void SetFlags(LONG lFlags)
	{
		m_lFlags = lFlags;
	}
};

// This class models an Extrinsic method request
class CCimHttpMethod : public CCimHttpIMethod
{
protected:
	BSTR m_strMethodName;
	BSTR m_strObjectPath;
	BOOLEAN m_isStatic;
	CParameterMap *m_pInputParameters;

public:

	CCimHttpMethod(BSTR strMethodName, BOOLEAN isStatic, BSTR strNamespace, BSTR strObjectPath, BSTR strID);
	virtual ~CCimHttpMethod();
	WCHAR *GetMethodName() 
	{
		return m_strMethodName;
	}

	static void DestroyParameterMap(CParameterMap *pParameters);

	const BSTR GetObjectPath() const
	{
		return m_strObjectPath;
	}
	const CParameterMap * GetInputParameters() const
	{
		return m_pInputParameters;
	}
	void SetInputParameters(CParameterMap * pInputParameters) 
	{
		if(m_pInputParameters)
			DestroyParameterMap(m_pInputParameters);
		m_pInputParameters = pInputParameters;
	}

	virtual HRESULT PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
	virtual void	WriteMethodHeader();
	virtual void	WriteMethodTrailer();
};

class CCimHttpGetClass : public CCimHttpIMethod
{
protected:
	BSTR m_strClassName;
	BOOLEAN m_bLocalOnly;
	BOOLEAN m_bIncludeQualifiers;
	BOOLEAN m_bIncludeClassOrigin;
	BSTR *m_strPropertyList;
	DWORD m_dwPropCount;
	
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
	virtual HRESULT CreateFlagsContext();

public:

	CCimHttpGetClass(BSTR strClassName, BSTR *pstrPropertyList, DWORD dwPropCount,
		BOOLEAN bLocalOnly, BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin, 
		BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpGetClass();
	const BSTR GetClassName() const
	{
		return m_strClassName;
	}

	BOOLEAN IsLocalOnly() const
	{
		return m_bLocalOnly;
	}

	WCHAR *GetMethodName ()
	{
		return L"GetClass";
	}


};

class CCimHttpCreateClass : public CCimHttpIMethod
{
private:
	BOOL	m_bIsModify;

protected:
	IXMLDOMNode	*m_pClass;
	
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpCreateClass(IXMLDOMNode *m_pClass, BSTR strNamespace, BSTR strID,
						BOOL bIsModify);
	virtual ~CCimHttpCreateClass();

	WCHAR *GetMethodName ()
	{
		return (m_bIsModify) ? L"ModifyClass" : L"CreateClass";
	}
};

class CCimHttpDeleteClass : public CCimHttpIMethod
{
protected:
	BSTR m_strClassName;
	
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpDeleteClass(BSTR strClassName, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpDeleteClass();
	const BSTR GetClassName() const
	{
		return m_strClassName;
	}

	WCHAR *GetMethodName ()
	{
		return L"DeleteClass";
	}
};

class CCimHttpCreateInstance : public CCimHttpIMethod
{
protected:
	IXMLDOMNode	*m_pInstance;

	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
	WCHAR *GetMethodName ()
	{
		return L"CreateInstance";
	}


public:

	CCimHttpCreateInstance(IXMLDOMNode *m_pInstance, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpCreateInstance();

};

class CCimHttpModifyInstance : public CCimHttpIMethod
{
protected:
	IXMLDOMNode	*m_pInstance;
	BSTR	m_bsInstanceName;
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
	WCHAR *GetMethodName ()
	{
		return L"ModifyInstance";
	}

public:

	CCimHttpModifyInstance(IXMLDOMNode *m_pInstance, 
						BSTR strInstanceName, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpModifyInstance();
};

class CCimHttpDeleteInstance : public CCimHttpIMethod
{
protected:
	BSTR m_strInstanceName;
	
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpDeleteInstance(BSTR strInstanceName, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpDeleteInstance();
	const BSTR GetInstanceName() const
	{
		return m_strInstanceName;
	}

	WCHAR *GetMethodName ()
	{
		return L"DeleteInstance";
	}
};

class CCimHttpEnumerateClasses : public CCimHttpGetClass
{
protected:
	BOOLEAN m_bDeepInheritance;
	HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpEnumerateClasses(BSTR strClassName, BSTR *strPropertyList, DWORD dwCount, BOOLEAN bDeepInheritance, BOOLEAN bLocalOnly, BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpEnumerateClasses() {}

	BOOLEAN IsDeepInheritance() const
	{
		return m_bDeepInheritance;
	}
	
	WCHAR *GetMethodName ()
	{
		return L"EnumerateClasses";
	}
};

class CCimHttpEnumerateInstances : public CCimHttpGetClass
{
protected:
	BOOLEAN m_bDeepInheritance;
	HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpEnumerateInstances(BSTR strClassName, BSTR *strPropertyList, DWORD dwCount, BOOLEAN bDeepInheritance, BOOLEAN bLocalOnly, BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpEnumerateInstances() {}

	BOOLEAN IsDeepInheritance() const
	{
		return m_bDeepInheritance;
	}

	WCHAR *GetMethodName ()
	{
		return L"EnumerateInstances";
	}
};

class CCimHttpEnumerateInstanceNames : public CCimHttpIMethod
{
private:
	BSTR	m_strClassName;
	
protected:
	HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpEnumerateInstanceNames(BSTR strClassName, BSTR strNamespace, BSTR strID)
		: CCimHttpIMethod (strNamespace, strID) 
	{
		m_strClassName = strClassName;
	}
	virtual ~CCimHttpEnumerateInstanceNames() 
	{
		if (m_strClassName)
			SysFreeString (m_strClassName);
	}

	WCHAR *GetMethodName ()
	{
		return L"EnumerateInstanceNames";
	}
};

class CCimHttpEnumerateClassNames : public CCimHttpIMethod
{
private:
	BSTR	m_strClassName;
	BOOL	m_bDeepInheritance;
	
protected:
	HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpEnumerateClassNames(BSTR strClassName, BSTR strNamespace, 
								BOOL bDeepInheritanceValue, BSTR strID)
		: CCimHttpIMethod (strNamespace, strID) 
	{
		m_strClassName = strClassName;
		m_bDeepInheritance = bDeepInheritanceValue;
	}
	virtual ~CCimHttpEnumerateClassNames() 
	{
		if (m_strClassName)
			SysFreeString (m_strClassName);
	}

	WCHAR *GetMethodName ()
	{
		return L"EnumerateClassNames";
	}
};

class CCimHttpGetInstance : public CCimHttpGetClass
{
protected:
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
public:

	CCimHttpGetInstance(BSTR strInstanceName, BSTR *pstrPropertyList, DWORD dwPropCount,
		BOOLEAN bLocalOnly, BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin, 
		BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpGetInstance() {}

	WCHAR *GetMethodName ()
	{
		return L"GetInstance";
	}
};

class CCimHttpExecQuery : public CCimHttpIMethod
{
protected:
	BSTR m_strQuery;
	BSTR m_strQueryLanguage;

	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpExecQuery(BSTR m_strQuery, BSTR m_strQueryLanguage, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpExecQuery();
	const BSTR GetQuery() const
	{
		return m_strQuery;
	}

	const BSTR GetQueryLanguage() const
	{
		return m_strQueryLanguage;
	}

	WCHAR *GetMethodName ()
	{
		return L"ExecQuery";
	}

	HRESULT CreateFlagsContext();
};

class CCimHttpGetProperty : public CCimHttpIMethod
{
protected:
	BSTR m_strInstanceName;
	BSTR m_strPropertyName;
	
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpGetProperty(BSTR strInstanceName, BSTR strPropertyName, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpGetProperty();
	const BSTR GetInstanceName() const
	{
		return m_strInstanceName;
	}

	WCHAR *GetMethodName ()
	{
		return L"GetProperty";
	}
};

class CCimHttpSetProperty : public CCimHttpIMethod
{
protected:
	BSTR m_strInstanceName;
	BSTR m_strPropertyName;
	IXMLDOMNode	*m_pPropertyValue;
	
	virtual HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpSetProperty(BSTR strInstanceName, BSTR strPropertyName, 
						IXMLDOMNode *pPropertyValue, BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpSetProperty();
	const BSTR GetInstanceName() const
	{
		return m_strInstanceName;
	}

	WCHAR *GetMethodName ()
	{
		return L"SetProperty";
	}
};

class CCimHttpAssociators : public CCimHttpGetClass
{
protected:
	BSTR	m_strAssocClass;
	BSTR	m_strResultClass;
	BSTR	m_strRole;
	BSTR	m_strResultRole;
	HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpAssociators (BSTR strClassName, BSTR *strPropertyList, DWORD dwCount, 
			BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin, 
			BSTR strAssocClass, BSTR strResultClass, BSTR strRole, BSTR strResultRole,
			BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpAssociators();

	WCHAR *GetMethodName ()
	{
		return L"Associators";
	}
};

class CCimHttpAssociatorNames : public CCimHttpIMethod
{
protected:
	BSTR	m_strObjectName;
	BSTR	m_strAssocClass;
	BSTR	m_strResultClass;
	BSTR	m_strRole;
	BSTR	m_strResultRole;
	HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpAssociatorNames (BSTR strObjectName, 
			BSTR strAssocClass, BSTR strResultClass, BSTR strRole, BSTR strResultRole,
			BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpAssociatorNames();

	WCHAR *GetMethodName ()
	{
		return L"AssociatorNames";
	}
};

class CCimHttpReferences : public CCimHttpGetClass
{
protected:
	BSTR	m_strRole;
	BSTR	m_strResultClass;
	HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpReferences (BSTR strClassName, BSTR *strPropertyList, DWORD dwCount, 
			BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin, 
			BSTR strResultClass, BSTR strRole, 
			BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpReferences();

	WCHAR *GetMethodName ()
	{
		return L"References";
	}
};

class CCimHttpReferenceNames : public CCimHttpIMethod
{
protected:
	BSTR	m_strObjectName;
	BSTR	m_strRole;
	BSTR	m_strResultClass;
	HRESULT PrepareResponseBody(IStream *pPrefixStrean, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);

public:

	CCimHttpReferenceNames (BSTR strClassName, 
			BSTR strResultClass, BSTR strRole, 
			BSTR strNamespace, BSTR strID);
	virtual ~CCimHttpReferenceNames();

	WCHAR *GetMethodName ()
	{
		return L"ReferenceNames";
	}
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\strings.h ===
#ifndef WMI_XML_STRINGS_H
#define WMI_XML_STRINGS_H

// List of HTTP Methods supported by this extension
#define	HTTP_POST_METHOD	"POST"
#define HTTP_MPOST_METHOD	"M-POST"
#define HTTP_OPTIONS_METHOD	"OPTIONS"

// These are headers used in an M-POST request
#define HTTP_MAN_HEADER					"http://www.dmtf.org/cim/mapping/http/v1.0"
#define HTTP_NS							"ns="

// The Server Variable that gives the HTTP Version # and its possible values
#define SV_SERVER_PROTOCOL	"SERVER_PROTOCOL"
#define SV_HTTP_1_0			"HTTP/1.0"
#define SV_HTTP_1_1			"HTTP/1.1"

// List of content types we support
#define HTTP_TEXTXML_CONTENTTYPE	"text/xml"
#define HTTP_APPXML_CONTENTTYPE		"application/xml"

// Media type parameters
#define HTTP_PARAMETER_CHARSET		"charset="

// A Macro to skip white spaces - useful in header parsing
#define SKIPWS(x)	while (x && isspace (*x)) x++;

// Fragments of the response header
#define NORMAL_HTTP_HEADER		"Content-type: text/xml; charset=\"utf-8\"\r\n"
#define MAN_HTTP_HEADER			"Ext:\r\nCache-Control: no-cache\r\nMan: http://www.dmtf.org/cim/mapping/http/v1.0 ; ns="
#define CRLF_HTTP_HEADER		"\r\n"
#define CIMOP_HTTP_HEADER		"CIMOperation: MethodResponse\r\n\r\n"
#define HTTP_STATUS_200_OK		"200 OK"
#define HTTP_STATUS_207_OK		"207 MultiStatus"
static LPCSTR CHUNKED_HTTP_HEADER		= "Transfer-Encoding: chunked\r\nContent-type: text/xml; charset=\"utf-8\"\r\n";

// Various intrinsinc method names
#define ASSOCIATORS_METHOD					L"Associators"
#define ASSOCIATOR_NAMES_METHOD				L"AssociatorNames"
#define REFERENCES_METHOD					L"References"
#define REFERENCE_NAMES_METHOD				L"ReferenceNames"
#define GET_CLASS_METHOD					L"GetClass"
#define GET_INSTANCE_METHOD					L"GetInstance"
#define DELETE_CLASS_METHOD					L"DeleteClass"
#define DELETE_INSTANCE_METHOD				L"DeleteInstance"
#define CREATE_CLASS_METHOD					L"CreateClass"
#define CREATE_INSTANCE_METHOD				L"CreateInstance"
#define ENUMERATE_INSTANCES_METHOD			L"EnumerateInstances"
#define EXEC_QUERY_METHOD					L"ExecQuery"
#define ENUMERATE_INSTANCENAMES_METHOD		L"EnumerateInstanceNames"
#define ENUMERATE_CLASSNAMES_METHOD			L"EnumerateClassNames"
#define ENUMERATE_CLASSES_METHOD			L"EnumerateClasses"
#define	GET_PROPERTY_METHOD					L"GetProperty"
#define SET_PROPERTY_METHOD					L"SetProperty"
#define	MODIFY_CLASS_METHOD					L"ModifyClass"
#define MODIFY_INSTANCE_METHOD				L"ModifyInstance"

#ifdef WMI_XML_WHISTLER

// Various Whistler Method Names
#define GET_OBJECT_METHOD					L"GetObject"
#define ADD_METHOD							L"Add"
#define REMOVE_METHOD						L"Remove"
#define RENAME_METHOD						L"Rename"
#define GET_OBJECT_SECURITY_METHOD			L"GetObjectSecurity"
#define PUT_OBJECT_SECURITY_METHOD			L"PutObjectSecurity"

#endif

// Parameters of a Request
#define ASSOC_CLASS_PARAM					L"AssocClass"
#define CLASS_NAME_PARAM					L"ClassName"
#define DEEP_INHERITANCE_PARAM				L"DeepInheritance"
#define INCLUDE_CLASS_ORIGIN_PARAM			L"IncludeClassOrigin"
#define INCLUDE_QUALIFIERS_PARAM			L"IncludeQualifiers"
#define INSTANCE_NAME_PARAM					L"InstanceName"
#define LOCAL_ONLY_PARAM					L"LocalOnly"
#define MODIFIED_CLASS_PARAM				L"ModifiedClass"
#define MODIFIED_INSTANCE_PARAM				L"ModifiedInstance"
#define	NEW_CLASS_PARAM						L"NewClass"
#define	MODIFIED_CLASS_PARAM				L"ModifiedClass"
#define	LFLAGS_PARAM						L"LFlags"
#define	NEW_INSTANCE_PARAM					L"NewInstance"
#define NEW_VALUE_PARAM						L"NewValue"
#define OBJECT_NAME_PARAM					L"ObjectName"
#define PROPERTY_LIST_PARAM					L"PropertyList"
#define PROPERTY_NAME_PARAM					L"PropertyName"
#define QUERY_LANGUAGE_PARAM				L"QueryLanguage"
#define QUERY_PARAM							L"Query"
#define RESULT_CLASS_PARAM					L"ResultClass"
#define RESULT_ROLE_PARAM					L"ResultRole"
#define ROLE_PARAM							L"Role"

static LPCWSTR STRING_TYPE				= L"string";
static LPCWSTR FALSE_WSTR				= L"FALSE";
static LPCWSTR TRUE_WSTR				= L"TRUE";
static LPCWSTR WQL_WSTR					= L"WQL";
static LPCWSTR SELECT_WSTR				= L"select ";
static LPCWSTR FROM_WSTR				= L" from ";
static LPCWSTR BACK_SLASH_WSTR			= L"\\";
static LPCWSTR DOT_SIGN					= L".";
static LPCWSTR COMMA_SIGN				= L",";
static LPCWSTR EQUALS_SIGN				= L"=";
static LPCWSTR COLON_SIGN				= L":";
static LPCWSTR QUOTE_SIGN				= L"\"";

// Various tags we need to retreive
#define CIM_TAG					L"CIM"
#define CLASS_TAG				L"CLASS"
#define CLASSNAME_TAG			L"CLASSNAME"
#define CLASSPATH_TAG			L"CLASSPATH"
#define IMETHODCALL_TAG			L"IMETHODCALL"
#define INSTANCE_TAG			L"INSTANCE"
#define INSTANCENAME_TAG		L"INSTANCENAME"
#define INSTANCEPATH_TAG		L"INSTANCEPATH"
#define IPARAMVALUE_TAG			L"IPARAMVALUE"
#define KEYBINDING_TAG			L"KEYBINDING"
#define	KEYVALUE_TAG			L"KEYVALUE"
#define	LOCALCLASSPATH_TAG		L"LOCALCLASSPATH"
#define LOCALINSTANCEPATH_TAG	L"LOCALINSTANCEPATH"
#define LOCALNAMESPACEPATH_TAG	L"LOCALNAMESPACEPATH"
#define MESSAGE_TAG				L"MESSAGE"
#define METHOD_TAG				L"METHOD"
#define METHODCALL_TAG			L"METHODCALL"
#define MULTIREQ_TAG			L"MULTIREQ"
#define	NAMESPACEPATH_TAG		L"NAMESPACEPATH"
#define PARAMETER_TAG			L"PARAMETER"
#define PARAMETERARRAY_TAG		L"PARAMETER.ARRAY"
#define PARAMETERREFERENCE_TAG	L"PARAMETER.REFERENCE"
#define PARAMETERREFARRAY_TAG	L"PARAMETER.REFARRAY"
#define PARAMVALUE_TAG			L"PARAMVALUE"
#define PROPERTY_TAG			L"PROPERTY"
#define PROPERTYARRAY_TAG		L"PROPERTY.ARRAY"
#define PROPERTYREFERENCE_TAG	L"PROPERTY.REFERENCE"
#define PROPERTYREFARRAY_TAG	L"PROPERTY.REFARRAY"
#define PROPERTYOBJECT_TAG		L"PROPERTY.OBJECT"
#define PROPERTYOBJECTARRAY_TAG	L"PROPERTY.OBJECTARRAY"
#define QUALIFIER_TAG			L"QUALIFIER"
#define SIMPLEREQ_TAG			L"SIMPLEREQ"
#define VALUE_TAG				L"VALUE"
#define VALUEARRAY_TAG			L"VALUE.ARRAY"
#define VALUENAMEDOBJECT_TAG	L"VALUE.NAMEDOBJECT"
#define VALUEREFERENCE_TAG		L"VALUE.REFERENCE"
#define VALUEREFARRAY_TAG		L"VALUE.REFARRAY"
#define VALUEOBJECT_TAG			L"VALUE.OBJECT"
#define VALUEOBJECTARRAY_TAG	L"VALUE.OBJECTARRAY"
#define CONTEXTOBJECT_TAG		L"CONTEXTOBJECT"
#define CONTEXTPROPERTY_TAG		L"CONTEXTPROPERTY"
#define CONTEXTPROPERTYARRAY_TAG		L"CONTEXTPROPERTY.ARRAY"

// Various Attribute names we need
extern BSTR ARRAYSIZE_ATTRIBUTE;
extern BSTR CIMVERSION_ATTRIBUTE;
extern BSTR DTDVERSION_ATTRIBUTE;
extern BSTR CLASS_NAME_ATTRIBUTE;
extern BSTR CLASS_ORIGIN_ATTRIBUTE;
extern BSTR ID_ATTRIBUTE;
extern BSTR NAME_ATTRIBUTE;
extern BSTR OVERRIDABLE_ATTRIBUTE;
extern BSTR PROTOVERSION_ATTRIBUTE;
extern BSTR REFERENCECLASS_ATTRIBUTE;
extern BSTR	SUPERCLASS_ATTRIBUTE;
extern BSTR TOINSTANCE_ATTRIBUTE;
extern BSTR TOSUBCLASS_ATTRIBUTE;
extern BSTR AMENDED_ATTRIBUTE;
extern BSTR TYPE_ATTRIBUTE;
extern BSTR VALUE_TYPE_ATTRIBUTE;
extern BSTR VTTYPE_ATTRIBUTE;
extern BSTR WMI_ATTRIBUTE;

static BYTE NEWLINE [] = { 0x0D, 0x00, 0x0A, 0x00 };
static BYTE UTF16SIG [] = { 0xFF, 0xFE };


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\service.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  SERVICE.CPP
//
//  rajesh  3/25/2000   Created.
//
// This file implements a class that wraps a standard IWbemServices pointer and
// and IEnumWbemClassObject pointer so that the implementation in NT4.0 (in the
// out-of-proc XML transport in Winmgmt.exe) can be accessed in the same way 
// as the implementation in Win2k (standard COM pointers in WinMgmt.exe).
// Whenever and NT4.0 call is made, the thread token is sent in the call too,
// thereby acheiving COM cloaking
//
//***************************************************************************
//***************************************************************************
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include <comdef.h>
#include <wbemcli.h>
#include "wmixmlst.h"
#include "service.h"
#include "maindll.h"

CWMIXMLEnumWbemClassObject :: CWMIXMLEnumWbemClassObject(IEnumWbemClassObject *pEnum)
{
	m_ReferenceCount = 0 ;
	m_pEnum = NULL;
	m_pXMLEnum = NULL;
	m_pEnum = pEnum;
	if(m_pEnum)
		m_pEnum->AddRef();
}
CWMIXMLEnumWbemClassObject :: CWMIXMLEnumWbemClassObject(IWmiXMLEnumWbemClassObject *pEnum)
{
	m_ReferenceCount = 0 ;
	m_pEnum = NULL;
	m_pXMLEnum = NULL;
	m_pXMLEnum = pEnum;
	if(m_pXMLEnum)
		m_pXMLEnum->AddRef();
}

CWMIXMLEnumWbemClassObject :: ~CWMIXMLEnumWbemClassObject()
{
	if(m_pEnum)
		m_pEnum->Release();
	if(m_pXMLEnum)
		m_pXMLEnum->Release();
}


//***************************************************************************
//
// CWMIXMLServices::QueryInterface
// CWMIXMLServices::AddRef
// CWMIXMLServices::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CWMIXMLEnumWbemClassObject::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( IUnknown * ) this ;
	}
	else if ( iid == IID_IEnumWbemClassObject )
	{
		*iplpv = ( IEnumWbemClassObject * ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CWMIXMLEnumWbemClassObject :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CWMIXMLEnumWbemClassObject :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT STDMETHODCALLTYPE CWMIXMLEnumWbemClassObject::Next(
			long lTimeout,
			ULONG uCount,
			IWbemClassObject** apObjects,
			ULONG* puReturned
			)
{
	if(m_pEnum)
		return m_pEnum->Next(lTimeout, uCount, apObjects, puReturned);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			result = m_pXMLEnum->Next((DWORD_PTR)pNewToken, lTimeout, uCount, apObjects, puReturned);
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		else
		{
			if(pNewToken)
				m_pXMLEnum->FreeToken((DWORD_PTR)pNewToken);
		}

		return result;
	}

}


CWMIXMLServices :: CWMIXMLServices(IWbemServices *pServices)
{
	m_ReferenceCount = 0 ;
	m_pServices = NULL;
	m_pXMLServices = NULL;
	m_pServices = pServices;
	if(m_pServices)
		m_pServices->AddRef();
}
CWMIXMLServices :: CWMIXMLServices(IWmiXMLWbemServices *pServices)
{
	m_ReferenceCount = 0 ;
	m_pServices = NULL;
	m_pXMLServices = NULL;
	m_pXMLServices = pServices;
	if(m_pXMLServices)
		m_pXMLServices->AddRef();
}


CWMIXMLServices :: ~CWMIXMLServices()
{
	if(m_pServices)
		m_pServices->Release();
	if(m_pXMLServices)
		m_pXMLServices->Release();
}

//***************************************************************************
//
// CWMIXMLServices::QueryInterface
// CWMIXMLServices::AddRef
// CWMIXMLServices::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CWMIXMLServices::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( IUnknown * ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( IWbemServices * ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CWMIXMLServices :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CWMIXMLServices :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT STDMETHODCALLTYPE CWMIXMLServices :: GetObject(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	if(m_pServices)
		return m_pServices->GetObject(strObjectPath, lFlags, pCtx, ppObject, ppCallResult);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			result = m_pXMLServices->GetObject((DWORD_PTR)pNewToken, strObjectPath, lFlags, pCtx, ppObject, ppCallResult);
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		else
		{
			if(pNewToken)
				m_pXMLServices->FreeToken((DWORD_PTR)pNewToken);
		}
		return result;
	}
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	if(m_pServices)
		return m_pServices->PutClass(pObject, lFlags, pCtx, ppCallResult);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			result = m_pXMLServices->PutClass((DWORD_PTR)pNewToken, pObject, lFlags, pCtx, ppCallResult);
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		else
		{
			if(pNewToken)
				m_pXMLServices->FreeToken((DWORD_PTR)pNewToken);
		}
		return result;
	}
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: DeleteClass(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	if(m_pServices)
		return m_pServices->DeleteClass(strClass, lFlags, pCtx, ppCallResult);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			result = m_pXMLServices->DeleteClass((DWORD_PTR)pNewToken, strClass, lFlags, pCtx, ppCallResult);
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		else
		{
			if(pNewToken)
				m_pXMLServices->FreeToken((DWORD_PTR)pNewToken);
		}
		return result;
	}
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: CreateClassEnum(
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	if(m_pServices)
		return m_pServices->CreateClassEnum(strSuperclass, lFlags, pCtx, ppEnum);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			// Talk to WinMgmt
			IWmiXMLEnumWbemClassObject *pEnum = NULL;
			if(SUCCEEDED(result = m_pXMLServices->CreateClassEnum((DWORD_PTR)pNewToken, strSuperclass, lFlags, pCtx, &pEnum)))
			{
				// Wrap it up in one of our own enumerators
				*ppEnum = NULL;
				*ppEnum = new CWMIXMLEnumWbemClassObject(pEnum);
				pEnum->Release();
				if(!(*ppEnum))
					result = E_OUTOFMEMORY;
			}

			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		else
		{
			if(pNewToken)
				m_pXMLServices->FreeToken((DWORD_PTR)pNewToken);
		}
		return result;
	}
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	if(m_pServices)
		return m_pServices->PutInstance(pInst, lFlags, pCtx, ppCallResult);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			result = m_pXMLServices->PutInstance((DWORD_PTR)pNewToken, pInst, lFlags, pCtx, ppCallResult);
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		else
		{
			if(pNewToken)
				m_pXMLServices->FreeToken((DWORD_PTR)pNewToken);
		}
		return result;
	}
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: DeleteInstance(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	if(m_pServices)
		return m_pServices->DeleteInstance(strObjectPath, lFlags, pCtx, ppCallResult);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			result = m_pXMLServices->DeleteInstance((DWORD_PTR)pNewToken, strObjectPath, lFlags, pCtx, ppCallResult);
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		return result;
	}
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: CreateInstanceEnum(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	if(m_pServices)
		return m_pServices->CreateInstanceEnum(strClass, lFlags, pCtx, ppEnum);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			// Talk to WinMgmt
			IWmiXMLEnumWbemClassObject *pEnum = NULL;
			if(SUCCEEDED(result = m_pXMLServices->CreateInstanceEnum((DWORD_PTR)pNewToken, strClass, lFlags, pCtx, &pEnum)))
			{
				// Wrap it up in one of our own enumerators
				*ppEnum = NULL;
				*ppEnum = new CWMIXMLEnumWbemClassObject(pEnum);
				pEnum->Release();
				if(!(*ppEnum))
					result = E_OUTOFMEMORY;
			}
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		return result;
	}
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: ExecQuery(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	if(m_pServices)
		return m_pServices->ExecQuery(strQueryLanguage, strQuery, lFlags, pCtx, ppEnum);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			// Talk to WinMgmt
			IWmiXMLEnumWbemClassObject *pEnum = NULL;
			if(SUCCEEDED(result = m_pXMLServices->ExecQuery((DWORD_PTR)pNewToken, strQueryLanguage, strQuery, lFlags, pCtx, &pEnum)))
			{
				// Wrap it up in one of our own enumerators
				*ppEnum = NULL;
				*ppEnum = new CWMIXMLEnumWbemClassObject(pEnum);
				pEnum->Release();
				if(!(*ppEnum))
					result = E_OUTOFMEMORY;
			}
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		else
		{
			if(pNewToken)
				m_pXMLServices->FreeToken((DWORD_PTR)pNewToken);
		}
		return result;
	}
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: ExecMethod(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	if(m_pServices)
		return m_pServices->ExecMethod(strObjectPath, strMethodName, lFlags, pCtx, pInParams, ppOutParams, ppCallResult);
	else
	{
		HRESULT result = E_FAIL;
		HANDLE pNewToken = NULL;
		if(SUCCEEDED(result = DuplicateTokenInWinmgmt(&pNewToken)))
		{
			result = m_pXMLServices->ExecMethod((DWORD_PTR)pNewToken, strObjectPath, strMethodName, lFlags, pCtx, pInParams, ppOutParams, ppCallResult);
			// No Need to close the duplicated handle - it will be closed in WinMgmt
		}
		else
		{
			if(pNewToken)
				m_pXMLServices->FreeToken((DWORD_PTR)pNewToken);
		}
		return result;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\service.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  SERVICE.H
//
//  rajesh  3/25/2000   Created.
//
// This file defines a class that wraps a standard IWbemServices pointer and
// and IEnumWbemClassObject pointer so that the implementation in NT4.0 (in the
// out-of-proc XML transport in Winmgmt.exe) can be accessed in the same way 
// as the implementation in Win2k (standard COM pointers in WinMgmt.exe).
// Whenever and NT4.0 call is made, the thread token is sent in the call too,
// thereby acheiving COM cloaking
//
//***************************************************************************

#ifndef CWrappedServices_H
#define CWrappedServices_H

// A wrapper around IEnumWbemClassObject or IWmiXMLEnumWbemClassObject
class CWMIXMLEnumWbemClassObject : public IEnumWbemClassObject
{
	private:
		long m_ReferenceCount;
		IEnumWbemClassObject *m_pEnum;
		IWmiXMLEnumWbemClassObject *m_pXMLEnum;

	public:
		CWMIXMLEnumWbemClassObject(IEnumWbemClassObject *pEnum);
		CWMIXMLEnumWbemClassObject(IWmiXMLEnumWbemClassObject *pXMLEnum);
		virtual ~CWMIXMLEnumWbemClassObject();

		// Members of IUnknown
		STDMETHODIMP QueryInterface (REFIID iid, LPVOID FAR *iplpv);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		// Members of IEnumWbemClassObject
		virtual HRESULT STDMETHODCALLTYPE Reset()
		{
			return WBEM_E_NOT_SUPPORTED;
		}

		virtual HRESULT STDMETHODCALLTYPE Next(
			long lTimeout,
			ULONG uCount,
			IWbemClassObject** apObjects,
			ULONG* puReturned
			);

		virtual HRESULT STDMETHODCALLTYPE NextAsync(
			ULONG uCount,
			IWbemObjectSink* pSink
			)
		{
			return WBEM_E_NOT_SUPPORTED;
		}

		virtual HRESULT STDMETHODCALLTYPE Clone(
			IEnumWbemClassObject** ppEnum
			)
		{
			return WBEM_E_NOT_SUPPORTED;
		}

		virtual HRESULT STDMETHODCALLTYPE Skip(
			long lTimeout,
			ULONG nCount
			)
		{
			return WBEM_E_NOT_SUPPORTED;
		}

};

// A wrapper around IWbemServices or IWmiXMLWbemServices
class CWMIXMLServices : public IWbemServices
{
private:
    long m_ReferenceCount;
	IWbemServices *m_pServices;
	IWmiXMLWbemServices *m_pXMLServices;

public:
	CWMIXMLServices(IWbemServices *pServices);
	CWMIXMLServices(IWmiXMLWbemServices *pServices);
	virtual ~CWMIXMLServices();

	// Members of IUnknown
	STDMETHODIMP QueryInterface (REFIID iid, LPVOID FAR *iplpv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Members of IWmiXMLServices
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
	{
		return WBEM_E_NOT_SUPPORTED;
	}
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
	{
		return WBEM_E_NOT_SUPPORTED;
	}
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
	{
		return WBEM_E_NOT_SUPPORTED;
	}
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


};

#endif // #ifndef CWrappedServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\request.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  REQUEST.H
//
//  rajeshr  3/25/2000   Created.
//
// Contains the implementation of the classes that model the various operations that can be done on
// a CIMOM using the XML/HTTP transport
//
//***************************************************************************

#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <httpext.h>
#include <msxml.h>
#include <time.h>
#include "wbemcli.h"

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <cominit.h>

#include "provtempl.h"
#include "common.h"
#include "wmixmlop.h"
#include "wmixmlst.h"
#include "concache.h"
#include "strings.h"
#include "cimerr.h"
#include "errors.h"
#include "wmiconv.h"
#include "request.h"
#include "xmlhelp.h"
#include "xml2wmi.h"
#include "wmixmlt.h"
#include "strings.h"
#include "parse.h"

// This indicates whether the random number generator has been seeded
BOOLEAN g_sRandom = FALSE;

// Note that we copy BSTR pointers from the input arguments instead of making
// a copy of them. This is how the contract is.
// The BSTRs get freed in the destructor
CCimHttpMessage :: CCimHttpMessage(BSTR pszID, BOOL bIsMpostRequest = FALSE)
{
	m_iHttpVersion = WMI_XML_HTTP_VERSION_INVALID;
	m_strID = pszID;
	m_httpStatus = NULL;
	m_WMIStatus = WBEM_E_FAILED;
	m_bIsMpostRequest = bIsMpostRequest;
	m_bIsMicrosoftWMIClient = FALSE;
	m_pHeaderStream = NULL;
	m_pTrailerStream = NULL;
	m_pFlagsContext = NULL;
}

CCimHttpMessage :: ~CCimHttpMessage()
{
	SysFreeString(m_strID);

	if(m_pFlagsContext)
		m_pFlagsContext->Release();

	if (m_pHeaderStream)
		m_pHeaderStream->Release();

	if (m_pTrailerStream)
		m_pTrailerStream->Release();

	delete [] m_httpStatus;

}

// INitializes the Header and Trailer streams
HRESULT CCimHttpMessage :: Initialize()
{
	HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pHeaderStream);

	// We need to create a trailer stream only for a HTTP 1.1 request since
	// for a HTTP 1.0 request everything (including the body) gets written onto
	// the header stream since chunked encoding is absent
	if(SUCCEEDED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pTrailerStream);
	return hr;
}

// Creates an IWbemCOntext object with the correct context values required for
// conversion of WMI objects to XML for this specific operation
HRESULT CCimHttpMessage :: CreateFlagsContext()
{
	HRESULT hr = E_FAIL;
	// Create an IWbemContext object
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemContext,
		0,
		CLSCTX_INPROC_SERVER,
		IID_IWbemContext, (LPVOID *) &m_pFlagsContext)))
	{
		if(SUCCEEDED(hr = SetBoolProperty(L"AllowWMIExtensions", m_bIsMicrosoftWMIClient)))
		{
		}
	}
	return hr;
}

// A Helper function for setting a booles value in a context
HRESULT CCimHttpMessage :: SetBoolProperty(LPCWSTR pszName, BOOL bValue)
{
	HRESULT result = E_FAIL;
	VARIANT vValue;
	VariantInit(&vValue);
	vValue.vt = VT_BOOL;
	if(bValue)
		vValue.boolVal = VARIANT_TRUE;
	else
		vValue.boolVal = VARIANT_FALSE;

	result = m_pFlagsContext->SetValue(pszName, 0, &vValue);
	VariantClear(&vValue);
	return result;
}

// This is the main function that is called by a user of this class to encode
// a response to the XML/HTTP request.
HRESULT CCimHttpMessage :: EncodeNormalResponse(LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT result = E_FAIL;

	// INitialize te header and trailer streams
	if(SUCCEEDED(result = Initialize()))
	{
		// By this time, there cannot be any HTTP errors in the response, only CIM errors.
		// Hence we are free to write the Common CIM Headers and trailers
		//======================================================================

		// Write the CIM and MESSAGE Tags
		PrepareCommonHeaders();

		// Get WinMgmt's verdict and write the SIMPLERSP, IMETHODRESPONSE/METHODRESPONSE, IRETURNVALUE/RETURNVALUE and body
		TalkToWinMgmtAndPrepareResponse(pECB);

		// Terminate the CIM and MESSAGE Elements
		PrepareCommonTrailersAndWriteToSocket(pECB);
	}

	return result;
}

// In this function we write till the MESSAGE element in a response
HRESULT CCimHttpMessage :: PrepareCommonHeaders()
{
	WRITEWSTR(m_pHeaderStream, L"<?xml version=\"1.0\" ?>");
	WRITENL(m_pHeaderStream) ;
	WRITEWSTR(m_pHeaderStream, L"<CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\">");
	WRITENL(m_pHeaderStream) ;
	WRITEWSTR(m_pHeaderStream, L"<MESSAGE ID=\"");
	WRITEWSTR(m_pHeaderStream, m_strID);
	WRITEWSTR(m_pHeaderStream, L"\" PROTOCOLVERSION=\"1.0\">");
	WRITENL(m_pHeaderStream) ;

	return S_OK;
}

// Get WinMgmt's verdict and write the SIMPLERSP, IMETHODRESPONSE/METHODRESPONSE, IRETURNVALUE and body
HRESULT CCimHttpMessage :: TalkToWinMgmtAndPrepareResponse (LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT result = E_FAIL;

	WRITEWSTR(m_pHeaderStream, L"<SIMPLERSP>");
	WRITENL(m_pHeaderStream) ;
	WriteMethodHeader (); // Write the IMETHODRESPONSE/METHODRESPONSE tag
	WRITENL(m_pHeaderStream) ;

	// Now, we can have only CIM Errors, no HTTP errors. Hence we're free to
	// send the header 200 OK
	switch(m_iHttpVersion)
	{
		case WMI_XML_HTTP_VERSION_1_0:
		{
			if(SendHTTPHeaders(pECB, HTTP_STATUS_200_OK, NORMAL_HTTP_HEADER))
				result =  S_OK;
			break;
		}
		case WMI_XML_HTTP_VERSION_1_1:
		{
			if(SendHTTPHeaders(pECB, HTTP_STATUS_200_OK, CHUNKED_HTTP_HEADER))
				result =  S_OK;
			break;
		}
	}
	if(FAILED(result))
		return result;

	// This call talks to WinMgmt and ensures that the contents of m_pHeaderStream are written to
	// the Socket irrespective of whether the chat with WinMgmt succeeded or not.
	// This is because all the headers till IMETHODRESPONSE/METHODRESPONSE are required
	// even if are encoding an error object by the call to EncodeErrorObject() below
	if(SUCCEEDED(result = PrepareResponseBody (m_pHeaderStream, m_pTrailerStream,  pECB)))
	{
	}

	// Send an error object in the body if the above call FAILED
	//===========================================================
	if(FAILED(result))
	{
		EncodeErrorObject(result);
	}


	// We have to write this irrespsective of whether the call to PrepareResponseBody succeeds
	WriteMethodTrailer (); // Terminate the IMETHODRESPONSE/METHODRESPONSE tag

	// For HTTP 1.0, we write everything on to the header stream since there is no
	// chunked encoding
	switch(m_iHttpVersion)
	{
		case WMI_XML_HTTP_VERSION_1_0:
		{
			WRITENL(m_pHeaderStream) ;
			WRITEWSTR(m_pHeaderStream, L"</SIMPLERSP>");
			WRITENL(m_pHeaderStream) ;
			break;
		}
		case WMI_XML_HTTP_VERSION_1_1:
		{
			WRITENL(m_pTrailerStream) ;
			WRITEWSTR(m_pTrailerStream, L"</SIMPLERSP>");
			WRITENL(m_pTrailerStream) ;
			break;
		}
	}

	return result;
}

HRESULT CCimHttpMessage :: EncodeErrorObject(HRESULT result)
{
	// Encodes a suitable error object in the stream
	// Map the WMI error to CIM First
	//===============================================

	int cimError = CIM_ERR_FAILED;
	switch(result)
	{
		case WBEM_E_ACCESS_DENIED: cimError = CIM_ERR_ACCESS_DENIED; break;
		case WBEM_E_INVALID_NAMESPACE: cimError = CIM_ERR_INVALID_NAMESPACE; break;
		case WBEM_E_INVALID_PARAMETER: cimError = CIM_ERR_INVALID_PARAMETER; break;
		case WBEM_E_INVALID_CLASS: cimError = CIM_ERR_INVALID_CLASS; break;
		case WBEM_E_NOT_FOUND: cimError = CIM_ERR_NOT_FOUND; break;
		case WBEM_E_NOT_SUPPORTED: cimError = CIM_ERR_NOT_SUPPORTED; break;
		case WBEM_E_CLASS_HAS_CHILDREN: cimError = CIM_ERR_CLASS_HAS_CHILDREN; break;
		case WBEM_E_CLASS_HAS_INSTANCES: cimError = CIM_ERR_CLASS_HAS_INSTANCES; break;
		case WBEM_E_INVALID_SUPERCLASS: cimError = CIM_ERR_INVALID_SUPERCLASS; break;
		case WBEM_E_ALREADY_EXISTS: cimError = CIM_ERR_ALREADY_EXISTS; break;
		case WBEM_E_INVALID_PROPERTY: cimError = CIM_ERR_NO_SUCH_PROPERTY; break;
		case WBEM_E_TYPE_MISMATCH: cimError = CIM_ERRTYPE_MISMATCH; break;
		case WBEM_E_INVALID_QUERY_TYPE: cimError = CIM_ERR_QUERY_LANGUAGE_NOT_SUPPORTED; break;
		case WBEM_E_INVALID_QUERY: cimError = CIM_ERR_INVALID_QUERY; break;
	}

	WCHAR errBuf[250];
	swprintf(errBuf, L"<ERROR CODE=\"%d\" DESCRIPTION=\"%s\">", cimError, cimErrorStrings[cimError]);
	switch(m_iHttpVersion)
	{
		case WMI_XML_HTTP_VERSION_1_0:
			WRITEWSTR(m_pHeaderStream, errBuf);
			WRITEWSTR(m_pHeaderStream, L"</ERROR>");
			break;

		case WMI_XML_HTTP_VERSION_1_1:
			WRITEWSTR(m_pTrailerStream, errBuf);
			WRITEWSTR(m_pTrailerStream, L"</ERROR>");
			break;
	}

	return S_OK;
}


HRESULT CCimHttpMessage :: PrepareCommonTrailersAndWriteToSocket(LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT result = E_FAIL;
	switch(m_iHttpVersion)
	{
		case WMI_XML_HTTP_VERSION_1_0:
			WRITEWSTR(m_pHeaderStream, L"</MESSAGE>");
			WRITENL(m_pHeaderStream) ;
			WRITEWSTR(m_pHeaderStream, L"</CIM>");
			WRITENL(m_pHeaderStream) ;
			result = SaveStreamToIISSocket(m_pHeaderStream, pECB, FALSE, TRUE);
			break;
		case WMI_XML_HTTP_VERSION_1_1:
			WRITEWSTR(m_pTrailerStream, L"</MESSAGE>");
			WRITENL(m_pTrailerStream) ;
			WRITEWSTR(m_pTrailerStream, L"</CIM>");
			WRITENL(m_pTrailerStream) ;
			result = SaveStreamToIISSocket(m_pTrailerStream, pECB, TRUE, TRUE);
			break;
	}

	return result;
}

BOOL CCimHttpMessage::SendHTTPHeaders(
	LPEXTENSION_CONTROL_BLOCK pECB,
	LPCSTR pszStatus,
	LPCSTR pszHeader
)
{
	// INitialize the return value from this function
	BOOL bStatus = FALSE;

	// Calculate the length of the header - depends if we are doing MPOST or
	// not
	DWORD len = strlen (pszHeader) + strlen (CIMOP_HTTP_HEADER);

	if (m_bIsMpostRequest)
	{
		len += strlen (MAN_HTTP_HEADER) + 7;
		// Generate a pseudo-random number with the current time as seed
		if (!g_sRandom)
		{
			srand( (unsigned) time (NULL) );
			g_sRandom = TRUE;
		}
	}

	LPSTR pszFullHeader = NULL;
	if(pszFullHeader = new char [len + 1])
	{
		if (m_bIsMpostRequest)
		{
			// Make sure result is in the range 0 to 99
			int i = (100 * rand () / RAND_MAX);
			if (100 == i)
				i--;

			sprintf (pszFullHeader, "%s%s%02d\r\n%02d-%s",
					pszHeader, MAN_HTTP_HEADER, i, i, CIMOP_HTTP_HEADER);
		}
		else
			sprintf (pszFullHeader, "%s%s", pszHeader, CIMOP_HTTP_HEADER);

		// Write successful HTTP headers. It doesnt matter if the above call failed
		//==========================================================================
		HSE_SEND_HEADER_EX_INFO HeaderExInfo;
		HeaderExInfo.pszStatus = pszStatus;
		HeaderExInfo.pszHeader = pszFullHeader;
		HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
		HeaderExInfo.cchHeader = strlen( HeaderExInfo.pszHeader );
		// For HTTP 1.1, we always keep the connection open
		// For HTTP 1.0, we're either required to close the connection or write a
		// content-lenght header. Since we arent writing a content-length header,
		// we close the connection
		if(m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
			HeaderExInfo.fKeepConn = TRUE;
		else
			HeaderExInfo.fKeepConn = FALSE;

		// Send headers using IIS-provided callback
		// (note - if we needed to keep connection open,
		//  we would set fKeepConn to TRUE *and* we would
		//  need to provide correct Content-Length: header)
		bStatus = pECB->ServerSupportFunction(
			pECB->ConnID,
			HSE_REQ_SEND_RESPONSE_HEADER_EX,
			&HeaderExInfo,
			NULL,
			NULL
			);

		delete [] pszFullHeader;
	}
	return bStatus;
}

// CCimHttpMultiMessage
CCimHttpMultiMessage :: CCimHttpMultiMessage(BSTR strID, BOOL bIsMpostRequest)
	: CCimHttpMessage (strID, bIsMpostRequest)
{
	m_ppSimpleMessages = NULL;
	m_dwSimpleMessageCount = 0;

}

CCimHttpMultiMessage :: ~CCimHttpMultiMessage()
{
	// First delete the object pointed to by each of the pointers in the array.
	for(DWORD i=0; i<m_dwSimpleMessageCount; i++)
		delete m_ppSimpleMessages[i];
	// Delete the array of pointers itself
	delete [] m_ppSimpleMessages;
}

void CCimHttpMultiMessage :: SetSimpleRequests(CCimHttpMessage **ppSimpleMessages, DWORD dwSimpleMessageCount)
{
	// First delete the object pointed to by each of the pointers in the array.
	for(DWORD i=0; i<m_dwSimpleMessageCount; i++)
		delete m_ppSimpleMessages[i];
	// Delete the array of pointers itself
	delete [] m_ppSimpleMessages;

	m_dwSimpleMessageCount = dwSimpleMessageCount;
	m_ppSimpleMessages = ppSimpleMessages;
}

CCimHttpMessage **CCimHttpMultiMessage :: GetSimpleRequests(DWORD *pdwSimpleMessageCount)
{
	*pdwSimpleMessageCount = m_dwSimpleMessageCount;
	return m_ppSimpleMessages;
}

HRESULT CCimHttpMultiMessage :: EncodeNormalResponse(LPEXTENSION_CONTROL_BLOCK pECB)
{
	if(!SendHTTPHeaders(pECB, HTTP_STATUS_207_OK, NORMAL_HTTP_HEADER))
		return E_FAIL;

	PrepareCommonHeaders();
	WRITEWSTR(m_pHeaderStream, L"<MULTIRSP>");
	WRITENL(m_pHeaderStream) ;

	// Initialize 2 streams (a header and a trailer) for each iteration of the loop below
	IStream *pLastTrailerStream = m_pHeaderStream;
	pLastTrailerStream->AddRef();
	IStream *pCurrentTrailerStream = NULL;

	// Execute each of the SIMPLEREQ objects in this MULTIREQ object
	//==============================================================
	CCimHttpMessage *pNextSimpleReq = NULL;
	for(DWORD i=0; i<m_dwSimpleMessageCount; i++)
	{
		pNextSimpleReq = m_ppSimpleMessages[i];

		// Write the headers in this request on to the trailer stream of the previous request
		WRITEWSTR(pLastTrailerStream, L"<SIMPLERSP>");
		WRITENL(pLastTrailerStream) ;
		pNextSimpleReq->WriteMethodHeader ();
		WRITENL(pLastTrailerStream) ;

		// Create a new trailer stream for the current request
		if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pCurrentTrailerStream)))
		{
			HRESULT result = pNextSimpleReq->PrepareResponseBody (pLastTrailerStream, pCurrentTrailerStream,  pECB);

			if(FAILED(result))
			{
				pNextSimpleReq->EncodeErrorObject(result);
			}

			// Release the last trailer stream and update it with the current one
			pLastTrailerStream->Release();
			pLastTrailerStream = pCurrentTrailerStream; // Optimize on an AddRef/Release combination here
		}

		// Write the trailers in this request on to the trailer stream of the last request in the loop above
		m_pTrailerStream->Release();
		m_pTrailerStream = pCurrentTrailerStream;// Optimize on an AddRef/Release combination here
		pNextSimpleReq->WriteMethodTrailer ();
		WRITENL(m_pTrailerStream) ;
		WRITEWSTR(m_pTrailerStream, L"</SIMPLERSP>");
		WRITENL(m_pTrailerStream) ;

		pNextSimpleReq = NULL;
	}

	HRESULT result = E_FAIL;
	WRITEWSTR(m_pTrailerStream, L"</MULTIRSP>");
	PrepareCommonTrailersAndWriteToSocket(pECB);

	return result;
}

// CCimHttpIMethod
CCimHttpIMethod :: CCimHttpIMethod(BSTR strNamespace, BSTR strID)
: CCimDMTFOrNovaMessage(strID)
{
	m_strNamespace = strNamespace;
	m_lFlags = 0;
}

CCimHttpIMethod :: ~CCimHttpIMethod()
{
	SysFreeString(m_strNamespace);
}

void CCimHttpIMethod :: WriteMethodHeader ()
{
	WRITEWSTR(m_pHeaderStream, L"<IMETHODRESPONSE NAME=\"");
	WRITEWSTR(m_pHeaderStream, GetMethodName ());
	WRITEWSTR(m_pHeaderStream, L"\">");

}

void CCimHttpIMethod :: WriteMethodTrailer ()
{
	switch(m_iHttpVersion)
	{
		case WMI_XML_HTTP_VERSION_1_0:
			WRITEWSTR(m_pHeaderStream, L"</IMETHODRESPONSE>");
			break;

		case WMI_XML_HTTP_VERSION_1_1:
			WRITEWSTR(m_pTrailerStream, L"</IMETHODRESPONSE>");
			break;
	}
}

// CCimHttpGetClass
CCimHttpGetClass :: CCimHttpGetClass(BSTR strClassName, BSTR *pstrPropertyList, DWORD dwPropCount,
									 BOOLEAN bLocalOnly, BOOLEAN bIncludeQualifiers,
									 BOOLEAN bIncludeClassOrigin, BSTR strNamespace, BSTR strID)
: CCimHttpIMethod(strNamespace, strID)
{
	m_strClassName = strClassName;
	m_bLocalOnly = bLocalOnly;
	m_bIncludeQualifiers = bIncludeQualifiers;
	m_bIncludeClassOrigin = bIncludeClassOrigin;
	m_strPropertyList = pstrPropertyList;
	m_dwPropCount = dwPropCount;
}

CCimHttpGetClass :: ~CCimHttpGetClass()
{
	SysFreeString(m_strClassName);

	for(DWORD i=0; i<m_dwPropCount; i++)
		SysFreeString(m_strPropertyList[i]);
	delete [] m_strPropertyList;
}


HRESULT CCimHttpGetClass :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.GetObject(m_strNamespace, m_strClassName,
								m_dwPropCount, m_strPropertyList, pECB, m_pFlagsContext);
	}
	return hr;
}

HRESULT CCimHttpGetClass :: CreateFlagsContext()
{
	HRESULT hr = E_FAIL;
	// Create an IWbemContext object
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemContext,
		0,
		CLSCTX_INPROC_SERVER,
		IID_IWbemContext, (LPVOID *) &m_pFlagsContext)))
	{
		if(SUCCEEDED(hr = SetBoolProperty(L"IncludeQualifiers", m_bIncludeQualifiers)))
		{
			if(SUCCEEDED(hr = SetBoolProperty(L"LocalOnly", m_bLocalOnly)))
			{
				if(SUCCEEDED(hr = SetBoolProperty(L"IncludeClassOrigin", m_bIncludeClassOrigin)))
				{
					if(SUCCEEDED(hr = SetBoolProperty(L"AllowWMIExtensions", m_bIsMicrosoftWMIClient)))
					{
					}
				}
			}
		}
	}
	return hr;
}

// CCimHttpCreateClass
CCimHttpCreateClass :: CCimHttpCreateClass(IXMLDOMNode *pClass, BSTR strNamespace, BSTR strID,
										   BOOL bIsModify)
: CCimHttpIMethod(strNamespace, strID)
{
	if(m_pClass = pClass)
		m_pClass->AddRef();
	m_bIsModify = bIsModify;
}

CCimHttpCreateClass :: ~CCimHttpCreateClass()
{
	if(m_pClass)
		m_pClass->Release ();
}


HRESULT CCimHttpCreateClass :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.CreateClass(m_strNamespace, m_pClass, m_bIsModify, pECB, m_pFlagsContext, m_lFlags);
	}
	return hr;
}

// CCimHttpDeleteClass
CCimHttpDeleteClass :: CCimHttpDeleteClass(BSTR strClassName, BSTR strNamespace, BSTR strID)
: CCimHttpIMethod(strNamespace, strID)
{
	m_strClassName = strClassName;
}

CCimHttpDeleteClass :: ~CCimHttpDeleteClass()
{
	SysFreeString(m_strClassName);
}

HRESULT CCimHttpDeleteClass :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.DeleteObject (m_strNamespace, m_strClassName, TRUE, pECB, m_pFlagsContext);
	}
	return hr;
}

// CCimHttpCreateInstance
CCimHttpCreateInstance :: CCimHttpCreateInstance(
	IXMLDOMNode *pInstance,
	BSTR strNamespace,
	BSTR strID
)
	: CCimHttpIMethod(strNamespace, strID)
{
	if(m_pInstance = pInstance)
		m_pInstance->AddRef();
}

CCimHttpCreateInstance :: ~CCimHttpCreateInstance()
{
	if(m_pInstance)
		m_pInstance->Release ();
}


HRESULT CCimHttpCreateInstance :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.CreateInstance(m_strNamespace, m_pInstance, pECB, m_pFlagsContext, m_lFlags);
	}
	return hr;
}

// CCimHttpModifyInstance
CCimHttpModifyInstance :: CCimHttpModifyInstance(
	IXMLDOMNode *pInstance,
	BSTR strInstanceName,
	BSTR strNamespace,
	BSTR strID
)
	: CCimHttpIMethod(strNamespace, strID)
{
	if(m_pInstance = pInstance)
		m_pInstance->AddRef();
	m_bsInstanceName = strInstanceName;
}

CCimHttpModifyInstance :: ~CCimHttpModifyInstance()
{
	if(m_pInstance)
		m_pInstance->Release ();

	SysFreeString (m_bsInstanceName);
}


HRESULT CCimHttpModifyInstance :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.ModifyInstance(m_strNamespace, m_pInstance, m_bsInstanceName, pECB, m_pFlagsContext, m_lFlags);
	}
	return hr;
}

// CCimHttpDeleteInstance
CCimHttpDeleteInstance :: CCimHttpDeleteInstance(BSTR strInstanceName, BSTR strNamespace, BSTR strID)
: CCimHttpIMethod(strNamespace, strID)
{
	m_strInstanceName = strInstanceName;
}

CCimHttpDeleteInstance :: ~CCimHttpDeleteInstance()
{
	SysFreeString(m_strInstanceName);
}

HRESULT CCimHttpDeleteInstance :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.DeleteObject (m_strNamespace, m_strInstanceName, FALSE, pECB, m_pFlagsContext);
	}
	return hr;
}

// EnumerateClasses

CCimHttpEnumerateClasses :: CCimHttpEnumerateClasses(BSTR strClassName, BSTR *pstrPropertyList,
				DWORD dwPropCount, BOOLEAN bDeepInheritance, BOOLEAN bLocalOnly, BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin, BSTR strNamespace, BSTR strID)
: CCimHttpGetClass(strClassName, pstrPropertyList, dwPropCount, bLocalOnly, bIncludeQualifiers, bIncludeClassOrigin, strNamespace, strID)
{
	m_bDeepInheritance = bDeepInheritance;
}

HRESULT CCimHttpEnumerateClasses :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.EnumerateClasses(m_strNamespace, m_strClassName,
			(m_bDeepInheritance)? VARIANT_TRUE : VARIANT_FALSE, m_dwPropCount, m_strPropertyList, pECB, m_pFlagsContext);
	}
	return hr;
}

// EnumerateInstances
CCimHttpEnumerateInstances :: CCimHttpEnumerateInstances(BSTR strClassName, BSTR *pstrPropertyList,
		DWORD dwCount, BOOLEAN bDeepInheritance, BOOLEAN bLocalOnly, BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin, BSTR strNamespace, BSTR strID)
: CCimHttpGetClass(strClassName, pstrPropertyList, dwCount,
				   bLocalOnly, bIncludeQualifiers, bIncludeClassOrigin, strNamespace, strID)
{
	m_bDeepInheritance = bDeepInheritance;
}

HRESULT CCimHttpEnumerateInstances :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.EnumerateInstances (m_strNamespace, m_strClassName,
			(m_bDeepInheritance)? VARIANT_TRUE : VARIANT_FALSE, m_bIsMicrosoftWMIClient, m_dwPropCount, m_strPropertyList, pECB, m_pFlagsContext);
	}
	return hr;
}

// EnumerateInstanceNames

HRESULT CCimHttpEnumerateInstanceNames :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.EnumerateInstanceNames
				(m_strNamespace, m_strClassName, pECB, m_pFlagsContext);
	}
	return hr;
}

// EnumerateClassNames

HRESULT CCimHttpEnumerateClassNames :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.EnumerateClassNames
				(m_strNamespace, m_strClassName, m_bDeepInheritance, pECB, m_pFlagsContext);
	}
	return hr;
}

// GetInstance
CCimHttpGetInstance :: CCimHttpGetInstance(BSTR strInstanceName,
		BSTR *pstrPropertyList, DWORD dwPropCount,
		BOOLEAN bLocalOnly, BOOLEAN bIncludeQualifiers, BOOLEAN bIncludeClassOrigin,
		BSTR strNamespace, BSTR strID)
: CCimHttpGetClass (strInstanceName, pstrPropertyList, dwPropCount,
					bLocalOnly, bIncludeQualifiers, bIncludeClassOrigin,
					strNamespace, strID)
{
}


HRESULT CCimHttpGetInstance :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.GetObject(m_strNamespace, m_strClassName, m_dwPropCount, m_strPropertyList, pECB, m_pFlagsContext);
	}
	return hr;
}

// CCimHttpExecQuery
CCimHttpExecQuery :: CCimHttpExecQuery(BSTR strQuery, BSTR strQueryLanguage, BSTR strNamespace, BSTR strID)
: CCimHttpIMethod(strNamespace, strID)
{
	m_strQueryLanguage = strQueryLanguage;
	m_strQuery = strQuery;
}

CCimHttpExecQuery :: ~CCimHttpExecQuery()
{
	SysFreeString(m_strQueryLanguage);
	SysFreeString(m_strQuery);
}

HRESULT CCimHttpExecQuery :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.ExecuteQuery(m_strNamespace, m_strQueryLanguage, m_strQuery, pECB, m_pFlagsContext);
	}
	return hr;
}

// Creates an IWbemCOntext object with the correct context values required for
// conversion of WMI objects to XML for this specific operation
HRESULT CCimHttpExecQuery :: CreateFlagsContext()
{
	HRESULT hr = E_FAIL;
	// Create an IWbemContext object
	// We want to give out as much information as possible in a query
	// THat is include qualifiers and class origin
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemContext,
		0,
		CLSCTX_INPROC_SERVER,
		IID_IWbemContext, (LPVOID *) &m_pFlagsContext)))
	{
		if(SUCCEEDED(hr = SetBoolProperty(L"IncludeQualifiers", TRUE)))
		{
			if(SUCCEEDED(hr = SetBoolProperty(L"IncludeClassOrigin", TRUE)))
			{
				if(SUCCEEDED(hr = SetBoolProperty(L"AllowWMIExtensions", m_bIsMicrosoftWMIClient)))
				{
				}
			}
		}
	}
	return hr;
}

// GetProperty
CCimHttpGetProperty :: CCimHttpGetProperty(BSTR strInstanceName, BSTR strPropertyName, BSTR strNamespace, BSTR strID)
: CCimHttpIMethod(strNamespace, strID)
{
	m_strInstanceName = strInstanceName;
	m_strPropertyName = strPropertyName;
}

CCimHttpGetProperty :: ~CCimHttpGetProperty()
{
	SysFreeString(m_strInstanceName);
	SysFreeString(m_strPropertyName);
}

HRESULT CCimHttpGetProperty :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.GetProperty(m_strNamespace, m_strInstanceName,
			m_strPropertyName, pECB, m_pFlagsContext);
	}
	return hr;
}

// SetProperty
CCimHttpSetProperty :: CCimHttpSetProperty(BSTR strInstanceName, BSTR strPropertyName,
							IXMLDOMNode *pPropertyValue, BSTR strNamespace, BSTR strID)
: CCimHttpIMethod(strNamespace, strID)
{
	m_strInstanceName = strInstanceName;
	m_strPropertyName = strPropertyName;
	if (m_pPropertyValue = pPropertyValue)
		m_pPropertyValue->AddRef ();
}

CCimHttpSetProperty :: ~CCimHttpSetProperty()
{
	SysFreeString(m_strInstanceName);
	SysFreeString(m_strPropertyName);
	if (m_pPropertyValue)
		m_pPropertyValue->Release ();
}

HRESULT CCimHttpSetProperty :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.SetProperty(m_strNamespace, m_strInstanceName,
				m_strPropertyName, m_pPropertyValue, pECB, m_pFlagsContext);
	}
	return hr;
}

// Associators

CCimHttpAssociators :: CCimHttpAssociators(
	BSTR strObjectName,
	BSTR *pstrPropertyList,
	DWORD dwCount,
	BOOLEAN bIncludeQualifiers,
	BOOLEAN bIncludeClassOrigin,
	BSTR strAssocClass,
	BSTR strResultClass,
	BSTR strRole,
	BSTR strResultRole,
	BSTR strNamespace,
	BSTR strID)
: CCimHttpGetClass(strObjectName, pstrPropertyList, dwCount, FALSE, bIncludeQualifiers, bIncludeClassOrigin,
				   strNamespace, strID)
{
	m_strAssocClass = strAssocClass,
	m_strResultClass = strResultClass;
	m_strRole = strRole;
	m_strResultRole = strResultRole;
}

CCimHttpAssociators :: ~CCimHttpAssociators()
{
	SysFreeString (m_strAssocClass);
	SysFreeString (m_strResultClass);
	SysFreeString (m_strRole);
	SysFreeString (m_strResultRole);
}


HRESULT CCimHttpAssociators :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
			CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
			hr = xmlTranslator.Associators(m_strNamespace, m_strClassName,
							m_strAssocClass, m_strResultClass, m_strRole, m_strResultRole, m_dwPropCount, m_strPropertyList, pECB, m_pFlagsContext);
	}
	return hr;
}

// AssociatorNames

CCimHttpAssociatorNames :: CCimHttpAssociatorNames(
	BSTR strObjectName,
	BSTR strAssocClass,
	BSTR strResultClass,
	BSTR strRole,
	BSTR strResultRole,
	BSTR strNamespace,
	BSTR strID)
: CCimHttpIMethod(strNamespace, strID)
{
	m_strObjectName =strObjectName;
	m_strAssocClass = strAssocClass,
	m_strResultClass = strResultClass;
	m_strRole = strRole;
	m_strResultRole = strResultRole;
}

CCimHttpAssociatorNames :: ~CCimHttpAssociatorNames()
{
	SysFreeString (m_strObjectName);
	SysFreeString (m_strAssocClass);
	SysFreeString (m_strResultClass);
	SysFreeString (m_strRole);
	SysFreeString (m_strResultRole);
}


HRESULT CCimHttpAssociatorNames :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		return xmlTranslator.AssociatorNames
			(m_strNamespace, m_strObjectName, m_strAssocClass,
			 m_strResultClass, m_strRole, m_strResultRole, pECB, m_pFlagsContext);
	}
	return hr;
}

// References

CCimHttpReferences :: CCimHttpReferences(
	BSTR strObjectName,
	BSTR *pstrPropertyList,
	DWORD dwCount,
	BOOLEAN bIncludeQualifiers,
	BOOLEAN bIncludeClassOrigin,
	BSTR strResultClass,
	BSTR strRole,
	BSTR strNamespace,
	BSTR strID)
: CCimHttpGetClass(strObjectName, pstrPropertyList, dwCount, FALSE, bIncludeQualifiers, bIncludeClassOrigin,
				   strNamespace, strID)
{
	m_strResultClass = strResultClass;
	m_strRole = strRole;
}

CCimHttpReferences :: ~CCimHttpReferences()
{
	SysFreeString (m_strResultClass);
	SysFreeString (m_strRole);
}


HRESULT CCimHttpReferences :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		return xmlTranslator.References(m_strNamespace, m_strClassName,
						m_strResultClass, m_strRole, m_dwPropCount, m_strPropertyList, pECB, m_pFlagsContext);
	}
	return hr;
}

// ReferenceNames

CCimHttpReferenceNames :: CCimHttpReferenceNames(
	BSTR strObjectName,
	BSTR strResultClass,
	BSTR strRole,
	BSTR strNamespace,
	BSTR strID)
: CCimHttpIMethod(strNamespace, strID)
{
	m_strObjectName = strObjectName;
	m_strResultClass = strResultClass;
	m_strRole = strRole;
}

CCimHttpReferenceNames :: ~CCimHttpReferenceNames()
{
	SysFreeString (m_strObjectName);
	SysFreeString (m_strResultClass);
	SysFreeString (m_strRole);
}


HRESULT CCimHttpReferenceNames :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.ReferenceNames(m_strNamespace, m_strObjectName,
						m_strResultClass, m_strRole, pECB, m_pFlagsContext);
	}
	return hr;
}

CCimHttpMethod :: CCimHttpMethod(BSTR strMethodName, BOOLEAN isStatic, BSTR strNamespace, BSTR strObjectPath, BSTR strID)
	: CCimHttpIMethod(strNamespace, strID)
{
	m_strMethodName = strMethodName;
	m_strObjectPath = strObjectPath;
	m_pInputParameters = NULL;
	m_isStatic = isStatic;
}

CCimHttpMethod :: ~CCimHttpMethod()
{
	SysFreeString(m_strMethodName);
	SysFreeString(m_strObjectPath);
	if(m_pInputParameters)
		DestroyParameterMap(m_pInputParameters);
	delete m_pInputParameters;
}

void CCimHttpMethod :: DestroyParameterMap(CParameterMap *pParameters)
{
	if(pParameters)
	{
		// iterating all (key, value) pairs
		POSITION oStartPosition = pParameters->GetStartPosition();
		while(oStartPosition)
		{
			BSTR strKey = NULL;
			IXMLDOMNode *pValue=NULL;
			pParameters->GetNextAssoc(oStartPosition, strKey, pValue);
			SysFreeString(strKey);
			if(pValue)
				pValue->Release();
		}
	}
}

void CCimHttpMethod :: WriteMethodHeader ()
{
	WRITEWSTR(m_pHeaderStream, L"<METHODRESPONSE NAME=\"");
	WRITEWSTR(m_pHeaderStream, m_strMethodName);
	WRITEWSTR(m_pHeaderStream, L"\">");
}

void CCimHttpMethod :: WriteMethodTrailer ()
{
	WRITEWSTR(m_pTrailerStream, L"</METHODRESPONSE>");
}


HRESULT CCimHttpMethod :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED (hr = CreateFlagsContext()))
	{
		// Interact with the translator to get the result XML
		//===================================================
		CXMLTranslator xmlTranslator((m_bIsMicrosoftWMIClient)?  m_pContextNode : NULL, m_iHttpVersion, pPrefixStream, pSuffixStream);
		hr = xmlTranslator.ExecuteMethod(m_strNamespace,
			m_strObjectPath, m_strMethodName, m_isStatic,
			m_pInputParameters, pECB, m_pFlagsContext);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\wmixmlt.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  WMIXMLT.H
//
//  rajeshr  3/25/2000   Created.
//
// Contains the class that interacts with WMI to satisfy XML/HTTP requests
//
//***************************************************************************
#ifndef _CWMI_XMLT_H_
#define _CWMI_XMLT_H_


//***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTranslator
//
//  DESCRIPTION:
//  This is a class that interacts with WMI to satisy XML/HTTP requests
//
//***************************************************************************

class CXMLTranslator 
{
private:
	// The version of the HTTP Request - This is used in deciding wheter
	// to write responses as chunks or to write them as one single packet
	WMI_XML_HTTP_VERSION		m_iHttpVersion; 

	// This is a cache of IWbemServices pointers
	CXMLConnectionCache			m_connectionCache;

	// Prefix and Suffix streams
	IStream *					m_pPrefixStream;
	IStream *					m_pSuffixStream;

	// An IWbemCOntext object comes encoded in this way
	IXMLDOMNode *				m_pContext;

	static BOOL		TransformQuery (BSTR *bsQueryString);
public:
    
    CXMLTranslator(IXMLDOMNode *pContext, WMI_XML_HTTP_VERSION iHttpVersion, IStream *pPrefixStream, IStream *pSuffixStream);
    virtual ~CXMLTranslator(void);

	HRESULT STDMETHODCALLTYPE  ExecuteQuery
		(
			BSTR pszNamespacePath,
			BSTR pszQueryLanguage,
			BSTR pszQueryString,
			LPEXTENSION_CONTROL_BLOCK pECB,
			IWbemContext *pFlagsContext
        );

	HRESULT STDMETHODCALLTYPE  DeleteObject
		(
		/*[in]*/	BSTR pszNamespacePath,
		/*[in]*/	BSTR pszObjectPath,
		/*[in]*/	BOOL bIsClass,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext

        );

	HRESULT STDMETHODCALLTYPE  EnumerateInstances
		(
		/*[in]*/	BSTR pszNamespacePath,
		/*[in]*/	BSTR pszClassName,
		/*[in]*/	VARIANT_BOOL bDeep,
					BOOL bIsMicrosoftWMIClient,
					DWORD dwNumProperties, // Size of following array
					BSTR *pPropertyList,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext
        );

	HRESULT STDMETHODCALLTYPE  EnumerateInstanceNames
		(
			/* [in]  */ BSTR pszNamespacePath,
			/* [in]  */	BSTR pszClassName,
						LPEXTENSION_CONTROL_BLOCK pECB,
						IWbemContext *pFlagsContext
		);

	HRESULT STDMETHODCALLTYPE  EnumerateClasses
		(
		/*[in]*/	BSTR pszNamespacePath,
		/*[in]*/	BSTR pszClassName,
		/*[in]*/	VARIANT_BOOL bDeep,
					DWORD dwNumProperties, // Size of following array
					BSTR *pPropertyList,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext
        );

	HRESULT STDMETHODCALLTYPE  EnumerateClassNames
		(
			/* [in]  */ BSTR pszNamespacePath,
			/* [in]  */	BSTR pszClassName,
			/* [in]  */ BOOL bDeepInheritance,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext
		);

	HRESULT STDMETHODCALLTYPE ExecuteMethod (
		BSTR pszNamespacePath,
		BSTR pszObjPath,
		BSTR pszMethodName,
		BOOLEAN isStaticMethod,
		CParameterMap *pParameterMap,
		LPEXTENSION_CONTROL_BLOCK pECB,
		IWbemContext *pFlagsContext
	);

	// Take the paramters from the input map and fill them into the IWbemClassObject
	HRESULT FormMethodParameters(BSTR pszNamespacePath, IWbemClassObject *pInSignature, CParameterMap *pParameterMap, IWbemClassObject **ppMethodParameters);

	HRESULT STDMETHODCALLTYPE  GetObject
		(
		/*[in]*/	BSTR pszNamespacePath,
		/*[in]*/	BSTR pszObjectPath,
					DWORD dwNumProperties, // Size of following array
					BSTR *pPropertyList,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext
        );

	HRESULT STDMETHODCALLTYPE  GetProperty
		(
		/*[in]*/	BSTR pszNamespacePath,
		/*[in]*/	BSTR pszObjectPath,
		/*[in]*/	BSTR pszPropertyName,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext
        );

	HRESULT STDMETHODCALLTYPE  SetProperty
		(
		/*[in]*/	BSTR pszNamespacePath,
		/*[in]*/	BSTR pszObjectPath,
		/*[in]*/	BSTR pszPropertyName,
		/*[in]*/	IXMLDOMNode *pPropertyValue,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext
        );

	HRESULT STDMETHODCALLTYPE Associators
		(
		/*[in]*/	BSTR strNamespace, 
		/*[in]*/	BSTR strObjectName, 
		/*[in]*/	BSTR strAssocClass, 
		/*[in]*/	BSTR strResultClass, 
		/*[in]*/	BSTR strRole, 
		/*[in]*/	BSTR strResultRole,
					DWORD dwPropCount, 
					BSTR *pPropertyList,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext);

	HRESULT STDMETHODCALLTYPE  AssociatorNames
		(
			/*[in]*/    BSTR pszNamespacePath,
			/*[in]*/	BSTR pszObjectName,
			/*[in]*/	BSTR strAssocClass, 
			/*[in]*/	BSTR strResultClass, 
			/*[in]*/	BSTR strRole, 
			/*[in]*/	BSTR strResultRole,
						LPEXTENSION_CONTROL_BLOCK pECB,
						IWbemContext *pFlagsContext
		);

	HRESULT STDMETHODCALLTYPE References
		(
		/*[in]*/	BSTR strNamespace, 
		/*[in]*/	BSTR strObjectName, 
		/*[in]*/	BSTR strResultClass, 
		/*[in]*/	BSTR strRole, 
					DWORD dwPropCount, 
					BSTR *pPropertyList,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext);

	HRESULT STDMETHODCALLTYPE  ReferenceNames
		(
			/*[in]*/    BSTR pszNamespacePath,
			/*[in]*/	BSTR pszObjectName,
			/*[in]*/	BSTR strResultClass, 
			/*[in]*/	BSTR strRole,
						LPEXTENSION_CONTROL_BLOCK pECB,
						IWbemContext *pFlagsContext
		);

	HRESULT STDMETHODCALLTYPE CreateClass
		(
			/*[in]*/	BSTR pszNamespacePath,
			/*[in]*/	IXMLDOMNode *pClass,
			/*[in]*/	BOOL bIsModify,
						LPEXTENSION_CONTROL_BLOCK pECB,
						IWbemContext *pFlagsContext,
						LONG lFlags
		);

	HRESULT STDMETHODCALLTYPE CreateInstance
		(
			/*[in]*/	BSTR pszNamespacePath,
			/*[in]*/	IXMLDOMNode *pInstance,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext,
					LONG lFlags);
	
	HRESULT STDMETHODCALLTYPE ModifyInstance
		(
			/*[in]*/	BSTR pszNamespacePath,
			/*[in]*/	IXMLDOMNode *pInstance,
			/*[in]*/	BSTR pszInstancePath,
						LPEXTENSION_CONTROL_BLOCK pECB,
						IWbemContext *pFlagsContext,
						LONG lFlags
		);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\xml2wmi.cpp ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  XML2WMI.CPP
//
//  alanbos  09-Jul-99   Created.
//
//  The XML -> WMI translator
//
//***************************************************************************
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <wbemidl.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <cominit.h>

#include <httpext.h>
#include <msxml.h>

#include "provtempl.h"
#include "common.h"
#include "wmixmlop.h"
#include "concache.h"
#include "wmiconv.h"
#include "xml2wmi.h"
#include "wmixmlt.h"
#include "request.h"
#include "strings.h"
#include "xmlhelp.h"
#include "parse.h"
//***************************************************************************
//
//  CXmlToWmi::CXmlToWmi
//
//  DESCRIPTION:
//
//  Constructor
//
//***************************************************************************

CXmlToWmi::CXmlToWmi ()
{
	m_pXml = NULL;
	m_pWmiObject = NULL;
	m_pServices = NULL;
}

HRESULT CXmlToWmi::Initialize (IXMLDOMNode *pXml, IWbemServices *pServices, IWbemClassObject *pWmiObject)
{
	if (m_pXml = pXml)
		m_pXml->AddRef ();
	if (m_pWmiObject = pWmiObject)
		m_pWmiObject->AddRef ();
	if (m_pServices = pServices)
		m_pServices->AddRef ();
	return S_OK;
}

//***************************************************************************
//
//  CXmlToWmi::~CXmlToWmi
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CXmlToWmi::~CXmlToWmi(void)
{
    if (m_pXml)
		m_pXml->Release ();
	if (m_pWmiObject)
		m_pWmiObject->Release ();
	if(m_pServices)
		m_pServices->Release();
}

HRESULT CXmlToWmi::MapClassName (BSTR *pstrClassName)
{
	HRESULT hr = WBEM_E_FAILED;
	*pstrClassName = NULL;

	if(SUCCEEDED(hr = GetBstrAttribute(m_pXml, NAME_ATTRIBUTE, pstrClassName)))
	{
		VARIANT value;
		VariantInit (&value);
		value.vt = VT_BSTR;
		value.bstrVal = *pstrClassName;
		hr = m_pWmiObject->Put (L"__CLASS", 0, &value, VT_BSTR);
		value.bstrVal = NULL;
		VariantClear (&value);
	}

	return hr;
}


//***************************************************************************
//
//  HRESULT CXmlToWmi::MapClass
//
//  DESCRIPTION:
//
//  Maps an XML <CLASS> into its WMI IWbemClassObject equivalent form
//
//  PARAMETERS:
//
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapClass (
	bool bIsModify
)
{
	HRESULT hr = S_OK;

	if(m_pXml && m_pWmiObject)
	{
		IWbemQualifierSet *pQualSet = NULL;

		if (SUCCEEDED(m_pWmiObject->GetQualifierSet (&pQualSet)))
		{
			BSTR strClassName = NULL;
			if (SUCCEEDED(hr = MapClassName (&strClassName)))
			{
				VARIANT_BOOL bHasChildNodes;

				if (SUCCEEDED(m_pXml->hasChildNodes (&bHasChildNodes)) &&
					(VARIANT_TRUE == bHasChildNodes))
				{
					IXMLDOMNodeList *pNodeList = NULL;
					if (SUCCEEDED(m_pXml->get_childNodes (&pNodeList)))
					{
						IXMLDOMNode *pNode = NULL;
						while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
						{
							// Get the Name of the property/method/qualifier
							// We dont need to map system properties that begin with "__"
							bool bMapElement = false;
							BSTR strName = NULL;
							if(SUCCEEDED(hr = GetBstrAttribute(pNode, NAME_ATTRIBUTE, &strName)))
							{
								// See if it is one of the System Properties
								if(_wcsnicmp(strName, L"__", 2) != 0)
									bMapElement = true;
								SysFreeString(strName);
							}

							// This element should be mapped only if it was defined/modified
							// in the current class. Hence get its class origin information
							// If there's no class origin information, assume that it is defined in
							// the current class
							BSTR strClassOrigin = NULL;
							if(bMapElement && SUCCEEDED(hr = GetBstrAttribute(pNode, CLASS_ORIGIN_ATTRIBUTE, &strClassOrigin)) && strClassOrigin)
							{
								if(_wcsicmp(strClassOrigin, strClassName) != 0)
									bMapElement = false;
								SysFreeString(strClassOrigin);
							}

							if(bMapElement)
							{
								BSTR strNodeName = NULL;
								if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
								{
									if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
										hr = MapQualifier (pNode, pQualSet);
									else if (0 == _wcsicmp(strNodeName, PROPERTY_TAG))
										hr = MapProperty (pNode, false, bIsModify);
									else if (0 == _wcsicmp(strNodeName, PROPERTYARRAY_TAG))
										hr = MapProperty (pNode, true, bIsModify);
									else if (0 == _wcsicmp(strNodeName, PROPERTYREFERENCE_TAG))
										hr = MapPropertyReference (pNode, false, bIsModify);
									else if (0 == _wcsicmp(strNodeName, PROPERTYREFARRAY_TAG))
										hr = MapPropertyReference (pNode, true, bIsModify);
									else if (0 == _wcsicmp(strNodeName, PROPERTYOBJECT_TAG))
										hr = MapPropertyObject (pNode, false, bIsModify);
									else if (0 == _wcsicmp(strNodeName, PROPERTYOBJECTARRAY_TAG))
										hr = MapPropertyObject (pNode, true, bIsModify);
									else if (0 == _wcsicmp(strNodeName, METHOD_TAG))
										hr = MapMethod (pNode, bIsModify);
									else
										hr = WBEM_E_FAILED;	// Parse error
									SysFreeString (strNodeName);
								}
							}

							pNode->Release ();
						}

						pNodeList->Release ();
					}
				}
			}
			SysFreeString(strClassName);

			pQualSet->Release ();
		}
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapInstance
//
//  DESCRIPTION:
//
//  Maps an XML <CLASS> into its WMI IWbemClassObject equivalent form
//
//  PARAMETERS:
//
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapInstance (
	bool bIsModify
)
{
	HRESULT hr = WBEM_E_FAILED;

	if(m_pXml && m_pWmiObject)
	{
		IWbemQualifierSet *pQualSet = NULL;

		if (SUCCEEDED(m_pWmiObject->GetQualifierSet (&pQualSet)))
		{
			VARIANT_BOOL bHasChildNodes;

			if (SUCCEEDED(m_pXml->hasChildNodes (&bHasChildNodes)) &&
				(VARIANT_TRUE == bHasChildNodes))
			{
				IXMLDOMNodeList *pNodeList = NULL;

				if (SUCCEEDED(m_pXml->get_childNodes (&pNodeList)))
				{
					IXMLDOMNode *pNode = NULL;
					hr = WBEM_S_NO_ERROR;

					while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
					{
						// Get the name of the element (QUALIFIER, PROPERTY, METHOD)
						BSTR strNodeName = NULL;
						if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
						{
							// Get the Name of the property/method/qualifier
							// We dont need to map system properties that begin with "__"
							bool bMap = false;
							BSTR strName = NULL;
							if(SUCCEEDED(hr = GetBstrAttribute(pNode, NAME_ATTRIBUTE, &strName)))
							{
								// See if it is one of the System Properties
								if(_wcsnicmp(strName, L"__", 2) != 0)
									bMap = true;
								SysFreeString(strName);
							}

							if(bMap)
							{
								if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
									hr = MapQualifier (pNode, pQualSet, true);
								if (0 == _wcsicmp(strNodeName, PROPERTY_TAG))
									hr = MapProperty (pNode, false, bIsModify, true);
								else if (0 == _wcsicmp(strNodeName, PROPERTYARRAY_TAG))
									hr = MapProperty (pNode, true, bIsModify, true);
								else if (0 == _wcsicmp(strNodeName, PROPERTYREFERENCE_TAG))
									hr = MapPropertyReference (pNode, false, bIsModify, true);
								else if (0 == _wcsicmp(strNodeName, PROPERTYREFARRAY_TAG))
									hr = MapPropertyReference (pNode, true, bIsModify, true);
								else if (0 == _wcsicmp(strNodeName, PROPERTYOBJECT_TAG))
									hr = MapPropertyObject (pNode, false, bIsModify, true);
								else if (0 == _wcsicmp(strNodeName, PROPERTYOBJECTARRAY_TAG))
									hr = MapPropertyObject (pNode, true, bIsModify, true);
								else
									hr = WBEM_E_FAILED;	// Parse error
							}

							SysFreeString (strNodeName);
						}

						pNode->Release ();
					}

					pNodeList->Release ();
				}
			}

			pQualSet->Release ();
		}
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapContextObject
//
//  DESCRIPTION:
//
//  Maps an XML <INSTANCE> into a IWbemContext object
//
//  PARAMETERS:
//
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapContextObject (IXMLDOMNode *pContextNode, IWbemContext **ppContext)
{
	HRESULT hr = WBEM_E_FAILED;
	*ppContext = NULL;

	// Create an IWbemContext object using the information in the INSTANCE element
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemContext,
		0,
		CLSCTX_INPROC_SERVER,
		IID_IWbemContext, (LPVOID *) ppContext)))
	{
		if(pContextNode)
		{
			// Go through the children of the INSTANCE node
			//**************************************************
			VARIANT_BOOL bHasChildNodes;
			if (SUCCEEDED(pContextNode->hasChildNodes (&bHasChildNodes)) &&
				(VARIANT_TRUE == bHasChildNodes))
			{
				IXMLDOMNodeList *pNodeList = NULL;
				if (SUCCEEDED(pContextNode->get_childNodes (&pNodeList)))
				{
					IXMLDOMNode *pNode = NULL;
					hr = WBEM_S_NO_ERROR;

					while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
					{
						BSTR strNodeName = NULL;

						if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
						{

							if (0 == _wcsicmp(strNodeName, CONTEXTPROPERTY_TAG))
								hr = MapContextProperty (pNode, *ppContext);
							else if (0 == _wcsicmp(strNodeName, CONTEXTPROPERTYARRAY_TAG))
								hr = MapContextPropertyArray (pNode, *ppContext);
							/* RAJESHR These need to be mapped too !!
							else if (0 == _wcsicmp(strNodeName, CONTEXTPROPERTYOBJECT_TAG))
								hr = MapContextPropertyObject (pNode, *ppContext);
							else if (0 == _wcsicmp(strNodeName, CONTEXTPROPERTYOBJECTARRAY_TAG))
								hr = MapContextPropertyObjectArray (pNode, *ppContext);
							*/
							else
								hr = WBEM_E_FAILED;	// Parse error

							SysFreeString (strNodeName);
						}

						pNode->Release ();
					}
					pNodeList->Release ();
				}
			}
		}
	}

	// Release the context object if the whole function call wasnt successful
	if(!SUCCEEDED(hr) && *ppContext)
	{
		(*ppContext)->Release();
		*ppContext = NULL;
	}

	return hr;
}


HRESULT CXmlToWmi::MapQualifier (
	IXMLDOMNode *pNode,
	IWbemQualifierSet *pQualSet,
	bool bInstance
)
{
	HRESULT hr = S_OK;

	BSTR strName = NULL;
	BSTR strType = NULL;
	BSTR strOverridable = NULL;
	BSTR strToSubclass = NULL;
	BSTR strToInstance = NULL;
	BSTR strAmended = NULL;

	// Get the attributes we need for the mapping
	if(SUCCEEDED(hr))
	{
		if(SUCCEEDED(hr = GetBstrAttribute (pNode, NAME_ATTRIBUTE, &strName)))
		{
			if(strName && bInstance)
			{
				// Dont map certain qualifiers for instances
				if(_wcsicmp(strName, L"CIMTYPE") == 0 ||
					_wcsicmp(strName, L"KEY") == 0 )
				{
					SysFreeString(strName);
					return S_OK;
				}
			}
		}
	}
	if(SUCCEEDED(hr))
		hr = GetBstrAttribute (pNode, TYPE_ATTRIBUTE, &strType);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, OVERRIDABLE_ATTRIBUTE, &strOverridable);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, TOSUBCLASS_ATTRIBUTE, &strToSubclass);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, TOINSTANCE_ATTRIBUTE, &strToInstance);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, AMENDED_ATTRIBUTE, &strAmended);

	// Build up the flavor
	long flavor = 0;

	if(SUCCEEDED(hr))
	{
		if (!strOverridable || (0 == _wcsicmp (strOverridable, L"true")))
			flavor |= WBEM_FLAVOR_OVERRIDABLE;
		else if (0 == _wcsicmp (strOverridable, L"false"))
			flavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;
		else
			hr = WBEM_E_FAILED;
	}

	if (SUCCEEDED(hr))
	{
		if (!strToSubclass || (0 == _wcsicmp (strToSubclass, L"true")))
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
		else if (0 != _wcsicmp (strToSubclass, L"false"))
			hr = WBEM_E_FAILED;
	}

	if (SUCCEEDED(hr))
	{
		if (strToInstance && (0 == _wcsicmp (strToInstance, L"true")))
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
		else if (strToInstance && (0 != _wcsicmp (strToInstance, L"false")))
			hr = WBEM_E_FAILED;
	}

	if (SUCCEEDED(hr))
	{
		if (strAmended && (0 == _wcsicmp (strAmended, L"true")))
			flavor |= WBEM_FLAVOR_AMENDED;
		else if (strAmended && (0 != _wcsicmp (strAmended, L"false")))
			hr = WBEM_E_FAILED;
	}

	// Map the Qualifier type
	CIMTYPE cimtype = CIM_ILLEGAL;

	if (CIM_ILLEGAL == (cimtype = CimtypeFromString (strType)))
		hr = WBEM_E_FAILED;

	// Map the Qualifier value
	VARIANT value;
	VariantInit (&value);

	if (SUCCEEDED (hr))
	{
		IXMLDOMNodeList *pNodeList = NULL;
		long length = 0;
		if (SUCCEEDED(hr = pNode->get_childNodes (&pNodeList)))
		{
			if (SUCCEEDED(hr = pNodeList->get_length (&length)) && (1 == length))
			{
				// Get the first node
				IXMLDOMNode *pValueNode = NULL;
				if (SUCCEEDED(hr = pNodeList->nextNode (&pValueNode)) && pValueNode)
				{
					// Get its name
					BSTR strNodeName = NULL;
					if(SUCCEEDED(hr = pValueNode->get_nodeName(&strNodeName)))
					{
						if (0 == _wcsicmp(strNodeName, VALUE_TAG))
						{
							BSTR bsValue = NULL;
							if(SUCCEEDED(hr = pValueNode->get_text(&bsValue)))
							{
								hr = MapStringValue (bsValue, value, cimtype);
								SysFreeString (bsValue);
							}
						}
						else if (0 == _wcsicmp(strNodeName, VALUEARRAY_TAG))
						{
							hr = MapStringArrayValue (pValueNode, value, cimtype);
						}

						SysFreeString (strNodeName);
					}
					pValueNode->Release ();
				}
			}

			pNodeList->Release ();
		}
	}

	// Put it all together
	if (SUCCEEDED (hr))
		hr = pQualSet->Put (strName, &value, flavor);

	if (strName)
		SysFreeString (strName);

	if (strType)
		SysFreeString (strType);

	if (strOverridable)
		SysFreeString (strOverridable);

	if (strToSubclass)
		SysFreeString (strToSubclass);

	if (strToInstance)
		SysFreeString (strToInstance);

	if (strAmended)
		SysFreeString (strAmended);

	VariantClear (&value);

	return hr;
}

HRESULT CXmlToWmi::MapProperty (
	IXMLDOMNode *pProperty,
	bool bIsArray,
	bool bIsModify, 
	bool bIsInstance
)
{
	HRESULT hr = S_OK;

	BSTR strName = NULL;
	BSTR strType = NULL;
	BSTR strArraySize = NULL;

	// Get the attributes we need for the mapping
	if(SUCCEEDED(hr))
		hr = GetBstrAttribute (pProperty, NAME_ATTRIBUTE, &strName);
	if(SUCCEEDED(hr))
		hr = GetBstrAttribute (pProperty, TYPE_ATTRIBUTE, &strType);

	// This is an optional attribute - hence we dont need to check for success
	if (SUCCEEDED(hr) && (bIsArray))
		GetBstrAttribute (pProperty, ARRAYSIZE_ATTRIBUTE, &strArraySize);

	if (SUCCEEDED(hr) && pProperty && strName && strType)
	{
		// Map the Property type
		CIMTYPE cimtype = CIM_ILLEGAL;

		if (CIM_ILLEGAL == (cimtype = CimtypeFromString (strType)))
			hr = WBEM_E_FAILED;
		else if (bIsArray)
			cimtype |= CIM_FLAG_ARRAY;

		// Does this property exist already? If we're doing a modify it had better!
		hr = m_pWmiObject->Get(strName, 0, NULL, NULL, NULL);

		if (!bIsModify || SUCCEEDED(hr))
		{
			// If we didn't find the property, put a provisional version
			// in so we can get the qualifier set
			if (SUCCEEDED(hr) || SUCCEEDED(hr = m_pWmiObject->Put(strName, 0, NULL, cimtype)))
			{
				IWbemQualifierSet *pQualSet = NULL;
				VARIANT value;
				VariantInit (&value);

				if (SUCCEEDED(hr = m_pWmiObject->GetPropertyQualifierSet (strName, &pQualSet)))
				{
					// If we have been given an ARRAYSIZE value then set this
					// as qualifiers of the property
					if (strArraySize)
						hr = SetArraySize (pQualSet, strArraySize);

					if (SUCCEEDED(hr))
					{
						// The content of this element should be 0 or
						// more QUALIFIER elements followed by an optional VALUE
						// element.
						VARIANT_BOOL bHasChildNodes;

						if (SUCCEEDED(pProperty->hasChildNodes (&bHasChildNodes)) &&
							(VARIANT_TRUE == bHasChildNodes))
						{
							IXMLDOMNodeList *pNodeList = NULL;
							// We can be in one of 3 states whilst iterating
							// this list - parsing qualifiers or parsing the value
							// or value array
							enum {
								parsingQualifiers,
								parsingValue,
								parsingValueArray,
							} parseState = parsingQualifiers;

							if (SUCCEEDED(pProperty->get_childNodes (&pNodeList)))
							{
								IXMLDOMNode *pNode = NULL;
								while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
								{
									BSTR strNodeName = NULL;
									if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
									{
										if (parsingQualifiers == parseState)
										{
											if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
												hr = MapQualifier (pNode, pQualSet, bIsInstance);
											else
												parseState = (bIsArray) ?
													parsingValueArray : parsingValue;
										}

										if (parsingValue == parseState)
										{
											if (0 == _wcsicmp(strNodeName, VALUE_TAG))
											{
												BSTR bsValue = NULL;
												if(SUCCEEDED(hr = pNode->get_text(&bsValue)))
												{
													hr = MapStringValue (bsValue, value, cimtype);
													SysFreeString (bsValue);
												}
											}
											else
												hr = WBEM_E_FAILED;	// Parse error
										}

										if (parsingValueArray == parseState)
										{
											if (0 == _wcsicmp(strNodeName, VALUEARRAY_TAG))
											{
												hr = MapStringArrayValue
														(pNode, value, cimtype);
											}
											else
												hr = WBEM_E_FAILED;
										}

										SysFreeString (strNodeName);
									}

									pNode->Release ();
								}

								pNodeList->Release ();
							}
						}
					}

					pQualSet->Release ();
				}

				// Put it all together - only do this if we have a real value
				if (SUCCEEDED (hr) && (VT_EMPTY != value.vt))
					hr = m_pWmiObject->Put (strName, 0, &value, cimtype);

				VariantClear (&value);
			}
		}
	}

	if (strName)
		SysFreeString (strName);

	if (strType)
		SysFreeString (strType);

	if (strArraySize)
		SysFreeString (strArraySize);

	return hr;
}

HRESULT CXmlToWmi::MapPropertyReference (
	IXMLDOMNode *pProperty,
	bool bIsArray,
	bool bIsModify,
	bool bIsInstance
)
{
	HRESULT hr = S_OK;

	if (pProperty)
	{
		BSTR strName = NULL;
		BSTR strReferenceClass = NULL;
		BSTR strArraySize = NULL;
		CIMTYPE cimtype = CIM_REFERENCE;
		if(bIsArray)
			cimtype |= CIM_FLAG_ARRAY;

		// Get the attributes we need for the mapping
		if(SUCCEEDED(hr))
			hr = GetBstrAttribute (pProperty, NAME_ATTRIBUTE, &strName);
		if(SUCCEEDED(hr))
			hr = GetBstrAttribute (pProperty, REFERENCECLASS_ATTRIBUTE, &strReferenceClass);

		// This is an optional attribute - hence we dont need to check for success
		if (SUCCEEDED(hr) && (bIsArray))
			GetBstrAttribute (pProperty, ARRAYSIZE_ATTRIBUTE, &strArraySize);

		if (pProperty && strName)
		{
			// Does this property exist already? If we're doing a modify it had better!
			hr = m_pWmiObject->Get(strName, 0, NULL, NULL, NULL);

			if (!bIsModify || SUCCEEDED(hr))
			{
				// If we didn't find the property, put a provisional version
				// in so we can get the qualifier set
				if (SUCCEEDED(hr) || SUCCEEDED(hr = m_pWmiObject->Put(strName, 0, NULL, cimtype)))
				{
					IWbemQualifierSet *pQualSet = NULL;
					VARIANT value;
					VariantInit (&value);

					if (SUCCEEDED(hr = m_pWmiObject->GetPropertyQualifierSet (strName, &pQualSet)))
					{
						// If we have been given an ARRAYSIZE value then set this
						// as qualifiers of the property
						if (strArraySize)
							hr = SetArraySize (pQualSet, strArraySize);

						// If we have been given a REFERENCECLASS value then set this
						// as qualifiers of the property
						if (strReferenceClass)
							hr = SetReferenceClass (pQualSet, strReferenceClass);

						if (SUCCEEDED(hr))
						{
							// The content of this element should be 0 or
							// more QUALIFIER elements followed by an optional
							// VALUE.REFERENCE element.
							VARIANT_BOOL bHasChildNodes;

							if (SUCCEEDED(pProperty->hasChildNodes (&bHasChildNodes)) &&
								(VARIANT_TRUE == bHasChildNodes))
							{
								IXMLDOMNodeList *pNodeList = NULL;
								// We can be in one of 3 states whilst iterating
								// this list - parsing qualifiers or parsing the value
								enum {
									parsingQualifiers,
									parsingValue,
									parsingValueArray,

								} parseState = parsingQualifiers;

								if (SUCCEEDED(pProperty->get_childNodes (&pNodeList)))
								{
									IXMLDOMNode *pNode = NULL;

									while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
									{
										BSTR strNodeName = NULL;

										if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
										{
											if (parsingQualifiers == parseState)
											{
												if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
													hr = MapQualifier (pNode, pQualSet, bIsInstance);
												else
													parseState = (bIsArray)? parsingValueArray : parsingValue;
											}

											if (parsingValue == parseState)
											{
												if (0 == _wcsicmp(strNodeName, VALUEREFERENCE_TAG))
												{
													hr = MapReferenceValue (pNode, value);
												}
												else
													hr = WBEM_E_FAILED;	// Parse error
											}

											if (parsingValueArray == parseState)
											{
												if (0 == _wcsicmp(strNodeName, VALUEREFARRAY_TAG))
												{
													hr = MapReferenceArrayValue (pNode, value);
												}
												else
													hr = WBEM_E_FAILED;	// Parse error
											}

											SysFreeString (strNodeName);
										}

										pNode->Release ();
									}

									pNodeList->Release ();
								}
							}
						}

						pQualSet->Release ();
					}

					// Put it all together - only do this if we have a real value
					if (SUCCEEDED (hr) && (VT_EMPTY != value.vt))
						hr = m_pWmiObject->Put (strName, 0, &value, cimtype);

					VariantClear (&value);
				}
			}
		}

		SysFreeString (strName);
		SysFreeString (strReferenceClass);
		SysFreeString (strArraySize);
	}

	return hr;
}

HRESULT CXmlToWmi::MapPropertyObject (
	IXMLDOMNode *pProperty,
	bool bIsArray,
	bool bIsModify,
	bool bIsInstance
)
{
	HRESULT hr = S_OK;

	if (pProperty)
	{
		BSTR strName = NULL;
		BSTR strReferenceClass = NULL;
		BSTR strArraySize = NULL;
		CIMTYPE cimtype = CIM_REFERENCE;
		if(bIsArray)
			cimtype |= CIM_FLAG_ARRAY;

		// Get the attributes we need for the mapping
		if(SUCCEEDED(hr))
			hr = GetBstrAttribute (pProperty, NAME_ATTRIBUTE, &strName);
		if(SUCCEEDED(hr))
			hr = GetBstrAttribute (pProperty, REFERENCECLASS_ATTRIBUTE, &strReferenceClass);

		// This is an optional attribute - hence we dont need to check for success
		if (SUCCEEDED(hr) && (bIsArray))
			GetBstrAttribute (pProperty, ARRAYSIZE_ATTRIBUTE, &strArraySize);

		if (pProperty && strName)
		{
			// Does this property exist already? If we're doing a modify it had better!
			hr = m_pWmiObject->Get(strName, 0, NULL, NULL, NULL);

			if (!bIsModify || SUCCEEDED(hr))
			{
				// If we didn't find the property, put a provisional version
				// in so we can get the qualifier set
				if (SUCCEEDED(hr) || SUCCEEDED(hr = m_pWmiObject->Put(strName, 0, NULL, cimtype)))
				{
					IWbemQualifierSet *pQualSet = NULL;
					VARIANT value;
					VariantInit (&value);

					if (SUCCEEDED(hr = m_pWmiObject->GetPropertyQualifierSet (strName, &pQualSet)))
					{
						// If we have been given an ARRAYSIZE value then set this
						// as qualifiers of the property
						if (strArraySize)
							hr = SetArraySize (pQualSet, strArraySize);

						// If we have been given a REFERENCECLASS value then set this
						// as qualifiers of the property
						if (strReferenceClass)
							hr = SetObjectClass (pQualSet, strReferenceClass);

						if (SUCCEEDED(hr))
						{
							// The content of this element should be 0 or
							// more QUALIFIER elements followed by an optional
							// VALUE.OBJECT element.
							VARIANT_BOOL bHasChildNodes;

							if (SUCCEEDED(pProperty->hasChildNodes (&bHasChildNodes)) &&
								(VARIANT_TRUE == bHasChildNodes))
							{
								IXMLDOMNodeList *pNodeList = NULL;
								// We can be in one of 3 states whilst iterating
								// this list - parsing qualifiers or parsing the value
								enum {
									parsingQualifiers,
									parsingValue,
									parsingValueArray,

								} parseState = parsingQualifiers;

								if (SUCCEEDED(pProperty->get_childNodes (&pNodeList)))
								{
									IXMLDOMNode *pNode = NULL;

									while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
									{
										BSTR strNodeName = NULL;

										if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
										{
											if (parsingQualifiers == parseState)
											{
												if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
													hr = MapQualifier (pNode, pQualSet, bIsInstance);
												else
													parseState = (bIsArray)? parsingValueArray : parsingValue;
											}

											if (parsingValue == parseState)
											{
												if (0 == _wcsicmp(strNodeName, VALUEOBJECT_TAG))
												{
													hr = MapObjectValue (pNode, value);
												}
												else
													hr = WBEM_E_FAILED;	// Parse error
											}

											if (parsingValueArray == parseState)
											{
												if (0 == _wcsicmp(strNodeName, VALUEOBJECTARRAY_TAG))
												{
													hr = MapObjectArrayValue (pNode, value);
												}
												else
													hr = WBEM_E_FAILED;	// Parse error
											}

											SysFreeString (strNodeName);
										}

										pNode->Release ();
									}

									pNodeList->Release ();
								}
							}
						}

						pQualSet->Release ();
					}

					// Put it all together - only do this if we have a real value
					if (SUCCEEDED (hr) && (VT_EMPTY != value.vt))
						hr = m_pWmiObject->Put (strName, 0, &value, cimtype);

					VariantClear (&value);
				}
			}
		}

		SysFreeString (strName);
		SysFreeString (strReferenceClass);
		SysFreeString (strArraySize);
	}

	return hr;
}

HRESULT CXmlToWmi::MapMethod (
	IXMLDOMNode *pMethod,
	bool bIsModify
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (pMethod)
	{
		BSTR strName = NULL;
		BSTR strType = NULL;

		// Get the attributes we need for the mapping
		GetBstrAttribute (pMethod, NAME_ATTRIBUTE, &strName);
		GetBstrAttribute (pMethod, TYPE_ATTRIBUTE, &strType);

		if (pMethod && strName)
		{

			// Does this method exist already? If we're doing a modify it had better!
			hr = m_pWmiObject->GetMethod(strName, 0, NULL, NULL);

			if (!bIsModify || SUCCEEDED(hr))
			{
				// If we didn't find the method, put a provisional version
				// in so we can get the qualifier set
				if (SUCCEEDED(hr) ||
					SUCCEEDED(hr = m_pWmiObject->PutMethod(strName, 0, NULL, NULL)))
				{
					IWbemQualifierSet *pQualSet = NULL;
					IWbemClassObject *pInParameters = NULL;
					IWbemClassObject *pOutParameters = NULL;

					if (SUCCEEDED(hr = m_pWmiObject->GetMethodQualifierSet (strName, &pQualSet)))
					{
						// If we have a return value, set that
						if (strType && (0 < wcslen (strType)))
						{
							CIMTYPE cimtype = CIM_ILLEGAL;

							if (CIM_ILLEGAL == (cimtype = CimtypeFromString (strType)))
								hr = WBEM_E_FAILED;
							else if (SUCCEEDED(hr = m_pServices->GetObject
								(L"__PARAMETERS", 0, NULL, &pOutParameters, NULL)))
								hr = pOutParameters->Put (L"ReturnValue", 0, NULL, cimtype);
						}


						// The content of this element should be 0 or
						// more QUALIFIER elements followed by 0 or more
						// PARAMETER.* elements.
						VARIANT_BOOL bHasChildNodes;

						if (SUCCEEDED(pMethod->hasChildNodes (&bHasChildNodes)) &&
							(VARIANT_TRUE == bHasChildNodes))
						{
							IXMLDOMNodeList *pNodeList = NULL;
							// We can be in one of 3 states whilst iterating
							// this list - parsing qualifiers or parsing the value
							enum {
								parsingQualifiers,
								parsingParameters
							} parseState = parsingQualifiers;

							if (SUCCEEDED(pMethod->get_childNodes (&pNodeList)))
							{
								IXMLDOMNode *pNode = NULL;
								ULONG paramId = 0;

								while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
								{
									BSTR strNodeName = NULL;

									if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
									{
										if (parsingQualifiers == parseState)
										{
											if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
												hr = MapQualifier (pNode, pQualSet);
											else
												parseState = parsingParameters;
										}

										if (parsingParameters == parseState)
										{
											if (0 == _wcsicmp(strNodeName, PARAMETER_TAG))
											{
												hr = MapParameter (pNode, &pInParameters,
														&pOutParameters,
														m_pServices, paramId);
												paramId++;
											}
											else if (0 == _wcsicmp(strNodeName,
														PARAMETERREFERENCE_TAG))
											{
												hr = MapReferenceParameter (pNode,
														&pInParameters, &pOutParameters,
														m_pServices, paramId);
												paramId++;
											}
											else if (0 == _wcsicmp(strNodeName,
														PARAMETERARRAY_TAG))
											{
												hr = MapParameter (pNode,
														&pInParameters, &pOutParameters,
														m_pServices, paramId, true);
										 		paramId++;
											}
											else if (0 == _wcsicmp(strNodeName,
														PARAMETERREFARRAY_TAG))
											{
												hr = MapReferenceParameter (pNode,
														&pInParameters, &pOutParameters,
														m_pServices, paramId, true);
												paramId++;
											}
											else
												hr = WBEM_E_FAILED;	// Parse error
										}

										SysFreeString (strNodeName);
									}

									pNode->Release ();
								}

								pNodeList->Release ();
							}
						}

						pQualSet->Release ();
					}

					// Put it all together
					if (SUCCEEDED (hr))
						hr = m_pWmiObject->PutMethod (strName, 0, pInParameters, pOutParameters);

					if (pInParameters)
						pInParameters->Release ();

					if (pOutParameters)
						pOutParameters->Release ();
				}
			}
		}

		if (strName)
			SysFreeString (strName);

		if (strType)
			SysFreeString (strType);
	}

	return hr;
}

HRESULT CXmlToWmi::MapParameter (
	IXMLDOMNode *pParameter,
	IWbemClassObject **ppInParameters,
	IWbemClassObject **ppOutParameters,
	IWbemServices *pService,
	ULONG paramId,
	bool bIsArray
)
{
	HRESULT hr = WBEM_E_FAILED;
	bool bIsInParameter = false;
	bool bIsOutParameter = false;
	BSTR bsName = NULL;
	CIMTYPE cimtype = CIM_ILLEGAL;
	long iArraySize = 0;

	if (DetermineParameterCharacteristics (pParameter, bIsArray, bIsInParameter,
					bIsOutParameter, bsName, cimtype, iArraySize))
	{
		if (bIsInParameter)
		{
			if (!(*ppInParameters))
				pService->GetObject (L"__PARAMETERS", 0, NULL, ppInParameters, NULL);

			if (*ppInParameters)
			{
				if (SUCCEEDED(hr = (*ppInParameters)->Put (bsName, 0, NULL, cimtype)))
				{
					// Now do the qualifiers
					IWbemQualifierSet *pQualSet = NULL;

					if (SUCCEEDED(hr = (*ppInParameters)->GetPropertyQualifierSet
												(bsName, &pQualSet)))
					{
						hr = MapParameterQualifiers (pParameter, pQualSet, paramId,
														bIsArray, iArraySize, true);
						pQualSet->Release ();
					}
				}
			}
		}

		if (bIsOutParameter)
		{
			if (!(*ppOutParameters))
				pService->GetObject (L"__PARAMETERS", 0, NULL, ppOutParameters, NULL);

			if (*ppOutParameters)
			{
				if (SUCCEEDED(hr = (*ppOutParameters)->Put (bsName, 0, NULL, cimtype)))
				{
					// Now do the qualifiers
					IWbemQualifierSet *pQualSet = NULL;

					if (SUCCEEDED(hr = (*ppOutParameters)->GetPropertyQualifierSet
												(bsName, &pQualSet)))
					{
						hr = MapParameterQualifiers (pParameter, pQualSet, paramId,
														bIsArray, iArraySize);
						pQualSet->Release ();
					}
				}
			}
		}

		SysFreeString (bsName);
	}

	return hr;
}

bool CXmlToWmi::DetermineParameterCharacteristics (
	IXMLDOMNode *pParameter,
	bool bIsArray,
	bool &bIsInParameter,
	bool &bIsOutParameter,
	BSTR &bsName,
	CIMTYPE &cimtype,
	long &iArraySize,
	bool bIsReference,
	BSTR *pbsReferenceClass)
{
	bool result = false;
	bIsInParameter = false;
	bIsOutParameter = false;

	// Get name
	GetBstrAttribute (pParameter, NAME_ATTRIBUTE, &bsName);

	if (bsName)
	{
		if (bIsArray)
		{
			// Get the arraysize (if any)
			BSTR bsArraySize = NULL;
			GetBstrAttribute (pParameter, ARRAYSIZE_ATTRIBUTE, &bsArraySize);

			if (bsArraySize)
			{
				iArraySize = wcstol (bsArraySize, NULL, 0);
				SysFreeString (bsArraySize);
			}
		}

		// Now get the cimtype
		if (bIsReference)
		{
			cimtype = CIM_REFERENCE;

			if (pbsReferenceClass)
				GetBstrAttribute (pParameter, REFERENCECLASS_ATTRIBUTE, pbsReferenceClass);
		}
		else
		{
			BSTR bsCimtype = NULL;
			GetBstrAttribute (pParameter, TYPE_ATTRIBUTE, &bsCimtype);
			cimtype = CimtypeFromString (bsCimtype);

			if (bsCimtype)
				SysFreeString (bsCimtype);
		}

		if (CIM_ILLEGAL != cimtype)
		{
			if (bIsArray)
				cimtype |= CIM_FLAG_ARRAY;

			result = true;
			// Now find out if the method is an in or out
			// (or both) parameter - need to go through
			// qualifier list
			IXMLDOMNodeList *pNodeList = NULL;

			if (SUCCEEDED(pParameter->get_childNodes (&pNodeList)))
			{
				IXMLDOMNode *pNode = NULL;
				HRESULT hr = S_OK;

				while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
				{
					BSTR strNodeName = NULL;

					if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
					{
						if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
						{
							BSTR bsName = NULL;
							GetBstrAttribute (pNode, NAME_ATTRIBUTE, &bsName);

							if (bsName)
							{
								bool bCandidate = false;
								bool bsIn = true;

								if (0 == _wcsicmp (bsName, L"IN"))
									bCandidate = true;
								else if (0 == _wcsicmp (bsName, L"OUT"))
								{
									bCandidate = true;
									bsIn = false;
								}

								if (bCandidate)
								{
									BSTR bsType = NULL;
									GetBstrAttribute (pNode, TYPE_ATTRIBUTE, &bsType);

									if (bsType && (0 == _wcsicmp (bsType, L"boolean")))
									{
										BSTR bsValue = NULL;

										if (SUCCEEDED(pNode->get_text(&bsValue)) &&
											bsValue && (0 == _wcsicmp (bsValue, L"TRUE")))
										{
											if (bsIn)
												bIsInParameter = true;
											else
												bIsOutParameter = true;
										}
									}

									SysFreeString (bsType);
								}

								SysFreeString (bsName);
							}
						}

						SysFreeString (strNodeName);
					}

					pNode->Release ();
				}

				pNodeList->Release ();
			}
		}
	}

	if (!result)
	{
		if (bsName)
		{
			SysFreeString (bsName);
			bsName = NULL;
		}
	}

	return result;
}

HRESULT CXmlToWmi::MapParameterQualifiers (
	IXMLDOMNode *pParameter,
	IWbemQualifierSet *pQualSet,
	ULONG paramId,
	bool bIsArray,
	long iArraySize,
	bool bIsInParameter
)
{
	HRESULT hr = S_OK;
	IXMLDOMNodeList *pNodeList = NULL;

	if (SUCCEEDED(pParameter->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;

		while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
		{
			BSTR strNodeName = NULL;

			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				if (0 == _wcsicmp(strNodeName, QUALIFIER_TAG))
				{
					// We must only add the IN qualifier to an In parameter,
					// and the OUT parameter to an Out parameter
					BSTR bsName = NULL;
					GetBstrAttribute (pNode, NAME_ATTRIBUTE, &bsName);

					if (bsName)
					{
						if (0 == _wcsicmp (bsName, L"IN"))
						{
							if (bIsInParameter)
								hr = MapQualifier (pNode, pQualSet);
						}
						else if (0 == _wcsicmp (bsName, L"OUT"))
						{
							if (!bIsInParameter)
								hr = MapQualifier (pNode, pQualSet);
						}
						else
							hr = MapQualifier (pNode, pQualSet);

						SysFreeString (bsName);
					}
				}
				else
					hr = WBEM_E_FAILED;
				SysFreeString (strNodeName);
			}

			pNode->Release ();
		}

		if (SUCCEEDED(hr))
		{
			long flavor = WBEM_FLAVOR_NOT_OVERRIDABLE |
										WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
			// Add in the parameter id
			VARIANT var;
			VariantInit (&var);
			var.vt = VT_I4;
			var.lVal = paramId;
			hr = pQualSet->Put (L"ID", &var, flavor);
			VariantClear (&var);

			if (SUCCEEDED(hr) && bIsArray && (0 < iArraySize))
			{
				// Add in MIN and MAX qualifiers
				var.vt = VT_I4;
				var.lVal = iArraySize;

				if (SUCCEEDED(hr = pQualSet->Put (L"MAX", &var, flavor)))
					hr = pQualSet->Put (L"MIN", &var, flavor);
			}
		}

		pNodeList->Release ();
	}

	return hr;
}

HRESULT CXmlToWmi::MapReferenceParameter (
	IXMLDOMNode *pParameter,
	IWbemClassObject **ppInParameters,
	IWbemClassObject **ppOutParameters,
	IWbemServices *pService,
	ULONG paramId,
	bool bIsArray
)
{
	HRESULT hr = WBEM_E_FAILED;
	bool bIsInParameter = false;
	bool bIsOutParameter = false;
	BSTR bsName = NULL;
	BSTR bsReferenceClass = NULL;
	long iArraySize = 0;
	CIMTYPE cimtype = CIM_ILLEGAL;

	if (DetermineParameterCharacteristics (pParameter, bIsArray, bIsInParameter,
					bIsOutParameter, bsName, cimtype, iArraySize,
					true, &bsReferenceClass))
	{
		if (bIsInParameter)
		{
			if (!(*ppInParameters))
				pService->GetObject (L"__PARAMETERS", 0, NULL, ppInParameters, NULL);

			if (*ppInParameters)
			{
				if (SUCCEEDED(hr = (*ppInParameters)->Put (bsName, 0, NULL, cimtype)))
				{
					// Now do the qualifiers
					IWbemQualifierSet *pQualSet = NULL;

					if (SUCCEEDED(hr = (*ppInParameters)->GetPropertyQualifierSet
												(bsName, &pQualSet)))
					{
						hr = MapParameterQualifiers (pParameter, pQualSet, paramId,
										bIsArray, iArraySize, true);

						// If a strong reference, add it now
						if (bsReferenceClass)
							SetReferenceClass (pQualSet, bsReferenceClass);

						pQualSet->Release ();
					}
				}
			}
		}

		if (bIsOutParameter)
		{
			if (!(*ppOutParameters))
				pService->GetObject (L"__PARAMETERS", 0, NULL, ppOutParameters, NULL);

			if (*ppOutParameters)
			{
				if (SUCCEEDED(hr = (*ppOutParameters)->Put (bsName, 0, NULL, cimtype)))
				{
					// Now do the qualifiers
					IWbemQualifierSet *pQualSet = NULL;

					if (SUCCEEDED(hr = (*ppOutParameters)->GetPropertyQualifierSet
												(bsName, &pQualSet)))
					{
						hr = MapParameterQualifiers (pParameter, pQualSet, paramId,
														bIsArray, iArraySize);
						// If a strong reference, add it now
						if (bsReferenceClass)
							SetReferenceClass (pQualSet, bsReferenceClass);

						pQualSet->Release ();
					}
				}
			}
		}

		SysFreeString (bsName);
	}

	if (bsReferenceClass)
		SysFreeString (bsReferenceClass);

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapPropertyValue
//
//  DESCRIPTION:
//
//  Maps an XML property value into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		curValue		Placeholder for new value (set on return)
//		cimtype			CIMTYPE of property (needed for mapping)
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapPropertyValue (
	VARIANT &curValue,
	CIMTYPE cimtype)
{
	HRESULT hr = WBEM_E_FAILED;

	// Parse the XML body to extract the value - we
	// are expecting (VALUE|VALUE.ARRAY|VALUE.REFERENCE)?

	// Get its name
	BSTR strNodeName = NULL;
	if(m_pXml && SUCCEEDED(m_pXml->get_nodeName(&strNodeName)))
	{
		if (_wcsicmp(strNodeName, VALUE_TAG) == 0)
		{
			// RAJESHR - check only one node
			BSTR bsValue = NULL;
			m_pXml->get_text(&bsValue);
			hr = MapStringValue (bsValue, curValue, cimtype);
			SysFreeString (bsValue);
		}
		else if (_wcsicmp(strNodeName, VALUEARRAY_TAG) == 0)
		{
			hr = MapStringArrayValue (m_pXml, curValue, cimtype);
		}
		else if (_wcsicmp(strNodeName, VALUEREFERENCE_TAG) == 0)
		{
			if (CIM_REFERENCE == cimtype)
				hr = MapReferenceValue (m_pXml, curValue);
			else
				hr = WBEM_E_TYPE_MISMATCH;
		}

		SysFreeString (strNodeName);
	}
	else
	{
		// Assume value is NULL
		VariantClear (&curValue);
		curValue.vt = VT_NULL;
		hr = S_OK;
	}

	return hr;
}




//***************************************************************************
//
//  HRESULT CXmlToWmi::MapStringValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		bsValue			the VALUE element content
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapStringValue (BSTR bsValue, VARIANT &curValue, CIMTYPE cimtype)
{
	// RAJESHR First we need to remove any CDATA section from the string value
	// Even though the WMI implementation used CDATA (if necessary) only for CIM_STRING and CIM_DATETIME,
	// other implementations might use a CDATA to escape other values as well

	HRESULT hr = WBEM_E_TYPE_MISMATCH;

	// We're assuming it's not an array
	if (!(cimtype & CIM_FLAG_ARRAY))
	{
		switch (cimtype)
		{
			// RAJESHR - more rigorous syntax checking
			case CIM_UINT8:
			{
				VariantClear (&curValue);
				curValue.vt = VT_UI1;
				curValue.bVal = (BYTE) wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
				break;

			case CIM_SINT8:
			case CIM_SINT16:
			{
				VariantClear (&curValue);
				curValue.vt = VT_I2;
				curValue.iVal = (short) wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
				break;

			case CIM_UINT16:
			case CIM_UINT32:
			case CIM_SINT32:
			{
				VariantClear (&curValue);
				curValue.vt = VT_I4;
				curValue.lVal = wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
				break;

			case CIM_REAL32:
			{
				VariantClear (&curValue);
				curValue.vt = VT_R4;
				curValue.fltVal = (float) wcstod (bsValue, NULL);
				hr = S_OK;
			}
				break;

			case CIM_REAL64:
			{
				VariantClear (&curValue);
				curValue.vt = VT_R8;
				curValue.dblVal = wcstod (bsValue, NULL);
				hr = S_OK;
			}
				break;

			case CIM_BOOLEAN:
			{
				VariantClear (&curValue);
				curValue.vt = VT_BOOL;
				curValue.boolVal = (0 == _wcsicmp (bsValue, L"TRUE")) ?
							VARIANT_TRUE : VARIANT_FALSE;
				hr = S_OK;
			}
				break;

			case CIM_CHAR16:
			{
				// As per the XML Spec, the following are invalid character values in an XML Stream:
				// Char ::=  #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

				// As per the CIM Operations spec, they need to be escaped as follows:
				//	If the value is not a legal XML character
				//  (as defined in [2, section 2.2] by the Char production)
				//	then it MUST be escaped using a \x<hex> escape convention
				//	where <hex> is a hexadecimal constant consisting of
				//	between one and four digits

				VariantClear (&curValue);
				curValue.vt = VT_I2;
				if(_wcsnicmp(bsValue, L"\\x", 2) == 0)
					// It is an escaped value
					swscanf (bsValue+2, L"%x", &(curValue.iVal));
				else
					// It is a normal value
					swscanf (bsValue, L"%c", &(curValue.iVal));
				hr = S_OK;
			}
				break;

			case CIM_STRING:
			case CIM_UINT64:
			case CIM_SINT64:
			case CIM_DATETIME:
			{
				VariantClear (&curValue);
				curValue.vt = VT_BSTR;
				curValue.bstrVal = SysAllocString (bsValue);
				hr = S_OK;
			}
				break;
		}
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapStringArrayValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE.ARRAY element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		pValueNode		the VALUE.ARRAY node
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapStringArrayValue (
	IXMLDOMNode *pValueNode,
	VARIANT &curValue,
	CIMTYPE cimtype
)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;

	// Build a safearray value from the node list
	IXMLDOMNodeList *pValueList = NULL;
	if (SUCCEEDED (pValueNode->get_childNodes (&pValueList)))
	{
		long length = 0;
		pValueList->get_length (&length);
		SAFEARRAYBOUND	rgsabound [1];
		rgsabound [0].lLbound = 0;
		rgsabound [0].cElements = length;
		VARTYPE vt = VTFromCIMType (cimtype & ~CIM_FLAG_ARRAY);
		SAFEARRAY *pArray = NULL;
		
		if(pArray = SafeArrayCreate (vt, 1, rgsabound))
		{
			IXMLDOMNode *pValue = NULL;
			long ix = 0;
			bool error = false;

			while (!error &&
					SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
			{
				BSTR strValName = NULL;

				if (SUCCEEDED(pValue->get_nodeName (&strValName)))
				{
					if (0 == _wcsicmp (strValName, VALUE_TAG))
					{
						BSTR bsValue = NULL;
						pValue->get_text (&bsValue);
						if(FAILED(MapStringValueIntoArray (bsValue, pArray, &ix, vt,
							cimtype & ~CIM_FLAG_ARRAY)))
							error = true;

						SysFreeString (bsValue);
						ix++;
					}
					else
					{
						// unexpected element
						error = true;
					}

					SysFreeString (strValName);
				}

				pValue->Release ();
				pValue = NULL;
			}

			if (error)
				SafeArrayDestroy(pArray);
			else
			{
				curValue.vt = VT_ARRAY|vt;
				curValue.parray = pArray;
				hr = S_OK;
			}
		}
		else
			hr = E_OUTOFMEMORY;
		pValueList->Release();
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapStringValueIntoArray
//
//  DESCRIPTION:
//
//  Maps XML VALUE.ARRAY/VALUE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		bsValue			the VALUE element content
//		pArray			SAFEARRAY in which to map the value
//		ix				index to map the value into
//		vt				VARTYPE of the SAFEARRAY
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapStringValueIntoArray (
	BSTR bsValue,
	SAFEARRAY *pArray,
	long *ix,
	VARTYPE vt,
	CIMTYPE cimtype)
{
	HRESULT hr = E_FAIL;
	switch (vt)
	{
		case VT_UI1:
		{
			BYTE bVal = (BYTE) wcstol (bsValue, NULL, 0);
			hr = SafeArrayPutElement (pArray, ix, &bVal);
		}
			break;

		case VT_I2:
		{
			short iVal;

			if (CIM_CHAR16 == cimtype)
				swscanf (bsValue, L"%c", &(iVal));
			else
				iVal = (short) wcstol (bsValue, NULL, 0);

			hr = SafeArrayPutElement (pArray, ix, &iVal);
		}
			break;

		case VT_I4:
		{
			long lVal = wcstol (bsValue, NULL, 0);
			hr = SafeArrayPutElement (pArray, ix, &lVal);
		}
			break;

		case VT_R4:
		{
			float fltVal = (float) wcstod (bsValue, NULL);
			hr = SafeArrayPutElement (pArray, ix, &fltVal);
		}
			break;

		case VT_R8:
		{
			double dblVal = wcstod (bsValue, NULL);
			hr = SafeArrayPutElement (pArray, ix, &dblVal);
		}
			break;

		case VT_BOOL:
		{
			VARIANT_BOOL boolVal = (0 == _wcsicmp (bsValue, L"TRUE")) ?
						VARIANT_TRUE : VARIANT_FALSE;
			hr = SafeArrayPutElement (pArray, ix, &boolVal);
		}
			break;

		case VT_BSTR:
			hr = SafeArrayPutElement (pArray, ix, bsValue);
			break;
	}
	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapReferenceValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE.REFERENCE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapReferenceValue (IXMLDOMNode *pValue, VARIANT &curValue)
{
	HRESULT hr = WBEM_E_FAILED;
	curValue.vt = VT_BSTR;
	if(SUCCEEDED(hr = ParseOneReferenceValue(pValue, &curValue.bstrVal)))
	{
	}
	return hr;
}



//***************************************************************************
//
//  HRESULT CXmlToWmi::MapReferenceArrayValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE.REFARRAY element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		pValueNode		the VALUE.REFARRAY node
//		curValue		Placeholder for new value (set on return)
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapReferenceArrayValue (
	IXMLDOMNode *pValueNode,
	VARIANT &curValue
)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;

	// Build a safearray value from the node list underneath VALUE.REFARRAY
	// Each such node is a VALUE.REFERENCE
	IXMLDOMNodeList *pValueList = NULL;
	if (SUCCEEDED (pValueNode->get_childNodes (&pValueList)))
	{
		long length = 0;
		pValueList->get_length (&length);
		SAFEARRAYBOUND	rgsabound [1];
		rgsabound [0].lLbound = 0;
		rgsabound [0].cElements = length;
		VARTYPE vt = VTFromCIMType (CIM_REFERENCE & ~CIM_FLAG_ARRAY);
		SAFEARRAY *pArray = NULL;
		
		if(pArray = SafeArrayCreate (vt, 1, rgsabound))
		{
			IXMLDOMNode *pValue = NULL;
			long ix = 0;
			bool error = false;

			while (!error &&
					SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
			{
				BSTR strValName = NULL;

				if (SUCCEEDED(pValue->get_nodeName (&strValName)))
				{
					if (0 == _wcsicmp (strValName, VALUEREFERENCE_TAG))
					{
						BSTR strNextValue = NULL;
						if(SUCCEEDED(ParseOneReferenceValue(pValue, &strNextValue)))
						{
							if(FAILED(SafeArrayPutElement (pArray, &ix, strNextValue)))
								error = true;
							SysFreeString(strNextValue);
						}
						ix++;
					}
					else
					{
						// unexpected element
						error = true;
					}

					SysFreeString (strValName);
				}

				pValue->Release ();
				pValue = NULL;
			}

			if (error)
				SafeArrayDestroy(pArray);
			else
			{
				curValue.vt = VT_ARRAY|vt;
				curValue.parray = pArray;
				hr = S_OK;
			}
		}
		else
			hr = E_OUTOFMEMORY;
		pValueList->Release();
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapObjectValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE.OBJECT element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapObjectValue (IXMLDOMNode *pValue, VARIANT &curValue)
{
	HRESULT hr = WBEM_E_FAILED;
	curValue.vt = VT_UNKNOWN;
	if(SUCCEEDED(hr = MapOneObjectValue(pValue, &curValue.punkVal)))
	{
	}
	return hr;
}

HRESULT CXmlToWmi::MapOneObjectValue (IXMLDOMNode *pValueRef, IUnknown **ppunkValue)
{
	HRESULT hr = E_FAIL;
	// Let's look at the child of the VALUE.OBJECT tag
	IXMLDOMNode *pChild = NULL;
	if (SUCCEEDED(pValueRef->get_firstChild (&pChild)) && pChild)
	{
		// Next node should be a CLASS or an INSTANCE element
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pChild->get_nodeName(&strNodeName)))
		{
			// In this case, we need the superclass (if any)
			// to spawn a derived class
			if (_wcsicmp(strNodeName, CLASS_TAG) == 0)
			{
				// Should have a CLASS element - does it have a SUPERCLASS attribute?
				BSTR strSuperClass = NULL;
				GetBstrAttribute (pChild, SUPERCLASS_ATTRIBUTE, &strSuperClass);
				IWbemClassObject *pObject = NULL;
				if (WBEM_S_NO_ERROR == (hr = m_pServices->GetObject (strSuperClass, 0, NULL, &pObject, NULL)))
				{
					// Got the underlying class - now map the new value 
					if (strSuperClass && (0 < wcslen (strSuperClass)))
					{
						IWbemClassObject *pSubClass = NULL;
						if (SUCCEEDED(hr = pObject->SpawnDerivedClass (0, &pSubClass)))
						{
							CXmlToWmi xmlToWmi;
							if(SUCCEEDED(hr = xmlToWmi.Initialize(pChild, m_pServices, pSubClass)))
							{
								if(SUCCEEDED(hr = xmlToWmi.MapClass ()))
								{
									*ppunkValue = pSubClass;
									pSubClass->AddRef();
								}
							}

							pSubClass->Release ();
						}
					}
					else
					{
						CXmlToWmi xmlToWmi;
						if(SUCCEEDED(hr = xmlToWmi.Initialize(pChild, m_pServices, pObject)))
						{
							hr = xmlToWmi.MapClass ();
						}
					}

					pObject->Release ();
				}
				SysFreeString(strSuperClass);
			}
			else if (_wcsicmp(strNodeName, INSTANCE_TAG) == 0)
			{
				// In this case, we need the class object of the instance
				// to spawn an instance
				IWbemClassObject *pObject = NULL;

				// Should have a CLASSNAME attribute
				BSTR strClassName = NULL;
				GetBstrAttribute (pChild, CLASS_NAME_ATTRIBUTE, &strClassName);

				if (strClassName && (0 < wcslen (strClassName)) &&
					WBEM_S_NO_ERROR == (hr = m_pServices->GetObject (strClassName, 0, NULL, &pObject, NULL)))
				{
					// Got the underlying class - now map the new value 
					IWbemClassObject *pNewInstance = NULL;
					if (SUCCEEDED(hr = pObject->SpawnInstance (0, &pNewInstance)))
					{
						CXmlToWmi xmlToWmi;
						if(SUCCEEDED(hr = xmlToWmi.Initialize(pChild, m_pServices, pNewInstance)))
						{
							if (SUCCEEDED (hr = xmlToWmi.MapInstance ()))
							{
								*ppunkValue = pNewInstance;
								pNewInstance->AddRef();
							}
						}
						pNewInstance->Release ();
					}
					pObject->Release ();
				}
				else
					hr = WBEM_E_FAILED;
				SysFreeString (strClassName);
			}

			SysFreeString(strNodeName);
		}
		pChild->Release();
	}

	return hr;
}


//***************************************************************************
//
//  HRESULT CXmlToWmi::MapObjectArrayValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE.OBJECTARRAY element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		pValueNode		the VALUE.OBJECTARRAY node
//		curValue		Placeholder for new value (set on return)
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapObjectArrayValue (
	IXMLDOMNode *pValueNode,
	VARIANT &curValue)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;

	// Build a safearray value from the node list underneath VALUE.OBJECTARRAY
	// Each such node is a VALUE.OBJECT
	IXMLDOMNodeList *pValueList = NULL;
	if (SUCCEEDED (pValueNode->get_childNodes (&pValueList)))
	{
		long length = 0;
		pValueList->get_length (&length);
		SAFEARRAYBOUND	rgsabound [1];
		rgsabound [0].lLbound = 0;
		rgsabound [0].cElements = length;
		VARTYPE vt = VTFromCIMType (CIM_OBJECT & ~CIM_FLAG_ARRAY);
		SAFEARRAY *pArray = NULL;
		if(pArray = SafeArrayCreate (vt, 1, rgsabound))
		{
			IXMLDOMNode *pValue = NULL;
			long ix = 0;
			bool error = false;

			while (!error &&
					SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
			{
				BSTR strValName = NULL;

				if (SUCCEEDED(pValue->get_nodeName (&strValName)))
				{
					if (0 == _wcsicmp (strValName, VALUEOBJECT_TAG))
					{
						IUnknown *pNextValue = NULL;
						if(SUCCEEDED(MapOneObjectValue(pValue, &pNextValue)))
						{
							if(FAILED(SafeArrayPutElement (pArray, &ix, pNextValue)))
								error = true;
							pNextValue->Release();;
						}
						ix++;
					}
					else
					{
						// unexpected element
						error = true;
					}

					SysFreeString (strValName);
				}

				pValue->Release ();
				pValue = NULL;
			}

			if (error)
				SafeArrayDestroy(pArray);
			else
			{
				curValue.vt = VT_ARRAY|vt;
				curValue.parray = pArray;
				hr = S_OK;
			}
		}
		else
			hr = E_OUTOFMEMORY;
		pValueList->Release();
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::VTFromCIMType
//
//  DESCRIPTION:
//
//  Utility function to map CIMTYPE to its VARTYPE equivalent
//
//  PARAMETERS:
//
//		cimtype			the CIMTYPE to be mapped
//
//  RETURN VALUES:
//
//		The corresponding VARTYPE, or VT_NULL if error
//
//***************************************************************************

VARTYPE CXmlToWmi::VTFromCIMType (CIMTYPE cimtype)
{
	VARTYPE vt = VT_NULL;

	switch (cimtype & ~CIM_FLAG_ARRAY)
	{
		case CIM_UINT8:
			vt = VT_UI1;
			break;

		case CIM_SINT8:
		case CIM_SINT16:
			vt = VT_I2;
			break;

		case CIM_UINT16:
		case CIM_UINT32:
		case CIM_SINT32:
			vt = VT_I4;
			break;

		case CIM_REAL32:
			vt = VT_R4;
			break;

		case CIM_REAL64:
			vt = VT_R8;
			break;

		case CIM_BOOLEAN:
			vt = VT_BOOL;
			break;

		case CIM_CHAR16:
			vt = VT_I2;
			break;

		case CIM_STRING:
		case CIM_UINT64:
		case CIM_SINT64:
		case CIM_DATETIME:
			vt = VT_BSTR;
			break;
	}

	return vt;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::CIMTypeFromString
//
//  DESCRIPTION:
//
//  Utility function to map type attribute string to its CIMTYPE equivalent
//
//  PARAMETERS:
//
//		bsType			the type string to be mapped
//
//  RETURN VALUES:
//
//		The corresponding CIMTYPE, or CIM_ILLEGAL if error
//
//***************************************************************************
CIMTYPE CXmlToWmi::CimtypeFromString (BSTR bsType)
{
	CIMTYPE cimtype = CIM_ILLEGAL;

	if (bsType)
	{
		if (0 == _wcsicmp (bsType, L"string"))
			cimtype = CIM_STRING;
		else if (0 == _wcsicmp (bsType, L"uint32"))
			cimtype = CIM_UINT32;
		else if (0 == _wcsicmp (bsType, L"boolean"))
			cimtype = CIM_BOOLEAN;
		else if (0 == _wcsicmp (bsType, L"sint32"))
			cimtype = CIM_SINT32;
		else if (0 == _wcsicmp (bsType, L"char16"))
			cimtype = CIM_CHAR16;
		else if (0 == _wcsicmp (bsType, L"uint8"))
			cimtype = CIM_UINT8;
		else if (0 == _wcsicmp (bsType, L"uint16"))
			cimtype = CIM_UINT16;
		else if (0 == _wcsicmp (bsType, L"sint16"))
			cimtype = CIM_SINT16;
		else if (0 == _wcsicmp (bsType, L"uint64"))
			cimtype = CIM_UINT64;
		else if (0 == _wcsicmp (bsType, L"sint64"))
			cimtype = CIM_SINT64;
		else if (0 == _wcsicmp (bsType, L"datetime"))
			cimtype = CIM_DATETIME;
		else if (0 == _wcsicmp (bsType, L"real32"))
			cimtype = CIM_REAL32;
		else if (0 == _wcsicmp (bsType, L"real64"))
			cimtype = CIM_REAL64;
	}

	return cimtype;
}

HRESULT CXmlToWmi::SetArraySize (
	IWbemQualifierSet *pQualSet,
	BSTR strArraySize
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (strArraySize)
	{
		VARIANT curValue;
		VariantInit (&curValue);
		curValue.vt = VT_I4;
		curValue.lVal = wcstol (strArraySize, NULL, 0);

		if (0 < curValue.lVal)
		{
			if (SUCCEEDED(hr = pQualSet->Put(L"MAX", &curValue,
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS|
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE|
					WBEM_FLAVOR_NOT_OVERRIDABLE)))
				hr = pQualSet->Put(L"MIN", &curValue,
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS|
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE|
					WBEM_FLAVOR_NOT_OVERRIDABLE);
		}

		VariantClear (&curValue);
	}

	return hr;
}

HRESULT CXmlToWmi::SetReferenceClass (
	IWbemQualifierSet *pQualSet,
	BSTR strReferenceClass
)
{
#define	REF_STR	L"ref"

	HRESULT hr = WBEM_E_FAILED;
	int strLen = wcslen(REF_STR);
	bool bIsStrongReference = (strReferenceClass && (0 < wcslen(strReferenceClass)));

	if (bIsStrongReference)
		strLen += wcslen(strReferenceClass) + 1;	// 1 for the ":" separator

	WCHAR *pRef = new WCHAR [strLen + 1];
	wcscpy (pRef, REF_STR);

	if (bIsStrongReference)
	{
		wcscat (pRef, L":");
		wcscat (pRef, strReferenceClass);
	}

	VARIANT curValue;
	VariantInit (&curValue);
	curValue.vt = VT_BSTR;
	curValue.bstrVal = SysAllocString (pRef);
	delete [] pRef;

	hr = pQualSet->Put(L"CIMTYPE", &curValue,
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS|
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE|
					WBEM_FLAVOR_NOT_OVERRIDABLE);

	VariantClear (&curValue);

	return hr;
#undef REF_STR
}


HRESULT CXmlToWmi::SetObjectClass (
	IWbemQualifierSet *pQualSet,
	BSTR strReferenceClass
)
{
#define	OBJ_STR	L"obj"

	HRESULT hr = WBEM_E_FAILED;
	int strLen = wcslen(OBJ_STR);
	bool bIsStrongReference = (strReferenceClass && (0 < wcslen(strReferenceClass)));

	if (bIsStrongReference)
		strLen += wcslen(strReferenceClass) + 1;	// 1 for the ":" separator

	WCHAR *pRef = new WCHAR [strLen + 1];
	wcscpy (pRef, OBJ_STR);

	if (bIsStrongReference)
	{
		wcscat (pRef, L":");
		wcscat (pRef, strReferenceClass);
	}

	VARIANT curValue;
	VariantInit (&curValue);
	curValue.vt = VT_BSTR;
	curValue.bstrVal = SysAllocString (pRef);
	delete [] pRef;

	hr = pQualSet->Put(L"CIMTYPE", &curValue,
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS|
					WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE|
					WBEM_FLAVOR_NOT_OVERRIDABLE);

	VariantClear (&curValue);

	return hr;
#undef OBJ_STR
}


HRESULT CXmlToWmi::MapContextProperty (
	IXMLDOMNode *pProperty,
	IWbemContext *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	BSTR strName = NULL;
	BSTR strType = NULL;

	// Get the NAMEof the property
	if(SUCCEEDED(hr = GetBstrAttribute (pProperty, NAME_ATTRIBUTE, &strName)) && strName)
	{
		// Get the VTTYPE of the property
		if(SUCCEEDED(hr = GetBstrAttribute (pProperty, VTTYPE_ATTRIBUTE, &strType)) && strType)
		{
			// Map the Property type
			VARTYPE vartype = VT_EMPTY;
			if (VT_EMPTY != (vartype = VarTypeFromString (strType)))
			{

				// Get the child element of type "VALUE"
				VARIANT_BOOL bHasChildNodes;
				if (SUCCEEDED(pProperty->hasChildNodes (&bHasChildNodes)) &&
					(VARIANT_TRUE == bHasChildNodes))
				{
					IXMLDOMNodeList *pNodeList = NULL;
					if (SUCCEEDED(pProperty->get_childNodes (&pNodeList)))
					{
						IXMLDOMNode *pNode = NULL;

						while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
						{
							BSTR strNodeName = NULL;

							if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
							{
								if (0 == _wcsicmp(strNodeName, VALUE_TAG))
								{
									BSTR bsValue = NULL;
									pNode->get_text(&bsValue);

									// Map the Qualifier value
									VARIANT value;
									VariantInit (&value);

									// Map the value to a variant
									if(SUCCEEDED(hr = MapContextStringValue (bsValue, value, vartype)))
									{
										// Put the value in the context
										hr = pContext->SetValue (strName, 0, &value);
										VariantClear (&value);
									}
									SysFreeString (bsValue);
								}
								SysFreeString (strNodeName);
							}

							pNode->Release ();
							pNode = NULL;
						}

						pNodeList->Release ();
					}
				}
			}
			SysFreeString(strType);
		}
		SysFreeString(strName);
	}

	return hr;
}


HRESULT CXmlToWmi::MapContextPropertyArray (
	IXMLDOMNode *pProperty,
	IWbemContext *pContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	BSTR strName = NULL;
	BSTR strType = NULL;
	BSTR strArraySize = NULL;

	// Get the NAME of the property
	if(SUCCEEDED(hr = GetBstrAttribute (pProperty, NAME_ATTRIBUTE, &strName)) && strName)
	{
		// Get the VTTYPE of the property
		if(SUCCEEDED(hr = GetBstrAttribute (pProperty, VTTYPE_ATTRIBUTE, &strType)) && strType)
		{
			// Get the size of the array
			if(SUCCEEDED(hr = GetBstrAttribute (pProperty, ARRAYSIZE_ATTRIBUTE, &strArraySize)) && strArraySize)
			{
				// Map the Property type
				VARTYPE vartype = VT_EMPTY;
				if (VT_EMPTY != (vartype = VarTypeFromString (strType)))
				{
					// Get the child element of type "VALUE.ARRAY"
					VARIANT_BOOL bHasChildNodes;
					if (SUCCEEDED(pProperty->hasChildNodes (&bHasChildNodes)) &&
						(VARIANT_TRUE == bHasChildNodes))
					{
						IXMLDOMNodeList *pNodeList = NULL;
						if (SUCCEEDED(pProperty->get_childNodes (&pNodeList)))
						{
							IXMLDOMNode *pNode = NULL;

							while (SUCCEEDED(hr) && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
							{
								BSTR strNodeName = NULL;

								if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
								{
									if (0 == _wcsicmp(strNodeName, VALUEARRAY_TAG))
									{
										VARIANT value;
										VariantInit(&value);

										// Map the value to a variant
										if(SUCCEEDED(hr = MapContextStringArrayValue (pNode, value, vartype)))
										{
											// Put the value in the context
											hr = pContext->SetValue (strName, 0, &value);
											VariantClear (&value);
										}
									}
									else
										hr = WBEM_E_FAILED;	// Parse error
									SysFreeString (strNodeName);
								}

								pNode->Release ();
								pNode = NULL;
							}

							pNodeList->Release ();
						}
					}
				}
				SysFreeString(strArraySize);
			}
			SysFreeString(strType);
		}
		SysFreeString(strName);
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::VarTypeFromString
//
//  DESCRIPTION:
//
//  Utility function to map type attribute string to its VARTYPE equivalent
//
//  PARAMETERS:
//
//		bsType			the type string to be mapped
//
//  RETURN VALUES:
//
//		The corresponding VARTYPE, or VT_EMPTY if error
//
//***************************************************************************
VARTYPE CXmlToWmi::VarTypeFromString (BSTR bsType)
{
	VARTYPE vartype = VT_EMPTY;

	if (bsType)
	{
		if (0 == _wcsicmp (bsType, L"VT_I4"))
			vartype = VT_I4;
		else if (0 == _wcsicmp (bsType, L"VT_R8"))
			vartype = VT_R8;
		else if (0 == _wcsicmp (bsType, L"VT_BOOL"))
			vartype = VT_BOOL;
		else if (0 == _wcsicmp (bsType, L"VT_BSTR"))
			vartype = VT_BSTR;
	}

	return vartype;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapContextStringValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		bsValue			the VALUE element content
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapContextStringValue (BSTR bsValue, VARIANT &curValue, VARTYPE vartype)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;

	// We're assuming it's not an array
	switch (vartype)
	{
		// RAJESHR - more rigorous syntax checking
		case VT_I4:
		{
			VariantClear (&curValue);
			curValue.vt = VT_I4;
			curValue.lVal = wcstol (bsValue, NULL, 0);
			hr = S_OK;
		}
			break;

		case VT_R8:
		{
			VariantClear (&curValue);
			curValue.vt = VT_R8;
			curValue.dblVal = wcstod (bsValue, NULL);
			hr = S_OK;
		}
			break;

		case VT_BOOL:
		{
			VariantClear (&curValue);
			curValue.vt = VT_BOOL;
			curValue.boolVal = (0 == _wcsicmp (bsValue, L"TRUE")) ?
						VARIANT_TRUE : VARIANT_FALSE;
			hr = S_OK;
		}
			break;

		case VT_BSTR:
		{
			VariantClear (&curValue);
			curValue.vt = VT_BSTR;
			curValue.bstrVal = SysAllocString (bsValue);
			hr = S_OK;
		}
			break;
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapContextStringArrayValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE.ARRAY element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		pValueNode		the VALUE.ARRAY node
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapContextStringArrayValue (
	IXMLDOMNode *pValueNode,
	VARIANT &curValue,
	VARTYPE vartype
)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;

	// Build a safearray value from the node list
	IXMLDOMNodeList *pValueList = NULL;

	if (SUCCEEDED (pValueNode->get_childNodes (&pValueList)))
	{
		long length = 0;
		pValueList->get_length (&length);
		SAFEARRAYBOUND	rgsabound [1];
		rgsabound [0].lLbound = 0;
		rgsabound [0].cElements = length;
		SAFEARRAY *pArray = NULL;
		if(pArray = SafeArrayCreate (vartype, 1, rgsabound))
		{
			IXMLDOMNode *pValue = NULL;
			long ix = 0;
			bool error = false;

			while (!error &&
					SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
			{
				BSTR strValName = NULL;

				if (SUCCEEDED(pValue->get_nodeName (&strValName)))
				{
					if (0 == _wcsicmp (strValName, VALUE_TAG))
					{
						BSTR bsValue = NULL;
						pValue->get_text (&bsValue);
						if(FAILED(MapContextStringValueIntoArray (bsValue, pArray, &ix, vartype)))
							error = true;
						SysFreeString (bsValue);
						ix++;
					}
					else
					{
						// unexpected element
						error = true;
					}

					SysFreeString (strValName);
				}

				pValue->Release ();
				pValue = NULL;
			}

			if (error)
				SafeArrayDestroy(pArray);
			else
			{
				curValue.vt = VT_ARRAY|vartype;
				curValue.parray = pArray;
				hr = S_OK;
			}
		}
		else
			hr = E_OUTOFMEMORY;
		pValueList->Release();
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::MapContextStringValueIntoArray
//
//  DESCRIPTION:
//
//  Maps XML VALUE.ARRAY/VALUE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		bsValue			the VALUE element content
//		pArray			SAFEARRAY in which to map the value
//		ix				index to map the value into
//		vt				VARTYPE of the SAFEARRAY
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXmlToWmi::MapContextStringValueIntoArray (
	BSTR bsValue,
	SAFEARRAY *pArray,
	long *ix,
	VARTYPE vt)
{
	HRESULT hr = E_FAIL;
	switch (vt)
	{
		case VT_I4:
		{
			long lVal = wcstol (bsValue, NULL, 0);
			hr = SafeArrayPutElement (pArray, ix, &lVal);
		}
			break;

		case VT_R8:
		{
			double dblVal = wcstod (bsValue, NULL);
			hr = SafeArrayPutElement (pArray, ix, &dblVal);
		}
			break;

		case VT_BOOL:
		{
			VARIANT_BOOL boolVal = (0 == _wcsicmp (bsValue, L"TRUE")) ?
						VARIANT_TRUE : VARIANT_FALSE;
			hr = SafeArrayPutElement (pArray, ix, &boolVal);
		}
			break;

		case VT_BSTR:
			hr = SafeArrayPutElement (pArray, ix, bsValue);
			break;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\wmixmlt.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  PARSE.CPP
//
//  rajeshr  3/25/2000   Created.
//
// Contains the class that interacts with WMI to satisfy XML/HTTP requests
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>
#include <initguid.h>
#include <objbase.h>
#include <wbemcli.h>
#include <wmiutils.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <cominit.h>

#include <httpext.h>
#include <msxml.h>

#include "provtempl.h"
#include "common.h"
#include "wmixmlop.h"
#include "wmixmlst.h"
#include "concache.h"
#include "wmiconv.h"
#include "xml2wmi.h"
#include "wmixmlt.h"
#include "request.h"
#include "whistler.h"
#include "strings.h"
#include "xmlhelp.h"
#include "parse.h"

// Strings for queries
#define WMIXMLT_Q				L"select __CLASS,__GENUS,__SUPERCLASS, __PATH, __RELPATH, "

static WCHAR *BuildPropertyList (DWORD dwNumProperties, BSTR *pPropertyArray);
static BSTR FormatAssociatorsQuery(
	BSTR strObjectPath,
	BSTR strAssocClass,
	BSTR strResultClass,
	BSTR strResultRole,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredAssocQualifier,
	BSTR strRequiredQualifier
);

static BSTR FormatReferencesQuery(
	BSTR strObjectPath,
	BSTR strResultClass,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredQualifier
);

// Required for the Query parser
static ULONG uFeatures[] =
{
	WMIQ_LF1_BASIC_SELECT,
	WMIQ_LF2_CLASS_NAME_IN_QUERY
};

// Strings for association and reference queries
#define WMIXML_QUERY_ASSOCOF	OLESTR("associators of ")
#define WMIXML_QUERY_OPENBRACE	OLESTR("{")
#define WMIXML_QUERY_CLOSEBRACE	OLESTR("}")
#define WMIXML_QUERY_WHERE		OLESTR(" where ")
#define WMIXML_QUERY_ASSOCCLASS	OLESTR(" AssocClass ")
#define WMIXML_QUERY_EQUALS		OLESTR("=")
#define WMIXML_QUERY_CLASSDEFS	OLESTR(" ClassDefsOnly ")
#define WMIXML_QUERY_REQASSOCQ	OLESTR(" RequiredAssocQualifier ")
#define WMIXML_QUERY_REQQUAL	OLESTR(" RequiredQualifier ")
#define WMIXML_QUERY_RESCLASS	OLESTR(" ResultClass ")
#define WMIXML_QUERY_RESROLE	OLESTR(" ResultRole ")
#define WMIXML_QUERY_ROLE		OLESTR(" Role ")
#define WMIXML_QUERY_SCHEMAONLY	OLESTR(" SchemaOnly ")
#define WMIXML_QUERY_REFOF		OLESTR("references of ")



//***************************************************************************
//
//  CXMLTranslator::CXMLTranslator
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CXMLTranslator::CXMLTranslator(IXMLDOMNode *pContext, WMI_XML_HTTP_VERSION iHttpVersion, IStream *pPrefixStream, IStream *pSuffixStream)
{
	m_iHttpVersion = iHttpVersion;
	if(m_pContext = pContext)
		m_pContext->AddRef();
	if(m_pPrefixStream = pPrefixStream)
		m_pPrefixStream->AddRef();
	if(m_pSuffixStream = pSuffixStream)
		m_pSuffixStream->AddRef();
}

//***************************************************************************
//
//  CXMLTranslator::~CXMLTranslator
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CXMLTranslator::~CXMLTranslator(void)
{
	if(m_pPrefixStream)
		m_pPrefixStream->Release();
	if(m_pSuffixStream)
		m_pSuffixStream->Release();
	if(m_pContext)
		m_pContext->Release();

}


//***************************************************************************
//
//  SCODE CXMLTranslator::GetObject
//
//  DESCRIPTION:
//
//  Transforms a single WBEM object into its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides
//		pszObjectPath			The relative (model) path of the object within
//								that namespace
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::GetObject (
	BSTR pszNamespacePath,
	BSTR pszObjectPath,
	DWORD dwNumProperties,
	BSTR *pPropertyArray,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == pszObjectPath)
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;
		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Get the requested object
				IWbemClassObject *pObject = NULL;
				// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
				// Otherwise, make a best effort call with no flags.
				// We need this to get the properties that have the "amended" qualifier on them
				if(WBEM_E_INVALID_PARAMETER  == (hr = pService->GetObject (pszObjectPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, pContext, &pObject, NULL)))
					hr = pService->GetObject (pszObjectPath, 0, pContext, &pObject, NULL);
				if (WBEM_S_NO_ERROR == hr)
				{
					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// Create the convertor
							IWbemXMLConvertor *pConvertor = NULL;
							if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
							{
								// Now do the translation
								if(SUCCEEDED(hr = SetI4ContextValue(pFlagsContext, L"PathLevel", 0)))
								{
									// Write an IRETURNVALUE to the Prefix Stream
									WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
									pConvertor->MapObjectToXML(pObject, pPropertyArray, dwNumProperties, pFlagsContext, m_pPrefixStream, NULL);
									WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
								}
								pConvertor->Release();
							}
						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// Create a stream
							// The reason we create a new stream instead of writing into m_pPrefixStream
							// is that we dont know if the call to MapObjectToXML will be successful
							// In the case it isnt, then we cannot write the IRETURNVALUE tag
							// In the case it is, we need to write the IRETURNVALUE tag before 
							// the encoding of the object
							IStream *pStream = NULL;
							if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
							{
								// Create the convertor
								IWbemXMLConvertor *pConvertor = NULL;
								if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
								{
									// Now do the translation
									if(SUCCEEDED(hr = SetI4ContextValue(pFlagsContext, L"PathLevel", 0)))
									{
										if (SUCCEEDED(hr = pConvertor->MapObjectToXML(pObject, pPropertyArray, dwNumProperties, pFlagsContext, pStream, NULL)))
										{
											// First Write an IRETURNVALUE to the Prefix Stream
											WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
											WRITEBSTR(pStream, L"</IRETURNVALUE>");

											// Write the translation to the IIS Socket
											SavePrefixAndBodyToIISSocket(m_pPrefixStream, pStream, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);
										}
									}
									pConvertor->Release();
								}
								pStream->Release ();
							}
						}
						break;
					}
					pObject->Release ();
				}
			}

			// Release the IWbemContext, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::GetProperty
//
//  DESCRIPTION:
//
//  Transforms a single WBEM Property value into its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides
//		pszObjectPath			The relative (model) path of the object within
//								that namespace
//		pszPropertyName			Name of the property whose value is requested
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::GetProperty (
	BSTR pszNamespacePath,
	BSTR pszObjectPath,
	BSTR pszPropertyName,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszObjectPath) || (NULL == pszPropertyName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Dont create a new context if we already have one
				if(pContext || (!pContext && SUCCEEDED(hr = CoCreateInstance (CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER,
												IID_IWbemContext, (void**) &pContext))) )
				{
					// Add the per-property GET information into the context
					VARIANT var;
					VariantInit (&var);
					var.vt = VT_BOOL;
					var.boolVal = VARIANT_TRUE;
					HRESULT hr2 = pContext->SetValue (L"__GET_EXTENSIONS", 0, &var);
					VariantClear (&var);

					SAFEARRAYBOUND rgsabound [1];
					rgsabound [0].lLbound = 0;
					rgsabound [0].cElements = 1;
					SAFEARRAY *pArray = SafeArrayCreate (VT_BSTR, 1, rgsabound);
					long ix = 0;
					hr2 = SafeArrayPutElement (pArray, &ix, pszPropertyName);
					var.vt = VT_ARRAY|VT_BSTR;
					var.parray = pArray;
					hr2 = pContext->SetValue (L"__GET_EXT_PROPERTIES", 0, &var);
					VariantClear (&var);

					// Get the requested object
					IWbemClassObject *pObject = NULL;

					// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
					// Otherwise, make a best effort call with no flags.
					// We need this to get the properties that have the "amended" qualifier on them
					if(WBEM_E_INVALID_PARAMETER  == (hr = pService->GetObject (pszObjectPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, pContext, &pObject, NULL)))
						hr = pService->GetObject (pszObjectPath, 0, pContext, &pObject, NULL);
					if (WBEM_S_NO_ERROR == hr)
					{
						switch(m_iHttpVersion)
						{
							// We write everything on to the prefix stream since there is no
							// chunked encoding in HTTP 1.0
							case WMI_XML_HTTP_VERSION_1_0:
							{
								// Create the convertor
								IWbemXMLConvertor *pConvertor = NULL;
								if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
								{
									// First Write an IRETURNVALUE to the Prefix Stream
									WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
									// Now do the translation
									hr = pConvertor->MapPropertyToXML (pObject, pszPropertyName, pFlagsContext, m_pPrefixStream);
									WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");

									pConvertor->Release();
								}
							}
							break;

							case WMI_XML_HTTP_VERSION_1_1:
							{
								// Create a stream
								IStream *pStream = NULL;
								if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
								{
									// Create the convertor
									IWbemXMLConvertor *pConvertor = NULL;
									if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
									{
										// Now do the translation
										if (SUCCEEDED(hr = pConvertor->MapPropertyToXML (pObject, pszPropertyName, pFlagsContext, pStream)))
										{
											// First Write an IRETURNVALUE to the Prefix Stream
											WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
											WRITEBSTR(pStream, L"</IRETURNVALUE>");

											// Write the translation to the IIS Socket
											SavePrefixAndBodyToIISSocket(m_pPrefixStream, pStream, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);
										}
										pConvertor->Release();
									}
									pStream->Release ();
								}
							}
							break;
						}
						pObject->Release ();
					}
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);
	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::SetProperty
//
//  DESCRIPTION:
//
//  Updates a single WBEM Property value
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides
//		pszObjectPath			The relative (model) path of the object within
//								that namespace
//		pszPropertyName			Name of the property whose value is requested
//		pszPropertyValue		The proposed value as an XML string
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::SetProperty (
	BSTR pszNamespacePath,
	BSTR pszObjectPath,
	BSTR pszPropertyName,
	IXMLDOMNode *pPropertyValue,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszObjectPath) || (NULL == pszPropertyName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{

		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{

			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Get the requested object first
				IWbemClassObject *pObject = NULL;
				if (WBEM_S_NO_ERROR == (hr = pService->GetObject (pszObjectPath, 0, NULL, &pObject, NULL)))
				{
					// Map the property value to its VARIANT equivalent and set in the
					// object
					VARIANT vvar;
					VariantInit (&vvar);
					CIMTYPE cimtype;
					long flavor;

					if (SUCCEEDED (hr = pObject->Get (pszPropertyName, 0, &vvar, &cimtype, &flavor)))
					{
						// Got the property - now map the new value and attempt to set it
						CXmlToWmi xmlToWmi;
						if(SUCCEEDED(hr = xmlToWmi.Initialize(pPropertyValue)))
						{
	 						if (SUCCEEDED (hr = xmlToWmi.MapPropertyValue (vvar, cimtype)))
							{
								if (SUCCEEDED (hr = pObject->Put (pszPropertyName, 0, &vvar, 0)))
								{
									// Set the value OK - now do a per-property put to commit the change
									if (pContext || (!pContext && SUCCEEDED(hr = CoCreateInstance (CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER,
																		IID_IWbemContext, (void**) &pContext))) )
									{
										// Add the per-property PUT information into the context
										VARIANT cvar;
										VariantInit (&cvar);
										cvar.vt = VT_BOOL;
										cvar.boolVal = VARIANT_TRUE;
										HRESULT hr2 = pContext->SetValue (L"__PUT_EXTENSIONS", 0, &cvar);
										VariantClear (&cvar);

										SAFEARRAYBOUND rgsabound [1];
										rgsabound [0].lLbound = 0;
										rgsabound [0].cElements = 1;
										SAFEARRAY *pArray = SafeArrayCreate (VT_BSTR, 1, rgsabound);
										long ix = 0;
										hr2 = SafeArrayPutElement (pArray, &ix, pszPropertyName);
										cvar.vt = VT_ARRAY|VT_BSTR;
										cvar.parray = pArray;
										hr2 = pContext->SetValue (L"__PUT_EXT_PROPERTIES", 0, &cvar);
										VariantClear (&cvar);

										// Set the instance - if we get WBEM_E_PROVIDER_NOT_CAPABLE,
										// roll back to a simple put with no context
										hr = pService->PutInstance (pObject, WBEM_FLAG_UPDATE_ONLY,
													pContext, NULL);
										if (WBEM_E_PROVIDER_NOT_CAPABLE == hr)
											hr = pService->PutInstance (pObject, WBEM_FLAG_UPDATE_ONLY,
														NULL, NULL);

									}
								}
							}
						}
					}

					VariantClear (&vvar);

					pObject->Release ();
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::CreateClass
//
//  DESCRIPTION:
//
//  Creates a new WMI class or modifies an existing one
//
//  PARAMETERS:
//
//		pszNamespacePath	The namespace path in which the object resides
//		pClass				The new class definition in XML format
//		bIsModify			Whether this is a modify operation
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::CreateClass (
	BSTR pszNamespacePath,
	IXMLDOMNode *pClass,
	BOOL bIsModify,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext,
	LONG lFlags)
{
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pClass))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;
		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				if (!bIsModify)
				{
					// Get the base object first; need to know if this is derived or not
					IWbemClassObject *pObject = NULL;

					// Should have a CLASS element - does it have a SUPERCLASS attribute?
					BSTR strSuperClass = NULL;
					GetBstrAttribute (pClass, SUPERCLASS_ATTRIBUTE, &strSuperClass);

					if (WBEM_S_NO_ERROR == (hr = pService->GetObject (strSuperClass, 0, pContext, &pObject, NULL)))
					{
						// Got the underlying class - now map the new value and attempt to set it
						if (strSuperClass && (0 < wcslen (strSuperClass)))
						{
							IWbemClassObject *pSubClass = NULL;
							if (SUCCEEDED(hr = pObject->SpawnDerivedClass (0, &pSubClass)))
							{
								CXmlToWmi xmlToWmi;
								if(SUCCEEDED(hr = xmlToWmi.Initialize(pClass, pService, pSubClass)))
								{
									if (SUCCEEDED (hr = xmlToWmi.MapClass ()))
										hr = pService->PutClass (pSubClass, WBEM_FLAG_CREATE_OR_UPDATE | lFlags, pContext, NULL);
								}

								pSubClass->Release ();
							}
						}
						else
						{
							CXmlToWmi xmlToWmi;
							if(SUCCEEDED(hr = xmlToWmi.Initialize(pClass, pService, pObject)))
							{
								if (SUCCEEDED(hr = xmlToWmi.MapClass ()))
									hr = pService->PutClass (pObject, WBEM_FLAG_CREATE_OR_UPDATE|lFlags, pContext, NULL);
							}
						}

						pObject->Release ();
					}
					SysFreeString (strSuperClass);
				}
				else
				{
					// Get the existing class definition first
					IWbemClassObject *pObject = NULL;

					// Should have a CLASS element - does it have a NAME attribute?
					BSTR strClass = NULL;
					GetBstrAttribute (pClass, NAME_ATTRIBUTE, &strClass);

					if (WBEM_S_NO_ERROR == (hr = pService->GetObject (strClass, 0, pContext, &pObject, NULL)))
					{
						CXmlToWmi xmlToWmi;
						if(SUCCEEDED(hr = xmlToWmi.Initialize(pClass, pService, pObject)))
						{
							if (SUCCEEDED(hr = xmlToWmi.MapClass (TRUE)))
								hr = pService->PutClass (pObject, WBEM_FLAG_UPDATE_ONLY|lFlags, NULL, NULL);
						}
						pObject->Release ();
					}

					SysFreeString (strClass);
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::CreateInstance
//
//  DESCRIPTION:
//
//  Creates a new WMI instance
//
//  PARAMETERS:
//
//		pszNamespacePath	The namespace path in which the object resides
//		pInstance			The new instance definition in XML format
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::CreateInstance (
	BSTR pszNamespacePath,
	IXMLDOMNode *pInstance,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext,
	LONG lFlags)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pInstance))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				IWbemClassObject *pObject = NULL;

				// Should have a CLASSNAME attribute
				BSTR strClassName = NULL;
				GetBstrAttribute (pInstance, CLASS_NAME_ATTRIBUTE, &strClassName);

				if (strClassName && (0 < wcslen (strClassName)) &&
					WBEM_S_NO_ERROR == (hr = pService->GetObject (strClassName, 0, NULL, &pObject, NULL)))
				{
					// Got the underlying class - now map the new value and attempt to set it
					IWbemClassObject *pNewInstance = NULL;

					if (SUCCEEDED(hr = pObject->SpawnInstance (0, &pNewInstance)))
					{
						CXmlToWmi xmlToWmi;
						if(SUCCEEDED(hr = xmlToWmi.Initialize(pInstance, pService, pNewInstance)))
						{
							if (SUCCEEDED (hr = xmlToWmi.MapInstance ()))
							{
								IWbemCallResult *pResult = NULL;
								// We need to make this a semi-sync call so that we can get
								// the object name of the create object
								if (SUCCEEDED(hr = pService->PutInstance
											(pNewInstance, WBEM_FLAG_CREATE_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY|lFlags, pContext, &pResult)) && pResult)
								{
									HRESULT hCallResult = S_OK;
									if (SUCCEEDED(hr = pResult->GetCallStatus (INFINITE, &hCallResult)))
									{
										if(SUCCEEDED(hCallResult))
										{
											// Now get the relpath string from the call result
											hr = WBEM_E_FAILED;
											BSTR resultString = NULL;
											if (SUCCEEDED(hr = pResult->GetResultString (INFINITE, &resultString)))
											{
												switch(m_iHttpVersion)
												{
													// We write everything on to the prefix stream since there is no
													// chunked encoding in HTTP 1.0
													case WMI_XML_HTTP_VERSION_1_0:
													{
														// Create the convertor
														IWbemXMLConvertor *pConvertor = NULL;
														if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
														{
															// First Write an IRETURNVALUE to the Prefix Stream
															WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
															// Now do the translation
															hr = pConvertor->MapInstanceNameToXML(resultString, pFlagsContext, m_pPrefixStream);
															WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
															pConvertor->Release();
														}
													}
													break;
													case WMI_XML_HTTP_VERSION_1_1:
													{
														// Create a stream
														IStream *pStream = NULL;
														if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
														{
															// Create the convertor
															IWbemXMLConvertor *pConvertor = NULL;
															if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
															{
																// Now do the translation
																if (SUCCEEDED(hr = pConvertor->MapInstanceNameToXML(resultString, pFlagsContext, pStream)))
																{
																	// First Write an IRETURNVALUE to the Prefix Stream
																	WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
																	WRITEBSTR(pStream, L"</IRETURNVALUE>");

																	// Write the translation to the IIS Socket
																	SavePrefixAndBodyToIISSocket(m_pPrefixStream, pStream, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);
																}
																pConvertor->Release();
															}
															pStream->Release ();
														}
													}
													break;
												}

												SysFreeString (resultString);
											}
										}
										else
											hr = hCallResult;
									}

									pResult->Release ();
								}
							}
						}

						pNewInstance->Release ();
					}

					pObject->Release ();
				}
				SysFreeString (strClassName);

			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();

		}
	}

	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::ModifyInstance
//
//  DESCRIPTION:
//
//  Modifies an existing WMI instance
//
//  PARAMETERS:
//
//		pszNamespacePath	The namespace path in which the object resides
//		pInstance			The new instance definition in XML format
//		pszInstancePath		The instance path
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::ModifyInstance (
	BSTR pszNamespacePath,
	IXMLDOMNode *pInstance,
	BSTR pszInstancePath,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext,
	LONG lFlags

)
{
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszInstancePath) || (NULL == pszNamespacePath) || (NULL == pInstance))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				IWbemClassObject *pCurInstance = NULL;

				// Get the instance (MUST exist)
				if (WBEM_S_NO_ERROR == (hr = pService->GetObject (pszInstancePath, 0, NULL, &pCurInstance, NULL)))
				{
					CXmlToWmi xmlToWmi;
					if(SUCCEEDED(hr = xmlToWmi.Initialize(pInstance, pService, pCurInstance)))
					{
						if (SUCCEEDED (hr = xmlToWmi.MapInstance (TRUE)))
							hr = pService->PutInstance (pCurInstance, WBEM_FLAG_UPDATE_ONLY|lFlags, pContext, NULL);
					}
					pCurInstance->Release ();
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::DeleteObject
//
//  DESCRIPTION:
//
//  Delete a class or instance
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides
//		pszObjectPath			The relative (model) path of the object within
//								that namespace
//		bIsClass				Whether this is a class or instance
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::DeleteObject (
	BSTR pszNamespacePath,
	BSTR pszObjectPath,
	BOOL bIsClass,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	HRESULT hr = WBEM_E_FAILED;

	if (NULL == pszObjectPath)
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Delete the requested object
				hr = (bIsClass) ? pService->DeleteClass (pszObjectPath, 0, pContext, NULL):
								  pService->DeleteInstance (pszObjectPath, 0, pContext, NULL);
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::ExecuteQuery
//
//  DESCRIPTION:
//
//  Transforms the query result set nto its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszQueryLanguage		The query language used
//		pszQueryString			The query to execute within	that namespace.
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::ExecuteQuery (
	BSTR pszNamespacePath,
	BSTR pszQueryLanguage,
	BSTR pszQueryString,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszQueryString))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Transform the query to include suitable system properties
				BOOL bMustFreeQueryString = TransformQuery (&pszQueryString);

				// Perform the query
				IEnumWbemClassObject *pEnum = NULL;
				// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
				// Otherwise, make a best effort call with no flags.
				// We need this to get the properties that have the "amended" qualifier on them
				long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
				if(WBEM_E_INVALID_PARAMETER  == (hr = pService->ExecQuery (pszQueryLanguage, pszQueryString, lFlags | WBEM_FLAG_USE_AMENDED_QUALIFIERS, pContext, &pEnum)))
					hr = pService->ExecQuery (pszQueryLanguage, pszQueryString, lFlags, pContext, &pEnum);
				if (WBEM_S_NO_ERROR == hr)
				{
					// Ensure we have impersonation enabled
					DWORD dwAuthnLevel, dwImpLevel;
					GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

					if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
						SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							MapEnum (pEnum, 3, 0, NULL, NULL, pECB, pFlagsContext, FALSE, m_pPrefixStream);
							WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							SaveStreamToIISSocket(m_pPrefixStream, pECB, TRUE);
							WRITEBSTR(m_pSuffixStream, L"</IRETURNVALUE>");

							// Create VALUE.OBJECTs
							MapEnum (pEnum, 0, 0, NULL, NULL, pECB, pFlagsContext, TRUE);
						}
						break;
					}

					pEnum->Release ();
				}
				if (bMustFreeQueryString)
					SysFreeString (pszQueryString);
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::EnumerateInstanceNames
//
//  DESCRIPTION:
//
//		Transforms the query result set into its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszClassName			The class whose instance names are to be enumerated
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::EnumerateInstanceNames (
	BSTR pszNamespacePath,
	BSTR pszClassName,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszClassName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Perform the query
				IEnumWbemClassObject *pEnum = NULL;

				BSTR bsQueryLang = NULL;
				if(bsQueryLang = SysAllocString(L"WQL"))
				{
					LPWSTR pszQuery = NULL;
					if(pszQuery = new WCHAR [ wcslen(L"select __RELPATH from ") + wcslen(pszClassName) + 1])
					{
						pszQuery[0] = NULL;
						wcscat(pszQuery, L"select __RELPATH from ");
						wcscat(pszQuery, pszClassName);
						BSTR bsQuery = NULL;
						if(bsQuery = SysAllocString(pszQuery))
						{
							// RAJESHR - Use semi sync and Forward only enumerator?
							long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
							if (SUCCEEDED (hr = pService->ExecQuery
														(bsQueryLang, bsQuery, 0, pContext, &pEnum)))
							{
								// Ensure we have impersonation enabled
								DWORD dwAuthnLevel, dwImpLevel;
								GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

								if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
									SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

								switch(m_iHttpVersion)
								{
									// We write everything on to the prefix stream since there is no
									// chunked encoding in HTTP 1.0
									case WMI_XML_HTTP_VERSION_1_0:
									{
										// First Write an IRETURNVALUE to the Prefix Stream
										WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
										// Now do the translation
										MapEnumNames (m_pPrefixStream, pEnum, 2, pFlagsContext);
										WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
									}
									break;
									case WMI_XML_HTTP_VERSION_1_1:
									{
										// Create a stream
										IStream *pStream = NULL;
										if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
										{
											// Now do the translation
											if (SUCCEEDED(MapEnumNames (pStream, pEnum, 2, pFlagsContext)))
											{
												// First Write an IRETURNVALUE to the Prefix Stream
												WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
												WRITEBSTR(pStream, L"</IRETURNVALUE>");

												// Write the translation to the IIS Socket
												SavePrefixAndBodyToIISSocket(m_pPrefixStream, pStream, pECB, TRUE);
											}
											pStream->Release ();
										}
									}
									break;
								}
								pEnum->Release ();
							}

							SysFreeString (bsQuery);
						}
						else
							hr = E_OUTOFMEMORY;

						delete [] pszQuery;
					}
					else
						hr = E_OUTOFMEMORY;
					SysFreeString (bsQueryLang);
				}
				else
					hr = E_OUTOFMEMORY;
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::EnumerateClassNames
//
//  DESCRIPTION:
//
//		Transforms the query result set into its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszClassName			The class whose subclass names are to be enumerated
//		bDeepInheritance		Whether to do a deep inheritance
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::EnumerateClassNames (
	BSTR pszNamespacePath,
	BSTR pszClassName,
	BOOL bDeepInheritance,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszClassName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
					// Perform the query
				IEnumWbemClassObject *pEnum = NULL;
				LONG lFlags = (bDeepInheritance) ? WBEM_FLAG_DEEP : WBEM_FLAG_SHALLOW;

				// RAJESHR - Can this be done more efficiently via a schema query ?
				lFlags |= (WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY);
				if (SUCCEEDED (hr = pService->CreateClassEnum
											(pszClassName, lFlags, pContext, &pEnum)))
				{
					// Ensure we have impersonation enabled
					DWORD dwAuthnLevel, dwImpLevel;
					GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

					if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
						SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							// Now do the translation
							MapClassNames (m_pPrefixStream, pEnum, pFlagsContext);
							WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// Create a stream
							IStream *pStream = NULL;

							if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
							{
								// Now do the translation
								if (SUCCEEDED(hr = MapClassNames (pStream, pEnum, pFlagsContext)))
								{
									// First Write an IRETURNVALUE to the Prefix Stream
									WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
									WRITEBSTR(pStream, L"</IRETURNVALUE>");

									// Write the translation to the IIS Socket
									SavePrefixAndBodyToIISSocket(m_pPrefixStream, pStream, pECB, TRUE);
								}

								pStream->Release ();
							}
						}
						break;
					}

					pEnum->Release ();
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);
	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::EnumerateInstances
//
//  DESCRIPTION:
//
//  Transforms the query result set nto its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszClassName			The class to be enumerated
//		bDeep					Whether this enumeration is deep
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::EnumerateInstances (
	BSTR pszNamespacePath,
	BSTR pszClassName,
	VARIANT_BOOL bDeep,
	BOOL bIsMicrosoftWMIClient,
	DWORD dwNumProperties,
	BSTR *pPropertyArray,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszClassName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;
		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Perform the Enumeration - RAJESHR if a property list is specified, can we make it more efficient using a Query?
				IEnumWbemClassObject *pEnum = NULL;

				long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;

				// DMTF and Microsoft have different interpretations of the Deep enumeration
				// For DMTF, we always have to ask our CIMOM to do a Deep enumeration and post-process
				// later. Whereas, for Microsoft we directly pass the flag as it is
				if(bIsMicrosoftWMIClient)
				{
					if(VARIANT_TRUE == bDeep) lFlags |= WBEM_FLAG_DEEP;
				}
				else // For DMTF
					lFlags |= WBEM_FLAG_DEEP;

				// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
				// Otherwise, make a best effort call with no flags.
				// We need this to get the properties that have the "amended" qualifier on them
				if(WBEM_E_INVALID_PARAMETER  == (hr = pService->CreateInstanceEnum (pszClassName, lFlags | WBEM_FLAG_USE_AMENDED_QUALIFIERS, pContext, &pEnum)))
					hr = pService->CreateInstanceEnum (pszClassName, lFlags, pContext, &pEnum);
				if (WBEM_S_NO_ERROR == hr)
				{
					// Ensure we have impersonation enabled
					DWORD dwAuthnLevel, dwImpLevel;
					GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

					if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
						SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");

							// Now do the translation
							// For Deep Enumerations and WMI Enumerations, we dont do anything special
							// For shallow instance enumerations we have to give the class basis
							// the CWmiToXml object so it can emulate DMTF-style shallow enumeration
							if (VARIANT_TRUE == bDeep || bIsMicrosoftWMIClient)
								MapEnum (pEnum, 1, dwNumProperties, pPropertyArray, NULL, pECB, pFlagsContext, FALSE, m_pPrefixStream);
							else
								MapEnum (pEnum, 1, dwNumProperties, pPropertyArray, pszClassName, pECB, pFlagsContext, FALSE, m_pPrefixStream);
							WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							SaveStreamToIISSocket(m_pPrefixStream, pECB, TRUE);
							WRITEBSTR(m_pSuffixStream, L"</IRETURNVALUE>");

							// Now do the translation
							// For shallow instance enumerations we have to give the class basis
							// the CWmiToXml object so it can emulate DMTF-style shallow enumeration
							if (VARIANT_TRUE == bDeep || bIsMicrosoftWMIClient)
								MapEnum (pEnum, 1, dwNumProperties, pPropertyArray, NULL, pECB, pFlagsContext, TRUE);
							else
								MapEnum (pEnum, 1, dwNumProperties, pPropertyArray, pszClassName, pECB, pFlagsContext, TRUE);
						}
						break;
					}

					pEnum->Release ();
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::EnumerateClasses
//
//  DESCRIPTION:
//
//  Transforms the query result set nto its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszClassName			The class to be enumerated
//		bDeep					Whether this enumeration is deep
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::EnumerateClasses (
	BSTR pszNamespacePath,
	BSTR pszClassName,
	VARIANT_BOOL bDeep,
	DWORD dwNumProperties,
	BSTR *pPropertyArray,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszClassName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Perform the query
				IEnumWbemClassObject *pEnum = NULL;
				long lDeepFlag = WBEM_FLAG_DEEP;
				if(bDeep == VARIANT_FALSE)
					lDeepFlag = WBEM_FLAG_SHALLOW;

				// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
				// Otherwise, make a best effort call with no flags.
				// We need this to get the properties that have the "amended" qualifier on them
				lDeepFlag |= WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
				if(WBEM_E_INVALID_PARAMETER  == (hr = pService->CreateClassEnum (pszClassName, lDeepFlag | WBEM_FLAG_USE_AMENDED_QUALIFIERS, pContext, &pEnum)))
					hr = pService->CreateClassEnum (pszClassName, lDeepFlag, pContext, &pEnum);

				if (WBEM_S_NO_ERROR == hr)
				{
					// Ensure we have impersonation enabled
					DWORD dwAuthnLevel, dwImpLevel;
					GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

					if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
						SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							// Now do the translation
							MapEnum (pEnum, 0, dwNumProperties, pPropertyArray, NULL, pECB, pFlagsContext, FALSE, m_pPrefixStream);
							WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");

						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							SaveStreamToIISSocket(m_pPrefixStream, pECB, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
							WRITEBSTR(m_pSuffixStream, L"</IRETURNVALUE>");

							// Now do the translation
							MapEnum (pEnum, 0, dwNumProperties, pPropertyArray, NULL, pECB, pFlagsContext, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
						}
						break;
					}
					pEnum->Release ();
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::Associators
//
//  DESCRIPTION:
//
//  Performs an "ASSOCIATORS OF" query and transforms the result into XML
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszClassName			The class to be enumerated
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::Associators (
	BSTR pszNamespacePath,
	BSTR pszObjectName,
	BSTR pszAssocClass,
	BSTR pszResultClass,
	BSTR pszRole,
	BSTR pszResultRole,
	DWORD dwNumProperties,
	BSTR *pPropertyArray,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszObjectName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{

				// Perform the query
				IEnumWbemClassObject *pEnum = NULL;

				WCHAR *strPropertyList = BuildPropertyList (dwNumProperties, pPropertyArray);
				BSTR bsQueryLang = NULL;
				bsQueryLang = SysAllocString(L"WQL");

				// Build the ASSOCIATORS OF query
				BSTR bsQuery = FormatAssociatorsQuery (pszObjectName, pszAssocClass, pszResultClass,
						pszResultRole, pszRole, FALSE, FALSE, NULL, NULL);

				// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
				// Otherwise, make a best effort call with no flags.
				// We need this to get the properties that have the "amended" qualifier on them
				long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
				if(WBEM_E_INVALID_PARAMETER  == (hr = pService->ExecQuery (bsQueryLang, bsQuery, lFlags | WBEM_FLAG_USE_AMENDED_QUALIFIERS, pContext, &pEnum)))
					hr = pService->ExecQuery (bsQueryLang, bsQuery, lFlags, pContext, &pEnum);
				SysFreeString (bsQueryLang);
				SysFreeString (bsQuery);

				if (WBEM_S_NO_ERROR == hr)
				{
					// Ensure we have impersonation enabled
					DWORD dwAuthnLevel, dwImpLevel;
					GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

					if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
						SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							MapEnum (pEnum, 3, 0, NULL, NULL, pECB, pFlagsContext, FALSE, m_pPrefixStream);
							WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							SaveStreamToIISSocket(m_pPrefixStream, pECB, TRUE);
							WRITEBSTR(m_pSuffixStream, L"</IRETURNVALUE>");
							MapEnum (pEnum, 3, 0, NULL, NULL, pECB, pFlagsContext, TRUE);
						}
						break;
					}

					pEnum->Release ();
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::AssociatorNames
//
//  DESCRIPTION:
//
//  Performs an "ASSOCIATORS OF" query, gets the names and transforms the
///	result into XML
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszObjectName			The object whose assocaitors are required
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::AssociatorNames (
	BSTR pszNamespacePath,
	BSTR pszObjectName,
	BSTR pszAssocClass,
	BSTR pszResultClass,
	BSTR pszRole,
	BSTR pszResultRole,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszObjectName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Perform the query
				IEnumWbemClassObject *pEnum = NULL;

				BSTR bsQueryLang = NULL;
				bsQueryLang = SysAllocString(L"WQL");

				// Build the ASSOCIATORS OF query
				BSTR bsQuery = FormatAssociatorsQuery (pszObjectName, pszAssocClass, pszResultClass,
						pszResultRole, pszRole, FALSE, FALSE, NULL, NULL);

				// RAJESHR - Use semi sync and Forward only enumerator?
				long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
				if(SUCCEEDED(hr = pService->ExecQuery (bsQueryLang, bsQuery, lFlags, pContext, &pEnum)))
				{
					// Ensure we have impersonation enabled
					DWORD dwAuthnLevel, dwImpLevel;
					GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

					if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
						SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							// Now do the translation
							MapEnumNames (m_pPrefixStream, pEnum, 3, pFlagsContext);
							WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// Create a stream
							IStream *pStream = NULL;
							if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
							{
								// Now do the translation
								if (SUCCEEDED(MapEnumNames (pStream, pEnum, 3, pFlagsContext)))
								{
									// First Write an IRETURNVALUE to the Prefix Stream
									WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
									WRITEBSTR(pStream, L"</IRETURNVALUE>");

									// Write the translation to the IIS Socket
									SavePrefixAndBodyToIISSocket(m_pPrefixStream, pStream, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);
								}
								pStream->Release ();
							}
						}
						break;
					}

					pEnum->Release ();
				}
				SysFreeString (bsQueryLang);
				SysFreeString (bsQuery);
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::References
//
//  DESCRIPTION:
//
//  Performs an "REFERENCES OF" query and transforms the result into XML
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszClassName			The class to be enumerated
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::References (
	BSTR pszNamespacePath,
	BSTR pszObjectName,
	BSTR pszResultClass,
	BSTR pszRole,
	DWORD dwNumProperties,
	BSTR *pPropertyArray,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszObjectName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Perform the query
				IEnumWbemClassObject *pEnum = NULL;

				WCHAR *strPropertyList = BuildPropertyList (dwNumProperties, pPropertyArray);
				BSTR bsQueryLang = SysAllocString(L"WQL");

				// Build the ASSOCIATORS OF query
				BSTR bsQuery = FormatReferencesQuery (pszObjectName, pszResultClass,
														pszRole, FALSE, FALSE, NULL);

				// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
				// Otherwise, make a best effort call with no flags.
				// We need this to get the properties that have the "amended" qualifier on them
				long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
				if(WBEM_E_INVALID_PARAMETER  == (hr = pService->ExecQuery (bsQueryLang, bsQuery, lFlags | WBEM_FLAG_USE_AMENDED_QUALIFIERS, pContext, &pEnum)))
					hr = pService->ExecQuery (bsQueryLang, bsQuery, lFlags, pContext, &pEnum);
				SysFreeString (bsQueryLang);
				SysFreeString (bsQuery);

				if (WBEM_S_NO_ERROR == hr)
				{
					// Ensure we have impersonation enabled
					DWORD dwAuthnLevel, dwImpLevel;
					GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

					if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
						SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							MapEnum (pEnum, 3, 0, NULL, NULL, pECB, pFlagsContext, FALSE, m_pPrefixStream);
							WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							SaveStreamToIISSocket(m_pPrefixStream, pECB, TRUE);
							WRITEBSTR(m_pSuffixStream, L"</IRETURNVALUE>");
							MapEnum (pEnum, 3, 0, NULL, NULL, pECB, pFlagsContext, TRUE);
						}
						break;
					}

					pEnum->Release ();
				}
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}

	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);
	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::ReferenceNames
//
//  DESCRIPTION:
//
//  Performs an "REFERENCES OF" query, gets the names and transforms the
///	result into XML
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszObjectName			The object whose assocaitors are required
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::ReferenceNames (
	BSTR pszNamespacePath,
	BSTR pszObjectName,
	BSTR pszResultClass,
	BSTR pszRole,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pszNamespacePath) || (NULL == pszObjectName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{
			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Perform the query
				IEnumWbemClassObject *pEnum = NULL;

				BSTR bsQueryLang = SysAllocString(L"WQL");

				// Build the ASSOCIATORS OF query
				BSTR bsQuery = FormatReferencesQuery (pszObjectName, pszResultClass,
						pszRole, FALSE, FALSE, NULL);

				// RAJESHR - Use semi sync and Forward only enumerator?
				if(SUCCEEDED(hr = pService->ExecQuery (bsQueryLang, bsQuery, 0, pContext, &pEnum)))
				{
					// Ensure we have impersonation enabled
					DWORD dwAuthnLevel, dwImpLevel;
					GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

					if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
						SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

					switch(m_iHttpVersion)
					{
						// We write everything on to the prefix stream since there is no
						// chunked encoding in HTTP 1.0
						case WMI_XML_HTTP_VERSION_1_0:
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
							// Now do the translation
							MapEnumNames (m_pPrefixStream, pEnum, 3, pFlagsContext);
							WRITEBSTR(m_pPrefixStream, L"</IRETURNVALUE>");
						}
						break;
						case WMI_XML_HTTP_VERSION_1_1:
						{
							// Create a stream
							IStream *pStream = NULL;
							if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
							{
								// Now do the translation
								if (SUCCEEDED(MapEnumNames (pStream, pEnum, 3, pFlagsContext)))
								{
									// First Write an IRETURNVALUE to the Prefix Stream
									WRITEBSTR(m_pPrefixStream, L"<IRETURNVALUE>");
									WRITEBSTR(pStream, L"</IRETURNVALUE>");

									// Write the translation to the IIS Socket
									SavePrefixAndBodyToIISSocket(m_pPrefixStream, pStream, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);
								}
								pStream->Release ();
							}
						}
						break;
					}
					pEnum->Release ();
				}
				SysFreeString (bsQueryLang);
				SysFreeString (bsQuery);
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr) && m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);
	return hr;
}

HRESULT CXMLTranslator::ExecuteMethod (
	BSTR pszNamespacePath,
	BSTR pszObjPath,
	BSTR pszMethodName,
	BOOLEAN isStaticMethod,
	CParameterMap *pParameterMap,
	LPEXTENSION_CONTROL_BLOCK pECB,
	IWbemContext *pFlagsContext
)
{
	// In case of HTTP 1.1, We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1)
		SavePrefixAndBodyToIISSocket(m_pPrefixStream, NULL, pECB, TRUE);

	HRESULT hr = WBEM_E_FAILED;

	if ( (NULL == pszNamespacePath) || (NULL == pszObjPath) || (NULL == pszMethodName))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Connect to the requested namespace
		IWbemServices	*pService = NULL;

		if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
		{

			// Create an IWbemContext Object if the client is WMI
			IWbemContext *pContext = NULL;
			if(m_pContext)
				hr = CXmlToWmi::MapContextObject(m_pContext, &pContext);

			if(SUCCEEDED(hr))
			{
				// Get the class to get at the method definition
				IWbemClassObject *pClass = NULL;
				IWbemClassObject *pInstance = NULL;
				if(isStaticMethod)
				{
					hr = pService->GetObject(pszObjPath, 0, 0, &pClass, NULL);
				}
				else
				{
					if(SUCCEEDED(hr = pService->GetObject(pszObjPath, 0, 0, &pInstance, NULL)))
					{
						// Get the __CLASS property
						BSTR strClassProp = NULL;
						if(strClassProp = SysAllocString(L"__CLASS"))
						{
							VARIANT classNameVariant;
							VariantInit(&classNameVariant);
							if(SUCCEEDED(hr = pInstance->Get(strClassProp, 0, &classNameVariant, NULL, NULL)))
							{
								hr = pService->GetObject(classNameVariant.bstrVal, 0, 0, &pClass, NULL);
								VariantClear(&classNameVariant);
							}
							SysFreeString(strClassProp);
						}
						else
							hr = E_OUTOFMEMORY;
					}
				}

				// Now we have the class definition. Get the Method definition
				if(SUCCEEDED(hr))
				{
					IWbemClassObject *pInSignature = NULL;
					if(SUCCEEDED(hr = pClass->GetMethod(pszMethodName, 0, &pInSignature, NULL)))
					{
						// Form an instance for the input parameters
						IWbemClassObject *pMethodParameters = NULL;
						if(SUCCEEDED(hr = FormMethodParameters(pszNamespacePath, pInSignature, pParameterMap, &pMethodParameters)))
						{
							IWbemClassObject *pOutputParameters= NULL;
							if(SUCCEEDED(hr = pService->ExecMethod(pszObjPath, pszMethodName, 0, pContext, pMethodParameters, &pOutputParameters, NULL)))
							{
								// We dont use chunked encoding for ExecMethod responses
								// Instead we write everything to the prefix stream for HTTP1.0 or the Suffix stream for HTTP 1.1
								// Create the convertor
								IWbemXMLConvertor *pConvertor = NULL;
								if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
								{
									// Now do the translation
									if (SUCCEEDED(hr = pConvertor->MapMethodResultToXML(pOutputParameters, pFlagsContext, 
										(m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1) ? m_pSuffixStream : m_pPrefixStream)))
									{
									}
									pConvertor->Release();
								}
								pOutputParameters->Release();
							}
							pMethodParameters->Release();
						}
						pInSignature->Release();
					}
				}

				// Release the instance and class associated with this method
				if(pClass)
					pClass->Release();
				if(pInstance)
					pInstance->Release();
			}

			// Release the IWbemContext object, if any
			if(pContext)
				pContext->Release();
			pService->Release();
		}
	}
	return hr;
}

// Take the paramters from the input map and fill them into the IWbemClassObject
HRESULT CXMLTranslator::FormMethodParameters(
			BSTR pszNamespacePath,
			IWbemClassObject *pInSignature, 
			CParameterMap *pParameterMap, 
			IWbemClassObject **ppMethodParameters)
{
	HRESULT hr = WBEM_E_FAILED;
	*ppMethodParameters = NULL;
	if(SUCCEEDED(hr = pInSignature->SpawnInstance(0, ppMethodParameters)))
	{
		if(SUCCEEDED(hr = pInSignature->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
		{
			BSTR strName = NULL;
			VARIANT variant;
			VariantInit(&variant);
			CIMTYPE cimType;
			while(SUCCEEDED(hr = pInSignature->Next(0, &strName, &variant, &cimType, NULL)) && hr != WBEM_S_NO_MORE_DATA)
			{
				// Get the property from the property map
				// We get one of (VALUE|VALUE.REFERENCE|VALUE.ARRAY|VALUE.REFARRAY|VALUE.OBJECT|VALUE.OBJECTARRAY)
				// in pPropertyValue
				IXMLDOMNode *pPropertyValue = NULL;
				if(pParameterMap->Lookup(strName, pPropertyValue))
				{
					// Map the parameter value to the property value
					switch(cimType)
					{
						case CIM_SINT8:
						case CIM_UINT8:
						case CIM_SINT16:
						case CIM_UINT16:
						case CIM_UINT32:
						case CIM_SINT32:
						case CIM_REAL32:
						case CIM_REAL64:
						case CIM_BOOLEAN:
						case CIM_STRING:
						case CIM_DATETIME:
						{
							BSTR strPropertyValue = NULL;
							if(SUCCEEDED(pPropertyValue->get_text(&strPropertyValue)))
							{
								hr = CXmlToWmi::MapStringValue(strPropertyValue, variant, cimType);
								SysFreeString(strPropertyValue);
							}
						}
						break;
						case CIM_SINT8|CIM_FLAG_ARRAY:
						case CIM_UINT8|CIM_FLAG_ARRAY:
						case CIM_SINT16|CIM_FLAG_ARRAY:
						case CIM_UINT16|CIM_FLAG_ARRAY:
						case CIM_UINT32|CIM_FLAG_ARRAY:
						case CIM_SINT32|CIM_FLAG_ARRAY:
						case CIM_REAL32|CIM_FLAG_ARRAY:
						case CIM_REAL64|CIM_FLAG_ARRAY:
						case CIM_BOOLEAN|CIM_FLAG_ARRAY:
						case CIM_STRING|CIM_FLAG_ARRAY:
						case CIM_DATETIME|CIM_FLAG_ARRAY:
							hr = CXmlToWmi::MapStringArrayValue(pPropertyValue, variant, cimType);
							break;
						case CIM_REFERENCE:
							hr = CXmlToWmi::MapReferenceValue(pPropertyValue, variant);
							break;
						case CIM_REFERENCE|CIM_FLAG_ARRAY:
							hr = CXmlToWmi::MapReferenceArrayValue(pPropertyValue, variant);
							break;
						case CIM_OBJECT:
						case CIM_OBJECT|CIM_FLAG_ARRAY:
						{
							// Ugh - these types require us to connect to Cimom to fetch the class of the embedded object
							// Connect to the requested namespace
							IWbemServices	*pService = NULL;
							if (SUCCEEDED (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
							{
								CXmlToWmi xmlToWmi;
								if(SUCCEEDED(hr = xmlToWmi.Initialize(NULL, pService, NULL)))
								{
									if(cimType == CIM_OBJECT)
										hr = xmlToWmi.MapObjectValue(pPropertyValue, variant);
									else
										hr = xmlToWmi.MapObjectArrayValue(pPropertyValue, variant);
								}
								pService->Release();
							}
						}
						break;
					}

					if(SUCCEEDED(hr))
						hr = (*ppMethodParameters)->Put(strName, 0, &variant, NULL);

					// No Need to delete/release the result of the call to LookUp()
					// since we're only using pointers
				}
				VariantClear(&variant);
				SysFreeString(strName);
			}
			pInSignature->EndEnumeration();
		}
	}

	if(FAILED(hr))
	{
		if(*ppMethodParameters)
			(*ppMethodParameters)->Release();
	}
	return hr;
}


WCHAR *BuildPropertyList (DWORD dwNumProperties, BSTR *pPropertyArray)
{
	WCHAR *pstrPropertyList = NULL;
	DWORD dwTotalMemory = 0;

	// Go thru the list and collect the amount of memory required for converting
	// this list of property names into a comma-separated list (one for the comma)
	for (DWORD i = 0; i < dwNumProperties; i++)
		dwTotalMemory += wcslen(pPropertyArray [i]);

	if (dwTotalMemory)
	{
		if(pstrPropertyList = new WCHAR[dwTotalMemory + dwNumProperties])
		{
			pstrPropertyList [0] = NULL;
			for(i=0; i<dwNumProperties; i++)
			{
				wcscat(pstrPropertyList, pPropertyArray[i]);
				if(i != dwNumProperties-1)
					wcscat(pstrPropertyList, L",");
			}
		}
	}

	return pstrPropertyList;
}


//***************************************************************************
//
//  BSTR FormatAssociatorsQuery
//
//  Description:
//
//  Takes the parameters to an AssociatorsOf call and constructs a WQL
//	query string from them.
//
//  Returns:	The constructed WQL query; this must be freed using
//				SysFreeString by the caller.
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

BSTR FormatAssociatorsQuery
(
	BSTR strObjectPath,
	BSTR strAssocClass,
	BSTR strResultClass,
	BSTR strResultRole,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredAssocQualifier,
	BSTR strRequiredQualifier
)
{
	BSTR bsQuery = NULL;

	// Get the length of the string:
	//  associators of {SourceObject} where
	//  AssocClass = AssocClassName
	//  ClassDefsOnly
	//  SchemaOnly
	//  RequiredAssocQualifier = QualifierName
	//  RequiredQualifier = QualifierName
	//  ResultClass = ClassName
	//  ResultRole = PropertyName
	//  Role = PropertyName

	long queryLength = 1; // Terminating NULL
	queryLength += wcslen (WMIXML_QUERY_ASSOCOF) +
				   wcslen (WMIXML_QUERY_OPENBRACE) +
				   wcslen (WMIXML_QUERY_CLOSEBRACE) +
				   wcslen (strObjectPath);

	BOOL needWhere = FALSE;

	if ((strAssocClass && (0 < wcslen (strAssocClass))) ||
		(strResultClass && (0 < wcslen (strResultClass))) ||
		(strResultRole && (0 < wcslen (strResultRole))) ||
		(strRole && (0 < wcslen (strRole))) ||
		(VARIANT_FALSE != bClassesOnly) ||
		(VARIANT_FALSE != bSchemaOnly) ||
		(strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier))) ||
		(strRequiredQualifier && (0 < wcslen (strRequiredQualifier))))
	{
		needWhere = TRUE;
		queryLength += wcslen (WMIXML_QUERY_WHERE);
	}

	if (strAssocClass && (0 < wcslen (strAssocClass)))
		queryLength += wcslen (WMIXML_QUERY_ASSOCCLASS) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strAssocClass);

	if (strResultClass && (0 < wcslen (strResultClass)))
		queryLength += wcslen (WMIXML_QUERY_RESCLASS) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strResultClass);

	if (strResultRole && (0 < wcslen (strResultRole)))
		queryLength += wcslen (WMIXML_QUERY_RESROLE) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strResultRole);

	if (strRole && (0 < wcslen (strRole)))
		queryLength += wcslen (WMIXML_QUERY_ROLE) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strRole);

	if (VARIANT_FALSE != bClassesOnly)
		queryLength += wcslen (WMIXML_QUERY_CLASSDEFS);

	if (VARIANT_FALSE != bSchemaOnly)
		queryLength += wcslen (WMIXML_QUERY_SCHEMAONLY);

	if (strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier)))
		queryLength += wcslen (WMIXML_QUERY_REQASSOCQ) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strRequiredAssocQualifier);

	if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		queryLength += wcslen (WMIXML_QUERY_REQQUAL) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strRequiredQualifier);

	// Allocate the string and fill it in
	bsQuery = SysAllocStringLen (WMIXML_QUERY_ASSOCOF, queryLength);
	wcscat (bsQuery, WMIXML_QUERY_OPENBRACE);
	wcscat (bsQuery, strObjectPath);
	wcscat (bsQuery, WMIXML_QUERY_CLOSEBRACE);

	if (needWhere)
	{
		wcscat (bsQuery, WMIXML_QUERY_WHERE);

		if (strAssocClass && (0 < wcslen (strAssocClass)))
		{
			wcscat (bsQuery, WMIXML_QUERY_ASSOCCLASS);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strAssocClass);
		}

		if (strResultClass && (0 < wcslen (strResultClass)))
		{
			wcscat (bsQuery, WMIXML_QUERY_RESCLASS);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strResultClass);
		}

		if (strResultRole && (0 < wcslen (strResultRole)))
		{
			wcscat (bsQuery, WMIXML_QUERY_RESROLE);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strResultRole);
		}

		if (strRole && (0 < wcslen (strRole)))
		{
			wcscat (bsQuery, WMIXML_QUERY_ROLE);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strRole);
		}

		if (VARIANT_FALSE != bClassesOnly)
			wcscat (bsQuery, WMIXML_QUERY_CLASSDEFS);

		if (VARIANT_FALSE != bSchemaOnly)
			wcscat (bsQuery, WMIXML_QUERY_SCHEMAONLY);

		if (strRequiredAssocQualifier && (0 < wcslen (strRequiredAssocQualifier)))
		{
			wcscat (bsQuery, WMIXML_QUERY_REQASSOCQ);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredAssocQualifier);
		}

		if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		{
			wcscat (bsQuery, WMIXML_QUERY_REQQUAL);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredQualifier);
		}
	}


	return bsQuery;
}


//***************************************************************************
//
//  BSTR FormatReferencesQuery
//
//  Description:
//
//  Takes the parameters to an ReferencesOf call and constructs a WQL
//	query string from them.
//
//  Returns:	The constructed WQL query; this must be freed using
//				SysFreeString by the caller.
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

BSTR FormatReferencesQuery
(
	BSTR strObjectPath,
	BSTR strResultClass,
	BSTR strRole,
	VARIANT_BOOL bClassesOnly,
	VARIANT_BOOL bSchemaOnly,
	BSTR strRequiredQualifier
)
{
	BSTR bsQuery = NULL;

	// Get the length of the string:
	//  references of {SourceObject} where
	//  ClassDefsOnly
	//  SchemaOnly
	//  RequiredQualifier = QualifierName
	//  ResultClass = ClassName
	//  Role = PropertyName
	long queryLength = 1; // Terminating NULL
	queryLength += wcslen (WMIXML_QUERY_REFOF) +
				   wcslen (WMIXML_QUERY_OPENBRACE) +
				   wcslen (WMIXML_QUERY_CLOSEBRACE) +
				   wcslen (strObjectPath);

	BOOL needWhere = FALSE;

	if ((strResultClass && (0 < wcslen (strResultClass))) ||
		(strRole && (0 < wcslen (strRole))) ||
		(VARIANT_FALSE != bClassesOnly) ||
		(VARIANT_FALSE != bSchemaOnly) ||
		(strRequiredQualifier && (0 < wcslen (strRequiredQualifier))))
	{
		needWhere = TRUE;
		queryLength += wcslen (WMIXML_QUERY_WHERE);
	}

	if (strResultClass && (0 < wcslen (strResultClass)))
		queryLength += wcslen (WMIXML_QUERY_RESCLASS) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strResultClass);

	if (strRole && (0 < wcslen (strRole)))
		queryLength += wcslen (WMIXML_QUERY_ROLE) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strRole);

	if (VARIANT_FALSE != bClassesOnly)
		queryLength += wcslen (WMIXML_QUERY_CLASSDEFS);

	if (VARIANT_FALSE != bSchemaOnly)
		queryLength += wcslen (WMIXML_QUERY_SCHEMAONLY);

	if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		queryLength += wcslen (WMIXML_QUERY_REQQUAL) +
					   wcslen (WMIXML_QUERY_EQUALS) +
					   wcslen (strRequiredQualifier);

	// Allocate the string and fill it in
	bsQuery = SysAllocStringLen (WMIXML_QUERY_REFOF, queryLength);
	wcscat (bsQuery, WMIXML_QUERY_OPENBRACE);
	wcscat (bsQuery, strObjectPath);
	wcscat (bsQuery, WMIXML_QUERY_CLOSEBRACE);

	if (needWhere)
	{
		wcscat (bsQuery, WMIXML_QUERY_WHERE);

		if (strResultClass && (0 < wcslen (strResultClass)))
		{
			wcscat (bsQuery, WMIXML_QUERY_RESCLASS);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strResultClass);
		}

		if (strRole && (0 < wcslen (strRole)))
		{
			wcscat (bsQuery, WMIXML_QUERY_ROLE);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strRole);
		}

		if (VARIANT_FALSE != bClassesOnly)
			wcscat (bsQuery, WMIXML_QUERY_CLASSDEFS);

		if (VARIANT_FALSE != bSchemaOnly)
			wcscat (bsQuery, WMIXML_QUERY_SCHEMAONLY);

		if (strRequiredQualifier && (0 < wcslen (strRequiredQualifier)))
		{
			wcscat (bsQuery, WMIXML_QUERY_REQQUAL);
			wcscat (bsQuery, WMIXML_QUERY_EQUALS);
			wcscat (bsQuery, strRequiredQualifier);
		}
	}

	return bsQuery;
}

BOOL CXMLTranslator::TransformQuery (BSTR *pbsQueryString) // , bool &bGenusAdded, bool&bClassAdded)
{
	return FALSE;

	/*
	bGenusAdded = true;
	bClassAdded = true;

	BOOL result = FALSE;

	// The problem we're facing here is the case where projected queries are used
	// In this case, what happens is that the projection list might be missing one of the 
	// following system properties that are required by us for generating VALUE.OBJECTs:
	//  __GENUS : We need this to decide whether to generate CLASS or INSTANCE tag
	// __CLASS : We need this for the NAME attribute of a CLASS or INSTANCE
	// __SUPERCLASS : We need this for a CLASS tag. But it is not mandatory
	// If we are doing a select, make sure we add in __CLASS, __GENUS and __SUPERCLASS
	// However, we also face the problem, that these might or might not have been present in the 
	// list of properties in the projection. If they were present, then we're fine. Otherwise,
	// we need to remove them in the final conversion to XML
    IWbemQuery *pQuery = NULL;
    HRESULT hr = CoCreateInstance(CLSID_WbemQuery, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemQuery, (LPVOID *) &pQuery);
	if(SUCCEEDED(hr))
	{
		// Parse it to get the properties in the projection list
		if(SUCCEEDED(hr = pQuery->SetLanguageFeatures(0, sizeof(uFeatures)/sizeof(ULONG), uFeatures)))
		{
			if(SUCCEEDED(hr = pQuery->Parse(L"SQL", *pbsQueryString, 0)))
			{
				SWbemRpnEncodedQuery *pRpn = NULL;
				if(SUCCEEDED(hr = pQuery->GetAnalysis(
					WMIQ_ANALYSIS_RPN_SEQUENCE,
					0,
					(LPVOID *) &pRpn
					)))
				{
					// Go thru the list, looking for __GENUS and __CLASS
					for(ULONG i=0; i<pRpn->m_uSelectListSize; i++)
					{
						SWbemQueryQualifiedName *p = pRpn->m_ppSelectList[i];
						if(_wcsicmp(p->m_ppszNameList[0], L"*") == 0)
						{
							bClassAdded = false;
							bGenusAdded = false;
							break;
						}
						else if(_wcsicmp(p->m_ppszNameList[0], L"__GENUS") == 0)
							bGenusAdded = false;
						else if(_wcsicmp(p->m_ppszNameList[0], L"__CLASS") == 0)
							bClassAdded = false;
					}
					pQuery->FreeMemory(pRpn);
				}

			}
		}
		pQuery->Release();
	}

	// Now we know whether __GENUS and __CLASS occured.
	if(bGenusAdded && bClassAdded)
		result = AddClause(L"select __GENUS, __CLASS, ");
	else if(bGenusAdded)
		result = AddClause(L"select __GENUS, ");
	else if(bClassAdded)
		result = AddClause(L"select __CLASS, ");

	return result;
	*/
}

BOOL AddClause(BSTR *pbsQueryString, LPCWSTR pszClause)
{
	BOOL result = FALSE;
	// RAJESHR - We're currently Hand-inserting clauses into the query. 
	// We should be really having an Unparse() in Core team's Query parser
	int i = 0;
	int len = wcslen (*pbsQueryString);

	// Move to the first space past the "select" token
	while ((i < len) && iswspace ((*pbsQueryString) [i]))
		i++;

	// See if the token was really "select"
	if ((i < len) && (0 == _wcsnicmp (L"select", &((*pbsQueryString) [i]), wcslen(L"select"))))
	{
		i += wcslen (L"select");

		// Move past the white spaces after "select"
		while ((i < len) && iswspace ((*pbsQueryString) [i]))
			i++;

		// Need to add in the system properties
		WCHAR *pNewQuery = NULL;
		if(pNewQuery = new WCHAR [wcslen (&((*pbsQueryString) [i])) +
					wcslen (pszClause) + 1])
		{
			wcscpy (pNewQuery, pszClause);
			wcscat (pNewQuery, &((*pbsQueryString) [i]));
			*pbsQueryString = NULL;
			if(*pbsQueryString = SysAllocString (pNewQuery))
				result = TRUE;
			delete [] pNewQuery;
		}
	}
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\wmcomm.h ===
/*
 -	WMCOMM.H
 -
 *
 */

// Default Codepage

/*
 -	CAcceptHeaderIterator
 -
 *	Purpose:
 *		Iterator for any Accept-* header. 
 *
 *	The class should be initialized with an accept-* header 
 *	(the format of the accept-* string is specified in HTTP 1.1 RFC.)
 *
 *	This class sorts the tokens based the quality factors specified
 *	in the header. 
 *
 *  The caller can call ScGetNextToken() to get the next token. The class
 *	returns ERROR_NO_DATA when there is no data to return.
 *
 *
 */

class CAcceptHeaderIterator
{
	protected:

		// Defn. of the Structure that contains pointer to each token in
		// the accept-* header
		//
		typedef struct _TokenInfo
		{
			LPSTR	pszToken;
			double	dbQuality;
		} 
		TOKENINFO;

		// Pointer to a copy of the given accept header
		//
		CHAR 		*m_pszAcceptHeader;

		// Array of token info structures
		//
		TOKENINFO					*m_pti;
		DWORD						m_ctiMax;
		DWORD						m_ctiUsed;

		// Flag to indicate if wild card is specified in accept header
		//
		BOOL						m_fWildCardPresent;
		
		// Current token index. (-1 is invalid/uninitialized value)
		//
		DWORD							m_itiCurrent;

		// Flag to indicate if we exhausted the list.
		//
		BOOL						m_fIterationCompleted;
		
		// Helper routines
		//
		HRESULT 						ScInsert(
											TOKENINFO *pti);
											
		HRESULT						ScGetTokenQFactor(	
											LPSTR 		pszToken,
											BOOL	 *	pfWildCard,
											TOKENINFO *	pti);

		// Advance the iterator to the next token. Override this function
		// if the derived class needs to advance the iterator differently.
		//
		virtual HRESULT				ScAdvance();

		//	NOT IMPLEMENTED
		//
		CAcceptHeaderIterator (const CAcceptHeaderIterator&);
		CAcceptHeaderIterator& operator= (const CAcceptHeaderIterator&);
		
	public:

		CAcceptHeaderIterator()
		{
			m_ctiMax = 0;
			m_ctiUsed = 0;
			m_fWildCardPresent = FALSE;
			m_fIterationCompleted = FALSE;
			m_itiCurrent = 0; 	// -1 indicates it is unitialized

		}
		
		~CAcceptHeaderIterator()
		{}

		// Initialize the object with a Accept-* header. This class doesnt take
		// ownership of the string.
		//
		HRESULT 	ScInit(LPCSTR pszAcceptHeader);

		// Get the next accept token
		//
		HRESULT	ScGetNextAcceptToken(LPCSTR *	ppszToken,
										double *	pdbQuality);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\idl\proxy\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\wmcomm.cpp ===
/*
 -	WMCOMM.CPP
 -
 *	Purpose:
 *		WebClient Common IIS/Store Utility Functions
 *
 *	Copyright (C) 1997-1999 Microsoft Corporation
 *
 *	References:
 *
 *
 *	[Date]		[email]		[Comment]
 *	11/22/99	wardb		Creation.
 *
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "wmcomm.h"


/*
 -	CAcceptHeaderIterator::ScInit
 -
 *	Purpose:
 *		Initializes the object with the Accept-language header.
 *	The header should conform to the specifications in HTTP 1.1 RFC.
 *
 */

HRESULT
CAcceptHeaderIterator::ScInit(LPCSTR pszAcceptHeader)
{

	HRESULT 	sc 				= S_OK;
	LPSTR	pszAcceptToken	= NULL;
	LPSTR	pszT 			= NULL;
	DWORD	cbLen			= 0;

	if (!pszAcceptHeader || !*pszAcceptHeader)
	{
		// if there is no accept header, treat the header
		// as a wildcard. (HTTP 1.1 RFC)
		//
		m_fWildCardPresent = TRUE;
		goto Exit;
	}

	// Make a local copy of the header
	//
	cbLen = strlen(pszAcceptHeader) + 1;
	m_pszAcceptHeader = new CHAR[cbLen];
	if (m_pszAcceptHeader == NULL)
	{
		sc = E_OUTOFMEMORY;
		goto Exit;
	}
	strcpy(m_pszAcceptHeader, pszAcceptHeader);

	// 	Findout number of accept tokens we have. "," is the	delimiter.
	//  Comma is the separator (not terminator) according to the RFC, so start
	//  counting from 1.
	//
	m_ctiMax = 1;
	for (pszT = m_pszAcceptHeader; *pszT; pszT++)
	{
		if (*pszT == ',') m_ctiMax++;
	}

	// Allocate the memory for lang info
	//
	m_pti = new TOKENINFO[m_ctiMax];
	if (!m_pti)
	{
		sc = E_OUTOFMEMORY;
		goto Exit;
	}
	memset(m_pti, 0, sizeof(TOKENINFO) * m_ctiMax);

	// Parse and sort the tokens correctly.
	//
	m_ctiUsed = 0;
	pszAcceptToken = strtok(m_pszAcceptHeader, ",");
	while (pszAcceptToken)
	{
		TOKENINFO 	ti = {0};
		BOOL		fWildCard = FALSE;

		// if we fail to get token and Q factor, ignore the token
		//
		if (SUCCEEDED(ScGetTokenQFactor(	pszAcceptToken,
											&fWildCard,
											&ti)))
		{
			if (!fWildCard)
			{
				// Not a wild card. Insert it in our array
				//
				sc = ScInsert(&ti);
				if (FAILED(sc))
					goto Exit;
			}
			else
			{
				// If it is a wild card, set a flag
				//
				m_fWildCardPresent = TRUE;
			}
		}

		// Get the next token from the header
		//
		pszAcceptToken = strtok(NULL, ",");
	}

Exit:
	return(sc);
}

/*
 -	CAcceptHeaderIterator::ScGetTokenQFactor
 -
 *	Purpose:
 *		Parses the accept token string with the quality factor and
 *	returns the values in TOKENINFO structure. If the quality
 *	factor is not present, then the q factor is assumed as 1.0
 *	if the quality factor is either <= 0.0 or greater than 1.0
 *	an error value is returned.
 *
 */

HRESULT
CAcceptHeaderIterator::ScGetTokenQFactor(	LPSTR 		pszAcceptToken,
											BOOL	 *	pfWildCard,
											TOKENINFO *	pti)
{
	HRESULT 	sc = S_OK;

	LPSTR	pszAcceptTokenEnd = NULL;
	LPSTR	pszAcceptTokenStart = NULL;
	LPSTR	pszQuality = NULL;
	double 	dbQuality = 0;

	// Findout the accept token end;
	//
	pszAcceptTokenStart 	= pszAcceptToken;
	pszAcceptTokenEnd 		= strchr(pszAcceptTokenStart, ';');
	if (pszAcceptTokenEnd)
	{
		// We have quality factor -- Terminate the token string where
		// the quality string starts.
		//
		*pszAcceptTokenEnd = '\0';
		pszQuality = pszAcceptTokenEnd + 1;
	}
	else
	{
		// No Quality factor -- Set the accept token end to point to the end of
		// the string.
		pszQuality = NULL;
		pszAcceptTokenEnd =  pszAcceptTokenStart + strlen(pszAcceptTokenStart);
	}

	// Find out the quality param
	//
	dbQuality = 1.0;
	if (pszQuality && *pszQuality)
	{
		// The syntax for quality parameter is:  "q=0.5"
		//
		while (*pszQuality && isspace(*pszQuality)) pszQuality++;
		if (*pszQuality != 'q')
			goto ErrorInvalidArg;

		pszQuality++;	// go past the 'q'

		while (*pszQuality && isspace(*pszQuality)) pszQuality++;
		if (*pszQuality != '=')
			goto ErrorInvalidArg;

		pszQuality++;	// move past the '=' sign.
		dbQuality = atof(pszQuality);

		if (dbQuality > 1.0 || dbQuality <= 0.0)
		{
			// If the Q value is not one of the legal values, just ignore.
			// Ignore the token if the Q value is 0.0 (as per the RFC)
			//
			goto ErrorInvalidArg;
		}
	}

	// Normalize accept tokens -- remove leading and trailing white spaces
	//
	while (*pszAcceptTokenStart && isspace(*pszAcceptTokenStart))
	{
		pszAcceptTokenStart++;
	}
	if (!*pszAcceptTokenStart)
	{
		// Accept token is empty
		//
		goto ErrorInvalidArg;
	}
	while (pszAcceptTokenEnd > pszAcceptTokenStart &&
			isspace(*(pszAcceptTokenEnd - 1)))
	{
		pszAcceptTokenEnd--;
	}
	*pszAcceptTokenEnd = '\0';

	// Check if it is a wild card string
	//
	*pfWildCard = (strcmp(pszAcceptTokenStart,"*") == 0);

	// Initialize the token info structure
	//
	pti->dbQuality 		= dbQuality;
	pti->pszToken 		= pszAcceptTokenStart;

Exit:
	return sc;

ErrorInvalidArg:
	sc = E_INVALIDARG;
	goto Exit;
}

/*
 -	CAcceptHeaderIterator::ScInsert
 -
 *	Purpose:
 *		Insert the tokeninfo in correct order (based on the
 *	quality factor). If two tokens have same quality factors, then their
 *	order in which they were added will be preserved.
 *
 */

HRESULT
CAcceptHeaderIterator::ScInsert(TOKENINFO * ptiCurrent)
{
	// Insert the accept token in correct order of qvalue (quality)
	//
	HRESULT		sc 		 	= S_OK;
	DWORD 		iCurLang 	= m_ctiUsed;

	while (	iCurLang > 0 &&
			 ptiCurrent->dbQuality > m_pti[iCurLang - 1].dbQuality)
	{
		iCurLang--;
	}

	if (iCurLang != m_ctiUsed)
	{
		memmove(	&m_pti[iCurLang+1],
					&m_pti[iCurLang],
					(m_ctiUsed - iCurLang) * sizeof(TOKENINFO));
	}

	m_pti[iCurLang] = *ptiCurrent;
	m_ctiUsed++;

	return sc;
}

/*
 -	CAcceptHeaderIterator::ScGetNextAcceptToken
 -
 *	Purpose:
 *		Returns the next non-null accept-token from the list. If the
 *	string is a wild card, then the wildcard flag will be set to true and
 *	the accept token is set to NULL.
 *
 */
HRESULT
CAcceptHeaderIterator::ScGetNextAcceptToken(	LPCSTR *	ppszAcceptToken,
												double *	pdbQuality)
{
	HRESULT sc = S_OK;

	*ppszAcceptToken 	= NULL;
	*pdbQuality = 0;

	// If we dont have any more tokens or wild cards to return
	// return an error back.
	//
	if (m_fIterationCompleted)
	{
		sc = HRESULT_FROM_WIN32(ERROR_NO_DATA);
	}
	else
	{
		// Advance our accept token pointer
		//
		sc = ScAdvance();
		if (SUCCEEDED(sc))
		{
			*ppszAcceptToken = m_pti[m_itiCurrent].pszToken;
			*pdbQuality = m_pti[m_itiCurrent].dbQuality;
		}
		else
		{
			// ScAdvance failed -- No more accept tokens
			// If the header has a wild-card char send it.
			//
			m_fIterationCompleted = TRUE;
		}
	}

	return sc;
}

/*
 -	CAcceptHeaderIterator::ScAdvance
 -
 *	Purpose:
 *		Advance the iterator to the next token. Override this function
 *	if we want to advance the iterator differently.
 *
 */

HRESULT
CAcceptHeaderIterator::ScAdvance()
{
	HRESULT	sc 			= S_OK;

	// Assert(m_ctiUsed <= m_ctiMax);

	if (!m_ctiUsed || m_itiCurrent>=m_ctiUsed)
	{
		// List is empty or the current pointer is at the end.
		//
		sc = HRESULT_FROM_WIN32(ERROR_NO_DATA);
		goto Exit;
	}

	m_itiCurrent++;

Exit:
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\whistler.cpp ===
#ifdef WMI_XML_WHISTLER


#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <httpext.h>
#include <msxml.h>
#include <time.h>
#include "wbemcli.h"

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <cominit.h>

#include "provtempl.h"
#include "common.h"
#include "wmixmlop.h"
#include "wmixmlst.h"
#include "concache.h"
#include "maindll.h"
#include "strings.h"
#include "cimerr.h"
#include "errors.h"
#include "wmiconv.h"
#include "xmlhelp.h"
#include "xml2wmi.h"
#include "wmixmlt.h"
#include "request.h"
#include "whistler.h"
#include "strings.h"
#include "parse.h"

#ifdef WMIXMLTRANSACT

// Declaration for class-static variable
CTransactionGUIDTable CCimWhistlerHttpMethod::s_oTransactionTable;

// Checks if the transaction table is empty
HRESULT CCimWhistlerHttpMethod::IsTransactionTableEmpty()
{
	HRESULT result = S_FALSE;
	EnterCriticalSection(&g_TransactionTableSection);
	if(s_oTransactionTable.GetCount() == 0)
		result = S_OK;
	LeaveCriticalSection(&g_TransactionTableSection);
	return result;
}

// Adds an IWbemTransaction corresponding to a GUID to the transaction table
HRESULT CCimWhistlerHttpMethod::AddToTransactionTable(GUID *pGUID, CServicesTransaction *pTrans)
{
	EnterCriticalSection(&g_TransactionTableSection);
	s_oTransactionTable.SetAt(pGUID, pTrans);
	pTrans->AddRef();
	LeaveCriticalSection(&g_TransactionTableSection);
	return S_OK;
}

// Gets an CServicesTransaction corresponding to a GUID to the transaction table
// The caller should call Release on the IWbemTransaction the he gets, when done
CServicesTransaction *CCimWhistlerHttpMethod::GetFromTransactionTable(GUID *pGUID)
{
	CServicesTransaction *pTrans = NULL;
	EnterCriticalSection(&g_TransactionTableSection);
	if( s_oTransactionTable.Lookup(pGUID, pTrans) && pTrans)
		pTrans->AddRef();
	LeaveCriticalSection(&g_TransactionTableSection);
	return pTrans;
}


// Removes an CServicesTransaction corresponding to a GUID to the transaction table
// and deletes it
HRESULT CCimWhistlerHttpMethod::RemoveFromTransactionTable(GUID *pGUID)
{
	HRESULT hr = E_FAIL;
	EnterCriticalSection(&g_TransactionTableSection);
	// First check to see if it exists
	// RAJESHR How do we ensure that the BSTR is SysFreeed when an element is removed
	CServicesTransaction *pTrans = NULL;
	if(s_oTransactionTable.Lookup(pGUID, pTrans) && pTrans)
	{
		s_oTransactionTable.RemoveKey(pGUID);
		pTrans->Release();
		hr = S_OK;
	}
	LeaveCriticalSection(&g_TransactionTableSection);
	return hr;
}

#endif

// CCimWhistlerHttpMethod
CCimWhistlerHttpMethod :: CCimWhistlerHttpMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE)
: CCimHttpMessage(strID, bIsMpostRequest)
{
	m_pIMethodCallNode = pIMethodCallNode;
	if(m_pIMethodCallNode)
		m_pIMethodCallNode->AddRef();
}

CCimWhistlerHttpMethod :: ~CCimWhistlerHttpMethod()
{
	if(m_pIMethodCallNode)
		m_pIMethodCallNode->Release();
}

void CCimWhistlerHttpMethod :: WriteMethodHeader ()
{
	WRITEWSTR(m_pHeaderStream, L"<IMETHODRESPONSE NAME=\"");
	WRITEWSTR(m_pHeaderStream, GetMethodName ());
	WRITEWSTR(m_pHeaderStream, L"\">");

}

void CCimWhistlerHttpMethod :: WriteMethodTrailer ()
{
	WRITEWSTR(m_pTrailerStream, L"</METHODRESPONSE>");
}

HRESULT CCimWhistlerHttpMethod :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;

	// All Whistler methods start off with arguments to IWbemConnection::Open() - so we parse this first
	// This gives us an IWbemConnection and possibly a IXMLDOMNode pointer for the rest of the arguments in the 
	// input packet
	IWbemServicesEx *pFirstServices = NULL;
	IXMLDOMNodeList *pServicesArgs = NULL;
	GUID tGUID; // If this is a part of a transaction, then a GUID will be present
	if(SUCCEEDED(hr = ParseOptionalGUID(m_pIMethodCallNode, &tGUID)))
	{
		if(SUCCEEDED(hr = ParseIWbemConnection(m_pIMethodCallNode, &pFirstServices, &pServicesArgs)))
		{
			// Now we need to get IWbemServicesEx pointers
			IWbemServicesEx *pNextServices = NULL;
			HRESULT hTemp = E_FAIL;
			while(SUCCEEDED(hr = ParseIWbemServices(pFirstServices, pServicesArgs, &pNextServices)) && pNextServices)
			{
				// Set the Services pointer for the next call
				pFirstServices->Release();
				pFirstServices = pNextServices;
				pNextServices = NULL;
			}

			// Talk to WinMgmt and get the response
			// Here we're passing in an IWbemServicesEx and the pointers to the actual method
			// in IWbemServicesEx
			hr = ExecuteWhistlerMethod(pPrefixStream, pSuffixStream, pECB, pFirstServices, pServicesArgs);

			pFirstServices->Release();
			pServicesArgs->Release();
		}
	}
	return hr;
}

// In this function, we expect an IMETHODCALL elment
HRESULT CCimWhistlerHttpMethod :: ParseOptionalGUID(IXMLDOMNode *pIMethodCallNode, GUID *pGUID)
{
	// If the first child to the IMETHODCALL is an IPARAMVALUE of name GUID, then 
	// this call is a part of a transaction
	IXMLDOMNode *pFirstChild = NULL;
	if(SUCCEEDED(pIMethodCallNode->get_firstChild(&pFirstChild)))
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pFirstChild->get_nodeName(&strNodeName)))
		{
			// See if it is the "GUID" argument
			if(_wcsicmp(strNodeName, L"GUID") == 0)
			{
				// The IPARAMVALUE should have a VALUE element below it
				IXMLDOMNode *pParamValue = NULL;
				if (SUCCEEDED(pFirstChild->get_firstChild (&pParamValue)) && pParamValue)
				{
					ParseGUIDArgument (pParamValue, pGUID);
					pParamValue->Release ();
				}

			}
			SysFreeString(strNodeName);
		}

		pFirstChild->Release();
	}
	return S_OK;
}

HRESULT CCimWhistlerHttpMethod :: ParseIWbemConnection(IXMLDOMNode *pIMethodCallNode, IWbemServicesEx **ppFirstServices, IXMLDOMNodeList **ppServicesArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemConnectionEx::Open function
	// We execute Open() to return an IWbemServicesEx as as out argument and also the rest of the IPARAMVALUEs under the IMETHODCALL NODE
	*ppFirstServices = NULL;
	*ppServicesArgs = NULL;

	// Collect the list of parameters for an Open Call
	// This includes strObject (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strObject = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	*ppServicesArgs = NULL;
	if(SUCCEEDED(pIMethodCallNode->get_childNodes(ppServicesArgs)))
	{
		IXMLDOMNode *pNextParam = NULL;
		while(SUCCEEDED((*ppServicesArgs)->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We process only IPARAMVALUE child nodes here
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					// Get the name of the parameter
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, L"strObject") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseBstrArgument (pParamValue, &strObject);
								pParamValue->Release ();
							}
						}
						else if(_wcsicmp(strParamName, L"lFlags") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseLongArgument (pParamValue, &lFlags);
								pParamValue->Release ();
							}
						}
						else if(_wcsicmp(strParamName, L"pCtx") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseIWbemContextArgument (pParamValue, &pCtx);
								pParamValue->Release ();
							}
						}

						SysFreeString(strParamName);
					}
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}
	}

	// Now that we have the arguments, execute the call
	IWbemConnection *pConnection = NULL;
	if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemConnection, NULL, CLSCTX_INPROC_SERVER,
																IID_IWbemConnection, (LPVOID *)&pConnection)))
	{
		hr = pConnection->Open(strObject, NULL, NULL, NULL, lFlags, pCtx, IID_IWbemServicesEx, (LPVOID *)ppFirstServices, NULL);
		pConnection->Release();
	}

	if(FAILED(hr))
		(*ppServicesArgs)->Release();

	return hr;
}

HRESULT CCimWhistlerHttpMethod :: ParseIWbemServices(IWbemServicesEx *pParentServices, IXMLDOMNodeList *&pServicesArgs, IWbemServicesEx **ppChildServices)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::Open function
	// We execute Open() to return an IWbemServicesEx as as out argument and also the rest of the IPARAMVALUEs under the IMETHODCALL NODE
	*ppChildServices = NULL;

	// Collect the list of parameters for an Open Call
	// This includes strScope (BSTR), strSelector (BSTR), lMode (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strScope = NULL;
	BSTR strSelector = NULL;
	long lMode = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pServicesArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strScope") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strScope);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"strSelector") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strSelector);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lMode") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lMode);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	hr = pParentServices->Open(strScope, strSelector, lMode, pCtx, ppChildServices, NULL);
	return hr;
}

HRESULT CCimWhistlerHttpMethod :: ParseBstrArgument(IXMLDOMNode *pNode, BSTR *pstrArgVal)
{
	// This expects a VALUE Node and gets the string underneath it as the argument value
	return pNode->get_text(pstrArgVal);
}

HRESULT CCimWhistlerHttpMethod :: ParseLongArgument(IXMLDOMNode *pNode, long *plArgVal)
{
	HRESULT hr = E_FAIL;
	BSTR strStringVal = NULL;
	if(SUCCEEDED(hr = pNode->get_text(&strStringVal)))
	{
		// Convert it to a long value
		*plArgVal = (long) wcstol (strStringVal, NULL, 0);
		SysFreeString(strStringVal);
	}
	return hr;
}

HRESULT CCimWhistlerHttpMethod :: ParseULongArgument(IXMLDOMNode *pNode, unsigned long *plArgVal)
{
	HRESULT hr = E_FAIL;
	BSTR strStringVal = NULL;
	if(SUCCEEDED(hr = pNode->get_text(&strStringVal)))
	{
		// Convert it to a long value
		*plArgVal = (unsigned long) wcstoul (strStringVal, NULL, 0);
		SysFreeString(strStringVal);
	}
	return hr;
}

// In this, we expect a VALUE element with the body containing a GUID value
HRESULT CCimWhistlerHttpMethod::ParseGUIDArgument(IXMLDOMNode *pNode, GUID *pGuid)
{
	HRESULT hr = E_FAIL;
	BSTR strGUID = NULL;
	if(SUCCEEDED(hr = pNode->get_text(&strGUID)))
	{
		// Convert it to a GUID value
		if(UuidFromString(strGUID, (UUID *)(pGuid)) == RPC_S_OK)
			hr = S_OK;
		SysFreeString(strGUID);
	}
	return hr;
}

HRESULT CCimWhistlerHttpMethod :: ParseIWbemContextArgument(IXMLDOMNode *pNode, IWbemContext **ppArgVal)
{
	return CXmlToWmi::MapContextObject(pNode, ppArgVal);
}

HRESULT CCimWhistlerGetObjectMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, 
														   IStream *pSuffixStream, 
														   LPEXTENSION_CONTROL_BLOCK pECB, 
														   IWbemServicesEx *pServices, 
														   IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::GetObject function
	// After collecting the arguments, we execute GetObject() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an GetObject Call
	// This includes strObjectPath (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strObjectPath = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strObjectPath") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strObjectPath);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	IWbemClassObject *pObject = NULL;
	if(SUCCEEDED(hr = pServices->GetObject(strObjectPath, lFlags, pCtx, &pObject, NULL)))
	{
		// Create a stream
		IStream *pStream = NULL;
		if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
		{
			// Create the convertor
			IWbemXMLConvertor *pConvertor = NULL;
			if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
			{
				if(SUCCEEDED(hr = CreateFlagsContext()))
				{
					// Now do the translation
					if(SUCCEEDED(hr = SetI4ContextValue(m_pFlagsContext, L"PathLevel", 0)))
					{
						if (SUCCEEDED(hr = pConvertor->MapObjectToXML(pObject, NULL, 0, m_pFlagsContext, pStream, NULL)))
						{
							// First Write an IRETURNVALUE to the Prefix Stream
							WRITEBSTR(pPrefixStream, L"<IRETURNVALUE>");
							WRITEBSTR(pStream, L"</IRETURNVALUE>");

							// Write the translation to the IIS Socket
							SavePrefixAndBodyToIISSocket(m_pHeaderStream, pStream, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);
						}
					}
				}
				pConvertor->Release();
			}
			pStream->Release ();
		}
		pObject->Release ();
	}

	// Release all the argument to the function
	SysFreeString(strObjectPath);
	if(pCtx)
		pCtx->Release();

	// We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr))
		SavePrefixAndBodyToIISSocket(pPrefixStream, NULL, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);

	return hr;
}

HRESULT CCimWhistlerEnumerateInstancesMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::CreateInstanceEnum function
	// After collecting the arguments, we execute GetObject() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an CreateInstanceEnum Call
	// This includes strClass (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strClass = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strClass") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strClass);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	IEnumWbemClassObject *pEnum = NULL;
	if(SUCCEEDED(hr = pServices->CreateInstanceEnum(strClass, lFlags, pCtx, &pEnum)))
	{
		// First Write an IRETURNVALUE to the Prefix Stream
		WRITEBSTR(pPrefixStream, L"<IRETURNVALUE>");
		SaveStreamToIISSocket(pPrefixStream, pECB, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
		WRITEBSTR(pSuffixStream, L"</IRETURNVALUE>");

		// Ensure we have impersonation enabled
		DWORD dwAuthnLevel, dwImpLevel;
		GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

		if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
			SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

		// Now do the translation
		// For shallow instance enumerations we have to give the class basis
		// the CWmiToXml object so it can emulate DMTF-style shallow enumeration
		if (lFlags & WBEM_FLAG_DEEP)
			MapEnum (pEnum, 1, 0, NULL, NULL, pECB, m_pFlagsContext, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
		else
			MapEnum (pEnum, 1, 0, NULL, strClass, pECB, m_pFlagsContext, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
		pEnum->Release ();
	}


	// Release all the argument to the function
	SysFreeString(strClass);
	if(pCtx)
		pCtx->Release();

	// We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr))
		SavePrefixAndBodyToIISSocket(pPrefixStream, NULL, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);

	return hr;
}

HRESULT CCimWhistlerEnumerateClassesMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::CreateClassEnum function
	// After collecting the arguments, we execute GetObject() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an CreateClassEnum Call
	// This includes strSuperclass (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strSuperclass = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strSuperclass") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strSuperclass);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	IEnumWbemClassObject *pEnum = NULL;
	if(SUCCEEDED(hr = pServices->CreateClassEnum(strSuperclass, lFlags, pCtx, &pEnum)))
	{
		// First Write an IRETURNVALUE to the Prefix Stream
		WRITEBSTR(pPrefixStream, L"<IRETURNVALUE>");
		SaveStreamToIISSocket(pPrefixStream, pECB, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
		WRITEBSTR(pSuffixStream, L"</IRETURNVALUE>");

		// Ensure we have impersonation enabled
		DWORD dwAuthnLevel, dwImpLevel;
		GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

		if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
			SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

		// Now do the translation
		MapEnum (pEnum, 1, 0, NULL, NULL, pECB, m_pFlagsContext, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
		pEnum->Release ();
	}

	// Release all the argument to the function
	SysFreeString(strSuperclass);
	if(pCtx)
		pCtx->Release();

	// We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr))
		SavePrefixAndBodyToIISSocket(pPrefixStream, NULL, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);
	return hr;
}

HRESULT CCimWhistlerExecQueryMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::ExecQuery function
	// After collecting the arguments, we execute ExecQuery() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an GetObject Call
	// This includes strQueryLanguage (BSTR), strQuery (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strQueryLanguage = NULL;
	BSTR strQuery = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strQueryLanguage") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strQueryLanguage);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"strQuery") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strQuery);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	IEnumWbemClassObject *pEnum = NULL;
	if(SUCCEEDED(hr = pServices->ExecQuery(strQueryLanguage, strQuery, lFlags, pCtx, &pEnum)))
	{
		// First Write an IRETURNVALUE to the Prefix Stream
		WRITEBSTR(pPrefixStream, L"<IRETURNVALUE>");
		SaveStreamToIISSocket(pPrefixStream, pECB, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
		WRITEBSTR(pSuffixStream, L"</IRETURNVALUE>");

		// Ensure we have impersonation enabled
		DWORD dwAuthnLevel, dwImpLevel;
		GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

		if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
			SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

		// Now do the translation
		MapEnum (pEnum, 3, 0, NULL, NULL, pECB, m_pFlagsContext, (m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1));
		pEnum->Release ();
	}

	// Release all the argument to the function
	SysFreeString(strQueryLanguage);
	SysFreeString(strQuery);
	if(pCtx)
		pCtx->Release();

	// We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr))
		SavePrefixAndBodyToIISSocket(pPrefixStream, NULL, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);

	return hr;
}
HRESULT CCimWhistlerDeleteClassMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::DeleteClass function
	// After collecting the arguments, we execute DeleteClass() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an DeleteClass Call
	// This includes strClass (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strClass = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strClass") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strClass);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	if(SUCCEEDED(hr = pServices->DeleteClass(strClass, lFlags, pCtx, NULL)))
	{
	}

	// Release all the argument to the function
	SysFreeString(strClass);
	if(pCtx)
		pCtx->Release();

	return hr;
}

HRESULT CCimWhistlerDeleteInstanceMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::DeleteInstance function
	// After collecting the arguments, we execute DeleteClass() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an DeleteClass Call
	// This includes strObjectPath (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strObjectPath = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strObjectPath") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strObjectPath);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	if(SUCCEEDED(hr = pServices->DeleteInstance(strObjectPath, lFlags, pCtx, NULL)))
	{
	}

	// Release all the argument to the function
	SysFreeString(strObjectPath);
	if(pCtx)
		pCtx->Release();

	return hr;
}

HRESULT CCimWhistlerCreateClassMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	return E_FAIL;
}

HRESULT CCimWhistlerCreateInstanceMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	return E_FAIL;
}

HRESULT CCimWhistlerAddMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::Add function
	// After collecting the arguments, we execute Add() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an GetObject Call
	// This includes strObjectPath (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strObjectPath = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strObjectPath") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strObjectPath);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	if(SUCCEEDED(hr = pServices->Add(strObjectPath, lFlags, pCtx, NULL)))
	{
	}

	// Release all the argument to the function
	SysFreeString(strObjectPath);
	if(pCtx)
		pCtx->Release();

	return hr;
}

HRESULT CCimWhistlerRemoveMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::Remove function
	// After collecting the arguments, we execute Remove() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an GetObject Call
	// This includes strObjectPath (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strObjectPath = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strObjectPath") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strObjectPath);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	if(SUCCEEDED(hr = pServices->Remove(strObjectPath, lFlags, pCtx, NULL)))
	{
	}

	// Release all the argument to the function
	SysFreeString(strObjectPath);
	if(pCtx)
		pCtx->Release();

	return hr;
}

HRESULT CCimWhistlerRenameMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::Rename function
	// After collecting the arguments, we execute Rename() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an GetObject Call
	// This includes strOldObjectPath (BSTR), strNewObjectPath (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strOldObjectPath = NULL;
	BSTR strNewObjectPath = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strOldObjectPath") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strOldObjectPath);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"strNewObjectPath") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strNewObjectPath);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	if(SUCCEEDED(hr = pServices->RenameObject(strOldObjectPath, strNewObjectPath, lFlags, pCtx, NULL)))
	{
	}

	// Release all the argument to the function
	SysFreeString(strNewObjectPath);
	SysFreeString(strOldObjectPath);
	if(pCtx)
		pCtx->Release();

	return hr;
}

#ifdef WMIOBJSECURITY

HRESULT CCimWhistlerGetObjectSecurityMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::GetObjectSecurity function
	// After collecting the arguments, we execute GetObjectSecurity() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an GetObjectSecurity Call
	// This includes strObjectPath (BSTR), lFlags (long), pCtx (IWbemContext)
	//===================================================================
	BSTR strObjectPath = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strObjectPath") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strObjectPath);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call
	IWbemRawSdAccessor *pSecurity = NULL;
	
	if(SUCCEEDED(hr = pServices->GetObjectSecurity(strObjectPath, lFlags, pCtx, IID_IWbemRawSdAccessor, (LPVOID *)&pSecurity, NULL)))
	{
		// Create a stream
		// The reason we create a new stream instead of writing into m_pPrefixStream
		// is that we dont know if the call to MapObjectToXML will be successful
		// In the case it isnt, then we cannot write the IRETURNVALUE tag
		// In the case it is, we need to write the IRETURNVALUE tag before 
		// the encoding of the object
		IStream *pStream = NULL;
		if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
		{
			// Convert the byte array to a VALUE.ARRAY element
			if (SUCCEEDED(hr = EncodeSecurity(pSecurity, pStream)))
			{
				// First Write an IRETURNVALUE to the Prefix Stream
				WRITEBSTR(pPrefixStream, L"<IRETURNVALUE>");
				WRITEBSTR(pStream, L"</IRETURNVALUE>");

				// Write the translation to the IIS Socket
				SavePrefixAndBodyToIISSocket(pPrefixStream, pStream, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);
			}
			pStream->Release ();
		}
		pSecurity->Release();
	}
	

	// Release all the argument to the function
	SysFreeString(strObjectPath);
	if(pCtx)
		pCtx->Release();

	// We have to ensure that we write thr contents of m_pPrefixStream to the socket irrespective of whether the call failed or not
	if(FAILED(hr))
		SavePrefixAndBodyToIISSocket(pPrefixStream, NULL, pECB, m_iHttpVersion == WMI_XML_HTTP_VERSION_1_1);

	return hr;
}

HRESULT CCimWhistlerPutObjectSecurityMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemServicesEx::PutObjectSecurity function
	// After collecting the arguments, we execute PutObjectSecurity() to return an IWbemClassObject as an argumetn

	// Collect the list of parameters for an PuObjectSecurity Call
	// This includes strObjectPath (BSTR), lFlags (long), pCtx (IWbemContext), pSecurityObject(VALUE.ARRAY)
	//===================================================================
	BSTR strObjectPath = NULL;
	long lFlags = 0;
	IWbemContext *pCtx = NULL;
	IWbemRawSdAccessor *pSecurity = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"strObjectPath") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseBstrArgument (pParamValue, &strObjectPath);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"lFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseLongArgument (pParamValue, &lFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pCtx") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseIWbemContextArgument (pParamValue, &pCtx);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pSecurityObject") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							DecodeSecurity (pParamValue, &pSecurity);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	
	// Now that we have the arguments, execute the call
	if(SUCCEEDED(hr = pServices->PutObjectSecurity(strObjectPath, lFlags, pCtx, IID_IWbemRawSdAccessor, pSecurity, NULL)))
	{
	}
	

	// Release all the argument to the function
	SysFreeString(strObjectPath);
	if(pCtx)
		pCtx->Release();
	if(pSecurity)
		pSecurity->Release();

	return hr;
}
#endif


#ifdef WMIXMLTRANSACT

HRESULT CCimWhistlerTransactionBeginMethod::ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemTransaction::Begin function
	// After collecting the arguments, we execute Begin() 

	// Collect the list of parameters for an Begin Call
	// This includes uTimeout (ULONG), uFlags (ULONG), pTransGUID (GUID *)
	//===================================================================
	unsigned long uTimeout = 0;
	unsigned long uFlags = 0;
	GUID TransGUID = NULL;

	IXMLDOMNode *pNextParam = NULL;
	while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
	{
		// Get its name
		BSTR strNodeName = NULL;
		if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
		{
			// We process only IPARAMVALUE child nodes here
			if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
			{
				// Get the name of the parameter
				BSTR strParamName = NULL;
				if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
				{
					if(_wcsicmp(strParamName, L"uTimeout") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseULongArgument (pParamValue, &uFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"uFlags") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseULongArgument (pParamValue, &uFlags);
							pParamValue->Release ();
						}
					}
					else if(_wcsicmp(strParamName, L"pTransGUID") == 0)
					{
						IXMLDOMNode *pParamValue = NULL;
						if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
						{
							ParseGUIDArgument (pParamValue, &TransGUID);
							pParamValue->Release ();
						}
					}

					SysFreeString(strParamName);
				}
			}

			SysFreeString(strNodeName);
		}
		pNextParam->Release();
		pNextParam = NULL;
	}

	// Now that we have the arguments, execute the call

	// Get the transactions pointer from the services
	IWbemTransaction *pTrans = NULL;
	if(SUCCEEDED(hr = pServices->QueryInterface(IID_IWbemTransaction, (LPVOID *)&pTrans)))
	{
		// Call Begin on it
		if(SUCCEEDED(hr = pTrans->Begin(uTimeout, uFlags, pTransGUID)))
		{
			CServicesTransaction *pTransCombo = NULL;
			if(pTransCombo = new CServicesTransaction(pTrans, pServices))
			{
				// Add it to the transaction table
				hr = AddToTransactionTable(pTransGUID, pTransCombo);
			}
			else
				hr = E_OUTOFMEMORY;
		}
		pTrans->Release();
	}


	// Release all the arguments to the function
	// The pTransGUID variable gets freed when the entry is removed from the hash table
	// delete pTransGUID;

	return hr;
}


HRESULT CCimWhistlerTransactionRollbackMethod :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemTransaction::Rollback function
	// plus the GUID of thr transaction
	// After collecting the arguments, we get the transaction pointer from our cache using the GUID
	// and then execute Rollback
	// Collect the list of parameters for an Rollback Call
	// This includes uFlags (ULONG), pTransGUID (GUID *)
	//===================================================================
	unsigned long uFlags = 0;
	GUID TransGUID = NULL;

	IXMLDOMNodeList *pMethodArgs = NULL;
	if(SUCCEEDED(m_pIMethodCallNode->get_childNodes(&pMethodArgs)))
	{
		IXMLDOMNode *pNextParam = NULL;
		while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We process only IPARAMVALUE child nodes here
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					// Get the name of the parameter
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, L"uFlags") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseULongArgument (pParamValue, &uFlags);
								pParamValue->Release ();
							}
						}
						else if(_wcsicmp(strParamName, L"pTransGUID") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseGUIDArgument (pParamValue, &TransGUID);
								pParamValue->Release ();
							}
						}

						SysFreeString(strParamName);
					}
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}
		pMethodArgs->Release();
	}

	// Now that we have the arguments, execute the call
	CServicesTransaction *pTrans = NULL;
	if(pTrans = GetFromTransactionTable(pTransGUID))
	{
		hr = (pTrans->m_pTrans)->Rollback(uFlags);

		// Also remove the entry from the table since a transaction ends on this call
		RemoveFromTransactionTable(pTransGUID);
		pTrans->Release();
	}
	else
	  hr = WBEM_E_FAILED;

	// Release all the arguments to the function
	delete pTransGUID;

	return hr;
}


HRESULT CCimWhistlerTransactionCommitMethod :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemTransaction::Commit function
	// plus the GUID of thr transaction
	// After collecting the arguments, we get the transaction pointer from our cache using the GUID
	// and then execute Rollback
	// Collect the list of parameters for an Commit Call
	// This includes uFlags (ULONG), pTransGUID (GUID *)
	//===================================================================
	unsigned long uFlags = 0;
	GUID TransGUID = NULL;

	IXMLDOMNodeList *pMethodArgs = NULL;
	if(SUCCEEDED(m_pIMethodCallNode->get_childNodes(&pMethodArgs)))
	{
		IXMLDOMNode *pNextParam = NULL;
		while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We process only IPARAMVALUE child nodes here
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					// Get the name of the parameter
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, L"uFlags") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseULongArgument (pParamValue, &uFlags);
								pParamValue->Release ();
							}
						}
						else if(_wcsicmp(strParamName, L"pTransGUID") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseGUIDArgument (pParamValue, &TransGUID);
								pParamValue->Release ();
							}
						}

						SysFreeString(strParamName);
					}
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}
		pMethodArgs->Release();
	}


	// Now that we have the arguments, execute the call
	CServicesTransaction *pTrans = NULL;
	if(pTrans = GetFromTransactionTable(pTransGUID))
	{
		hr = (pTrans->m_pTrans)->Commit(uFlags);

		// Also remove the entry from the table since a transaction ends on this call
		RemoveFromTransactionTable(pTransGUID);
		pTrans->Release();
	}
	else
		hr = WBEM_E_FAILED;

	// Release all the arguments to the function
	delete pTransGUID;

	return hr;
}

HRESULT CCimWhistlerTransactionQueryStateMethod :: PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB)
{
	HRESULT hr = E_FAIL;

	// In this function we expect the pIMethodCallNode argument to have the arguments to an IWbemTransaction::QueryState function
	// plus the GUID of thr transaction
	// After collecting the arguments, we get the transaction pointer from our cache using the GUID
	// and then execute QueryState
	// Collect the list of parameters for an QueryState Call
	// This includes uFlags (ULONG), pTransGUID (GUID *)
	//===================================================================
	unsigned long uFlags = 0;
	GUID TransGUID = NULL;

	IXMLDOMNodeList *pMethodArgs = NULL;
	if(SUCCEEDED(m_pIMethodCallNode->get_childNodes(&pMethodArgs)))
	{
		IXMLDOMNode *pNextParam = NULL;
		while(SUCCEEDED(pMethodArgs->nextNode(&pNextParam)) && pNextParam)
		{
			// Get its name
			BSTR strNodeName = NULL;
			if(SUCCEEDED(pNextParam->get_nodeName(&strNodeName)))
			{
				// We process only IPARAMVALUE child nodes here
				if(_wcsicmp(strNodeName, IPARAMVALUE_TAG) == 0)
				{
					// Get the name of the parameter
					BSTR strParamName = NULL;
					if(SUCCEEDED(GetBstrAttribute(pNextParam, NAME_ATTRIBUTE, &strParamName)))
					{
						if(_wcsicmp(strParamName, L"uFlags") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseULongArgument (pParamValue, &uFlags);
								pParamValue->Release ();
							}
						}
						else if(_wcsicmp(strParamName, L"pTransGUID") == 0)
						{
							IXMLDOMNode *pParamValue = NULL;
							if (SUCCEEDED(pNextParam->get_firstChild (&pParamValue)) && pParamValue)
							{
								ParseGUIDArgument (pParamValue, TransGUID);
								pParamValue->Release ();
							}
						}

						SysFreeString(strParamName);
					}
				}

				SysFreeString(strNodeName);
			}
			pNextParam->Release();
			pNextParam = NULL;
		}
		pMethodArgs->Release();
	}

	
	 // Now that we have the arguments, execute the call
	CServicesTransaction *pTrans = NULL;
	if(pTrans = GetFromTransactionTable(pTransGUID))
	{
		ULONG uState = 0;
		if(SUCCEEDED(hr = (pTrans->m_pTrans)->QueryState(uFlags, &uState)))
		{

		}
		pTrans->Release();
	}
	else
		hr = WBEM_E_FAILED;

	// Release all the arguments to the function
	delete pTransGUID;

	return hr;
}

#endif


HRESULT CCimWhistlerHttpMethod :: CreateFlagsContext()
{
	HRESULT hr = E_FAIL;
	// Create an IWbemContext object
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemContext,
		0,
		CLSCTX_INPROC_SERVER,
		IID_IWbemContext, (LPVOID *) &m_pFlagsContext)))
	{
		if(SUCCEEDED(hr = SetBoolProperty(L"IncludeQualifiers", TRUE)))
		{
			if(SUCCEEDED(hr = SetBoolProperty(L"LocalOnly", FALSE)))
			{
				if(SUCCEEDED(hr = SetBoolProperty(L"IncludeClassOrigin", FALSE)))
				{
					if(SUCCEEDED(hr = SetBoolProperty(L"AllowWMIExtensions", TRUE)))
					{
					}
				}
			}
		}
	}
	return hr;
}

#ifdef WMIOBJSECURITY

HRESULT CCimWhistlerGetObjectSecurityMethod::EncodeSecurity(IWbemRawSdAccessor *pSecurity, IStream *pStream)
{
	HRESULT hr = E_FAIL;

	// Write the contents of the BYTE array as a VALUE.ARRAY into the stream
	ULONG uRequired = 0;
	if(SUCCEEDED(hr = pSecurity->Get(0, 0, &uRequired, NULL)))
	{
		BYTE *pValues = NULL;
		if(pValues = new BYTE[uRequired])
		{
			if(SUCCEEDED(hr = pSecurity->Get(0, uRequired, &uRequired, pValues)))
			{
				WRITEWSTR(pStream, L"<VALUE.ARRAY>");
				WCHAR pszTemp[10];
				for(ULONG i=0; i<uRequired; i++)
				{
					pszTemp[0] = NULL;
					swprintf(pszTemp, L"%d", pValues[i]);
					WRITEWSTR(pStream, L"<VALUE>");
					WRITEWSTR(pStream, pszTemp);
					WRITEWSTR(pStream, L"</VALUE>");
				}
				WRITEWSTR(pStream, L"</VALUE.ARRAY>");
			}
		}
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

HRESULT CCimWhistlerPutObjectSecurityMethod::DecodeSecurity(IXMLDOMNode *pValueArrayNode, IWbemRawSdAccessor **ppSecurity)
{
	HRESULT hr = E_FAIL;

	// We get a VALUE.ARRAY tag here
	// Go thru all its child VALUE tags and collect the values
	IXMLDOMNodeList *pValueTags = NULL;
	if(SUCCEEDED(hr = pValueArrayNode->get_childNodes(&pValueTags)))
	{
		long uNumValues = 0;
		if(SUCCEEDED(hr = pValueTags->get_length(&uNumValues)) && uNumValues)
		{
			BYTE *pValues = NULL;
			if(pValues = new BYTE[uNumValues])
			{
				// Go thru each of the child nodes now
				IXMLDOMNode *pNextValue = NULL;
				long i=0;
				while(SUCCEEDED(hr = pValueTags->nextNode(&pNextValue)) && pNextValue && i<uNumValues)
				{
					BSTR strValue = NULL;
					if(SUCCEEDED(hr = pNextValue->get_text(&strValue)))
					{
						pValues[i] = 0;
						swscanf(strValue, L"%d", &(pValues[i++]));
						SysFreeString(strValue);
					}
					pNextValue->Release();
					pNextValue = NULL;
				}
			}
			else
				hr = E_OUTOFMEMORY;
		}
		pValueTags->Release();
	}
	return hr;
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\idl\uuid\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\whistler.h ===
#ifdef WMI_XML_WHISTLER

//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  WHISTLER.H
//
//  rajeshr  3/25/2000   Created.
//
// Contains the classes that model the various operations that can be done on
// WMI using the Whistler APIs
//
//***************************************************************************

#ifndef CIM_WHISTLER_HTTP_REQUEST_H
#define CIM_WHISTLER_HTTP_REQUEST_H


// A Whistler Method - we hold on to the body here instead of parsing it since it is tedious
class CCimWhistlerHttpMethod : public CCimHttpMessage
{
	protected:
		// This is the IMETHODCALL node
		IXMLDOMNode *m_pIMethodCallNode;


	protected:
		HRESULT ParseOptionalGUID(IXMLDOMNode *pIMethodCallNode, GUID *pGUID);
		HRESULT ParseIWbemConnection(IXMLDOMNode *pIMethodCallNode, IWbemServicesEx **ppFirstServices, IXMLDOMNodeList **ppServicesArgs);
		HRESULT ParseIWbemServices(IWbemServicesEx *pParentServices, IXMLDOMNodeList *&pServicesArgs, IWbemServicesEx **ppChildServices);

		HRESULT ParseBstrArgument(IXMLDOMNode *pNode, BSTR *pstrArgVal);
		HRESULT ParseLongArgument(IXMLDOMNode *pNode, long *plArgVal);
		HRESULT ParseULongArgument(IXMLDOMNode *pNode, unsigned long *plArgVal);
		HRESULT ParseGUIDArgument(IXMLDOMNode *pNode, GUID *pGuid);
		HRESULT ParseIWbemContextArgument(IXMLDOMNode *pNode, IWbemContext **ppArgVal);


	public:
		CCimWhistlerHttpMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest);
		virtual ~CCimWhistlerHttpMethod();
		virtual void	WriteMethodHeader();
		virtual void	WriteMethodTrailer ();
		virtual HRESULT PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs) = 0;
		virtual HRESULT CreateFlagsContext();

		
		// We need a hash table of GUIDs Versus IWbemTransaction pointers
		// for each of the currently ongoing transaction
		static CTransactionGUIDTable s_oTransactionTable;

		// Methods for manipulating the global transactions table
		static HRESULT IsTransactionTableEmpty();
		static HRESULT RemoveFromTransactionTable(GUID *pGUID);
		static CServicesTransaction *GetFromTransactionTable(GUID *pGUID);
		static HRESULT AddToTransactionTable(GUID *pGUID, CServicesTransaction *pTrans);


};


/* The following classes model a Whistler-stule Request
 * most of them just involve marshalling the requests from w Whistler API
 */
class CCimWhistlerGetObjectMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerGetObjectMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"GetObject";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);

};

class CCimWhistlerEnumerateInstancesMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerEnumerateInstancesMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"EnumerateInstances";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerEnumerateClassesMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerEnumerateClassesMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"EnumerateClasses";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerExecQueryMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerExecQueryMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"ExecQuery";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerDeleteClassMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerDeleteClassMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"GetObject";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerDeleteInstanceMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerDeleteInstanceMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"DeleteInstance";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerCreateClassMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerCreateClassMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}
		
		WCHAR	*GetMethodName() 
		{
			return L"CreateClass";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerCreateInstanceMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerCreateInstanceMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"CreateInstance";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerAddMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerAddMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"Add";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerRemoveMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerRemoveMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"Remove";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerRenameMethod : public CCimWhistlerHttpMethod
{
	public:
		CCimWhistlerRenameMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"Rename";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

#ifdef WMIOBJSECURITY
class CCimWhistlerGetObjectSecurityMethod : public CCimWhistlerHttpMethod
{
	protected:
		HRESULT EncodeSecurity(IWbemRawSdAccessor *pSecurity, IStream *pStream);

	public:
		CCimWhistlerGetObjectSecurityMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"GetObjectSecurity";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, 
			LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerPutObjectSecurityMethod : public CCimWhistlerHttpMethod
{
	protected:
		HRESULT DecodeSecurity(IXMLDOMNode *pValueArrayNode, IWbemRawSdAccessor **ppSecurity);

	public:
		CCimWhistlerPutObjectSecurityMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"PutObjectSecurity";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, 
			LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};
#endif


/*
 * The following 4 classes represent the methods in the IWbemTransaction interface
 */



class CCimWhistlerTransactionBeginMethod : public CCimWhistlerHttpMethod
{

	public:
		CCimWhistlerTransactionBeginMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"TransactionBegin";
		}
		virtual HRESULT ExecuteWhistlerMethod(IStream *pPrefixStream, IStream *pSuffixStream, 
			LPEXTENSION_CONTROL_BLOCK pECB, IWbemServicesEx *pServices, IXMLDOMNodeList *pMethodArgs);
};

class CCimWhistlerTransactionRollbackMethod : public CCimWhistlerHttpMethod
{

	public:
		CCimWhistlerTransactionRollbackMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"TransactionBegin";
		}
		virtual HRESULT PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
};

class CCimWhistlerTransactionCommitMethod : public CCimWhistlerHttpMethod
{

	public:
		CCimWhistlerTransactionCommitMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"TransactionBegin";
		}
		virtual HRESULT PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
};

class CCimWhistlerTransactionQueryStateMethod : public CCimWhistlerHttpMethod
{

	public:
		CCimWhistlerTransactionQueryStateMethod(IXMLDOMNode *pIMethodCallNode, BSTR strID, BOOL bIsMpostRequest = FALSE) :
			CCimWhistlerHttpMethod(pIMethodCallNode, strID, bIsMpostRequest)
		{}

		WCHAR	*GetMethodName() 
		{
			return L"TransactionBegin";
		}
		virtual HRESULT PrepareResponseBody(IStream *pPrefixStream, IStream *pSuffixStream, LPEXTENSION_CONTROL_BLOCK pECB);
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\xml2wmi.h ===
//***************************************************************************
//
//  (c) 1999 by Microsoft Corporation
//
//  XML2WMI.h
//
//  alanbos  09-Jul-99   Created.
//
//  Perform XML to WMI mapping functions
//
//***************************************************************************

#ifndef _XML2WMI_H_
#define _XML2WMI_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CXmlToWmi
//
//  DESCRIPTION:
//
//  Performs conversion of XML to WMI.
//
//***************************************************************************

class CXmlToWmi
{
private:
	IXMLDOMNode			*m_pXml;
	IWbemClassObject	*m_pWmiObject;
	IWbemServices		*m_pServices;

	// Methods for Class/Instance handling
	static HRESULT MapQualifier (IXMLDOMNode *pNode, IWbemQualifierSet *pQualSet, bool bIsInstance = false);
	HRESULT MapProperty (IXMLDOMNode *pNode, bool bIsArray, bool bIsModify, bool bIsInstance = false);
	HRESULT MapPropertyReference (IXMLDOMNode *pNode, bool bIsArray, bool bIsModify, bool bIsInstance = false);
	HRESULT MapPropertyObject (IXMLDOMNode *pProperty, bool bIsArray, bool bIsModify, bool bIsInstance = false);
	HRESULT MapMethod (IXMLDOMNode *pNode, bool bIsModify);

	// Mapping of parameter elements
	static HRESULT	MapParameter (IXMLDOMNode *pNode, IWbemClassObject **ppInParameters,
									IWbemClassObject **ppOutParameters,
									IWbemServices *pService, ULONG paramId,
									bool isArray = false);
	static HRESULT	MapReferenceParameter (IXMLDOMNode *pNode, 
				IWbemClassObject **ppInParameters, IWbemClassObject **ppOutParameters,
				IWbemServices *pService, ULONG paramId, bool isArray = false);
	static HRESULT	MapParameterQualifiers (IXMLDOMNode *pNode, 
				IWbemQualifierSet *pQualSet, ULONG paramId, bool bIsArray, 
				long iArraySize, bool bIsInParameter = false);
	static bool		DetermineParameterCharacteristics (IXMLDOMNode *pParameter, 
						bool bIsArray,	bool &bIsInParameter, 
						bool &bIsOutParameter, BSTR &bsName, 
						CIMTYPE &cimtype, long &iArraySize, 
						bool bIsReference = false, BSTR *pbsReferenceClass = NULL);


	// Mapping of value elements
	static HRESULT		MapStringValueIntoArray (BSTR bsValue, SAFEARRAY *pArray, long *ix, 
									VARTYPE vt, CIMTYPE cimtype);
	static HRESULT  MapOneReferenceValue (IXMLDOMNode *pValue, BSTR *pstrValue);
	static HRESULT FormRefValueKeyBinding(LPWSTR *ppszValue, LPCWSTR pszPropertyName, LPCWSTR pszRefValue);
	HRESULT MapOneObjectValue (IXMLDOMNode *pValueRef, IUnknown **ppunkValue);

	// Bits 'n' Bobs
	static VARTYPE	VTFromCIMType (CIMTYPE cimtype);
	static CIMTYPE	CimtypeFromString (BSTR bsType);
	static HRESULT	SetArraySize (IWbemQualifierSet *pQualSet, BSTR strArraySize);
	static HRESULT	SetReferenceClass (IWbemQualifierSet *pQualSet, BSTR strReferenceClass);
	static HRESULT	SetObjectClass (IWbemQualifierSet *pQualSet, BSTR strReferenceClass);

	// Stuff for creating an IWbemContext object from an CONTEXTOBJECT element
	static HRESULT MapContextProperty (IXMLDOMNode *pProperty, IWbemContext *pContext);
	static HRESULT MapContextPropertyArray (IXMLDOMNode *pProperty, IWbemContext *pContext);
	static VARTYPE VarTypeFromString (BSTR bsType);
	static HRESULT MapContextStringValue (BSTR bsValue, VARIANT &curValue, VARTYPE vartype);
	static HRESULT MapContextStringArrayValue (IXMLDOMNode *pValueNode, VARIANT &curValue, VARTYPE vartype );
	static HRESULT MapContextStringValueIntoArray (BSTR bsValue, SAFEARRAY *pArray, long *ix, VARTYPE vt);

	HRESULT MapClassName (BSTR *pstrClassName);

public:
    
	CXmlToWmi ();
	HRESULT Initialize(IXMLDOMNode *pXml, IWbemServices *pServices = NULL, IWbemClassObject *pWmiObject = NULL);
	virtual    ~CXmlToWmi(void);

	HRESULT MapClass (bool bIsModify = false);
	HRESULT MapInstance (bool bIsModify = false);
	HRESULT	MapPropertyValue (VARIANT &curValue, CIMTYPE cimtype);
	static HRESULT	MapStringValue (BSTR bsValue, VARIANT &curValue, CIMTYPE cimtype);
	static HRESULT	MapStringArrayValue (IXMLDOMNode *pValue, VARIANT &curValue, CIMTYPE cimtype);
	static HRESULT	MapReferenceValue (IXMLDOMNode *pValue, VARIANT &curValue);
	static HRESULT	MapReferenceArrayValue (IXMLDOMNode *pValueNode, VARIANT &curValue);
	HRESULT	MapObjectValue (IXMLDOMNode *pValue, VARIANT &curValue);
	HRESULT MapObjectArrayValue (IXMLDOMNode *pValueNode, VARIANT &curValue);

	// Create an IWbemContext object from an CONTEXTOBJECT element
	static HRESULT MapContextObject(IXMLDOMNode *pContextNode, IWbemContext **ppContext);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\idl\proxy\wmixmlst_proxy.c ===
#include <wmixmlst_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\xmlhelp.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  xmlhelp.h
//
//  rajesh  3/25/2000   Created.
//
// Contains the declarations for helper routines that are commonly used for
// navigating the XML tree, writing to IIS socket etc.
//
//***************************************************************************
#ifndef WMI_XML_HELP_H
#define WMI_XML_HELP_H

// Converts LPWSTR to Ansi
DWORD convertLPWSTRToUTF8(LPCWSTR theWcharString, char ** retValue);

// Gets a BSTR attribute from an element
HRESULT GetBstrAttribute(IXMLDOMNode *pNode, const BSTR strAttributeName, BSTR *strAttributeValue);

// A function to escape newlines, tabs etc. from a property value
BSTR EscapeSpecialCharacters(BSTR strInputString);

// Logging functions
void Log (LPEXTENSION_CONTROL_BLOCK pECB, LPCSTR pszLogMessage);
void LogError (LPEXTENSION_CONTROL_BLOCK pECB , LPCSTR pszLogMessage, DWORD dwStatus);

// Writing data to the IIS socket
HRESULT SaveStreamToIISSocket (IStream *pStream, LPEXTENSION_CONTROL_BLOCK pECB, BOOLEAN bChunked = FALSE, BOOLEAN bEncodeLastChunk = FALSE);
HRESULT SavePrefixAndBodyToIISSocket(IStream *pPrefixStream, IStream *pBodyStream, LPEXTENSION_CONTROL_BLOCK pECB, BOOLEAN bChunked);

// IWbemContext creation and manipulation routines
HRESULT SetI4ContextValue(IWbemContext *pContext, LPCWSTR pszName, DWORD dwValue);
HRESULT CreateXMLTranslator(IWbemXMLConvertor **pConvertor);

// This maps the result of an enumeration or query to XML
HRESULT MapEnum(IEnumWbemClassObject *pEnum,
								DWORD dwPathLevel, DWORD dwNumProperties,
								BSTR *pPropertyList,
								BSTR bsClassBasis,
								LPEXTENSION_CONTROL_BLOCK pECB,
								IWbemContext *pFlagsContext,
								BOOLEAN bChunked,
								IStream *pNonChunkedStream = NULL);
// This maps the class names in a class enumeration to XML
HRESULT MapClassNames (IStream *pStream, IEnumWbemClassObject *pEnum, IWbemContext *pFlagsContext);
// This maps the instance names in an instance enumeration to XML
HRESULT MapEnumNames (IStream *pStream, IEnumWbemClassObject *pEnum, DWORD dwPathLevel, IWbemContext *pFlagsContext);

// These macros are helpful in writing to a stream
#define WRITEBSTR(theStream, X)	theStream->Write ((void const *)X, wcslen (X) * sizeof (OLECHAR), NULL);
#define WRITEWSTR(theStream, X)	theStream->Write ((void const *)X, wcslen (X) * sizeof (OLECHAR), NULL);
#define WRITEWSTRL(theStream, X,L) theStream->Write ((void const *)X, L * sizeof (OLECHAR), NULL);
#ifdef WMIXML_DONL	
#define WRITENEWLINE(theStream)			theStream->Write (NEWLINE, 4, NULL);
#else
#define WRITENEWLINE(theStream)
#endif
#define WRITECDATASTART(theStream)		WRITEBSTR(theStream, CDATASTART)
#define WRITECDATAEND(theStream)		WRITEBSTR(theStream, CDATAEND)
#define WRITEAMP(theStream)		        WRITEBSTR(theStream, AMPERSAND)
#define WRITELT(theStream)		        WRITEBSTR(theStream, LEFTCHEVRON)
#define WRITEGT(theStream)		        WRITEBSTR(theStream, RIGHTCHEVRON)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\idl\proxy\wmixmlstp_dlldata.c ===
#include <dlldata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\xmlhelp.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  XMLHELP.CPP
//
//  rajesh  3/25/2000   Created.
//
// Contains the implementation of the XML and IIS Helper routines
//
//***************************************************************************

#include <windows.h>
#include <initguid.h>
#include <objbase.h>
#include <httpext.h>
#include <mshtml.h>
#include <msxml.h>

#include "strings.h"
#include "wmiconv.h"
#include "xmlhelp.h"

// The table of XML Encoders that we have
// static CEncoderMap g_encodersMap;

//
// Converts LPWSTR to its UTF-8 encoding
// Returns -1 if it fails
//
DWORD convertLPWSTRToUTF8(LPCWSTR theWcharString, ULONG lNumberOfWideChars, LPSTR * lppszRetValue, DWORD dwPrefixMemoryAllocated = 0, DWORD dwSuffixMemoryAllocated = 0)
{
	// Find the length of the Ansi string required
	DWORD dwBytesToWrite = WideCharToMultiByte(  CP_UTF8,    // UTF-8 code page
		0,				// performance and mapping flags
		theWcharString,	// address of wide-character string
		lNumberOfWideChars,				// number of characters in string
		NULL,			// address of buffer for new string
		0,				// size of buffer
		NULL,			// address of default for unmappable
                        // characters
		NULL);			// address of flag set when default char. used

	if(dwBytesToWrite == 0 )
		return dwBytesToWrite;

	// Allocate the required length for the Ansi string
	*lppszRetValue = NULL;
	if(!(*lppszRetValue = new char[dwBytesToWrite + dwPrefixMemoryAllocated + dwSuffixMemoryAllocated]))
		return 0;

	// Leave out the first dwPrefixMemoryAllocated bytes
	*lppszRetValue += dwPrefixMemoryAllocated;

	// Convert BSTR to ANSI
	dwBytesToWrite = WideCharToMultiByte(  CP_ACP,         // code page
		0,         // performance and mapping flags
		theWcharString, // address of wide-character string
		lNumberOfWideChars,       // number of characters in string
		*lppszRetValue,  // address of buffer for new string
		dwBytesToWrite,      // size of buffer
		NULL,  // address of default for unmappable
                         // characters
		NULL   // address of flag set when default
                             // char. used
		);

	return dwBytesToWrite;
}


HRESULT GetBstrAttribute(IXMLDOMNode *pNode, const BSTR strAttributeName, BSTR *pstrAttributeValue)
{
	HRESULT result = E_FAIL;
	*pstrAttributeValue = NULL;

	IXMLDOMElement *pElement = NULL;
	if(SUCCEEDED(result = pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pElement)))
	{
		VARIANT var;
		VariantInit(&var);
		if(SUCCEEDED(result = pElement->getAttribute(strAttributeName, &var)))
		{
			if(var.bstrVal)
			{
				*pstrAttributeValue = var.bstrVal;
				var.bstrVal = NULL;
				// No need to clear the variant since we took over its memory
			}
			else
				result = E_FAIL;
		}
		pElement->Release();
	}
	return result;
}

// A function to escape newlines, tabs etc. from a property value
BSTR EscapeSpecialCharacters(BSTR strInputString)
{
	// Escape all the quotes - This code taken from winmgmt\common\var.cpp
	// =====================

	int nStrLen = wcslen(strInputString);
	LPWSTR wszValue = NULL;
	BSTR retValue = NULL;
	if(wszValue = new WCHAR[nStrLen*2+10])
	{
		LPWSTR pwc = wszValue;
		for(int i = 0; i < (int)nStrLen; i++)
		{
			switch(strInputString[i])
			{
				case L'\n':
					*(pwc++) = L'\\';
					*(pwc++) = L'n';
					break;
				case L'\t':
					*(pwc++) = L'\\';
					*(pwc++) = L't';
					break;
				case L'"':
				case L'\\':
					*(pwc++) = L'\\';
					*(pwc++) = strInputString[i];
					break;
				default:
					*(pwc++) = strInputString[i];
					break;
			}
		}
		*pwc = 0;
		retValue = SysAllocString(wszValue);
		delete [] wszValue;
	}
	return retValue;
}

// Logging functions
void Log (LPEXTENSION_CONTROL_BLOCK pECB, LPCSTR pszLogMessage)
{
	DWORD dwLength = strlen(pszLogMessage);
	pECB->ServerSupportFunction(pECB->ConnID, HSE_APPEND_LOG_PARAMETER,
	  (LPVOID)pszLogMessage,
      &dwLength,
	  NULL
	);
}

void LogError (LPEXTENSION_CONTROL_BLOCK pECB , LPCSTR pszLogMessage, DWORD dwStatus)
{
	DWORD dwLength = strlen(pszLogMessage);
	pECB->ServerSupportFunction(pECB->ConnID, HSE_APPEND_LOG_PARAMETER,
		  (LPVOID)pszLogMessage,
		  &dwLength,
		  NULL
		);

	pECB->dwHttpStatusCode = dwStatus;
}

HRESULT SaveStreamToIISSocket (IStream *pStream, LPEXTENSION_CONTROL_BLOCK pECB, BOOLEAN bChunked, BOOLEAN bEncodeLastChunk)
{
	HRESULT result = E_FAIL;

	LARGE_INTEGER	offset;
	offset.LowPart = offset.HighPart = 0;
	if(SUCCEEDED(result = pStream->Seek (offset, STREAM_SEEK_SET, NULL)))
	{
		// Covert the LPWSTR XML data to UTF8 before writing
		//=====================================
		STATSTG statstg;
		if (SUCCEEDED(result = pStream->Stat(&statstg, STATFLAG_NONAME)))
		{
			ULONG cbSize = (statstg.cbSize).LowPart;
			WCHAR *pText = NULL;

			if(cbSize)
			{
				if(pText = new WCHAR [(cbSize/2)])
				{
					if (SUCCEEDED(result = pStream->Read(pText, cbSize, NULL)))
					{
						DWORD dwPrefixMemoryAllocated = 0, dwSuffixMemoryAllocated = 0;
						if(bChunked) // Write as a Chunk
						{
							// Chunk = ChunkSize + CRLF + ChunkBody + CRLF
							// Extra memory for prefix is for the ChunkSize (16), CRLF(2)
							dwPrefixMemoryAllocated += 18;
							// Extra memory for prefix is for the  CRLF(2)
							dwSuffixMemoryAllocated += 2;
							if(bEncodeLastChunk) // Encode an empty chunk too
							{
								// LastChunk = "0" followed by CRLF, followed by CRLF
								dwSuffixMemoryAllocated += 5;
							}

						}
						LPSTR pszMessage = NULL, pszMemoryAllocated = NULL;
						DWORD dwBytesToWrite = convertLPWSTRToUTF8(pText, cbSize/2, &pszMemoryAllocated, dwPrefixMemoryAllocated, dwSuffixMemoryAllocated);

						if(dwBytesToWrite > 0)
						{
							pszMessage = pszMemoryAllocated;
							// Write the Chunk details if any
							if(bChunked) // Write as a Chunk
							{
								// produce hex string of the number of bytes
								// and compute the length of this string
								CHAR szChunkLength[16];
								_itoa( dwBytesToWrite, szChunkLength, 16 );
								int dwChunkLengthLength = strlen( szChunkLength );

								//
								// step back to make place for hex number and CRLF,
								//
								pszMessage = pszMessage - 2 - dwChunkLengthLength;
								dwBytesToWrite += dwChunkLengthLength + 2;
								memmove( pszMessage, szChunkLength, dwChunkLengthLength );
								pszMessage[dwChunkLengthLength] = '\r';
								pszMessage[dwChunkLengthLength+1] = '\n';

								// Write the CRLF at the end of the chunk, after the body
								pszMessage[dwBytesToWrite] = '\r';
								pszMessage[dwBytesToWrite+1] = '\n';
								dwBytesToWrite += 2;


								// See if the last enmpty chunk needs to be written
								if(bEncodeLastChunk) // Encode an empty chunk too
								{
									// LastChunk = "0" followed by CRLF
									pszMessage[dwBytesToWrite] = '0';
									pszMessage[dwBytesToWrite+1] = '\r';
									pszMessage[dwBytesToWrite+2] = '\n';
									pszMessage[dwBytesToWrite+3] = '\r';
									pszMessage[dwBytesToWrite+4] = '\n';
									dwBytesToWrite += 5;
								}
							}

							if(!pECB->WriteClient( pECB->ConnID, (LPVOID)pszMessage, &dwBytesToWrite, HSE_IO_SYNC))
								result = E_FAIL;
							delete [] pszMemoryAllocated;
						}
						else
							result = E_OUTOFMEMORY;
					}
					delete [] pText;
				}
				else
					result = E_OUTOFMEMORY;
			}
		}
	}

	return result;
}

HRESULT SavePrefixAndBodyToIISSocket(IStream *pPrefixStream, IStream *pBodyStream, 
									 LPEXTENSION_CONTROL_BLOCK pECB, BOOLEAN bChunked)
{
	HRESULT result = S_OK;
	if(pPrefixStream)
		result = SaveStreamToIISSocket(pPrefixStream, pECB, bChunked);

	if(SUCCEEDED(result) && pBodyStream)
		result = SaveStreamToIISSocket(pBodyStream, pECB, bChunked);

	return result;
}

// RAJESHR - Remove this to read the GUID frm the registry on startup
DEFINE_GUID(CLSID_WbemXMLConvertor,
	0x610037ec, 0xce06, 0x11d3, 0x93, 0xfc, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
HRESULT CreateXMLTranslator(IWbemXMLConvertor **pConvertor)
{

	HRESULT result = E_FAIL;

	// Create the XMLAdaptor object
	//******************************************************
	*pConvertor = NULL;
	if(SUCCEEDED(result = CoCreateInstance(CLSID_WbemXMLConvertor,
		0,
		CLSCTX_INPROC_SERVER,
        IID_IWbemXMLConvertor, (LPVOID *) pConvertor)))
	{
	}
	return result;
}

HRESULT SetI4ContextValue(IWbemContext *pContext, LPCWSTR pszName, DWORD dwValue)
{
	HRESULT result = E_FAIL;
	VARIANT vValue;
	VariantInit(&vValue);
	vValue.vt = VT_I4;
	vValue.lVal = dwValue;
	result = pContext->SetValue(pszName, 0, &vValue);
	VariantClear(&vValue);
	return result;
}


HRESULT MapEnum(	IEnumWbemClassObject *pEnum,
					DWORD dwPathLevel, DWORD dwNumProperties,
					BSTR *pPropertyList,
					BSTR bsClassBasis,
					LPEXTENSION_CONTROL_BLOCK pECB,
					IWbemContext *pFlagsContext,
					BOOLEAN bChunked,
					IStream *pNonChunkedStream)
{
	HRESULT hr = WBEM_E_FAILED;
	ULONG	dummy = 0;

	if(SUCCEEDED(hr = SetI4ContextValue(pFlagsContext, L"PathLevel", dwPathLevel)))
	{
		IWbemClassObject *pObject = NULL;
		bool bError = false;
		while (!bError && SUCCEEDED(hr = pEnum->Next (INFINITE, 1, &pObject, &dummy)) && dummy != 0)
		{
			// Create a stream if chunked encoding is used
			// Otherwise, we just write to the pNonChunkedStream stream
			IStream *pStream = NULL;
			if(bChunked)
				hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
			else
				pStream = pNonChunkedStream;

			if (SUCCEEDED(hr))
			{
				// Create the convertor
				IWbemXMLConvertor *pConvertor = NULL;
				if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
				{
					// Write an appropriate VALUE tag
					if(dwPathLevel == 1)
						// This is used for ENUMINSTANCE
						WRITEBSTR(pStream, L"<VALUE.NAMEDINSTANCE>")
					else if (dwPathLevel == 3) // This is used for Associators, References
						WRITEBSTR(pStream, L"<VALUE.OBJECTWITHPATH>")


					// Now do the translation

					// For shallow instance enumerations we'll have to do
					// some work to emulate DMTF semantics. Only do this
					// if a class basis is supplied
					hr = pConvertor->MapObjectToXML (pObject, pPropertyList, dwNumProperties, pFlagsContext, pStream, bsClassBasis);

					// End with an appropriate VALUE tag
					if(dwPathLevel == 1) // This is used for ENUMINSTANCE
						WRITEBSTR(pStream, L"</VALUE.NAMEDINSTANCE>")
					else if (dwPathLevel == 3) // This is used for Associators, References
						WRITEBSTR(pStream, L"</VALUE.OBJECTWITHPATH>")
	
					// We need to write the encoding of the object to the IIS Socket only
					// if we are using chunked encoding
					// Otherwise, the caller will assume the responsibility of writing the
					// contents of the pNonChunkedStream, once we return from this call
					if(bChunked && SUCCEEDED(hr))
						hr = SaveStreamToIISSocket(pStream, pECB, bChunked);
					pConvertor->Release();
				}

				// Release the new stream that we created for chunked encoding
				if(bChunked)
					pStream->Release();
			}

			if(FAILED(hr))
				bError = true;

			pObject->Release ();
			pObject = NULL;
		}
	}

	return hr;
}

HRESULT MapEnumNames (IStream *pStream, IEnumWbemClassObject *pEnum, DWORD dwPathLevel, IWbemContext *pFlagsContext)
{
	HRESULT hr = WBEM_E_FAILED;
	ULONG	dummy = 0;

	// Get the Name or Path of each object and map it
	//=====================================
	IWbemClassObject *pObject = NULL;
	while (SUCCEEDED(hr = pEnum->Next (INFINITE, 1, &pObject, &dummy)) && dummy != 0)
	{
		VARIANT var;
		VariantInit (&var);
		if ((WBEM_S_NO_ERROR == pObject->Get(
				(2 == dwPathLevel) ? L"__RELPATH" : L"__PATH",
				0, &var, NULL, NULL)) &&
					(VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			// Create the convertor
			IWbemXMLConvertor *pConvertor = NULL;
			if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
			{
				hr = (2 == dwPathLevel) ? pConvertor->MapInstanceNameToXML (var.bstrVal, pFlagsContext, pStream) :
													  pConvertor->MapInstancePathToXML (var.bstrVal, pFlagsContext, pStream);
				pConvertor->Release();
			}
		}
		VariantClear (&var);
		pObject->Release ();
		pObject = NULL;
	}

	return hr;
}

HRESULT MapClassNames (IStream *pStream, IEnumWbemClassObject *pEnum, IWbemContext *pFlagsContext)
{
	HRESULT hr = WBEM_E_FAILED;
	ULONG	dummy = 0;

	// Get the Name or Path of each class and map it
	//=====================================
	IWbemClassObject *pObject = NULL;
	while (SUCCEEDED(hr = pEnum->Next (INFINITE, 1, &pObject, &dummy)) && dummy != 0)
	{
		VARIANT var;
		VariantInit (&var);

		if ((WBEM_S_NO_ERROR == pObject->Get(L"__CLASS", 0, &var, NULL, NULL)) &&
			(VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			// Create the convertor
			IWbemXMLConvertor *pConvertor = NULL;
			if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
			{
				hr = pConvertor->MapClassNameToXML (var.bstrVal, pFlagsContext, pStream);
				pConvertor->Release();
			}
		}
			VariantClear(&var);
		pObject->Release ();
		pObject = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\cwmixmlserv.h ===
#ifndef CWMIXMLServices_H
#define CWMIXMLServices_H


class CWMIXMLEnumWbemClassObject : public IWmiXMLEnumWbemClassObject
{
private:
    long m_ReferenceCount ;
	IEnumWbemClassObject *m_pEnum;


public:
	CWMIXMLEnumWbemClassObject(IEnumWbemClassObject *pEnum);
	virtual ~CWMIXMLEnumWbemClassObject();

	// Members of IUnknown
	STDMETHODIMP QueryInterface (REFIID iid, LPVOID FAR *iplpv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Members of IWmiXMLEnumWbemClassObject
    HRESULT STDMETHODCALLTYPE Next(
 	/* [in] */  DWORD_PTR hToken, 
    /* [in] */  long lTimeout,
    /* [in] */  ULONG uCount,
    /* [out, size_is(uCount), length_is(*puReturned)] */ IWbemClassObject** apObjects,
    /*[out] */ ULONG* puReturned
        );

	HRESULT  STDMETHODCALLTYPE FreeToken(
 		/* [in] */ DWORD_PTR hToken); 


};


class CWMIXMLServices : public IWmiXMLWbemServices
{
private:
    long m_ReferenceCount ;
	IWbemServices *m_pServices;


public:
	CWMIXMLServices(IWbemServices *pServices);
	virtual ~CWMIXMLServices();

	// Members of IUnknown
	STDMETHODIMP QueryInterface (REFIID iid, LPVOID FAR *iplpv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Members of IWmiXMLServices
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWmiXMLEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWmiXMLEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWmiXMLEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ DWORD_PTR hToken,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

		virtual HRESULT  STDMETHODCALLTYPE FreeToken(
 			/* [in] */ DWORD_PTR hToken); 

};

#endif // #ifndef CWMIXMLServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\globals.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Count of locks
extern long g_lComponents;

// Count of active locks
extern long g_lServerLocks;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\cwmixmlst.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//
//***************************************************************************
#include "precomp.h"
#include <tchar.h>
#include <comdef.h>

#include <wbemtran.h>
#include <wbemprov.h>
#include "globals.h"
#include "wmixmlst.h"
#include "wmixmlstf.h"
#include "cwmixmlst.h"
#include "xmlsec.h"
#include "cwmixmlserv.h"

// Globals

void CheckTheError()
{
	LPVOID lpMsgBuf;
	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL
	);

	// Free the buffer.
	LocalFree( lpMsgBuf );

}

CWMIXMLTransport :: CWMIXMLTransport()
{
	InterlockedIncrement(&g_lComponents);
	m_ReferenceCount = 0 ;
	m_bRegisteredClassObject = FALSE;
	m_dwClassFac = 0;
	m_bProcessID = 0;
	m_bProcessID = GetCurrentProcessId();
}

CWMIXMLTransport :: ~CWMIXMLTransport()
{
	HRESULT hr = E_FAIL;
	if(m_bRegisteredClassObject)
		hr = CoRevokeClassObject(m_dwClassFac);
}

//***************************************************************************
//
// CWMIXMLTransport::QueryInterface
// CWMIXMLTransport::AddRef
// CWMIXMLTransport::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CWMIXMLTransport::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( IUnknown * ) ( IWmiXMLTransport * )this ;
	}
	else if ( iid == IID_IWmiXMLTransport )
	{
		*iplpv = ( IWmiXMLTransport * ) this ;
	}
	else if ( iid == IID_IWbemTransport )
	{
		*iplpv = ( IWbemTransport * ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CWMIXMLTransport :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CWMIXMLTransport :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT STDMETHODCALLTYPE CWMIXMLTransport :: Initialize()
{
	// Do a CoRegisterClassObject to register for the
	CWMIXMLTransportFactory *lpunk1 = new CWMIXMLTransportFactory;
	lpunk1->AddRef();

	HRESULT hr = CoRegisterClassObject(
						  CLSID_WmiXMLTransport,			//Class identifier (CLSID) to be registered
						  (IUnknown *) lpunk1,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  &m_dwClassFac							//Pointer to the value returned
						  );

	if(SUCCEEDED(hr))
	{
		m_bRegisteredClassObject = TRUE;

		// Get a Locator

	}
	else
	{
		delete lpunk1;
		return E_FAIL;
	}
	return S_OK;

}

/*
HRESULT STDMETHODCALLTYPE CWMIXMLTransport :: GetImpersonatingUser(LPSTR *ppszUserName)
{
	TCHAR pszUser[100];
	DWORD dwLenght = 100;
	*ppszUserName = NULL;
	HRESULT status = S_OK;

	if(GetUserName(pszUser, &dwLenght))
	{
#ifdef UNICODE
	// Convert to char
	char szUser[128];
	WideCharToMultiByte(CP_ACP, 0, pszUser, -1, szUser, 128, NULL, NULL);

	*ppszUserName = (char *) CoTaskMemAlloc((strlen(szUser) + 1)*sizeof(char));
	if(*ppszUserName)
		strcpy(*ppszUserName, szUser);
	else
		status = E_OUTOFMEMORY;
#else
	*ppszUserName = (char *) CoTaskMemAlloc((strlen(szUser) + 1)*sizeof(char));
	*ppszUserName = new char [strlen(pszUser) + 1];
	if(*ppszUserName)
		strcpy(*ppszUserName, pszUser);
	else
		status = E_OUTOFMEMORY;
#endif
	}
	return status;
}
*/

HRESULT STDMETHODCALLTYPE CWMIXMLTransport :: ConnectUsingToken(
            /* [in] */ DWORD_PTR dwToken,
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWmiXMLWbemServices **ppNamespace)
{
	HANDLE hToken = (HANDLE) dwToken;
	HRESULT result = E_FAIL;
	*ppNamespace = NULL;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Create a Locator and Login into WinMgmt
		IWbemLevel1Login *pLocator = NULL;
		if(SUCCEEDED(result = CoCreateInstance(CLSID_WbemLevel1Login, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLevel1Login, (LPVOID *)&pLocator)))
		{
			IWbemServices *pServices = NULL;
			if(SUCCEEDED(result = pLocator->NTLMLogin(strNetworkResource, strLocale, lSecurityFlags, pCtx, &pServices)))
			{
				// Switch back the context to the old one
				IUnknown *pOldestContext = NULL;
				if(SUCCEEDED(result = CoSwitchCallContext(pOldContext, &pOldestContext)))
				{
					// Release all the contexts we got
					pOldestContext->Release();
					pOldContext->Release();

					// Create my wrapper around the IWbemServices
					*ppNamespace = new CWMIXMLServices(pServices);
					if(*ppNamespace)
					{
						result = WBEM_S_NO_ERROR;
					}
					else
						result = E_OUTOFMEMORY;
				}
				pServices->Release();
			}
			pLocator->Release();
		}

		// Change the call context back to the original COM one
		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	else
		CheckTheError();

	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}


	/*
	// Get the SID from the Token
	DWORD dwLength = 0;
	GetTokenInformation(hToken, TokenUser, NULL, dwLength, &dwLength);
	PTOKEN_USER pUserInfo = (PTOKEN_USER) new BYTE [dwLength];
	if(GetTokenInformation(hToken, TokenUser, pUserInfo, dwLength, &dwLength))
	{
		PSID pSid = pUserInfo->User.Sid;
		if(IsValidSid(pSid))
		{
			TCHAR pszAccountName[100];
			DWORD dwAccountNameSize = 100;
			TCHAR pszDomainName[100];
			DWORD dwDomainNameSize = 100;
			SID_NAME_USE accountType;
			// Get its user account name
			if(LookupAccountSid(NULL, pSid,  pszAccountName,  &dwAccountNameSize, pszDomainName, &dwDomainNameSize, &accountType))
			{
				*ppszUser = new TCHAR [200];
				_tcscpy(*ppszUser, pszAccountName);
				_tcscat(*ppszUser, L"\\");
				_tcscat(*ppszUser, pszDomainName);
				_tcscat(*ppszUser, L":Results of Method Call:");
			}


*/


												/*
												BSTR strObjectName = SysAllocString(L"userID");
												BSTR strMethodName = SysAllocString(L"GetUserID");

												IWbemClassObject *pOutputParams = NULL;
												if(SUCCEEDED(pServices->ExecMethod(strObjectName, strMethodName, 0, NULL, NULL, &pOutputParams, NULL)))
												{
													BSTR strDomain = SysAllocString(L"sDomain");
													BSTR strUser = SysAllocString(L"sUser");
													BSTR strImpLevel = SysAllocString(L"sImpLevel");

													VARIANT var;

													VariantInit(&var);
													if(SUCCEEDED(pOutputParams->Get(strDomain, 0, &var, NULL, NULL)))
													{
														_tcscat(*ppszUser, L":");
														_tcscat(*ppszUser, var.bstrVal);
													}
													VariantClear(&var);

													VariantInit(&var);
													if(SUCCEEDED(pOutputParams->Get(strUser, 0, &var, NULL, NULL)))
													{
														_tcscat(*ppszUser, L":");
														_tcscat(*ppszUser, var.bstrVal);
													}
													VariantClear(&var);

													VariantInit(&var);
													if(SUCCEEDED(pOutputParams->Get(strImpLevel, 0, &var, NULL, NULL)))
													{
														_tcscat(*ppszUser, L":");
														_tcscat(*ppszUser, var.bstrVal);
													}
													VariantClear(&var);

													pOutputParams->Release();
												}
												SysFreeString(strObjectName);
												SysFreeString(strMethodName);
											}
											SysFreeString(strNamespace);
											*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\cwmixmlserv.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//
//***************************************************************************
#include "precomp.h"
#include <tchar.h>
#include <comdef.h>
#include <wbemtran.h>
#include <wbemprov.h>
#include "globals.h"
#include "wmixmlst.h"
#include "wmixmlstf.h"
#include "cwmixmlserv.h"
#include "xmlsec.h"

CWMIXMLEnumWbemClassObject :: CWMIXMLEnumWbemClassObject(IEnumWbemClassObject *pEnum)
{
	InterlockedIncrement(&g_lComponents);
	m_ReferenceCount = 0 ;
	m_pEnum = NULL;
	m_pEnum = pEnum;
	if(m_pEnum)
		m_pEnum->AddRef();
}

CWMIXMLEnumWbemClassObject :: ~CWMIXMLEnumWbemClassObject()
{
	if(m_pEnum)
		m_pEnum->Release();
}

//***************************************************************************
//
// CWMIXMLServices::QueryInterface
// CWMIXMLServices::AddRef
// CWMIXMLServices::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CWMIXMLEnumWbemClassObject::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( IUnknown * ) this ;
	}
	else if ( iid == IID_IWmiXMLEnumWbemClassObject )
	{
		*iplpv = ( IWmiXMLEnumWbemClassObject * ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CWMIXMLEnumWbemClassObject :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CWMIXMLEnumWbemClassObject :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT STDMETHODCALLTYPE CWMIXMLEnumWbemClassObject :: Next(
 	/* [in] */  DWORD_PTR dwToken,
    /* [in] */  long lTimeout,
    /* [in] */  ULONG uCount,
    /* [out, size_is(uCount), length_is(*puReturned)] */ IWbemClassObject** apObjects,
    /*[out] */ ULONG* puReturned
    )
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		result = m_pEnum->Next(lTimeout, uCount, apObjects, puReturned);

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT  STDMETHODCALLTYPE CWMIXMLEnumWbemClassObject :: FreeToken(
 	/* [in] */ DWORD_PTR dwToken) 
{
	HANDLE hToken = (HANDLE)dwToken;
	CloseHandle(hToken);
	return S_OK;
}


CWMIXMLServices :: CWMIXMLServices(IWbemServices *pServices)
{
	InterlockedIncrement(&g_lComponents);
	m_ReferenceCount = 0 ;
	m_pServices = NULL;
	m_pServices = pServices;
	if(m_pServices)
		m_pServices->AddRef();
}

CWMIXMLServices :: ~CWMIXMLServices()
{
	if(m_pServices)
		m_pServices->Release();
}

//***************************************************************************
//
// CWMIXMLServices::QueryInterface
// CWMIXMLServices::AddRef
// CWMIXMLServices::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CWMIXMLServices::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( IUnknown * ) this ;
	}
	else if ( iid == IID_IWmiXMLWbemServices )
	{
		*iplpv = ( IWmiXMLWbemServices * ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CWMIXMLServices :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CWMIXMLServices :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT STDMETHODCALLTYPE CWMIXMLServices :: GetObject(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		result = m_pServices->GetObject(strObjectPath, lFlags, pCtx, ppObject, ppCallResult);

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: PutClass(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		result = m_pServices->PutClass(pObject, lFlags, pCtx, ppCallResult);

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: DeleteClass(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		result = m_pServices->DeleteClass(strClass, lFlags, pCtx, ppCallResult);

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: CreateClassEnum(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWmiXMLEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		IEnumWbemClassObject *pEnum = NULL;
		*ppEnum = NULL;
		if(SUCCEEDED(result = m_pServices->CreateClassEnum(strSuperclass, lFlags, pCtx, &pEnum)))
		{
			// Wrap the enumerator in our own one
			*ppEnum = new CWMIXMLEnumWbemClassObject(pEnum);
			if(*ppEnum)
			{
				result = WBEM_S_NO_ERROR;
			}
			else
				result = E_OUTOFMEMORY;
			pEnum->Release();
		}

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: PutInstance(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		result = m_pServices->PutInstance(pInst, lFlags, pCtx, ppCallResult);

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: DeleteInstance(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		result = m_pServices->DeleteInstance(strObjectPath, lFlags, pCtx, ppCallResult);

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: CreateInstanceEnum(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWmiXMLEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		IEnumWbemClassObject *pEnum = NULL;
		*ppEnum = NULL;
		if(SUCCEEDED(result = m_pServices->CreateInstanceEnum(strClass, lFlags, pCtx, &pEnum)))
		{
			// Wrap the enumerator in our own one
			*ppEnum = new CWMIXMLEnumWbemClassObject(pEnum);
			if(*ppEnum)
			{
				result = WBEM_S_NO_ERROR;
			}
			else
				result = E_OUTOFMEMORY;
			pEnum->Release();
		}

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: ExecQuery(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWmiXMLEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		IEnumWbemClassObject *pEnum = NULL;
		*ppEnum = NULL;
		if(SUCCEEDED(result = m_pServices->ExecQuery(strQueryLanguage, strQuery, lFlags, pCtx, &pEnum)))
		{
			// Wrap the enumerator in our own one
			*ppEnum = new CWMIXMLEnumWbemClassObject(pEnum);
			if(*ppEnum)
			{
				result = WBEM_S_NO_ERROR;
			}
			else
				result = E_OUTOFMEMORY;
			pEnum->Release();
		}

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT STDMETHODCALLTYPE CWMIXMLServices :: ExecMethod(
    /* [in] */ DWORD_PTR dwToken,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	HRESULT result = E_FAIL;
	HANDLE hToken = (HANDLE)dwToken;

	// Change the COM call context to our own one
	IUnknown *pOldContext = NULL;
	if(SUCCEEDED(result = CXmlCallSecurity::SwitchCOMToThreadContext(hToken, &pOldContext)))
	{
		// Talk to WinMgmt
		result = m_pServices->ExecMethod(strObjectPath, strMethodName, lFlags, pCtx, pInParams, ppOutParams, ppCallResult);

		// Switch back the context to the standard COM one
		IUnknown *pXmlContext = NULL;
		CoSwitchCallContext(pOldContext, &pXmlContext);
		pXmlContext->Release();
	}
	// This handle was duplicated from the ISAPI extension on to the current process. Hence
	// we need to close it here
	CloseHandle(hToken);
	return result;
}

HRESULT  STDMETHODCALLTYPE CWMIXMLServices :: FreeToken(
 	/* [in] */ DWORD_PTR dwToken) 
{
	HANDLE hToken = (HANDLE)dwToken;
	CloseHandle(hToken);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\main.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************
#include "precomp.h"
#include <tchar.h>
#include <olectl.h>

/* WMISAPI includes */
#include "globals.h"
#include "wmiisapi.h"
#include "isapifac.h"

// Count of locks
long g_lComponents = 0;
// Count of active locks
long g_lServerLocks = 0;

BOOL s_Exiting = FALSE ;

typedef HRESULT (WINAPI* PFNCOINITIALIZEEX)(void* pvReserved,  //Reserved
                                            DWORD dwCoInit      //COINIT value
                                            );

typedef HRESULT (WINAPI* PFNCOINITIALIZESECURITY)(
								PSECURITY_DESCRIPTOR         pSecDesc,
								LONG                         cAuthSvc,
								SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
								void                        *pReserved1,
								DWORD                        dwAuthnLevel,
								DWORD                        dwImpLevel,
								void                        *pReserved2,
								DWORD                        dwCapabilities,
								void                        *pReserved3 );

HRESULT COMInit();
STDAPI ExeRegisterServer(void);
STDAPI ExeUnregisterServer(void);


BOOL StartupProvider (DWORD *pdwClassFac)
{

	CWMIISAPIClassFactory *lpunk1 = new CWMIISAPIClassFactory;
	lpunk1->AddRef();

	HRESULT hr = CoRegisterClassObject(
						  CLSID_WmiISAPI,			//Class identifier (CLSID) to be registered
						  (IUnknown *) lpunk1,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  &pdwClassFac[0]							//Pointer to the value returned
						  );

	return (SUCCEEDED(hr));
}

void ShutdownProvider(DWORD *pdwClassFac)
{
	// Delete the Initializer objects
	CoRevokeClassObject(pdwClassFac[0]);
}

BOOL ParseCommandLine ()
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;

		if ( t_Arg )
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
			    ExeRegisterServer();
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
			    ExeUnregisterServer();
			}
            else if(_tcsicmp(t_Arg, _TEXT ( "/EMBEDDING" ) ) == 0)
		    {
			    // COM called us, so this is the real thing...
                t_Exit = FALSE;
		    }
		}
	}

	return t_Exit ;
}

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsStart ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"WMI ISAPI Remoter" ;

	WNDCLASS  t_wc ;

	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;

	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	if (t_HWnd)
	{
		ShowWindow ( t_HWnd, SW_SHOW ) ;
	}

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	DestroyWindow ( a_HWnd ) ;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;

        if ( s_Exiting )
            return ;
	}
}


int WINAPI WinMain (

    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
    // Initialize the COM Library.
	HRESULT hr = COMInit();

	BOOL t_Exit = ParseCommandLine();

	if (!t_Exit)
	{
		HWND hWnd = WindowsStart(hInstance);

		if (hWnd)
		{
			DWORD dwCookie = 0;

			if (StartupProvider(&dwCookie))
			{
				WindowsDispatch();
				ShutdownProvider(&dwCookie);
			}

			WindowsStop(hWnd);
		}
	}

	// Uninitialize the COM Library.
	::CoUninitialize() ;

	return 0 ;
}


////////////////////////////////////////////////////////////////////
// Strings used during self registration
////////////////////////////////////////////////////////////////////
LPCTSTR LOCALSRV32_STR			= __TEXT("LocalServer32");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR BOTH_STR				= __TEXT("Both");

LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");

// WMI ISAPI Remoter
LPCTSTR WMIISAPI_NAME_STR		= __TEXT("WMI ISAPI Remoter");

#define REG_FORMAT2_STR			_T("%s%s")
#define REG_FORMAT3_STR			_T("%s%s\\%s")
#define VER_IND_STR				_T("VersionIndependentProgID")
#define NOT_INTERT_STR			_T("NotInsertable")
#define PROGID_STR				_T("ProgID")
#define THREADING_MODULE_STR	_T("ThreadingModel")

#define CLSID_STR				_T("CLSID\\")


/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


//***************************************************************************
//
// ExeRegisterServer
//
// Purpose: Called when /register is specified on the command line.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI ExeRegisterServer(void)
{
	TCHAR szModule[MAX_PATH + 1];
	HINSTANCE hInst = GetModuleHandle(_T("DSPROV"));
	GetModuleFileName(hInst,(TCHAR*)szModule, MAX_PATH + 1);

	TCHAR szWMIISAPIClassID[128];
	TCHAR szWMIISAPICLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WmiISAPI, szWMIISAPIClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWMIISAPIClassID[128];
	if(StringFromGUID2(CLSID_WmiISAPI, wszWMIISAPIClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWMIISAPIClassID, -1, szWMIISAPICLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWMIISAPICLSIDClassID, CLSID_STR);
	_tcscat(szWMIISAPICLSIDClassID, szWMIISAPIClassID);

	//
	// Create entries under CLSID for DS Class Provider
	//
	if (FALSE == SetKeyAndValue(szWMIISAPICLSIDClassID, NULL, NULL, WMIISAPI_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWMIISAPICLSIDClassID, LOCALSRV32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWMIISAPICLSIDClassID, LOCALSRV32_STR, THREADING_MODEL_STR, BOTH_STR))
		return SELFREG_E_CLASS;


	return S_OK;
}

//***************************************************************************
//
// ExeUnregisterServer
//
// Purpose: Called when /unregister is specified on the command line.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI ExeUnregisterServer(void)
{
	TCHAR szModule[MAX_PATH + 1];
	HINSTANCE hInst = GetModuleHandle(_T("DSPROV"));
	GetModuleFileName(hInst,(TCHAR*)szModule, MAX_PATH + 1);


	TCHAR szWMIISAPIClassID[128];
	TCHAR szWMIISAPICLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WmiISAPI, szWMIISAPIClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWMIISAPIClassID[128];
	if(StringFromGUID2(CLSID_WmiISAPI, wszWMIISAPIClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWMIISAPIClassID, -1, szWMIISAPICLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWMIISAPICLSIDClassID, CLSID_STR);
	_tcscat(szWMIISAPICLSIDClassID, szWMIISAPIClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szWMIISAPICLSIDClassID, LOCALSRV32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szWMIISAPIClassID))
		return SELFREG_E_CLASS;

}



/////////////////////////////////////////////////////////////////////////////
HRESULT COMInit()
{
    HRESULT hr;
    PFNCOINITIALIZESECURITY pfnCoInitializeSecurity = NULL;
    PFNCOINITIALIZEEX pfnCoInitializeEx = NULL;


    //Get handle to COM library
    HMODULE ghOle32 = LoadLibraryEx(_T("ole32.dll"), NULL, 0);

    if(ghOle32 != NULL)
    {
	    //Get ptr to functions CoInitialize and CoInitializeSecurity.
        pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress(ghOle32,
                                                   "CoInitializeEx");
        pfnCoInitializeSecurity = (PFNCOINITIALIZESECURITY) GetProcAddress(ghOle32,
                                             "CoInitializeSecurity");

        //Initialize COM
	    if (pfnCoInitializeEx)
	    {
	        hr = pfnCoInitializeEx(NULL, COINIT_MULTITHREADED);
        }
	    else
	    {
            hr = CoInitialize(NULL);
	    }

	    if(FAILED(hr))
	    {
		    FreeLibrary(ghOle32);
            ghOle32 = NULL;
            return E_FAIL;
	    }

	    //Initialize Security
	    if (pfnCoInitializeSecurity)
	    {
		    hr = pfnCoInitializeSecurity(NULL, -1, NULL, NULL,
		      							   RPC_C_AUTHN_LEVEL_NONE,
			       						   RPC_C_IMP_LEVEL_IMPERSONATE,
     				   					   NULL, EOAC_NONE, 0);
        }

	    if(FAILED(hr))
	    {
	        CoUninitialize();
	        FreeLibrary(ghOle32);
            ghOle32 = NULL;
	        return E_FAIL;
	    }

    }
    else
    {
	    return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\cwmixmlst.h ===
#ifndef CWMIXMLTransport_H
#define CWMIXMLTransport_H


class CWMIXMLTransport : public IWmiXMLTransport, public IWbemTransport 
{
private:
    long m_ReferenceCount ;
	DWORD m_dwClassFac;
	BOOLEAN m_bRegisteredClassObject;
	DWORD m_bProcessID;


public:
	CWMIXMLTransport();
	virtual ~CWMIXMLTransport();

	// Members of IUnknown
	STDMETHODIMP QueryInterface (REFIID iid, LPVOID FAR *iplpv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Members of IWbemTransport
	virtual HRESULT STDMETHODCALLTYPE Initialize();

	// Members of IWmiXMLTransport
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConnectUsingToken( 
            /* [in] */ DWORD_PTR dwToken,
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWmiXMLWbemServices **ppNamespace);
        
	virtual	HRESULT STDMETHODCALLTYPE GetPID(
		/*[out] */	DWORD *pdwPID
		)
	{
		*pdwPID = m_bProcessID;
		return S_OK;
	}


};

#endif // CWMIXMLTransport_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\maindll.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************
#include "precomp.h"
#include <tchar.h>
#include <olectl.h>

/* WMISAPI includes */
#include <wbemtran.h>
#include "globals.h"
#include "wmixmlst.h"
#include "wmixmlstf.h"
#include "cwmixmlst.h"

// HANDLE of the DLL
HINSTANCE   g_hInst = NULL;

// Count of locks
long g_lComponents = 0;
// Count of active locks
long g_lServerLocks = 0;


//***************************************************************************
//
// DllMain
//
// Description: Entry point for DLL.  Good place for initialization.
// Parameters: The standard DllMain() parameters
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (
	HINSTANCE hInstance,
	ULONG ulReason ,
	LPVOID pvReserved
)
{
	g_hInst = hInstance;
	BOOL status = TRUE ;

    if ( DLL_PROCESS_ATTACH == ulReason )
		status = TRUE ;
    else if ( DLL_PROCESS_DETACH == ulReason )
		status = TRUE ;
    else if ( DLL_THREAD_DETACH == ulReason )
		status = TRUE ;
    else if ( DLL_THREAD_ATTACH == ulReason )
		status = TRUE ;

    return status ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Description: Called by COM when some client wants a a class factory.
//
//	Parameters: Ths standard DllGetClassObject() parameters
//
//	Return Value: S_OK only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (
	REFCLSID rclsid ,
	REFIID riid,
	void **ppv
)
{
	HRESULT status = S_OK ;

	if ( rclsid == CLSID_WmiXMLTransport )
	{
		CWMIXMLTransportFactory *lpunk = NULL;
		lpunk = new CWMIXMLTransportFactory ;

		if(lpunk)
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
				delete lpunk ;
		}
		else
			status = E_OUTOFMEMORY ;
	}
	else
		status = CLASS_E_CLASSNOTAVAILABLE ;
	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Description: Called periodically by COM in order to determine if the
// DLL can be unloaded.
//
// Return Value: S_OK if there are no objects in use and the class factory
// isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	if(g_lServerLocks == 0 && g_lComponents == 0)
		return S_OK;
	else
		return S_FALSE;
}

/***************************************************************************
 *
 * SetKeyAndValue
 *
 * Description: Helper function for DllRegisterServer that creates
 * a key, sets a value, and closes that key. If pszSubkey is NULL, then
 * the value is created for the pszKey key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValueName    LPTSTR to the value name to use
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteKey
 *
 * Description: Helper function for DllUnRegisterServer that deletes the subkey
 * of a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


//***************************************************************************
//
// AddTransportEntry
//
// Purpose: Adds transport section entries in the registry
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

SCODE AddTransportEntry(CLSID clsid, TCHAR * pShortName, TCHAR * pDesc, TCHAR * pVersion)
{

    HKEY h1 = NULL, h2 = NULL, h3 = NULL, h4 = NULL, h5 = NULL;
    DWORD dwDisp;
    DWORD dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\MICROSOFT"),
                        0, KEY_ALL_ACCESS, &h1);

    dwStatus = RegCreateKeyEx(h1, __TEXT("WBEM"), 0, 0, 0, KEY_ALL_ACCESS,
        0, &h2, &dwDisp);

    if(dwStatus == 0)
        dwStatus = RegCreateKeyEx(h2, __TEXT("Cimom"), 0, 0, 0, KEY_ALL_ACCESS,
            0, &h3, &dwDisp);

    if(dwStatus == 0)
        dwStatus = RegCreateKeyEx(h3, __TEXT("Transports"), 0, 0, 0, KEY_ALL_ACCESS,
            0, &h4, &dwDisp);

    if(dwStatus == 0)
        dwStatus = RegCreateKeyEx(h4, pShortName, 0, 0, 0, KEY_ALL_ACCESS,
            0, &h5, &dwDisp);

    if(dwStatus == 0)
    {
        dwStatus = RegSetValueEx(h5, __TEXT("Enabled"), 0, REG_SZ, (BYTE *)"1", 2);
        dwStatus = RegSetValueEx(h5, __TEXT("Name"), 0, REG_SZ, (BYTE *)pShortName, (_tcslen(pShortName)+1)*sizeof(TCHAR));
        dwStatus = RegSetValueEx(h5, __TEXT("Version"), 0, REG_SZ, (BYTE *)pVersion, (_tcslen(pVersion)+1)*sizeof(TCHAR));

        WCHAR      wcID[50];
        // Create the guid.

        if(StringFromGUID2(clsid, wcID, 50))
        {
            dwStatus = RegSetValueEx(h5, __TEXT("CLSID"), 0, REG_SZ, (BYTE *)wcID, (_tcslen(wcID)+1)*sizeof(TCHAR));
        }

    }

    if(h5)
        RegCloseKey(h5);
    if(h4)
        RegCloseKey(h4);
    if(h3)
        RegCloseKey(h3);
    if(h2)
        RegCloseKey(h2);
    if(h1)
        RegCloseKey(h1);

    return S_OK;
}

//***************************************************************************
//
// RemoveTransportEntry
//
// Purpose: Removes transport section entries in the registry
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

SCODE RemoveTransportEntry(TCHAR * pShortName)
{
    DWORD dwRet;
    HKEY hKey;
    TCHAR cKey[MAX_PATH];
    lstrcpy(cKey, __TEXT("SOFTWARE\\MICROSOFT\\WBEM\\Cimom\\transports"));

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, cKey, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,pShortName);
        RegCloseKey(hKey);
    }

    lstrcpy(cKey, __TEXT("SOFTWARE\\MICROSOFT\\WBEM\\Cimom"));

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, cKey, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,__TEXT("transports"));
        RegCloseKey(hKey);
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////
// Strings used during self registration
////////////////////////////////////////////////////////////////////
LPCTSTR INPROC32_STR			= __TEXT("InprocServer32");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR BOTH_STR				= __TEXT("Both");

LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");

// WMI ISAPI Remoter
LPCTSTR WMIISAPI_NAME_STR		= __TEXT("WMI ISAPI Remoter");


STDAPI DllRegisterServer()
{

	TCHAR szModule[512];
	GetModuleFileName(g_hInst, szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szWMIISAPIClassID[128];
	TCHAR szWMIISAPICLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WmiXMLTransport, szWMIISAPIClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWMIISAPIClassID[128];
	if(StringFromGUID2(CLSID_WmiXMLTransport, wszWMIISAPIClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWMIISAPIClassID, -1, szWMIISAPICLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWMIISAPICLSIDClassID, CLSID_STR);
	_tcscat(szWMIISAPICLSIDClassID, szWMIISAPIClassID);

	//
	// Create entries under CLSID for DS Class Provider
	//
	if (FALSE == SetKeyAndValue(szWMIISAPICLSIDClassID, NULL, NULL, WMIISAPI_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWMIISAPICLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWMIISAPICLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, BOTH_STR))
		return SELFREG_E_CLASS;


    AddTransportEntry(CLSID_WmiXMLTransport, __TEXT("XmlTransport"),__TEXT("WMI XML Transport"), __TEXT("1.0"));

	return S_OK;
}


STDAPI DllUnregisterServer(void)
{
    RemoveTransportEntry(__TEXT("XmlTransport"));

	TCHAR szModule[512];
	GetModuleFileName(g_hInst,szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szWMIISAPIClassID[128];
	TCHAR szWMIISAPICLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WmiXMLTransport, szWMIISAPIClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWMIISAPIClassID[128];
	if(StringFromGUID2(CLSID_WmiXMLTransport, wszWMIISAPIClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWMIISAPIClassID, -1, szWMIISAPICLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWMIISAPICLSIDClassID, CLSID_STR);
	_tcscat(szWMIISAPICLSIDClassID, szWMIISAPIClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szWMIISAPICLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szWMIISAPIClassID))
		return SELFREG_E_CLASS;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\precomp.h ===
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\wmixmlstf.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//
//***************************************************************************
#include "precomp.h"
#include <tchar.h>
#include <comdef.h>

#include <wbemtran.h>
#include "globals.h"
#include "wmixmlst.h"
#include "wmixmlstf.h"
#include "cwmixmlst.h"


//***************************************************************************
//
// CWMIXMLTransportFactory::CWMIXMLTransportFactory
// CWMIXMLTransportFactory::~CWMIXMLTransportFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CWMIXMLTransportFactory :: CWMIXMLTransportFactory ()
{
	m_ReferenceCount = 0 ;
}

CWMIXMLTransportFactory::~CWMIXMLTransportFactory ()
{
}

//***************************************************************************
//
// CWMIXMLTransportFactory::QueryInterface
// CWMIXMLTransportFactory::AddRef
// CWMIXMLTransportFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CWMIXMLTransportFactory::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CWMIXMLTransportFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CWMIXMLTransportFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CWMIXMLTransportFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CWMIXMLTransportFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		CWMIXMLTransport *lpunk = NULL;
		lpunk = new CWMIXMLTransport();
		if(!lpunk)
			status = E_OUTOFMEMORY ;
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
	}

	return status ;
}

//***************************************************************************
//
// CWMIXMLTransportFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CWMIXMLTransportFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\xmlsec.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    CALLSEC.H

Abstract:

    IWbemCallSecurity, IServerSecurity implementation for
    provider impersonation.

History:

    raymcc      29-Jul-98        First draft.

--*/


#ifndef _XML_CALLSEC_H_
#define _XML_CALLSEC_H_

//***************************************************************************
//
//  CXmlCallSecurity
//
//  This object is used to supply client impersonation to providers.
//
//***************************************************************************

class CXmlCallSecurity : public IServerSecurity
{
    LONG    m_lRef;                     // COM ref count
    HANDLE  m_hThreadToken;             // Client token for impersonation

    DWORD   m_dwPotentialImpLevel;      // Potential RPC_C_IMP_LEVEL_ or 0
    DWORD   m_dwActiveImpLevel;         // Active RPC_C_IMP_LEVEL_ or 0
    

    // IServerSecurity::QueryBlanket values
    
    DWORD   m_dwAuthnSvc;               // Authentication service 
    DWORD   m_dwAuthzSvc;               // Authorization service
    DWORD   m_dwAuthnLevel;             // Authentication level
    LPWSTR  m_pServerPrincNam;          // 
    LPWSTR  m_pIdentity;                // User identity
    

public:
    CXmlCallSecurity(HANDLE hToken);
   ~CXmlCallSecurity();

    // IUnknown.
    // =========

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();        
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);


    // IServerSecurity.
    // ================
    virtual HRESULT STDMETHODCALLTYPE QueryBlanket( 
            /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
            /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
            /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
            /* [out] */ DWORD __RPC_FAR *pImpLevel,
            /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
            /* [out] */ DWORD __RPC_FAR *pCapabilities
            );
    virtual HRESULT STDMETHODCALLTYPE ImpersonateClient( void);
    virtual HRESULT STDMETHODCALLTYPE RevertToSelf( void);
    virtual BOOL STDMETHODCALLTYPE IsImpersonating( void);

	// Helper function
	static HRESULT SwitchCOMToThreadContext(HANDLE hToken, IUnknown **pOldContext);

	HRESULT CloneThreadContext();
	HRESULT CloneThreadToken();
};
            


#endif // _XML_CALLSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\wmixmlstf.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_TRANSPORT_CLASS_FACTORY_H
#define WMI_XML_TRANSPORT_CLASS_FACTORY_H


////////////////////////////////////////////////////////////////
//////
//////		The WMI ISAPI class factory
//////
///////////////////////////////////////////////////////////////
class CWMIXMLTransportFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:


    CWMIXMLTransportFactory () ;
    ~CWMIXMLTransportFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;

};

#endif // WMI_XML_TRANSPORT_CLASS_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\xmltrans\wmixmlst\xmlsec.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    CALLSEC.CPP

Abstract:

    IWbemCallSecurity, IServerSecurity implementation for
    provider impersonation.

History:

    raymcc      29-Jul-98        First draft.

--*/
#include "precomp.h"
#include <xmlsec.h>

//***************************************************************************
//
//  CXmlCallSecurity
//
//  This object is used to supply client impersonation to providers.
//
//  Usage:
//  (1) When client first makes call, call CreateInst() and get a new
//      empty object (ref count of 1).  Constructors/Destructors are private.
//
//***************************************************************************
// ok

CXmlCallSecurity::CXmlCallSecurity(HANDLE hToken)
{
	// Ref count
    m_lRef = 1;
	// Duplicate and store the thread token for later use
	m_hThreadToken = NULL;
	DuplicateHandle(GetCurrentProcess(), hToken, GetCurrentProcess(), &m_hThreadToken, 0, FALSE, DUPLICATE_SAME_ACCESS);

    m_dwPotentialImpLevel   = 0;            // Potential
    m_dwActiveImpLevel      = 0;            // Active impersonation

    m_dwAuthnSvc   = 0;
    m_dwAuthzSvc   = 0;
    m_dwAuthnLevel = 0;

    m_pServerPrincNam = 0;
    m_pIdentity = 0;

}



//***************************************************************************
//
//  ~CXmlCallSecurity
//
//  Destructor.  Closes any open handles, deallocates any non-NULL
//  strings.
//
//***************************************************************************
// ok

CXmlCallSecurity::~CXmlCallSecurity()
{
    if (m_hThreadToken)
        CloseHandle(m_hThreadToken);

    if (m_pServerPrincNam)
        CoTaskMemFree(m_pServerPrincNam);

    if (m_pIdentity)
        CoTaskMemFree(m_pIdentity);
}


//***************************************************************************
//
//  CXmlCallSecurity::AddRef
//
//***************************************************************************
// ok

ULONG CXmlCallSecurity::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CXmlCallSecurity::Release
//
//***************************************************************************
// ok

ULONG CXmlCallSecurity::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CXmlCallSecurity::QueryInterface
//
//***************************************************************************
// ok

HRESULT CXmlCallSecurity::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
    {
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IServerSecurity)
    {
        *ppv = (IServerSecurity *) this;
        AddRef();
        return S_OK;
    }

    else return E_NOINTERFACE;
}


//***************************************************************************
//
// CXmlCallSecurity:QueryBlanket
//
//***************************************************************************
// ok

HRESULT STDMETHODCALLTYPE CXmlCallSecurity::QueryBlanket(
    /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
    /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
    /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
    /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
    /* [out] */ DWORD __RPC_FAR *pImpLevel,
    /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
    /* [out] */ DWORD __RPC_FAR *pCapabilities
    )
{
    if (m_dwPotentialImpLevel == 0 || m_hThreadToken == 0)
        return E_FAIL;

    // Return DWORD parameters, after checking.
    // ========================================

    if (pAuthnSvc)
        *pAuthnSvc = m_dwAuthnSvc;

    if (pAuthzSvc)
        *pAuthzSvc = m_dwAuthzSvc;

    if (pAuthnLevel)
        *pAuthnLevel = m_dwAuthnLevel;

    if (pServerPrincName)
    {
        *pServerPrincName = 0;

        if (m_pServerPrincNam)
        {
            *pServerPrincName = (LPWSTR) CoTaskMemAlloc((wcslen(m_pServerPrincNam) + 1) * 2);
            wcscpy(*pServerPrincName, m_pServerPrincNam);
        }
    }

    if (pPrivs)
    {
        *pPrivs = m_pIdentity;  // Documented to point to an internal!!
    }

    return S_OK;
}

//***************************************************************************
//
//  CXmlCallSecurity::ImpersonateClient
//
//***************************************************************************
// ok

HRESULT STDMETHODCALLTYPE CXmlCallSecurity::ImpersonateClient(void)
{
    if (m_dwActiveImpLevel != 0)        // Already impersonating
        return S_OK;

    if (m_dwPotentialImpLevel == 0)
        return (ERROR_CANT_OPEN_ANONYMOUS | 0x80070000);

    BOOL bRes;
    bRes = SetThreadToken(NULL, m_hThreadToken);

    if (bRes)
    {
        m_dwActiveImpLevel = m_dwPotentialImpLevel;
        return S_OK;
    }

    return E_FAIL;
}


//***************************************************************************
//
//  CXmlCallSecurity::RevertToSelf
//
//  Returns S_OK or E_FAIL.
//  Returns E_NOTIMPL on Win9x platforms.
//
//***************************************************************************
// ok

HRESULT STDMETHODCALLTYPE CXmlCallSecurity::RevertToSelf( void)
{
    if (m_dwActiveImpLevel == 0)
        return S_OK;

    if (m_dwPotentialImpLevel == 0)
        return (ERROR_CANT_OPEN_ANONYMOUS | 0x80070000);

    // If here,we are impersonating and can definitely revert.
    // =======================================================

    BOOL bRes = SetThreadToken(NULL, NULL);

    if (bRes == FALSE)
        return E_FAIL;

    m_dwActiveImpLevel = 0;        // No longer actively impersonating

    return S_OK;
}


//***************************************************************************
//
//  CXmlCallSecurity::IsImpersonating
//
//***************************************************************************

BOOL STDMETHODCALLTYPE CXmlCallSecurity::IsImpersonating( void)
{
    if (m_dwActiveImpLevel != 0)
        return TRUE;

    return FALSE;
}


//***************************************************************************
//
//  CXmlCallSecurity::CloneThreadContext
//
//  Call this on a thread to retrieve the potential impersonation info for
//  that thread and set the current object to be able to duplicate it later.
//
//  Return codes:
//
//  S_OK
//  E_FAIL
//  E_NOTIMPL on Win9x
//  E_ABORT if the calling thread is already impersonating a client.
//
//***************************************************************************

HRESULT CXmlCallSecurity::CloneThreadContext()
{
    // Get the current context.
    // ========================
    IServerSecurity *pSec = 0;
    HRESULT hRes = E_FAIL;
	
	if(SUCCEEDED(hRes = CoGetCallContext(IID_IServerSecurity, (LPVOID *) &pSec)))
	{
		// If here, we are not impersonating and we want to gather info
		// about the client's call.
		// ============================================================

		if(SUCCEEDED(hRes = pSec->QueryBlanket(
			&m_dwAuthnSvc,
			&m_dwAuthzSvc,
			&m_pServerPrincNam,
			&m_dwAuthnLevel,
			NULL,
			NULL,              // RPC_AUTHZ_HANDLE
			NULL                    // Capabilities; not used
			)))
		{
			// Get the SID from the Token
			DWORD dwLength = 0;
			if(GetTokenInformation(m_hThreadToken, TokenUser, NULL, dwLength, &dwLength))
			{
				PTOKEN_USER pUserInfo = NULL;
				if(pUserInfo = (PTOKEN_USER) new BYTE [dwLength])
				{
					if(GetTokenInformation(m_hThreadToken, TokenUser, pUserInfo, dwLength, &dwLength))
					{
						PSID pSid = pUserInfo->User.Sid;
						if(IsValidSid(pSid))
						{
							TCHAR pszAccountName[100];
							DWORD dwAccountNameSize = 100;
							TCHAR pszDomainName[100];
							DWORD dwDomainNameSize = 100;
							SID_NAME_USE accountType;
							// Get its user account name
							if(LookupAccountSid(NULL, pSid,  pszAccountName,  &dwAccountNameSize, pszDomainName, &dwDomainNameSize, &accountType))
							{
								m_pIdentity = NULL;
								if(m_pIdentity = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR)*(dwDomainNameSize + 1 + dwAccountNameSize + 1)) )
								{
									wcscpy(m_pIdentity, pszDomainName);
									wcscat(m_pIdentity, L"\\");
									wcscat(m_pIdentity, pszAccountName);
								}
								else
									hRes = E_OUTOFMEMORY;
							}
							else
								hRes = E_FAIL;
						}
						else
							hRes = E_FAIL;
					}
					else
						hRes = E_FAIL;
				}
				else
					hRes = E_OUTOFMEMORY;
			}
			else
				hRes = E_FAIL;
		}
		pSec->Release();
	}

	if(SUCCEEDED(hRes))
		hRes = CloneThreadToken();

	return hRes;
}


HRESULT CXmlCallSecurity::CloneThreadToken()
{

    DWORD dwTmp = 0, dwBytesReturned = 0;

    GetTokenInformation(
        m_hThreadToken,
        TokenImpersonationLevel,
        &dwTmp,
        sizeof(DWORD),
        &dwBytesReturned
        );

    switch (dwTmp)
    {
        case SecurityAnonymous:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
            break;

        case SecurityIdentification:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            break;

        case SecurityImpersonation:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            break;

        case SecurityDelegation:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
            break;

        default:
            m_dwPotentialImpLevel = 0;
            break;
    }

    return S_OK;
}

HRESULT CXmlCallSecurity::SwitchCOMToThreadContext(HANDLE hToken, IUnknown **pOldContext)
{
	HRESULT result = E_FAIL;

	// Duplcate the thread token so that you have query access for impersonation
	HANDLE hNewToken = NULL;
	if(DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS,  NULL, SecurityImpersonation, TokenImpersonation, &hNewToken))
	{
		// Set the thread token
		if(ImpersonateLoggedOnUser(hNewToken))
		{
			/*
			WCHAR wName[256]; DWORD dwSize = 256;
			GetUserName(wName, &dwSize);
			*/

			// Set the COM Call context - The destructor of this will close the token handle
			CXmlCallSecurity *pXmlContext = NULL;
			if(pXmlContext = new CXmlCallSecurity(hNewToken))
			{
				if(SUCCEEDED(result = pXmlContext->CloneThreadContext()))
				{
					if(SUCCEEDED(result = CoSwitchCallContext(pXmlContext, pOldContext)))
					{
					}
				} 

				// This is born with a refcount of 1 - so we can release it
				pXmlContext->Release();
			}
			else
				result = E_OUTOFMEMORY;

			if(FAILED(result))
				::RevertToSelf();
		} // Impersonate()

		CloseHandle(hNewToken);
	}
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\classfac.cpp ===
//***************************************************************************/
//
//  CLASSFAC.CPP
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)1997-2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************/
#include "precomp.h"

#include "wmi2xsdguids.h"

#include "wmitoxml.h"
#include <wmi2xsd.h>
#include "wmixmlconverter.h"

#include "classfac.h"
////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CEncoderClassFactory::CEncoderClassFactory(const CLSID & ClsId)
{
    m_cRef=0L;
    InterlockedIncrement((LONG *) &g_cObj);
    m_ClsId = ClsId;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////
CEncoderClassFactory::~CEncoderClassFactory(void)
{
    InterlockedDecrement((LONG *) &g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Standard Ole routines needed for all interfaces
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEncoderClassFactory::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv=this;
    }

    if (NULL!=*ppv)
    {
        AddRef();
        hr = S_OK;
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEncoderClassFactory::AddRef(void)
{
    return InterlockedIncrement((long*)&m_cRef);
}
/////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEncoderClassFactory::Release(void)
{
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if ( !cRef ){
		delete this;
		return 0;
	}
	return cRef;
}
////////////////////////////////////////////////////////////////////////////////////////
//
// Instantiates an object returning an interface pointer.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEncoderClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj)
{
    HRESULT   hr = E_OUTOFMEMORY;
    IUnknown* pObj = NULL;

    *ppvObj=NULL;

    //==================================================================
    // This object doesnt support aggregation.
    //==================================================================

    if (NULL!=pUnkOuter)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else
    {
        //==============================================================
        //Create the object passing function to notify on destruction.
        //==============================================================
        if (m_ClsId == CLSID_WMIXMLConverter)
        {
			pObj = new CWmiXMLConverter;
			if(!pObj)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				hr = ((CWmiXMLConverter *)pObj)->FInit();

			}
        }
        else if (m_ClsId == CLSID_XMLWMIConverter)
        {
	        // FIXX create XMLTOXMI object
			if(!pObj)
			{
				hr = E_OUTOFMEMORY;
			}
        }

        if(pObj)
        {
            hr = pObj->QueryInterface(riid, ppvObj);
	    }

    }

    //===================================================================
    //Kill the object if initial creation or Init failed.
    //===================================================================
    if (FAILED(hr))
    {
        SAFE_DELETE_PTR(pObj);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEncoderClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\classfac.h ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  classfac.h
//
//  ramrao 13 Nov 2000 - Created
//
//
//		Declaration of CEncoderClassFactory class
//		Class Factory implementation for Encoder
//
//***************************************************************************/
#ifndef _XML_ENCODER_HEADER
#define _XML_ENCODER_HEADER

////////////////////////////////////////////////////////////////////
//
// This class is the class factory for Encoder objects.
//
////////////////////////////////////////////////////////////////////

class CEncoderClassFactory : public IClassFactory 
{

    protected:
        ULONG   m_cRef;
        CLSID	m_ClsId;

    public:
        CEncoderClassFactory(const CLSID & ClsId);
        virtual ~CEncoderClassFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void **);
        STDMETHODIMP         LockServer(BOOL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\enum.cpp ===
/***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  enum.cpp
//
//  ramrao 9th Dec 2001
//
//
//		Declaration for a util class for enumerator
//
//***************************************************************************/

#include <precomp.h>
#include <enum.h>

CEnumObject::CEnumObject(ENUMTYPE eType)
{
	m_lEnumType		= eType;
	m_Position		= 0;
	m_lFlags		= 0;
	m_EnumState		= ENUM_NOTACTIVE;
}

 
CEnumObject::~CEnumObject()
{
	CleanLinkedList();
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Removes an item from the list if present
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::RemoveItem(WCHAR * pwsName)
{
	CHashElement *	pItem	= NULL;
	HRESULT			hr			= S_OK;
	LONG			lPos		= 0;

	if(pItem = (CHashElement *)m_HashTbl.Find(pwsName))
	{
		m_HashTbl.Remove(pwsName);
		RemoveNameFromList(pwsName);
		SAFE_DELETE_PTR(pItem);

	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to set begin enumeration on the qualifier set
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::BeginEnumeration(long lFlags)
{
	HRESULT hr = S_OK;
	if(SUCCEEDED(hr = IsValidFlags(lFlags)))
	{
		m_EnumState		= ENUM_ACTIVE;
		m_Position		= 0;
		m_lFlags		= lFlags;
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// delete all entries in the linked list and empty the linked list
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::CleanLinkedList()
{
	HRESULT		hr				= S_OK;
	int			nSizeofArray	= m_Names.GetSize();
	void *		pItem			= NULL;
	WCHAR	*	szName			= NULL;

	for(int nIndex = 0 ;nIndex < nSizeofArray;nIndex++)
	{
		szName = (WCHAR *)m_Names[nIndex];
		if(pItem = m_HashTbl.Find(szName))
		{
			m_HashTbl.Remove(szName);
			SAFE_DELETE_PTR(pItem);
		}
		SAFE_DELETE_ARRAY(szName);
	}
	m_Names.RemoveAll();
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to get names of all the item in the qualifier set
//
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::GetNames(long lFlags,SAFEARRAY * *pNames)
{
	HRESULT hr = WBEM_E_UNEXPECTED;
	LONG lNames = 0;

	LONG cElems = m_Names.GetSize();
	BSTR *strNames = new BSTR[cElems];

	if(strNames)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		LONG		cNames	= 0;
		LONG		lIndex	= 0;
		CHashElement *pElem = NULL;
		for(lIndex = 0 ; lIndex < (LONG)cElems && SUCCEEDED(hr) ; lIndex++)
		{
			strNames[lIndex] = NULL;
			Get((LPCWSTR)m_Names[lIndex],lFlags ,pElem);
			if(pElem)
			{
				if(NULL == (strNames[lIndex] = SysAllocString((WCHAR *)m_Names[lIndex])))
				{
					hr = E_OUTOFMEMORY;
				}
				cNames++;
			}
			pElem = NULL;
		}
		
		if(SUCCEEDED(hr))
		{
			SAFEARRAYBOUND rgsabound[1];

			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= cNames;
			*pNames = SafeArrayCreate(VT_BSTR,1,rgsabound);
			
			if(!(*pNames))
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

			for(lIndex = 0 ; lIndex < cNames && SUCCEEDED(hr) ; lIndex++)
			{
				hr = SafeArrayPutElement(*pNames,&lIndex,strNames[lIndex]);
				SAFE_FREE_SYSSTRING(strNames[lIndex]);
			}

			if(FAILED(hr))
			{
				SafeArrayDestroy(*pNames);
				*pNames = NULL;
			}
		}

		SAFE_DELETE_ARRAY(strNames);
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to end the  enumeration
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::EndEnumeration(void)
{
	HRESULT hr = S_OK;
	m_EnumState		= ENUM_NOTACTIVE;
	m_lFlags		= 0;
	m_Position		= 0;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to fetch a item
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::Get(	LPCWSTR wszName,
								long lFlags,
								CHashElement *& pElement)
{
	HRESULT hr = S_OK;
	if(wszName && lFlags != 0  )
	{
		pElement = (CHashElement *)m_HashTbl.Find(wszName);
		if(!pElement)
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}

	if(SUCCEEDED(hr) && (S_OK != (hr = IsValidPropForEnumFlags(pElement,lFlags))))
	{
		pElement = NULL;
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if a given flag is valid
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::IsValidFlags(LONG lFlags)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	if(lFlags ==0 || lFlags == WBEM_FLAG_LOCAL_ONLY || lFlags == WBEM_FLAG_PROPAGATED_ONLY)
	{
		hr = S_OK;
	}
	return hr;
		
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if a given qualifier flavor is valid
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::IsValidFlavor(LONG lFlavor)
{
	LONG lTempFlavor =	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS ||
						WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	||
						WBEM_FLAVOR_NOT_OVERRIDABLE	||
						WBEM_FLAVOR_OVERRIDABLE	||
						WBEM_FLAVOR_AMENDED;

	return (lFlavor | ~lTempFlavor) ? E_FAIL : S_OK;
	

}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to get the next qualifier in the qualifier set
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::Next(long lFlags,
							BSTR *pstrName,
							CHashElement *& pElement)
{
	HRESULT hr = S_OK;

	if(m_EnumState == ENUM_ACTIVE)
	{
		if(m_Position < m_Names.GetSize())
		{
			// navigate thru the enumerator till we get
			//  the next property satisfying the enumerator flags
			do
			{
				// Get the next item
				pElement = (CHashElement *)m_HashTbl.Find((WCHAR *)m_Names[m_Position]);
				
				if(!pElement)
				{
					hr = WBEM_S_NO_MORE_DATA;
					m_EnumState = ENUM_END;
					break;
				}
				m_Position++;
			}
			while(FAILED(IsValidPropForEnumFlags(pElement)));

			if(SUCCEEDED(hr))
			{
				*pstrName = SysAllocString(pElement->GetKey());
				if(*pstrName)
				{
					hr = S_OK;
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
		}
		else
		{
			m_EnumState = ENUM_END;
			hr = WBEM_S_NO_MORE_DATA;
		}
	}
	else
	if(m_EnumState == ENUM_END)
	{
		hr = WBEM_S_NO_MORE_DATA;
	}
	else
	{
		hr = WBEM_E_UNEXPECTED;
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Removes and deletes name from the array of qualifier names
//  
////////////////////////////////////////////////////////////////////////////////////////
 
void CEnumObject::RemoveNameFromList(LPCWSTR pStrName)
{
	if(pStrName)
	{
		WCHAR *szName = NULL;
		// Remove string from the list
		for(int i = 0 ; i < m_Names.GetSize(); i++)
		{
			szName = (WCHAR *)m_Names.GetAt(i);
			if(_wcsicmp(pStrName,szName) == 0)
			{
				m_Names.RemoveAt(i);
				SAFE_DELETE_ARRAY(szName);
				break;
			}
		}

	}
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a qualilfer to the linked list
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CEnumObject::AddItem(WCHAR * pwsName,CHashElement *pItem)
{
	HRESULT hr = WBEM_E_OUT_OF_MEMORY;


	int nIndex = 0;
	if(SUCCEEDED(hr))
	{
		if(-1 == (nIndex = m_Names.Add(pwsName)))
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			hr = m_HashTbl.Add(pwsName,pItem);
		}

	}
	
	if(FAILED(hr))
	{
		m_Names.RemoveAt(nIndex);
	}

	return hr;
}

HRESULT CEnumObject::IsValidPropForEnumFlags(CHashElement *pElement,LONG lFlags)
{
	HRESULT hr = S_OK;
	lFlags == -1 ? m_lFlags : lFlags;

	// if a flag is passed (which is internal)
	// check if the property satisfies the flag
	if(SUCCEEDED(hr) && lFlags != 0)
	{
		LONG lFlavor = pElement->GetFlavor();
		 // check for system property
		if(!((lFlags & WBEM_FLAG_SYSTEM_ONLY) && 
			(lFlavor & WBEM_FLAVOR_ORIGIN_SYSTEM )))
		{
			hr = E_FAIL;
		}
		
		// check for non system property	
		if(!( (lFlags & WBEM_FLAG_NONSYSTEM_ONLY) &&	
				((lFlavor & WBEM_FLAVOR_ORIGIN_SYSTEM ) == 0) )) 
		{
			hr = E_FAIL;
		}

		// local properties
		if(!((lFlags & WBEM_FLAG_LOCAL_ONLY) && 
			(lFlavor & WBEM_FLAVOR_ORIGIN_LOCAL  )) )
		{
			hr = E_FAIL;
		}
			
		// propogated properties
		if(! ( (lFlags & WBEM_FLAG_PROPAGATED_ONLY) && 
				(lFlavor & WBEM_FLAVOR_ORIGIN_PROPAGATED ) ) ) 	
		{
			hr = E_FAIL;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\critsec.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Generic critical section handling classes
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __CRITSEC_H_
#define __CRITSEC_H_

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The constructor/destructor automatically initializes/deletes the CRITIICAL_SECTION correctly, to ensure 
// that each call is correctly paired, IF the fAutoInit is set to TRUE, otherwise, you have to manually deal
// with this - this is implemented for the static global CS that is required.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CCriticalSection 
{
    public:		

	    inline CCriticalSection(BOOL fAutoInit);		// CTOR. 
	    virtual inline ~CCriticalSection();		                // DTOR.
	    inline void Enter();			                // Enter the critical section
	    inline void Leave();			                // Leave the critical section
//	    inline DWORD OwningThreadId();	                // Returns the "owning" thread id
        inline void Init(void);
        inline void Delete(void);

    private:

        BOOL                m_fAutoInit;
	    CRITICAL_SECTION	m_criticalsection;			// standby critical section
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline CCriticalSection::CCriticalSection(BOOL fAutoInit)
{
    m_fAutoInit = fAutoInit;
    if( m_fAutoInit ){
	    Init();
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CCriticalSection::Init(void)
{
    InitializeCriticalSection(&m_criticalsection);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CCriticalSection::Delete(void)
{
	DeleteCriticalSection(&m_criticalsection);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline CCriticalSection::~CCriticalSection()
{
    if( m_fAutoInit ){
        Delete();
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CCriticalSection::Enter(void)
{
	EnterCriticalSection(&m_criticalsection);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CCriticalSection::Leave(void)
{
	LeaveCriticalSection(&m_criticalsection);
}





class CAutoBlock
{
private:
	CCriticalSection *m_pCriticalSection;

public:
	CAutoBlock(CCriticalSection *pCriticalSection);
	virtual ~CAutoBlock();
};

inline CAutoBlock::CAutoBlock(CCriticalSection *pCriticalSection)
{
	m_pCriticalSection = NULL;
	if(pCriticalSection)
		pCriticalSection->Enter();

	m_pCriticalSection = pCriticalSection;
}

inline CAutoBlock::~CAutoBlock()
{
	if(m_pCriticalSection)
		m_pCriticalSection->Leave();

}



#endif // __CRITSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\enum.h ===
/***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  enum.h
//
//  ramrao 9th Dec 2001
//
//
//		Declaration for a util class for enumerator
//
//***************************************************************************/

#include "hash.h"

typedef enum _enumState
{
	ENUM_NOTACTIVE	= -1,
	ENUM_ACTIVE,
	ENUM_END
}ENUMSTATE;

typedef enum __enumType
{
	PROPERTY_ENUM,
	QUALIFIERS_ENUM,
	METHOD_ENUM
}ENUMTYPE;

class CEnumObject
{
private:
	ENUMTYPE				m_lEnumType;
	CPtrArray 				m_Names;
	LONG					m_Position;
	CStringToPtrHTable		m_HashTbl;
	LONG					m_lFlags;
	ENUMSTATE				m_EnumState;

	HRESULT IsValidFlags(LONG lFlags);
	HRESULT IsValidFlavor(LONG lFlavor);
	void	RemoveNameFromList(LPCWSTR pStrName);
	HRESULT CleanLinkedList();
	HRESULT IsValidPropForEnumFlags(CHashElement *pElement,LONG lFlags = -1);
	
public:
	CEnumObject(ENUMTYPE eType = QUALIFIERS_ENUM);
	~CEnumObject();

	HRESULT BeginEnumeration(long lFlags);
	HRESULT EndEnumeration(void);
	HRESULT Get(LPCWSTR wszName,
				long lFlags,
				CHashElement *& pElement);
	HRESULT Next(long lFlags,
				 BSTR *pstrName,
				CHashElement *& pElement);
	HRESULT RemoveItem(WCHAR * pwsName);
	HRESULT AddItem(WCHAR * pwsName,CHashElement * pItem);
	HRESULT GetNames(long lFlags,SAFEARRAY ** pNames);
	LONG	GetEnumPos() { return m_Position; }
	void	SetEnumPos(LONG lPos) 
	{
		m_Position = lPos; 
	}
	ENUMSTATE	GetEnumState()					{ return m_EnumState; }
	void		SetEnumState(ENUMSTATE eState)	{ m_EnumState = eState; }
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\globals.h ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMIXMLSchema.h
//
//  ramrao 14 Nov 2000 - Created
//
//
//		Global decrlaration for Encoder
//
//***************************************************************************/

#ifndef _GLOBALS_H_

#define _GLOBALS_H_

#include "resource.h"

#define THICOMPONENT L"WMI XSD Encoder"

#define DEFAULTWMIPREFIX	L"wmi"

extern long g_cObj;
extern long g_cLock;
extern HMODULE g_hModule;



#define NOSCHEMATAGS				0x8000

// Diffferent values of WmiElemType attributes
#define WMIPROPERTY			L"property"
#define	WMIQUALIFIER		L"qualifier"
#define WMIMETHOD			L"method"
#define WMIINPARAM			L"inparameter"
#define WMIOUTPARAM			L"outparameter"

// Internal Error values
#define WBEMXML_E_PROPNOTSTARTED		0x80082001
#define WBEMXML_E_METHODNOTSTARTED		0x80082002
#define WBEMXML_E_PARAMNOTSTARTED		0x80082003
#define WBEMXML_E_SCHEMAINCOMPLETE		0x80082004
#define WBEMXML_E_RETURNVALNOTSTARTED	0x80082005
#define WBEMXML_E_INSTANCEINCOMPLETE	0x80082006



extern BSTR g_strStdNameSpace;
extern BSTR g_strStdLoc;
extern BSTR g_strStdPrefix;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\testcli\main.cpp ===
#include <stdio.h>
#include <ole2.h>
#include <wbemcli.h>
#include <objbase.h>
#include <tchar.h>
#include <initguid.h>
#include "wmi2xsd.h"


HRESULT AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW);
void LogToFile(HRESULT hr ,char *pStr);
HRESULT WriteToFile(char * strData ,TCHAR *pFileName = NULL);


int _cdecl main(int argc, char * argv[])
{
	IWbemLocator *pLoc = NULL;
	IWbemServices *pSer = NULL;
	LONG lFlags	= 0;

	if(argc < 3)
	{
		printf("\n testcli <Namespace> <class name>");
		return 0;
	}

	CoInitialize(NULL);

	HRESULT hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_INPROC_SERVER ,IID_IWbemLocator,(void **)&pLoc);

	WCHAR * pTemp = NULL;
	AllocateAndConvertAnsiToUnicode(argv[1],pTemp);

    // Using the locator, connect to WMI in the given namespace.
    BSTR pNamespace = SysAllocString(pTemp);
	delete [] pTemp;

    if(pLoc->ConnectServer(pNamespace,
                            NULL,    //using current account
                            NULL,    //using current password
                            0L,      // locale
                            0L,      // securityFlags
                            NULL,    // authority (NTLM domain)
                            NULL,    // context
                            &pSer) == S_OK) 
	if(FAILED(hr))
	{
		LogToFile(hr ,"ConnectToServer Failed");
		return 0;
	}

    // Done with pNamespace.
    SysFreeString(pNamespace);

    // Done with pIWbemLocator. 
    pLoc->Release(); 

    // Switch security level to IMPERSONATE. 
    CoSetProxyBlanket(pSer,    // proxy
        RPC_C_AUTHN_WINNT,        // authentication service
        RPC_C_AUTHZ_NONE,         // authorization service
        NULL,                         // server principle name
        RPC_C_AUTHN_LEVEL_CALL,   // authentication level
        RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
        NULL,                         // identity of the client
       EOAC_NONE);               // capability flags


	if(SUCCEEDED(hr))
	{
		IWbemClassObject *pObject = NULL;
		IWMIXMLConverter *pConv = NULL;

		AllocateAndConvertAnsiToUnicode(argv[2],pTemp);
		BSTR strPath = SysAllocString(pTemp);
		delete [] pTemp;

		if(argc == 4)
		{
			lFlags = atoi(argv[3]);
		}

		if(FAILED(hr = pSer->GetObject(strPath,WBEM_FLAG_RETURN_WBEM_COMPLETE,NULL,&pObject,NULL)))
		{
			LogToFile(hr ,"GetObject Failed");
			return 0;
		}
		
		hr = CoCreateInstance(CLSID_WMIXMLConverter,NULL, CLSCTX_INPROC_SERVER ,IID_IWMIXMLConverter,(void **)&pConv);
		if(SUCCEEDED(hr))
		{
			IStream *pStream = NULL;
			BSTR strNamespace = SysAllocString(L"http://www.testsvr.com/wmi/root/cimv2");
			BSTR strWmiSchemaLoc = SysAllocString(L"http://www.testsvr.com/wmi/");
			BSTR strWmiNs = SysAllocString(L"http://www.testsvr.com/wmi/wmi.xsd");

			BSTR strSchemaLoc[2];
			strSchemaLoc[0] = SysAllocString(L"http://www.testsrv.com/wmi/root/cimv2/cim_logicaldisk.xsd");
			strSchemaLoc[1] = SysAllocString(L"http://www.testsrv.com/wmi/root/cimv2/cim1_logicaldisk1.xsd");

			BSTR strNSPrefix = SysAllocString(L"test");
			BSTR strwmiPrefix = SysAllocString(L"wmi1");

			hr = CreateStreamOnHGlobal(NULL,TRUE,&pStream);
			if(FAILED(hr))
			{
				LogToFile(hr ,"CreateStreamOnHGlobal Failed");
				return 0;
			}

			hr = pConv->SetXMLNamespace(strNamespace,strNSPrefix);
			if(FAILED(hr))
			{
				LogToFile(hr ,"SetXMLNamespace Failed");
				return 0;
			}

			hr = pConv->SetWMIStandardSchemaLoc(strWmiNs , strWmiSchemaLoc,strwmiPrefix);
			if(FAILED(hr))
			{
				LogToFile(hr ,"SetWMIStandardSchemaLoc Failed");
				return 0;
			}

			hr = pConv->SetSchemaLocations(2,strSchemaLoc);
			if(FAILED(hr))
			{
				LogToFile(hr ,"SetSchemaLocations Failed");
				return 0;
			}

			hr = pConv->GetXMLForObject(pObject,lFlags, pStream);
			if(FAILED(hr))
			{
				LogToFile(hr ,"GetXMLForObject Failed");
				return 0;
			}
/*
			LARGE_INTEGER l;
			ULARGE_INTEGER ul;
			memset(&ul,0,sizeof(ULARGE_INTEGER));
			memset(&l,0,sizeof(LARGE_INTEGER));
			
			hr = pStream->Seek(l ,STREAM_SEEK_SET,(ULARGE_INTEGER *)&l);
			if(FAILED(hr))
			{
				LogToFile(hr ,"Seek Failed");
				return 0;
			}

			hr = pStream->SetSize(ul);
			if(FAILED(hr))
			{
				LogToFile(hr ,"SetSize Failed");
				return 0;
			}
			hr = pConv->SetSchemaLocations(0,NULL);
			if(FAILED(hr))
			{
				LogToFile(hr ,"SetSchemaLocations Failed");
				return 0;
			}
			hr = pConv->GetXMLForObject(pObject,lFlags, pStream);
			if(FAILED(hr))
			{
				LogToFile(hr ,"GetXMLForObject Failed");
				return 0;
			}
*/
			pStream->Release();

			SysFreeString(strNamespace);
			SysFreeString(strWmiNs);
			SysFreeString(strWmiSchemaLoc);
			SysFreeString(strSchemaLoc[0]);
			SysFreeString(strSchemaLoc[1]);
			SysFreeString(strNSPrefix);
			SysFreeString(strwmiPrefix);
		}
		else
		if(FAILED(hr))
		{
			LogToFile(hr ,"CoCreateInstance of WMIXMLConverter failed");
			return 0;
		}

		if(pObject)
		pObject->Release();
		if(pConv)
		pConv->Release();

	}

	CoUninitialize();

	return 0;
}








////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert ANSI to UNICODE string
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW)
{
    HRESULT hr = S_OK;
    pszW = NULL;

	if(pstr)
	{
		int nSize = strlen(pstr);
		if (nSize != 0 )
		{

			// Determine number of wide characters to be allocated for the
			// Unicode string.
			nSize++;
			pszW = new WCHAR[nSize * 2];
			if (NULL != pszW)
			{
				// Covert to Unicode.
				if(MultiByteToWideChar(CP_ACP, 0, pstr, nSize,pszW,nSize))
				{
					hr = S_OK;
				}
				else
				{
					delete [] pszW;
					hr = E_FAIL;
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert UNICODE  to ANSI string
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT UnicodeToAnsi(WCHAR * pszW, char *& pAnsi)
{
    ULONG cbAnsi, cCharacters;
    HRESULT hr = S_OK;

    pAnsi = NULL;
    if (pszW != NULL)
	{

        cCharacters = wcslen(pszW)+1;
        // Determine number of bytes to be allocated for ANSI string. An
        // ANSI string can have at most 2 bytes per character (for Double
        // Byte Character Strings.)
        cbAnsi = cCharacters*2;
		pAnsi = new char[cbAnsi];
		if (NULL != pAnsi)
        {
			// Convert to ANSI.
			if (0 != WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, pAnsi, cbAnsi, NULL, NULL))
			{
				hr = S_OK;
	        }
			else
			{
	            delete [] pAnsi;
				hr = E_FAIL;
			}
        }
		else
		{
			hr = E_OUTOFMEMORY;
		}

    }
    return hr;
}


void LogToFile(HRESULT hr ,char *pStr)
{
	char szHresult[40];
	sprintf(szHresult,"\n %x	:	",hr);
	WriteToFile(szHresult);

	WriteToFile(pStr);


}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  WriteToFile 
//	Writes data to a file. 
// If file name is not given then data is written to %SYSTEMDIR%\wbem\logs\xmlencoder.log file
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT WriteToFile(char * strData ,TCHAR *pFileName)
{
	HANDLE hFile;
	TCHAR strFileName[512];

	if(GetSystemDirectory(strFileName,512))
	{
		_tcscat(strFileName,_T("\\wbem\\logs\\"));
		if(pFileName)
		{
			_tcscat(strFileName,pFileName);
		}
		else
		{
			_tcscat(strFileName,_T("xmlencoder.log"));
		}
	}
	
	DWORD nLen = (strlen(strData) + 1) * sizeof(char);

	if(INVALID_HANDLE_VALUE == 
		(hFile = CreateFile(strFileName,GENERIC_WRITE,FILE_SHARE_READ,NULL, OPEN_ALWAYS ,FILE_ATTRIBUTE_NORMAL,NULL)))
	{
		hFile = CreateFile(strFileName,GENERIC_WRITE,FILE_SHARE_READ,NULL, CREATE_NEW ,FILE_ATTRIBUTE_NORMAL,NULL);
	}

	if(INVALID_HANDLE_VALUE != hFile)
	{
		SetFilePointer(hFile,0,NULL,FILE_END);
		char * pData = NULL;
		nLen = strlen(strData);
		BOOL bWrite = WriteFile(hFile,(VOID *)strData,nLen,&nLen,NULL);

		CloseHandle(hFile);
	}

	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\hash.cpp ===
/***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  hash.cpp
//
//  ramrao 4th Jan 2001 - Created
//
//
//		Declaration of CStringToPtrHTable class
//		Implementation of Hash table for mapping a String to pointer
//		This pointer is pointer to class derived from CHashString
//
//***************************************************************************/

#include "precomp.h"
#include "hash.h"
////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor
//  
////////////////////////////////////////////////////////////////////////////////////////

CStringToPtrHTable::CStringToPtrHTable()
{
	for(int i = 0 ; i < sizeHTable ; i++)
	{
		m_ptrList[i] = NULL;
	}
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//  
////////////////////////////////////////////////////////////////////////////////////////
CStringToPtrHTable::~CStringToPtrHTable()
{
	for(int i = 0 ; i < sizeHTable ; i++)
	{
		SAFE_DELETE_PTR(m_ptrList[i]);
	}
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Find the item which is identified by a string
//  
////////////////////////////////////////////////////////////////////////////////////////
void * CStringToPtrHTable::Find(WCHAR const * str)
{
	CHashElement *	pCur	= NULL;
	BOOL			bFound	= FALSE;
    LONG			lHash	= Hash(str);
	int				nSize	= m_ptrList[lHash]->GetSize();

	pCur = (CHashElement *)m_ptrList[lHash]->GetAt(0);

    for (int i = 0 ; i < nSize && pCur != NULL ; i++ )
	{
		 pCur = (CHashElement *)m_ptrList[lHash]->GetAt(i);
        if (_wcsicmp(str,pCur->GetKey()) == 0)
		{
			bFound = TRUE;
			break;
		}
    }
	return bFound ? pCur : NULL;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Add an item to the hash table
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CStringToPtrHTable::Add (WCHAR const * str, void * pVoid)
{
	HRESULT hr = S_OK;
    LONG lHash = Hash (str);


	if(m_ptrList[lHash] == NULL)
	{
		m_ptrList[lHash] = new CPtrArray;
		if(m_ptrList[lHash] == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if(SUCCEEDED(hr))
	{
		if(!m_ptrList[lHash]->Add(pVoid))
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Removes an item from hash table
//  
////////////////////////////////////////////////////////////////////////////////////////
void CStringToPtrHTable::Remove (WCHAR const * str)
{
	CHashElement *	pCur	= NULL;
    LONG			lHash	= Hash(str);
	int				nSize	= m_ptrList[lHash]->GetSize();

	pCur = (CHashElement *)m_ptrList[lHash]->GetAt(0);

    for (int i = 0 ; i < nSize && pCur != NULL ; i++ )
	{
		pCur = (CHashElement *)m_ptrList[lHash]->GetAt(i);
        if (_wcsicmp(str,pCur->GetKey()) == 0)
		{
			m_ptrList[lHash]->RemoveAt(i);
			break;
		}
    }
	
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Private hashing function
//  
////////////////////////////////////////////////////////////////////////////////////////
LONG CStringToPtrHTable::Hash (WCHAR const * str) const
{
    // must be unsigned, hash should return positive number
    ULONG lVal = str [0];
    for (LONG i = 1; str [i] != 0; ++i)
	{
        lVal = (lVal << 4) + str [i];
	}
    return lVal % sizeHTable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\precomp.h ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  precomp.h
//
//  ramrao Created 13 Nov 2000.
//
//  Master include file.
//
//***************************************************************************/


#pragma warning(disable:4786)
#pragma warning(disable:4192)

#include <stdio.h>
#include <atlbase.h>
#include <wbemidl.h>


#include <tchar.h>
#include <miniafx.h>
#include <wbemcli.h>

#include "wmi2xmlstrs.h"
#include "globals.h"

#include "wmixmlutils.h"
#include "utils.h"

#include "critsec.h"

#include "wmixmlobject.h"

#include "wmixmlschema.h"

#include "wmixmlinst.h"
#include "wmi2xsd.h"
#include "msxml2.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\hash.h ===
/***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmitoxml.h
//
//  ramrao 4th Jan 2001 - Created
//
//
//		Declaration of CStringToPtrHTable class
//		Implementation of Hash table for mapping a String to pointer
//		This pointer is pointer to class derived from CHashElement
//
//***************************************************************************/

#if !defined WMI2XSD_HASH_H
#define WMI2XSD_HASH_H

const int sizeHTable = 127;

//================================================================
// Base class
//================================================================
class CHashElement
{
public:
	virtual WCHAR * GetKey() = 0;
	virtual LONG  GetFlags() = 0;
	virtual LONG  GetFlavor() = 0;
	virtual ~CHashElement() {}
};



//================================================================
// Hash table of strings
// creates and maintains a hash table of pointers of 
// class derived from CHashElement clss
//================================================================
class CStringToPtrHTable
{
public:
	CStringToPtrHTable();
	~CStringToPtrHTable();
    void *	Find(WCHAR const * str) ;
    HRESULT Add (WCHAR const * str, void * pVoid);
	void	Remove (WCHAR const * str);

private:
    LONG Hash (WCHAR const * str) const;
    CPtrArray * m_ptrList [sizeHTable];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_QUALIFIER                   1
#define IDS_STARTPROPANNOTATION         2
#define IDS_DEFAULTVAL                  3
#define IDS_ENDPROPEANNOTATION          4
#define IDS_ENDTAG                      5
#define IDS_BEGINANNOTATION             6
#define IDS_ENDANNOTATION               7
#define IDS_BEGINAPPINFO                8
#define IDS_ENDAPPINFO                  9
#define IDS_BEGINCOMPLEXTYPE            10
#define IDS_BEGINCHILDCOMPLEXTYPE       11
#define IDS_ENDCOMPLEXTYPE              12
#define IDS_ENDCHILDCOMPLEXTYPE         13
#define IDS_ELEMFORPROP                 14
#define IDS_XSDINCLUDE                  15
#define IDS_XSDIMPORT                   16
#define IDS_BEGINXSD                    17
#define IDS_ENDXSDSCHEMA                18
#define IDS_XSDNAMESPACEPREFIX          19
#define IDS_NAMESPACEPREFIX             19
#define IDS_XSDNAMESPACE                20
#define IDS_NAMESPACE                   20
#define IDS_TARGETNAMESPACE             21
#define IDS_BEGINGROUP                  22
#define IDS_ENDGROUP                    23
#define IDS_PROPDEFAULT                 24
#define IDS_XSDANYATTR                  25
#define IDS_ELEMFORCOMPLEXTYPE          26
#define IDS_XSDANYPROP                  27
#define IDS_METHODBEGIN                 28
#define IDS_METHODEND                   29
#define IDS_METHODINPARAMBEGIN          30
#define IDS_METHODPARAMEND              31
#define IDS_METHODOUTPARAMBEGIN         32
#define IDS_BEGINMETHODRETVAL           33
#define IDS_ENDMETHODRETVAL             34
#define IDS_WMIXMLENCODING              35
#define IDS_WMINSPREFIX                 36
#define IDS_OVERRIDABLE                 37
#define IDS_TOSUBCLASS                  38
#define IDS_TOINSTANCE                  39
#define IDS_AMENDED                     40
#define IDS_ENDXMLTAG                   41
#define IDS_ARRAYELEM                   42
#define IDS_BEGIN_ARRAYVAL_INAPPINFO    43
#define IDS_END_ARRAYVAL_INAPPINFO      44
#define IDS_DEFARRAYVAL                 45
#define IDS_DEFAULTWMISTDLOC            46
#define IDS_DEF_WMISTDLOC               46
#define IDS_DEFSTDNAMESPACE             47
#define IDS_DEF_STDNAMESPACE            47
#define IDS_CLASS_SCHEMALOC             48
#define IDS_BEGININSTPROP               49
#define IDS_ENDINSTPROP                 50
#define IDS_INSTPROP                    51
#define IDS_XSITYPE                     52
#define IDS_XSINAMESPACE                53
#define IDS_PROPNULL                    54
#define IDS_BEGININST                   55
#define IDS_ENDINST                     56
#define IDS_XSISCHEMALOC                57
#define IDS_BEGINPROPDEFAULT            58
#define IDS_ENDPROPDEFAULT              60
#define IDS_BEGINTAG_ARRAYVAL_INAPPINFO 61
#define IDC_CURSOR1                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\utils.cpp ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  utils.cpp
//
//  ramrao Created 13 Nov 2000.
//
//  Utility classes and function
//
//***************************************************************************/

#include "precomp.h"
#include "wmitoxml.h"


#define WMI2XSD_REGISTRYPATH _T("Software\\Microsoft\\Wbem\\XML")

#define WINNT_VER_UTF_SUPPORTED		4

extern	DWORD		g_dwNTMajorVersion;


////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  Utility Classes:  CStringConversion
//**********************************************************************************************


////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert ANSI to UNICODE string
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CStringConversion::AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW)
{
    HRESULT hr = S_OK;
    pszW = NULL;

	if(pstr)
	{
		int nSize = strlen(pstr);
		if (nSize != 0 )
		{

			// Determine number of wide characters to be allocated for the
			// Unicode string.
			nSize++;
			pszW = new WCHAR[nSize + 1];
			if (pszW)
			{
				// Covert to Unicode.
				if(MultiByteToWideChar(CP_ACP, 0, pstr, nSize,pszW,nSize))
				{
					hr = S_OK;
				}
				else
				{
					SAFE_DELETE_ARRAY(pszW);
					hr = E_FAIL;
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////
// Function to convert UNICODE  to ANSI string
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CStringConversion::UnicodeToAnsi(WCHAR * pszW, char *& pAnsi)
{
    ULONG cbAnsi, cCharacters;
    HRESULT hr = S_OK;

    pAnsi = NULL;
    if (pszW != NULL)
	{

        cCharacters = wcslen(pszW)+1;
        // Determine number of bytes to be allocated for ANSI string. An
        // ANSI string can have at most 2 bytes per character (for Double
        // Byte Character Strings.)
        cbAnsi	= cCharacters;
		pAnsi	= new char[cbAnsi];
		if ( pAnsi)
        {
			// Convert to ANSI.
			if (0 != WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, pAnsi, cbAnsi, NULL, NULL))
			{
				hr = S_OK;
	        }
			else
			{
	            SAFE_DELETE_ARRAY(pAnsi);
				hr = E_FAIL;
			}
        }
		else
		{
			hr = E_OUTOFMEMORY;
		}

    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Converts LPWSTR to its UTF-8 encoding
// Returns -1 if it fails
////////////////////////////////////////////////////////////////////////////////////////////////
DWORD CStringConversion::ConvertLPWSTRToUTF8(LPCWSTR theWcharString, ULONG lNumberOfWideChars, LPSTR * lppszRetValue)
{
	
	DWORD dwRet = -1;
	// Find the length of the Ansi string required
	DWORD dwBytesToWrite = WideCharToMultiByte( g_dwNTMajorVersion >= WINNT_VER_UTF_SUPPORTED ? CP_UTF8 : CP_ACP,	// UTF-8 code page
												0,																	// performance and mapping flags
												theWcharString,														// address of wide-character string
												lNumberOfWideChars,													// number of characters in string
												NULL,																// address of buffer for new string
												0,																	// size of buffer
												NULL,																// address of default for unmappable characters
												NULL);																// address of flag set when default char. used

	if(dwBytesToWrite)
	{

		// Allocate the required length for the Ansi string
		*lppszRetValue		= NULL;
		if(*lppszRetValue = new char[dwBytesToWrite])
		{

			// Convert BSTR to ANSI
			dwRet = WideCharToMultiByte(	g_dwNTMajorVersion >= WINNT_VER_UTF_SUPPORTED ? CP_UTF8 : CP_ACP,	// use UTF8 page if available
											0,																	// performance and mapping flags												// else use AnsiCode page					
											theWcharString,														// address of wide-character string
											lNumberOfWideChars,													// number of characters in string
											*lppszRetValue,														// address of buffer for new string
											dwBytesToWrite,														// size of buffer
											NULL,																// address of default for unmappable characters
											NULL);																// address of flag set when default
																												// char. used
		}
	}

	return dwRet;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  End of Utility Class CStringConversion
//**********************************************************************************************


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  TranslateAndLog 
//	Logs message to a log file
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void TranslateAndLog( WCHAR * wcsMsg )
{
    char * pStr = NULL;

	if( SUCCEEDED(CStringConversion::UnicodeToAnsi(wcsMsg,pStr)))
    {
//		ERRORTRACE((THICOMPONENT,pStr));
   		//ERRORTRACE((THICOMPONENT,"\n"));
        SAFE_DELETE_ARRAY(pStr);
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  LoadAndAllocateStringW 
//	Loads a string from string table. ALlocates memory for the string
//	calling funcition should releas the memory
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT LoadAndAllocateStringW(LONG strID , WCHAR *& pwcsOut)
{
	HRESULT hr			= S_OK;
	TCHAR *	pStrTemp	= NULL;

	if(SUCCEEDED(hr = LoadAndAllocateString(strID , pStrTemp)))
	{

#ifndef UNICODE
		hr = CStringConversion::AllocateAndConvertAnsiToUnicode(pStrTemp,pwcsOut);
		SAFE_DELETE_ARRAY(pStrTemp);
#else
		pwcsOut = pStrTemp;
#endif

	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  LoadAndAllocateStringA 
//	Loads a string from string table. ALlocates memory for the string
//	calling funcition should releas the memory
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT LoadAndAllocateStringA(LONG strID , char *& pszOut)
{

	HRESULT hr			= S_OK;
	TCHAR *	pStrTemp	= NULL;

	if(SUCCEEDED(hr = LoadAndAllocateString(strID , pStrTemp)))
	{

#ifdef UNICODE
		hr = CStringConversion::UnicodeToAnsi(pStrTemp,pszOut);
		SAFE_DELETE_ARRAY(pStrTemp);
#else
		pszOut = pStrTemp;
#endif
	
	}

	return hr;

}


#define INITBUFSIZE		100
#define	INCRBUFFSIZE	50

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  LoadAndAllocateString 
//	Loads a string from the string table. Allocates memory 
//  and caller has to free the memory
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT LoadAndAllocateString(LONG strID , TCHAR *& pstrOut)
{
    int		nLen		= 0;
	int		nAllocSize	= 0;
	HRESULT hr			= S_OK;

	do
	{
		SAFE_DELETE_ARRAY(pstrOut);
		nAllocSize = nAllocSize ? (nAllocSize + INCRBUFFSIZE) : INITBUFSIZE ;

		pstrOut = new TCHAR[nAllocSize];
		if(pstrOut)
		{
			nLen = ::LoadString(g_hModule, strID, pstrOut, nAllocSize);
		}
		else
		{
			SAFE_DELETE_ARRAY(pstrOut);
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	while((nLen + 1) >= nAllocSize);

    return hr; // excluding terminator
}




/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  WriteToFile 
//	Writes data to a file. 
// If file name is not given then data is written to %SYSTEMDIR%\wbem\logs\xmlencoder.log file
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT WriteToFile(char * strData ,TCHAR *pFileName)
{
	HANDLE hFile;
	TCHAR strFileName[512];

	if(GetSystemDirectory(strFileName,512))
	{
		_tcscat(strFileName,_T("\\wbem\\"));
		if(pFileName)
		{
			_tcscat(strFileName,pFileName);
		}
		else
		{
			_tcscat(strFileName,_T("wmi2xsd.xml"));
		}
	}
	
	DWORD nLen = (strlen(strData) + 1) * sizeof(char);

	if(INVALID_HANDLE_VALUE != 
		(hFile = CreateFile(strFileName,GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)))
	{
		char * pData = NULL;
		nLen = strlen(strData);
		BOOL bWrite = WriteFile(hFile,(VOID *)strData,nLen,&nLen,NULL);

		CloseHandle(hFile);
	}

	return S_OK;

}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to compare data of same types and check if both are same
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CompareData(VARIANT * pvData1 , VARIANT *pvData2)
{

	BOOL bRet = FALSE;

	if(!((pvData2->vt & VT_ARRAY) || (pvData1->vt  & VT_ARRAY) ))
	{
	
		if(VT_NULL == pvData1->vt || pvData2->vt == VT_NULL)
		{
			// if both the property is NULL then return TRUE
			if(VT_NULL == pvData1->vt && pvData2->vt == VT_NULL)
			{
				bRet = TRUE;
			}

		}
		else
		{
			HRESULT hr = VarCmp(pvData1,pvData2 ,LOCALE_USER_DEFAULT, NORM_IGNORECASE ); // FIX get LCID
			bRet = hr == VARCMP_EQ ? TRUE: FALSE;
		}
	}
	else
	{
		// FIXX compare arrays
	}

    
	return bRet;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// checks if the given property is an embedded object
// and returns the number
// Return Values:	the logging level 
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsEmbededType(LONG cimtype)
{
	return (cimtype == CIM_OBJECT) || (cimtype == (CIM_OBJECT | CIM_FLAG_ARRAY));
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Reads registry "LoggingLevel" keyvalue at HKEY_LOCAL_MACHINE\software\microsoft\wbem\xml
// and returns the number
// Return Values:	the logging level 
//
/////////////////////////////////////////////////////////////////////////////////////////////////
ULONG GetLoggingLevel()
{
	ULONG nLoggingLevel = 0;
	HKEY	hKey;

	// Get the Logging level
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
			WMI2XSD_REGISTRYPATH, 0, KEY_QUERY_VALUE, &hKey))
	{
		DWORD dwlen = 0;

		dwlen = sizeof (nLoggingLevel);
	
		if (ERROR_SUCCESS != RegQueryValueEx (hKey, _T("LoggingLevel"), 
				NULL, NULL, (BYTE *) &nLoggingLevel,  &dwlen))
		{
			nLoggingLevel = 0;
		}
		RegCloseKey (hKey);
	}

	return nLoggingLevel;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// copies data from source stream to destination stream.
//
//	Parameters:
//			pStreamIn		-	Source stream pointer
//			pOutStream		-	Destination stream pointer
//			bConvertToUTF8	-	Flag which determines if data has to be converted to UTF8
//								before writing to destination stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CopyStream(IStream *pStreamIn , IStream *pOutStream,BOOL bConvertToUTF8)
{
	HRESULT			hr		= S_OK;
	STATSTG			stat;
	LARGE_INTEGER	lSeek;
	LARGE_INTEGER	lCur;


	memset(&lCur,0,sizeof(LARGE_INTEGER));
	memset(&lSeek , 0, sizeof(LARGE_INTEGER));

	// Store the current seek pointer
	pOutStream->Seek(lSeek,STREAM_SEEK_CUR,(ULARGE_INTEGER *)&lCur);

	if(SUCCEEDED(hr = pStreamIn->Stat(&stat,STATFLAG_NONAME )) && stat.cbSize.LowPart &&		// get the lenght 
		SUCCEEDED(hr =pStreamIn->Seek(lSeek,STREAM_SEEK_SET,(ULARGE_INTEGER *)&lSeek))  )	// move to the begining of stream
	{
		void *	pStrOut	= NULL;
		LPWSTR	pstrTemp		= NULL;
		ULONG	lSizeWritten	= 0;
		ULONG	lSizeRead		= 0;
		ULONG	lSizeinWchars	= stat.cbSize.LowPart /sizeof(WCHAR);

		pstrTemp = new WCHAR[lSizeinWchars + 2];

		if(pstrTemp)
		{
			pstrTemp[lSizeinWchars] = 0;
			while (lSizeRead <= lSizeinWchars)
			{
				if(SUCCEEDED(hr = pStreamIn->Read(pstrTemp,lSizeinWchars * sizeof(WCHAR),&lSizeRead)))
				{
					if(!lSizeRead)
					{
						break;
					}
					// NULL terminate the string
					pstrTemp[lSizeinWchars] = 0;
		
					if(bConvertToUTF8)
					{
						// call this function to convert WCHAR to UTF8 format
						lSizeWritten = (ULONG)CStringConversion::ConvertLPWSTRToUTF8(	pstrTemp,
																	lSizeinWchars * sizeof(WCHAR) > lSizeRead ? lSizeRead/sizeof(WCHAR) : lSizeinWchars ,
																	(LPSTR *)&pStrOut);
					}
					else
					{
						pStrOut =  pstrTemp;
						lSizeWritten = wcslen(pstrTemp) * sizeof(WCHAR);
					}

					if(lSizeWritten >0)
					{
						ULONG lTest;
						hr = pOutStream->Write(pStrOut,(ULONG)lSizeWritten ,&lTest); 
					}
				}
				if(FAILED(hr))
				{
					break;
				}
				
			}
			if(bConvertToUTF8)
			{
				SAFE_DELETE_ARRAY(pStrOut);
			}

			SAFE_DELETE_ARRAY(pstrTemp);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		SAFE_DELETE_ARRAY(pstrTemp);
	}
	// Reset the position to the previous one
	pOutStream->Seek(lCur,STREAM_SEEK_SET,NULL);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if the given property is NULL of not
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsPropNull(VARIANT *pVar)
{
	return ((pVar->vt == VT_NULL) || (pVar->vt == VT_EMPTY));
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if the given property value is given as strings
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsStringType(CIMTYPE cimtype)
{
	BOOL bRet = FALSE;
	
	switch(cimtype)
	{
		case VT_BSTR:
		case CIM_UINT64:
		case CIM_SINT64:
		case CIM_DATETIME:
			bRet = TRUE;
			break;

		default:
			bRet = FALSE;
	};

	return bRet;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if the given property/qualifier name is valid
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT IsValidName(WCHAR *pstrName)
{
	HRESULT hr = E_FAIL;
	if(pstrName)
	{
		if(wcslen(pstrName) > 0)
		{
			if(iswalpha(*pstrName))
			{
				hr = S_OK;
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\utils.h ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  utils.h
//
//  ramrao Created 13 Nov 2000.
//
//  Utility classes/macros and function decralation
//
//***************************************************************************/

#ifndef _WMI2XSD_UTILS_H_
#define _WMI2XSD_UTILS_H_


// Macros used to free/release memory
#define SAFE_DELETE_PTR(pv)  \
	{ delete pv;  \
      pv = NULL; }

#define SAFE_RELEASE_PTR(pv)  \
    { if(pv){ pv->Release(); }  \
      pv = NULL; }

#define SAFE_DELETE_ARRAY(pv)  \
	{ delete []pv;  \
      pv = NULL; }

#define SAFE_FREE_SYSSTRING(pv)  \
    {  SysFreeString(pv);  \
      pv = NULL; }


#define STR_TRUE			L"True"
#define STR_FALSE			L"False"

#define XSD_BOOL			L"xsd:boolean"
#define XSD_STRING			L"xsd:string"
#define XSD_I2				L"xsd:short"
#define XSD_UI1				L"xsd:unsignedByte"
#define XSD_I1				L"xsd:byte"
#define XSD_UI2				L"xsd:unsignedShort"
#define XSD_I4				L"xsd:int"
#define XSD_UI4				L"xsd:unsignedInt"
#define XSD_I8				L"xsd:long"
#define XSD_UI8				L"xsd:unsignedLong"
#define XSD_R4				L"xsd:float"
#define XSD_R8				L"xsd:double"

#define MAXOCCURS_FORARRAY	L"xsd:unbounded"
#define MINOCCURS			L"xsd:unbounded"

#define XSD_ANYTYPE			L"xsd:anyType"

#define XSD_SCHEMANAMESPACE	L"http://www.w3.org/2000/10/XMLSchema"

#define WMI_DATETIME		L"datetime"

#define MAXXSDTYPESIZE			255
#define MAXNUMERICSIZE			50
#define QUALIFIERFLAVORSIZE		50


#define WMI_BOOL			L"boolean"
#define WMI_STRING			L"string"
#define WMI_I2				L"char16"
#define WMI_UI1				L"uint8"
#define WMI_I1				L"sint8"
#define WMI_UI2				L"uint16"
#define WMI_I4				L"uint32"
#define WMI_UI4				L"sint32"
#define WMI_I8				L"sint64"
#define WMI_UI8				L"sint64"
#define WMI_R4				L"real32"
#define WMI_R8				L"real64"
#define WMI_REF				L"ref"
#define WMI_OBJ				L"obj"


/// WMIRELATED 

#define WMI_EMBEDDEDOBJECT_UNTYPED	L"object"



// Some WMI property names
#define CLASSNAMEPROP	L"__CLASS"
#define PARENTCLASSPROP	L"__SUPERCLASS"
#define GENUSPROP		L"__GENUS"
#define SERVER			L"__SERVER"
#define NAMESPACE		L"__NAMESPACE"
#define CIMTYPEPROP		L"CIMTYPE"
#define OBJECT			L"object"


void	TranslateAndLog( WCHAR * wcsMsg );
//HRESULT ConvertVariantToString(VARIANT varIn,WCHAR *& strout,BSTR szProperty = NULL);
//HRESULT ConvertVariantToString(VARIANT &varIn,BSTR strProperty,IStream *pStream,BOOL bEscape = TRUE);

HRESULT LoadAndAllocateStringW(LONG strID , WCHAR *& pwcsOut);
HRESULT LoadAndAllocateStringA(LONG strID , char *& pszOut);
HRESULT LoadAndAllocateString(LONG strID , TCHAR *& pstrOut);

HRESULT WriteToFile(char * strData ,TCHAR *pFileName = NULL);

HRESULT ConvertVariantArrayToXML(VARIANT varIn,IStream *pStream,BOOL bEscape = FALSE);
HRESULT ConvertToString(void * pData,VARTYPE vt ,IStream *pStream,BOOL bEscape);

//HRESULT GetPropertyWMIType(CIMTYPE cimtype,WCHAR * pType,BOOL &bArray,BOOL bStdWmiImport=FALSE);
//HRESULT GetPropertyXSDType(CIMTYPE cimtype,WCHAR * pType,BOOL &bArray,BOOL bStdWmiImport=FALSE);
//HRESULT GetQualifierWMIType(VARTYPE vType,WCHAR * pType,BOOL & bArray);
//HRESULT GetQualifierXSDType(VARTYPE vType,WCHAR * pType,BOOL & bArray);


BOOL	CompareData(VARIANT * pvData1 , VARIANT *pvData2);
BOOL	IsEmbededType(LONG cimtype);
BOOL	IsPropNull(VARIANT *pVar);
BOOL	IsStringType(CIMTYPE cimtype);

ULONG	GetLoggingLevel();

//HRESULT AddStringToStream(LONG strID,IStream *pStream);
//HRESULT WriteToStream(IStream *pStream, WCHAR * pBuffer , ULONG *pcbWchar = NULL );
HRESULT CopyStream(IStream *pStreamIn , IStream *pOutStream,BOOL bConvert= TRUE);
HRESULT IsValidName(WCHAR *pstrName);

/*
HRESULT WriteByte (IStream *pStream, unsigned char val);
HRESULT WriteLong (IStream *pStream, long lVal);
HRESULT WriteShort (IStream *pStream, short iVal);
HRESULT WriteDouble (IStream *pStream, double dVal);
HRESULT WriteFloat (IStream *pStream, float fVal);
HRESULT WriteChar(IStream *pStream, char cVal);
HRESULT WriteBool (IStream *pStream, BOOL bVal);
HRESULT WriteString(IStream *pStream, WCHAR * pwcsVal,BOOL bEscape = FALSE);


HRESULT ReplaceXMLSpecialCharsAndWrite(WCHAR *pwcsStr,IStream * pStream);
*/


// Class to Manage string conversions
class CStringConversion
{
    public:
        CStringConversion()  {}
        virtual  ~CStringConversion() {}
        static HRESULT	UnicodeToAnsi(WCHAR * pszW, char *& pAnsi);
        static HRESULT	AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW);
		static DWORD	ConvertLPWSTRToUTF8(LPCWSTR theWcharString, 
											ULONG lNumberOfWideChars, 
											LPSTR * lppszRetValue);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wbemobjtxtsrc.cpp ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WbemObjectTxtSrc.cpp
//
//  ramrao 13 Nov 2000 - Created
//
//  Entry points required for IWbemObjectTextSrc by WMI CORE ie.
// 	OpenWbemTextSource 
//	CloseWbemTextSource 
//	WbemObjectToText 
//	TextToWbemObject 
//
//***************************************************************************/

#include "precomp.h"
#include "wmitoxml.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// API for initializing the Text Source
// Return Values
//	S_OK					- Success
//	E_OUTOFMEMORY			- Out of memory
//	E_FAIL					- Failed to initialize the text source
//	E_INVALID_ARG			- Invalid argument
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT OpenWbemTextSource(long lFlags, ULONG uObjTextFormat)
{
	return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// API for releasing the the resources allocated for the text source
// Return Values
//	S_OK					- Success
//	E_OUTOFMEMORY			- Out of memory
//	E_FAIL					- Failed to initialize the text source
//	E_INVALID_ARG			- Invalid argument
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CloseWbemTextSource(long lFlags, ULONG uObjTextFormat)
{
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// API for Converting an Object to Text
// Return Values
//	S_OK					- Success
//	E_OUTOFMEMORY			- Out of memory
//	E_FAIL					- Failed to initialize the text source
//	E_INVALID_ARG			- Invalid argument
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT __declspec(dllexport) WbemObjectToText(long lFlags, ULONG uObjTextFormat, void *pWbemContext, void *pWbemClassObject, BSTR *pstrText)
{
	BSTR bstrTemp;
	CWMIToXML wmixml;
//	wmixml.FInit(0,(IWbemClassObject *)pWbemClassObject);
	wmixml.GetXML(bstrTemp);
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// API for converting a XML string to WMI object
// Returns a Encoder implemented IWBEMClassObject 
// Return Values
//	S_OK					- Success
//	E_OUTOFMEMORY			- Out of memory
//	E_FAIL					- Failed to initialize the text source
//	E_INVALID_ARG			- Invalid argument
//
// Object returned cannot be passed to WMI CORE
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT TextToWbemObject(long lFlags, ULONG uObjTextFormat, void *pWbemContext, BSTR strText, void **ppWbemClassObject)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\maindll.cpp ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  MainDll.cpp
//
//  ramrao 13 Nov 2000 - Created
//
//  DLL entry points except for IWbemObjectTextSrc 
//
//***************************************************************************/

#include "precomp.h"
#include <initguid.h>
#include "wmi2xsdguids.h"
#include <wmi2xsd.h>
#include "classfac.h"


HMODULE g_hModule	= NULL;

//Count number of objects and number of locks.

long		g_cObj=0;
long		g_cLock=0;
BOOL		g_Init	= FALSE;


// These are the globals which are initialized in the Initialize () function
DWORD		g_dwNTMajorVersion = 0;
BSTR g_strStdNameSpace	= NULL;
BSTR g_strStdLoc		= NULL;
BSTR g_strStdPrefix		= NULL;





// Utility functions
void	ConvertToTCHAR(WCHAR *pStrIn , TCHAR *& pOut);
void	SafeDeleteTStr(TCHAR *& pStr);
HRESULT CreateKey(TCHAR * szCLSID, TCHAR * szName);
HRESULT DeleteKey(TCHAR * pCLSID, TCHAR * pID);
HRESULT InitDll();
void	FreeGlobals();



//***************************************************************************
//
//  GetOSVersion
//
//  DESCRIPTION:
//	Get the windows version
//
//***************************************************************************
 
HRESULT GetOSVersion ()
{
	HRESULT hr = S_OK;

	if (!g_dwNTMajorVersion)
	{
		// Get OS info
		OSVERSIONINFO	osVersionInfo;
		osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

		GetVersionEx (&osVersionInfo);
		g_dwNTMajorVersion = osVersionInfo.dwMajorVersion;

	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// DllMain
//
// Purpose: Entry point for DLL.  
// Return: TRUE if OK.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{

	BOOL fRc = TRUE;

	switch( ulReason )
	{
		case DLL_PROCESS_DETACH:
		break;

		case DLL_PROCESS_ATTACH:			
		g_hModule = hInstance;
		if (!DisableThreadLibraryCalls(g_hModule))
		{
			TranslateAndLog( L"DisableThreadLibraryCalls failed" );
		}
		break;
	}
	return fRc;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  
//	Returns S_OK - If object is implemented in encoder
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void ** ppv)
{
    HRESULT hr =  CLASS_E_CLASSNOTAVAILABLE ;
	
	CEncoderClassFactory *pFactory = NULL;

	if(!g_Init)
	{
		if(SUCCEEDED(hr = InitDll()))
		{
			g_Init = TRUE;
		}
	}
	//============================================================================
    //  Verify the caller is asking for our type of object.
    //============================================================================
    if((CLSID_WMIXMLConverter != rclsid) &&  (CLSID_XMLWMIConverter != rclsid)  )
    {
        hr = E_FAIL;
    }
    else
	{
        //============================================================================
        // Check that we can provide the interface.
        //============================================================================
        if (IID_IUnknown != riid && IID_IClassFactory != riid)
        {
            hr = E_NOINTERFACE;
        }
        else
		{

            //============================================================================
            // Get a new class factory.
            //============================================================================
			pFactory=new CEncoderClassFactory(rclsid);
            if (NULL==pFactory)
            {
                hr = E_OUTOFMEMORY;
            }
			else
			{
				hr = S_OK;
			}

            //============================================================================
            // Verify we can get an instance.
            //============================================================================
            if( SUCCEEDED(hr))
            {
				hr = pFactory->QueryInterface(riid, ppv);
                if (FAILED(hr))
                {
					SAFE_DELETE_PTR(pFactory);
                }
            }
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
/////////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc = S_FALSE;

    //============================================================================
    // It is OK to unload if there are no objects or locks on the 
    // class factory.
    //============================================================================
    
   if (0L==g_cObj && 0L==g_cLock)
	{
	   FreeGlobals();
	   g_Init = FALSE;

	   // Release global pointers
		sc = S_OK;
	}

    return sc;
}


/////////////////////////////////////////////////////////////////////
// Exported function to unregister the dll
/////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
    WCHAR      wcID[128];
	TCHAR	*  pId = NULL;
    TCHAR      strCLSID[MAX_PATH];
    HRESULT hr = E_OUTOFMEMORY;

    //===============================================
    // Delete keys for WMI to XML converter
    //===============================================
    StringFromGUID2(CLSID_WMIXMLConverter, wcID, 128);
	ConvertToTCHAR(wcID , pId);
	if(pId)
	{
		_stprintf(strCLSID, _T("CLSID\\%s"),pId);
		hr = DeleteKey(strCLSID, pId);
		SafeDeleteTStr(pId);

		if(SUCCEEDED(hr))
		{
			//===============================================
			// Delete keys for XML to WMI converter
			//===============================================
			StringFromGUID2(CLSID_XMLWMIConverter, wcID, 128);
			ConvertToTCHAR(wcID , pId);
			if(pId)
			{
				_stprintf(strCLSID, _T("CLSID\\%s"),pId);
				hr = DeleteKey(strCLSID,pId);
				SafeDeleteTStr(pId);
			}
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to register the server
/////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer(void)
{   
    WCHAR wcID[128];
    TCHAR * pID = NULL;
    TCHAR szCLSID[128];
    HRESULT hr = WBEM_E_FAILED;
    

    //==============================================
    // Create keys for WDM Instance Provider.
    //==============================================
    StringFromGUID2(CLSID_WMIXMLConverter, wcID, 128);


	ConvertToTCHAR(wcID,pID);

	if( pID )
    {
		_stprintf(szCLSID, _T("CLSID\\%s"),pID);

		SafeDeleteTStr(pID);
		
		hr = CreateKey(szCLSID,_T("WMI to XML Converter"));
        if( SUCCEEDED(hr) )
        {
            //==============================================
            // Create keys for WMI to XML converter
            //==============================================
            StringFromGUID2(CLSID_XMLWMIConverter, wcID, 128);
			ConvertToTCHAR(wcID,pID);
	        if( pID )
            {
                _stprintf(szCLSID,_T("CLSID\\%s"),pID);
				SafeDeleteTStr(pID);
	
				//==============================================
				// Create keys for XML to WMI converter
				//==============================================
		        hr = CreateKey(szCLSID,_T("XML to WMi Converter"));
	        }
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
// Convert the given string to TCHAR string
/////////////////////////////////////////////////////////////////////////////////////////////////
void ConvertToTCHAR(WCHAR *pStrIn , TCHAR *& pOut)
{

	#ifndef UNICODE
			CStringConversion::UnicodeToAnsi(pStrIn,pOut);
	#else
			pOut = pStrIn;
	#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Delete the string if allocated. Memory is 
// allocated only if the system ANSI
/////////////////////////////////////////////////////////////////////////////////////////////////
void SafeDeleteTStr(TCHAR *& pStr)
{
	#ifndef UNICODE
			SAFE_DELETE_ARRAY(pStr);
	#else
			pStr = NULL;
	#endif
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// CreateKey
//
// Function to create a key
//
// Return:  S_OK if creating a key is successful
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CreateKey(TCHAR * szCLSID, TCHAR * szName)
{
    HKEY hKey1, hKey2;
    LONG ret = 0;


    ret = RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    if( ERROR_SUCCESS == ret )
    {
        DWORD dwLen;
        dwLen = (_tcsclen(szName)+1) * sizeof(TCHAR);
        ret = RegSetValueEx(hKey1, NULL, 0, REG_SZ, (CONST BYTE *)szName, dwLen);
        
		if( ERROR_SUCCESS == ret )
        {
			ret = RegCreateKey(hKey1, _T("InprocServer32"), &hKey2);
            if( ERROR_SUCCESS == ret )
            {
                TCHAR szModule[MAX_PATH];

                GetModuleFileName(g_hModule, szModule,  MAX_PATH);
                dwLen = (_tcsclen(szModule)+1) * sizeof(TCHAR);
                ret = RegSetValueEx(hKey2, NULL, 0, REG_SZ, (CONST BYTE *)szModule, dwLen );
                if( ERROR_SUCCESS == ret )
                {
                    dwLen = (_tcsclen(_T("Both"))+1) * sizeof(TCHAR);
                    ret = RegSetValueEx(hKey2, _T("ThreadingModel"), 0, REG_SZ,(CONST BYTE *)_T("Both"), dwLen);
                }
                CloseHandle(hKey2);
            }
        }
        CloseHandle(hKey1);
    }

	return (ret == ERROR_SUCCESS) ? S_OK : E_FAIL;
    
}


/////////////////////////////////////////////////////////////////////////////////////
//
// DeleteKey
//
// Called when it is time to remove the registry entries.
//
// Return:  S_OK if deletion of key is successful
//
/////////////////////////////////////////////////////////////////////////////////////
HRESULT DeleteKey(TCHAR * pCLSID, TCHAR * pID)
{
    HKEY hKey;
	HRESULT hr = S_OK;


    hr = RegOpenKey(HKEY_CLASSES_ROOT, pCLSID, &hKey);
    if(NO_ERROR == hr)
    {
        hr = RegDeleteKey(hKey,_T("InprocServer32"));
        CloseHandle(hKey);
    }


    hr = RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hKey);
    if(NO_ERROR == hr)
    {
        hr = RegDeleteKey(hKey,pID);
        CloseHandle(hKey);
    }


    return hr;
}



/////////////////////////////////////////////////////////////////////////////////////
//
// InitDll
//
// Function to initialize global variables
//
// Return:  S_OK if initialization is successful
//
/////////////////////////////////////////////////////////////////////////////////////
HRESULT InitDll()
{
	HRESULT hr = S_OK;

	GetOSVersion();

	SAFE_FREE_SYSSTRING(g_strStdLoc);
	SAFE_FREE_SYSSTRING(g_strStdNameSpace);
	SAFE_FREE_SYSSTRING(g_strStdPrefix);
	
	g_strStdLoc = SysAllocString( L"http://www.microsoft.com/wmi/soap/wmi.xsd");
	if(!g_strStdLoc)
	{
		hr = E_OUTOFMEMORY;
	}

	if(SUCCEEDED(hr))
	{
		g_strStdNameSpace = SysAllocString(L"http://www.microsoft.com/wmi/soap");
		if(!g_strStdNameSpace)
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if(SUCCEEDED(hr))
	{
		g_strStdPrefix = SysAllocString(DEFAULTWMIPREFIX);
		if(!g_strStdPrefix)
		{
			hr = S_OK;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////
//
// FreeGlobals
//
// Function to Free global resources
//
//
/////////////////////////////////////////////////////////////////////////////////////
void FreeGlobals()
{
	SAFE_FREE_SYSSTRING(g_strStdLoc);
	SAFE_FREE_SYSSTRING(g_strStdNameSpace);
	SAFE_FREE_SYSSTRING(g_strStdPrefix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wbemqualset.h ===
/***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WbemQualSet.h
//
//  ramrao 18 Dec 2000 - Created
//
//
//		Declaration of CWbemQualifierSet class 
//		This class implements IWbemQualifierSet interface
//
//***************************************************************************/

#include "hash.h"
#include "enum.h"


// Base class for storing property and qualifiers
class CPropRoot:public CHashElement
{
public:
	CPropRoot();
	virtual ~CPropRoot();
	
	HRESULT		SetName(LPCWSTR cszName);
	HRESULT		SetFlavor(LONG lFlavor);
	HRESULT		SetValue(VARIANT *pVal);
	HRESULT		SetFlags(LONG lFlags);

	LPWSTR		GetName() { return m_pszName;}
	VARIANT *	GetValue()	 { return &m_vValue; }
	
	virtual LONG	GetFlags()	{ return m_lFlags; }
	virtual	WCHAR * GetKey()	{ return m_pszName; }
	virtual LONG	GetFlavor()	{ return m_lFlavor; }

private:
	WCHAR * m_pszName;
	LONG	m_lFlavor;
	VARIANT	m_vValue;
	CIMTYPE	m_cimType;
	LONG	m_lFlags;
};

// class for storing Qualifiers
class CQualifier:public CPropRoot
{
public:
	virtual ~CQualifier() {}
};

class CWbemQualifierSet:public IWbemQualifierSet
{

private:
	CEnumObject m_Enum;
	LONG		m_cRef;
	ENUMSTATE	m_EnumState;
	CPtrArray 	m_QualifNames;
	LONG		m_Position;
	LONG		m_lQualifFlags;

	CStringToPtrHTable		m_QualifiersHashTbl;

	HRESULT GetQualifier(CQualifier *pQualifier ,VARIANT *pVal,long *plFlavor);
	HRESULT IsValidFlavor(LONG lFlavor);

public:
	CWbemQualifierSet();
	virtual ~CWbemQualifierSet();
	HRESULT AddQualifer(LPCWSTR wszName,	VARIANT *pVal,long lFlavor , LONG lFlags = WBEM_FLAVOR_ORIGIN_LOCAL);
	static BOOL		ISValidEnumFlags(LONG lFlags);

	// IUnknown Methods
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IWbemQualifierSet Methods
    virtual HRESULT STDMETHODCALLTYPE Get( 
        /* [string][in] */ LPCWSTR wszName,
        /* [in] */ long lFlags,
        /* [unique][in][out] */ VARIANT *pVal,
        /* [unique][in][out] */ long *plFlavor);
    
    virtual HRESULT STDMETHODCALLTYPE Put( 
        /* [string][in] */ LPCWSTR wszName,
        /* [in] */ VARIANT *pVal,
        /* [in] */ long lFlavor);
    
    virtual HRESULT STDMETHODCALLTYPE Delete( 
        /* [string][in] */ LPCWSTR wszName);
    
    virtual HRESULT STDMETHODCALLTYPE GetNames( 
        /* [in] */ long lFlags,
        /* [out] */ SAFEARRAY * *pNames);
    
    virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
        /* [in] */ long lFlags);
    
    virtual HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ long lFlags,
        /* [unique][in][out] */ BSTR *pstrName,
        /* [unique][in][out] */ VARIANT *pVal,
        /* [unique][in][out] */ long *plFlavor);
    
    virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void);


	// Public methods
	HRESULT FInit();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wbemclassobject.cpp ===
//***************************************************************************/
//
//  WbemClassObject.CPP
//
//  Purpose: Implementation of IWbemClassObject interface in CWbemClassObject class
//
//  Copyright (c)1997-2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************/
#include <precomp.h>
#include <wmi2xsd.h>
#include "wbemclassobject.h"

BOOL IsValidGetNamesFlag(LONG lFlags);
LONG GetEnumFlags(LONG lFlags);
/*******************************************************************************/
//
//	Begin of CProperty class defination
//
/*******************************************************************************/

////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CProperty::CProperty()
{
	m_pszOriginClass	= NULL;
	m_pNode				= NULL;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CProperty::~CProperty()
{
	SAFE_DELETE_ARRAY(m_pszOriginClass);
	SAFE_RELEASE_PTR(m_pNode);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the property origin
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CProperty::SetPropOrigin(WCHAR * pstrOrigin)
{
	HRESULT hr = S_OK;
	SAFE_DELETE_ARRAY(m_pszOriginClass);

	if(pstrOrigin)
	{
		m_pszOriginClass = new WCHAR[wcslen(pstrOrigin) + 1];
		if(m_pszOriginClass)
		{
			wcscpy(m_pszOriginClass,pstrOrigin);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	return hr;
}

/*******************************************************************************/
//
//	End of CProperty class defination
//
/*******************************************************************************/





/*******************************************************************************/
//
//	CWbemClassObject class defination
//
/********************************************************************************/

////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CWbemClassObject::CWbemClassObject()
: m_PropEnum(PROPERTY_ENUM)
{
	m_cRef = 0;
	m_pQualSet		= NULL;
	m_bClass		= FALSE;
	m_pIDomDoc		= NULL;
	m_bInitObject	= FALSE;
	InterlockedIncrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//  
////////////////////////////////////////////////////////////////////////////////////////
CWbemClassObject::~CWbemClassObject()
{
	SAFE_DELETE_PTR(m_pQualSet);
	InterlockedDecrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Initialization function which initializes the XML of the object which needs 
//	to be represented as WMI object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassObject::FInit(VARIANT *pVarXml)
{
	BSTR strTemp = NULL;
	HRESULT hr = S_OK;

	if(pVarXml)
	{
		switch(pVarXml->vt)
		{
			case VT_BSTR:
			case VT_UNKNOWN:
				break;

			default:
				hr = WBEM_E_FAILED;
				break;
		}
		
		if(SUCCEEDED(hr) && !m_pIDomDoc)
		{
			hr = CoCreateInstance(CLSID_DOMDocument,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IXMLDOMDocument2 , 
								  (void **)&m_pIDomDoc);

			if(FAILED(hr))
			{
				//FIXX Log error for Cocreateinstance
			}
		}

		// If everything is fine then Load the given XML 
		if(SUCCEEDED(hr))
		{
			VARIANT_BOOL vBool;
			if(pVarXml->vt == VT_BSTR)
			{
				hr = m_pIDomDoc->loadXML(pVarXml->bstrVal,&vBool);
			}
			else
			{
				hr = m_pIDomDoc->load(*pVarXml,&vBool);

			}

			if(hr != S_OK || vBool == VARIANT_FALSE)
			{
				hr = WBEM_E_FAILED;
			}
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	return hr;

}


////////////////////////////////////////////////////////////////////////////////////////
//
// QueryInterface
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWbemClassObject::QueryInterface(REFIID riid, LPVOID* ppv)
{
	HRESULT hr = E_NOINTERFACE;
	*ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWbemClassObject==riid)
		*ppv = reinterpret_cast<IWbemClassObject *>(this);

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = NOERROR;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// AddRef
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CWbemClassObject::AddRef(void)
{
	return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Release 
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CWbemClassObject::Release(void)
{
	if(InterlockedDecrement(&m_cRef) == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Get a qualifier set of the given object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::GetQualifierSet(IWbemQualifierSet** ppQualSet)
{
	HRESULT hr = S_OK;
	if(m_pQualSet)
	{
		m_pQualSet = new CWbemQualifierSet;
		if(m_pQualSet)
		{
			hr = InitializeQualifiers();
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pQualSet->QueryInterface(IID_IWbemQualifierSet , (void **)ppQualSet);
	}
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Fetch a particular property of the object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::Get(	LPCWSTR wszName,
								long lFlags,
								VARIANT* pVal,
								CIMTYPE* pType,
								long* plFlavor)
{
	HRESULT hr = S_OK;
	if(wszName && lFlags != 0  )
	{
		CHashElement *pProperty = NULL;
		hr = m_PropEnum.Get(wszName,lFlags,pProperty);
		if(pProperty && SUCCEEDED(hr))
		{
			if(SUCCEEDED(hr))
			{
				hr = GetProperty((CProperty *)pProperty,pVal, pType,plFlavor);
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Sets property value of the object. If property is not present for the object
//	this function adds property to the object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::Put(	LPCWSTR wszName,
								long lFlags,
								VARIANT* pVal,
								CIMTYPE Type)
{
	HRESULT			hr			= S_OK;
	CHashElement *	pProperty		= NULL;

	hr = m_PropEnum.Get(wszName,lFlags,pProperty);
	if(!pProperty)
	{
//		hr = SetProperty((CProperty *)pProperty,pVal,Type);
	}
	else
	{
		hr = S_OK;
		if(IsValidName((WCHAR *)wszName))
		{
//			hr = AddProperty(wszName,lFlags,pVal,Type);
		}
		else
		{
			hr = WBEM_E_INVALID_PARAMETER;
		}
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Deletes a property
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::Delete( LPCWSTR wszName)
{
	HRESULT hr = S_OK;
	CHashElement *	pTemp		= NULL;

	hr = m_PropEnum.Get(wszName,0,pTemp);

	if(SUCCEEDED(hr))
	{
		CProperty *pProp = (CProperty *)pTemp;
		// FIXX Remove the property node 
		// hr = REMOVEPROPERTY(wszName);

		if(SUCCEEDED(hr))
		{
			hr = m_PropEnum.RemoveItem((WCHAR *)wszName);
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Gets names of all the property in a SAFEARRAY
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::GetNames(LPCWSTR wszQualifierName,
									long lFlags,
									VARIANT* pQualifierVal,
									SAFEARRAY * pNames)
{
	HRESULT hr = S_OK;

	if(!IsValidGetNamesFlag(lFlags) ||
	(((lFlags & WBEM_FLAG_ONLY_IF_TRUE) || 
		(lFlags & WBEM_FLAG_ONLY_IF_IDENTICAL)) &&
		wszQualifierName == NULL))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}

	if(lFlags == WBEM_FLAG_ALWAYS)
	{
		hr = m_PropEnum.GetNames(lFlags ,&pNames);
	}
	else
	{
		LONG			lCurEnumPos	= m_PropEnum.GetEnumPos();
		ENUMSTATE		curEState	= m_PropEnum.GetEnumState();
		BSTR			strName		= NULL;
		CHashElement *	pElem		= NULL;
		CProperty	 *	pProp		= NULL;

		hr = m_PropEnum.BeginEnumeration(GetEnumFlags(lFlags));
		while (hr == S_OK)
		{
			if(SUCCEEDED(hr = m_PropEnum.Next(0,&strName,pElem)))
			{
				pProp = (CProperty *)pElem;
				CWbemQualifierSet *pSet = pProp->GetQualifierSet();

				if(pSet)
				{
				}
				else
				{
					hr = E_FAIL;
				}
			}
		}

		m_PropEnum.EndEnumeration();
		
		m_PropEnum.SetEnumPos(lCurEnumPos);
		m_PropEnum.SetEnumState(curEState);
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Begins property enumeration on the object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::BeginEnumeration(long lEnumFlags)
{
	return m_PropEnum.BeginEnumeration(lEnumFlags);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Fetches the next property in the enumeration
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::Next(long lFlags,
								BSTR* strName,
								VARIANT* pVal,
								CIMTYPE* pType,
								long* plFlavor)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Ends property enumeration
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::EndEnumeration()
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Gets pointer to the property qualifier set
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::GetPropertyQualifierSet(	LPCWSTR wszProperty,
													IWbemQualifierSet** ppQualSet)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Creates and returns a copy of the current WBEM object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::Clone(IWbemClassObject** ppCopy)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the WBEM object as text in MOF format
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::GetObjectText(long lFlags,
										BSTR* pstrObjectText)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Creates a class derived for the current object
//	Function is valid only if the object is a class
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::SpawnDerivedClass(long lFlags,
												IWbemClassObject** ppNewClass)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Creates an instance of class represented by this object
//	Function valid only if the object represented is a class
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::SpawnInstance(long lFlags,
										IWbemClassObject** ppNewInstance)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Compares the current object with another
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::CompareTo(long lFlags,
									IWbemClassObject* pCompareTo)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Gets the names of the class in which the property was defined
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::GetPropertyOrigin(LPCWSTR wszName,
											BSTR* pstrClassName)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Returns the parent class name
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::InheritsFrom(LPCWSTR strAncestor)
{
	HRESULT hr = S_OK;
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
//	Fetches detail about a particular method
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::GetMethod(LPCWSTR wszName,
									long lFlags,
									IWbemClassObject** ppInSignature,
									IWbemClassObject** ppOutSignature)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Adds a method to the object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::PutMethod(LPCWSTR wszName,
									long lFlags,
									IWbemClassObject* pInSignature,
									IWbemClassObject* pOutSignature)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Deletes a method on the WMI object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::DeleteMethod(LPCWSTR wszName)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Begins method enumeration on the object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::BeginMethodEnumeration(long lEnumFlags)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Gets the next method in the method enumeration
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::NextMethod(long lFlags,
									  BSTR* pstrName,
									  IWbemClassObject** ppInSignature,
									  IWbemClassObject** ppOutSignature)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Ends method enumeration on the object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::EndMethodEnumeration()
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Returns IWbemQualifierset pointer for method qualifiers
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::GetMethodQualifierSet(LPCWSTR wszMethod,
												IWbemQualifierSet** ppQualSet)
{
	HRESULT hr = S_OK;
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Get class name of in which a particular method was defined
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWbemClassObject::GetMethodOrigin(LPCWSTR wszMethodName,
										   BSTR* pstrClassName)
{
	HRESULT hr = S_OK;
	return hr;
}



//////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//
//	Function to initiallize class/instance qualifiers
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassObject::InitializeQualifiers()
{
	HRESULT hr = S_OK;

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Initialize qualifiers for a property
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassObject::InitializePropQualifiers(WCHAR * pstrProp)
{
	HRESULT hr = S_OK;

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Initialize qualifiers for a Method
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassObject::InitializeMethodQualifiers(WCHAR * pstrMethod)
{
	HRESULT hr = S_OK;

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Initialize a particular property and add it to the hashtable
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassObject::InitializeProperty(WCHAR * pstrProp)
{
	HRESULT hr = S_OK;

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Initialize a all properties and add it to the hashtable
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassObject::InitializeAllProperties()
{
	HRESULT hr = S_OK;

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
//	Initialize a particular Method and add it to the hashtable
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassObject::InitializeMethod(WCHAR * pstrMethod)
{
	HRESULT hr = S_OK;

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Initialize a all properties and add it to the hashtable
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemClassObject::InitializeAllMethods()
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT CWbemClassObject::GetProperty(CProperty * pProperty,VARIANT * pVal, CIMTYPE * pType,LONG * plFlavor)
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT CWbemClassObject::InitObject()
{
	HRESULT hr = S_OK;
	if(!m_bInitObject)
	{
		if(m_pIDomDoc)
		{
			hr = E_FAIL;
		}
		else
		{
			m_bInitObject = TRUE;
		}
	}

	return hr;
}

LONG GetEnumFlags(LONG lFlags)
{
	LONG lEnumFlags = 0;

	if(lFlags & WBEM_FLAG_SYSTEM_ONLY)
	{
		lEnumFlags |= WBEM_FLAG_SYSTEM_ONLY;
	}

	if(lFlags & WBEM_FLAG_NONSYSTEM_ONLY)
	{
		lEnumFlags |= WBEM_FLAG_NONSYSTEM_ONLY;
	}

	if(lFlags & WBEM_FLAG_LOCAL_ONLY)
	{
		lEnumFlags |= WBEM_FLAG_LOCAL_ONLY;
	}

	if(lFlags & WBEM_FLAG_PROPAGATED_ONLY)
	{
		lEnumFlags |= WBEM_FLAG_PROPAGATED_ONLY;
	}

	return lEnumFlags;
}

BOOL IsValidGetNamesFlag(LONG lFlags)
{
	BOOL bSet = TRUE;
	BOOL bRet = TRUE;
	// one of the three flags is to be set
	// WBEM_FLAG_ONLY_IF_TRUE ,WBEM_FLAG_ONLY_IF_FALSE & WBEM_FLAG_ONLY_IF_FALSE
	if(WBEM_FLAG_ONLY_IF_TRUE & lFlags)
	{
		bSet = TRUE;
	}
	if(WBEM_FLAG_ONLY_IF_FALSE & lFlags)
	{
		if(bSet)
		{
			bRet = FALSE;
		}
	}

	if(WBEM_FLAG_ONLY_IF_IDENTICAL & lFlags)
	{
		if(bSet)
		{
			bRet = FALSE;
		}
		bSet = TRUE;
	}
	 
	if(!bSet)
	{
		bRet = FALSE;
	}

	// only WBEM_FLAG_LOCAL_ONLY or WBEM_FLAG_PROPAGATED_ONLY can be set
	if(bRet)
	{
		bSet = FALSE;
		if(lFlags & WBEM_FLAG_LOCAL_ONLY)
		{
			bSet = TRUE;
		}

		if(lFlags & WBEM_FLAG_PROPAGATED_ONLY)
		{
			if(bSet)
			{
				bRet = FALSE;
			}
			bSet = TRUE;
		}

	}

	// only WBEM_FLAG_SYSTEM_ONLY or WBEM_FLAG_NONSYSTEM_ONLY can be set
	if(bRet)
	{
		bSet = FALSE;
		if(lFlags & WBEM_FLAG_SYSTEM_ONLY)
		{
			bSet = TRUE;
		}

		if(lFlags & WBEM_FLAG_NONSYSTEM_ONLY)
		{
			if(bSet)
			{
				bRet = FALSE;
			}
			bSet = TRUE;
		}

	}
	
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wbemqualset.cpp ===
//***************************************************************************/
//
//  WbemQualSet.CPP
//
//  Purpose: Implementation of IWbemQualifierSet interface in 
//				CWbemQualifierSet class
//
//  Copyright (c)1997-2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************/
#include <precomp.h>
#include <wmi2xsd.h>
#include "wbemqualset.h"

//*********************************************************************************************
//		CPropRoot Class implementation
//*********************************************************************************************


////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CPropRoot::CPropRoot()
{
	m_pszName	= NULL;
	m_lFlavor	= 0;
	m_cimType	= 0;
	m_lFlags	= WBEM_FLAVOR_ORIGIN_LOCAL;
	VariantInit(&m_vValue);

}

////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//  
////////////////////////////////////////////////////////////////////////////////////////
CPropRoot::~CPropRoot()
{
	VariantClear(&m_vValue);
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to set the name of the qualifier
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropRoot::SetName(LPCWSTR szName)
{
	m_pszName  = (WCHAR *)szName;
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Set flags for the qualifier
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropRoot::SetFlags(LONG lFlags)
{
	HRESULT hr = S_OK;
	if(lFlags == WBEM_FLAVOR_ORIGIN_LOCAL || lFlags == WBEM_FLAVOR_ORIGIN_PROPAGATED)
	{
		m_lFlags = lFlags;
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Set Qualifier flavor
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropRoot::SetFlavor(LONG lFlavor)
{
	m_lFlavor = lFlavor;
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Set qualifier Value
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropRoot::SetValue(VARIANT *pVal)
{
	HRESULT hr = S_OK;
	VariantClear(&m_vValue);
	
	if(pVal)
	{
		hr = VariantCopy(&m_vValue,pVal);
	}
	
	if(SUCCEEDED(hr))
	{
		// FIXX m_cimType = GetCIMType(pVal->vt);
	}
	return hr;
}


//*********************************************************************************************
//		End of CPropRoot Class implementation
//*********************************************************************************************


//*********************************************************************************************
//		CWbemQualifierSet Class implementation
//*********************************************************************************************

////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CWbemQualifierSet::CWbemQualifierSet() 
: m_Enum(QUALIFIERS_ENUM)
{
	m_cRef			= 0;
	InterlockedIncrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//  
////////////////////////////////////////////////////////////////////////////////////////
CWbemQualifierSet::~CWbemQualifierSet()
{
	InterlockedDecrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to initialize the object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::FInit()
{
	HRESULT hr = S_OK;	
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// QueryInterface
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWbemQualifierSet::QueryInterface(REFIID riid, LPVOID* ppv)
{
	HRESULT hr = E_NOINTERFACE;
	*ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWbemQualifierSet==riid)
		*ppv = reinterpret_cast<IWbemQualifierSet *>(this);

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = NOERROR;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// AddRef
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CWbemQualifierSet::AddRef(void)
{
	return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Release 
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CWbemQualifierSet::Release(void)
{
	if(InterlockedDecrement(&m_cRef) == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to fetch a qualifier
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::Get(	LPCWSTR wszName,
								long lFlags,
								VARIANT *pVal,
								long *plFlavor)
{
	HRESULT hr = S_OK;
	if(wszName && lFlags != 0  )
	{
		CHashElement *pQualifier = NULL;
		hr = m_Enum.Get(wszName,lFlags,pQualifier);
		if(pQualifier && SUCCEEDED(hr))
		{
			if(SUCCEEDED(hr))
			{
				hr = GetQualifier((CQualifier *)pQualifier,pVal,plFlavor);
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}

	return hr;
}
        
////////////////////////////////////////////////////////////////////////////////////////
//
// Function to put a value to qualifier or to add a new qualifier
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::Put(LPCWSTR wszName,
								VARIANT *pVal,
								long lFlavor)
{
	HRESULT hr		= S_OK;
	BOOL	bNew	= FALSE;

	if(FAILED(IsValidFlavor(lFlavor)) || 
		wszName == NULL || 
		(wszName != NULL && wcslen(wszName) == 0))
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		CHashElement *pTemp = NULL;
		CQualifier *pQualifier = NULL;
		hr = m_Enum.Get(wszName,0,pTemp);

		// if qualifier is not present then add a new qualifier
		if(!pTemp)
		{
			if(IsValidName((WCHAR *)wszName))
			{
				hr = AddQualifer(wszName,pVal,lFlavor);
			}
			else
			{
				hr = WBEM_E_INVALID_PARAMETER;
			}
		}
		else
		{
			pQualifier = (CQualifier *)pTemp;
			if(SUCCEEDED(hr = pQualifier->SetValue(pVal)))
			{
				hr = pQualifier->SetFlavor(lFlavor);
			}
		}
	}
	return hr;
}
        
////////////////////////////////////////////////////////////////////////////////////////
//
// Function to delete an existing qualifier
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::Delete(LPCWSTR wszName)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	
	if(wszName)
	{
		hr = m_Enum.RemoveItem((WCHAR *)wszName);
	}
	return hr;
}
        
////////////////////////////////////////////////////////////////////////////////////////
//
// Function to get names of all the qualifiers in the qualifier set
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::GetNames(long lFlags,SAFEARRAY * *pNames)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;

	if(ISValidEnumFlags(lFlags))
	{
		hr = S_OK;
	}

	if(pNames && SUCCEEDED(hr))
	{
		hr = m_Enum.GetNames(lFlags,pNames);
	}
	return hr;
}
        
////////////////////////////////////////////////////////////////////////////////////////
//
// Function to set begin enumeration on the qualifier set
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::BeginEnumeration(long lFlags)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	if(ISValidEnumFlags(lFlags))
	{
		hr = m_Enum.BeginEnumeration(lFlags);
	}
	return hr;
}
        
////////////////////////////////////////////////////////////////////////////////////////
//
// Function to get the next qualifier in the qualifier set
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::Next(long lFlags,
								BSTR *pstrName,
								VARIANT *pVal,
								long *plFlavor)
{
	HRESULT hr = S_OK;

	if(lFlags != 0)
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		// Get the next qualifier
		CHashElement *pQualifier = NULL;
		hr = m_Enum.Next(lFlags,pstrName,pQualifier);
		if(pQualifier && SUCCEEDED(hr))
		{
			hr = GetQualifier((CQualifier *)pQualifier,pVal,plFlavor);
				
			if(FAILED(hr))
			{
				SAFE_FREE_SYSSTRING(*pstrName);
			}
		}
	}
	return hr;
}
        
////////////////////////////////////////////////////////////////////////////////////////
//
// Function to end the qualifier enumeration
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::EndEnumeration(void)
{
	return m_Enum.EndEnumeration();
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Gets a qualifier
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::GetQualifier(CQualifier *pQualifier ,VARIANT *pVal,long *plFlavor)
{
	HRESULT hr = S_OK;
	if(pVal)
	{
		hr = VariantCopy(pVal,pQualifier->GetValue());
	}
	if(plFlavor)
	{
		*plFlavor = pQualifier->GetFlavor();
	}

	if(FAILED(hr) && pVal)
	{
		VariantClear(pVal);
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a qualilfer to the linked list
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemQualifierSet::AddQualifer(LPCWSTR wszName,	VARIANT *pVal,long lFlavor , LONG lFlags)
{
	HRESULT hr = WBEM_E_OUT_OF_MEMORY;
	CQualifier * pQualifier = new CQualifier;

	WCHAR *pszNameToAdd = new WCHAR[wcslen(wszName) + 1 ];

	if(pszNameToAdd)
	{
		wcscpy(pszNameToAdd,wszName);
	}

	if(pQualifier && pszNameToAdd)
	{
		hr = pQualifier->SetName(wszName);
	}

	if(SUCCEEDED(hr))
	{
		hr = pQualifier->SetValue(pVal);
	}

	if(SUCCEEDED(hr))
	{
		hr = pQualifier->SetFlavor(lFlavor);
	}

	if(SUCCEEDED(hr))
	{
		hr = pQualifier->SetFlags(lFlags);
	}

	int nIndex = 0;
	if(SUCCEEDED(hr))
	{
		hr = m_Enum.AddItem(pszNameToAdd,pQualifier);
	}
	
	if(FAILED(hr))
	{
		SAFE_DELETE_PTR(pQualifier);
		SAFE_DELETE_PTR(pszNameToAdd);
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if a given qualifier flavor is valid
//  
////////////////////////////////////////////////////////////////////////////////////////
 
HRESULT CWbemQualifierSet::IsValidFlavor(LONG lFlavor)
{
	LONG lTempFlavor =	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS ||
						WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	||
						WBEM_FLAVOR_NOT_OVERRIDABLE	||
						WBEM_FLAVOR_OVERRIDABLE	||
						WBEM_FLAVOR_AMENDED;

	return (lFlavor | ~lTempFlavor) ? E_FAIL : S_OK;
	

}

////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if the enum flags are valid
//  
////////////////////////////////////////////////////////////////////////////////////////
 
BOOL CWbemQualifierSet::ISValidEnumFlags(LONG lFlags)
{
	return (lFlags == 0 || lFlags == WBEM_FLAG_LOCAL_ONLY || lFlags == WBEM_FLAG_PROPAGATED_ONLY);
}
//*********************************************************************************************
//		End of CWbemQualifierSet Class implementation
//*********************************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wbemclassobject.h ===
/***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WbemClassObject.h
//
//  ramrao Jan 4th 2001 - Created
//
//
//		Declaration of CWbemClassObject class and some related classes
//		This class implements IWbemClassObject interface
//
//***************************************************************************/

#include "wbemqualset.h"

//========================================================================
// class to store a property
//========================================================================
class CProperty :public CPropRoot
{
private:
	WCHAR *					m_pszOriginClass;
	IXMLDOMNode *			m_pNode;
	CWbemQualifierSet	*	m_pQualSet;		// PropertyQualifier

public:
	CProperty();
	virtual ~CProperty();

	HRESULT SetPropOrigin(WCHAR * pstrOrigin);
	WCHAR * GetPropOrigin() {return 	m_pszOriginClass;}
	CWbemQualifierSet *	GetQualifierSet() { return m_pQualSet;}
};




//========================================================================
// Class to implement IWbemClassObject interface
//========================================================================
class CWbemClassObject:public IWbemClassObject
{
private:
	CEnumObject				m_PropEnum;
	LONG					m_cRef;
	CWbemQualifierSet	*	m_pQualSet;		// class/instance qualifierset
	BOOL					m_bClass;

	IXMLDOMDocument2	*	m_pIDomDoc;
	BOOL					m_bInitObject;

public:
	CWbemClassObject();
	virtual ~CWbemClassObject();

	// IUnknown Methods
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    virtual HRESULT STDMETHODCALLTYPE  GetQualifierSet(
		/* [out] */ IWbemQualifierSet** ppQualSet);

    virtual HRESULT STDMETHODCALLTYPE  Get(
        /* [in, string] */ LPCWSTR wszName,
        /* [in] */ long lFlags,
        /* [out, OPTIONAL] */ VARIANT* pVal,
        /* [out, OPTIONAL] */ CIMTYPE* pType,
        /* [out, OPTIONAL] */ long* plFlavor);

    virtual HRESULT STDMETHODCALLTYPE  Put(
        /* [in, string] */	LPCWSTR wszName,
        /* [in] */			long lFlags,
        /* [in] */			VARIANT* pVal,
        /* [in] */			CIMTYPE Type);

    virtual HRESULT STDMETHODCALLTYPE  Delete(/* [in, string] */ LPCWSTR wszName);

    virtual HRESULT STDMETHODCALLTYPE  GetNames(
        /* [in, string] */	LPCWSTR wszQualifierName,
        /* [in] */			long lFlags,
        /* [in] */			VARIANT* pQualifierVal,
        /* [out] */			SAFEARRAY * pNames);

    virtual HRESULT STDMETHODCALLTYPE  BeginEnumeration(/* [in] */ long lEnumFlags);

    virtual HRESULT STDMETHODCALLTYPE  Next(
        /* [in] */ long lFlags,
        /* [out, OPTIONAL] */ BSTR* strName,
        /* [out, OPTIONAL] */ VARIANT* pVal,
        /* [out, OPTIONAL] */ CIMTYPE* pType,
        /* [out, OPTIONAL] */ long* plFlavor
        );

    virtual HRESULT STDMETHODCALLTYPE  EndEnumeration();

    virtual HRESULT STDMETHODCALLTYPE  GetPropertyQualifierSet(
        /* [in, string] */	LPCWSTR wszProperty,
        /* [out] */			IWbemQualifierSet** ppQualSet);

    virtual HRESULT STDMETHODCALLTYPE  Clone(
        /* [out] */ IWbemClassObject** ppCopy
        );

    virtual HRESULT STDMETHODCALLTYPE  GetObjectText(
        /* [in] */  long lFlags,
        /* [out] */ BSTR* pstrObjectText
        );

    virtual HRESULT STDMETHODCALLTYPE  SpawnDerivedClass(
        /* [in] */ long lFlags,
        /* [out] */ IWbemClassObject** ppNewClass);

    virtual HRESULT STDMETHODCALLTYPE  SpawnInstance(
        /* [in] */ long lFlags,
        /* [out] */ IWbemClassObject** ppNewInstance);

    virtual HRESULT STDMETHODCALLTYPE  CompareTo(
        /* [in] */ long lFlags,
        /* [in] */ IWbemClassObject* pCompareTo
        );

    virtual HRESULT STDMETHODCALLTYPE  GetPropertyOrigin(
        /* [in, string] */ LPCWSTR wszName,
        /* [out] */ BSTR* pstrClassName);

    virtual HRESULT STDMETHODCALLTYPE  InheritsFrom(
        /* [in] */ LPCWSTR strAncestor);

    // Method manipulation.
    // ====================

    virtual HRESULT STDMETHODCALLTYPE  GetMethod(
        /* [in, string] */ LPCWSTR wszName,
        /* [in] */ long lFlags,
        /* [out] */ IWbemClassObject** ppInSignature,
        /* [out] */ IWbemClassObject** ppOutSignature);

    virtual HRESULT STDMETHODCALLTYPE  PutMethod(
        /* [in, string] */ LPCWSTR wszName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemClassObject* pInSignature,
        /* [in] */ IWbemClassObject* pOutSignature);

    virtual HRESULT STDMETHODCALLTYPE  DeleteMethod(
        /* [in, string] */ LPCWSTR wszName);

    virtual HRESULT STDMETHODCALLTYPE  BeginMethodEnumeration(/* [in] */ long lEnumFlags);

    virtual HRESULT STDMETHODCALLTYPE  NextMethod(
        /* [in] */ long lFlags,
        /* [out, OPTIONAL] */ BSTR* pstrName,
        /* [out, OPTIONAL] */ IWbemClassObject** ppInSignature,
        /* [out, OPTIONAL] */ IWbemClassObject** ppOutSignature);

    virtual HRESULT STDMETHODCALLTYPE  EndMethodEnumeration();

    virtual HRESULT STDMETHODCALLTYPE  GetMethodQualifierSet(
        /* [in, string] */ LPCWSTR wszMethod,
        /* [out] */ IWbemQualifierSet** ppQualSet);

    virtual HRESULT STDMETHODCALLTYPE  GetMethodOrigin(
        /* [in, string] */ LPCWSTR wszMethodName,
        /* [out] */ BSTR* pstrClassName);



	HRESULT FInit(VARIANT *pVarXml);

private:
	HRESULT InitializeQualifiers();
	HRESULT InitializePropQualifiers(WCHAR * pstrProp);
	HRESULT InitializeMethodQualifiers(WCHAR * pstrMethod);
	HRESULT InitializeProperty(WCHAR * pstrProp);
	HRESULT InitializeAllProperties();
	HRESULT InitializeMethod(WCHAR * pstrMethod);
	HRESULT InitializeAllMethods();
	HRESULT GetProperty(CProperty * pProperty,VARIANT * pVal, CIMTYPE * pType,LONG * plFlavor);
	HRESULT InitObject();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmi2xsdguids.h ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Wmi2XsdGuids.h
//
//  ramrao 13 Nov 2000 - Created
//
//  DLL entry points except for IWbemObjectTextSrc 
//
//***************************************************************************/

#ifndef _WMI2XSDGUID_

#define _WMI2XSDGUID_

// {2E014513-4D34-45b7-8DFF-4BA91405A99F}
DEFINE_GUID(CLSID_WMIXMLConverter, 
0x2e014513, 0x4d34, 0x45b7, 0x8d, 0xff, 0x4b, 0xa9, 0x14, 0x5, 0xa9, 0x9f);

// {13D1C40C-13D9-423a-AE9E-5241A9C1EF78}
DEFINE_GUID(CLSID_XMLWMIConverter, 
0x13d1c40c, 0x13d9, 0x423a, 0xae, 0x9e, 0x52, 0x41, 0xa9, 0xc1, 0xef, 0x78);

// {F46ACA59-7ED3-45ed-AE2E-3C64DA381459}
DEFINE_GUID(IID_IWMIXMLConverter, 
0xf46aca59, 0x7ed3, 0x45ed, 0xae, 0x2e, 0x3c, 0x64, 0xda, 0x38, 0x14, 0x59);

// {98775469-904D-45ce-9718-AF89F6A24BEE}
DEFINE_GUID(IID_IXMLWMIConverter, 
0x98775469, 0x904d, 0x45ce, 0x97, 0x18, 0xaf, 0x89, 0xf6, 0xa2, 0x4b, 0xee);


#endif // _WMI2XSDGUID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmi2xmlstrs.h ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmi2xmlstrs.h
//
//  ramrao 7 Dec 2000 - Created
//
//
//		Declaration of the various strings used and macros to write
//		data to stream
//
//***************************************************************************/
#ifndef	WMIXML_STR_H

#define WMIXML_STR_H

const WCHAR	STR_BEGINANNOTATION[]				=	L"<xsd:annotation>";
const WCHAR	STR_ENDANNOTATION[]					=	L"</xsd:annotation>";
const WCHAR	STR_BEGINAPPINFO[]					=	L"<xsd:appinfo>";
const WCHAR	STR_ENDAPPINFO[]					=	L"</xsd:appinfo>";
const WCHAR	STR_ENDCOMPLEXTYPE[]				=	L"</xsd:complexType>";
const WCHAR	STR_ENDCHILDCOMPLEXTYPE[]			=	L"</xsd:extension></xsd:complexContent>";
const WCHAR	STR_ENDXSDSCHEMA[]					=	L"</xsd:schema>";
const WCHAR	STR_BEGINGROUP[]					=	L"<xsd:group>\n<xsd:all>";
const WCHAR	STR_ENDGROUP[]						=	L"</xsd:all>\n</xsd:group>";
const WCHAR	STR_XSDANYATTR[]					=	L"<xsd:anyAttribute/>";
const WCHAR	STR_OVERRIDABLE[]					=	L" overridable = 'True' ";
const WCHAR	STR_TOSUBCLASS[]					=	L" toSubclass = 'True' ";
const WCHAR	STR_TOINSTANCE[]					=	L" toInstance = 'True' ";
const WCHAR	STR_AMENDED[]						=	L" amended = 'True'";
const WCHAR	STR_CLASS_SCHEMALOC[]				=	L"%s:%s";
const WCHAR	STR_XSINAMESPACE[]					=	L" xmlns:xsi='http://www.w3.org/2000/10/XLSchema-instance' ";
const WCHAR	STR_PROPNULL[]						=	L" xsi:null='1' ";

const WCHAR STR_TRUE[]							=	L"True";
const WCHAR STR_FALSE[]							=	L"False";

const WCHAR STR_CDATA_START[]					=	L"<![CDATA[";
const WCHAR STR_CDATA_END[]						=	L"]]>";
const WCHAR	STR_BEGINARRAYELEM[]				=	L"<arrayElement>";
const WCHAR	STR_ENDARRAYELEM[]					=	L"</arrayElement>";

const WCHAR	STR_ARRAYTYPE[]						=	L"arrayType";

const WCHAR	STR_QUALIFIER[]						=	L"qualifier";
const WCHAR	STR_PROPERTY[]						=	L"property";
const WCHAR	STR_METHOD[]						=	L"method";
const WCHAR	STR_METHODPARAM[]					=	L"parameter";
const WCHAR	STR_METHODRETVAL[]					=	L"returnval";

const WCHAR	STR_NAMEATTR[]						=	L" name";
const WCHAR	STR_TYPEATTR[]						=	L" Type";
const WCHAR	STR_ARRAYATTR[]						=	L" array";
const WCHAR	STR_VALUEATTR[]						=	L" value";
const WCHAR	STR_MINOCCURS[]						=	L" minOccurs";
const WCHAR	STR_MAXOCCURS[]						=	L" maxOccurs";
const WCHAR STR_BASEATTR[]						=	L" base";
const WCHAR STR_SCHEMALOCATTR[]					=	L" schemaLocation";
const WCHAR STR_NAMESPACEATTR[]					=	L" namespace";
const WCHAR	STR_TARGETNAMESPACEATTR[]			=	L" targetNamespace";
const WCHAR	STR_DEFAULTATTR[]					=	L" default";
const WCHAR STR_ARRAY_TYPEATTR[]				=	L" arrayType";

const WCHAR STR_ELEMENT[]						=	L"xsd:element";
const WCHAR STR_COMPLEXTYPE[]					=	L"xsd:complexType";
const WCHAR	STR_BEGINCHILDCOMPLEXTYPE[]			=	L"<xsd:complexContent>";
const WCHAR STR_BEGINEXTENSION[]				=	L"<xsd:extension";
const WCHAR	STR_XSDINCLUDE[]					=	L"xsd:include";
const WCHAR	STR_XSDIMPORT[]						=	L"xsd:import";
const WCHAR	STR_BEGINXSD[]						=	L"<xsd:schema xmlns:xsd = 'http://www.w3.org/2000/10/XMLSchema' ";
const WCHAR	STR_NAMESPACE[]						=	L" xmlns";
const WCHAR	STR_XSISCHEMALOC[]					=	L" xsi:schemaLocation";

const WCHAR	STR_EQUALS[]						=	L"=";
const WCHAR	STR_SINGLEQUOTE[]					=	L"'";
const WCHAR	STR_CLOSINGBRACKET[]				=	L">";
const WCHAR	STR_BEGININGBRACKET[]					=	L"<";
const WCHAR	STR_FORWARDSLASH[]					=	L"/";
const WCHAR	STR_COLON[]							=	L":";
const WCHAR	STR_SPACE[]							=	L" ";


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmiconnection.cpp ===
/***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WmiConnection.cpp
//
//  ramrao 22 Nov 2000 - Created
//
//
//		Implementation of CWMIConnection class
//
//***************************************************************************/

#include "precomp.h"
#include "wmitoxml.h"

////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor
//  
////////////////////////////////////////////////////////////////////////////////////////
CWMIConnection::CWMIConnection(BSTR strNamespace , BSTR strUser,BSTR strPassword,BSTR strLocale)
{
	m_pIWbemServices	= NULL;
	m_bInitFailed		= FALSE;
	m_strNamespace		= NULL;
	m_strUser			= NULL;
	m_strPassword		= NULL;
	m_strLocale			= NULL;

	if(strNamespace)
	{
		m_strNamespace		= SysAllocString(strNamespace);
	}

	if(strUser)
	{
		m_strUser			= SysAllocString(strUser);
	}

	if(strPassword)
	{
		m_strPassword		= SysAllocString(strPassword);
	}

	if(strLocale)
	{
		m_strLocale			= SysAllocString(strLocale);
	}

	if((strNamespace && !m_strNamespace) ||
		(strUser && !strUser) ||
		(strPassword && !strPassword) ||
		(m_strLocale && !strLocale) )
	{
		m_bInitFailed = TRUE;
	}

	m_lRef = 1;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//  
////////////////////////////////////////////////////////////////////////////////////////
CWMIConnection::~CWMIConnection()
{
	SAFE_RELEASE_PTR(m_pIWbemServices);
	SAFE_FREE_SYSSTRING(m_strNamespace);
	SAFE_FREE_SYSSTRING(m_strUser);
	SAFE_FREE_SYSSTRING(m_strPassword);
	SAFE_FREE_SYSSTRING(m_strLocale);
}


////////////////////////////////////////////////////////////////////////////////////////
//
//	Function to return the object for a class. This makes a connection to WMI if required
//	Uses the user credentials already set on this object.
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIConnection::GetObject(BSTR strClassName , IWbemClassObject ** ppObject)
{
	HRESULT hr = E_FAIL;
	if(!m_bInitFailed)
	{
		if(SUCCEEDED(hr = ConnectToWMI()))
		{
			hr = m_pIWbemServices->GetObject(strClassName,0,NULL,ppObject,NULL);
		}

	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to connect to WMI with the given user credentials
//	
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIConnection::ConnectToWMI()
{
	HRESULT hr = S_OK;
	if(!m_pIWbemServices)
	{
		IWbemLocator *pLoc = NULL;

		if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_INPROC_SERVER ,IID_IWbemLocator,(void **)&pLoc)))
		{

			hr = pLoc->ConnectServer(m_strNamespace,
									m_strUser,			//using current account
									m_strUser,			//using current password
									m_strLocale,		// locale						// Add Locale
									0L,					// securityFlags
									NULL,				// authority (NTLM domain)
									NULL,				// context
									&m_pIWbemServices);
		}

		SAFE_RELEASE_PTR(pLoc);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlconverter.h ===
#ifndef _IWMITOXMLCONVERTER_H_
#define _IWMITOXMLCONVERTER_H_

class CWmiXMLConverter : public IWMIXMLConverter
{

private:
	long					m_cRef; 

	CWMIToXML	*			m_pXmlConverter;
	CCriticalSection	*	m_pCritSec;

public:
	CWmiXMLConverter();
	virtual ~CWmiXMLConverter();

	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetXMLNamespace( 
            /* [in] */ BSTR strNamespace,
            /* [in] */ BSTR strNamespacePrefix);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetWMIStandardSchemaLoc( 
            /* [in] */ BSTR strStdImportSchemaLoc,
            /* [in] */ BSTR strStdImportNamespace,
            /* [in] */ BSTR strNameSpaceprefix);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSchemaLocations( 
            /* [in] */ ULONG cSchema,
            /* [in] */ BSTR *pstrSchemaLocation);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetXMLForObject( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ LONG lFlags,
            /* [in] */ IStream *pOutputStream);
        




public:
	HRESULT FInit();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmitoxml.h ===
/***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmitoxml.h
//
//  ramrao 13 Nov 2000 - Created
//
//
//		Declaration of CWMIToXML class
//
//***************************************************************************/


#ifndef _CWMITOXML_H_

#define _CWMITOXML_H_

class CWbemConnection
{
protected:
	LONG	m_lRef;

public:
	
	CWbemConnection() { m_lRef = 1;}

	virtual HRESULT GetObject(BSTR strClassName, IWbemClassObject ** ppObject) = 0;
	
	ULONG	AddRef() 
	{ 
		return InterlockedIncrement(&m_lRef);
	}

	ULONG	Release() 
	{ 
		if(InterlockedDecrement(&m_lRef) == 0) 
		{
			delete this;
			return 0;
		}
		return m_lRef;
	}

};


class CWMIConnection : public CWbemConnection
{
	IWbemServices *	m_pIWbemServices ;
	BSTR			m_strNamespace;
	BSTR			m_strUser;
	BSTR			m_strPassword;
	BSTR			m_strLocale;

	LONG			m_bInitFailed;

public:
	CWMIConnection(BSTR strNamespace , BSTR strUser,BSTR strPassword,BSTR strLocale);
	virtual ~CWMIConnection();

	virtual HRESULT GetObject(BSTR strClassName, IWbemClassObject ** ppObject);

private:

	HRESULT ConnectToWMI();
};



class CWMIToXML
{
private:

	IWbemClassObject *		m_pIObject;
	CWbemConnection	 *		m_pConnection;

	BSTR					m_strUser;
	BSTR					m_strPassword;
	BSTR					m_strLocale;

	IStream *				m_pITmpStream;

	CWMIXMLSchema		*	m_pSchema;
	CWMIXMLInstance		*	m_pInstance;

	BSTR					m_strWmiNamespace;
	BSTR					m_strWmiSchemaLoc;
	BSTR					m_strWmiSchemaPrefix;

	BSTR					m_strNamespace;
	BSTR					m_strNamespacePrefix;


	BOOL					m_bClass;
	BOOL					m_bDCOMObj;
	LONG					m_lFlags;
	CPtrArray				m_arrSchemaLocs;

public:
	CWMIToXML() ;
	virtual ~CWMIToXML() ;

	HRESULT SetUserAuthentication(BSTR strUser,BSTR strPassword,BSTR strLocale);

	HRESULT GetXML(BSTR & strSchema);
	HRESULT GetXML(IStream *pStream);


	void SetFlags(LONG lFlags)
	{
		m_lFlags = lFlags;
	}
	HRESULT SetWMIObject(IWbemClassObject *pObject);
	HRESULT SetXMLNamespace(BSTR strNamespace,BSTR strNamespacePrefix);
	HRESULT SetWMIStandardSchemaLoc(BSTR strStdImportSchemaLoc,BSTR strStdImportNamespace,BSTR strNameSpaceprefix);
	HRESULT SetSchemaLocations(ULONG cSchema,BSTR *pstrSchemaLocation);



private:
	HRESULT InitInstanceObject();
	HRESULT AddPropertiesForSchema();
	HRESULT AddPropertiesForInstance();
	HRESULT SetSchemaLocation();
	HRESULT GetSchema();
	HRESULT GetInstance();

	HRESULT AddSchemaAttributesAndIncludes();
	HRESULT AddProperties();
	HRESULT AddQualifiers(IWbemQualifierSet *pQualifierSet);
	HRESULT AddMethods();
	HRESULT AddMethodParameter(IWbemClassObject *pObject, BOOL bReturnVal);

	BOOL IsClass() { return m_bClass; }

	
	void	ReleaseSchemaLocs(BOOL bReleaseInUnderlyingObject = FALSE );
	HRESULT SetTargetNamespace();
	HRESULT AddSchemaIncludes();
	HRESULT SetWMIStdSchemaInfo();
	HRESULT InitSchemaObject();

	HRESULT LogAndSetOutputString(IStream *pStream,BOOL bStrout = FALSE,BSTR * pstrOut = NULL);

	BOOL	IsDCOMObj() { return m_bDCOMObj; }
	HRESULT GetClass(BSTR strClass,IWbemClassObject ** pObject);
	HRESULT ExtractNamespace(BSTR & strNamespace);
	HRESULT IsPropertyChange(BSTR strProp,BOOL &bChange);

	HRESULT GetQualifier(	BSTR strProperty, 
							BSTR strQualifier , 
							VARIANT * pvVal , 
							LONG *  plFlavor = NULL,
							IWbemClassObject *pIObject = NULL);
	
	HRESULT GetSchemaLocationOfClass(BSTR strClass ,BSTR & strSchemaLoc);
	HRESULT AddIncludesForClassIfAlreadyNotPresent(BSTR strClass);
	HRESULT GetEmbeddedType(BSTR strProp , BSTR & strEmbeddedType);
	HRESULT AddPropertiesForSchemaToAppInfo(BOOL bFindAddIncludes = FALSE);
	HRESULT SetStream(IStream *pStream);
	BOOL	CheckIfLocalQualifiersExist(IWbemQualifierSet * pQualifierSet);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmitoxml.cpp ===
***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmitoxml.cpp
//
//  ramrao 13 Nov 2000 - Created
//
//
//		Declaration of CWMIToXML class
//
//***************************************************************************/

#include <precomp.h>
#include "wmitoxml.h"
	


#define INITBUFFSIZE	10000
#define BUFFINCRSIZE	5000

#define CLASS_GENUS		1
/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CWMIToXML::CWMIToXML()
{
	m_pIObject				= NULL;
	m_pConnection			= NULL;

	m_strUser				= NULL;
	m_strPassword			= NULL;
	m_strLocale				= NULL;

	m_bDCOMObj				= TRUE;


	m_lFlags				= 0;

	m_strWmiNamespace		= NULL;	
	m_strWmiSchemaLoc		= NULL;
	m_strWmiSchemaPrefix	= NULL;

	m_strNamespace			= NULL;
	m_strNamespacePrefix	= NULL;
	m_bClass				= TRUE;
	m_pITmpStream			= NULL;

	m_pInstance				= NULL;
	m_pSchema				= NULL;

	// Set the initial size to 2 and growsize by 2
	m_arrSchemaLocs.SetSize(0,2);
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CWMIToXML::~CWMIToXML()
{
	SAFE_RELEASE_PTR(m_pIObject);
	SAFE_FREE_SYSSTRING(m_strUser);
	SAFE_FREE_SYSSTRING(m_strPassword);
	SAFE_FREE_SYSSTRING(m_strLocale);

	ReleaseSchemaLocs();

	SAFE_FREE_SYSSTRING(m_strWmiNamespace);
	SAFE_FREE_SYSSTRING(m_strWmiSchemaLoc);
	SAFE_FREE_SYSSTRING(m_strWmiSchemaPrefix);

	SAFE_FREE_SYSSTRING(m_strNamespace);
	SAFE_FREE_SYSSTRING(m_strNamespacePrefix);

	SAFE_DELETE_PTR(m_pInstance);
	SAFE_DELETE_PTR(m_pSchema);
	SAFE_DELETE_PTR(m_pConnection);

	SAFE_RELEASE_PTR(m_pITmpStream);

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initialization function to sent user credentials
//
// Returns	S_OK
//			E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::SetUserAuthentication(BSTR strUser,BSTR strPassword,BSTR strLocale)
{
	HRESULT hr = S_OK;

	SAFE_FREE_SYSSTRING(m_strUser);
	SAFE_FREE_SYSSTRING(m_strPassword);
	SAFE_FREE_SYSSTRING(m_strLocale);

	if(strUser)
	{
		if((m_strUser = SysAllocString(strUser)))
		{
			if(strPassword)
			{
				if(m_strPassword = SysAllocString(strPassword))
				{
					if(strLocale)
					{
						if(!(m_strLocale = SysAllocString(strLocale)))
						{
							hr = E_OUTOFMEMORY;
						}
					}
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if(FAILED(hr))
	{
		SAFE_FREE_SYSSTRING(m_strUser);
		SAFE_FREE_SYSSTRING(m_strPassword);
		SAFE_FREE_SYSSTRING(m_strLocale);
	}

	return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Gets Schema of a given class and puts data to the internal Stream
//
// Returns	S_OK
//			E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::GetSchema()
{
	HRESULT hr = S_OK;
	IWbemQualifierSet *pQualifierSet = NULL;
	
	if(WMIXML_INCLUDE_XSITYPE & m_lFlags)
	{
		hr = E_INVALIDARG;
	}
	
	if(SUCCEEDED(hr) && SUCCEEDED(hr = InitSchemaObject()))
	{
		// Call this function to navigate thru the propertyies
		// to find any embedded property and add includes for them
		hr = AddPropertiesForSchemaToAppInfo(TRUE);
	}

	// Add Includes, set Target Namespace and namespaces
	if(SUCCEEDED(hr))
	{
		hr = AddSchemaAttributesAndIncludes();
	}

	// writes schema data till the begining of the Annotation section
	if(SUCCEEDED(hr))
	{
		hr = m_pSchema->BeginSchemaAndWriteTillBeginingOfAnnotation();
	}

	// Get Qualifiers of the class and add them to the Appinfo section
	if(SUCCEEDED(hr) && SUCCEEDED(m_pIObject->GetQualifierSet(&pQualifierSet)))
	{
		hr = AddQualifiers(pQualifierSet);
	}
	SAFE_RELEASE_PTR(pQualifierSet);

	// Add Properties and its qualifiers to Appinfo section
	if(SUCCEEDED(hr))
	{
		hr = AddPropertiesForSchemaToAppInfo();
	}

	// Add methods to apppinfo section
	if(SUCCEEDED(hr))
	{
		hr = AddMethods();
	}

	// End the annotation section
	if(SUCCEEDED(hr))
	{
		hr = m_pSchema->EndAnnotation();
	}

	// Write data to the stream till the defination fo the complexType for the class
	if(SUCCEEDED(hr))
	{
		hr = m_pSchema->PrepareStreamToAddPropertiesForComplexType();
	}

	// Add Properties as elements of the complex type
	if(SUCCEEDED(hr))
	{
		hr = AddPropertiesForSchema();
	}

	// End the schema
	if(SUCCEEDED(hr))
	{
		hr = m_pSchema->EndSchema();
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function which goes thru the methods of a class and adds them to XML schema
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddMethods()
{
	HRESULT hr = S_OK;

	BSTR	strMethod = NULL;
	LONG	lFlavor	= 0;
	VARIANT vQual;

	IWbemClassObject *	pInObject		= NULL;
	IWbemClassObject *	pOutObject		= NULL;
	IWbemQualifierSet *	pQualifierSet	= NULL;

	VariantInit(&vQual);

	// Enumerate the methods
	hr = m_pIObject->BeginMethodEnumeration(0); //WBEM_FLAG_LOCAL_ONLY );

	while(hr == S_OK)
	{
		if(S_OK == m_pIObject->NextMethod(0,&strMethod,&pInObject,&pOutObject))
		{
			if(SUCCEEDED(hr = m_pSchema->BeginMethod(strMethod)))
			{
				// Get and add method quallifiers
				if(SUCCEEDED(hr = m_pIObject->GetMethodQualifierSet(strMethod,&pQualifierSet)))
				{
					hr = AddQualifiers(pQualifierSet);
					SAFE_RELEASE_PTR(pQualifierSet);
				}

				// Add Input parameter object
				if(SUCCEEDED(hr) && pInObject)
				{
					hr = AddMethodParameter(pInObject,FALSE);
				}

				// Add output parameter object
				if(SUCCEEDED(hr) && pOutObject)
				{
					hr = AddMethodParameter(pOutObject,TRUE);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pSchema->EndMethod();
				}
			}
			
			SAFE_FREE_SYSSTRING(strMethod);
			SAFE_RELEASE_PTR(pInObject);
			SAFE_RELEASE_PTR(pOutObject);
		}
		else
		{
			break;
		}
		
	}

	m_pIObject->EndMethodEnumeration();


	return (hr == WBEM_S_NO_MORE_DATA) ? S_OK : hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to go thru the qualifierset and add them to XML schema
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddQualifiers(IWbemQualifierSet *pQualifierSet)
{
	HRESULT hr = S_OK;

	BSTR	strQual = NULL;
	LONG	lFlavor	= 0;
	VARIANT vQual;

	VariantInit(&vQual);

	// Start the enumeration
	hr = pQualifierSet->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);

	while(hr == S_OK)
	{
		if(S_OK == pQualifierSet->Next(0,&strQual,&vQual,&lFlavor))
		{
			// Add quallifier
			hr = m_pSchema->AddQualifier(strQual,&vQual,lFlavor);
			VariantClear(&vQual);
			SAFE_FREE_SYSSTRING(strQual);
		}
		else
		{
			break;
		}
	}
	
	pQualifierSet->EndEnumeration();

	return (hr == WBEM_S_NO_MORE_DATA) ? S_OK : hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function to go thru the properties of the WMI object and add appInfo section
//	for the XML schema
//  
//  bFindAddIncludes - TRUE		-	indicates the function to look for the list of <includes>
//									and add them to the schema. Does not add properties to 
//									appinfo section
//						FALSE	-	Adds properties to appinfo section if 
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddPropertiesForSchemaToAppInfo(BOOL bFindAddIncludes)
{
	HRESULT				hr				= S_OK;
	BSTR				strProp			= NULL;
	LONG				lFlavor			= 0;
	LONG				cimtype			= 0;
	IWbemQualifierSet *	pQualifierSet	= NULL;
	BOOL				bChanged		= TRUE;
	VARIANT				vProp;
	BSTR				strEmbeddedType = NULL;

	VariantInit(&vProp);
	
	hr = m_pIObject->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY );
//	hr = m_pIObject->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY );

	
	while(hr == S_OK)
	{
		if(S_OK == (hr = m_pIObject->Next(0,&strProp,&vProp,&cimtype,&lFlavor)))
		{
			BOOL bAddToAppInfo	= FALSE;
			BOOL bQualifiers	= FALSE;

			if(IsEmbededType(cimtype))
			{
				hr = GetEmbeddedType(strProp,strEmbeddedType);
			}

			// Check if any Local property qualifiers exist for the property
			if(SUCCEEDED(hr = m_pIObject->GetPropertyQualifierSet(strProp,&pQualifierSet)))
			{
				bQualifiers = CheckIfLocalQualifiersExist(pQualifierSet);
			}

			// Check if the property value is changed if property is
			// propogated from a parent class
			if(SUCCEEDED(hr) && (WBEM_FLAVOR_ORIGIN_PROPAGATED  & lFlavor) )
			{
				// Not going to call this function once the bug from Sanjes about WBEM_FLAVOR_LOCAL only
				// returns modified properties FIXX
				hr = IsPropertyChange(strProp,bChanged);
			}

			// if property is changed or if there are qualifiers then
			// property has to be added to appinfo
			if(SUCCEEDED(hr) && ((bChanged || bQualifiers)))
			{
				bAddToAppInfo = TRUE;
			}

			// if property is not changed and if the property values
			// is NULL then there is no need of adding this property to appinfo
			// FIXX - check if this is the design
			if(bChanged == FALSE && IsPropNull(&vProp))
			{
				bAddToAppInfo = FALSE;
			}

			// If the property is local or if there is any change in defauvalue or
			// type of the property ( in terms of strongly typing
			// the CIM_OBJECT type property add it to annotation section)
			if(bAddToAppInfo) 
			{
				// if the property is an strongly typed embedded object
				// then add a <include ...> for the the schema for the 
				// class if not already added
				if(strEmbeddedType && bFindAddIncludes)
				{
					hr = AddIncludesForClassIfAlreadyNotPresent(strEmbeddedType);
				}


				if(bFindAddIncludes == FALSE && SUCCEEDED(hr) && SUCCEEDED(hr = m_pSchema->BeginPropertyInAnnotation(strProp,0,&vProp,cimtype,lFlavor,strEmbeddedType)))
				{
					hr = AddQualifiers(pQualifierSet);
					SAFE_RELEASE_PTR(pQualifierSet);
					
					if(SUCCEEDED(hr))
					{
						hr = m_pSchema->EndPropertyInAnnotation();
					}
				}
			}
			VariantClear(&vProp);
			SAFE_FREE_SYSSTRING(strProp);
			SAFE_FREE_SYSSTRING(strEmbeddedType);
			SAFE_RELEASE_PTR(pQualifierSet);
		}
	}
	m_pIObject->EndEnumeration();


	return (hr == WBEM_S_NO_MORE_DATA) ? S_OK : hr;
}



////////////////////////////////////////////////////////////////////////////////////////
//
// Function to go thru the properties of the WMI object and add it XML schema
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddPropertiesForSchema()
{
	HRESULT				hr				= S_OK;
	BSTR				strProp			= NULL;
	LONG				lFlavor			= 0;
	LONG				cimtype			= 0;
	BSTR				strEmbeddedType = NULL;


	hr = m_pIObject->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);
	
	while(hr == S_OK)
	{
		if(S_OK == (hr = m_pIObject->Next(0,&strProp,NULL,&cimtype,&lFlavor)))
		{
			if(IsEmbededType(cimtype))
			{
				hr = GetEmbeddedType(strProp,strEmbeddedType);
			}

			if(SUCCEEDED(hr))
			{
				hr = m_pSchema->AddProperty(strProp,0,cimtype,lFlavor,strEmbeddedType);
			}
			SAFE_FREE_SYSSTRING(strEmbeddedType);
			SAFE_FREE_SYSSTRING(strProp);
		}
	}	
	m_pIObject->EndEnumeration();

	return (hr == WBEM_S_NO_MORE_DATA) ? S_OK : hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to set the schema <include>, targetNamespace and other attributes of 
// of XML schema to be returned
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddSchemaAttributesAndIncludes()
{
	HRESULT hr = S_OK;


	hr = SetTargetNamespace();;

	if(SUCCEEDED(hr))
	{
		hr = AddSchemaIncludes();
	}
	if(SUCCEEDED(hr))
	{
		hr = SetWMIStdSchemaInfo();
	}
	return hr;

}




////////////////////////////////////////////////////////////////////////////////////////
//
// Function which goes thru the parameter object of the method and adds
// them to the XML schema
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddMethodParameter(IWbemClassObject *pObject, BOOL bReturnVal)
{
	HRESULT				hr				= S_OK;
	BSTR				strParam		= NULL;
	LONG				lFlavor			= 0;
	LONG				cimtype			= 0;
	VARIANT				vVal;

	VariantInit(&vVal);
	

	hr = pObject->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
	
	while(hr == S_OK)
	{
		if(S_OK == (hr = pObject->Next(0,&strParam,&vVal,&cimtype,&lFlavor)))
		{
			if(bReturnVal)
			{
				hr = m_pSchema->BeginReturnVal(strParam,cimtype);
			}
			else
			{
				hr = m_pSchema->BeginParameter(strParam,cimtype,&vVal,lFlavor);
			}

			if(SUCCEEDED(hr))
			{
				IWbemQualifierSet *	pQualifierSet	= NULL;
				// add qualifiers for the paramters/return values
				if(SUCCEEDED(hr = pObject->GetPropertyQualifierSet(strParam,&pQualifierSet)))
				{
					hr = AddQualifiers(pQualifierSet);
					SAFE_RELEASE_PTR(pQualifierSet);
				}

				if(SUCCEEDED(hr))
				{
					if(bReturnVal)
					{
						hr = m_pSchema->EndReturnVal();
					}
					else
					{
						hr = m_pSchema->EndParameter();
					}
				}
			}
			VariantClear(&vVal);
			SAFE_FREE_SYSSTRING(strParam);
		}
	}

	pObject->EndEnumeration();

	return (hr == WBEM_S_NO_MORE_DATA) ? S_OK : hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to release the string stored in SchemaLocations for <include> or schemaLocation
//  
//	Parameter
//		bReleaseInUnderlyingObject	-	Indicates if schema location from the underlying 
//										schema object has to be cleared		
////////////////////////////////////////////////////////////////////////////////////////
void CWMIToXML::ReleaseSchemaLocs(BOOL bReleaseInUnderlyingObject)
{
	int nSize = m_arrSchemaLocs.GetSize();
	for(int lIndex = 0 ; lIndex <  nSize ; lIndex ++)
	{
		SysFreeString((BSTR)m_arrSchemaLocs.ElementAt(lIndex));
	}
	m_arrSchemaLocs.RemoveAll();

	if(bReleaseInUnderlyingObject && m_pSchema)
	{
		m_pSchema->ClearIncludes();
	}

}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to set XMLNamespace of the document to be returned 
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::SetXMLNamespace( BSTR strNamespace,
											BSTR strNamespacePrefix)
{
	HRESULT hr = E_FAIL;
	SAFE_FREE_SYSSTRING(m_strNamespace);
	SAFE_FREE_SYSSTRING(m_strNamespacePrefix);
	if(strNamespace)
	{
		hr = E_OUTOFMEMORY;
		m_strNamespace = SysAllocString(strNamespace);
		if(m_strNamespace)
		{
			hr = S_OK;
			if(strNamespacePrefix)
			{
				hr = E_OUTOFMEMORY;
				m_strNamespacePrefix = SysAllocString(strNamespacePrefix);
				if(m_strNamespacePrefix)
				{
					hr = S_OK;
				}

			}
		}
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to set the TargetNamespace on the schema to be returned
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::SetTargetNamespace()
{
	HRESULT hr = E_FAIL;
	if(m_strNamespace)
	{
		hr = m_pSchema->SetTargetNamespace(m_strNamespace,m_strNamespacePrefix);
	}
	return hr;

}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to initilize the member variable with WMI specific declaration details
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::SetWMIStandardSchemaLoc(BSTR strStdImportSchemaLoc,
													BSTR strStdImportNamespace,
													BSTR strNameSpaceprefix)
{
	HRESULT hr = E_FAIL;
	
	SAFE_FREE_SYSSTRING(m_strWmiSchemaLoc);
	SAFE_FREE_SYSSTRING(m_strWmiNamespace);
	SAFE_FREE_SYSSTRING(m_strWmiSchemaPrefix);

	if(strStdImportSchemaLoc && strStdImportNamespace)
	{
		hr = S_OK;
		m_strWmiSchemaLoc		= SysAllocString(strStdImportSchemaLoc);
		m_strWmiNamespace	= SysAllocString(strStdImportNamespace);

		if(m_strWmiSchemaLoc && m_strWmiNamespace)
		{
			if(strNameSpaceprefix)
			{
				m_strWmiSchemaPrefix = SysAllocString(strNameSpaceprefix);
				if(!m_strWmiSchemaPrefix)
				{
					hr = E_OUTOFMEMORY;
				}

			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Function to set the <import> in the schema for WMI specific declarations
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::SetWMIStdSchemaInfo()
{
	HRESULT hr = S_OK;
	if(IsClass())
	{
		if(m_strWmiNamespace)
		{
			hr = m_pSchema->SetWMIStdImport(m_strWmiNamespace,m_strWmiSchemaLoc,m_strWmiSchemaPrefix);
		}
		else
		// set the default values
		{
			hr = m_pSchema->SetWMIStdImport(g_strStdNameSpace,g_strStdLoc,g_strStdPrefix);
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Set the schemalocation for to be used in the output XML.
// This function initializes the member variable
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWMIToXML::SetSchemaLocations(ULONG cSchema,BSTR *pstrSchemaLocation)
{
	HRESULT hr		= S_OK;
	BSTR	strTemp	= NULL;


	// Release the schemaLocations and also the schemaLocations of the
	// underlying schema object
	ReleaseSchemaLocs(TRUE);
	if(cSchema)
	{
		ULONG lSize = (ULONG)m_arrSchemaLocs.GetSize();
		BOOL bFail = FALSE;
		for(ULONG lIndex = 0 ; lIndex < cSchema ; lIndex++)
		{
			if(pstrSchemaLocation[lIndex])
			{
				if(strTemp = SysAllocString(pstrSchemaLocation[lIndex]))
				{
					if(-1 == m_arrSchemaLocs.Add((void *) strTemp))
					{
						hr		= E_OUTOFMEMORY;
						bFail	= TRUE;
						break;
					}
				}
			}
			else
			{
				hr		= E_INVALIDARG;
				bFail	= TRUE;
				break;
			}
		}

		if(bFail)
		{
			ReleaseSchemaLocs(TRUE);
		}
	}

	return hr;

}

////////////////////////////////////////////////////////////////////////////////////////
//
// Get Schemas to be included from the and call methods to add schema includes
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddSchemaIncludes()
{
	HRESULT hr = S_OK;
	ULONG lSize = (ULONG)m_arrSchemaLocs.GetSize();

	for(ULONG lIndex = 0 ; lIndex < lSize && SUCCEEDED(hr) ; lIndex++)
	{
		hr = m_pSchema->AddXSDInclude((BSTR)m_arrSchemaLocs.ElementAt(lIndex));

	}
	return hr;


}

////////////////////////////////////////////////////////////////////////////////////////
//
// Set the WMI object to be converted
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::SetWMIObject(IWbemClassObject *pObject)
{
	HRESULT hr = S_OK;
	SAFE_RELEASE_PTR(m_pIObject);
	hr = pObject->QueryInterface(IID_IWbemClassObject , (void **)&m_pIObject);

	if(SUCCEEDED(hr))
	{
		VARIANT vGenus;
		IXMLDOMNode *ptempNode = NULL;
		VariantInit(&vGenus);

		m_bClass = TRUE;
		hr = m_pIObject->Get(GENUSPROP,0,&vGenus,NULL,NULL);

		// if __GENUS property is not available then
		// object is considered to be an instance
		if(FAILED(hr) || (SUCCEEDED(hr) && vGenus.lVal != CLASS_GENUS) )
		{
			m_bClass	= FALSE;
			hr			= S_OK;
		}

		// Checking if the object is a DCOM object
		if(SUCCEEDED(m_pIObject->QueryInterface(IID_IXMLDOMNode , (void **)&ptempNode)))
		{
			SAFE_RELEASE_PTR(ptempNode);
			m_bDCOMObj = FALSE;
		}
	}

	if(SUCCEEDED(hr))
	{
		SAFE_DELETE_PTR(m_pInstance);
		SAFE_DELETE_PTR(m_pSchema);
		if(m_bClass)
		{
			m_pSchema = new CWMIXMLSchema;
		}
		else
		{
			m_pInstance = new CWMIXMLInstance;
		}

		if(!m_pInstance && !m_pSchema)
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Overloaded function to get XML of a given object and put data into BSTR
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::GetXML(BSTR & strOut)
{
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr))
	{
		if(IsClass())
		{
			hr = GetSchema();
		}
		else
		{
			hr = GetInstance();
		}
	}

	// call this function to dump the stream data 
	// to a file and also to output string
	if(SUCCEEDED(hr))
	{
		LogAndSetOutputString(m_pITmpStream,TRUE,&strOut);
	}
	SAFE_RELEASE_PTR(m_pITmpStream);

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Overloaded function to get XML of a given object and put data into the stream
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::GetXML(IStream *pStream)
{
	HRESULT hr = S_OK;


	if(SUCCEEDED(hr))
	{
		if(IsClass())
		{
			hr = GetSchema();
		}
		else
		{
			hr = GetInstance();
		}
	}

	// call this function to Log the stream data to a file 
	if(SUCCEEDED(hr))
	{
		LogAndSetOutputString(pStream);
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to initialize the SchemaObject member variable
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::InitSchemaObject()
{
	HRESULT hr = S_OK;

	VARIANT vClass;
	VARIANT	vParentClass;
	
	VariantInit(&vClass);
	VariantInit(&vParentClass);

	if(SUCCEEDED(hr = m_pSchema->FInit()))
	{
		// Get class name and parent class name
		if(SUCCEEDED(hr = m_pIObject->Get(CLASSNAMEPROP,0,&vClass,NULL,NULL)) &&
			SUCCEEDED(hr = m_pIObject->Get(PARENTCLASSPROP,0,&vParentClass,NULL,NULL)) )
		{
			hr = m_pSchema->SetWMIClass(	vClass.vt == VT_BSTR ? vClass.bstrVal : NULL,
										vParentClass.vt == VT_BSTR ? vParentClass.bstrVal : NULL);
			
			// Add Include if parent class is not already set
			if(SUCCEEDED(hr))
			{
				m_pSchema->SetFlags(m_lFlags);
				// Add include for the parent class if not alread present
				hr = AddIncludesForClassIfAlreadyNotPresent(vParentClass.bstrVal);
			}
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = SetStream(m_pITmpStream);
	}

	VariantClear(&vClass);
	VariantClear(&vParentClass);

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Put the data in the stream to the output BSTR if required and
//	dump the contents of the stream to a file
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::LogAndSetOutputString(IStream *pStream ,BOOL bStrout,BSTR * pstrOut)
{
	HRESULT hr				= S_OK;
	UINT	nLoggingLevel	= 0;
	STATSTG			stat;
	memset(&stat,0,sizeof(STATSTG));

	hr = pStream->Stat(&stat,STATFLAG_NONAME );
	hr = CopyStream(m_pITmpStream,pStream,!(m_lFlags & WMI_XMLINST_NONAMESPACE));
		
	nLoggingLevel = GetLoggingLevel();

	if(SUCCEEDED(hr) && (pstrOut || nLoggingLevel))
	{
		
		LARGE_INTEGER	lCur;
		LARGE_INTEGER	lSeek;
		ULONG			cb			= INITBUFFSIZE;
		ULONG			cbAlloc		= cb;
		char	*		pBuffer		= NULL;
		ULONG			lBytesRead	= 0;

		memset(&lSeek,0,sizeof(LARGE_INTEGER));
		memset(&lCur,0,sizeof(LARGE_INTEGER));
		
		pBuffer = new char[cbAlloc];

		memset(&stat,0,sizeof(STATSTG));
		hr = pStream->Stat(&stat,STATFLAG_NONAME );
		if(pBuffer)
		{

			// Store the current seek pointer
			pStream->Seek(lSeek,STREAM_SEEK_CUR,(ULARGE_INTEGER *)&lCur);

			pStream->Seek(lSeek,STREAM_SEEK_SET,NULL);
			hr = pStream->Read(pBuffer,cb,&cb);
			lBytesRead = cb;
			while(hr == S_OK && (lBytesRead >= cbAlloc))
			{
				char *pTemp = pBuffer;
				
				cbAlloc += BUFFINCRSIZE;
				cb		=  BUFFINCRSIZE;

				pBuffer = new char[cbAlloc];
				if(pBuffer)
				{
					memcpy(pBuffer,pTemp,lBytesRead);
					SAFE_DELETE_ARRAY(pTemp);
					hr = pStream->Read(((BYTE *)pBuffer) + lBytesRead,cb,&cb);
					lBytesRead += cb;
				}
				else
				{
					SAFE_DELETE_ARRAY(pTemp);
					hr = E_OUTOFMEMORY;
				}

			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
		
		if(hr == S_OK)
		{
			pBuffer[lBytesRead] = 0;
			if(bStrout)
			{
				WCHAR * pwcsOut = NULL;
				if(SUCCEEDED(hr = CStringConversion::AllocateAndConvertAnsiToUnicode(pBuffer,pwcsOut)))
				{
					*pstrOut = NULL;
					*pstrOut = SysAllocString(pwcsOut);
					if(!*pstrOut)
					{
						hr = E_OUTOFMEMORY;
					}
				}
				SAFE_DELETE_ARRAY(pwcsOut);
			}
			if(nLoggingLevel)
			{
				WriteToFile(pBuffer);
			}
		}
		SAFE_DELETE_ARRAY(pBuffer);
		// Reset the position to the previous one
		pStream->Seek(lCur,STREAM_SEEK_SET,NULL);
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Makes a connection to WMI and gets the Parentclass if alread not obtained
//  
//	FIXX - This function will not be use later after bug 251872 is fixed
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWMIToXML::GetClass(BSTR strClass,IWbemClassObject ** ppObject)
{
	HRESULT hr = S_OK;

	if(!m_pConnection)
	{
		// If the object is a DCOM object
		if(IsDCOMObj())					
		{
			BSTR strNamespace = NULL;

			if(SUCCEEDED(hr = ExtractNamespace(strNamespace)))
			{
				m_pConnection = new CWMIConnection(strNamespace,m_strUser,m_strPassword,m_strLocale);

				if(!m_pConnection)
				{
					hr = E_OUTOFMEMORY;	
				}
				SAFE_FREE_SYSSTRING(strNamespace);
			}
		}
		else
		{
			// do HTTP connection FIXX
		}
	}

	hr = m_pConnection->GetObject(strClass ,ppObject);

	if(ppObject == NULL && SUCCEEDED(hr))
	{
		hr = S_FALSE;		// indicates that there is no parent class
	}


	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Makes a connection to WMI and gets the Parentclass if alread not obtained
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWMIToXML::ExtractNamespace(BSTR & strNamespace)
{
	HRESULT hr			= E_FAIL;
	
	VARIANT vNamespace;
	VARIANT vServer;

	SAFE_FREE_SYSSTRING(strNamespace);

	VariantInit(&vNamespace);
	VariantInit(&vServer);

	if(SUCCEEDED(hr = m_pIObject->Get(NAMESPACE,0,&vNamespace,NULL,NULL)) &&  
		SUCCEEDED(hr = m_pIObject->Get(SERVER,0,&vServer,NULL,NULL)) )
	{
		if(vNamespace.vt == VT_BSTR && vServer.vt == VT_BSTR)
		{
			hr = E_OUTOFMEMORY;

			WCHAR *	pNamespace	= NULL;
			int nAllocsize = SysStringLen(vServer.bstrVal) + SysStringLen(vNamespace.bstrVal) + 10 ; 
			pNamespace = new WCHAR[nAllocsize];
			if(pNamespace)
			{
				swprintf(pNamespace,L"\\\\%s\\%s" , vServer.bstrVal,vNamespace.bstrVal);
				strNamespace = SysAllocString(pNamespace);

				if(strNamespace)
				{
					hr = S_OK;
				}

				SAFE_DELETE_ARRAY(pNamespace);
			}

		}
		else
		{
			hr = E_FAIL;
		}
	}

	VariantClear(&vNamespace);
	VariantClear(&vServer);

	return hr;

}


////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if a property has changed as compared to the property from origin class if
// the property is propogated from the parent class
//  
//	FIXX - This function will not be use later after bug 251872 is fixed
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::IsPropertyChange(BSTR strProp,BOOL &bChange)
{
	HRESULT				hr			= S_OK;
	IWbemClassObject *	pOriginObj	= NULL;
	BSTR				strClass	= NULL;
	LONG				cimtype		= 0;


	VARIANT vOrigVal;
	VARIANT vVal;

	VariantInit(&vOrigVal);
	VariantInit(&vVal);

	bChange = FALSE;

	if(SUCCEEDED(hr = m_pIObject->GetPropertyOrigin(strProp,&strClass)))
	{
		if(SUCCEEDED(hr = GetClass(strClass,&pOriginObj)))
		{
			hr = m_pIObject->Get(strProp,0,&vVal,&cimtype,NULL);

			if(SUCCEEDED(hr))
			{
				hr = pOriginObj->Get(strProp,0,&vOrigVal,&cimtype,NULL);
			}

			if(SUCCEEDED(hr) && !(cimtype == CIM_OBJECT || cimtype == (CIM_OBJECT | CIM_FLAG_ARRAY)))
			{
				bChange = !(CompareData(&vVal,&vOrigVal));
			}

			// if the property is a object check if the property type is 
			// changed in the class
			if(cimtype == CIM_OBJECT || cimtype == (CIM_OBJECT | CIM_FLAG_ARRAY))
			{
				VariantClear(&vVal);
				VariantClear(&vOrigVal);
				LONG lFlavor = 0;

				hr = GetQualifier(strProp,CIMTYPEPROP,&vVal,&lFlavor,pOriginObj);
				
				if(SUCCEEDED(hr))
				{
					hr = GetQualifier(strProp,CIMTYPEPROP,&vVal,&lFlavor);
				}

				if(SUCCEEDED(hr))
				{
					if(_wcsicmp(vVal.bstrVal,vOrigVal.bstrVal))
					{
						bChange = TRUE;
					}
				}

			}
		}
	}
	VariantClear(&vVal);
	VariantClear(&vOrigVal);

	return hr;
}




////////////////////////////////////////////////////////////////////////////////////////
//
// Fetches a property / class qualifer
//	strProperty is NULL indicates to get a class qualfier
//	pIObject == NULL indicates that fetching has to be done on m_pIObject
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::GetQualifier(BSTR strProperty, 
								BSTR strQualifier , 
								VARIANT * pvVal , 
								LONG *  plFlavor,
								IWbemClassObject *pIObject)
{
	HRESULT				hr			= S_OK;
	IWbemClassObject *	pIObj		= NULL;
	IWbemQualifierSet * pIQualSet	= NULL;

	pIObj = pIObject == NULL ? m_pIObject : pIObject;

	if(strProperty)
	{
		hr = pIObj->GetPropertyQualifierSet(strProperty,&pIQualSet);
	}
	else
	{
		hr = pIObj->GetQualifierSet(&pIQualSet);
	}


	if(SUCCEEDED(hr))
	{
		hr = pIQualSet->Get(strQualifier,0,pvVal,plFlavor);
	}

	SAFE_RELEASE_PTR(pIQualSet);

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Goes thru the list of Schema includes and Adds them if alread not present
// Called to add includes for embedded properties and parent classes
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddIncludesForClassIfAlreadyNotPresent(BSTR strClass)
{
	BOOL	bFound					= FALSE;
	BSTR	strSchemaLocofClass		= NULL;
	HRESULT hr						= S_OK;
	ULONG	cSchemaLocs				= (ULONG)m_arrSchemaLocs.GetSize();

	// get the schemaLocation of the given class using the Namespace of the
	// the class( ie TargetNamespace)
	if(SUCCEEDED(hr = GetSchemaLocationOfClass(strClass,strSchemaLocofClass)))
	{
		// go thru the list and check if it is already there
		for(ULONG lIndex = 0 ; lIndex < cSchemaLocs ; lIndex++)
		{
			if(_wcsicmp(strSchemaLocofClass,(BSTR)m_arrSchemaLocs.ElementAt(lIndex)) == 0)
			{
				bFound = TRUE;
				break;
			}
		}

		// if <include> is not already added then add them
		if(SUCCEEDED(hr) && bFound == FALSE)
		{
			if(-1 == m_arrSchemaLocs.Add((void *)strSchemaLocofClass))
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Constructs the SchemaLocation of the given class, 
// Assumption: SchemaLocation/TargetNamespace of the class is already set
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::GetSchemaLocationOfClass(BSTR strClass ,BSTR & strSchemaLoc)
{
	HRESULT hr			= E_OUTOFMEMORY;

	WCHAR * pStrSchemaLoc = NULL;


	LONG lSize = SysStringLen(strClass) + SysStringLen(m_strNamespace) + + wcslen((WCHAR *)STR_CLASS_SCHEMALOC) + 2; // one for BackSlash
	hr = E_OUTOFMEMORY;

	if(pStrSchemaLoc = new WCHAR[lSize])
	{
		swprintf(pStrSchemaLoc , STR_CLASS_SCHEMALOC , m_strNamespace,strClass);
		if(strSchemaLoc = SysAllocString(pStrSchemaLoc))
		{
			hr = S_OK;
		}
		SAFE_DELETE_ARRAY(pStrSchemaLoc);
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Gets XML for the given instance
//
// Returns	S_OK
//			E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::GetInstance()
{
	HRESULT hr = S_OK;
	IWbemQualifierSet *pQualifierSet = NULL;
	
	// Initialize the object
	if(SUCCEEDED(hr = InitInstanceObject()))
	{
		// This sets the SchemaLocation of the instance
		hr = SetSchemaLocation();
	}	

	if(SUCCEEDED(hr))
	{
		hr = m_pInstance->BeginInstance();
	}

	if(SUCCEEDED(hr))
	{
		hr = AddPropertiesForInstance();
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pInstance->EndInstance();
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to initialize the instance object
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::InitInstanceObject()
{
	HRESULT hr = S_OK;
	VARIANT vClass;
	VariantInit(&vClass);

	hr = m_pIObject->Get(CLASSNAMEPROP,0,&vClass,NULL,NULL);

	// Not checking for the success of previous call as instances 
	// from queries may not have class names
	hr = m_pInstance->FInit(m_lFlags,vClass.bstrVal);

	VariantClear(&vClass);

	if(SUCCEEDED(hr))
	{
		hr = SetStream(m_pITmpStream);
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the SchemaLocation of the instance
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::SetSchemaLocation()
{
	HRESULT hr = S_OK;
	if(m_arrSchemaLocs.GetSize())
	{
		if(m_arrSchemaLocs.ElementAt(0))
		{
			hr = m_pInstance->SetSchemaLocation(m_strNamespace,(BSTR)m_arrSchemaLocs.ElementAt(0));
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to go thru the properties of the WMI object and add it XML schema
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::AddPropertiesForInstance()
{
	HRESULT				hr				= S_OK;
	BSTR				strProp			= NULL;
	LONG				lFlavor			= 0;
	LONG				cimtype			= 0;
	VARIANT				vProp;
	BSTR				strEmbeddedType = NULL;
	IWbemClassObject *	pIInstance		= NULL;


	VariantInit(&vProp);
	
	hr = m_pIObject->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY );

	
	while(hr == S_OK)
	{
		if(S_OK == (hr = m_pIObject->Next(0,&strProp,&vProp,&cimtype,&lFlavor)))
		{
			if(IsEmbededType(cimtype))
			{
				hr = GetEmbeddedType(strProp , strEmbeddedType);
			}

			if(SUCCEEDED(hr))
			{
				hr = m_pInstance->AddProperty(strProp,cimtype,IsPropNull(&vProp)? NULL:&vProp,strEmbeddedType);
			}
			
			SAFE_FREE_SYSSTRING(strEmbeddedType);
			SAFE_FREE_SYSSTRING(strProp);
			VariantClear(&vProp);
		}
	}
	m_pIObject->EndEnumeration();


	return (hr == WBEM_S_NO_MORE_DATA) ? S_OK : hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  GetEmbeddedType 
//	Get the CIMTYPE qualifier of the embedded property and returns the object type of the 
//	embedded property
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::GetEmbeddedType(BSTR strProp , BSTR &strEmbeddedType)
{
	HRESULT hr = S_OK;
	VARIANT vProp;

	VariantInit(&vProp);

	// get the CIMTYPE qualifier and compare it with Object
	// to check if the embedded object is weakly typed or not
	// If not weekly typed then get the name of the class
	// of the embedded property
	BSTR strCimtype = SysAllocString(CIMTYPEPROP);
	if(SUCCEEDED(hr = GetQualifier(strProp,strCimtype ,&vProp)))
	{
		if(_wcsicmp(vProp.bstrVal,OBJECT))
		{
			WCHAR * pTempStr = new WCHAR[SysStringLen(vProp.bstrVal)];
			WCHAR * pTempStr1 = new WCHAR[SysStringLen(vProp.bstrVal)];
			if(pTempStr)
			{
				swscanf(vProp.bstrVal,L"%[^:]:%s",pTempStr1,pTempStr);
				strEmbeddedType = SysAllocString(pTempStr);
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
			SAFE_DELETE_ARRAY(pTempStr1);
			SAFE_DELETE_ARRAY(pTempStr);
		}
	}
	SAFE_FREE_SYSSTRING(strCimtype);
	VariantClear(&vProp);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  SetStream 
//	Sets the stream pointer to write
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIToXML::SetStream(IStream *pStream)
{
	HRESULT hr = S_OK;
	if(SUCCEEDED(hr = CreateStreamOnHGlobal(NULL,TRUE,&m_pITmpStream)))
	{
		if(IsClass())
		{
			hr = m_pSchema->SetStream(m_pITmpStream);
		}
		else
		{
			hr = m_pInstance->SetStream(m_pITmpStream);
		}
	}
	return hr;
}	

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Checks if any LOCAL qualifier exists in the qualifier set
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIToXML::CheckIfLocalQualifiersExist(IWbemQualifierSet * pQualifierSet)
{
	BOOL bRet			= FALSE;
	BSTR strQualifier	= NULL;

	if(SUCCEEDED(pQualifierSet->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY))) 
	{
		if(S_OK == pQualifierSet->Next(0,&strQualifier,NULL,NULL))
		{
			SAFE_FREE_SYSSTRING(strQualifier);
			bRet = TRUE;
		}
		pQualifierSet->EndEnumeration();
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlconverter.cpp ===
//***************************************************************************/
//
//  CLASSFAC.CPP
//
//  Purpose: Contains implementation of IWmiXMLConverter interface
//
//  Copyright (c)1997-2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************/
#include <precomp.h>

#include "wmitoxml.h"

#include <wmi2xsd.h>
#include "wmixmlconverter.h"
#include "wmi2xsdguids.h"


////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CWmiXMLConverter::CWmiXMLConverter()
{
    InterlockedIncrement(&g_cObj);
	m_cRef					= 0;
	m_pXmlConverter			= NULL;
	m_pCritSec				= NULL;

}


////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//  
////////////////////////////////////////////////////////////////////////////////////////
CWmiXMLConverter::~CWmiXMLConverter()
{

    InterlockedDecrement(&g_cObj);
	SAFE_DELETE_PTR(m_pXmlConverter);
	SAFE_DELETE_PTR(m_pCritSec);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// QueryInterface
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CWmiXMLConverter::QueryInterface(REFIID riid, LPVOID *ppv)
{
	HRESULT hr = E_NOINTERFACE;
	*ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWMIXMLConverter==riid)
		*ppv = reinterpret_cast<IWMIXMLConverter *>(this);

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = NOERROR;
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// AddRef
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)  CWmiXMLConverter::AddRef(void)
{
	return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Release 
//  
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)  CWmiXMLConverter::Release(void)
{
	if(InterlockedDecrement(&m_cRef) == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}


HRESULT CWmiXMLConverter::FInit()
{
	HRESULT hr = S_OK;
	
	m_pXmlConverter = new CWMIToXML;
	m_pCritSec		= new CCriticalSection(TRUE);
	if(!m_pXmlConverter || !m_pCritSec)
	{
		hr = E_OUTOFMEMORY;
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Function to set XMLNamespace of the document to be returned 
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiXMLConverter::SetXMLNamespace( BSTR strNamespace,
											BSTR strNamespacePrefix)
{
	CAutoBlock autobloc(m_pCritSec);
	return m_pXmlConverter->SetXMLNamespace(strNamespace,strNamespacePrefix);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the schema location from where schema for the WMI specific Schema has to
// to be imported from
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiXMLConverter::SetWMIStandardSchemaLoc(BSTR strStdImportSchemaLoc,
													BSTR strStdImportNamespace,
													BSTR strNameSpaceprefix)
{
	CAutoBlock autobloc(m_pCritSec);
	return m_pXmlConverter->SetWMIStandardSchemaLoc(strStdImportSchemaLoc,strStdImportNamespace,strNameSpaceprefix);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the various schema location from which schema has to be included
//	schemas define here should be same as that of the targetnamespace of the class
// or the namespace underwhich the instance has to created
//  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWmiXMLConverter::SetSchemaLocations( 
    /* [in] */ ULONG cSchema,
    /* [in] */ BSTR *pstrSchemaLocation)
{
	HRESULT hr = S_OK;
	CAutoBlock autobloc(m_pCritSec);
	if(cSchema &&  !pstrSchemaLocation)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		hr = m_pXmlConverter->SetSchemaLocations(cSchema,pstrSchemaLocation);
	}
	return hr;
}



////////////////////////////////////////////////////////////////////////////////////////
//
// Function which converts an WMI object to an XML
//  
//	Returns S_OK	
//			E_INVALIDARG		- If one fo the parameters are invalid			
////////////////////////////////////////////////////////////////////////////////////////
HRESULT  CWmiXMLConverter::GetXMLForObject( 
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ LONG lFlags,
    /* [in] */ IStream *pOutputStream)
{
	CAutoBlock autobloc(m_pCritSec);

	HRESULT hr = S_OK;
	if(pObject == NULL || pOutputStream == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		m_pXmlConverter->SetFlags(lFlags);

		if(SUCCEEDED(hr = m_pXmlConverter->SetWMIObject(pObject)))
		{
			hr = m_pXmlConverter->GetXML(pOutputStream);
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlinst.cpp ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMIXMLInst.cpp
//
//  ramrao 13 Nov 2000 - Created
//
//  Class that implements conversion of a WMI Instance to XML
//
//		Implementation of CWMIXMLInst class
//
//***************************************************************************/

#include "precomp.h"

#include "wmi2xsd.h"


#define WMI_XMLINST_OK				0
#define WMI_XMLINST_BEGINPROP		1
/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CWMIXMLInstance::CWMIXMLInstance()
{
	m_strClass				= NULL;
	m_lFlags				= 0;;
	m_strSchemaNamespace	= NULL;
	m_strSchemaLocation		= NULL;

	m_lState				= WMI_XMLINST_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CWMIXMLInstance::~CWMIXMLInstance()
{

	SAFE_FREE_SYSSTRING(m_strClass);
	SAFE_FREE_SYSSTRING(m_strSchemaNamespace);
	SAFE_FREE_SYSSTRING(m_strSchemaLocation);
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initialization function , Sets the instance pointer and also creates 
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::FInit(LONG lFlags, BSTR strClass)
{
	HRESULT hr = S_OK;
	
	m_lFlags	= lFlags;
	hr			= SetWMIClass(strClass);

	if(SUCCEEDED(hr))
	{
		if(m_pIWMIXMLUtils = new CWMIXMLUtils)
		{
			m_pIWMIXMLUtils->SetFlags(lFlags);
		}
		else
		{
			hr  = E_OUTOFMEMORY;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the class name of the instance which is to be converted
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::SetWMIClass(BSTR strClass)
{
	HRESULT hr = S_OK;
	if(strClass)
	{
		SAFE_FREE_SYSSTRING(m_strClass);
		m_strClass = SysAllocString(strClass);
		if(!m_strClass)
		{
			hr =E_OUTOFMEMORY;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Add a property to the XML. 
// This function adds an propety as an XML for the XML representing the WMI object
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::AddProperty(BSTR strProperty,CIMTYPE cimtype,VARIANT * pvVal,BSTR strEmbeddedType)							   
{
	HRESULT	hr			= S_OK;

	// Beging the property XML tag
	if(SUCCEEDED(hr = BeginPropTag(strProperty,cimtype,!(BOOL)pvVal,strEmbeddedType)))
	{
		// convert the variant to string and write it to the buffer
		if(pvVal)
		{
			BOOL bCData = TRUE;
			if( (cimtype & VT_ARRAY) || IsEmbededType(cimtype) || !IsStringType(cimtype))
			{
				bCData = FALSE;
			}

			// Property will not be start with <CDATA section if the property is
			// array or of type object
			if(bCData)
			{
				hr  = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CDATA_START);
			}

			// Call this function to convert the Value to a string and write it to the stream
			if(SUCCEEDED(hr = m_pIWMIXMLUtils->ConvertVariantToString(*pvVal, strProperty,m_lFlags & WMI_ESCAPE_XMLSPECIALCHARS)) &&
				bCData)
			{
				hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CDATA_END);
			}
	
		}
		
		// End the tag for the property
		if(SUCCEEDED(hr))
		{
			hr = AddTag(strProperty,FALSE);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Starts a XML tag for representing the property
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::BeginPropTag(BSTR strProperty,CIMTYPE cimtype , BOOL bNull,BSTR strEmbeddePropType)							   
{
	HRESULT hr			= S_OK;
	BOOL	bArray		= cimtype & CIM_FLAG_ARRAY;

	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(strProperty);
	}

	// If the property is an array then add the "arratType" attribute
	if(SUCCEEDED(hr) && bArray)
	{
		if(strEmbeddePropType)
		{
			hr = WriteAttribute((WCHAR *)STR_ARRAY_TYPEATTR,strEmbeddePropType);
		}
		else
		{
			WCHAR  szXSDType[MAXXSDTYPESIZE];
			if(SUCCEEDED(hr = m_pIWMIXMLUtils->GetPropertyXSDType(cimtype ,szXSDType ,bArray,FALSE)))
			{
				hr = WriteAttribute((WCHAR *)STR_ARRAY_TYPEATTR,szXSDType);
			}
		}
	}

	// if the property is NULL then set the attribute
	// for specifying it as NULL
	if(bNull)
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_PROPNULL);
	}

	// if xsi:type is to be set for the properties then set it
	if(SUCCEEDED(hr) && (m_lFlags & WMIXML_INCLUDE_XSITYPE) && !IsEmbededType(cimtype))
	{
		WCHAR  szXSDType[MAXXSDTYPESIZE];
		if(SUCCEEDED(hr = m_pIWMIXMLUtils->GetPropertyXSDType(cimtype,szXSDType ,bArray,FALSE)) )
		{
			hr = WriteAttribute((WCHAR *)STR_TYPEATTR,szXSDType);
		}
	}


	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	if(SUCCEEDED(hr))
	{
		m_lState	= WMI_XMLINST_BEGINPROP;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a XML tag with the given name to the stream
//
//	bBegin	- if bBegin is True the Tag added is <strTagName> aand
// if bBegin is False then Tag added is an end tag ( </strTagName>)
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::AddTag(BSTR strTagName,BOOL bBegin)
{
	HRESULT hr			= S_OK;

		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr) && bBegin == FALSE)
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_FORWARDSLASH);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(strTagName);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	if(SUCCEEDED(hr) && bBegin == FALSE)
	{
		m_lState	= WMI_XMLINST_OK;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the schema location of the XML
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::SetSchemaLocation(BSTR strNamespace,BSTR strSchemaLocation)
{
	HRESULT hr = S_OK;
	SAFE_FREE_SYSSTRING(m_strSchemaNamespace);
	SAFE_FREE_SYSSTRING(m_strSchemaLocation);

	if(strNamespace)
	{
		hr = E_OUTOFMEMORY;
		if(m_strSchemaNamespace = SysAllocString(strNamespace))
		{
			hr = S_OK;
			if(strSchemaLocation)
			{
				hr = E_OUTOFMEMORY;
				if(m_strSchemaLocation = SysAllocString(strSchemaLocation))
				{
					hr = S_OK;
				}
			}
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Begins a XML for representing WMI Instance
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::BeginInstance()
{
	HRESULT hr			= S_OK;

	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(m_strClass);
	}

	// if no namespace is to be added ( this will in case of representing embedded instances)
	if(SUCCEEDED(hr) && !(m_lFlags & WMI_XMLINST_NONAMESPACE))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_XSINAMESPACE);

		if(SUCCEEDED(hr) && m_strSchemaNamespace)
		{

			hr = WriteAttribute((WCHAR *)STR_NAMESPACE,m_strSchemaNamespace);

			// set the schemaLocation attribute
			if(SUCCEEDED(hr) && m_strSchemaLocation)
			{
				hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SPACE);

				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_XSISCHEMALOC);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_EQUALS);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream(m_strSchemaNamespace);
				}
				
				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SPACE);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream(m_strSchemaLocation);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
				}
			}

		}
	}
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	return hr;
	
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Ends a XML for representing WMI Instance
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::EndInstance()
{
	HRESULT hr =  AddTag(m_strClass,FALSE);
	
	m_pIWMIXMLUtils->SetStream(NULL);

	return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Begins a Embedded instance
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::BeginEmbeddedInstance(BSTR strClass)							   
{
	return AddTag(strClass,TRUE);
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Begins a Embedded instance
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::EndEmbeddedInstance(BSTR strClass)							   
{
	return AddTag(strClass,FALSE);
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a give string to stream. Depending on the flags escapes the special XML characters
//	before writing
//
//	This function takes care of escaping instance for which are written as default values
//	in Appinfo section of the schema
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLInstance::WriteToStream(IStream * pStreamOut,WCHAR *pBuffer)
{
	HRESULT hr = S_OK;
/*
	if(m_lFlags & WMI_ESCAPE_XMLSPECIALCHARS)
	{
		hr = m_pIWMIXMLUtils->ReplaceXMLSpecialCharsAndWrite(pBuffer);
	}
	else
	{
		hr = ::WriteToStream(pStreamOut,pBuffer);
	}
*/	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsduuid\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlobject.h ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMIXMLObject.h
//
//  ramrao 12 Dec 2000
//
//  Class that implements conversion of a WMI Instance to XML
//
//		declaration of CWMIXMLObject class. Base class for both
//		classes for converstion from WMI to XML
//
//***************************************************************************/

#ifndef _WMI2XSD_WMIOBJ2XML_H_
#define _WMI2XSD_WMIOBJ2XML_H_

class CWMIXMLObject
{
protected:
	CWMIXMLUtils *m_pIWMIXMLUtils;
	HRESULT WriteAttribute(WCHAR *szAttrName , WCHAR * szStrAttrVal);

public:
	CWMIXMLObject() { m_pIWMIXMLUtils = NULL;}
	virtual ~CWMIXMLObject() 
		{  SAFE_DELETE_PTR(m_pIWMIXMLUtils);}
	
	HRESULT SetStream(IStream *pStream) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlschema.h ===
//***************************************************************************
///
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMIXMLSchema.h
//
//  ramrao 13 Nov 2000 - Created
//
//
//		Declaration of CWMIXMLSchema class
//
//***************************************************************************/


#ifndef _CWMIXMLSCHEMA_H_

#define _CWMIXMLSCHEMA_H_

typedef enum _SCHEMA_STATE
{
	SCHEMA_OK = 0,
	SCHEMA_BEGINPROPINANNOTATION = 0x1,
	SCHEMA_BEGINMETHODINANNOTATION = 0x2,
	SCHEMA_BEGINPARAMINANNOTATION = 0x4,
	SCHEMA_BEGINRETURNINANNOTATION = 0x8
}SCHEMASTATE;

class CXSDSchemaLocs
{
private:

	BSTR m_strSchemaLoc;
	BSTR m_strNamespace;
	BSTR m_strNSQualifier;

public:
	CXSDSchemaLocs() ;
	virtual ~CXSDSchemaLocs() ;

	BOOL ISNull() { return(m_strSchemaLoc == NULL); }

	HRESULT SetImport(BSTR strSchemaLoc , BSTR strNamespace , BSTR strNSQualifier);

	BSTR GetSchemLoc() { return m_strSchemaLoc;}
	BSTR GetNamespace() { return m_strNamespace;}
	BSTR GetNamespaceQualifier() { return m_strNSQualifier;}

};

class CWMIXMLSchema:public CWMIXMLObject
{
	
private:

	CXSDSchemaLocs	m_wmiStdImport;
	CPtrArray		m_arrIncludes;
	LONG			m_lFlags;
	LONG			m_schemaState;

	BSTR			m_strClass;
	BSTR			m_strParentClass;
	BSTR			m_strTargetNamespace;
	BSTR			m_strTargetNSPrefix;

	

public:
	CWMIXMLSchema();
	virtual ~CWMIXMLSchema();

	HRESULT FInit();
	HRESULT SetWMIClass(BSTR strClass ,BSTR strParentClass = NULL);
	void	SetFlags(LONG lFlags) { m_lFlags = lFlags; m_pIWMIXMLUtils->SetFlags(lFlags);}
	
	HRESULT SetTargetNamespace(BSTR strTargetNS,BSTR strTargetNamespacePrefix= NULL);
	HRESULT	SetWMIStdImport(BSTR strNamespace, BSTR strSchemaLoc, BSTR strPrefix = NULL);
	HRESULT AddXSDInclude(BSTR strInclude);
	HRESULT AddQualifier(BSTR strName,VARIANT *pVal,LONG lFalvor =0);
	void	ClearIncludes();
	
	HRESULT BeginPropertyInAnnotation(BSTR strProperty,
										LONG lFlags,
										VARIANT *pVarVal, 
										CIMTYPE cimtype,
										LONG lFlavor = 0,
										BSTR strEmbeddedObjectType = NULL);

	HRESULT EndPropertyInAnnotation();

	HRESULT AddProperty(BSTR strProperty,
						LONG lFlags,
						CIMTYPE cimtype,
						LONG lFlavor = 0,
						BSTR strObjectType= NULL);

	HRESULT BeginMethod(BSTR strMethod);
	HRESULT EndMethod();

	HRESULT BeginParameter(BSTR strParam,
							CIMTYPE cimtype,
							VARIANT *pValue,
							BOOL bInParam = TRUE,
							LONG lFlavor = 0,
							BSTR strObjectType= NULL);
	HRESULT EndParameter();
	
	HRESULT BeginReturnVal(BSTR strReturnVal , 
							CIMTYPE cimtypeOfRet , 
							BSTR strObjectTypeOfRet = NULL);
	HRESULT EndReturnVal();
	
	HRESULT BeginSchemaAndWriteTillBeginingOfAnnotation();
	HRESULT EndAnnotation();
	HRESULT PrepareStreamToAddPropertiesForComplexType();
	HRESULT EndSchema();


private:
	
	HRESULT BeginComplexType();
	HRESULT BeginDerivationSectionIfAny();
	HRESULT AddIncludes();
	HRESULT AddImports();
	HRESULT AddElementForComplexType();
	HRESULT AddProperties();
	HRESULT BeginSchema();

	HRESULT BeginPropAnnotation(BSTR strProperty,VARIANT *pVarVal, BSTR strPropertyType,LONG lFlavor,BOOL bArray);
	HRESULT EndWMITag(WCHAR * pStrTag);

	HRESULT AddFlavor(LONG lFlavor);
	HRESULT GetDateTypePropertyName(WCHAR * pStrTypeName);
	HRESULT WriteNameSpace(WCHAR * pstrNamespace , WCHAR * pstrNSPrefix);
	HRESULT GetType(CIMTYPE cimtype,WCHAR *pStrOut,BOOL &bArray , BSTR strEmbeddedObjectType , BOOL bXSDType);


};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlinst.h ===
//***************************************************************************
///
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMIXMLInstance.h
//
//  ramrao 3 Dec 2000 - Created
//
//
//		Declaration for CWMIXMLInstance class
//
//***************************************************************************/

#define	WMI_XMLINST_NONAMESPACE		0x0800
#define	WMI_ESCAPE_XMLSPECIALCHARS	0x1000

class CWMIXMLInstance:public CWMIXMLObject
{
	
private:

	BSTR				m_strClass;
	BSTR				m_strSchemaNamespace;
	BSTR				m_strSchemaLocation;
	LONG				m_lFlags;
	LONG				m_lState;
	BOOL				m_bEscape;


	HRESULT SetWMIClass(BSTR strClass);
	HRESULT WriteToStream(IStream * pStreamOut,WCHAR *pBuffer);

public:
	CWMIXMLInstance();
	virtual ~CWMIXMLInstance();

	HRESULT FInit(LONG lFlags = 0 , BSTR strClass = NULL);
	HRESULT BeginPropTag(BSTR strProperty,CIMTYPE cimtype , BOOL bNull = FALSE,BSTR strEmbeddePropType = NULL);							   ;
	HRESULT AddTag(BSTR strProperty,BOOL bBegin);
	HRESULT AddProperty(BSTR strProperty,CIMTYPE cimtype,VARIANT * pvVal=NULL,BSTR strEmbeddedType=NULL);
	HRESULT SetSchemaLocation(BSTR strNamespace,BSTR strSchemaLocation);
	HRESULT BeginEmbeddedInstance(BSTR strClass);							   
	HRESULT EndEmbeddedInstance(BSTR strClass);							   
	HRESULT BeginInstance();
	HRESULT EndInstance();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlobject.cpp ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMIXMLObject.cpp
//
//  ramrao 12 Dec 2000
//
//  Class that implements conversion of a WMI Instance to XML
//
//		Implementation of CWMIXMLObject class
//
//***************************************************************************/

#include "precomp.h"


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the stream pointer to write the schema
// Return Values:	S_OK				- 
//					E_INVALIDARG				- 
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLObject::SetStream(IStream *pStream) 
{ 
	HRESULT hr = S_OK;
	if(pStream) 
	{ 
		hr = m_pIWMIXMLUtils->SetStream(pStream);
	}
	return hr; 
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function which writes 
// Return Values:	S_OK				- 
//					E_INVALIDARG				- 
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLObject::WriteAttribute(WCHAR *szAttrName , WCHAR * szStrAttrVal)
{
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = m_pIWMIXMLUtils->WriteToStream(szAttrName)))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_EQUALS);
	}
	
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteString(szStrAttrVal,TRUE);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlutils.h ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmixmlutils.h
//
//  ramrao 12 Dec 2000
//
//  Class that implements conversion of a WMI Instance to XML
//
//		declaration of CWMIXMLUtils class. 
//
//***************************************************************************/
#ifndef _WMIXML_UTILS_H_
#define _WMIXML_UTILS_H_

class CWMIXMLUtils
{
	private:
		LONG		m_lFlags;
		IStream *	m_pIStream;
	
	HRESULT GetXMLForInstance(IUnknown *pUnk ,BOOL bEscape);
	HRESULT WriteToStreamDirect( WCHAR * pBuffer , ULONG *pcbWchar = NULL );

	public:

	CWMIXMLUtils();
	virtual ~CWMIXMLUtils();

	HRESULT SetStream(IStream *pStream);
	void	SetFlags(LONG lFlags) { m_lFlags = lFlags; }

	HRESULT ConvertVariantToString(VARIANT &varIn,BSTR strProperty,BOOL bEscape = TRUE);
	HRESULT ConvertVariantArrayToXML(VARIANT varIn,BOOL bEscape = FALSE);
	HRESULT ConvertToString(void * pData,VARTYPE vt ,BOOL bEscape);

	HRESULT AddStringToStream(LONG strID);
	HRESULT WriteToStream( WCHAR * pBuffer , ULONG *pcbWchar = NULL );

	HRESULT WriteByte ( unsigned char val);
	HRESULT WriteLong ( long lVal);
	HRESULT WriteShort ( short iVal);
	HRESULT WriteDouble ( double dVal);
	HRESULT WriteFloat ( float fVal);
	HRESULT WriteChar( char cVal);
	HRESULT WriteWChar( WCHAR cVal);
	HRESULT WriteBool (BOOL bVal);
	HRESULT WriteString( WCHAR * pwcsVal,BOOL bEscape = FALSE);


	HRESULT ReplaceXMLSpecialCharsAndWrite(WCHAR *pwcsStr);

	HRESULT GetPropertyWMIType(CIMTYPE cimtype,WCHAR * pType,BOOL &bArray,BOOL bStdWmiImport=FALSE);
	HRESULT GetPropertyXSDType(CIMTYPE cimtype,WCHAR * pType,BOOL &bArray,BOOL bStdWmiImport=FALSE);
	HRESULT GetQualifierWMIType(VARTYPE vType,WCHAR * pType,BOOL & bArray);
	HRESULT GetQualifierXSDType(VARTYPE vType,WCHAR * pType,BOOL & bArray);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlschema.cpp ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMIXMLSchema.cpp
//
//  ramrao 13 Nov 2000 - Created
//
//  Class that implements conversion implements functions to facilitate
//  converstion of WMI class to XML schema
//
//		Implementation of CWMIXMLSchema class
//
//***************************************************************************/

#include "precomp.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*********************************************************************************************************************/
//				CXSDSchemaLocs implementation
//*********************************************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CXSDSchemaLocs::CXSDSchemaLocs() 
{ 
	m_strSchemaLoc		=	NULL;
	m_strNamespace		=	NULL;
	m_strNSQualifier	=	NULL; 
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CXSDSchemaLocs::~CXSDSchemaLocs() 
{ 
	SAFE_FREE_SYSSTRING(m_strSchemaLoc); 
	SAFE_FREE_SYSSTRING(m_strNamespace); 
	SAFE_FREE_SYSSTRING(m_strNSQualifier); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Set values of the different member variables for import
//
//	Returns S_OK
//			E_FAIL
//			E_OUTOFMEMORY
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CXSDSchemaLocs::SetImport(BSTR strSchemaLoc , BSTR strNamespace , BSTR strNSQualifier)
{
	HRESULT hr = E_FAIL;

	if( strSchemaLoc && strNamespace)
	{
		hr = E_OUTOFMEMORY;

		// Allocte string and check if string is allocated successfully
		if( m_strSchemaLoc	= SysAllocString(strSchemaLoc))
		{
			// Allocte string and check if string is allocated successfully
			if(m_strNamespace	= SysAllocString(strNamespace))
			{
				if(strNSQualifier)
				{
					m_strNSQualifier = SysAllocString(strNSQualifier);
				}
				else
				{
					m_strNSQualifier = SysAllocString(DEFAULTWMIPREFIX);
				}

				// check if string is allocated successfully
				if(m_strNSQualifier)
				{
					hr = S_OK;
				}
				else
				{
					SAFE_FREE_SYSSTRING(m_strSchemaLoc);
					SAFE_FREE_SYSSTRING(m_strNamespace);
				}
			}
			else
			{
				SAFE_FREE_SYSSTRING(m_strSchemaLoc);
			}
		}
	}

	return hr;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*********************************************************************************************************************/
//				CWMIXMLSchema implementation
//*********************************************************************************************************************/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CWMIXMLSchema::CWMIXMLSchema()
{
	m_strTargetNamespace	= NULL;
	m_strClass				= NULL;
	m_strParentClass		= NULL;
	m_strTargetNSPrefix		= NULL;

	m_lFlags				= 0;
	m_schemaState			= SCHEMA_OK;

	// Set the initial size to 2 and growsize by 2
	m_arrIncludes.SetSize(0,2);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CWMIXMLSchema::~CWMIXMLSchema()
{
	ClearIncludes();

	SAFE_FREE_SYSSTRING(m_strTargetNamespace);
	SAFE_FREE_SYSSTRING(m_strClass);
	SAFE_FREE_SYSSTRING(m_strParentClass);
	SAFE_FREE_SYSSTRING(m_strTargetNSPrefix);


}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function to initialize the class.
// Flag Values: NOSCHEMAHEADERS
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::FInit()
{
	HRESULT hr = S_OK;
	if(m_pIWMIXMLUtils = new CWMIXMLUtils)
	{
		return S_OK;
	}

	return E_OUTOFMEMORY;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the targetNamespace attribute of the schema
//
// Returns	S_OK
//			E_OUTOFMEMORY
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::SetWMIClass(BSTR strClass ,BSTR strParentClass)
{
	HRESULT hr = S_OK;

	if(strClass)
	{
		hr = E_OUTOFMEMORY;
		if(m_strClass =SysAllocString(strClass))
		{
			hr = S_OK;
			if(strParentClass)
			{
				hr = E_OUTOFMEMORY;
				if(m_strParentClass	= SysAllocString(strParentClass))
				{
					hr = S_OK;
				}
			}
			
		}
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the targetNamespace attribute of the schema
//
// Returns	S_OK
//			E_OUTOFMEMORY
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::SetTargetNamespace(BSTR strTargetNS,BSTR strTargetNamespacePrefix)
{
	HRESULT hr = S_OK;
	SAFE_FREE_SYSSTRING(m_strTargetNamespace);
	
	if(strTargetNS)
	{
		if(m_strTargetNamespace = SysAllocString(strTargetNS))
		{
			m_strTargetNSPrefix  = SysAllocString(strTargetNamespacePrefix);
		}

		if(m_strTargetNamespace == NULL || 
			(strTargetNamespacePrefix != NULL && m_strTargetNSPrefix == NULL) )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a <include> with the schemaLocation provided to be included in the schema
//
// Returns	S_OK
//			E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::AddXSDInclude(BSTR strSchemaLoc)
{
	HRESULT hr = E_FAIL;
	BSTR strToAdd = NULL;

	if(strSchemaLoc)
	{
		hr = S_OK;

		strToAdd = SysAllocString(strSchemaLoc);
		if(strToAdd)
		{
			if(-1 == m_arrIncludes.Add((void *) strToAdd))
			{
				SAFE_FREE_SYSSTRING(strToAdd);
				hr = E_OUTOFMEMORY;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Clears all the Strings in the array 
//
// Returns	S_OK
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIXMLSchema::ClearIncludes()
{
	int nIncludes = m_arrIncludes.GetSize();
	BSTR strInclude	= NULL;

	for(int nIndex = 0 ; nIndex < nIncludes ; nIndex++)
	{
		strInclude = (BSTR)m_arrIncludes.ElementAt(nIndex);
		SAFE_FREE_SYSSTRING(strInclude);	
	}
	m_arrIncludes.RemoveAll();

}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a Qualifier in the annotation. 
// Function can be used to add both class and property qualifiers.
// Flag Values: NOSCHEMAHEADERS
//
///	FIXX - How to put Arrays in Qualifiers
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::AddQualifier(BSTR strName,VARIANT *pVal,LONG lFlavor)
{
	HRESULT	hr			= S_OK;
	WCHAR *	pstrVal		= NULL;
	BOOL	bArray		= FALSE;
	
	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(
								m_wmiStdImport.ISNull() ? 
								(WCHAR *)DEFAULTWMIPREFIX : 
								m_wmiStdImport.GetNamespaceQualifier());
	}

							
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_QUALIFIER);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_NAMEATTR,strName);
	}


	if(SUCCEEDED(hr))
	{
		WCHAR	szWMIType[MAXXSDTYPESIZE];
		if(SUCCEEDED(hr = m_pIWMIXMLUtils->GetQualifierWMIType(pVal->vt,szWMIType,bArray)))
		{
				hr = WriteAttribute((WCHAR *)STR_TYPEATTR,szWMIType);
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_ARRAYATTR,bArray ? STR_TRUE : STR_FALSE);
	}

	if(SUCCEEDED(hr) && pVal != NULL && pVal->vt == VT_NULL && pVal->vt == VT_EMPTY)
	{
		if(SUCCEEDED(hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_VALUEATTR)))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_EQUALS);
		}
		
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->ConvertVariantToString(*pVal,strName,TRUE);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = AddFlavor(lFlavor);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_FORWARDSLASH);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a property element in Annotation and doesn't add the closing </property> 
// making it easy for adding property qualifiers
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginPropertyInAnnotation(BSTR strProperty,
												 LONG lFlags,
												 VARIANT *pVarVal, 
												 CIMTYPE cimtype,
												 LONG lFlavor,
												 BSTR strEmbeddedObjectType)
{
	HRESULT	hr			= S_OK;
	BOOL	bArray		= FALSE;
	
	WCHAR	szWMIType[MAXXSDTYPESIZE];

	
	hr = GetType(cimtype,szWMIType,bArray , strEmbeddedObjectType , FALSE);
	
	bArray = (cimtype & CIM_FLAG_ARRAY);

	if(SUCCEEDED(hr))	
	{
		hr = BeginPropAnnotation(strProperty,pVarVal,(WCHAR *)szWMIType,lFlavor,bArray);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function to initialize the class.
// Flag Values: End a Property in Annotation ie. adds </property> tag
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::EndPropertyInAnnotation()
{
	HRESULT hr = S_OK;

	// If property is not started then return an error
	if( m_schemaState != SCHEMA_BEGINPROPINANNOTATION)
	{
		hr = WBEMXML_E_PROPNOTSTARTED;
	}
	else
	{
		if(SUCCEEDED(hr = EndWMITag((WCHAR *)STR_PROPERTY)))
		{
			// Set the state back to method additon
			m_schemaState = SCHEMA_OK;
		}
	}
	return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Add a property to the schema. 
// This function adds an element to the ComplexType representing the class.
// function used for adding property ( except embedded property)
//
// Returns :
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::AddProperty(BSTR strProperty,LONG lFlags,CIMTYPE cimtype,LONG lFlavor,BSTR strEmbeddedObject)
								   
{
	HRESULT	hr			= S_OK;
	BOOL	bArray		= FALSE;
	
	WCHAR	szXSDType[MAXXSDTYPESIZE];

	hr = GetType(cimtype,szXSDType,bArray , strEmbeddedObject , TRUE);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_ELEMENT);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_NAMEATTR,strProperty);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_TYPEATTR,szXSDType);
	}

	if(SUCCEEDED(hr))
	{
		WCHAR * pwcsOccurs = new WCHAR[wcslen(MAXOCCURS_FORARRAY) + 1];
		if(pwcsOccurs)
		{

			LONG lOccurs = 0;
			swprintf(pwcsOccurs,L"%ld",lOccurs);

			hr = WriteAttribute((WCHAR *)STR_MINOCCURS,pwcsOccurs);
			lOccurs = 1;
			if(cimtype & CIM_FLAG_ARRAY)
			{
				wcscpy(pwcsOccurs,MAXOCCURS_FORARRAY);
			}
			else
			{
				swprintf(pwcsOccurs,L"%ld",lOccurs);
			}
			
			if(SUCCEEDED(hr))
			{
				hr = WriteAttribute((WCHAR *)STR_MAXOCCURS,pwcsOccurs);
			}

			SAFE_DELETE_ARRAY(pwcsOccurs);
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_FORWARDSLASH);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}
	
	return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Set the import parameters to be done for WMI standard defination such as datetime
//
// Note:This should be done before creating any element or qualifier
// Return Values:	S_OK				- pStream is NULL
//					E_FAIL		
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT	CWMIXMLSchema::SetWMIStdImport(BSTR strNamespace, BSTR strSchemaLoc, BSTR strPrefix)
{
	return m_wmiStdImport.SetImport(strSchemaLoc,strNamespace,strPrefix);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a complexType defination to stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginComplexType()
{
	HRESULT hr = S_OK;

	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COMPLEXTYPE,FALSE);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_NAMEATTR,m_strClass);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a complexType defination to stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginDerivationSectionIfAny()
{
	HRESULT hr			= S_OK;
	
	if(m_strParentClass)
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGINCHILDCOMPLEXTYPE);
		
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGINEXTENSION);
		}
		

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BASEATTR);
			
			if(SUCCEEDED(hr))
			{
				hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_EQUALS);
			}

			if(SUCCEEDED(hr))
			{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
			}

			if(m_strTargetNSPrefix)
			{
				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream(m_strTargetNSPrefix);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
				}

			}

			if(SUCCEEDED(hr))
			{
				hr = m_pIWMIXMLUtils->WriteToStream(m_strParentClass);
			}

			if(SUCCEEDED(hr))
			{
				hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
			}
		}

		
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
		}

		return hr;
	}

	return hr;
}





/////////////////////////////////////////////////////////////////////////////////////////////////
//
// writes <include> section to the schema
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::AddIncludes()
{
	HRESULT		hr			= S_OK;
	int			nIncludes	= 0;
	BSTR		strInclude	= NULL;
	
	nIncludes = m_arrIncludes.GetSize();
	for(int nIndex = 0 ; nIndex < nIncludes && SUCCEEDED(hr) ; nIndex++)
	{
		strInclude = (BSTR)m_arrIncludes.ElementAt(nIndex);

		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_XSDINCLUDE);
		}
		
		
		if(SUCCEEDED(hr))
		{
			hr = WriteAttribute((WCHAR *)STR_SCHEMALOCATTR,strInclude);
		}
		
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_FORWARDSLASH);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
		}
	}
	
	return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes the <import> section to the schema
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::AddImports()
{
	HRESULT hr			= S_OK;
	
	if(!m_wmiStdImport.ISNull())
	{
		BSTR strSchemaLoc			= m_wmiStdImport.GetSchemLoc();
		BSTR strNamespace			= m_wmiStdImport.GetNamespace();

		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_XSDIMPORT);
		}
		
		
		if(SUCCEEDED(hr))
		{
			hr = WriteAttribute((WCHAR *)STR_SCHEMALOCATTR,strSchemaLoc);
		}
		
		if(SUCCEEDED(hr))
		{
			hr = WriteAttribute((WCHAR *)STR_NAMESPACEATTR,strNamespace);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_FORWARDSLASH);
		}

		if(SUCCEEDED(hr))
		{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes an <element> section for the complexType that will be defined in the schema
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::AddElementForComplexType()
{
	
	HRESULT		hr			= S_OK;

	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_ELEMENT);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_NAMEATTR,m_strClass);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_TYPEATTR);
	}
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_EQUALS);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
	}

	if( SUCCEEDED(hr) && m_strTargetNSPrefix)
	{
		hr = m_pIWMIXMLUtils->WriteToStream(m_strTargetNSPrefix);
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(m_strClass);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
	}

	if(SUCCEEDED(hr))
	{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_FORWARDSLASH);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Begins <Schema> and sets the different attributes
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginSchema()
{
	HRESULT		hr			= S_OK;

	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGINXSD);

	if(SUCCEEDED(hr))
	{
		hr = WriteNameSpace(m_strTargetNamespace,m_strTargetNSPrefix);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteNameSpace(m_wmiStdImport.GetNamespace(),m_wmiStdImport.GetNamespaceQualifier());
	}
	
	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_TARGETNAMESPACEATTR,m_strTargetNamespace);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a property element in Annotation and doesn't add the closing tag for property
// making it easy for adding property qualifiers
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginPropAnnotation(BSTR strProperty,
										   VARIANT *pVarVal, 
										   WCHAR * pstrPropertyType,
										   LONG lFlavor,
										   BOOL bArray)
{

	HRESULT	hr			= S_OK;

	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(
										m_wmiStdImport.ISNull() ? 
										(WCHAR *)DEFAULTWMIPREFIX : 
										m_wmiStdImport.GetNamespaceQualifier());
	}
							
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_PROPERTY);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_NAMEATTR,strProperty);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_TYPEATTR,pstrPropertyType);
	}

	if(SUCCEEDED(hr) && pVarVal != NULL && pVarVal->vt != VT_NULL && pVarVal->vt != VT_EMPTY)
	{
		if(SUCCEEDED(hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_DEFAULTATTR)))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_EQUALS);
		}
		
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->ConvertVariantToString(*pVarVal,strProperty,TRUE);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
		}

	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	if(SUCCEEDED(hr))
	{
		m_schemaState = SCHEMA_BEGINPROPINANNOTATION;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a Method to the Annotation section
// This begins the method annotation . End Method has to be called after adding the parameters
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginMethod(BSTR strMethod)
{
	HRESULT	hr					= S_OK;
	WCHAR *	pstrVal				= NULL;
	WCHAR *	pwcsMethodFormat	= NULL;
	
	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(m_wmiStdImport.ISNull() ? 
										DEFAULTWMIPREFIX :m_wmiStdImport.
											GetNamespaceQualifier());
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_METHOD);
	}

	if(SUCCEEDED(hr))
	{
		hr = WriteAttribute((WCHAR *)STR_NAMEATTR,strMethod);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	if(SUCCEEDED(hr))
	{
		m_schemaState = SCHEMA_BEGINMETHODINANNOTATION;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Ends the method section in annotation section
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::EndMethod()
{

	
	HRESULT hr = S_OK;

	// If property is not started then return an error
	if( m_schemaState != SCHEMA_BEGINMETHODINANNOTATION)
	{
		hr = WBEMXML_E_METHODNOTSTARTED;
	}
	else
	{	
		if(SUCCEEDED(hr = EndWMITag((WCHAR *)STR_METHOD)))
		{
			// Set the state back to method additon
			m_schemaState = SCHEMA_OK;
		} 
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Begins a parameter declaration in a method
// This can be called only after call to BeginMethod and before EndMethod

//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginParameter(BSTR strParam,
						CIMTYPE cimtype,
						VARIANT *pValue,
						BOOL bInParam ,
						LONG lFlavor,
						BSTR strObjectType)
{
	
	HRESULT hr = S_OK;
	
	// If property is not started then return an error
	if( m_schemaState != SCHEMA_BEGINMETHODINANNOTATION)
	{
		hr = WBEMXML_E_METHODNOTSTARTED;
	}
	else
	{
		BOOL	bArray			= FALSE;
		WCHAR	szWMIType[MAXXSDTYPESIZE];

		
		hr = GetType(cimtype,szWMIType,bArray , strObjectType , FALSE);

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream(
											m_wmiStdImport.ISNull() ? 
											(WCHAR *)DEFAULTWMIPREFIX : 
											m_wmiStdImport.GetNamespaceQualifier());
		}
								
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_METHODPARAM);
		}

		if(SUCCEEDED(hr))
		{
			hr = WriteAttribute((WCHAR *)STR_NAMEATTR,strParam);
		}

		if(SUCCEEDED(hr))
		{
			hr = WriteAttribute((WCHAR *)STR_TYPEATTR,szWMIType);
		}

		if(SUCCEEDED(hr) && pValue && pValue->vt != VT_NULL && pValue->vt != VT_EMPTY)
		{
			if(SUCCEEDED(hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_DEFAULTATTR)))
			{
				hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_EQUALS);
			}
			
			if(SUCCEEDED(hr))
			{
				hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
			}

			if(SUCCEEDED(hr))
			{
				hr = m_pIWMIXMLUtils->ConvertVariantToString(*pValue,strParam,TRUE);
			}

			if(SUCCEEDED(hr))
			{
				hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
			}
		}

		if(SUCCEEDED(hr))
		{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
		}
	}

	if(SUCCEEDED(hr))
	{
		m_schemaState = (m_schemaState | SCHEMA_BEGINPARAMINANNOTATION);
	}

	return hr;
	
}
/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Ends a parameter declaration in a method
// This can be called only after call to BeginMethod and before EndMethod
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::EndParameter()
{
	HRESULT hr = S_OK;

	// If property is not started then return an error
	if( m_schemaState != (SCHEMA_BEGINPARAMINANNOTATION | SCHEMA_BEGINMETHODINANNOTATION) )
	{
		hr = WBEMXML_E_PARAMNOTSTARTED;
	}
	else
	{
		if(SUCCEEDED(hr = EndWMITag((WCHAR *)STR_METHODPARAM)))
		{
			// Set the state back to method additon
			m_schemaState = SCHEMA_BEGINMETHODINANNOTATION;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Adds section to define Return value of a method
// This can be called only after call to BeginMethod and before EndMethod
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginReturnVal(BSTR strReturnVal , 
										CIMTYPE cimtype, 
										BSTR strObjectEmbeddedObjType)
{
	HRESULT	hr	= S_OK;

	if( m_schemaState !=  SCHEMA_BEGINMETHODINANNOTATION) 
	{
		hr = WBEMXML_E_METHODNOTSTARTED;
	}
	else
	{
		BOOL	bArray		= FALSE;

		WCHAR	szWMIType[MAXXSDTYPESIZE];
		
		hr = GetType(cimtype,szWMIType,bArray , strObjectEmbeddedObjType , FALSE);

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream(
											m_wmiStdImport.ISNull() ? 
											(WCHAR *)DEFAULTWMIPREFIX : 
											m_wmiStdImport.GetNamespaceQualifier());
		}
								
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_METHODRETVAL);
		}

		if(SUCCEEDED(hr))
		{
			hr = WriteAttribute((WCHAR *)STR_NAMEATTR,strReturnVal);
		}

		if(SUCCEEDED(hr))
		{
			hr = WriteAttribute((WCHAR *)STR_TYPEATTR,szWMIType);
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
		}
	}

	if(SUCCEEDED(hr))
	{
		m_schemaState = m_schemaState | SCHEMA_BEGINRETURNINANNOTATION;
	}

	return hr;
	
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Adds end tag for return value of a parameter
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::EndReturnVal()
{
	HRESULT hr = S_OK;

	// If property is not started then return an error
	if( m_schemaState != (SCHEMA_BEGINRETURNINANNOTATION | SCHEMA_BEGINMETHODINANNOTATION) )
	{
		hr = WBEMXML_E_RETURNVALNOTSTARTED;
	}
	else
	{
		if(SUCCEEDED(hr = EndWMITag((WCHAR *)STR_METHODRETVAL)))
		{
			// Set the state back to method additon
			m_schemaState = SCHEMA_BEGINMETHODINANNOTATION;
		}
	}
	return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Ends a Tag as specified in the String ID and writes it to teh stream
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::EndWMITag( WCHAR *pStrTag)
{
	HRESULT hr = S_OK;
	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGININGBRACKET);

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_FORWARDSLASH);
	}
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(m_wmiStdImport.ISNull() ? 
									DEFAULTWMIPREFIX :
									m_wmiStdImport.GetNamespaceQualifier());
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(pStrTag);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_CLOSINGBRACKET);
	}

	return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Add flavor for the property
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::AddFlavor(LONG lFlavor)
{
	HRESULT hr = S_OK;

	if(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)
	{
		hr = m_pIWMIXMLUtils->WriteString((WCHAR *)STR_TOSUBCLASS);
	}

	if(SUCCEEDED(hr) && (lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE))
	{
		hr = m_pIWMIXMLUtils->WriteString((WCHAR *)STR_TOINSTANCE);
	}

	if(SUCCEEDED(hr) && (lFlavor & WBEM_FLAVOR_OVERRIDABLE))
	{
		hr = m_pIWMIXMLUtils->WriteString((WCHAR *)STR_OVERRIDABLE);
	}

	if(SUCCEEDED(hr) && (lFlavor & WBEM_FLAVOR_AMENDED))
	{
		hr = m_pIWMIXMLUtils->WriteString((WCHAR *)STR_AMENDED);
	}


	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Get the DateType property name
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::GetDateTypePropertyName(WCHAR * pStrTypeName)
{
	// copy the prefix
	m_wmiStdImport.ISNull() ?wcscpy(pStrTypeName,DEFAULTWMIPREFIX):
				wcscpy(pStrTypeName,m_wmiStdImport.GetNamespaceQualifier());

	wcscat(pStrTypeName,L":");
	wcscat(pStrTypeName,WMI_DATETIME);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// BeginAnnotation - begins the annotation section
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::BeginSchemaAndWriteTillBeginingOfAnnotation()
{
	HRESULT hr = S_OK;

	// Check if Schema state is valid. 
	// ie is there any Begin called without calling end
	if(m_schemaState != SCHEMA_OK)
	{
		hr = WBEMXML_E_SCHEMAINCOMPLETE;
	}
	else
	{

		if(SUCCEEDED(hr) && !(m_lFlags & NOSCHEMATAGS))
		{
			hr = BeginSchema();
		}

		if(SUCCEEDED(hr))
		{
			hr = AddIncludes();
		}

		if(SUCCEEDED(hr))
		{
			hr = AddImports();
		}

		if(SUCCEEDED(hr))
		{
			hr = AddElementForComplexType();
		}

		if(SUCCEEDED(hr))
		{
			hr = BeginComplexType();
		}

		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGINANNOTATION);
			// Add <appinfo>
			if(SUCCEEDED(hr))
			{
				hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGINAPPINFO);
			}
		}
	}

	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Write the Annotation section from the member variable stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::EndAnnotation()
{
	HRESULT hr = S_OK;

	// Add </annotation>
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_ENDAPPINFO);
	}

	// Add </appinfo>
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_ENDANNOTATION);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function which writes sections after finishing the <appinfo> section and set the stream
// ready to add properties
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::PrepareStreamToAddPropertiesForComplexType()
{
	HRESULT hr = S_OK;

	// Add tags for derivation if the complex type
	// is to be derived from a class
	hr = BeginDerivationSectionIfAny();

	if(SUCCEEDED(hr))
	{
		// Add <group> <all)
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_BEGINGROUP);
	}

	return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function which writes sections to end the schema
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::EndSchema()
{
	HRESULT hr = S_OK;

	// Add </all> </group>
	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_ENDGROUP);

	if(SUCCEEDED(hr))
	{
		// Add </anyAttribute> for system properties
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_XSDANYATTR);
	}

	// if the complextype is a derived class then add
	// the closing tags for derivation
	if(SUCCEEDED(hr) && m_strParentClass )
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_ENDCHILDCOMPLEXTYPE);

	}

	if(SUCCEEDED(hr))
	{
		// End ComplexType
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_ENDCOMPLEXTYPE);

	}

	if(SUCCEEDED(hr) && !(m_lFlags & NOSCHEMATAGS))
	{
		// End schema
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_ENDXSDSCHEMA);
	}

	m_pIWMIXMLUtils->SetStream(NULL);

	return hr;
}





/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function to write %s:xmlns = 'namespace' to the stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::WriteNameSpace(WCHAR * pstrNamespace , WCHAR * pstrNSPrefix)
{
	HRESULT hr = S_OK;

	hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_NAMESPACE);

	if(SUCCEEDED(hr) && pstrNSPrefix)
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_COLON);
		if(SUCCEEDED(hr))
		{
			hr = m_pIWMIXMLUtils->WriteToStream(pstrNSPrefix);
		}
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_EQUALS);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream(pstrNamespace);
	}
	
	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_FORWARDSLASH);
	}

	if(SUCCEEDED(hr))
	{
		hr = m_pIWMIXMLUtils->WriteToStream((WCHAR *)STR_SINGLEQUOTE);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function to get the type of the property/qualifer
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLSchema::GetType(CIMTYPE cimtype,WCHAR *pStrOut,BOOL &bArray , BSTR strEmbeddedObjectType , BOOL bXSDType)
{
	HRESULT hr = S_OK;

	// If the property is an embedded property
	if(IsEmbededType(cimtype))
	{
		// Check if the embedded propoerty is typed to some classs or not
		// If not Set the XSD type to "wmi:obj"
		if(strEmbeddedObjectType == NULL || (strEmbeddedObjectType != NULL && 
			( (SysStringLen(strEmbeddedObjectType) == 0) ||
			_wcsicmp(WMI_EMBEDDEDOBJECT_UNTYPED,strEmbeddedObjectType) == 0 ) ))
		{
			wcscpy(pStrOut,WMI_OBJ);
		}
		// else type the type the name of the class
		else
		{
			if(m_strTargetNSPrefix)
			{
				swprintf(pStrOut, L"%s:%s",m_strTargetNSPrefix,strEmbeddedObjectType);
			}
			else
			{
				wcscpy(pStrOut , strEmbeddedObjectType);
			}
		}
	}
	else
	if(cimtype == CIM_DATETIME  || cimtype == (CIM_DATETIME & CIM_FLAG_ARRAY))
	{
		hr = GetDateTypePropertyName(pStrOut);
	}
	else
	{
		if(bXSDType)
		{
			hr = m_pIWMIXMLUtils->GetPropertyXSDType(cimtype,pStrOut,bArray,m_wmiStdImport.ISNull());
		}
		else
		{
			hr = m_pIWMIXMLUtils->GetPropertyWMIType(cimtype,pStrOut,bArray,m_wmiStdImport.ISNull());
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\encoder\wmi2xsd\wmixmlutils.cpp ===
//***************************************************************************/
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmixmlutils.cpp
//
//  ramrao Created 13 Nov 2000.
//
//  Utility CWMIXMLUtils implementation
//
//***************************************************************************/

#include "precomp.h"
#include "wmitoxml.h"

#define MAX_ESCAPELEN				50

#define WMI2XSD_REGISTRYPATH L"Software\\Microsoft\\Wbem\\XML"

WCHAR g_strXMLSpecialChars[] = {L"&'<>\""};

WCHAR g_strEscapeSequence[][MAX_ESCAPELEN] = {{L"&amp;"},{L"&apos;"},{L"&lt;"},{L"&gt;"} , {L"&quot;"}};

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CWMIXMLUtils::CWMIXMLUtils()
{
	m_pIStream	= NULL;
	m_lFlags	= 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CWMIXMLUtils::~CWMIXMLUtils()
{
	SAFE_RELEASE_PTR(m_pIStream);
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the stream pointer of the class
//
// Return Values:	S_OK				- 
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::SetStream(IStream *pStream) 
{ 
	HRESULT hr = S_OK;
	SAFE_RELEASE_PTR(m_pIStream);
	if(pStream)
	{
		hr = pStream->QueryInterface(IID_IStream,(void **)&m_pIStream); 
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Converts a given object to XML and writes it to the stream
//	Used to converting embedded instance
//
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::GetXMLForInstance(IUnknown *pUnk , BOOL bEscape)
{
	IWbemClassObject *	pObject = NULL;
	HRESULT				hr		= S_OK;
	CWMIToXML			xmlConv;
	BSTR				strXml	= NULL;

	LONG				lFlags	= WMI_XMLINST_NONAMESPACE | m_lFlags;

	if(bEscape)
	{
		lFlags |= WMI_ESCAPE_XMLSPECIALCHARS;
	}

	hr = pUnk->QueryInterface(IID_IWbemClassObject , (void **)&pObject);

	xmlConv.SetFlags(lFlags);
	if(SUCCEEDED(hr) && SUCCEEDED(hr = xmlConv.SetWMIObject(pObject)))
	{
		hr = xmlConv.GetXML(m_pIStream);
	}
	
	SAFE_RELEASE_PTR(pObject);

	return hr;
}






/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a byte to Stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteByte ( unsigned char val)
{
	WCHAR szInt[MAXNUMERICSIZE];
	ULONG cbWritten = swprintf(szInt,L"%d",val);
	return  WriteToStream( szInt);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a long value
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteLong ( long lVal)
{
	WCHAR szInt[MAXNUMERICSIZE];
	ULONG cbWritten = swprintf(szInt,L"%d",lVal);
	return  WriteToStream(szInt);

}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a short values
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteShort ( short iVal)
{
	WCHAR szInt[MAXNUMERICSIZE];
	ULONG cbWritten = swprintf(szInt,L"%d",iVal);
	return  WriteToStream( szInt);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a double value to stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteDouble ( double dVal)
{
	WCHAR szInt[MAXNUMERICSIZE];
	ULONG cbWritten = swprintf(szInt,L"%G",dVal);
	return  WriteToStream( szInt);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a float value to stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteFloat ( float fVal)
{
	WCHAR szInt[MAXNUMERICSIZE];
	ULONG cbWritten = swprintf(szInt,L"%G",fVal);
	return  WriteToStream( szInt);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a character to stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteChar( char cVal)
{
	HRESULT hr = S_OK;
	// As per the XML Spec, the following are invalid character values in an XML Stream:
	// Char ::=  #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

	// As per the CIM Operations spec, they need to be escaped as follows:
	//	If the value is not a legal XML character
	//  (as defined in [2, section 2.2] by the Char production)
	//	then it MUST be escaped using a \x<hex> escape convention
	//	where <hex> is a hexadecimal constant consisting of
	//	between one and four digits

	if(	cVal < 0x9 ||
		(cVal == 0xB || cVal == 0xC)	||
		(cVal > 0xD && cVal <0x20)	||
		(cVal >0xD7FF && cVal < 0xE000) ||
		(cVal > 0xFFFD)
		)
	{
		// Map it in the escaped manner
		WCHAR charStr [7];
		swprintf (charStr, L"\\x%04x", cVal&0xffff);
		charStr[6] = NULL;
		hr = WriteToStream( charStr);
	}
	else
	{
		ULONG cbWritten = 0;
		for(ULONG i = 0 ; i < wcslen(g_strXMLSpecialChars) ; i++)
		{
			if(g_strXMLSpecialChars[i] == cVal)
			{
				hr = WriteToStream( g_strEscapeSequence[i] , &cbWritten);
			}
		}

		if(!cbWritten)
		{
			// Map it in the normal manner
			WCHAR charStr [2];
			swprintf (charStr, L"%c", cVal);
			charStr[1] = NULL;
			hr = WriteToStream( g_strEscapeSequence[i] , &cbWritten);
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a wide character to stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteWChar( WCHAR wVal)
{
	WCHAR str[2];
	str[0] = wVal;
	str[1] = 0;

	return WriteToStream(str);
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a bool value to stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteBool ( BOOL bVal)
{
	return WriteToStream( bVal ? STR_TRUE : STR_FALSE);
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Writes a string to stream
//	
//	Parameter
//		bEscape	- Signifies if stream has to be escaped for special XML charachters
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteString( WCHAR * pwcsVal,BOOL bEscape)
{
	if(bEscape)
	{
		return ReplaceXMLSpecialCharsAndWrite(pwcsVal );
	}
	else
	{
		return WriteToStream( pwcsVal);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ConvertVariantToString 
//	Converts a given variant to string
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::ConvertVariantToString(VARIANT &varIn,BSTR strProperty,BOOL bEscape)
{
	HRESULT		hr			= S_OK;
	

	if(!(varIn.vt & VT_ARRAY))
	{
		hr = E_OUTOFMEMORY;

		switch(varIn.vt)
		{
				case VT_UI1:
					{
						BYTE bVal = varIn.bVal ;
						hr = WriteByte( bVal);
					}
					break;

				case VT_I1:
					{
						char cVal = varIn.cVal;
						hr =WriteChar(cVal);
					}
					break;

				case VT_I2:
					{
						short iVal = varIn.iVal ;
						hr =WriteShort(iVal);
					}
					break;

				case VT_UI2:
				case VT_UI4:
				case VT_I4:
					{
						long lVal = varIn.lVal ;
						hr =WriteLong(lVal);
					}
					break;

				case VT_R4:
					{
						float fVal = varIn.fltVal;
						hr = WriteFloat ( fVal);
					}
					break;

				case VT_R8:
					{
						double dblVal = varIn.dblVal; 
						hr = WriteDouble ( dblVal);
					}
					break;

				case VT_BOOL:
					{
						BOOL vBool = varIn.boolVal == VARIANT_TRUE ? TRUE : FALSE; 
						hr  = WriteBool (  vBool);
					}
					break;


				case VT_BSTR:
					{
						BSTR bstrVal = varIn.bstrVal ;
						if(bstrVal)
						{
							hr = WriteString (  bstrVal,bEscape);
						}
					}
					break;

				case CIM_UINT64:
				case CIM_SINT64:
				case CIM_DATETIME:
					{
						BSTR bstrVal = varIn.bstrVal ;
						if(bstrVal)
						{
							hr = WriteString (  bstrVal,bEscape);
						}
					}
					break;

				case VT_UNKNOWN:
					if(varIn.punkVal != NULL)
					{
						hr = GetXMLForInstance(varIn.punkVal, bEscape);
					}
					break;

				default:
					TranslateAndLog(L"Unhandled data type");
					hr = E_FAIL;
				


		};
	}
	else
	{
		hr = ConvertVariantArrayToXML(varIn, bEscape);
	}

	return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ConvertVariantArrayToXML 
//	Converts a given safearray to XML as per the SOAP array format
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::ConvertVariantArrayToXML(VARIANT varIn,BOOL bEscape)
{
	HRESULT hr		= E_FAIL;
	long	lBound	= 0;
	long	uBound	= 0;

	VARTYPE vArrayType = varIn.vt & (~VT_ARRAY);

	// Get the size of the array
	if(SUCCEEDED(SafeArrayGetLBound(varIn.parray,1,&lBound)) && 
		SUCCEEDED(SafeArrayGetUBound(varIn.parray,1,&uBound)) )
	{
		long	lArraySize		= uBound - lBound;
		int		nElementSIze	= 0;
		void *	pData			= NULL;
		WCHAR *	pTempStr		= NULL;
		
		hr = E_OUTOFMEMORY;

		nElementSIze	= SafeArrayGetElemsize(varIn.parray);
		
		pData			= new BYTE[nElementSIze];

		if(pData)
		{
			hr = S_OK;
			// Array size include both UBOUND and LBOUND
			for( long lIndex = 0 ; lIndex <= lArraySize && SUCCEEDED(hr); lIndex++)
			{
				// get the array element
				if(SUCCEEDED(hr = SafeArrayGetElement(varIn.parray,&lIndex,pData)))
				{
					// convert the element to string
					if(SUCCEEDED(hr))
					{
						hr = WriteString( (WCHAR *)STR_BEGINARRAYELEM,bEscape);
						if(SUCCEEDED(hr))
						{
							hr = ConvertToString(pData,vArrayType, bEscape);
						}
						if(SUCCEEDED(hr))
						{
							hr = WriteString( (WCHAR *)STR_ENDARRAYELEM,bEscape);
						}
						SAFE_DELETE_ARRAY(pTempStr);
					}
				}

			}
			SAFE_DELETE_ARRAY(pData);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ConvertToString 
//	Converts a given data in a memory to string
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::ConvertToString(void * pData,VARTYPE vt ,BOOL bEscape)
{
	HRESULT		hr			= S_OK;
	

	hr = E_OUTOFMEMORY;
	switch(vt)
	{

				case VT_UI1:
					{
						BYTE *pbVal = (BYTE *)pData;
						WriteByte (  *pbVal);
					}
					break;

				case VT_I1:
					{
						char *pcVal = (char *)pData;
						hr =WriteChar( *pcVal);
					}
					break;

				case VT_I2:
					{
						long *plVal = (long *)pData;
						hr =WriteLong( *plVal);
					}
					break;

				case VT_UI2:
				case VT_UI4:
				case VT_I4:
					{
						short * plVal = (short *)pData;
						hr =WriteShort( *plVal);
					}
					break;

				case VT_R4:
					{
						float *pfVal = (float *)pData;
						hr = WriteFloat (  *pfVal);
					}
					break;

				case VT_R8:
					{
						double * pdblVal = (double *)pData; 
						hr = WriteDouble (  *pdblVal);
					}
					break;

				case VT_BOOL:
					{
						BOOL vBool = *((VARIANT_BOOL *)pData) == VARIANT_TRUE ? TRUE : FALSE; 
						hr  = WriteBool (  vBool);
					}
					break;


				case VT_BSTR:
					{
						BSTR * pbstrVal = (BSTR *)pData;
						if(pbstrVal)
						{
							hr = WriteString(  *pbstrVal);
						}
					}
					break;

				case CIM_UINT64:
				case CIM_SINT64:
				case CIM_DATETIME:
					{
						BSTR * pbstrVal = (BSTR *)pData;
						if(pbstrVal)
						{
							hr = WriteString (  *pbstrVal);
						}
					}
					break;

				case VT_UNKNOWN:
					{
						IUnknown ** ppUnk = (IUnknown **)pData;
						if(*ppUnk)
						{
							hr = GetXMLForInstance(*ppUnk, bEscape);
						}
					}
					break;

				default:
					TranslateAndLog(L"Unhandled data type");
					hr = E_FAIL;
				

	};
	return hr;

}




/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the WMI type in string for a property 
// This function does not take care of embedded properties
// Return Values:	S_OK				- 
//					E_FAIL				- 
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::GetPropertyWMIType(CIMTYPE cimtype,WCHAR * pType,BOOL &bArray,BOOL bStdWmiImport)
{
	HRESULT hr = S_OK;
	
	bArray = FALSE;

	// If the type is array set the output param
	// and get the original type of array
	if(cimtype & CIM_FLAG_ARRAY)
	{
		bArray = TRUE;
		cimtype = cimtype & ~CIM_FLAG_ARRAY;
	}
	
	switch(cimtype)
	{

		case CIM_SINT8:
			wcscpy(pType,WMI_I1);
			break;

		case CIM_UINT8:
			wcscpy(pType,WMI_UI1);
			break;

		case CIM_CHAR16:
		case CIM_SINT16:
			wcscpy(pType,WMI_I2);
			break;

		case CIM_UINT16:
			wcscpy(pType,WMI_UI2);
			break;

		case CIM_BOOLEAN:
			wcscpy(pType,WMI_BOOL);
			break;

		case CIM_SINT32:
			wcscpy(pType,WMI_UI2);
			break;

		case CIM_UINT32:
			wcscpy(pType,WMI_UI2);
			break;

		case CIM_REAL32:
			wcscpy(pType,WMI_R4);
			break;
		
		case CIM_SINT64:
			wcscpy(pType,WMI_I8);
			break;

		case CIM_UINT64:
			wcscpy(pType,WMI_UI8);
			break;

		case CIM_REAL64:
			wcscpy(pType,WMI_R8);
			break;

		case CIM_DATETIME:
			if(!bStdWmiImport)
			{
				wcscpy(pType,DEFAULTWMIPREFIX);
				wcscat(pType,L":");
				wcscat(pType,WMI_DATETIME);
			}
			else
			{
				// FIXX check if datetime schema has to included in schema?
				wcscpy(pType,WMI_STRING);
			}
			break;


		case CIM_STRING:
			wcscpy(pType,WMI_STRING);
			break;

		case CIM_REFERENCE:
			wcscpy(pType,WMI_REF);
			break;


		default:
			TranslateAndLog(L"Invalid property Type");
			hr = E_FAIL;
	};

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the XSD type in string for a property 
// This function does not take care of embedded properties
// Return Values:	S_OK				- 
//					E_FAIL				- 
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::GetPropertyXSDType(CIMTYPE cimtype,WCHAR * pType,BOOL &bArray,BOOL bStdWmiImport)
{
	HRESULT hr = S_OK;
	
	bArray = FALSE;

	// If the type is array set the output param
	// and get the original type of array
	if(cimtype & CIM_FLAG_ARRAY)
	{
		bArray = TRUE;
		cimtype = cimtype & ~CIM_FLAG_ARRAY;
	}
	
	switch(cimtype)
	{

		case CIM_SINT8:
			wcscpy(pType,XSD_I1);
			break;

		case CIM_UINT8:
			wcscpy(pType,XSD_UI1);
			break;

		case CIM_CHAR16:
		case CIM_SINT16:
			wcscpy(pType,XSD_I2);
			break;

		case CIM_UINT16:
			wcscpy(pType,XSD_UI2);
			break;

		case CIM_BOOLEAN:
			wcscpy(pType,XSD_BOOL);
			break;

		case CIM_SINT32:
			wcscpy(pType,XSD_UI2);
			break;

		case CIM_UINT32:
			wcscpy(pType,XSD_UI2);
			break;

		case CIM_REAL32:
			wcscpy(pType,XSD_R4);
			break;
		
		case CIM_SINT64:
			wcscpy(pType,XSD_I8);
			break;

		case CIM_UINT64:
			wcscpy(pType,XSD_UI8);
			break;

		case CIM_REAL64:
			wcscpy(pType,XSD_R8);
			break;

		case CIM_DATETIME:
			if(!bStdWmiImport)
			{
				wcscpy(pType,DEFAULTWMIPREFIX);
				wcscat(pType,L":");
				wcscat(pType,WMI_DATETIME);
			}
			else
			{
				// FIXX check if datetime schema has to included in schema?
				wcscpy(pType,XSD_STRING);
			}
			break;


		case CIM_STRING:
			wcscpy(pType,XSD_STRING);
			break;

		case CIM_REFERENCE:
			wcscpy(pType,XSD_STRING);
			break;


		default:
			TranslateAndLog(L"Invalid property Type");
			hr = E_FAIL;
	};

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the XSD type in string for a quallifier
// Return Values:	S_OK				- 
//					E_FAIL				- Invalid qualifier type
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::GetQualifierWMIType(VARTYPE vType,WCHAR * pType,BOOL & bArray)
{
	HRESULT hr = S_OK;
	
	// If the type is array set the output param
	// and get the original type of array
	if(vType & VT_ARRAY)
	{
		bArray = TRUE;
		vType = vType & ~VT_ARRAY;
	}

	switch(vType)
	{
		case VT_I4:
			wcscpy(pType,WMI_I4);
			break;

		case VT_R8:
			wcscpy(pType,WMI_R8);
			break;

		case VT_BSTR:
			wcscpy(pType,WMI_STRING);
			break;

		case VT_BOOL:
			wcscpy(pType,WMI_BOOL);
			break;

		default:
			TranslateAndLog(L"Invalid Qualifier Type");
			hr = E_FAIL;
	};

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the XSD type in string for a quallifier
// Return Values:	S_OK				- 
//					E_FAIL				- Invalid qualifier type
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::GetQualifierXSDType(VARTYPE vType,WCHAR * pType,BOOL & bArray)
{
	HRESULT hr = S_OK;
	
	// If the type is array set the output param
	// and get the original type of array
	if(vType & VT_ARRAY)
	{
		bArray = TRUE;
		vType = vType & ~VT_ARRAY;
	}

	switch(vType)
	{
		case VT_I4:
			wcscpy(pType,XSD_I4);
			break;

		case VT_R8:
			wcscpy(pType,XSD_R8);
			break;

		case VT_BSTR:
			wcscpy(pType,XSD_STRING);
			break;

		case VT_BOOL:
			wcscpy(pType,XSD_BOOL);
			break;

		default:
			TranslateAndLog(L"Invalid Qualifier Type");
			hr = E_FAIL;
	};

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Loads strig from string table and writes it to the stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::AddStringToStream(LONG strID )
{
	HRESULT hr = S_OK;
	WCHAR * pBuffer = NULL;

	if(SUCCEEDED(hr = LoadAndAllocateStringW(strID,pBuffer)))
	{
		ULONG lSize = wcslen(pBuffer);
			// write data to the output stream
		hr = WriteToStream( pBuffer,&lSize);
	}
	SAFE_DELETE_ARRAY(pBuffer);
	return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Converts the the data from WCHAR to UTF8 and writes it to the output stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteToStream( WCHAR * pBuffer , ULONG * pcbWritten )
{
	HRESULT hr = S_OK;
	
	if(m_lFlags & WMI_ESCAPE_XMLSPECIALCHARS)
	{
		hr = ReplaceXMLSpecialCharsAndWrite(pBuffer);
	}
	else
	{
		ULONG lSizeToBeWritten = wcslen(pBuffer) * sizeof(WCHAR);
		if(lSizeToBeWritten >0)
		{
			hr = m_pIStream->Write(pBuffer,
									lSizeToBeWritten,
									pcbWritten); 
		}
	}

	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Converts the the data from WCHAR to UTF8 and writes it to the output stream
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::WriteToStreamDirect( WCHAR * pBuffer , ULONG * pcbWritten )
{
	HRESULT hr = S_OK;
	
	ULONG lSizeToBeWritten = wcslen(pBuffer) * sizeof(WCHAR);
	if(lSizeToBeWritten >0)
	{
		hr = m_pIStream->Write(pBuffer,
								lSizeToBeWritten,
								pcbWritten); 
	}
	
	return hr;

}
/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function which escapes XML special characters
// Return Values:	S_OK				- 
//					E_FAIL				- 
//					E_OUTOFMEMORY
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIXMLUtils::ReplaceXMLSpecialCharsAndWrite(WCHAR *pwcsStr)
{
	HRESULT hr			= S_OK;
	BOOL	bFound		= FALSE;
	int		iIndex		= 0;
	WCHAR * pWcharOut	= NULL;
	WCHAR str[2];
	str[1] = 0;

	ULONG ulChars = wcslen(pwcsStr);
	int cEscapeSeq = wcslen(g_strXMLSpecialChars);

	for(ULONG lOuterIndex = 0 ; lOuterIndex < ulChars && SUCCEEDED(hr) ; lOuterIndex++)
	{
		bFound = FALSE;
		for(iIndex = 0 ; iIndex < cEscapeSeq  && SUCCEEDED(hr); iIndex++)
		{
			if(pwcsStr[lOuterIndex] == g_strXMLSpecialChars[iIndex])
			{
				bFound = TRUE;
				break;
			}

		}
		if(bFound)
		{
			pWcharOut	= g_strEscapeSequence[iIndex];
		}
		else
		{

			str[0] = pwcsStr[lOuterIndex];
			pWcharOut	= str;
		}

		hr = WriteToStreamDirect(pWcharOut);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\dserlzer.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  dserlzer.h
//
//  alanbos  28-Nov-00   Created.
//
//  Defines the WMI object deserializer.
//
//***************************************************************************

#ifndef _DESRLZER_H_
#define _DESRLZER_H_

/***************************************************************************
//
//  INTERFACE NAME:
//
//  IWmiDeserializer
//
//  DESCRIPTION:
//
//  Defines the WMI XSD deserialization interface. 
//
//***************************************************************************/

interface IWmiDeserializer : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE Deserialize (
		BOOL bIsClass, 
		IWbemServices *pIWbemServices, 
		IWbemClassObject **ppIWbemClassObject
	) = 0;
};

/***************************************************************************
//
//  CLASS NAME:
//
//  CWmiDeserializer
//
//  DESCRIPTION:
//
//  IWmiDeserializer implementation. 
//
//***************************************************************************/

class CWmiDeserializer : public IWmiDeserializer, public ISAXContentHandler
{
private:
	LONG						m_cRef;
	BOOL						m_bIsClass;
	IWbemServices				*m_pIWbemServices;
	IWbemClassObject			*m_pIWbemClassObject;

	// Temporary variables for capturing information as it is being parsed
	BSTR						m_strClassName;			// Current class being parsed
	BSTR						m_strSuperClassName;	// Superclass of the above
	BSTR						m_strPropertyName;		// Current property being parsed
	BSTR						m_strMethodName;		// Current method being parsed
	BSTR						m_strQualifierName;		// Current qualifier being parsed
	IWbemQualifierSet			*m_pObjectQualifierSet;	// Qualifiers for current object being parsed
	IWbemQualifierSet			*m_pPropertyQualifierSet;// Qualifiers for current property being parsed
	IWbemQualifierSet			*m_pMethodQualifierSet;	// Qualifiers for current method being parsed

	// states of the parser
	enum
	{
		INVALID = 0,
		APPINFO_PROPERTY,	// We're inside a <property> tag in the AppInfo section
		APPINFO_METHOD,		// We're inside a <method> tag in the AppInfo section
		BODY_ELEMENT,		// We're inside an <element> tag - Most likely a property
	} m_iParserState;

	// A method to get a named attribute from an attribute set
	HRESULT GetAttributeValue(ISAXAttributes *pAttributes, 
						  LPCWSTR lpAttributeName, int iAttributeNameLen,
						  BSTR *pstrAttributeValue);

	// A method to convert the XML Qualifier attributes to WMI Qualifier features
	HRESULT ConvertQualifierToWMI(ISAXAttributes * pAttributes,
								 BSTR *pstrName,
								 VARIANT *pValue,
								 LONG& lQualifierFlavor);

	// A method to convert a Qualifier value from XML to WMI
	HRESULT ConvertQualifierValueToWMI(BSTR strType, bool bIsArray, BSTR strValue, VARIANT *pValue);

	// Methods to convert specific types of qualifier values
	HRESULT ConvertBooleanQualifierArray(VARIANT *pValue, BSTR strValue);
	HRESULT ConvertStringQualifierArray(VARIANT *pValue, BSTR strValue);	
	HRESULT ConvertSint32QualifierArray(VARIANT *pValue, BSTR strValue);
	HRESULT ConvertReal64QualifierArray(VARIANT *pValue, BSTR strValue);

	// A method to set the type of a property to the correct type
	HRESULT RectifyProperty(IWbemClassObject *pIWbemClassObject, BSTR strName, BSTR strType);

public:
	CWmiDeserializer(IWbemServices *pServices);
	virtual ~CWmiDeserializer();

	// ISAXContentHandler methods
	STDMETHODIMP putDocumentLocator (
        struct ISAXLocator * pLocator ) 
	{ return S_OK; }

    STDMETHODIMP startDocument ( );

    STDMETHODIMP endDocument ( );

    STDMETHODIMP startPrefixMapping (
        const unsigned short * pwchPrefix,
        int cchPrefix,
        const unsigned short * pwchUri,
        int cchUri )
	{ return S_OK; }
	
    STDMETHODIMP endPrefixMapping (
        const unsigned short * pwchPrefix,
        int cchPrefix )
	{ return S_OK; }

    STDMETHODIMP startElement (
        const unsigned short * pwchNamespaceUri,
        int cchNamespaceUri,
        const unsigned short * pwchLocalName,
        int cchLocalName,
        const unsigned short * pwchQName,
        int cchQName,
        ISAXAttributes * pAttributes );

    STDMETHODIMP endElement (
        const unsigned short * pwchNamespaceUri,
        int cchNamespaceUri,
        const unsigned short * pwchLocalName,
        int cchLocalName,
        const unsigned short * pwchQName,
        int cchQName );

    STDMETHODIMP characters (
        const unsigned short * pwchChars,
        int cchChars );

    STDMETHODIMP ignorableWhitespace (
        const unsigned short * pwchChars,
        int cchChars )
	{ return S_OK; }

    STDMETHODIMP processingInstruction (
        const unsigned short * pwchTarget,
        int cchTarget,
        const unsigned short * pwchData,
        int cchData )
	{ return S_OK; }

    STDMETHODIMP skippedEntity (
        const unsigned short * pwchName,
        int cchName )
	{ return S_OK; }


	// IWmiDeserializer methods
	STDMETHODIMP Deserialize (
		BOOL bIsClass, 
		IWbemServices *pIWbemServices, 
		IWbemClassObject **ppIWbemClassObject);

	// IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\httptrns.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  httptrns.h
//
//  alanbos  31-Oct-00   Created.
//
//  Defines the HTTP SOAP transport entity.
//
//***************************************************************************

#ifndef _HTTPTRNS_H_
#define _HTTPTRNS_H_

#define HTTP_M_POST					"M-POST"
#define HTTP_POST					"POST"
#define HTTP_GET					"GET"

#define	HTTP_WMI_XMLTEXT			"text/xml"
#define HTTP_SOAP_MAN_HEADER		"http://schemas.xmlsoap.org/soap/envelope/"
#define HTTP_SOAP_ACTION			"SOAPAction"
#define HTTP_NS						"ns="

// A Macro to skip white spaces - useful in header parsing
#define SKIPWS(x)	while (x && isspace (*x)) x++;

//***************************************************************************
//
//  CLASS NAME:
//
//  HTTPTransport
//
//  DESCRIPTION:
//
//  HTTP Transport endpoint implementation.
//
//***************************************************************************

class HTTPTransport : public SOAPTransport
{
private:
	LPEXTENSION_CONTROL_BLOCK m_pECB;
	char	*m_pSOAPAction;

	class HTTPTransportRequestStream : IStream
	{
	private:
		LONG m_cRef;
		LPEXTENSION_CONTROL_BLOCK m_pECB;
		bool m_readingFirstBuffer;
		bool m_finishedReading;
		ULONG m_bytesRead;

		void	ReadFromBuffer (long & numRead, void *pv, ULONG cb);
		
	public:
		HTTPTransportRequestStream (LPEXTENSION_CONTROL_BLOCK pECB) :
		  m_pECB (pECB),
		  m_cRef (1),
		  m_readingFirstBuffer (true),
		  m_finishedReading (false),
		  m_bytesRead (0) {}
		  virtual ~HTTPTransportRequestStream () {}

	  	// IUnknown functions
		//===================
		STDMETHODIMP			QueryInterface(REFIID iid,void ** ppvObject);
		STDMETHODIMP_(ULONG)	AddRef();
		STDMETHODIMP_(ULONG)	Release();

		// IStream functions 
		//==================
		STDMETHODIMP Read(void *pv,ULONG cb,ULONG *pcbRead);
		STDMETHODIMP Write(void const *pv,ULONG cb,ULONG *pcbWritten);
		STDMETHODIMP Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition);
		STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
		STDMETHODIMP CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten);
		STDMETHODIMP Commit(DWORD grfCommitFlags);
		STDMETHODIMP Revert(void);
		STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
		STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
		STDMETHODIMP Stat(STATSTG *pstatstg,DWORD grfStatFlag);
		STDMETHODIMP Clone(IStream **ppstm);
	};

	class HTTPTransportResponseStream : IStream
	{
	private:
		LONG m_cRef;
		LPEXTENSION_CONTROL_BLOCK m_pECB;
		
	public:
		HTTPTransportResponseStream (LPEXTENSION_CONTROL_BLOCK pECB) :
		  m_pECB (pECB),
		  m_cRef (1) {}
		  virtual ~HTTPTransportResponseStream () {}

	  	// IUnknown functions
		//===================
		STDMETHODIMP			QueryInterface(REFIID iid,void ** ppvObject);
		STDMETHODIMP_(ULONG)	AddRef();
		STDMETHODIMP_(ULONG)	Release();

		// IStream functions 
		//==================
		STDMETHODIMP Read(void *pv,ULONG cb,ULONG *pcbRead);
		STDMETHODIMP Write(void const *pv,ULONG cb,ULONG *pcbWritten);
		STDMETHODIMP Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition);
		STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
		STDMETHODIMP CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten);
		STDMETHODIMP Commit(DWORD grfCommitFlags);
		STDMETHODIMP Revert(void);
		STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
		STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
		STDMETHODIMP Stat(STATSTG *pstatstg,DWORD grfStatFlag);
		STDMETHODIMP Clone(IStream **ppstm);
	};

	HTTPTransportRequestStream		*m_pRequestStream;
	HTTPTransportResponseStream		*m_pResponseStream;

	// Content-Type
	bool			IsXMLText () const;
	bool			IsSOAPActionOK () const;
	bool			IsMPost () const;
	bool			AllMandatoryHeadersUnderstood () const;
	static LPSTR	GetExtensionHeader (LPCSTR pszName, bool bIsMpostRequest, DWORD dwNs);
	static bool		CheckManHeader (LPCSTR pszReceivedManHeader, LPCSTR pszRequiredManHeader, DWORD &dwNs);
	bool			SendServerStatus (bool ok) const;
	
	// Overridden from SOAPTransport
	bool		AbortResponse () const;
	bool		SendSOAPError (bool bIsClientError = true) const;
		
public:
	HTTPTransport (LPEXTENSION_CONTROL_BLOCK pECB, char* soapAction) :
			m_pECB (pECB),
			m_pSOAPAction (NULL)
	{
		m_pRequestStream = new HTTPTransportRequestStream (m_pECB);
		m_pResponseStream = new HTTPTransportResponseStream (m_pECB);

		if (soapAction)
			m_pSOAPAction = _strdup (soapAction);
	}

	~HTTPTransport () 
	{
		if (m_pRequestStream)
		{
			m_pRequestStream->Release ();
			m_pRequestStream = NULL;
		}

		if (m_pResponseStream)
		{
			m_pResponseStream->Release ();
			m_pResponseStream = NULL;
		}

		if (m_pSOAPAction)
		{
			delete [] m_pSOAPAction;
			m_pSOAPAction = NULL;
		}
	}

	bool	GetQueryString (CComBSTR & bsQueryString) const;

	// Overriden from SOAPTransport
	bool		SendStatus (LPCSTR pError, bool bWithContent = true) const;
	HRESULT		GetRootXMLNamespace (CComBSTR & bsNamespace, bool bStripQuery = false) const;

	void	GetRequestStream (CComPtr<IStream> & pIStream)
	{
		if (m_pRequestStream)
			m_pRequestStream->QueryInterface (IID_IStream, (LPVOID*) &pIStream);
	}

	void	GetResponseStream (CComPtr<IStream> & pIStream) 
	{
		if (m_pResponseStream)
			m_pResponseStream->QueryInterface (IID_IStream, (LPVOID*) &pIStream);
	}

	bool	IsValidEncapsulation ();

	bool	IsPostOrMPost () const
	{
		return (m_pECB && m_pECB->lpszMethod && 
				((0 == strcmp(m_pECB->lpszMethod, HTTP_POST)) || (0 == strcmp(m_pECB->lpszMethod, HTTP_M_POST))));
	}

	bool	IsGet () const
	{
		return (m_pECB && m_pECB->lpszMethod && (0 == strcmp(m_pECB->lpszMethod, HTTP_GET)));
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\dserlzer.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  DSERLZER.CPP
//
//  rajeshr  08-Jan-01   Created.
//
//  WMI XSD Deserializer implementation. Server side only.  
//
//***************************************************************************

#include "precomp.h"

// Element Names
//================================================
static LPCWSTR	WMI_XML_ELEMENT		= L"element";
static LPCWSTR	WMI_XML_COMPLEX_TYPE= L"complexType";
static LPCWSTR	WMI_XML_PROPERTY	= L"property";
static LPCWSTR	WMI_XML_METHOD		= L"method";
static LPCWSTR	WMI_XML_QUALIFIER	= L"qualifier";

// Attribute Names
//=======================================
static LPCWSTR	WMI_XML_NAME		= L"name";
static int		WMI_XML_NAME_LEN	= 4;
static LPCWSTR	WMI_XML_BASE		= L"base";
static int		WMI_XML_BASE_LEN	= 4;
static LPCWSTR	WMI_XML_TYPE		= L"type";
static int		WMI_XML_TYPE_LEN	= 4;
static LPCWSTR	WMI_XML_VALUE		= L"value";
static int		WMI_XML_VALUE_LEN	= 5;
// Qualifier flavor attributes
static LPCWSTR	WMI_XML_TOSUBCLASS	= L"toSubclass";
static int		WMI_XML_TOSUBCLASS_LEN = 10;
static LPCWSTR	WMI_XML_TOINSTANCE	= L"toInstance";
static int		WMI_XML_TOINSTANCE_LEN = 10;
static LPCWSTR	WMI_XML_OVERRIDABLE = L"overridable";
static int		WMI_XML_OVERRIDABLE_LEN = 11;
static LPCWSTR	WMI_XML_AMENDED		= L"amended";
static int		WMI_XML_AMENDED_LEN = 7;
static LPCWSTR	WMI_XML_ARRAY		= L"array";
static int		WMI_XML_ARRAY_LEN	= 5;


CWmiDeserializer::CWmiDeserializer(IWbemServices *pServices) : 
		 m_cRef (1),
		 m_bIsClass (FALSE)
{
	m_pIWbemServices = pServices;
	m_pIWbemServices->AddRef();

	m_pIWbemClassObject = NULL;
	m_strSuperClassName = m_strClassName = m_strPropertyName = m_strMethodName = m_strQualifierName = NULL;

	m_pObjectQualifierSet = NULL;
	m_pPropertyQualifierSet = NULL;
	m_pMethodQualifierSet = NULL;

	m_iParserState = INVALID;
}

CWmiDeserializer::~CWmiDeserializer()
{
	m_pIWbemServices->Release();
	
	if(m_pIWbemClassObject)
		m_pIWbemClassObject->Release();
	if(m_pObjectQualifierSet)
		m_pObjectQualifierSet->Release();
	if(m_pPropertyQualifierSet)
		m_pPropertyQualifierSet->Release();
	if(m_pMethodQualifierSet)
		m_pMethodQualifierSet->Release();

	SysFreeString(m_strSuperClassName);
	SysFreeString(m_strClassName);
	SysFreeString(m_strPropertyName);
	SysFreeString(m_strMethodName);
	SysFreeString(m_strQualifierName);
}

STDMETHODIMP CWmiDeserializer::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (__uuidof(ISAXContentHandler)==riid)
		*ppv = (ISAXContentHandler *)this;
	else if (__uuidof(ISAXErrorHandler)==riid)
		*ppv = (ISAXErrorHandler *)this;
	else if (__uuidof(ISAXLexicalHandler)==riid)
		*ppv = (ISAXLexicalHandler *)this;
		
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiDeserializer::AddRef(void)
{
	InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWmiDeserializer::Release(void)
{
	LONG cRef = InterlockedDecrement(&m_cRef);

    if (0L!=cRef)
        return cRef;

    delete this;
    return 0;
}

HRESULT STDMETHODCALLTYPE CWmiDeserializer::Deserialize (
		BOOL bIsClass, 
		IWbemServices *pIWbemServices, 
		IWbemClassObject **ppIWbemClassObject)
{
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CWmiDeserializer::startDocument()
{
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CWmiDeserializer::endDocument ( )
{
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CWmiDeserializer::startElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	HRESULT result = E_FAIL;

	// A Complex Type
	if (0 == wcscmp(WMI_XML_COMPLEX_TYPE, pwchLocalName))
	{
		// We need to get the name of the class and the superclass
		if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_NAME, WMI_XML_NAME_LEN, &m_strClassName)))
		{
			// Get a superclass if any. This is an optional attribute
			GetAttributeValue(pAttributes, WMI_XML_BASE, WMI_XML_BASE_LEN, &m_strSuperClassName);

			// Get an IWbemClassObject that corresponds to the super class or is an empty class
			IWbemClassObject *pSuperClass = NULL;
			if(SUCCEEDED(result = m_pIWbemServices->GetObject(m_strSuperClassName, 0, NULL, &pSuperClass, NULL)))
			{
				result = pSuperClass->SpawnDerivedClass(0, &m_pIWbemClassObject);
				pSuperClass->Release();
			}
		}
	}
	// AppInfo Section - This usually comes before the Properties
	// We have certain important pieces of information in the AppInfo section including:
	// 1. Property Qualifiers
	// 2. Property default values
	// 3. Object Qualifiers
	// However, the actual property types come only in the body of the complex type.
	// Since we're using SAX, we need to store the AppInfo section information somewhere until
	// we get the property type. We can use a hash table, but the method adopted here
	// is to use the IWbemClassObject itself as a bag of properties. Until we actually get the
	// property type from the Properties section, we assume that the type of the property is
	// VT_BSTR

	// A property or or method object qualifier
	else if (0 == wcscmp(WMI_XML_QUALIFIER, pwchLocalName))
	{
		if(m_pIWbemClassObject)
		{
			// Convert the XML Qualifier attributes to a WMI Qualifier
			//===========================================================
			BSTR strName = NULL;
			VARIANT vValue;
			VariantInit(&vValue);
			LONG lFlavor = 0;
			if(SUCCEEDED(result = ConvertQualifierToWMI(pAttributes, &strName, &vValue, lFlavor)))
			{
				// Is it a Property qualifier?
				if(m_iParserState == APPINFO_PROPERTY)
				{
					// Get a Qualifier Set for the property, if we dont already have one
					if(!m_pPropertyQualifierSet)
						result = m_pIWbemClassObject->GetPropertyQualifierSet(m_strPropertyName, &m_pPropertyQualifierSet);

					if(SUCCEEDED(result))
						result = m_pPropertyQualifierSet->Put(strName, &vValue, lFlavor);
				}
				// Is it a Method qualifier?
				if(m_iParserState == APPINFO_METHOD)
				{
					// Get a Qualifier Set for the property, if we dont already have one
					if(!m_pMethodQualifierSet)
						result = m_pIWbemClassObject->GetMethodQualifierSet(m_strMethodName, &m_pMethodQualifierSet);

					if(SUCCEEDED(result))
						result = m_pMethodQualifierSet->Put(strName, &vValue, lFlavor);
				}
				else // It is an object qualifier
				{
					// Get a Qualifier Set for the object, if we dont already have one
					if(!m_pObjectQualifierSet)
						result = m_pIWbemClassObject->GetQualifierSet(&m_pObjectQualifierSet);

					if(SUCCEEDED(result))
						result = m_pObjectQualifierSet->Put(strName, &vValue, lFlavor);
				}

				SysFreeString(strName);
				VariantClear(&vValue);
				// No need to release the qualifier set since we will most likely need it for
				// adding another qualifier

			}
		}
	}
	// A Property
	else if (0 == wcscmp(WMI_XML_PROPERTY, pwchLocalName))
	{
		if(m_pIWbemClassObject)
		{

			m_iParserState = APPINFO_PROPERTY;

			// Create a property of type VT_BSTR provisonally in the object, 
			// so that we can get the qualifier set

			// Free any existing data in our temporary variables
			SysFreeString(m_strPropertyName);
			m_strPropertyName = NULL;

			// Get the name of the property
			if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_NAME, WMI_XML_NAME_LEN, &m_strPropertyName)))
			{
				if(SUCCEEDED(result = m_pIWbemClassObject->Put(m_strPropertyName, 0, NULL, CIM_STRING)))
				{
					// Release any Qualifier Set currently being held 
					if(m_pPropertyQualifierSet)
					{
						m_pPropertyQualifierSet->Release();
						m_pPropertyQualifierSet = NULL;
					}
				}
			}
		}
	}	
	// A Method
	else if (0 == wcscmp(WMI_XML_METHOD, pwchLocalName))
	{
		if(m_pIWbemClassObject)
		{

			m_iParserState = APPINFO_METHOD;

			// Create a Method of type "void f()" provisonally in the object, 
			// so that we can get the qualifier set

			// Free any existing data in our temporary variables
			SysFreeString(m_strMethodName);
			m_strMethodName = NULL;

			// Get the name of the property
			if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_NAME, WMI_XML_NAME_LEN, &m_strMethodName)))
			{
				if(SUCCEEDED(result = m_pIWbemClassObject->PutMethod(m_strMethodName, 0, NULL, NULL)))
				{
					// Release any Qualifier Set currently being held 
					if(m_pMethodQualifierSet)
					{
						m_pMethodQualifierSet->Release();
						m_pMethodQualifierSet = NULL;
					}
				}
			}
		}
	}	
	// Properties in the body of the complex type
	else if (0 == wcscmp(WMI_XML_ELEMENT, pwchLocalName))
	{
		if(m_pIWbemClassObject)
		{
			m_iParserState = BODY_ELEMENT;
			// Get the Name of the property
			BSTR strName = NULL;
			if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_NAME, WMI_XML_NAME_LEN, &strName)))
			{
				// Get the Type of the property
				BSTR strType = NULL;
				if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_TYPE, WMI_XML_TYPE_LEN, &strType)))
				{
					// Set the actual type of the property
					result = RectifyProperty(m_pIWbemClassObject, strName, strType);

					SysFreeString(strType);
				}
				SysFreeString(strName);
			}

		}
	}

	return result;
}

HRESULT CWmiDeserializer::GetAttributeValue(ISAXAttributes *pAttributes, 
						  LPCWSTR lpAttributeName, int iAttributeNameLen,
						  BSTR *pstrAttributeValue)
{
	HRESULT result = E_FAIL;

	int iAttributeIndex = 0;
	// Get the index of the attribute
	if(SUCCEEDED(result = pAttributes->getIndexFromName(NULL, 0, lpAttributeName, iAttributeNameLen, &iAttributeIndex)))
	{
		// Get the Value of the attribute
		int iAttributeValueLength = 0;
		LPCWSTR lpAttributeValue = NULL;
		if(SUCCEEDED(result = pAttributes->getValue(iAttributeIndex, &lpAttributeValue, &iAttributeValueLength)))
		{
			// Convert it to BSTR for returning
			if (*pstrAttributeValue = SysAllocStringLen(lpAttributeValue, iAttributeValueLength))
				result = S_OK;
			else
				result = E_OUTOFMEMORY;
		}
	}
	return result;
}


HRESULT STDMETHODCALLTYPE CWmiDeserializer::endElement (
        const wchar_t * pwchNamespaceUri,
        int cchNamespaceUri,
        const wchar_t * pwchLocalName,
        int cchLocalName,
        const wchar_t * pwchQName,
        int cchQName )
{
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CWmiDeserializer::characters (
        const unsigned short * pwchChars,
        int cchChars )
{
	return S_OK;
}

// A method to set the type of a property to the correct type
HRESULT CWmiDeserializer::RectifyProperty(IWbemClassObject *pIWbemClassObject, BSTR strName, BSTR strType)
{
	HRESULT result = E_FAIL;
	return result;
}

HRESULT CWmiDeserializer::ConvertQualifierToWMI(ISAXAttributes * pAttributes,
												 BSTR *pstrName,
												 VARIANT *pValue,
												 LONG& lQualifierFlavor)
{
	lQualifierFlavor = WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS; // The default
	HRESULT result = S_OK;

	// Get its Name, Type and Value - These are mandatory attributes
	//==============================================================
	pstrName = NULL;
	BSTR strType = NULL;
	BSTR strValue = NULL;
	BSTR strArray = NULL;
	bool bIsArray = false;

	if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_NAME, WMI_XML_NAME_LEN, pstrName)))
	{
		if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_TYPE, WMI_XML_TYPE_LEN, &strType)))
		{
			if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_VALUE, WMI_XML_VALUE_LEN, &strValue)))
			{
				// Now get the optional attributes
				// These are the qualifier flavors and the "array" attribute
				//============================================================
				BSTR strArray = NULL;
				if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_ARRAY, WMI_XML_ARRAY_LEN, &strArray)))
				{
					if(wcscmp(strArray, L"true") == 0)
						bIsArray = true;
					SysFreeString(strArray);
				}

				BSTR strFlavorValue = NULL;
				if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_TOSUBCLASS, WMI_XML_TOSUBCLASS_LEN, &strFlavorValue)))
				{
					if(wcscmp(strFlavorValue, L"false") == 0)
						lQualifierFlavor &= (~WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS); // Remove the default flag set
					SysFreeString(strFlavorValue);
				}
				if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_TOINSTANCE, WMI_XML_TOINSTANCE_LEN, &strFlavorValue)))
				{
					if(wcscmp(strFlavorValue, L"true") == 0)
						lQualifierFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE; 
					SysFreeString(strFlavorValue);
				}
				if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_OVERRIDABLE, WMI_XML_OVERRIDABLE_LEN, &strFlavorValue)))
				{
					if(wcscmp(strFlavorValue, L"true") == 0)
						lQualifierFlavor |= WBEM_FLAVOR_OVERRIDABLE; 
					SysFreeString(strFlavorValue);
				}
				if(SUCCEEDED(result = GetAttributeValue(pAttributes, WMI_XML_AMENDED, WMI_XML_AMENDED_LEN, &strFlavorValue)))
				{
					if(wcscmp(strFlavorValue, L"true") == 0)
						lQualifierFlavor |= WBEM_FLAVOR_AMENDED; 
					SysFreeString(strFlavorValue);
				}

				// Now convert the value of the Qualifier to a Variant
				result = ConvertQualifierValueToWMI(strType, bIsArray, strValue, pValue);
				SysFreeString(strValue);

			}
			else
				result = WBEM_E_INVALID_SYNTAX;
			SysFreeString(strType);
		}
		else
			result = WBEM_E_INVALID_SYNTAX;
	}
	else
		result = WBEM_E_INVALID_SYNTAX;
	return result;
}

HRESULT CWmiDeserializer::ConvertQualifierValueToWMI(BSTR strType, bool bIsArray, BSTR strValue, VARIANT *pValue)
{
	HRESULT result = WBEM_E_INVALID_SYNTAX;

	// Check if it is an array
	if(bIsArray)
		pValue->vt |= VT_ARRAY;

	// Qualifier values in WMI can be of 4 types
	//==========================================
	if(wcscmp(strType, L"boolean") == 0)
	{
		pValue->vt |= VT_BOOL;
		if(bIsArray)
			result = ConvertBooleanQualifierArray(pValue, strValue);
		else
		{
			if(wcscmp(strValue, L"true") == 0)
				pValue->boolVal = VARIANT_TRUE;
			else // Do I need to match the value to "false" ?
				pValue->boolVal = VARIANT_FALSE;
			result = S_OK;
		}
	}
	else if(wcscmp(strType, L"string") == 0)
	{
		pValue->vt |= VT_BSTR;
		if(bIsArray)
			result = ConvertStringQualifierArray(pValue, strValue);
		else
		{
			if(pValue->bstrVal = SysAllocString(strValue))
				result = S_OK;
			else
				result = E_OUTOFMEMORY;
		}
	}
	else if(wcscmp(strType, L"sint32") == 0)
	{
		if(bIsArray)
			result = ConvertSint32QualifierArray(pValue, strValue);
		else
		{
			pValue->vt |= VT_I4;
			pValue->lVal = wcstol (strValue, NULL, 0);
		}
	}
	else if(wcscmp(strType, L"real64") == 0)
	{
		if(bIsArray)
			result = ConvertReal64QualifierArray(pValue, strValue);
		else
		{
			pValue->vt |= VT_R8;
			pValue->dblVal = wcstod (strValue, NULL);	
		}
	}
	return result;
}

HRESULT CWmiDeserializer::ConvertBooleanQualifierArray(VARIANT *pValue, BSTR strValue)
{
	HRESULT result = WBEM_E_INVALID_SYNTAX;
	return result;
}

HRESULT CWmiDeserializer::ConvertStringQualifierArray(VARIANT *pValue, BSTR strValue)
{
	HRESULT result = WBEM_E_INVALID_SYNTAX;
	return result;
}

HRESULT CWmiDeserializer::ConvertSint32QualifierArray(VARIANT *pValue, BSTR strValue)
{
	HRESULT result = WBEM_E_INVALID_SYNTAX;
	return result;
}

HRESULT CWmiDeserializer::ConvertReal64QualifierArray(VARIANT *pValue, BSTR strValue)
{
	HRESULT result = WBEM_E_INVALID_SYNTAX;
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\httptrns.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  HTTPTRNS.CPP
//
//  alanbos  31-Oct-00   Created.
//
//  HTTP transport endpoint implementation.  
//
//***************************************************************************

#include "precomp.h"

static char *clientSOAPFault =
		"<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">"
		"<Body>"
		"<Fault>"
		"<faultcode>Client</faultcode>"
		"<faultstring>Unsupported request</faultstring>"
		"</Fault>"
		"</Body>"
		"</Envelope>";

static char *serverSOAPFault =
		"<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">"
		"<Body>"
		"<Fault>"
		"<faultcode>Server</faultcode>"
		"<faultstring>Server error</faultstring>"
		"</Fault>"
		"</Body>"
		"</Envelope>";

#define WMISOAP_EX_HEADER				"Ext:\r\nCache-Control: no-cache=\"Ext\"\r\n"
#define WMISOAP_CONTENTTYPE_HEADER		"Content-Type: text/xml; charset=utf-8\r\n"
#define WMISOAP_HEADER_TERMINATE		"\r\n"

bool HTTPTransport::IsValidEncapsulation () 
{
	bool result = false;

	if (IsXMLText ())
	{
		if (IsSOAPActionOK ())
		{
			if (AllMandatoryHeadersUnderstood ())
			{
				result = true;
			}
			else
				SendStatus ("510 Not Extended", false);
		}
		else
			SendSOAPError ();
	}
	else 
		SendStatus ("406 Not Acceptable", false);
	
	return result;
}

bool HTTPTransport::IsXMLText () const
{
	bool result = false;
	CHAR szTempBuffer [1024];
	DWORD dwBufferSize = 1024;

	if (m_pECB && m_pECB->GetServerVariable (m_pECB->ConnID, "HTTP_CONTENT_TYPE", szTempBuffer, &dwBufferSize))
	{
		char *ptr = szTempBuffer;
		SKIPWS(ptr)
		
		int lenXmlText = strlen (HTTP_WMI_XMLTEXT);
		int len = strlen (ptr);

		if ((0 == strncmp (HTTP_WMI_XMLTEXT, ptr, lenXmlText))
			&& ((len == lenXmlText) ||
				(ptr [lenXmlText] == ' ') ||
				(ptr [lenXmlText] == ';')))
			result = true;
	}

	return result;
}

bool HTTPTransport::IsMPost () const
{
	return (m_pECB && m_pECB->lpszMethod && (0 == strcmp(m_pECB->lpszMethod, HTTP_M_POST)));
}

bool HTTPTransport::GetQueryString (CComBSTR & bsQueryString) const
{
	bool result = false;

	if (m_pECB)
	{
		CHAR szTempBuffer [1024];
		DWORD dwBufferSize = 1024;
		
		if (m_pECB->GetServerVariable (m_pECB->ConnID, "QUERY_STRING", szTempBuffer, &dwBufferSize))
		{
			wchar_t *pwcsQueryString = new wchar_t [dwBufferSize];
			
			if (pwcsQueryString)
			{
				pwcsQueryString [dwBufferSize-1] = NULL;
			
				if ((dwBufferSize-1) == mbstowcs (pwcsQueryString, szTempBuffer, dwBufferSize-1))
				{
					bsQueryString = pwcsQueryString;
					result = true;
				}

				delete [] pwcsQueryString;
				pwcsQueryString = NULL;
			}
		}	
		else if (ERROR_INSUFFICIENT_BUFFER == GetLastError ())
		{
			char *pszTempBuffer = new char [dwBufferSize + 1];

			if (pszTempBuffer)
			{
				if (m_pECB->GetServerVariable (m_pECB->ConnID, "QUERY_STRING", pszTempBuffer, &dwBufferSize))
				{
					wchar_t *pwcsQueryString = new wchar_t [dwBufferSize];
			
					if (pwcsQueryString)
					{
						pwcsQueryString [dwBufferSize-1] = NULL;
					
						if (dwBufferSize-1 == mbstowcs (pwcsQueryString, pszTempBuffer, dwBufferSize-1))
						{
							bsQueryString = pwcsQueryString;
							result = true;
						}

						delete [] pwcsQueryString;
						pwcsQueryString = NULL;
					}
				}

				delete [] pszTempBuffer;
				pszTempBuffer = NULL;
			}
		}
	}

	return result;
}

bool HTTPTransport::IsSOAPActionOK () const
{
	bool result = false;

	if (m_pECB && m_pSOAPAction)
	{
		DWORD dwSOAPNs = 0;
		CHAR szTempBuffer [1024];
		DWORD dwBufferSize = 1024;
		bool bIsMpost = IsMPost();

		if (bIsMpost)
		{
			// Get the ns identifier for the SOAP extension header
			if (m_pECB->GetServerVariable (m_pECB->ConnID, "HTTP_MAN", szTempBuffer, &dwBufferSize))
				CheckManHeader(szTempBuffer, HTTP_SOAP_MAN_HEADER, dwSOAPNs);
		}

		// Get the SOAPAction header
		dwBufferSize = 1024;
		LPSTR pSOAPAction = GetExtensionHeader (HTTP_SOAP_ACTION, bIsMpost, dwSOAPNs);

		if (pSOAPAction)
		{
			if (m_pECB->GetServerVariable (m_pECB->ConnID, pSOAPAction, szTempBuffer, &dwBufferSize))
			{
				// Is it what we expect?
				if (0 == strcmp (m_pSOAPAction, szTempBuffer))
					result = true;
			}

			delete pSOAPAction;
		}
	}

	return result;
}

bool HTTPTransport::AllMandatoryHeadersUnderstood () const
{
	bool result = false;

	if (IsMPost ())
	{
		// TODO - look for anything other than the SOAP header
	}
	else
	{
		// A NO-OP - can't have mandatory headers in a POST
		result = true;
	}

	return result;
}

LPSTR HTTPTransport::GetExtensionHeader (LPCSTR pszName, bool bIsMpost, DWORD dwNs)
{
	LPSTR pszHeader = NULL;
	if (bIsMpost)
	{
		if(pszHeader = new char [strlen("HTTP") + strlen(pszName) + 4])
			sprintf (pszHeader, "%s_%02d_%s", "HTTP", dwNs, pszName);
	}
	else
	{
		if(pszHeader = new char [strlen("HTTP") + strlen (pszName) + 2])
			sprintf (pszHeader, "%s_%s", "HTTP", pszName);
	}
	return pszHeader;
}

bool HTTPTransport::CheckManHeader (
	LPCSTR pszReceivedManHeader,
	LPCSTR pszRequiredManHeader,
	DWORD &dwNs
)
{
	bool result = false;
	LPCSTR ptr = NULL;

	// Get the location of the Man header in the string
	if (ptr = strstr(pszReceivedManHeader, pszRequiredManHeader))
	{
		// Look for the "; ns=XX" string
		SKIPWS(ptr)

		if (ptr && (ptr = strchr (ptr, ';')) && *(++ptr))
		{
			SKIPWS(ptr)

			if (ptr && (0 == _strnicmp (ptr, HTTP_NS, strlen (HTTP_NS))))
			{
				// Now we should find ourselves a NS value
				ptr += strlen (HTTP_NS);

				if (ptr)
				{
					dwNs = strtol (ptr, NULL, 0);
					result = TRUE;
				}
			}
		}
	}

	return result;
}

bool HTTPTransport::SendServerStatus (bool ok) const
{
	return (ok) ? SendStatus ("200 OK") : SendStatus ("500 Internal Server Error");
}

bool HTTPTransport::SendStatus (LPCSTR pError, bool bWithContent) const
{
	bool status = false;

	if (m_pECB)
	{
		HSE_SEND_HEADER_EX_INFO HeaderExInfo;
		HeaderExInfo.pszStatus = pError;
		HeaderExInfo.cchStatus = strlen( HeaderExInfo.pszStatus );
		HeaderExInfo.pszHeader = NULL;

		
		// For M-POST we must send back the Ext header
		if (IsMPost())
		{
			if (bWithContent)
				HeaderExInfo.pszHeader = WMISOAP_EX_HEADER
										 WMISOAP_CONTENTTYPE_HEADER
										 WMISOAP_HEADER_TERMINATE ;
			else
				HeaderExInfo.pszHeader = WMISOAP_EX_HEADER
										 WMISOAP_HEADER_TERMINATE ;
		}
		else
		{
			if (bWithContent)
				HeaderExInfo.pszHeader = WMISOAP_CONTENTTYPE_HEADER
										 WMISOAP_HEADER_TERMINATE ;
		}
			

		HeaderExInfo.cchHeader = (HeaderExInfo.pszHeader) ? strlen( HeaderExInfo.pszHeader ) : 0;
		HeaderExInfo.fKeepConn = FALSE;

		status = (TRUE == m_pECB->ServerSupportFunction(
			m_pECB->ConnID,
			HSE_REQ_SEND_RESPONSE_HEADER_EX,
			&HeaderExInfo,
			NULL,
			NULL));
	}

	return status;
}

// Used to signal a "standard" SOAP error
bool HTTPTransport::SendSOAPError (bool bIsClientError) const
{
	bool status = SendStatus ("500 Internal Server Error");

	if (status)
	{
		if (m_pECB)
		{
			if (bIsClientError)
			{
				DWORD dwBuffSize = strlen (clientSOAPFault);
				status = (TRUE == m_pECB->WriteClient(
										m_pECB->ConnID, 
										clientSOAPFault, 
										&dwBuffSize, 
										HSE_IO_SYNC));
			}
			else
			{
				DWORD dwBuffSize = strlen (serverSOAPFault);
				status = (TRUE == m_pECB->WriteClient(
										m_pECB->ConnID, 
										serverSOAPFault, 
										&dwBuffSize, 
										HSE_IO_SYNC));
			}
		}
		else
			status = false;		// Shouldn't happen, but...
	}

	return status;
}

// Used to signal abnormal termination of the response
bool HTTPTransport::AbortResponse (void) const
{
	bool status = false;

	if (m_pECB)
	{
		status = (TRUE == m_pECB->ServerSupportFunction (
										m_pECB->ConnID,
										HSE_REQ_ABORTIVE_CLOSE,
										NULL,
										NULL,
										NULL));
	}

	return status;
}

HRESULT	HTTPTransport::GetRootXMLNamespace (
	CComBSTR & bsNamespace,
	bool bStripQuery) const
{
	HRESULT hr = E_FAIL;

	if (m_pECB)
	{
		CHAR szTempBuffer [1024];
		DWORD dwBufferSize = 1024;

		// Build the HTTP URL
		bsNamespace = L"http";

		// Secure HTTP??
		if (m_pECB->GetServerVariable (m_pECB->ConnID, "HTTP_SERVER_PORT_SECURE", szTempBuffer, &dwBufferSize)
				&& (0 < dwBufferSize))
		{
			// Secure port?
			if (0 == strcmp ("1", szTempBuffer))
				bsNamespace += L"s";
		}

		dwBufferSize = 1024;
		bsNamespace += L"://";

		// Hostname - this had better be there
		if (m_pECB->GetServerVariable (m_pECB->ConnID, "HTTP_HOST", szTempBuffer, &dwBufferSize)
				&& (0 < dwBufferSize))
		{
			wchar_t *pwHostString = new wchar_t [dwBufferSize];
			pwHostString [dwBufferSize-1] = NULL;
			
			if (dwBufferSize-1 == mbstowcs (pwHostString, szTempBuffer, dwBufferSize-1))
			{
				bsNamespace += pwHostString;
				dwBufferSize = 1024;

				// Server port?
				if (m_pECB->GetServerVariable (m_pECB->ConnID, "HTTP_SERVER_PORT", szTempBuffer, &dwBufferSize)
							&& (0 < dwBufferSize))
				{
					wchar_t *pwPortString = new wchar_t [dwBufferSize];

					if (dwBufferSize-1 == mbstowcs (pwPortString, szTempBuffer, dwBufferSize-1))
					{
						bsNamespace += L":";
						bsNamespace += pwPortString;
					}
				}

				dwBufferSize = 1024;

				// URL - this must be there
				if (m_pECB->GetServerVariable (m_pECB->ConnID, "HTTP_URL", szTempBuffer, &dwBufferSize) 
							&& (0 < dwBufferSize))
				{
					if (bStripQuery)
					{
						char *ptr = NULL;
						
						if (ptr = strchr (szTempBuffer, '?'))
						{
							*ptr = NULL;
							dwBufferSize = strlen (szTempBuffer) + 1;
						}
					}

					wchar_t *pwURLString = new wchar_t [dwBufferSize];
					pwURLString [dwBufferSize-1] = NULL;
					
					if (dwBufferSize-1 == mbstowcs (pwURLString, szTempBuffer, dwBufferSize-1))
					{
						bsNamespace += pwURLString;
						hr = S_OK;
					}

					delete [] pwURLString;
				}
			}

			delete [] pwHostString;
		}
	}

	return hr;
}

/****************************************************************************
 *
 * HTTPTransport::HTTPTransportRequestStream
 *
 ****************************************************************************/

STDMETHODIMP HTTPTransport::HTTPTransportRequestStream::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IStream==riid)
		*ppv = (IStream *)this;
	else if (IID_ISequentialStream==riid)
		*ppv = (ISequentialStream *)this;
	
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) HTTPTransport::HTTPTransportRequestStream::AddRef(void)
{
	InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) HTTPTransport::HTTPTransportRequestStream::Release(void)
{
	LONG cRef = InterlockedDecrement(&m_cRef);

    if (0L!=cRef)
        return cRef;

    delete this;
    return 0;
}


HRESULT HTTPTransport::HTTPTransportRequestStream::Read(void *pv,ULONG cb,ULONG *pcbRead)
{	
	HRESULT status = S_FALSE;

	if (m_pECB && pv)
	{
		long numRead = 0;

		if (!m_finishedReading)
		{
			if (m_readingFirstBuffer) // Are we still reading from the first block?
			{
				// Can we get it all from here?
				if (m_bytesRead + cb <= m_pECB->cbAvailable)
				{
					numRead = cb;
					memcpy (pv, (m_pECB->lpbData) + m_bytesRead, numRead);
					m_bytesRead += numRead;

					// Check if we have exhausted the first buffer now
					if (m_bytesRead == m_pECB->cbAvailable)
						m_readingFirstBuffer = false;
				}
				else if (m_bytesRead < m_pECB->cbAvailable)
				{
					// We can get some from what's left in the first buffer
					numRead = m_pECB->cbAvailable - m_bytesRead;
					memcpy (pv, (m_pECB->lpbData) + m_bytesRead, numRead);
					byte *pb = (byte*)pv;
					pb += numRead;
					pv = pb;
					m_bytesRead = m_pECB->cbAvailable;
					m_readingFirstBuffer = false;

					// Now we have (cb - numRead) to still try and read
					if (m_bytesRead < m_pECB->cbTotalBytes)
					{
						ReadFromBuffer (numRead, pv, cb - numRead);
					}
					else
					{
						// We are done
						m_finishedReading = true;
					}
				}
			}
			else if (m_bytesRead < m_pECB->cbTotalBytes)
			{
				ReadFromBuffer (numRead, pv, cb);
			}
			else
				m_finishedReading = true;
		}

		if (pcbRead)
			*pcbRead = numRead;

		if (0 < numRead)
			status = S_OK;
	}

	return status;
}

void HTTPTransport::HTTPTransportRequestStream::ReadFromBuffer (long & numRead, void *pv, ULONG cb)
{
	DWORD dwBufSiz = cb - numRead;

	if (0 < dwBufSiz)
	{
		while (m_pECB->ReadClient (m_pECB->ConnID, pv, &dwBufSiz))
		{
			if (0 == dwBufSiz)
			{
				// End of stream reached - flag it 
				m_finishedReading = true;
				break;
			} else {
				// Increment what we read
				m_bytesRead += dwBufSiz;
				numRead += dwBufSiz;
				byte *pb = (byte*)pv;
				pb += dwBufSiz;
				pv = pb;
			}

			if (m_bytesRead == m_pECB->cbTotalBytes)
			{
				// Have read all we can
				m_finishedReading = true;
			}

			// Reduce the number requested
			dwBufSiz = cb - numRead;

			// If this is now 0, break out
			if (0 == dwBufSiz)
			{
				m_finishedReading = true;
				break;
			}
		}
	}
}

HRESULT HTTPTransport::HTTPTransportRequestStream::Write(void const *pv,ULONG cb,ULONG *pcbWritten)
{
	HRESULT status = S_OK;

	if (0 < cb)
		status = STG_E_CANTSAVE;
	
	if (pcbWritten)
		*pcbWritten = 0;

	return status;
}

HRESULT HTTPTransport::HTTPTransportRequestStream::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
	// TODO
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportRequestStream::SetSize(ULARGE_INTEGER libNewSize)
{
	// TODO
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportRequestStream::CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten)
{
	// TODO
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportRequestStream::Commit(DWORD grfCommitFlags)
{
	// TODO
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportRequestStream::Revert(void)
{
	// TODO
	return S_OK;
}
	
HRESULT HTTPTransport::HTTPTransportRequestStream::LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return STG_E_INVALIDFUNCTION;
}

HRESULT HTTPTransport::HTTPTransportRequestStream::UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return STG_E_INVALIDFUNCTION;
}

HRESULT HTTPTransport::HTTPTransportRequestStream::Stat(STATSTG *pstatstg,DWORD grfStatFlag)
{
	// TODO
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportRequestStream::Clone(IStream **ppstm)
{
	return S_OK;
}


/****************************************************************************
 *
 * HTTPTransport::HTTPTransportResponseStream
 *
 ****************************************************************************/

STDMETHODIMP HTTPTransport::HTTPTransportResponseStream::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IStream==riid)
		*ppv = (IStream *)this;
	else if (IID_ISequentialStream==riid)
		*ppv = (ISequentialStream *)this;
	
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) HTTPTransport::HTTPTransportResponseStream::AddRef(void)
{
	InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) HTTPTransport::HTTPTransportResponseStream::Release(void)
{
	LONG cRef = InterlockedDecrement(&m_cRef);

    if (0L!=cRef)
        return cRef;

    delete this;
    return 0;
}


HRESULT HTTPTransport::HTTPTransportResponseStream::Read(void *pv,ULONG cb,ULONG *pcbRead)
{	
	return S_FALSE;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::Write(const void *pv,ULONG cb,ULONG *pcbWritten)
{
	HRESULT status = STG_E_CANTSAVE;

	if (pcbWritten)
		*pcbWritten = 0;

	if (m_pECB)
	{
		DWORD dwBytes = cb;

		if (m_pECB->WriteClient (m_pECB->ConnID, (void*)pv, &dwBytes, HSE_IO_SYNC))
		{
			if (pcbWritten)
				*pcbWritten = dwBytes;

			status = S_OK;
		} 
	}
	
	return status;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
	// TODO
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::SetSize(ULARGE_INTEGER libNewSize)
{
	// TODO
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten)
{
	// TODO
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::Commit(DWORD grfCommitFlags)
{
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::Revert(void)
{
	return S_OK;
}
	
HRESULT HTTPTransport::HTTPTransportResponseStream::LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return STG_E_INVALIDFUNCTION;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return STG_E_INVALIDFUNCTION;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::Stat(STATSTG *pstatstg,DWORD grfStatFlag)
{
	return S_OK;
}

HRESULT HTTPTransport::HTTPTransportResponseStream::Clone(IStream **ppstm)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opdelcs.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  OPDELCS.CPP
//
//  alanbos  07-Nov-00   Created.
//
//  WMI Delete Class operation implementation.  
//
//***************************************************************************

#include "precomp.h"

HRESULT WMIDeleteClassOperation::BeginRequest (
	CComPtr<IWbemServices> & pIWbemServices
)
{
	return pIWbemServices->DeleteClass (m_bsClassName, 0, GetContext(), NULL);
}

bool WMIDeleteClassOperation::ProcessElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	bool result = false;

	if (0 == wcscmp(WMI_DELETECLASS_PARAMETER_NAME, pwchLocalName))
	{
		// following content will be the value of the classname
		SetParseState (Name);
		result = true;
	}

	return result;
}

bool WMIDeleteClassOperation::ProcessContent (
        const unsigned short * pwchChars,
        int cchChars )
{
	if (Name == GetParseState ())
		m_bsClassName = SysAllocStringLen (pwchChars, cchChars);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opdelin.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  OPDELCS.CPP
//
//  alanbos  07-Nov-00   Created.
//
//  WMI Delete Class operation implementation.  
//
//***************************************************************************

#include "precomp.h"

static char *pStrResponse = "<DeleteInstanceResponse xmlns=\""
							WMI_SOAP_NS
							"\"/>";

HRESULT WMIDeleteInstanceOperation::BeginRequest (
	CComPtr<IWbemServices> & pIWbemServices
)
{
	return pIWbemServices->DeleteInstance (m_bsInstanceName, 0, GetContext(), NULL);
}

bool WMIDeleteInstanceOperation::ProcessElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	bool result = false;

	if (0 == wcscmp(WMI_DELETEINSTANCE_PARAMETER_NAME, pwchLocalName))
	{
		// following content will be the value of the classname
		SetParseState (Name);
		result = true;
	}

	return result;
}

bool WMIDeleteInstanceOperation::ProcessContent (
        const unsigned short * pwchChars,
        int cchChars )
{
	if (Name == GetParseState ())
		m_bsInstanceName = SysAllocStringLen (pwchChars, cchChars);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opdelcs.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  opdelcls.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the class for the WMI DeleteClass operation.
//
//***************************************************************************

#ifndef _OPDELCLS_H_
#define _OPDELCLS_H_

#define WMI_DELETECLASS_PARAMETER_NAME		L"ClassName"

//***************************************************************************
//
//  CLASS NAME:
//
//  WMIDeleteClassOperation
//
//  DESCRIPTION:
//
//  WMI DeleteClass Operation handler.
//
//***************************************************************************

class WMIDeleteClassOperation : public WMIOperation
{
private:
	CComBSTR				m_bsClassName;

	typedef enum DeleteClassParseState {
		Name = 1,				// Class element
	};

	// Overridden methods from WMIOperation
	HRESULT BeginRequest (CComPtr<IWbemServices> & pIWbemServices);
	
	bool ProcessElement (      
				const wchar_t __RPC_FAR *pwchNamespaceUri,
				int cchNamespaceUri,
				const wchar_t __RPC_FAR *pwchLocalName,
				int cchLocalName,
				const wchar_t __RPC_FAR *pwchRawName,
				int cchRawName,
				ISAXAttributes __RPC_FAR *pAttributes);

	bool ProcessContent (        
				const unsigned short * pwchChars,
				int cchChars );

	LPCSTR GetOperationResponseName (void)
	{
		return "DeleteClassResponse";
	}

	bool ResponseHasContent (void)
	{
		return false;
	}

public:
	WMIDeleteClassOperation (SOAPActor *pActor) : WMIOperation (pActor)  {}
	~WMIDeleteClassOperation () {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\objretvr.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  objretvr.h
//
//  alanbos  04-Dec-00   Created.
//
//  Defines the HTTP GET handler
//
//***************************************************************************

#ifndef _OBJRETVR_H_
#define _OBJRETVR_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  ObjectRetriever
//
//  DESCRIPTION:
//
//  ObjectRetriever implementation. 
//
//***************************************************************************

class ObjectRetriever 
{
private:
	LONG					m_cRef;
	CComPtr<IWbemPath>		m_pIWbemPath;
	HTTPTransport			&m_HTTPTransport;

	bool					IsClassPath ();
	bool					GetNamespacePath (CComBSTR & bsNamespacePath);
	bool					GetClassName (CComBSTR & bsClassName);

	HRESULT					EncodeAndSendClass (
								CComBSTR & bsNamespacePath,
								CComPtr<IWbemClassObject> & pIWbemClassObject
							);
	
public:
	ObjectRetriever(HTTPTransport &HTTPTransport);
	virtual ~ObjectRetriever();

	void Fetch (void);

	// IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opdelin.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  opdelcls.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the class for the WMI DeleteClass operation.
//
//***************************************************************************

#ifndef _OPDELIN_H_
#define _OPDELIN_H_

#define WMI_DELETEINSTANCE_PARAMETER_NAME		L"InstanceName"

//***************************************************************************
//
//  CLASS NAME:
//
//  WMIDeleteInstanceOperation
//
//  DESCRIPTION:
//
//  WMI DeleteClass Operation handler.
//
//***************************************************************************

class WMIDeleteInstanceOperation : public WMIOperation
{
private:
	CComBSTR				m_bsInstanceName;

	typedef enum DeleteInstanceParseState {
		Name = 1,				// Name element
	};

	// Overridden methods from WMIOperation
	HRESULT BeginRequest (CComPtr<IWbemServices> & pIWbemServices);
	
	bool ProcessElement (      
				const wchar_t __RPC_FAR *pwchNamespaceUri,
				int cchNamespaceUri,
				const wchar_t __RPC_FAR *pwchLocalName,
				int cchLocalName,
				const wchar_t __RPC_FAR *pwchRawName,
				int cchRawName,
				ISAXAttributes __RPC_FAR *pAttributes);

	bool ProcessContent (        
				const unsigned short * pwchChars,
				int cchChars );
	
	LPCSTR GetOperationResponseName (void)
	{
		return "DeleteInstanceResponse";
	}

	bool ResponseHasContent (void)
	{
		return false;
	}

public:
	WMIDeleteInstanceOperation (SOAPActor *pActor) : WMIOperation (pActor)  {}
	~WMIDeleteInstanceOperation () {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opexecqy.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  OPEXECQY.CPP
//
//  alanbos  07-Nov-00   Created.
//
//  WMI Exec Query operation implementation.  
//
//***************************************************************************

#include "precomp.h"

HRESULT WMIExecQueryOperation::BeginRequest (
	CComPtr<IWbemServices> & pIWbemServices
)
{
	HRESULT hr = WBEM_E_FAILED;
	LONG lFlags = WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY;

	if (m_bUseAmendedQualifiers)
		lFlags |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;

	if (m_bDirectRead)
		lFlags |= WBEM_FLAG_DIRECT_READ;

	if (m_bEnsureLocatable)
		lFlags |= WBEM_FLAG_ENSURE_LOCATABLE;

	if (m_bPrototype)
		lFlags |= WBEM_FLAG_PROTOTYPE;

	// Call the enumerator
	if (SUCCEEDED(hr = pIWbemServices->ExecQuery (
						m_bsQueryLanguage,
						m_bsQuery,
						lFlags, 
						GetContext(), 
						&m_pIEnumWbemClassObject)))
	{
		/*
		 * Get the first object - we do this as we are operating in semi-sync and some
		 * errors are only flagged on Next, not on ExecQuery.
		 */
		ULONG lReturned = 0;
		hr = m_pIEnumWbemClassObject->Next (WBEM_INFINITE, 1, &m_pFirstIWbemClassObject, &lReturned);

		if ((S_OK == hr) && (1 == lReturned))
			m_bIsEmptyResultsSet = false;
	}

	return hr;
}

HRESULT WMIExecQueryOperation::ProcessRequest (void)
{
	HRESULT hr = S_OK;
	
	// Start by checking if we have an initial object
	if (m_pFirstIWbemClassObject)
	{
		hr = EncodeAndSendObject (m_pFirstIWbemClassObject);
		m_pFirstIWbemClassObject.Release ();
	}

	// Now send the remainder
	if (SUCCEEDED(hr))
	{
		CComPtr<IWbemClassObject> pIWbemClassObject;
		ULONG lReturned = 0;

		while ((S_OK == (hr = m_pIEnumWbemClassObject->Next (WBEM_INFINITE, 1, &pIWbemClassObject, &lReturned)))
				&& (1 == lReturned))
		{
			if (FAILED(hr = EncodeAndSendObject (pIWbemClassObject)))
				break;

			lReturned = 0;
		}
	}

	return hr;
}

bool WMIExecQueryOperation::ProcessElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	bool result = false;

	if (0 == wcscmp(WMI_EXECQUERY_PARAMETER_QUERYLANGUAGE, pwchLocalName))
	{
		// following content will be the value of the object name
		SetParseState (QueryLanguage);
		result = true;
	}
	else if (0 == wcscmp(WMI_EXECQUERY_PARAMETER_QUERY, pwchLocalName))
	{
		// following content will be the value of UseAmendedQualifiers
		SetParseState (Query);
		result = true;
	}
	else if (0 == wcscmp(WMI_GETOBJECT_PARAMETER_USEAQ, pwchLocalName))
	{
		// following content will be the value of UseAmendedQualifiers
		SetParseState (UseAmendedQualifiers);
		result = true;
	}
	else if (0 == wcscmp(WMI_EXECQUERY_PARAMETER_DIRECTREAD, pwchLocalName))
	{
		// following content will be the value of DirectRead
		SetParseState (DirectRead);
		result = true;
	}
	else if (0 == wcscmp(WMI_EXECQUERY_PARAMETER_ENSURELOC, pwchLocalName))
	{
		// following content will be the value of DirectRead
		SetParseState (EnsureLocatable);
		result = true;
	}
	else if (0 == wcscmp(WMI_EXECQUERY_PARAMETER_PROTOTYPE, pwchLocalName))
	{
		// following content will be the value of DirectRead
		SetParseState (Prototype);
		result = true;
	}

	return result;
}

bool WMIExecQueryOperation::ProcessContent (
        const unsigned short * pwchChars,
        int cchChars )
{
	bool result = true;

	switch (GetParseState ())
	{
		case QueryLanguage:
			m_bsQueryLanguage = SysAllocStringLen (pwchChars, cchChars);
			break;

		case Query:
			m_bsQuery = SysAllocStringLen (pwchChars, cchChars);
			break;

		case UseAmendedQualifiers:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bUseAmendedQualifiers = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bUseAmendedQualifiers = false;
				else
					result = false;
			}
			break;

		case DirectRead:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bDirectRead = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bDirectRead = false;
				else
					result = false;
			}
			break;

		case EnsureLocatable:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bEnsureLocatable = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bEnsureLocatable = false;
				else
					result = false;
			}
			break;

		case Prototype:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bPrototype = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bPrototype = false;
				else
					result = false;
			}
			break;
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\objretvr.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  OBJRETVR.CPP
//
//  alanbos  04-Dec-00   Created.
//
//  HTTP GET handler implementation.  
//
//***************************************************************************

#include "precomp.h"
#define	PATH_VARIABLE L"path="

ObjectRetriever::ObjectRetriever(HTTPTransport &httpTransport) : 
		 m_cRef (1),
		 m_HTTPTransport (httpTransport)
{
	// Create our path parser object
	CoCreateInstance (CLSID_WbemDefPath, NULL,
					CLSCTX_INPROC_SERVER, IID_IWbemPath, (LPVOID*) &m_pIWbemPath);
}

ObjectRetriever::~ObjectRetriever()
{}

STDMETHODIMP ObjectRetriever::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
		
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) ObjectRetriever::AddRef(void)
{
	InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) ObjectRetriever::Release(void)
{
	LONG cRef = InterlockedDecrement(&m_cRef);

    if (0L!=cRef)
        return cRef;

    delete this;
    return 0;
}

void ObjectRetriever::Fetch (void)
{
	if (m_pIWbemPath)
	{
		// Get the query from the path
		CComBSTR bsQueryString;

		if (m_HTTPTransport.GetQueryString (bsQueryString) && bsQueryString)
		{
			// TODO - shouldn't assume that the path variable is at the front of the query
			if (0 == wcsncmp (bsQueryString, PATH_VARIABLE, wcslen (PATH_VARIABLE)))
			{
				HRESULT hr = WBEM_E_FAILED;

				// TODO - we need to 
				// (A) Consume only everything up to the next query variable
				// (B) URL-decode the path
				if (SUCCEEDED(hr= m_pIWbemPath->SetText (
							WBEMPATH_CREATE_ACCEPT_ALL,
							bsQueryString.m_str + wcslen(PATH_VARIABLE))))
				{
					if (IsClassPath ())
					{
						CComBSTR bsNamespacePath;
						CComBSTR bsClassName;

						if (GetNamespacePath (bsNamespacePath) && GetClassName (bsClassName))
						{
							WMIConnection wmiConn (bsNamespacePath, NULL);
							CComPtr<IWbemServices> pIWbemServices;
							wmiConn.GetIWbemServices (pIWbemServices);

							if (pIWbemServices)
							{
								CComPtr<IWbemClassObject> pIWbemClassObject;

								if (SUCCEEDED(hr = pIWbemServices->GetObject (bsClassName, 0, 
													NULL, &pIWbemClassObject, NULL)))
								{
									// We got it - now format a response
									m_HTTPTransport.SendStatus ("200 OK", true);
									hr = EncodeAndSendClass (bsNamespacePath, pIWbemClassObject);
								}
							}
							else
							{
								/*
								 * We do not encode WMI HRESULTs in the response - this
								 * could be a non-existent namespace or access denied, or
								 * some other error. Rather than reveal potentially
								 * interesting information to a casual intruder, we keep
								 * things terse.
								 */
								m_HTTPTransport.SendStatus ("500 Server Error", false);
							}
						}
						else
							m_HTTPTransport.SendStatus ("500 Server Error", false);
					}
					else
					{
						// Not a class path - we don't support anything else
						m_HTTPTransport.SendStatus ("400 Bad Request", false);
					}
				}
				else
				{
					// an invalid path
					m_HTTPTransport.SendStatus ("400 Bad Request", false);
				}
			}
			else
			{
				// Missing the path variable
				m_HTTPTransport.SendStatus ("400 Bad Request", false);
			}
		}
	}
	else
		m_HTTPTransport.SendStatus ("500 Server Error", false);
}

bool ObjectRetriever::IsClassPath ()
{
	bool result = false;

	if (m_pIWbemPath)
	{
		ULONGLONG uInfo;

		result = (SUCCEEDED(m_pIWbemPath->GetInfo (0, &uInfo)) &&
				  (WBEMPATH_INFO_IS_CLASS_REF & uInfo));
	}

	return result;
}

bool ObjectRetriever::GetNamespacePath (CComBSTR & bsNamespacePath)
{
	bool result = false;

	if (m_pIWbemPath)
	{
		ULONG lBuflen = 0;
		m_pIWbemPath->GetText (WBEMPATH_GET_NAMESPACE_ONLY, &lBuflen, NULL);

		if (lBuflen)
		{
			LPWSTR pszText = new wchar_t [lBuflen + 1];

			if (pszText)
			{
				pszText [lBuflen] = NULL;

				if (SUCCEEDED(m_pIWbemPath->GetText (WBEMPATH_GET_NAMESPACE_ONLY, &lBuflen, pszText)))
				{
					bsNamespacePath.Empty ();
					if (bsNamespacePath.m_str = SysAllocString (pszText))
						result = true;
				}

				delete [] pszText;
			}
		}
	}

	return result;
}

bool ObjectRetriever::GetClassName (CComBSTR & bsClassName)
{
	bool result = false;

	if (m_pIWbemPath)
	{
		ULONG lBuflen = 0;
		m_pIWbemPath->GetClassName (&lBuflen, NULL);

		if (lBuflen)
		{
			LPWSTR pszText = new wchar_t [lBuflen + 1];

			if (pszText)
			{
				pszText [lBuflen] = NULL;

				if (SUCCEEDED(m_pIWbemPath->GetClassName (&lBuflen, pszText)))
				{
					bsClassName.Empty ();
					if (bsClassName.m_str = SysAllocString (pszText))
						result = true;
				}

				delete [] pszText;
			}
		}
	}

	return result;
}
		
HRESULT ObjectRetriever::EncodeAndSendClass (
	CComBSTR & bsWmiNamespace,
	CComPtr<IWbemClassObject> & pIWbemClassObject
)
{
	HRESULT hr = WBEM_E_FAILED;
	CComPtr<IWMIXMLConverter> pIWMIXMLConverter;

	if (SUCCEEDED(hr = CoCreateInstance(
			CLSID_WMIXMLConverter,
			NULL, 
			CLSCTX_INPROC_SERVER ,
			IID_IWMIXMLConverter,
			(void **)&pIWMIXMLConverter)))
	{
		CComPtr<IStream> pIResponseStream;
		m_HTTPTransport.GetResponseStream (pIResponseStream);

		if (pIResponseStream)
		{
			// Get the XML Schema target namespace for this WMI class
			CComBSTR bsRootXMLNamespace;
			m_HTTPTransport.GetRootXMLNamespace(bsRootXMLNamespace, true);

			if (bsRootXMLNamespace)
			{
				CWmiURI	wmiURI (bsRootXMLNamespace, bsWmiNamespace);
				CComBSTR bsXMLNamespace;

				if (wmiURI.GetURIForNamespace (bsXMLNamespace))
				{
					if (SUCCEEDED(hr = pIWMIXMLConverter->SetXMLNamespace (
						bsXMLNamespace, 
						NULL)))
					{
						CComVariant varValue;

						// Set schemaLocation values for include of SUPERCLASS
						if (SUCCEEDED(pIWbemClassObject->Get (L"__SUPERCLASS", 0, &varValue, NULL, NULL)) &&
										(VT_BSTR == varValue.vt) && (NULL != varValue.bstrVal))
						{
							CComBSTR bsXMLNamespace;
							BSTR strSchemaLoc[1];
							
							if (wmiURI.GetURIForClass (varValue.bstrVal, bsXMLNamespace))
							{
								// Note this string will be freed by the destructor of CComBSTR
								strSchemaLoc[0] = bsXMLNamespace.m_str;
						
								if (SUCCEEDED(hr = pIWMIXMLConverter->SetSchemaLocations (1, strSchemaLoc)))
								{
									hr = pIWMIXMLConverter->GetXMLForObject (
														pIWbemClassObject, 0, pIResponseStream);
								}
							}
						}
					}
				}
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opgetcl.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  opdelcls.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the class for the WMI GetClasses operation.
//
//***************************************************************************

#ifndef _OPGETCL_H_
#define _OPGETCL_H_

#define WMI_GETCLASSES_PARAMETER_BASIS		L"ClassBasis"
#define WMI_GETCLASSES_PARAMETER_USEAQ		L"UseAmendedQualifiers"
#define WMI_GETCLASSES_PARAMETER_DEEP		L"Deep"

//***************************************************************************
//
//  CLASS NAME:
//
//  WMIDeleteClassOperation
//
//  DESCRIPTION:
//
//  WMI DeleteClass Operation handler.
//
//***************************************************************************

class WMIGetClassesOperation : public WMIEncodingOperation
{
private:
	CComBSTR					m_bsClassBasis;
	bool						m_bUseAmendedQualifiers;
	bool						m_bDeep;
	bool						m_bIsEmptyResultsSet;

	CComPtr<IEnumWbemClassObject>	m_pIEnumWbemClassObject;
	CComPtr<IWbemClassObject>		m_pFirstIWbemClassObject;

	typedef enum GetClassesParseState {
		ClassBasis = 1,				
		UseAmendedQualifiers,
		Deep
	};

	// Overridden methods from WMIOperation
	HRESULT	BeginRequest (CComPtr<IWbemServices> & pIWbemServices);
	HRESULT	ProcessRequest (void);
	
	bool	ProcessElement (      
				const wchar_t __RPC_FAR *pwchNamespaceUri,
				int cchNamespaceUri,
				const wchar_t __RPC_FAR *pwchLocalName,
				int cchLocalName,
				const wchar_t __RPC_FAR *pwchRawName,
				int cchRawName,
				ISAXAttributes __RPC_FAR *pAttributes);

	bool	ProcessContent (        
				const unsigned short * pwchChars,
				int cchChars );

	bool	ResponseHasContent (void)
	{
		return !m_bIsEmptyResultsSet;
	}

public:
	WMIGetClassesOperation (SOAPActor *pActor) : 
		WMIEncodingOperation (pActor),
		m_bUseAmendedQualifiers (true),
		m_bDeep (true),
		m_bIsEmptyResultsSet (true) {}
	~WMIGetClassesOperation () {}

	// Overridden from WMIOperation
	LPCSTR GetOperationResponseName (void)
	{
		return "GetClassesResponse";
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opexecqy.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  opexecqy.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the class for the WMI ExecQuery operation.
//
//***************************************************************************

#ifndef _OPEXECQY_H_
#define _OPEXECQY_H_

#define WMI_EXECQUERY_PARAMETER_QUERYLANGUAGE	L"QueryLanguage"
#define WMI_EXECQUERY_PARAMETER_QUERY			L"Query"
#define WMI_EXECQUERY_PARAMETER_USEAQ			L"UseAmendedQualifiers"
#define WMI_EXECQUERY_PARAMETER_DIRECTREAD		L"DirectRead"
#define WMI_EXECQUERY_PARAMETER_ENSURELOC		L"EnsureLocatable"
#define WMI_EXECQUERY_PARAMETER_PROTOTYPE		L"Prototype"

//***************************************************************************
//
//  CLASS NAME:
//
//  WMIExecQueryOperation
//
//  DESCRIPTION:
//
//  WMI ExecQuery Operation handler.
//
//***************************************************************************

class WMIExecQueryOperation : public WMIEncodingOperation
{
private:
	CComBSTR					m_bsQueryLanguage;
	CComBSTR					m_bsQuery;
	bool						m_bUseAmendedQualifiers;
	bool						m_bDirectRead;
	bool						m_bEnsureLocatable;
	bool						m_bPrototype;
	bool						m_bIsEmptyResultsSet;

	CComPtr<IEnumWbemClassObject>	m_pIEnumWbemClassObject;
	CComPtr<IWbemClassObject>		m_pFirstIWbemClassObject;

	typedef enum ExecQueryParseState {
		QueryLanguage = 1,				
		Query,
		UseAmendedQualifiers,
		DirectRead,
		EnsureLocatable,
		Prototype
	};

	// Overridden methods from WMIOperation
	HRESULT BeginRequest (CComPtr<IWbemServices> & pIWbemServices);
	HRESULT	ProcessRequest (void);
	
	bool ProcessElement (      
				const wchar_t __RPC_FAR *pwchNamespaceUri,
				int cchNamespaceUri,
				const wchar_t __RPC_FAR *pwchLocalName,
				int cchLocalName,
				const wchar_t __RPC_FAR *pwchRawName,
				int cchRawName,
				ISAXAttributes __RPC_FAR *pAttributes);

	bool ProcessContent (        
				const unsigned short * pwchChars,
				int cchChars );

	LPCSTR GetOperationResponseName (void)
	{
		return "ExecQueryResponse";
	}

	bool	ResponseHasContent (void)
	{
		return !m_bIsEmptyResultsSet;
	}

public:
	WMIExecQueryOperation (SOAPActor *pActor) : 
		WMIEncodingOperation (pActor),
		m_bsQueryLanguage (L"WQL"),
		m_bUseAmendedQualifiers (true),
		m_bDirectRead (false),
		m_bEnsureLocatable (false),
		m_bPrototype (false),
		m_bIsEmptyResultsSet (true) {}
	~WMIExecQueryOperation () {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opgetcl.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  OPDELCS.CPP
//
//  alanbos  07-Nov-00   Created.
//
//  WMI Get Classes operation implementation.  
//
//***************************************************************************

#include "precomp.h"

HRESULT WMIGetClassesOperation::BeginRequest (
	CComPtr<IWbemServices> & pIWbemServices
)
{
	HRESULT hr = WBEM_E_FAILED;
	LONG lFlags = WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY;

	if (m_bUseAmendedQualifiers)
		lFlags |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;

	if (!m_bDeep)
		lFlags |= WBEM_FLAG_SHALLOW;

	// Call the enumerator
	if (SUCCEEDED(hr = pIWbemServices->CreateClassEnum (
					m_bsClassBasis, 
					lFlags, 
					GetContext(), 
					&m_pIEnumWbemClassObject)))
	{
		/*
		 * Get the first object - we do this as we are operating in semi-sync and some
		 * errors are only flagged on Next, not on CreateClassEnum.
		 */
		ULONG lReturned = 0;
		hr = m_pIEnumWbemClassObject->Next (WBEM_INFINITE, 1, &m_pFirstIWbemClassObject, &lReturned);

		if ((S_OK == hr) && (1 == lReturned))
			m_bIsEmptyResultsSet = false;
	}

	return hr;
}

HRESULT WMIGetClassesOperation::ProcessRequest (void)
{
	HRESULT hr = S_OK;
	
	// Start by checking if we have an initial object
	if (m_pFirstIWbemClassObject)
	{
		hr = EncodeAndSendClass (m_pFirstIWbemClassObject);
		m_pFirstIWbemClassObject.Release ();
	}

	// Now send the remainder
	if (SUCCEEDED(hr))
	{
		CComPtr<IWbemClassObject> pIWbemClassObject;
		ULONG lReturned = 0;

		while ((S_OK == (hr = m_pIEnumWbemClassObject->Next (WBEM_INFINITE, 1, &pIWbemClassObject, &lReturned)))
				&& (1 == lReturned))
		{
			if (FAILED(hr = EncodeAndSendClass (pIWbemClassObject)))
				break;

			lReturned = 0;
		}
	}

	return hr;
}

			
bool WMIGetClassesOperation::ProcessElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	bool result = false;

	if (0 == wcscmp(WMI_GETCLASSES_PARAMETER_BASIS, pwchLocalName))
	{
		// following content will be the value of the object name
		SetParseState (ClassBasis);
		result = true;
	}
	else if (0 == wcscmp(WMI_GETOBJECT_PARAMETER_USEAQ, pwchLocalName))
	{
		// following content will be the value of UseAmendedQualifiers
		SetParseState (UseAmendedQualifiers);
		result = true;
	}
	else if (0 == wcscmp(WMI_GETCLASSES_PARAMETER_DEEP, pwchLocalName))
	{
		// following content will be the value of DirectRead
		SetParseState (Deep);
		result = true;
	}

	return result;
}

bool WMIGetClassesOperation::ProcessContent (
        const unsigned short * pwchChars,
        int cchChars )
{
	bool result = true;

	switch (GetParseState ())
	{
		case ClassBasis:
			m_bsClassBasis = SysAllocStringLen (pwchChars, cchChars);
			break;

		case UseAmendedQualifiers:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bUseAmendedQualifiers = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bUseAmendedQualifiers = false;
				else
					result = false;
			}
			break;

		case Deep:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bDeep = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bDeep = false;
				else
					result = false;
			}
			break;
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opgetin.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  opdelcls.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the class for the WMI GetInstances operation.
//
//***************************************************************************

#ifndef _OPGETIN_H_
#define _OPGETIN_H_

#define WMI_GETINSTANCES_PARAMETER_BASIS		L"ClassBasis"
#define WMI_GETINSTANCES_PARAMETER_USEAQ		L"UseAmendedQualifiers"
#define WMI_GETINSTANCES_PARAMETER_DIRECTREAD	L"DirectRead"
#define WMI_GETINSTANCES_PARAMETER_DEEP			L"Deep"

//***************************************************************************
//
//  CLASS NAME:
//
//  WMIGetInstancesOperation
//
//  DESCRIPTION:
//
//  WMI GetInstances Operation handler.
//
//***************************************************************************

class WMIGetInstancesOperation : public WMIEncodingOperation
{
private:
	CComBSTR					m_bsClassBasis;
	bool						m_bUseAmendedQualifiers;
	bool						m_bDirectRead;
	bool						m_bDeep;
	bool						m_bIsEmptyResultsSet;

	CComPtr<IEnumWbemClassObject>	m_pIEnumWbemClassObject;	
	CComPtr<IWbemClassObject>		m_pFirstIWbemClassObject;

	typedef enum GetInstancesParseState {
		ClassBasis = 1,				
		UseAmendedQualifiers,
		DirectRead,
		Deep
	};

	// Overridden methods from WMIOperation
	HRESULT BeginRequest (CComPtr<IWbemServices> & pIWbemServices);
	HRESULT	ProcessRequest (void);
	
	bool ProcessElement (      
				const wchar_t __RPC_FAR *pwchNamespaceUri,
				int cchNamespaceUri,
				const wchar_t __RPC_FAR *pwchLocalName,
				int cchLocalName,
				const wchar_t __RPC_FAR *pwchRawName,
				int cchRawName,
				ISAXAttributes __RPC_FAR *pAttributes);

	bool ProcessContent (        
				const unsigned short * pwchChars,
				int cchChars );

	bool	ResponseHasContent (void)
	{
		return !m_bIsEmptyResultsSet;
	}

public:
	WMIGetInstancesOperation (SOAPActor *pActor) : 
		WMIEncodingOperation (pActor),
		m_bUseAmendedQualifiers (true),
		m_bDirectRead (false),
		m_bDeep (true),
		m_bIsEmptyResultsSet (true) {}
	~WMIGetInstancesOperation () {}

	// Overridden from WMIOperation
	LPCSTR GetOperationResponseName (void)
	{
		return "GetInstancesResponse";
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opgetob.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  OPDELCS.CPP
//
//  alanbos  07-Nov-00   Created.
//
//  WMI Delete Class operation implementation.  
//
//***************************************************************************

#include "precomp.h"

HRESULT WMIGetObjectOperation::BeginRequest (
	CComPtr<IWbemServices> & pIWbemServices
)
{
	HRESULT hr = WBEM_E_FAILED;
	LONG lFlags = WBEM_RETURN_WHEN_COMPLETE;

	if (m_bUseAmendedQualifiers)
		lFlags |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;

	if (m_bDirectRead)
		lFlags |= WBEM_FLAG_DIRECT_READ;

	// Get the object
	hr = pIWbemServices->GetObject (
						m_bsObjectName, 
						lFlags, 
						GetContext(), 
						&m_pIWbemClassObject,
						NULL);
	
	return hr;
}

HRESULT WMIGetObjectOperation::ProcessRequest (void)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pIWbemClassObject)
	{
		CComVariant varValue;

		if (SUCCEEDED(hr = m_pIWbemClassObject->Get (L"__GENUS", 0, &varValue, NULL, NULL)))
		{
			 if (WBEM_GENUS_CLASS == varValue.lVal)
			 	 hr = EncodeAndSendClass (m_pIWbemClassObject);
			 else
				 hr = EncodeAndSendInstance (m_pIWbemClassObject);
		}
	}

	return hr;
}

bool WMIGetObjectOperation::ProcessElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	bool result = false;

	if (0 == wcscmp(WMI_GETOBJECT_PARAMETER_NAME, pwchLocalName))
	{
		// following content will be the value of the object name
		SetParseState (Name);
		result = true;
	}
	else if (0 == wcscmp(WMI_GETOBJECT_PARAMETER_USEAQ, pwchLocalName))
	{
		// following content will be the value of UseAmendedQualifiers
		SetParseState (UseAmendedQualifiers);
		result = true;
	}
	else if (0 == wcscmp(WMI_GETOBJECT_PARAMETER_DIRECTREAD, pwchLocalName))
	{
		// following content will be the value of DirectRead
		SetParseState (DirectRead);
		result = true;
	}

	return result;
}

bool WMIGetObjectOperation::ProcessContent (
        const unsigned short * pwchChars,
        int cchChars )
{
	bool result = true;

	switch (GetParseState ())
	{
		case Name:
			m_bsObjectName = SysAllocStringLen (pwchChars, cchChars);
			break;

		case UseAmendedQualifiers:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bUseAmendedQualifiers = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bUseAmendedQualifiers = false;
				else
					result = false;
			}
			break;

		case DirectRead:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bDirectRead = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bDirectRead = false;
				else
					result = false;
			}
			break;
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opgetin.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  OPGETIN.CPP
//
//  alanbos  07-Nov-00   Created.
//
//  WMI Get Classes operation implementation.  
//
//***************************************************************************

#include "precomp.h"

HRESULT WMIGetInstancesOperation::BeginRequest (
	CComPtr<IWbemServices> & pIWbemServices
)
{
	HRESULT hr = WBEM_E_FAILED;
	LONG lFlags = WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY;

	if (m_bUseAmendedQualifiers)
		lFlags |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;

	if (m_bDirectRead)
		lFlags |= WBEM_FLAG_DIRECT_READ;

	if (!m_bDeep)
		lFlags |= WBEM_FLAG_SHALLOW;

	// Call the enumerator
	if (SUCCEEDED(hr = pIWbemServices->CreateInstanceEnum (
						m_bsClassBasis, 
						lFlags, 
						GetContext(), 
						&m_pIEnumWbemClassObject)))
	{
		/*
		 * Get the first object - we do this as we are operating in semi-sync and some
		 * errors are only flagged on Next, not on CreateInstanceEnum.
		 */
		ULONG lReturned = 0;
		hr = m_pIEnumWbemClassObject->Next (WBEM_INFINITE, 1, &m_pFirstIWbemClassObject, &lReturned);

		if ((S_OK == hr) && (1 == lReturned))
			m_bIsEmptyResultsSet = false;
	}

	return hr;
}

HRESULT WMIGetInstancesOperation::ProcessRequest (void)
{
	HRESULT hr = S_OK;
	
	// Start by checking if we have an initial object
	if (m_pFirstIWbemClassObject)
	{
		hr = EncodeAndSendInstance (m_pFirstIWbemClassObject);
		m_pFirstIWbemClassObject.Release ();
	}

	// Now send the remainder
	if (SUCCEEDED(hr))
	{
		CComPtr<IWbemClassObject> pIWbemClassObject;
		ULONG lReturned = 0;

		while ((S_OK == (hr = m_pIEnumWbemClassObject->Next (WBEM_INFINITE, 1, &pIWbemClassObject, &lReturned)))
				&& (1 == lReturned))
		{
			if (FAILED(hr = EncodeAndSendInstance (pIWbemClassObject)))
				break;

			lReturned = 0;
		}
	}

	return hr;
}

bool WMIGetInstancesOperation::ProcessElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	bool result = false;

	if (0 == wcscmp(WMI_GETCLASSES_PARAMETER_BASIS, pwchLocalName))
	{
		// following content will be the value of the object name
		SetParseState (ClassBasis);
		result = true;
	}
	else if (0 == wcscmp(WMI_GETOBJECT_PARAMETER_USEAQ, pwchLocalName))
	{
		// following content will be the value of UseAmendedQualifiers
		SetParseState (UseAmendedQualifiers);
		result = true;
	}
	else if (0 == wcscmp(WMI_GETINSTANCES_PARAMETER_DIRECTREAD, pwchLocalName))
	{
		// following content will be the value of DirectRead
		SetParseState (DirectRead);
		result = true;
	}
	else if (0 == wcscmp(WMI_GETCLASSES_PARAMETER_DEEP, pwchLocalName))
	{
		// following content will be the value of DirectRead
		SetParseState (Deep);
		result = true;
	}

	return result;
}

bool WMIGetInstancesOperation::ProcessContent (
        const unsigned short * pwchChars,
        int cchChars )
{
	bool result = true;

	switch (GetParseState ())
	{
		case ClassBasis:
			m_bsClassBasis = SysAllocStringLen (pwchChars, cchChars);
			break;

		case UseAmendedQualifiers:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bUseAmendedQualifiers = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bUseAmendedQualifiers = false;
				else
					result = false;
			}
			break;

		case DirectRead:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bDirectRead = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bDirectRead = false;
				else
					result = false;
			}
			break;

		case Deep:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bDeep = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bDeep = false;
				else
					result = false;
			}
			break;
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opgetob.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  opdelcls.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the class for the WMI DeleteClass operation.
//
//***************************************************************************

#ifndef _OPGETOB_H_
#define _OPGETOB_H_

#define WMI_GETOBJECT_PARAMETER_NAME		L"ObjectName"
#define WMI_GETOBJECT_PARAMETER_USEAQ		L"UseAmendedQualifiers"
#define WMI_GETOBJECT_PARAMETER_DIRECTREAD	L"DirectRead"

//***************************************************************************
//
//  CLASS NAME:
//
//  WMIDeleteClassOperation
//
//  DESCRIPTION:
//
//  WMI DeleteClass Operation handler.
//
//***************************************************************************

class WMIGetObjectOperation : public WMIEncodingOperation
{
private:
	CComBSTR					m_bsObjectName;
	bool						m_bUseAmendedQualifiers;
	bool						m_bDirectRead;

	CComPtr<IWbemClassObject>	m_pIWbemClassObject;

	typedef enum GetObjectParseState {
		Name = 1,				// ObjectName element
		UseAmendedQualifiers,
		DirectRead
	};

	// Overridden methods from WMIOperation
	HRESULT BeginRequest (CComPtr<IWbemServices> & pIWbemServices);
	HRESULT	ProcessRequest (void);
	
	bool ProcessElement (      
				const wchar_t __RPC_FAR *pwchNamespaceUri,
				int cchNamespaceUri,
				const wchar_t __RPC_FAR *pwchLocalName,
				int cchLocalName,
				const wchar_t __RPC_FAR *pwchRawName,
				int cchRawName,
				ISAXAttributes __RPC_FAR *pAttributes);

	bool ProcessContent (        
				const unsigned short * pwchChars,
				int cchChars );
public:
	WMIGetObjectOperation (SOAPActor *pActor) : 
		WMIEncodingOperation (pActor),
		m_bUseAmendedQualifiers (true),
		m_bDirectRead (false) {}
	~WMIGetObjectOperation () {}

	// Overridden from WMIOperation
	LPCSTR GetOperationResponseName (void)
	{
		return "GetObjectResponse";
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opputcl.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  OPPUTCL.CPP
//
//  alanbos  07-Nov-00   Created.
//
//  WMI Put Class operation implementation.  
//
//***************************************************************************

#include "precomp.h"

static char *pStrResponse = "<PutClassResponse xmlns=\""
							WMI_SOAP_NS
							"\"/>";

HRESULT WMIPutClassOperation::BeginRequest (
	CComPtr<IWbemServices> & pIWbemServices
)
{
	int lFlags = 0;

	switch (m_createMode)
	{
		case CreateOrUpdate:
			lFlags |= WBEM_FLAG_CREATE_OR_UPDATE;
			break;

		case CreateOnly:
			lFlags |= WBEM_FLAG_CREATE_ONLY;
			break;

		case UpdateOnly:
			lFlags |= WBEM_FLAG_UPDATE_ONLY;
			break;
	}

	switch (m_updateMode)
	{
		case CreateOrUpdate:
			lFlags |= WBEM_FLAG_CREATE_OR_UPDATE;
			break;

		case CreateOnly:
			lFlags |= WBEM_FLAG_CREATE_ONLY;
			break;

		case UpdateOnly:
			lFlags |= WBEM_FLAG_UPDATE_ONLY;
			break;
	}

	return pIWbemServices->PutClass (m_pIWbemClassObject, 0, GetContext(), NULL);
}

HRESULT WMIPutClassOperation::ProcessRequest (void)
{
	// TODO
	return WBEM_E_NOT_SUPPORTED;
}

bool WMIPutClassOperation::ProcessElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	bool result = false;

	if (0 == wcscmp(WMI_PUTCLASS_PARAMETER_USEAQ, pwchLocalName))
	{
		// following content will be the value of UseAmendedQualifiers
		SetParseState (UseAmendedQualifiers);
		result = true;
	}
	else if (0 == wcscmp(WMI_PUTCLASS_PARAMETER_CREATEMODE, pwchLocalName))
	{
		// following content will be the value of CreateMode
		SetParseState (CreateMode);
		result = true;
	}
	else if (0 == wcscmp(WMI_PUTCLASS_PARAMETER_UPDATEMODE, pwchLocalName))
	{
		// following content will be the value of UpdateMode
		SetParseState (UpdateMode);
		result = true;
	}
	else if (0 == wcscmp(WMI_PUTCLASS_PARAMETER_CLASS, pwchLocalName))
	{
		// following content will be the value of the Class
		SetParseState (Class);

		// TODO. Here we need to switch in our special ISAXContentHandler
		// implementation to take over the processing of the input 
		// stream. To do this we will need WmiOperation to expose a 
		// method to "push" a new ISAXContentHandler onto the ISAXXMLReader
		// that it holds internally.
		// This ISAXContentHandler will deserialize the input XML into
		// an IWbemClassObject representing a WMI class. It will also need
		// to flag any decoding errors to the operation handler.
		// When we are done with the deserializer, we must "pop" the content
		// handler off the stack so that control can return to the default
		// WmiOperation implementation of ISAXContentHandler.
		
		CComPtr<IWbemServices> pIWbemServices;
		GetIWbemServices (pIWbemServices);

		if (pIWbemServices)
		{
			// TODO - make this a CoCreate call!
			CComPtr<IWmiDeserializer> pIWmiDeserializer = new CWmiDeserializer (pIWbemServices);

			if (pIWmiDeserializer)
			{
				/*
				 * We need the namespace to have been identified at this
				 * point. Obviously this means that content model of the <PutClass>
				 * operation is not strictly <all> (i.e. unordered). Whilst
				 * we do not publish the WSDL for WMISOAP, we can live with this.
				 * Ultimately we would need to attach an IMXWriter at this point
				 * to store the XML in a DOM for later processing.
				 */

	#if 0
				// Swap in the new content handler
				if (SUCCEEDED(SetContentHandler ((CComPtr<IWmiDeserializer> &) pIWmiDeserializer)))
				{
					if (SUCCEEDED(pIWmiDeserializer->Deserialize (TRUE, pIWbemServices, &m_pIWbemClassObject)))
						result = true;

					if (FAILED(RestoreContentHandler ()))
						result = false;
				}
	#endif
			}
		}
	
	}
	
	return result;
}

bool WMIPutClassOperation::ProcessContent (
        const unsigned short * pwchChars,
        int cchChars )
{
	bool result = true;

	switch (GetParseState ())
	{
		case UseAmendedQualifiers:
			{
				if (0 == wcsncmp (pwchChars, L"true", cchChars))
					m_bUseAmendedQualifiers = true;
				else if (0 == wcsncmp (pwchChars, L"false", cchChars))
					m_bUseAmendedQualifiers = false;
				else
					result = false;
			}
			break;

		case CreateMode:
			{
				if (0 == wcsncmp (pwchChars, L"CreateOrUpdate", cchChars))
					m_createMode = CreateOrUpdate;
				else if (0 == wcsncmp (pwchChars, L"CreateOnly", cchChars))
					m_createMode = CreateOnly;
				else if (0 == wcsncmp (pwchChars, L"UpdateOnly", cchChars))
					m_createMode = UpdateOnly;
				else
					result = false;
			}
			break;

		case UpdateMode:
			{
				if (0 == wcsncmp (pwchChars, L"Compatible", cchChars))
					m_updateMode = Compatible;
				else if (0 == wcsncmp (pwchChars, L"Safe", cchChars))
					m_updateMode = Safe;
				else if (0 == wcsncmp (pwchChars, L"Force", cchChars))
					m_updateMode = Force;
				else
					result = false;
			}
			break;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\precomp.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  precomp.h
//
//  alanbos  31-Oct-31   Created.
//
//  Master include file.
//
//***************************************************************************

#pragma warning(disable:4786)
#pragma warning(disable:4192)


#include <stdio.h>
#include <process.h>
#include <httpext.h>
#include <atlbase.h>
#include <msxml2.h>     
#include <wbemidl.h>
#include <wmi2xsd.h>
#include <wmiutils.h>

#include "thrdpool.h"
#include "wmisoap.h"
#include "soaptrns.h"
#include "httptrns.h"
#include "objretvr.h"
#include "wmiconn.h"
#include "soapactr.h"
#include "wmiuri.h"
#include "dserlzer.h"
#include "wmiopn.h"
#include "opgetob.h"
#include "opgetcl.h"
#include "opgetin.h"
#include "opexecqy.h"
#include "opdelcs.h"
#include "opdelin.h"
#include "opputcl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\soaptrns.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  soaptrns.h
//
//  alanbos  31-Oct-00   Created.
//
//  Defines the abstract base class for SOAP transport entities.
//
//***************************************************************************

#ifndef _SOAPTRNS_H_
#define _SOAPTRNS_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  SOAPTransport
//
//  DESCRIPTION:
//
//  Abstract SOAP Transport endpoint.
//
//***************************************************************************

class SOAPTransport
{
protected:
	SOAPTransport() {}

public:
	virtual ~SOAPTransport () {}

	virtual void		GetRequestStream (CComPtr<IStream> & pIStream) = 0;
	virtual void		GetResponseStream (CComPtr<IStream> & pIStream) = 0;
	virtual bool		IsValidEncapsulation () = 0;

	virtual bool		SendSOAPError (bool bIsClientError = true) const = 0;
	virtual bool		SendServerStatus (bool ok) const = 0;
	virtual bool		AbortResponse () const = 0;
	virtual HRESULT		GetRootXMLNamespace (CComBSTR & bsNamespace, bool bStripQuery = false) const = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\opputcl.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  opputcls.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the class for the WMI PutClass operation.
//
//***************************************************************************

#ifndef _OPPUTCL_H_
#define _OPPUTCL_H_

#define WMI_PUTCLASS_PARAMETER_CLASS		L"Class"
#define WMI_PUTCLASS_PARAMETER_USEAQ		L"UseAmendedQualifiers"
#define WMI_PUTCLASS_PARAMETER_CREATEMODE	L"CreateMode"
#define WMI_PUTCLASS_PARAMETER_UPDATEMODE	L"UpdateMode"


//***************************************************************************
//
//  CLASS NAME:
//
//  WMIPutClassOperation
//
//  DESCRIPTION:
//
//  WMI DeleteClass Operation handler.
//
//***************************************************************************

class WMIPutClassOperation : public WMIOperation
{
private:
	CComPtr<IWbemClassObject>			m_pIWbemClassObject;
	bool								m_bUseAmendedQualifiers;

	typedef enum CreateMode {
		CreateOrUpdate,
		CreateOnly,
		UpdateOnly
	}	CreateMode;
	
	CreateMode							m_createMode;

	typedef enum UpdateMode {
		Compatible,
		Safe,
		Force
	} UpdateMode;
	
	UpdateMode							m_updateMode;

	typedef enum PutClassParseState {
		Class = 1,				// Class element
		UseAmendedQualifiers,
		CreateMode,
		UpdateMode
	};

	// Overridden methods from WMIOperation
	HRESULT BeginRequest (CComPtr<IWbemServices> & pIWbemServices);
	HRESULT	ProcessRequest (void);
	
	bool ProcessElement (      
				const wchar_t __RPC_FAR *pwchNamespaceUri,
				int cchNamespaceUri,
				const wchar_t __RPC_FAR *pwchLocalName,
				int cchLocalName,
				const wchar_t __RPC_FAR *pwchRawName,
				int cchRawName,
				ISAXAttributes __RPC_FAR *pAttributes);

	bool ProcessContent (        
				const unsigned short * pwchChars,
				int cchChars );

	LPCSTR GetOperationResponseName (void)
	{
		return "PutClassResponse";
	}

	bool ResponseHasContent (void)
	{
		return false;
	}

public:
	WMIPutClassOperation (SOAPActor *pActor) : 
		WMIOperation (pActor),
		m_bUseAmendedQualifiers(true),
		m_createMode (CreateOrUpdate),
		m_updateMode (Compatible)
		{}
	~WMIPutClassOperation () {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\soapactr.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  SOAPACTR.CPP
//
//  alanbos  31-Oct-00   Created.
//
//  SOAP actor decoder implementation.  
//
//***************************************************************************

#include "precomp.h"

SOAPActor::SOAPActor(SOAPTransport &SoapTransport) : 
		 m_cRef (1),
		 m_SOAPTransport (SoapTransport),
		 m_parseState (Start),
		 m_headerNest (0),
		 m_pOperationHandler (NULL),
		 m_bClientError (true)
{
 	CComPtr<IUnknown> pIUnknown;
	HRESULT hr = CoCreateInstance(CLSID_SAXXMLReader, NULL, CLSCTX_ALL,
		 IID_IUnknown, (void **)&pIUnknown);

	if (SUCCEEDED(hr))
		hr = pIUnknown->QueryInterface (IID_ISAXXMLReader, (void**)&m_pISAXXMLReader);	
}

SOAPActor::~SOAPActor()
{
	if (m_pOperationHandler)
	{
		m_pOperationHandler->Release ();
		m_pOperationHandler = NULL;
	}
}

STDMETHODIMP SOAPActor::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (__uuidof(ISAXContentHandler)==riid)
		*ppv = (ISAXContentHandler *)this;
	else if (__uuidof(ISAXErrorHandler)==riid)
		*ppv = (ISAXErrorHandler *)this;
	else if (__uuidof(ISAXLexicalHandler)==riid)
		*ppv = (ISAXLexicalHandler *)this;
		
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) SOAPActor::AddRef(void)
{
	InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) SOAPActor::Release(void)
{
	LONG cRef = InterlockedDecrement(&m_cRef);

    if (0L!=cRef)
        return cRef;

    delete this;
    return 0;
}

void SOAPActor::Act (void)
{
	if (m_pISAXXMLReader)
	{
		// Get our request stream
		CComPtr<IStream> pRequestStream;
		m_SOAPTransport.GetRequestStream (pRequestStream);

		if (pRequestStream)
		{
			CComVariant var (reinterpret_cast<IUnknown*>(this));

			// Register ourselves as a content handler
			if (SUCCEEDED(m_pISAXXMLReader->putContentHandler (this))) 
			{
				// Start parsing!
				CComVariant var ((IUnknown*) pRequestStream);
				HRESULT parseStatus = S_OK;

				if (SUCCEEDED(parseStatus = m_pISAXXMLReader->parse (var)))
				{
					// Did we get an operation handler hooked up?
					if (m_pOperationHandler)
					{
						/*
						 * Go fire - pass in the stream to which the handler should send
						 * the response.
						 */
						m_pOperationHandler->Execute ();

						// Finally release our operation handler
						m_pOperationHandler->Release ();
						m_pOperationHandler = NULL;
					}	
				}
				else 
				{
					// The parse failed
					m_SOAPTransport.SendSOAPError (m_bClientError);
				}
			}
		}
	}
}

HRESULT STDMETHODCALLTYPE SOAPActor::startDocument()
{
	// Unhook any current operation handler
	if (m_pOperationHandler)
	{
		m_pOperationHandler->Release ();
		m_pOperationHandler = NULL;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE SOAPActor::endDocument ( )
{
	m_parseState = End;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE SOAPActor::startElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	HRESULT result = E_FAIL;

	if (IsSOAPElement(pwchNamespaceUri))
	{
		// Could be a SOAP element - let's take a look
		if (0 == wcscmp (pwchLocalName, SOAP_ELEMENT_ENVELOPE))
		{
			switch (m_parseState)
			{
				case Start:
					{
						m_parseState = Envelope;
					
						if (CheckEnvelopeAttributes (pAttributes))
							result = S_OK;
					}
					break;

				case HeaderChildElement:
				case HeaderNestedElement:
				{
					// Not interested - just bump up the nest count 
					m_parseState = HeaderNestedElement;
					m_headerNest++;
					result = S_OK;
				}

				case BodyComplete:
				case Header:
				case Body:
					{
						// ignore
						result = S_OK;
					}
					break;

				case EnvelopeComplete:
				case HeaderComplete:
				case End:
					{
						// illegal
					}
					break;
			}
		}
		else if (0 == wcscmp (pwchLocalName, SOAP_ELEMENT_HEADER))
		{
			switch (m_parseState)
			{
				case Envelope:
					{
						if (CheckEnvelopeAttributes (pAttributes))
						{
							m_parseState = Header;
							result = S_OK;
						}
					}
					break;

				case HeaderChildElement:
				case HeaderNestedElement:
					{
						// Not interested - just bump up the nest count 
						m_parseState = HeaderNestedElement;
						m_headerNest++;
						result = S_OK;
					}
					break;

				case BodyComplete:
				case Header:
				case Body:
					{
						// ignore
						result = S_OK;
					}
					break;

				case EnvelopeComplete:
				case HeaderComplete:
				case End:
					{
						// illegal
					}
					break;
			}
		}
		else if (0 == wcscmp (pwchLocalName, SOAP_ELEMENT_BODY))
		{
			switch (m_parseState)
			{
				case Envelope:
				case HeaderComplete:
					{
						if (CheckBodyAttributes (pAttributes))
						{
							m_parseState = Body;
							result = S_OK;
						}
					}
					break;

				case HeaderChildElement:
				case HeaderNestedElement:
				{
					// Not interested - just bump up the nest count 
					m_parseState = HeaderNestedElement;
					m_headerNest++;
					result = S_OK;
				}

				case BodyComplete:
				case Header:
				case Body:
					{
						// ignore
						result = S_OK;
					}
					break;

				case EnvelopeComplete:
				case End:
					{
						// illegal
					}
					break;
			}
		}
		else 
		{
			// Not a recognized SOAP request element
			switch (m_parseState)
			{
				case Envelope:
				case HeaderComplete:
				case EnvelopeComplete:
				case End:
					{
						// illegal
					}
					break;

				case HeaderChildElement:
				case HeaderNestedElement:
					{
						// Not interested - just bump up the nest count 
						m_parseState = HeaderNestedElement;
						m_headerNest++;
						result = S_OK;
					}
					break;

				case BodyComplete:
				case Header:
				case Body:
					{
						// ignore
						result = S_OK;
					}
					break;
			}
		}
	}
	else
	{
		/*
		 * Not a SOAP element. There are 3 situations in which this can legally arise:
		 *  
		 * 1. We are parsing the content of the <Header> element
		 * 2. We are parsing the content of the <Body> element
		 * 3. We are parsing the content of the <Envelope> after the <Body>
		 */

		switch (m_parseState)
		{
			case Header:
				{
					m_parseState = HeaderChildElement;

					// We are not interested in headers, unless they
					// say mustUnderstand in which case we don't understand!
					if (!MustUnderstand (pAttributes))
						result = S_OK;
				}
				break;

			case HeaderChildElement:
			case HeaderNestedElement:
				{
					// Not interested - just bump up the nest count 
					m_parseState = HeaderNestedElement;
					m_headerNest++;
					result = S_OK;
				}
				break;
		
			case BodyComplete:
				// Not interested
				result = S_OK;
				break;

			case End:
			case EnvelopeComplete:
			case Envelope:
			case HeaderComplete:
				// error
				break;

			case Body:
				{
					// Start the parsing of the WMI Request body here
					bool bRecognizedOperation = true;

					if (!m_pOperationHandler)
					{
						/*
						 * This will AddRef the returned operation, which we release
						 * in either Act, startDocument or ~SOAPActor.
						 */
						m_pOperationHandler = WMIOperation::GetOperationHandler (
																this,
																pwchLocalName,
																bRecognizedOperation);
					}

					if (bRecognizedOperation)
					{
						if (!m_pOperationHandler)
							m_bClientError = false;
						else
						{
							// Hand over control to the Operation content handler
							if (SUCCEEDED(m_pISAXXMLReader->putContentHandler (m_pOperationHandler)))
								result = m_pOperationHandler->startElement( 
											  pwchNamespaceUri,
											  cchNamespaceUri,
											  pwchLocalName,
											  cchLocalName,
											  pwchRawName,
											  cchRawName,
											  pAttributes);
						}
					}
					else
					{
						// error will be signalled on return from parsing
					}
				}
				break;
		}
	}

	return result;
}


HRESULT STDMETHODCALLTYPE SOAPActor::endElement (
        const wchar_t * pwchNamespaceUri,
        int cchNamespaceUri,
        const wchar_t * pwchLocalName,
        int cchLocalName,
        const wchar_t * pwchQName,
        int cchQName )
{
	HRESULT result = E_FAIL;

	if (IsSOAPElement(pwchNamespaceUri))
	{
		// Could be a SOAP element - let's take a look
		if (0 == wcscmp (pwchLocalName, SOAP_ELEMENT_ENVELOPE))
		{
			switch (m_parseState)
			{
				case BodyComplete:
					m_parseState = EnvelopeComplete;
					result = S_OK;
					break;

				case Envelope:
				case HeaderComplete:
					// Error - we haven't had a Body
					break;

				case Header:
				case End:
				case EnvelopeComplete:
				case Start:
					// shouldn't happen
					break;

				default:
					// ignore for now
					result = S_OK;
					break;
			}
		}
		else if (0 == wcscmp (pwchLocalName, SOAP_ELEMENT_HEADER))
		{
			switch (m_parseState)
			{
				case Header:
				case Envelope:
					m_parseState = Body;
					result = S_OK;
					break;

				case HeaderComplete:
				case End:
				case EnvelopeComplete:
				case Start:
					// shouldn't happen
					break;
				
				default:
					// ignore for now
					result = S_OK;
					break;
			}
		}
		else if (0 == wcscmp (pwchLocalName, SOAP_ELEMENT_BODY))
		{
			switch (m_parseState)
			{
				case Body:
					m_parseState = BodyComplete;;
					result = S_OK;
					break;

				case Header:
				case Envelope:
				case HeaderComplete:
				case End:
				case EnvelopeComplete:
				case Start:
					// shouldn't happen
					break;
				
				default:
					// ignore for now
					result = S_OK;
					break;
			}	
		}
	}
	else
	{
		// We don't care about non-SOAP closing tags here beyond the 
		// mechanics of changing the header nesting level, and that's
		// dealt with below. 

		result = S_OK;
	}

	if (HeaderChildElement == m_parseState)
		m_parseState = Header;
	else if (HeaderNestedElement == m_parseState)
	{
		if (0 == --m_headerNest)
			m_parseState = HeaderChildElement;
	}

	return result;
}

HRESULT STDMETHODCALLTYPE SOAPActor::characters (
        const unsigned short * pwchChars,
        int cchChars )
{
	return S_OK;
}

bool SOAPActor::CheckEnvelopeAttributes (
		ISAXAttributes __RPC_FAR *pAttributes
) const
{
	bool result = false;
	/*
	 * This checks that the attributes are valid. Note that SOAP [3]
	 * states that <Envelope> MAY contain xmlns declarations but we
	 * won't see these as we are using the default settings for the
	 * SAX parser which does not surface them to us here. SOAP [3] also
	 * states that other attributes may be present but they MUST be
	 * namespace-qualified.
	 */

	int numAttributes = 0;

	if (pAttributes && 
		SUCCEEDED(pAttributes->getLength(&numAttributes)) &&
		(0 < numAttributes))
	{
		bool ok = true;
		
		while (ok && (0 <= --numAttributes)) // zero-based index
		{
			const wchar_t *pwchQName = NULL;
			const wchar_t *pwchUri = NULL;
			const wchar_t *pwchLocalName = NULL;
			int cchUri = 0;
			int cchLocalName = 0;
			int cchQName = 0;
			
			int iQNameLen = 0;

			if (SUCCEEDED(pAttributes->getName(
							   numAttributes, 
							   &pwchUri, 
							   &cchUri,
							   &pwchLocalName,
							   &cchLocalName,
							   &pwchQName,
							   &cchQName)))
			{
				// for xmlbs the local name is empty - we ignore these
				if (0 == cchLocalName)
					continue;

				// Check all attributes are ns-qualified 
				ok = (0 < cchUri);

				/*
				 * Special case - if this is the SOAP encodingStyle attribute it had better
				 * be the one we understand! Note some ambiguity in the SOAP spec here; in
				 * one place it says that it isn't mandatory to ns-qualify SOAP elements and
				 * attributes, but also says that all attributes of <Envelope> MUST be
				 * qualified. We go with the tighter statement here.
				 */
				if (ok && (0 == wcsncmp (pwchLocalName, SOAP_ATTRIBUTE_ENCODINGSTYLE, cchLocalName)) &&
					(0 == wcsncmp (pwchUri, SOAP_NS_ENVELOPE, cchUri)))
				{
					const wchar_t *pwchValue = NULL;
					int cchValue = 0;

					if (SUCCEEDED(pAttributes->getValue (numAttributes, &pwchValue, &cchValue)))
						ok = CheckEncodingStyle (pwchValue);
				}
			}
		}

		result = ok;
	}

	return result;
}

bool SOAPActor::CheckHeaderAttributes (
		ISAXAttributes __RPC_FAR *pAttributes
) const
{
	// Since WMI SOAP does not recognize any headers, we don't care
	return true;
}

bool SOAPActor::CheckBodyAttributes (
		ISAXAttributes __RPC_FAR *pAttributes
) const
{
	bool result = true;
	// The SOAP spec is currently ambiguous on Body attributes;
	// the only one we care about is the encodingStyle

	int numAttributes = 0;

	if (pAttributes && 
		SUCCEEDED(pAttributes->getLength(&numAttributes)) &&
		(0 < numAttributes))
	{
		while (0 <= --numAttributes) // zero-based index
		{
			const wchar_t *pwchQName = NULL;
			const wchar_t *pwchUri = NULL;
			const wchar_t *pwchLocalName = NULL;
			int cchUri = 0;
			int cchLocalName = 0;
			int cchQName = 0;
			
			int iQNameLen = 0;

			if (SUCCEEDED(pAttributes->getName(
							   numAttributes, 
							   &pwchUri, 
							   &cchUri,
							   &pwchLocalName,
							   &cchLocalName,
							   &pwchQName,
							   &cchQName)))
			{
				// for xmlbs the local name is empty - we ignore these
				if (0 == cchLocalName)
					continue;

				/*
				 * If this is the SOAP encodingStyle attribute it had better
				 * be the one we understand! Note that we are "lax" about
				 * allowing a unqualified attribute here since the SOAP spec is
				 * ambiguous.
				 */
				if ((0 == wcsncmp (pwchLocalName, SOAP_ATTRIBUTE_ENCODINGSTYLE, cchLocalName)) &&
					((NULL == pwchUri) || (0 == wcsncmp (pwchUri, SOAP_NS_ENVELOPE, cchUri))))
				{
					const wchar_t *pwchValue = NULL;
					int cchValue = 0;

					if (SUCCEEDED(pAttributes->getValue (numAttributes, &pwchValue, &cchValue)))
						result = CheckEncodingStyle (pwchValue);

					break; // not interested in other attributes
				}
			}
		}
	}

	return result;
}

bool SOAPActor::CheckEncodingStyle (const wchar_t *pwchValue)
{
	// TODO - actually we need to ensure that the value contains
	// a URI which is equal to, or an extension of, the standard
	// SOAP encoding URI.
	return (pwchValue) && (0 == wcscmp (pwchValue, SOAP_NS_ENCODING));
}

bool SOAPActor::MustUnderstand (
		ISAXAttributes __RPC_FAR *pAttributes
) 
{
	bool result = false;
	int numAttributes = 0;

	if (pAttributes && 
		SUCCEEDED(pAttributes->getLength(&numAttributes)) &&
		(0 < numAttributes))
	{
		while (0 <= --numAttributes) // zero-based index
		{
			const wchar_t *pwchQName = NULL;
			const wchar_t *pwchUri = NULL;
			const wchar_t *pwchLocalName = NULL;
			int cchUri = 0;
			int cchLocalName = 0;
			int cchQName = 0;
			
			int iQNameLen = 0;

			if (SUCCEEDED(pAttributes->getName(
							   numAttributes, 
							   &pwchUri, 
							   &cchUri,
							   &pwchLocalName,
							   &cchLocalName,
							   &pwchQName,
							   &cchQName)))
			{
				// for xmlbs the local name is empty - we ignore these
				if (0 == cchLocalName)
					continue;

				/*
				 * If this is the SOAP mustUnderstand attribute it had better
				 * be 0! Note that we are "lax" about
				 * allowing a unqualified attribute here since the SOAP spec is
				 * ambiguous.
				 */
				if ((0 == wcsncmp (pwchLocalName, SOAP_ATTRIBUTE_MUSTUNDERSTAND, cchLocalName)) &&
					((NULL == pwchUri) || (0 == wcsncmp (pwchUri, SOAP_NS_ENVELOPE, cchUri))))
				{
					const wchar_t *pwchValue = NULL;
					int cchValue = 0;

					if (SUCCEEDED(pAttributes->getValue (numAttributes, &pwchValue, &cchValue)))
						result = (NULL != pwchValue) && (0 == wcscmp (pwchValue, L"1"));

					break; // not interested in other attributes
				}
			}
		}
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\soapactr.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  soapactr.h
//
//  alanbos  31-Oct-00   Created.
//
//  Defines the handler class for the SOAP message.
//
//***************************************************************************

#ifndef _SOAPACTR_H_
#define _SOAPACTR_H_

#define SAX_LEXICAL_HANDLER		L"http://xml.org/sax/properties/lexical-handler"

// Standard Namespaces
#define SOAP_NS_ENVELOPE		L"http://schemas.xmlsoap.org/soap/envelope/"
#define SOAP_NS_ENCODING		L"http://schemas.xmlsoap.org/soap/encoding/"

// Element names
#define SOAP_ELEMENT_ENVELOPE	L"Envelope"
#define SOAP_ELEMENT_HEADER		L"Header"
#define SOAP_ELEMENT_BODY		L"Body"

// Attribute names
#define SOAP_ATTRIBUTE_ENCODINGSTYLE	L"encodingStyle"
#define SOAP_ATTRIBUTE_MUSTUNDERSTAND	L"mustUnderstand"

//***************************************************************************
//
//  CLASS NAME:
//
//  SOAPActor
//
//  DESCRIPTION:
//
//  SOAP actor implementation. 
//
//***************************************************************************

class WMIOperation;

class SOAPActor : public ISAXContentHandler
{
private:
	LONG					m_cRef;
	CComPtr<ISAXXMLReader>	m_pISAXXMLReader;
	SOAPTransport			&m_SOAPTransport;
	ULONG					m_headerNest;
	bool					m_bClientError;
	WMIOperation			*m_pOperationHandler;

	typedef enum SOAPParseState {
		Start,					// Not yet met the root element
		Envelope,				// Hit <Envelope> 
		Header,					// Hit <Header>
		HeaderChildElement,		// Hit a child of <Header>
		HeaderNestedElement,	// Hit some descendent of a child of <Header>
		HeaderComplete,			// Hit </Header>
		Body,					// Hit <Body>
		BodyComplete,			// Hit </Body>
		EnvelopeComplete,		// Hit </Envelope>
		End						// Finished
	};

	SOAPParseState	m_parseState;

	bool CheckEnvelopeAttributes (ISAXAttributes *pAttributes) const;
	bool CheckHeaderAttributes (ISAXAttributes *pAttributes) const;
	bool CheckBodyAttributes (ISAXAttributes *pAttributes) const;

	static bool CheckEncodingStyle (const wchar_t *pwchValue);
	inline static bool IsSOAPElement (const wchar_t *pwchNamespaceUri)
	{
		return (NULL == pwchNamespaceUri) || (0 == wcscmp (SOAP_NS_ENVELOPE, pwchNamespaceUri));
	}

   public:
		SOAPActor(SOAPTransport &SoapTransport);
		virtual ~SOAPActor();

		void Act (void);

		bool SendServerStatus (bool ok)
		{
			return m_SOAPTransport.SendServerStatus (ok);
		}

		bool AbortResponse ()
		{
			return m_SOAPTransport.AbortResponse ();
		}

		void GetResponseStream (CComPtr<IStream> & pIStream)
		{
			m_SOAPTransport.GetResponseStream (pIStream);
		}

		static bool MustUnderstand (ISAXAttributes *pAttributes);

		HRESULT	SetContentHandler (CComPtr<ISAXContentHandler> & pISAXContentHandler)
		{
			HRESULT hr = E_FAIL;

			if (m_pISAXXMLReader)
				if (pISAXContentHandler)
					hr = m_pISAXXMLReader->putContentHandler (pISAXContentHandler);

			return hr;
		}
	
		HRESULT	RestoreContentHandler ()
		{
			HRESULT hr = E_FAIL;

			if (m_pISAXXMLReader)
				hr = m_pISAXXMLReader->putContentHandler (this);

			return hr;
		}

		HRESULT GetRootXMLNamespace (CComBSTR & bsNamespace) const
		{
			return m_SOAPTransport.GetRootXMLNamespace (bsNamespace);
		}
			
	   
      // ISAXContentHandler methods
	   STDMETHODIMP putDocumentLocator (
        struct ISAXLocator * pLocator ) 
	{ return S_OK; }

    STDMETHODIMP startDocument ( );

    STDMETHODIMP endDocument ( );

    STDMETHODIMP startPrefixMapping (
        const unsigned short * pwchPrefix,
        int cchPrefix,
        const unsigned short * pwchUri,
        int cchUri )
	{ return S_OK; }
	
    STDMETHODIMP endPrefixMapping (
        const unsigned short * pwchPrefix,
        int cchPrefix )
	{ return S_OK; }

    STDMETHODIMP startElement (
        const unsigned short * pwchNamespaceUri,
        int cchNamespaceUri,
        const unsigned short * pwchLocalName,
        int cchLocalName,
        const unsigned short * pwchQName,
        int cchQName,
        struct ISAXAttributes * pAttributes );

    STDMETHODIMP endElement (
        const unsigned short * pwchNamespaceUri,
        int cchNamespaceUri,
        const unsigned short * pwchLocalName,
        int cchLocalName,
        const unsigned short * pwchQName,
        int cchQName );

    STDMETHODIMP characters (
        const unsigned short * pwchChars,
        int cchChars );

    STDMETHODIMP ignorableWhitespace (
        const unsigned short * pwchChars,
        int cchChars )
	{ return S_OK; }

    STDMETHODIMP processingInstruction (
        const unsigned short * pwchTarget,
        int cchTarget,
        const unsigned short * pwchData,
        int cchData )
	{ return S_OK; }

    STDMETHODIMP skippedEntity (
        const unsigned short * pwchName,
        int cchName )
	{ return S_OK; }


	// IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\wmiconn.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMICONN.CPP
//
//  alanbos  02-Nov-00   Created.
//
//  WMI Connection cache implementation.  
//
//***************************************************************************

#include "precomp.h"

STDMETHODIMP WMIConnection::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
		
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) WMIConnection::AddRef(void)
{
	InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) WMIConnection::Release(void)
{
	LONG cRef = InterlockedDecrement(&m_cRef);

    if (0L!=cRef)
        return cRef;

    delete this;
    return 0;
}

void WMIConnection::GetIWbemServices (CComPtr<IWbemServices> &pIWbemServices)
{
	if (m_pIWbemServices)
		pIWbemServices = m_pIWbemServices;
	else
	{
		CComPtr<IWbemLocator>	pIWbemLocator;

		if (SUCCEEDED(CoCreateInstance (CLSID_WbemLocator, 0,
			CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*) &pIWbemLocator)))
		{
			if (SUCCEEDED(m_connectionStatus = pIWbemLocator->ConnectServer (
					m_bsNamespacePath,
					NULL,
					NULL,
					m_bsLocale,
					0, 
					NULL,
					NULL,
					&m_pIWbemServices)))
				pIWbemServices = m_pIWbemServices;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\thrdpool.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  thrdpool.h
//
//  rajeshr  01-Jan-01   Created.
//
//  Thread Pool for handling ISAPI requests
//	The main reason we require a thread pool is that we need to do COM initialization on 
//	our own threads
//
//***************************************************************************

#include <precomp.h>




CThreadPool::CThreadPool()
{
	m_oMonitorThread = NULL;
	m_cNumberOfThreads = m_cNumberOfActiveThreads = 0;
	m_pWorkerThreads = NULL;
	m_oSemaphore = NULL;
	m_bShutDown = false;
}

CThreadPool::~CThreadPool()
{
}

HRESULT CThreadPool::Initialize(LONG cNumberOfThreads, LONG cTaskQueueLength)
{
	HRESULT hr = E_FAIL;

	// Initialize the circular queue
	if(SUCCEEDED(hr = m_oQueue.Initialize(cTaskQueueLength)))
	{
		// Create the semaphore
		if(m_oSemaphore = CreateSemaphore(NULL, 0, cNumberOfThreads, NULL))
		{
			// Create the array of handles of the worker threads
			if(m_pWorkerThreads = new HANDLE[cNumberOfThreads])
			{

				// Create the worker threads themselves
				for(int i=0; i<cNumberOfThreads; i++)
				{
					if(!(m_pWorkerThreads[i] = CreateThread(NULL, 0, &s_fWorkProc, (LPVOID) this, CREATE_SUSPENDED, NULL)))
						break;
				}

				// Were all threads successfully created?
				if(i == cNumberOfThreads)
				{
					m_cNumberOfThreads = cNumberOfThreads;

					// Resume all the threads
					for(int k=0; k<cNumberOfThreads; k++)
					{
						if(ResumeThread(m_pWorkerThreads[k]) != -1)
							m_cNumberOfActiveThreads ++;
					}

					if(m_cNumberOfActiveThreads != cNumberOfThreads)
						Terminate();
					else
						hr = S_OK;
				}
				else 
				{
					// Deallocate resources
					for(int j=0; j<i; j++)
						CloseHandle(m_pWorkerThreads[j]);

					hr = E_FAIL;
				}

				if(FAILED(hr))
				{
					delete [] m_pWorkerThreads;
					m_pWorkerThreads = NULL;
				}
			}

			if(FAILED(hr))
			{
				CloseHandle(m_oSemaphore);
				m_oSemaphore = NULL;
			}
		}

	}
	return hr;
}

HRESULT CThreadPool::Terminate()
{
	// First let the worker threads know that you want them to shut down
	m_bShutDown = true;

	// Also, increment the semaphores that the threads are waiting on
	// This should be done for a number of times that is equal to the
	// number of threads
	ReleaseSemaphore(m_oSemaphore, m_cNumberOfThreads, NULL);

	// Now, wait till all worker threads have exited
	WaitForMultipleObjects(m_cNumberOfThreads, m_pWorkerThreads, TRUE, INFINITE);

	// Close the handles of the worker threads
	for(int j=0; j<m_cNumberOfThreads; j++)
		CloseHandle(m_pWorkerThreads[j]);

	// Release the Array of Handles
	delete [] m_pWorkerThreads;
	m_pWorkerThreads = NULL;


	CloseHandle(m_oSemaphore);

	return S_OK;
}

HRESULT CThreadPool::QueueTask(CTask *pTask)
{
	HRESULT hr = E_FAIL;

	// Add the task to the Queue
	if(SUCCEEDED(hr = m_oQueue.AddTask(pTask)))
	{
		// Increment the semaphore
		ReleaseSemaphore(m_oSemaphore, 1, NULL);
	}

	return hr;
}

DWORD WINAPI CThreadPool::s_fMonitorProc(LPVOID lpParameter)
{
	ExitThread(0);
	return 0;
}

DWORD WINAPI CThreadPool::s_fWorkProc(LPVOID lpParameter)
{
	HRESULT hr = E_FAIL;

	CThreadPool *pPool = (CThreadPool *)lpParameter;

	// We need to be called on an STA because the SAXXMLReader doesn't work otherwise.
	// rajeshr - We need to change this as soon as msxml changes this
	if(SUCCEEDED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
	{
		while(true)
		{
			// Check to see if we have been asked to terminate
			if(pPool->m_bShutDown)
			{
				// Decrement the count of active threads
				InterlockedDecrement(&(pPool->m_cNumberOfActiveThreads));
				break;
			}

			// Wait for the next task
			WaitForSingleObject(pPool->m_oSemaphore, INFINITE);

			CTask *pNextTask = NULL;
			if(pNextTask = (pPool->m_oQueue).RemoveTask())
			{
				pNextTask->Execute();

				// Destroy the task object
				delete pNextTask;
			}
			else
			{
				// The Semaphore was set without a task being in the queue
				// This special condition is created when we want the Thread Pool to shutdown
				// Decrement the count of active threads
				InterlockedDecrement(&(pPool->m_cNumberOfActiveThreads));
				break; 
			}
		}

		CoUninitialize();
	}

	ExitThread(0);
	return 0;
}


/////////////////////////////////////////
// Code for the circular queue of tasks
////////////////////////////////////////

CTask :: CTask(LPEXTENSION_CONTROL_BLOCK pECB)
{
	m_pECB = pECB;
}

CTask :: ~CTask()
{}

void CTask :: Execute()
{
	
	// Figure out what sort of request we are dealing with
	HTTPTransport httpTransport (m_pECB, HTTP_WMI_SOAP_ACTION);
	
	if (httpTransport.IsPostOrMPost ())
	{
		// Create ourselves an HTTP endpoint bound to our specific action
		if (httpTransport.IsValidEncapsulation())
		{
			SOAPActor soapActor (httpTransport);
			soapActor.Act();
		}
	}
	else if (httpTransport.IsGet ())
	{
		// A WMI object GET 
		ObjectRetriever objectRetriever (httpTransport);
		objectRetriever.Fetch ();
	}
	else
	{
	
		// Anything else is not supported by us
		httpTransport.SendStatus("501 Not Implemented", false);
	}

	// Inform IIS that we are finally done with the request
	m_pECB->ServerSupportFunction(
			m_pECB->ConnID,
			HSE_REQ_DONE_WITH_SESSION,
			NULL,
			NULL,
			NULL
			);


}

CTaskQueue::CTaskQueue()
{
	m_ppTasks = NULL;
	m_cMaxTasks = 0;
	m_iHead = m_iTail = -1;
}


CTaskQueue::~CTaskQueue()
{
	EnterCriticalSection(&m_csQueueProtector);

	// Kill all the pending tasks in the queue
	// By this time all the worker threads should have been terminated
	CTask *pNextTask = NULL;
	while(pNextTask = RemoveTask())
	{
		// Inform IIS that we are finally done with the request
		pNextTask->m_pECB->ServerSupportFunction(
				pNextTask->m_pECB->ConnID,
				HSE_REQ_DONE_WITH_SESSION,
				NULL,
				NULL,
				NULL
				);
		delete pNextTask;
	}

	delete [] m_ppTasks;
	LeaveCriticalSection(&m_csQueueProtector);

	DeleteCriticalSection(&m_csQueueProtector);
}


HRESULT CTaskQueue::Initialize(LONG cMaxTasks)
{
	if(cMaxTasks < 2)
		return S_FALSE;

	InitializeCriticalSection(&m_csQueueProtector);

	HRESULT hr = S_OK;
	if(m_ppTasks = new CTask * [cMaxTasks])
	{
		for(int i=0; i<cMaxTasks; i++)
			m_ppTasks[i] = NULL;
		m_cMaxTasks = cMaxTasks;

	}
	else
		hr = E_OUTOFMEMORY;

	return hr;
}

HRESULT CTaskQueue::AddTask(CTask *pTask)
{
	HRESULT hr = S_OK;
	EnterCriticalSection(&m_csQueueProtector);
	// Is this an empty queue ?
	if(m_iHead == -1)
	{
		m_ppTasks[0] = pTask;
		m_iHead = 0;
		m_iTail = 1;
	}
	// Is this a Full Queue
	else if (m_iHead == m_iTail)
	{
		hr = S_FALSE;
	}
	else
	{
		m_ppTasks[m_iTail] = pTask;
		m_iTail = (m_iTail + 1) % m_cMaxTasks;
	}
	LeaveCriticalSection(&m_csQueueProtector);

	return hr;
}

CTask *CTaskQueue::RemoveTask()
{
	EnterCriticalSection(&m_csQueueProtector);
	CTask *pRet = NULL;
	if(m_iHead != -1)
	{
		pRet = m_ppTasks[m_iHead];
		m_iHead = (m_iHead + 1) % m_cMaxTasks;

		// Was this the last task in the queue ?
		if(m_iHead == m_iTail)
			m_iTail = m_iHead = -1;
	}
	LeaveCriticalSection(&m_csQueueProtector);

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\wmiconn.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmiconn.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the connection cache for WMI operations.
//
//***************************************************************************

#ifndef _WMICONN_H_
#define _WMICONN_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  WMIConnection
//
//  DESCRIPTION:
//
//  Represents a single WMI connection.
//
//***************************************************************************

class WMIConnection : IUnknown
{
private:
	LONG					m_cRef;

	// Basic arguments to all operations
	CComBSTR				m_bsNamespacePath;
	CComBSTR				m_bsLocale;

	// The WMI internals
	CComPtr<IWbemServices>	m_pIWbemServices;
	HRESULT					m_connectionStatus;

public:
	WMIConnection (BSTR bsNamespacePath, BSTR bsLocale) :
	  m_bsNamespacePath (bsNamespacePath),
	  m_bsLocale (bsLocale),
	  m_connectionStatus (WBEM_E_FAILED),
	  m_cRef (1)
	{}

	virtual ~WMIConnection() {}

	// IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	void GetIWbemServices (CComPtr<IWbemServices> &pIWbemServices);

	HRESULT	GetConnectionStatus () const
	{
		return m_connectionStatus;
	}

	void SetNamespace (CComBSTR & bsNamespace)
	{
		m_bsNamespacePath = bsNamespace;
	}

	bool GetNamespace (CComBSTR & bsNamespace) const
	{
		bool result = false;

		if (m_bsNamespacePath)
		{
			bsNamespace = m_bsNamespacePath;
			result = true;
		}

		return result;
	}

	void SetLocale (CComBSTR & bsLocale)
	{
		m_bsLocale = bsLocale;
	}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\thrdpool.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  thrdpool.CPP
//
//  rajeshr  01-Jan-01   Created.
//
//  Thread Pool for handling ISAPI requests
//	The main reason we require a thread pool is that we need to do COM initialization on 
//	our own threads
//
//***************************************************************************

#ifndef WMI_SOAP_THRD_POOL_H
#define WMI_SOAP_THRD_POOL_H

class CTask
{
public:
	LPEXTENSION_CONTROL_BLOCK m_pECB;

	void Execute();

	CTask(LPEXTENSION_CONTROL_BLOCK pECB);
	virtual ~CTask();
};

class CTaskQueue
{
public:
	CTaskQueue();
	virtual ~CTaskQueue();

	HRESULT Initialize(LONG cMaxTasks);
	HRESULT AddTask(CTask *pTask);
	CTask *RemoveTask();

private:
	// A Circular queue of tasks
	CTask **m_ppTasks; // [0..m_cMaxTasks-1]
	LONG m_cMaxTasks;
	LONG m_iHead;
	LONG m_iTail;

	// A critical section to protect the book keeping variables
	CRITICAL_SECTION m_csQueueProtector;
};
class CThreadPool
{
	public:
		CThreadPool();
		virtual ~CThreadPool();

		HRESULT Initialize(LONG cNumberOfThreads, LONG cTaskQueueLength);
		HRESULT Terminate();

		HRESULT QueueTask(CTask *pTask);

	private:
		// A Monitoring Thread
		HANDLE m_oMonitorThread;

		// The count of worker thread handle
		LONG m_cNumberOfThreads;

		// The Worker threads
		HANDLE *m_pWorkerThreads;

		// The count of worker threads that are in the RESUMEd state, rather than SUSPENDED state
		LONG m_cNumberOfActiveThreads;
		
		// A boolean that gets set when the worker threads need to be shut down
		bool m_bShutDown;

		// A circular queue of tasks
		CTaskQueue m_oQueue;

		// A counted semaphore for waking up threads from the pool
		// when a new task exists
		HANDLE m_oSemaphore;

		// The Function called by the monitoring thread
		static DWORD WINAPI s_fMonitorProc(LPVOID lpParameter);

		// The Function called by the worker threads
		static DWORD WINAPI s_fWorkProc(LPVOID lpParameter);

		// A Function that makes the Worker threads exit gracefully
		void KillThreads();

};





#endif // WMI_SOAP_THRD_POOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\wmiopn.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMIOPN.CPP
//
//  alanbos  02-Nov-00   Created.
//
//  WMI operation implementation.  
//
//***************************************************************************

#include "precomp.h"

static char *pStrSOAPPreamble =
		"<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\">"
		"<SOAP-ENV:Body>";
		
static char *pStrSOAPPostamble =
		"</SOAP-ENV:Body>"
		"</SOAP-ENV:Envelope>";

static char *pStrClassStart = "<Class>";
static char *pStrClassEnd = "</Class>";

static char *pStrInstanceStart = "<Instance>";
static char *pStrInstanceEnd = "</Instance>";

static char *pStrObjectStart = "<Object>";
static char *pStrObjectEnd = "</Object>";

static char *pStrStartOpenTag = "<";
static char *pStrStartCloseTag = " xmlns=\""
							WMI_SOAP_NS
							"\">";

static char *pStartEmptyCloseTag = " xmlns=\""
							WMI_SOAP_NS
							"\"/>";

static char *pStrEndOpenTag = "</";
static char *pStrEndCloseTag = ">";

WMIOperation::WMIOperation (SOAPActor *pActor) :
	m_pWMIConnection (NULL),
	m_elementNest (0),
	m_parseState (Other),
	m_pActor (pActor),
	m_cRef (0)
{
	if (m_pActor)
		m_pActor->GetResponseStream (m_pIResponseStream);
}

STDMETHODIMP WMIOperation::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
		
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) WMIOperation::AddRef(void)
{
	InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) WMIOperation::Release(void)
{
	LONG cRef = InterlockedDecrement(&m_cRef);

    if (0L!=cRef)
        return cRef;

    delete this;
    return 0;
}

WMIOperation *WMIOperation::GetOperationHandler (
			SOAPActor *pActor,
			const wchar_t *pwchOperationName,
			bool & bIsSupported
			)
{
	bIsSupported = false;
	WMIOperation *pWmiOperation = NULL;

	if (pwchOperationName)
	{
		if (0 == wcscmp (WMI_OPERATION_GET_OBJECT, pwchOperationName))
		{
			bIsSupported = true;
			pWmiOperation = new WMIGetObjectOperation (pActor);
		}
		else if (0 == wcscmp (WMI_OPERATION_EXEC_QUERY, pwchOperationName))
		{
			bIsSupported = true;
			pWmiOperation = new WMIExecQueryOperation (pActor);
		}
		else if (0 == wcscmp (WMI_OPERATION_GET_CLASSES, pwchOperationName))
		{
			bIsSupported = true;
			pWmiOperation = new WMIGetClassesOperation (pActor);
		}
		else if (0 == wcscmp (WMI_OPERATION_GET_INSTANCES, pwchOperationName))
		{
			bIsSupported = true;
			pWmiOperation = new WMIGetInstancesOperation (pActor);
		}
		else if (0 == wcscmp (WMI_OPERATION_DELETE_CLASS, pwchOperationName))
		{
			bIsSupported = true;
			pWmiOperation = new WMIDeleteClassOperation (pActor);
		}
		else if (0 == wcscmp (WMI_OPERATION_DELETE_INSTANCE, pwchOperationName))
		{
			bIsSupported = true;
			pWmiOperation = new WMIDeleteInstanceOperation (pActor);
		}
	}

	if (pWmiOperation)
		pWmiOperation->AddRef ();

	return pWmiOperation;
}

void WMIOperation::Execute ()
{
	if (m_pIResponseStream)
	{
		CComPtr<IWbemServices> pIWbemServices;
		GetIWbemServices(pIWbemServices);
		// This is set if we hit an error in mid-response
		bool bOperationErrorInProgress = false;

		if (pIWbemServices)
		{
			HRESULT hr = PrepareRequest ();

			if (SUCCEEDED(hr))
			{
				HRESULT hr = BeginRequest (pIWbemServices);

				/*
				 * At this point we have not yet sent anything
				 * back to the client. The next call will
				 * be the first to stream information back to the client.
				 */
				if (PrepareResponse (hr))
				{
					if (SUCCEEDED (hr))
					{
						if (ResponseHasContent ())
						{
							if (SendOperationStartTag ())
							{
								if (SUCCEEDED(ProcessRequest ()))
								{
									if (!SendOperationEndTag ())
									{
										// Failure mid-response
										bOperationErrorInProgress = true;
									}
								}
								else
								{
									// Failure mid-response
									bOperationErrorInProgress = true;
								}
							}
							else
							{
								// Failure mid-response
								bOperationErrorInProgress = true;
							}
						}
						else
						{
							if (!SendOperationEmptyTag ())
							{
								// Failure mid-response
								bOperationErrorInProgress = true;
							}
						}
					}
					else
					{
						// Nothing else to do except complete the response (below)
					}
				}
				else
				{
					// Initial PrepareResponse failed
					bOperationErrorInProgress = true;
				}
			}
			else
			{
				// Signal to the client that the operation failed (very early on)
				if (!PrepareResponse (hr))
				{
					// Failure mid-response
					bOperationErrorInProgress = true;
				}
			}
		}
		else
		{
			if (!PrepareResponse (GetConnectionStatus()))
			{
				// Failure mid-response
				bOperationErrorInProgress = true;
			}
		}

		// If no hitches thus far, complete the response to the client
		if (!bOperationErrorInProgress)
			bOperationErrorInProgress = !CompleteResponse ();
		
		if (bOperationErrorInProgress)
		{
			// Something went awry - log the error and try to signal this to the client
			if (m_pActor)
			{
				// TODO - log the error
				if (!m_pActor->AbortResponse ())
				{
					// Oh lummee we are in deep do-do. Try and log it then
					// TODO - log the error
				}

			}
		}
	}
	else
	{
		// Can't even write back - nothing to do!
		// TODO - log the error
	}
}

bool WMIOperation::SendOperationStartTag ()
{
	bool result = false;
	LPCSTR pStrOperation = GetOperationResponseName ();

	if (pStrOperation)
	{
		if (SUCCEEDED(m_pIResponseStream->Write (pStrStartOpenTag, strlen(pStrStartOpenTag), NULL)) &&
			SUCCEEDED(m_pIResponseStream->Write (pStrOperation, strlen(pStrOperation), NULL)) &&
			SUCCEEDED(m_pIResponseStream->Write (pStrStartCloseTag, strlen(pStrStartCloseTag), NULL)))
			result = true;
	}

	return result;
}

bool WMIOperation::SendOperationEmptyTag ()
{
	bool result = false;
	LPCSTR pStrOperation = GetOperationResponseName ();

	if (pStrOperation)
	{
		if (SUCCEEDED(m_pIResponseStream->Write (pStrStartOpenTag, strlen(pStrStartOpenTag), NULL)) &&
			SUCCEEDED(m_pIResponseStream->Write (pStrOperation, strlen(pStrOperation), NULL)) &&
			SUCCEEDED(m_pIResponseStream->Write (pStartEmptyCloseTag, strlen(pStartEmptyCloseTag), NULL)))
			result = true;
	}

	return result;
}

bool WMIOperation::SendOperationEndTag ()
{
	bool result = false;
	LPCSTR pStrOperation = GetOperationResponseName ();

	if (pStrOperation)
	{
		if (SUCCEEDED(m_pIResponseStream->Write (pStrEndOpenTag, strlen(pStrEndOpenTag), NULL)) &&
			SUCCEEDED(m_pIResponseStream->Write (pStrOperation, strlen(pStrOperation), NULL)) &&
			SUCCEEDED(m_pIResponseStream->Write (pStrEndCloseTag, strlen(pStrEndCloseTag), NULL)))
			result = true;
	}

	return result;
}

bool WMIOperation::PrepareResponse (HRESULT hr)
{
	bool bSentOK = false;

	if (m_pActor)
	{
		// NB: The assigment is intended here
		if (bSentOK = m_pActor->SendServerStatus (SUCCEEDED(hr)))
		{
			// Send the preamble
			if (SUCCEEDED(m_pIResponseStream->Write (pStrSOAPPreamble, strlen (pStrSOAPPreamble), NULL)))
			{
				if (FAILED(hr))
				{
					// Send the fault
					// TODO - just fake it for now
					char *pFaultMsg1 =
							"<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">"
							"<Body>"
							"<Fault>"
							"<faultcode>Client</faultcode>"
							"<faultstring>";
					
					char faultMsg2 [10];
					sprintf (faultMsg2, "%x", hr);

					char *pFaultMsg3 = 
							"</faultstring>"
							"</Fault>"
							"</Body>"
							"</Envelope>";

					if (FAILED(m_pIResponseStream->Write (pFaultMsg1, strlen(pFaultMsg1), NULL)) ||
						FAILED(m_pIResponseStream->Write (faultMsg2, strlen(faultMsg2), NULL)) ||
						FAILED(m_pIResponseStream->Write (pFaultMsg3, strlen(pFaultMsg3), NULL)))
						bSentOK = false;
				}
			}
			else
				bSentOK = false;
		}
	}

	return bSentOK;
}

bool WMIOperation::CompleteResponse ()
{
	// Send the postamble
	return (SUCCEEDED(m_pIResponseStream->Write (pStrSOAPPostamble, strlen (pStrSOAPPostamble), NULL)));
}

HRESULT STDMETHODCALLTYPE WMIOperation::startElement( 
      const wchar_t __RPC_FAR *pwchNamespaceUri,
      int cchNamespaceUri,
      const wchar_t __RPC_FAR *pwchLocalName,
      int cchLocalName,
      const wchar_t __RPC_FAR *pwchRawName,
      int cchRawName,
      ISAXAttributes __RPC_FAR *pAttributes)
{
	HRESULT result = E_FAIL;
	m_elementNest++;

	// We are only interested in second-level elements (i.e. the 
	// parameter names) where level 1 == operation name header
	if (2 == m_elementNest)
	{
		// Handle the "standard parameters" here
		if (0 == wcscmp(WMI_PARAMETER_NAMESPACE, pwchLocalName))
		{
			// following content will be the value of the namespace
			m_parseState = Namespace;
			result = S_OK;
		}
		else if (0 == wcscmp(WMI_PARAMETER_CONTEXT, pwchLocalName))
		{
			// following content will be the value of the context
			m_parseState = Context;
		}
		else if (0 == wcscmp(WMI_PARAMETER_LOCALE, pwchLocalName))
		{
			// following content will be the value of the locale
			m_parseState = Locale;
		}
		else if (ProcessElement (pwchNamespaceUri, cchNamespaceUri, pwchLocalName, 
									cchLocalName, pwchRawName, cchRawName, pAttributes))
		{
			// Recognized and handled by the operation-specific subclass
			result = S_OK;
		}
		else
		{
			m_parseState = Other;

			// For anything else, all we care about is whether 
			// the SOAP:mustUnderstand attribute is present or not
			if (!SOAPActor::MustUnderstand (pAttributes)) 
				result = S_OK;
		}
	}
	else
	{
		// Ignore subcontent
		result = S_OK;
	}

	return result;
}

HRESULT STDMETHODCALLTYPE WMIOperation::characters (
        const unsigned short * pwchChars,
        int cchChars )
{
	HRESULT result = S_OK;

	// We are only interested in second-level elements (i.e. the 
	// parameter names) where level 1 == operation name header
	if (2 == m_elementNest)
	{
		if (Namespace == m_parseState)
		{
			CComBSTR bsNamespace = SysAllocStringLen (pwchChars, cchChars);

			if (!m_pWMIConnection)
				m_pWMIConnection = new WMIConnection (bsNamespace, NULL);
			else
				m_pWMIConnection->SetNamespace (bsNamespace);
		}
		else if (Locale == m_parseState)
		{
			CComBSTR bsLocale = SysAllocStringLen (pwchChars, cchChars);

			if (!m_pWMIConnection)
				m_pWMIConnection = new WMIConnection (NULL, bsLocale);
			else
				m_pWMIConnection->SetLocale (bsLocale);
		}
		else if (Context == m_parseState)
		{
			// TODO
		}
		else
			result = (ProcessContent (pwchChars, cchChars)) ? S_OK : E_FAIL;
	}

	return result;
}

HRESULT STDMETHODCALLTYPE WMIOperation::endElement (
        const wchar_t * pwchNamespaceUri,
        int cchNamespaceUri,
        const wchar_t * pwchLocalName,
        int cchLocalName,
        const wchar_t * pwchQName,
        int cchQName )
{
	HRESULT hr = S_OK;

	// If we have popped the stack, return control to the parent handler
	if (0 == --m_elementNest)
	{
		if (m_pActor)
			hr = m_pActor->RestoreContentHandler ();
		else
			hr = E_FAIL;
	}

	return hr;
}

HRESULT WMIEncodingOperation::PrepareRequest (void)
{
	HRESULT hr = WBEM_E_FAILED;

	CComBSTR bsRootXMLNamespace;

	// Build up the root URL for all schema's
	if (SUCCEEDED(hr = GetRootXMLNamespace (bsRootXMLNamespace)))
	{
		CComBSTR bsWmiNamespace;

		if (GetWMINamespace (bsWmiNamespace))
		{
			m_bsRootSchemaURI.Set (bsRootXMLNamespace, bsWmiNamespace);
			
			if (m_bsRootSchemaURI.GetURIForNamespace (m_bsXMLNamespace))
			{
				// Set the default targetNamespace for every schema we might return
				hr = m_pIWMIXMLConverter->SetXMLNamespace (
								m_bsXMLNamespace, 
								NULL);
			}
		}
	}

	return hr;
}

	
HRESULT WMIEncodingOperation::EncodeAndSendClass (
	CComPtr<IWbemClassObject> & pIWbemClassObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pIResponseStream && m_pIWMIXMLConverter)
	{
		m_pIResponseStream->Write (pStrClassStart, strlen (pStrClassStart), NULL);
		CComVariant varValue;
		// NB: We let the WMI standard target namespace default
			
		// Clear any existing schemaLocation
		hr = m_pIWMIXMLConverter->SetSchemaLocations (0, NULL);

		// Set schemaLocation values for include of SUPERCLASS
		if (SUCCEEDED(pIWbemClassObject->Get (L"__SUPERCLASS", 0, &varValue, NULL, NULL)) &&
						(VT_BSTR == varValue.vt) && (NULL != varValue.bstrVal))
		{
			CComBSTR bsXMLNamespace;
			BSTR strSchemaLoc[1];
			
			if (m_bsRootSchemaURI.GetURIForClass (varValue.bstrVal, bsXMLNamespace))
			{
				// Note this string will be freed by the destructor of CComBSTR
				strSchemaLoc[0] = bsXMLNamespace.m_str;
		
				if (SUCCEEDED(hr = m_pIWMIXMLConverter->SetSchemaLocations (1, strSchemaLoc)))
					hr = m_pIWMIXMLConverter->GetXMLForObject (pIWbemClassObject, 0, m_pIResponseStream);
			}
		}
		
		m_pIResponseStream->Write (pStrClassEnd, strlen (pStrClassEnd), NULL);
	}

	return hr;
}

HRESULT WMIEncodingOperation::EncodeAndSendObject (
	CComPtr<IWbemClassObject> & pIWbemClassObject
)
{
	HRESULT hr = WBEM_E_FAILED;
	
	// Is this a class or an instance?
	CComVariant varValue;

	if (SUCCEEDED(pIWbemClassObject->Get (L"__GENUS", 0, &varValue, NULL, NULL)))
	{
		if (WBEM_GENUS_CLASS == varValue.lVal)
			hr = EncodeAndSendClass (pIWbemClassObject);
		else
			hr = EncodeAndSendInstance (pIWbemClassObject);
	}
	else
	{
		// No idea - take a wild guess!
		// TODO
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\wmisoap.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  WMISOAP.CPP
//
//  alanbos  27-Oct-00   Created.
//
//  The main entry point for the WMI SOAP ISAPI extension.  
//
//***************************************************************************

#include "precomp.h"

// The Global Thread Pool that is used for handling requests
// After numerous exchange of emails with the IIS guys, it has been decided that we need
// to use a thread pool for handling requests. Wonder why they do not
// provide it themselves.
CThreadPool g_oThreadPool;

// Number of threads in the pool
LONG g_iNumberOfThreads = 4;

// Queue length of the task queue in the thread pool - typically 2*g_iNumberOfThreads
LONG g_iQueueLength = 8;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  
//
//  PARAMETERS:
//
//		hModule           instance handle
//		ulReason          why we are being called
//		pvReserved        reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************
BOOL WINAPI DllMain( HINSTANCE hModule, 
                       DWORD  ulReason, 
                       LPVOID lpReserved
					 )
{
    switch (ulReason)
	{
		case DLL_PROCESS_ATTACH:
			// DisableThreadLibraryCalls (hModule);
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;

		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}

//***************************************************************************
//
//  BOOL WINAPI GetExtensionVersion
//
//  DESCRIPTION:
//
//  Called once by IIS to get version information.  Of little consequence.
//
//  PARAMETERS:
//
//		pVer			pointer to a HSE_VERSION_INFO structure that
//						will hold the version info.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pVer)
{
	pVer->dwExtensionVersion = MAKELONG(1, 0);
    strcpy(pVer->lpszExtensionDesc, "WMI XML/SOAP ISAPI Extension"); 

	// Initialize the Thread Pool that will handle the queued requests
	if(FAILED(g_oThreadPool.Initialize(g_iNumberOfThreads, g_iQueueLength)))
		return FALSE;
	return TRUE;
}

//***************************************************************************
//
//  BOOL WINAPI HttpExtensionProc
//
//  DESCRIPTION:
//
//  Called once by IIS to service a single HTTP request.
//
//  PARAMETERS:
//
//		pECB			pointer to a EXTENSION_CONTROL_BLOCK structure that
//						will hold the request.
//
//  RETURN VALUE:
//
//		HSE_STATUS_SUCCESS	request has been processed
//
//	NOTES:
//		
//		Status codes are set in the dwHttpStatusCode field of the ECB
//
//***************************************************************************
DWORD WINAPI HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pECB)
{
	bool bSuccess = false;
	try 
	{
		// Just queue the task on to the thread pool
		CTask * pTask = NULL;
		if(pTask = new CTask(pECB))
		{
			if(SUCCEEDED(g_oThreadPool.QueueTask(pTask)))
				bSuccess = true;
		}


	}
	catch (...) {}

	if(!bSuccess)
	{
		// Send a 500 internal server error
		// We could not successfully enqueue a task.
		// Hence the task queue is full.
		// rajeshr : This means we should send a specific HTTP code
	}
	return HSE_STATUS_PENDING;
}
	
//***************************************************************************
//
//  BOOL WINAPI TerminateExtension
//
//  DESCRIPTION:
//
//		Called once by IIS to unload the extension.
//
//  PARAMETERS:
//
//		dwFlags		determines nature of request (advisory or mandatory) 
//
//  RETURN VALUE:
//
//		TRUE (always agree to an unload for now)
//
//***************************************************************************
BOOL WINAPI TerminateExtension(DWORD dwFlags  )
{
	// Shut down the threads in the thread pool graciously
	g_oThreadPool.Terminate();

	// We need to unload the COM DLLs that we loaded in this extension
	CoFreeUnusedLibraries();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\wmiopn.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmiopn.h
//
//  alanbos  02-Nov-00   Created.
//
//  Defines the abstract base class for WMI operation handlers.
//
//***************************************************************************

#ifndef _WMIOPN_H_
#define _WMIOPN_H_

// Operation names
#define WMI_OPERATION_DELETE_CLASS		L"DeleteClass"
#define WMI_OPERATION_DELETE_INSTANCE	L"DeleteInstance"
#define WMI_OPERATION_GET_OBJECT		L"GetObject"
#define WMI_OPERATION_PUT_CLASS			L"PutClass"
#define WMI_OPERATION_PUT_INSTANCE		L"PutInstance"
#define WMI_OPERATION_EXEC_QUERY		L"ExecQuery"
#define WMI_OPERATION_GET_CLASSES		L"GetClasses"
#define WMI_OPERATION_GET_INSTANCES		L"GetInstances"


// Common parameter names
#define WMI_PARAMETER_NAMESPACE			L"Namespace"
#define WMI_PARAMETER_LOCALE			L"Locale"
#define WMI_PARAMETER_CONTEXT			L"Context"

//***************************************************************************
//
//  CLASS NAME:
//
//  WMIOperation
//
//  DESCRIPTION:
//
//  Abstract WMI Operation handler.
//
//***************************************************************************

class WMIOperation : public ISAXContentHandler
{
private:
	const static int			wmiOperationState = 0x10;

	typedef enum OperationParseState {
		Namespace = 0,			// Namespace element
		Locale,					// Locale element
		Context,				// Context element 
		Other					// Other
	};

	LONG						m_cRef;
	WMIConnection				*m_pWMIConnection;
	CComPtr<IWbemLocator>		m_pIWbemLocator;
	CComPtr<IWbemContext>		m_pIWbemContext;
	CComPtr<IWbemClassObject>	m_pWMIErrorObject;
	CComPtr<IStream>			m_pIResponseStream;
	SOAPActor					*m_pActor;
	LONG						m_headerNest;
	LONG						m_elementNest;
	int							m_parseState;

	void Initialize ();

	void SetContext (CComPtr<IWbemContext> & pIWbemContext)
	{
		m_pIWbemContext = pIWbemContext;
	}

	bool	PrepareResponse (HRESULT hr);
	bool	CompleteResponse ();

	bool	SendOperationStartTag ();
	bool	SendOperationEndTag ();
	bool	SendOperationEmptyTag ();

	HRESULT	GetConnectionStatus () const
	{
		return (m_pWMIConnection) ? m_pWMIConnection->GetConnectionStatus() :
									WBEM_E_FAILED;
	}

protected:
	WMIOperation(SOAPActor *pActor);

	// BeginRequest should get as far as determining initial success/failure
	virtual HRESULT BeginRequest (CComPtr<IWbemServices> & pIWbemServices) = 0;

	// ProcessRequest should perform any remaining processing
	virtual HRESULT ProcessRequest (void) 
	{
		return S_OK;
	}

	// PrepareRequest should intialize any data that is dependent on the whole
	// request being parsed, but not execute the request
	virtual HRESULT	PrepareRequest (void) 
	{
		return S_OK;
	}

	// The name of the operation as it appears in the SOAP payload
	virtual LPCSTR GetOperationResponseName (void) = 0;

	// Whether this response has any content
	virtual bool ResponseHasContent (void)
	{
		return true;
	}

	virtual bool ProcessElement (      
				const wchar_t __RPC_FAR *pwchNamespaceUri,
				int cchNamespaceUri,
				const wchar_t __RPC_FAR *pwchLocalName,
				int cchLocalName,
				const wchar_t __RPC_FAR *pwchRawName,
				int cchRawName,
				ISAXAttributes __RPC_FAR *pAttributes) = 0;

	virtual bool ProcessContent (        
				const unsigned short * pwchChars,
				int cchChars ) = 0;

	// Used for operation-specific parse state
	void	SetParseState (int parseState)
	{
		m_parseState = parseState | wmiOperationState;
	}

	int		GetParseState (void) const
	{
		return (m_parseState & ~wmiOperationState);
	}

	void	GetResponseStream (CComPtr<IStream> & pIStream)
	{
		pIStream = m_pIResponseStream;
	}

	HRESULT	SetContentHandler (CComPtr<ISAXContentHandler> & pISAXContentHandler)
	{
		HRESULT hr = E_FAIL;

		if (m_pActor)
			hr = m_pActor->SetContentHandler (pISAXContentHandler);

		return hr;
	}

	HRESULT	RestoreContentHandler ()
	{
		HRESULT hr = E_FAIL;

		if (m_pActor)
			hr = m_pActor->RestoreContentHandler ();

		return hr;
	}

	void GetIWbemServices (CComPtr<IWbemServices> & pIWbemServices) const
	{
		if (m_pWMIConnection)
			m_pWMIConnection->GetIWbemServices(pIWbemServices);
	}

	bool GetWMINamespace (CComBSTR & bsNamespace) const
	{
		return (m_pWMIConnection) ? m_pWMIConnection->GetNamespace(bsNamespace) : false;
	}

	HRESULT GetRootXMLNamespace (CComBSTR & bsNamespace) const
	{
		HRESULT hr = E_FAIL;

		if (m_pActor)
			hr = m_pActor->GetRootXMLNamespace (bsNamespace);

		return hr;
	}

public:
	virtual ~WMIOperation () 
	{
		if (m_pWMIConnection)
		{
			m_pWMIConnection->Release ();
			m_pWMIConnection = NULL;
		}
	}

	// IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// ISAXContentHandler methods
	STDMETHODIMP putDocumentLocator (ISAXLocator * pLocator) 
	{ return S_OK; }

    STDMETHODIMP startDocument ( )
	{ return S_OK; }

    STDMETHODIMP endDocument ( )
	{ return S_OK; }

    STDMETHODIMP startPrefixMapping (
        const unsigned short * pwchPrefix,
        int cchPrefix,
        const unsigned short * pwchUri,
        int cchUri )
	{ return S_OK; }
	
    STDMETHODIMP endPrefixMapping (
        const unsigned short * pwchPrefix,
        int cchPrefix )
	{ return S_OK; }

    STDMETHODIMP startElement (
        const unsigned short * pwchNamespaceUri,
        int cchNamespaceUri,
        const unsigned short * pwchLocalName,
        int cchLocalName,
        const unsigned short * pwchQName,
        int cchQName,
        ISAXAttributes * pAttributes );

    STDMETHODIMP endElement (
        const unsigned short * pwchNamespaceUri,
        int cchNamespaceUri,
        const unsigned short * pwchLocalName,
        int cchLocalName,
        const unsigned short * pwchQName,
        int cchQName );

    STDMETHODIMP characters (
        const unsigned short * pwchChars,
        int cchChars );

    STDMETHODIMP ignorableWhitespace (
        const unsigned short * pwchChars,
        int cchChars )
	{ return S_OK; }

    STDMETHODIMP processingInstruction (
        const unsigned short * pwchTarget,
        int cchTarget,
        const unsigned short * pwchData,
        int cchData )
	{ return S_OK; }

    STDMETHODIMP skippedEntity (
        const unsigned short * pwchName,
        int cchName )
	{ return S_OK; }

	// Other methods
	static WMIOperation *GetOperationHandler (
			SOAPActor *pActor, 
			const wchar_t *pwchOperationName, 
			bool &bIsSupported
			);

	CComPtr<IWbemContext> & GetContext () const
	{
		return (CComPtr<IWbemContext> &) m_pIWbemContext; 
	}

	CComPtr<IWbemClassObject>	& GetErrorObject () const
	{
		return (CComPtr<IWbemClassObject> &) m_pWMIErrorObject;
	}

	void SetErrorObject (IWbemClassObject *pWMIErrorObject)
	{
		m_pWMIErrorObject = pWMIErrorObject;
	}

	void Execute ();
};


//***************************************************************************
//
//  CLASS NAME:
//
//  WMIEncodingOperation
//
//  DESCRIPTION:
//
//  Abstract WMI Operation handler for all encoding operations.
//
//***************************************************************************

class WMIEncodingOperation : public WMIOperation
{
private:
	CComPtr<IWMIXMLConverter>	m_pIWMIXMLConverter;
	CComPtr<IStream>			m_pIResponseStream;
	CWmiURI						m_bsRootSchemaURI;
	CComBSTR					m_bsXMLNamespace;

protected:
	HRESULT	EncodeAndSendClass (
		CComPtr<IWbemClassObject> & pIWbemClassObject
	);

	HRESULT EncodeAndSendInstance (
		CComPtr<IWbemClassObject> & pIWbemClassObject
	)
	{
		return WBEM_E_FAILED;
	}

	HRESULT EncodeAndSendObject (
		CComPtr<IWbemClassObject> & pIWbemClassObject
	);

	// overridden from WMIOperation
	HRESULT	PrepareRequest (void);

public:
	WMIEncodingOperation (SOAPActor *pActor) : WMIOperation (pActor) 
	{
		GetResponseStream (m_pIResponseStream);

		HRESULT hr = CoCreateInstance(
			CLSID_WMIXMLConverter,
			NULL, 
			CLSCTX_INPROC_SERVER ,
			IID_IWMIXMLConverter,
			(void **)&m_pIWMIXMLConverter);
	}

	~WMIEncodingOperation () {};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\wmiuri.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  wmiuri.h
//
//  alanbos  28-Nov-00   Created.
//
//  A WMI URI helper.
//
//***************************************************************************

#ifndef _WMIURI_H_
#define _WMIURI_H_

/***************************************************************************
//
//  CLASS NAME:
//
//  CWmiURI
//
//  DESCRIPTION:
//
//  IWmiDeserializer implementation. 
//
//***************************************************************************/

class CWmiURI 
{
private:
	CComBSTR	m_bsRootURI;
	bool		m_bOK;

	static void	NormalizeSlashes (wchar_t *pwsPath)
	{
		if (pwsPath)
		{
			// Make sure we map "\" to "/"
			size_t nsLen = wcslen (pwsPath);

			for (size_t i = 0; i < nsLen; i++)
			{
				if (L'\\' == pwsPath [i])
					pwsPath [i] = L'/';
			}
		}
	}

public:
	CWmiURI(CComBSTR const & bsRootURI, CComBSTR & bsWMINamespace) 
		: m_bOK (false)
	{
		Set (bsRootURI, bsWMINamespace);
	}

	CWmiURI () :
		m_bOK (false)
	{}

	virtual ~CWmiURI() {}

	void Set (CComBSTR const & bsRootURI, CComBSTR & bsWMINamespace)
	{
		if (bsRootURI)
		{
			m_bsRootURI = bsRootURI;

			if (bsWMINamespace)
			{
				NormalizeSlashes (bsWMINamespace);
				m_bsRootURI += L"?path=";
				m_bsRootURI += bsWMINamespace;
				m_bOK = true;
			}
		}
	}

	bool	GetURIForClass(CComBSTR const & bsClassName, CComBSTR & bsClassURI) const
	{
		bool result = false;

		if (m_bOK)
		{
			if (bsClassName && (0 < wcslen (bsClassName)))
			{
				bsClassURI = m_bsRootURI;
				bsClassURI += L":";
				bsClassURI += bsClassName;
				result = true;
			}
		}

		return result;
	}

	bool	GetURIForNamespace(CComBSTR & bsNamespaceURI) const
	{
		bool result = false;

		if (m_bOK)
		{
			bsNamespaceURI = m_bsRootURI;
				result = true;
		}

		return result;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\wmisoap.h ===
#ifndef WMISOAP
#define WMISOAP

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the WMISOAP_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// WMISOAP_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef WMISOAP_EXPORTS
#define WMISOAP_API __declspec(dllexport)
#else
#define WMISOAP_API __declspec(dllimport)
#endif

// The value of the HTTP SOAPAction header for WMI operations
#define HTTP_WMI_SOAP_ACTION		"http://www.microsoft.com/wmi/soap/1.0"

// The XML namespace to be used to tag WMI operations in the SOAP body
#define WMI_SOAP_NS					HTTP_WMI_SOAP_ACTION		

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\msxml3\inc\msxml2did.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*         Copyright (c) 1996 - 1999 Microsoft Corporation. All rights reserved.**///*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __MSXML2DID_H__
#define __MSXML2DID_H__
//;end_internal

#define DISPID_XOBJ_MIN                 0x00010000
#define DISPID_XOBJ_MAX                 0x0001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN


#define DISPID_XMLELEMENTCOLLECTION             DISPID_XOBJ_BASE

#define DISPID_XMLELEMENTCOLLECTION_LENGTH     DISPID_XMLELEMENTCOLLECTION + 1
#define DISPID_XMLELEMENTCOLLECTION_NEWENUM     DISPID_NEWENUM
#define DISPID_XMLELEMENTCOLLECTION_ITEM        DISPID_XMLELEMENTCOLLECTION + 3


#define DISPID_XMLDOCUMENT                      DISPID_XMLELEMENTCOLLECTION + 100

#define DISPID_XMLDOCUMENT_ROOT                 DISPID_XMLDOCUMENT + 1
#define DISPID_XMLDOCUMENT_FILESIZE             DISPID_XMLDOCUMENT + 2
#define DISPID_XMLDOCUMENT_FILEMODIFIEDDATE     DISPID_XMLDOCUMENT + 3
#define DISPID_XMLDOCUMENT_FILEUPDATEDDATE      DISPID_XMLDOCUMENT + 4
#define DISPID_XMLDOCUMENT_URL                  DISPID_XMLDOCUMENT + 5
#define DISPID_XMLDOCUMENT_MIMETYPE             DISPID_XMLDOCUMENT + 6
#define DISPID_XMLDOCUMENT_READYSTATE           DISPID_XMLDOCUMENT + 7
#define DISPID_XMLDOCUMENT_CREATEELEMENT        DISPID_XMLDOCUMENT + 8
#define DISPID_XMLDOCUMENT_CHARSET              DISPID_XMLDOCUMENT + 9
#define DISPID_XMLDOCUMENT_VERSION              DISPID_XMLDOCUMENT + 10
#define DISPID_XMLDOCUMENT_DOCTYPE              DISPID_XMLDOCUMENT + 11
#define DISPID_XMLDOCUMENT_DTDURL               DISPID_XMLDOCUMENT + 12
#define DISPID_XMLDOCUMENT_ASYNC                DISPID_XMLDOCUMENT + 13
#define DISPID_XMLDOCUMENT_CASEINSENSITIVE      DISPID_XMLDOCUMENT + 14
#define DISPID_XMLDOCUMENT_BASEURL              DISPID_XMLDOCUMENT + 15
#define DISPID_XMLDOCUMENT_XML                  DISPID_XMLDOCUMENT + 16
#define DISPID_XMLDOCUMENT_LASTERROR            DISPID_XMLDOCUMENT + 17
#define DISPID_XMLDOCUMENT_TRIMWHITESPACE       DISPID_XMLDOCUMENT + 18
#define DISPID_XMLDOCUMENT_COMMIT				DISPID_XMLDOCUMENT + 19

#define DISPID_XMLELEMENT                       DISPID_XMLDOCUMENT + 100

#define DISPID_XMLELEMENT_TAGNAME               DISPID_XMLELEMENT + 1
#define DISPID_XMLELEMENT_PARENT                DISPID_XMLELEMENT + 2
#define DISPID_XMLELEMENT_SETATTRIBUTE          DISPID_XMLELEMENT + 3
#define DISPID_XMLELEMENT_GETATTRIBUTE          DISPID_XMLELEMENT + 4
#define DISPID_XMLELEMENT_REMOVEATTRIBUTE       DISPID_XMLELEMENT + 5
#define DISPID_XMLELEMENT_CHILDREN              DISPID_XMLELEMENT + 6
#define DISPID_XMLELEMENT_TYPE                  DISPID_XMLELEMENT + 7
#define DISPID_XMLELEMENT_TEXT                  DISPID_XMLELEMENT + 8
#define DISPID_XMLELEMENT_ADDCHILD              DISPID_XMLELEMENT + 9
#define DISPID_XMLELEMENT_REMOVECHILD           DISPID_XMLELEMENT + 10
#define DISPID_XMLELEMENT_ATTRIBUTES            DISPID_XMLELEMENT + 11

#define DISPID_XMLNOTIFSINK                     DISPID_XMLELEMENT + 100 

#define DISPID_XMLNOTIFSINK_CHILDADDED          DISPID_XMLNOTIFSINK + 1

#define DISPID_XMLATTRIBUTE                     DISPID_XMLNOTIFSINK + 100

#define DISPID_XMLATTRIBUTE_NAME                DISPID_XMLATTRIBUTE + 1
#define DISPID_XMLATTRIBUTE_VALUE               DISPID_XMLATTRIBUTE + 2


// IXMLError2
#define DISPID_XMLERROR                         DISPID_XMLNOTIFSINK + 100
#define DISPID_XMLERROR_REASON                  DISPID_XMLERROR + 1
#define DISPID_XMLERROR_LINE                    DISPID_XMLERROR + 2
#define DISPID_XMLERROR_POS                     DISPID_XMLERROR + 3

// INode
#define DISPID_NODE                             DISPID_XMLERROR + 100
#define DISPID_NODE_NAME                        DISPID_NODE + 1
#define DISPID_NODE_PARENT                      DISPID_NODE + 2
#define DISPID_NODE_TYPE                        DISPID_NODE + 3

#define DISPID_NODE_VALUE                       DISPID_NODE + 4

#define DISPID_NODE_SETATTRIBUTE                DISPID_NODE + 5
#define DISPID_NODE_GETATTRIBUTE                DISPID_NODE + 6
#define DISPID_NODE_REMOVEATTRIBUTE             DISPID_NODE + 7
#define DISPID_NODE_ATTRIBUTES                  DISPID_NODE + 8

#define DISPID_NODE_ADD                         DISPID_NODE + 9
#define DISPID_NODE_REMOVE                      DISPID_NODE + 10
#define DISPID_NODE_CHILDREN                    DISPID_NODE + 11

// INodeList
#define DISPID_NODELIST                         DISPID_NODE + 100
#define DISPID_NODELIST_NEWENUM                 DISPID_NODELIST + 1
#define DISPID_NODELIST_NEXT                    DISPID_NODELIST + 2
#define DISPID_NODELIST_CURRENT                 DISPID_NODELIST + 3
#define DISPID_NODELIST_MOVE                    DISPID_NODELIST + 4
#define DISPID_NODELIST_MOVETONODE              DISPID_NODELIST + 5

#define DISPID_NODELIST_LENGTH                  DISPID_NODELIST + 6
#define DISPID_NODELIST_ITEM                    DISPID_NODELIST + 7


// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

#define DISPID_XMLDOM_DOCUMENT2                    (DISPID_XMLDOMEVENT__TOP + 1)
#define DISPID_XMLDOM_DOCUMENT2_NAMESPACES         (DISPID_XMLDOM_DOCUMENT2 + 1)
#define DISPID_XMLDOM_DOCUMENT2_SCHEMAS            (DISPID_XMLDOM_DOCUMENT2 + 2)
#define DISPID_XMLDOM_DOCUMENT2_VALIDATE           (DISPID_XMLDOM_DOCUMENT2 + 3)
#define DISPID_XMLDOM_DOCUMENT2_SETPROPERTY        (DISPID_XMLDOM_DOCUMENT2 + 4)
#define DISPID_XMLDOM_DOCUMENT2_GETPROPERTY        (DISPID_XMLDOM_DOCUMENT2 + 5)
#define DISPID_XMLDOM_DOCUMENT2__TOP               (DISPID_XMLDOM_DOCUMENT2 + 6)

#define DISPID_XMLDOM_SCHEMACOLLECTION               (DISPID_DOM_BASE + 1)
#define DISPID_XMLDOM_SCHEMACOLLECTION_ADD           (DISPID_XMLDOM_SCHEMACOLLECTION + 1)
#define DISPID_XMLDOM_SCHEMACOLLECTION_GET           (DISPID_XMLDOM_SCHEMACOLLECTION + 2)
#define DISPID_XMLDOM_SCHEMACOLLECTION_REMOVE        (DISPID_XMLDOM_SCHEMACOLLECTION + 3)
#define DISPID_XMLDOM_SCHEMACOLLECTION_LENGTH        (DISPID_XMLDOM_SCHEMACOLLECTION + 4)
#define DISPID_XMLDOM_SCHEMACOLLECTION_NAMESPACEURI  (DISPID_XMLDOM_SCHEMACOLLECTION + 5)
#define DISPID_XMLDOM_SCHEMACOLLECTION_ADDCOLLECTION (DISPID_XMLDOM_SCHEMACOLLECTION + 6)
#define DISPID_XMLDOM_SCHEMACOLLECTION__TOP          (DISPID_XMLDOM_SCHEMACOLLECTION + 7)

#define DISPID_XMLDOM_SELECTION                    (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_XMLDOM_SELECTION_EXPR               (DISPID_XMLDOM_SELECTION + 1)
#define DISPID_XMLDOM_SELECTION_CONTEXT            (DISPID_XMLDOM_SELECTION + 2)
#define DISPID_XMLDOM_SELECTION_PEEKNODE           (DISPID_XMLDOM_SELECTION + 3)
#define DISPID_XMLDOM_SELECTION_MATCHES            (DISPID_XMLDOM_SELECTION + 4)
#define DISPID_XMLDOM_SELECTION_REMOVENEXT         (DISPID_XMLDOM_SELECTION + 5)
#define DISPID_XMLDOM_SELECTION_REMOVEALL          (DISPID_XMLDOM_SELECTION + 6)
#define DISPID_XMLDOM_SELECTION_CLONE              (DISPID_XMLDOM_SELECTION + 7)
#define DISPID_XMLDOM_SELECTION_GETPROPERTY        (DISPID_XMLDOM_SELECTION + 8)
#define DISPID_XMLDOM_SELECTION_SETPROPERTY        (DISPID_XMLDOM_SELECTION + 9)
#define DISPID_XMLDOM_SELECTION__TOP               (DISPID_XMLDOM_SELECTION + 10)

#define DISPID_XMLDOM_TEMPLATE                    (DISPID_DOM_BASE)
#define DISPID_XMLDOM_TEMPLATE_STYLESHEET         (DISPID_XMLDOM_TEMPLATE + 1)
#define DISPID_XMLDOM_TEMPLATE_CREATEPROCESSOR    (DISPID_XMLDOM_TEMPLATE + 2)
#define DISPID_XMLDOM_TEMPLATE__TOP               (DISPID_XMLDOM_TEMPLATE + 3)

#define DISPID_XMLDOM_PROCESSOR                    (DISPID_DOM_BASE)
#define DISPID_XMLDOM_PROCESSOR_INPUT              (DISPID_XMLDOM_PROCESSOR + 1)
#define DISPID_XMLDOM_PROCESSOR_XSLTEMPLATE        (DISPID_XMLDOM_PROCESSOR + 2)
#define DISPID_XMLDOM_PROCESSOR_SETSTARTMODE       (DISPID_XMLDOM_PROCESSOR + 3)
#define DISPID_XMLDOM_PROCESSOR_STARTMODE          (DISPID_XMLDOM_PROCESSOR + 4)
#define DISPID_XMLDOM_PROCESSOR_STARTMODEURI       (DISPID_XMLDOM_PROCESSOR + 5)
#define DISPID_XMLDOM_PROCESSOR_OUTPUT             (DISPID_XMLDOM_PROCESSOR + 6)
#define DISPID_XMLDOM_PROCESSOR_TRANSFORM          (DISPID_XMLDOM_PROCESSOR + 7)
#define DISPID_XMLDOM_PROCESSOR_RESET              (DISPID_XMLDOM_PROCESSOR + 8)
#define DISPID_XMLDOM_PROCESSOR_READYSTATE         (DISPID_XMLDOM_PROCESSOR + 9)
#define DISPID_XMLDOM_PROCESSOR_ADDPARAMETER       (DISPID_XMLDOM_PROCESSOR + 10)
#define DISPID_XMLDOM_PROCESSOR_ADDOBJECT          (DISPID_XMLDOM_PROCESSOR + 11)
#define DISPID_XMLDOM_PROCESSOR_STYLESHEET         (DISPID_XMLDOM_PROCESSOR + 12)
#define DISPID_XMLDOM_PROCESSOR__TOP               (DISPID_XMLDOM_PROCESSOR + 13)


#define  DISPID_XMLDSO                       DISPID_XOBJ_BASE
#define  DISPID_XMLDSO_DOCUMENT              DISPID_XMLDSO  +  1
#define  DISPID_XMLDSO_JAVADSOCOMPATIBLE     DISPID_XMLDSO_DOCUMENT  +  1


#define DISPID_SAX_XMLREADER__MIN                 0x00000501
#define DISPID_SAX_XMLREADER__MAX                 0x00010000
#define DISPID_SAX_XMLREADER__BASE                DISPID_SAX_XMLREADER__MIN

#define DISPID_SAX_XMLREADER (DISPID_SAX_XMLREADER__BASE)
#define DISPID_SAX_XMLREADER_GETFEATURE (DISPID_SAX_XMLREADER + 1)
#define DISPID_SAX_XMLREADER_PUTFEATURE (DISPID_SAX_XMLREADER + 2)
#define DISPID_SAX_XMLREADER_GETPROPERTY (DISPID_SAX_XMLREADER + 3)
#define DISPID_SAX_XMLREADER_PUTPROPERTY (DISPID_SAX_XMLREADER + 4)
#define DISPID_SAX_XMLREADER_ENTITYRESOLVER (DISPID_SAX_XMLREADER + 5)
#define DISPID_SAX_XMLREADER_CONTENTHANDLER (DISPID_SAX_XMLREADER + 6)
#define DISPID_SAX_XMLREADER_DTDHANDLER (DISPID_SAX_XMLREADER + 7)
#define DISPID_SAX_XMLREADER_ERRORHANDLER (DISPID_SAX_XMLREADER + 8)
#define DISPID_SAX_XMLREADER_BASEURL (DISPID_SAX_XMLREADER + 9)
#define DISPID_SAX_XMLREADER_SECUREBASEURL (DISPID_SAX_XMLREADER + 10)
#define DISPID_SAX_XMLREADER_PARSE (DISPID_SAX_XMLREADER + 11)
#define DISPID_SAX_XMLREADER_PARSEURL (DISPID_SAX_XMLREADER + 12)
#define DISPID_SAX_XMLREADER_PARENT (DISPID_SAX_XMLREADER + 13)
#define DISPID_SAX_XMLREADER__TOP (DISPID_SAX_XMLREADER + 14)

#define DISPID_SAX_XMLFILTER__BASE (DISPID_SAX_XMLREADER__TOP + 1)
#define DISPID_SAX_XMLFILTER (DISPID_SAX_XMLFILTER__BASE)
#define DISPID_SAX_XMLFILTER_GETFEATURE (DISPID_SAX_XMLFILTER + 1)
#define DISPID_SAX_XMLFILTER_PUTFEATURE (DISPID_SAX_XMLFILTER + 2)
#define DISPID_SAX_XMLFILTER_GETPROPERTY (DISPID_SAX_XMLFILTER + 3)
#define DISPID_SAX_XMLFILTER_PUTPROPERTY (DISPID_SAX_XMLFILTER + 4)
#define DISPID_SAX_XMLFILTER_ENTITYRESOLVER (DISPID_SAX_XMLFILTER + 5)
#define DISPID_SAX_XMLFILTER_CONTENTHANDLER (DISPID_SAX_XMLFILTER + 6)
#define DISPID_SAX_XMLFILTER_DTDHANDLER (DISPID_SAX_XMLFILTER + 7)
#define DISPID_SAX_XMLFILTER_ERRORHANDLER (DISPID_SAX_XMLFILTER + 8)
#define DISPID_SAX_XMLFILTER_BASEURL (DISPID_SAX_XMLFILTER + 9)
#define DISPID_SAX_XMLFILTER_SECUREBASEURL (DISPID_SAX_XMLFILTER + 10)
#define DISPID_SAX_XMLFILTER_PARSE (DISPID_SAX_XMLFILTER + 11)
#define DISPID_SAX_XMLFILTER_PARSEURL (DISPID_SAX_XMLFILTER + 12)
#define DISPID_SAX_XMLFILTER_PARENT (DISPID_SAX_XMLFILTER + 13)
#define DISPID_SAX_XMLFILTER__TOP (DISPID_SAX_XMLFILTER + 15)

#define DISPID_SAX_LOCATOR__BASE (DISPID_SAX_XMLFILTER__TOP + 1)
#define DISPID_SAX_LOCATOR (DISPID_SAX_LOCATOR__BASE)
#define DISPID_SAX_LOCATOR_COLUMNNUMBER (DISPID_SAX_LOCATOR + 1)
#define DISPID_SAX_LOCATOR_LINENUMBER (DISPID_SAX_LOCATOR + 2)
#define DISPID_SAX_LOCATOR_PUBLICID (DISPID_SAX_LOCATOR + 3)
#define DISPID_SAX_LOCATOR_SYSTEMID (DISPID_SAX_LOCATOR + 4)
#define DISPID_SAX_LOCATOR__TOP (DISPID_SAX_LOCATOR + 5)

#define DISPID_SAX_ENTITYRESOLVER__BASE (DISPID_SAX_LOCATOR__TOP + 1)
#define DISPID_SAX_ENTITYRESOLVER (DISPID_SAX_ENTITYRESOLVER__BASE)
#define DISPID_SAX_ENTITYRESOLVER_RESOLVEENTITY (DISPID_SAX_ENTITYRESOLVER + 1)
#define DISPID_SAX_ENTITYRESOLVER__TOP (DISPID_SAX_ENTITYRESOLVER + 2)

#define DISPID_SAX_CONTENTHANDLER__BASE (DISPID_SAX_ENTITYRESOLVER__TOP + 1)
#define DISPID_SAX_CONTENTHANDLER (DISPID_SAX_CONTENTHANDLER__BASE)
#define DISPID_SAX_CONTENTHANDLER_DOCUMENTLOCATOR (DISPID_SAX_CONTENTHANDLER + 1)
#define DISPID_SAX_CONTENTHANDLER_STARTDOCUMENT (DISPID_SAX_CONTENTHANDLER + 2)
#define DISPID_SAX_CONTENTHANDLER_ENDDOCUMENT (DISPID_SAX_CONTENTHANDLER + 3)
#define DISPID_SAX_CONTENTHANDLER_STARTPREFIXMAPPING (DISPID_SAX_CONTENTHANDLER + 4)
#define DISPID_SAX_CONTENTHANDLER_ENDPREFIXMAPPING (DISPID_SAX_CONTENTHANDLER + 5)
#define DISPID_SAX_CONTENTHANDLER_STARTELEMENT (DISPID_SAX_CONTENTHANDLER + 6)
#define DISPID_SAX_CONTENTHANDLER_ENDELEMENT (DISPID_SAX_CONTENTHANDLER + 7)
#define DISPID_SAX_CONTENTHANDLER_CHARACTERS (DISPID_SAX_CONTENTHANDLER + 8)
#define DISPID_SAX_CONTENTHANDLER_IGNORABLEWHITESPACE (DISPID_SAX_CONTENTHANDLER + 9)
#define DISPID_SAX_CONTENTHANDLER_PROCESSINGINSTRUCTION (DISPID_SAX_CONTENTHANDLER + 10)
#define DISPID_SAX_CONTENTHANDLER_SKIPPEDENTITY (DISPID_SAX_CONTENTHANDLER + 11)
#define DISPID_SAX_CONTENTHANDLER__TOP (DISPID_SAX_CONTENTHANDLER + 12)

#define DISPID_SAX_DTDHANDLER__BASE (DISPID_SAX_CONTENTHANDLER__TOP + 1)
#define DISPID_SAX_DTDHANDLER (DISPID_SAX_DTDHANDLER__BASE)
#define DISPID_SAX_DTDHANDLER_NOTATIONDECL (DISPID_SAX_DTDHANDLER + 1)
#define DISPID_SAX_DTDHANDLER_UNPARSEDENTITYDECL (DISPID_SAX_DTDHANDLER + 2)
#define DISPID_SAX_DTDHANDLER__TOP (DISPID_SAX_DTDHANDLER + 3)

#define DISPID_SAX_ERRORHANDLER__BASE (DISPID_SAX_DTDHANDLER__TOP + 1)
#define DISPID_SAX_ERRORHANDLER (DISPID_SAX_ERRORHANDLER__BASE)
#define DISPID_SAX_ERRORHANDLER_ERROR (DISPID_SAX_ERRORHANDLER + 1)
#define DISPID_SAX_ERRORHANDLER_FATALERROR (DISPID_SAX_ERRORHANDLER + 2)
#define DISPID_SAX_ERRORHANDLER_IGNORABLEWARNING (DISPID_SAX_ERRORHANDLER + 3)
#define DISPID_SAX_ERRORHANDLER__TOP (DISPID_SAX_ERRORHANDLER + 4)

#define DISPID_SAX_ATTRIBUTES__BASE (DISPID_SAX_ERRORHANDLER__TOP + 1)
#define DISPID_SAX_ATTRIBUTES (DISPID_SAX_ATTRIBUTES__BASE)
#define DISPID_SAX_ATTRIBUTES_LENGTH (DISPID_SAX_ATTRIBUTES + 1)
#define DISPID_SAX_ATTRIBUTES_GETURI (DISPID_SAX_ATTRIBUTES + 2)
#define DISPID_SAX_ATTRIBUTES_GETLOCALNAME (DISPID_SAX_ATTRIBUTES + 3)
#define DISPID_SAX_ATTRIBUTES_GETQNAME (DISPID_SAX_ATTRIBUTES + 4)
#define DISPID_SAX_ATTRIBUTES_GETINDEXFROMNAME (DISPID_SAX_ATTRIBUTES + 5)
#define DISPID_SAX_ATTRIBUTES_GETINDEXFROMQNAME (DISPID_SAX_ATTRIBUTES + 6)
#define DISPID_SAX_ATTRIBUTES_GETTYPE (DISPID_SAX_ATTRIBUTES + 7)
#define DISPID_SAX_ATTRIBUTES_GETTYPEFROMNAME (DISPID_SAX_ATTRIBUTES + 8)
#define DISPID_SAX_ATTRIBUTES_GETTYPEFROMQNAME (DISPID_SAX_ATTRIBUTES + 9)
#define DISPID_SAX_ATTRIBUTES_GETVALUE (DISPID_SAX_ATTRIBUTES + 10)
#define DISPID_SAX_ATTRIBUTES_GETVALUEFROMNAME (DISPID_SAX_ATTRIBUTES + 11)
#define DISPID_SAX_ATTRIBUTES_GETVALUEFROMQNAME (DISPID_SAX_ATTRIBUTES + 12)
#define DISPID_SAX_ATTRIBUTES__TOP (DISPID_SAX_ATTRIBUTES + 13)

#define DISPID_SAX_LEXICALHANDLER__BASE (DISPID_SAX_ATTRIBUTES__TOP + 1)
#define DISPID_SAX_LEXICALHANDLER (DISPID_SAX_LEXICALHANDLER__BASE)
#define DISPID_SAX_LEXICALHANDLER_STARTDTD (DISPID_SAX_LEXICALHANDLER + 1)
#define DISPID_SAX_LEXICALHANDLER_ENDDTD (DISPID_SAX_LEXICALHANDLER + 2)
#define DISPID_SAX_LEXICALHANDLER_STARTENTITY (DISPID_SAX_LEXICALHANDLER + 3)
#define DISPID_SAX_LEXICALHANDLER_ENDENTITY (DISPID_SAX_LEXICALHANDLER + 4)
#define DISPID_SAX_LEXICALHANDLER_STARTCDATA (DISPID_SAX_LEXICALHANDLER + 5)
#define DISPID_SAX_LEXICALHANDLER_ENDCDATA (DISPID_SAX_LEXICALHANDLER + 6)
#define DISPID_SAX_LEXICALHANDLER_COMMENT (DISPID_SAX_LEXICALHANDLER + 7)
#define DISPID_SAX_LEXICALHANDLER__TOP (DISPID_SAX_LEXICALHANDLER + 8)

#define DISPID_SAX_DECLHANDLER__BASE (DISPID_SAX_LEXICALHANDLER__TOP + 1)
#define DISPID_SAX_DECLHANDLER (DISPID_SAX_DECLHANDLER__BASE)
#define DISPID_SAX_DECLHANDLER_ELEMENTDECL (DISPID_SAX_DECLHANDLER + 1)
#define DISPID_SAX_DECLHANDLER_ATTRIBUTEDECL (DISPID_SAX_DECLHANDLER + 2)
#define DISPID_SAX_DECLHANDLER_INTERNALENTITYDECL (DISPID_SAX_DECLHANDLER + 3)
#define DISPID_SAX_DECLHANDLER_EXTERNALENTITYDECL (DISPID_SAX_DECLHANDLER + 4)
#define DISPID_SAX_DECLHANDLER__TOP (DISPID_SAX_DECLHANDLER + 5)

#define DISPID_MX_ATTRIBUTES__BASE (DISPID_SAX_DECLHANDLER__TOP + 1)
#define DISPID_MX_ATTRIBUTES (DISPID_MX_ATTRIBUTES__BASE)
#define DISPID_MX_ATTRIBUTES_ADDATTRIBUTE (DISPID_MX_ATTRIBUTES + 1)
#define DISPID_MX_ATTRIBUTES_CLEAR (DISPID_MX_ATTRIBUTES + 2)
#define DISPID_MX_ATTRIBUTES_REMOVEATTRIBUTE (DISPID_MX_ATTRIBUTES + 3)
#define DISPID_MX_ATTRIBUTES_SETATTRIBUTE (DISPID_MX_ATTRIBUTES + 4)
#define DISPID_MX_ATTRIBUTES_SETATTRIBUTES (DISPID_MX_ATTRIBUTES + 5)
#define DISPID_MX_ATTRIBUTES_SETLOCALNAME (DISPID_MX_ATTRIBUTES + 6)
#define DISPID_MX_ATTRIBUTES_SETQNAME (DISPID_MX_ATTRIBUTES + 7)
#define DISPID_MX_ATTRIBUTES_SETTYPE (DISPID_MX_ATTRIBUTES + 8)
#define DISPID_MX_ATTRIBUTES_SETURI (DISPID_MX_ATTRIBUTES + 9)
#define DISPID_MX_ATTRIBUTES_SETVALUE (DISPID_MX_ATTRIBUTES + 10)
#define DISPID_MX_ATTRIBUTES_ADDATTRIBUTEFROMINDEX (DISPID_MX_ATTRIBUTES + 11)
#define DISPID_MX_ATTRIBUTES__TOP (DISPID_MX_ATTRIBUTES + 11)

#define DISPID_MX_WRITER__BASE (DISPID_MX_ATTRIBUTES__TOP + 1)
#define DISPID_MX_WRITER (DISPID_MX_WRITER__BASE)
#define DISPID_MX_WRITER_OUTPUT (DISPID_MX_WRITER + 1)
#define DISPID_MX_WRITER_DESTINATION (DISPID_MX_WRITER + 2)
#define DISPID_MX_WRITER_ENCODING (DISPID_MX_WRITER + 3)
#define DISPID_MX_WRITER_BYTEORDERMARK (DISPID_MX_WRITER + 4)
#define DISPID_MX_WRITER_INDENT (DISPID_MX_WRITER + 5)
#define DISPID_MX_WRITER_STANDALONE (DISPID_MX_WRITER + 6)
#define DISPID_MX_WRITER_OMITXMLDECLARATION (DISPID_MX_WRITER + 7)
#define DISPID_MX_WRITER_VERSION (DISPID_MX_WRITER + 8)
#define DISPID_MX_WRITER_DISABLEOUTPUTESCAPING (DISPID_MX_WRITER + 9)
#define DISPID_MX_WRITER_FLUSH (DISPID_MX_WRITER + 10)
#define DISPID_MX_WRITER_RESET (DISPID_MX_WRITER + 11)
#define DISPID_MX_WRITER__TOP (DISPID_MX_WRITER + 12)

#define DISPID_MX_READER_CONTROL__BASE (DISPID_MX_WRITER__TOP + 1)
#define DISPID_MX_READER_CONTROL (DISPID_MX_READER_CONTROL__BASE)
#define DISPID_MX_READER_CONTROL_ABORT (DISPID_MX_READER_CONTROL + 1)
#define DISPID_MX_READER_CONTROL_RESUME (DISPID_MX_READER_CONTROL + 2)
#define DISPID_MX_READER_CONTROL_SUSPEND (DISPID_MX_READER_CONTROL + 3)
#define DISPID_MX_READER_CONTROL__TOP (DISPID_MX_READER_CONTROL + 4)

//;begin_internal
#endif // __MSXMLDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\adreplpv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by adreplpv.rc
//
#define IDS_PROJNAME                    100
#define IDS_ADREPLPROVIDER_DESC         101
#define IDR_ADReplProvider              102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\adreplpv\adreplpv.cpp ===
// adreplpv.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f adreplpvps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
//#include "adreplpv.h"

//#include "adreplpv_i.c"
#include "Wbem.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ADReplProvider, CProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance /*, &LIBID_ADREPLPVLib */); // EricB
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE); // EricB remote IDL
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\adreplpv\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

bool g_DoAssert = false;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\msxml3\inc\msxml2.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __msxml2_h__
#define __msxml2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXMLDOMImplementation_FWD_DEFINED__
#define __IXMLDOMImplementation_FWD_DEFINED__
typedef interface IXMLDOMImplementation IXMLDOMImplementation;
#endif 	/* __IXMLDOMImplementation_FWD_DEFINED__ */


#ifndef __IXMLDOMNode_FWD_DEFINED__
#define __IXMLDOMNode_FWD_DEFINED__
typedef interface IXMLDOMNode IXMLDOMNode;
#endif 	/* __IXMLDOMNode_FWD_DEFINED__ */


#ifndef __IXMLDOMDocumentFragment_FWD_DEFINED__
#define __IXMLDOMDocumentFragment_FWD_DEFINED__
typedef interface IXMLDOMDocumentFragment IXMLDOMDocumentFragment;
#endif 	/* __IXMLDOMDocumentFragment_FWD_DEFINED__ */


#ifndef __IXMLDOMDocument_FWD_DEFINED__
#define __IXMLDOMDocument_FWD_DEFINED__
typedef interface IXMLDOMDocument IXMLDOMDocument;
#endif 	/* __IXMLDOMDocument_FWD_DEFINED__ */


#ifndef __IXMLDOMSchemaCollection_FWD_DEFINED__
#define __IXMLDOMSchemaCollection_FWD_DEFINED__
typedef interface IXMLDOMSchemaCollection IXMLDOMSchemaCollection;
#endif 	/* __IXMLDOMSchemaCollection_FWD_DEFINED__ */


#ifndef __IXMLDOMDocument2_FWD_DEFINED__
#define __IXMLDOMDocument2_FWD_DEFINED__
typedef interface IXMLDOMDocument2 IXMLDOMDocument2;
#endif 	/* __IXMLDOMDocument2_FWD_DEFINED__ */


#ifndef __IXMLDOMNodeList_FWD_DEFINED__
#define __IXMLDOMNodeList_FWD_DEFINED__
typedef interface IXMLDOMNodeList IXMLDOMNodeList;
#endif 	/* __IXMLDOMNodeList_FWD_DEFINED__ */


#ifndef __IXMLDOMNamedNodeMap_FWD_DEFINED__
#define __IXMLDOMNamedNodeMap_FWD_DEFINED__
typedef interface IXMLDOMNamedNodeMap IXMLDOMNamedNodeMap;
#endif 	/* __IXMLDOMNamedNodeMap_FWD_DEFINED__ */


#ifndef __IXMLDOMCharacterData_FWD_DEFINED__
#define __IXMLDOMCharacterData_FWD_DEFINED__
typedef interface IXMLDOMCharacterData IXMLDOMCharacterData;
#endif 	/* __IXMLDOMCharacterData_FWD_DEFINED__ */


#ifndef __IXMLDOMAttribute_FWD_DEFINED__
#define __IXMLDOMAttribute_FWD_DEFINED__
typedef interface IXMLDOMAttribute IXMLDOMAttribute;
#endif 	/* __IXMLDOMAttribute_FWD_DEFINED__ */


#ifndef __IXMLDOMElement_FWD_DEFINED__
#define __IXMLDOMElement_FWD_DEFINED__
typedef interface IXMLDOMElement IXMLDOMElement;
#endif 	/* __IXMLDOMElement_FWD_DEFINED__ */


#ifndef __IXMLDOMText_FWD_DEFINED__
#define __IXMLDOMText_FWD_DEFINED__
typedef interface IXMLDOMText IXMLDOMText;
#endif 	/* __IXMLDOMText_FWD_DEFINED__ */


#ifndef __IXMLDOMComment_FWD_DEFINED__
#define __IXMLDOMComment_FWD_DEFINED__
typedef interface IXMLDOMComment IXMLDOMComment;
#endif 	/* __IXMLDOMComment_FWD_DEFINED__ */


#ifndef __IXMLDOMProcessingInstruction_FWD_DEFINED__
#define __IXMLDOMProcessingInstruction_FWD_DEFINED__
typedef interface IXMLDOMProcessingInstruction IXMLDOMProcessingInstruction;
#endif 	/* __IXMLDOMProcessingInstruction_FWD_DEFINED__ */


#ifndef __IXMLDOMCDATASection_FWD_DEFINED__
#define __IXMLDOMCDATASection_FWD_DEFINED__
typedef interface IXMLDOMCDATASection IXMLDOMCDATASection;
#endif 	/* __IXMLDOMCDATASection_FWD_DEFINED__ */


#ifndef __IXMLDOMDocumentType_FWD_DEFINED__
#define __IXMLDOMDocumentType_FWD_DEFINED__
typedef interface IXMLDOMDocumentType IXMLDOMDocumentType;
#endif 	/* __IXMLDOMDocumentType_FWD_DEFINED__ */


#ifndef __IXMLDOMNotation_FWD_DEFINED__
#define __IXMLDOMNotation_FWD_DEFINED__
typedef interface IXMLDOMNotation IXMLDOMNotation;
#endif 	/* __IXMLDOMNotation_FWD_DEFINED__ */


#ifndef __IXMLDOMEntity_FWD_DEFINED__
#define __IXMLDOMEntity_FWD_DEFINED__
typedef interface IXMLDOMEntity IXMLDOMEntity;
#endif 	/* __IXMLDOMEntity_FWD_DEFINED__ */


#ifndef __IXMLDOMEntityReference_FWD_DEFINED__
#define __IXMLDOMEntityReference_FWD_DEFINED__
typedef interface IXMLDOMEntityReference IXMLDOMEntityReference;
#endif 	/* __IXMLDOMEntityReference_FWD_DEFINED__ */


#ifndef __IXMLDOMParseError_FWD_DEFINED__
#define __IXMLDOMParseError_FWD_DEFINED__
typedef interface IXMLDOMParseError IXMLDOMParseError;
#endif 	/* __IXMLDOMParseError_FWD_DEFINED__ */


#ifndef __IXTLRuntime_FWD_DEFINED__
#define __IXTLRuntime_FWD_DEFINED__
typedef interface IXTLRuntime IXTLRuntime;
#endif 	/* __IXTLRuntime_FWD_DEFINED__ */


#ifndef __IXSLTemplate_FWD_DEFINED__
#define __IXSLTemplate_FWD_DEFINED__
typedef interface IXSLTemplate IXSLTemplate;
#endif 	/* __IXSLTemplate_FWD_DEFINED__ */


#ifndef __IXSLProcessor_FWD_DEFINED__
#define __IXSLProcessor_FWD_DEFINED__
typedef interface IXSLProcessor IXSLProcessor;
#endif 	/* __IXSLProcessor_FWD_DEFINED__ */


#ifndef __ISAXXMLReader_FWD_DEFINED__
#define __ISAXXMLReader_FWD_DEFINED__
typedef interface ISAXXMLReader ISAXXMLReader;
#endif 	/* __ISAXXMLReader_FWD_DEFINED__ */


#ifndef __ISAXXMLFilter_FWD_DEFINED__
#define __ISAXXMLFilter_FWD_DEFINED__
typedef interface ISAXXMLFilter ISAXXMLFilter;
#endif 	/* __ISAXXMLFilter_FWD_DEFINED__ */


#ifndef __ISAXLocator_FWD_DEFINED__
#define __ISAXLocator_FWD_DEFINED__
typedef interface ISAXLocator ISAXLocator;
#endif 	/* __ISAXLocator_FWD_DEFINED__ */


#ifndef __ISAXEntityResolver_FWD_DEFINED__
#define __ISAXEntityResolver_FWD_DEFINED__
typedef interface ISAXEntityResolver ISAXEntityResolver;
#endif 	/* __ISAXEntityResolver_FWD_DEFINED__ */


#ifndef __ISAXContentHandler_FWD_DEFINED__
#define __ISAXContentHandler_FWD_DEFINED__
typedef interface ISAXContentHandler ISAXContentHandler;
#endif 	/* __ISAXContentHandler_FWD_DEFINED__ */


#ifndef __ISAXDTDHandler_FWD_DEFINED__
#define __ISAXDTDHandler_FWD_DEFINED__
typedef interface ISAXDTDHandler ISAXDTDHandler;
#endif 	/* __ISAXDTDHandler_FWD_DEFINED__ */


#ifndef __ISAXErrorHandler_FWD_DEFINED__
#define __ISAXErrorHandler_FWD_DEFINED__
typedef interface ISAXErrorHandler ISAXErrorHandler;
#endif 	/* __ISAXErrorHandler_FWD_DEFINED__ */


#ifndef __ISAXLexicalHandler_FWD_DEFINED__
#define __ISAXLexicalHandler_FWD_DEFINED__
typedef interface ISAXLexicalHandler ISAXLexicalHandler;
#endif 	/* __ISAXLexicalHandler_FWD_DEFINED__ */


#ifndef __ISAXDeclHandler_FWD_DEFINED__
#define __ISAXDeclHandler_FWD_DEFINED__
typedef interface ISAXDeclHandler ISAXDeclHandler;
#endif 	/* __ISAXDeclHandler_FWD_DEFINED__ */


#ifndef __ISAXAttributes_FWD_DEFINED__
#define __ISAXAttributes_FWD_DEFINED__
typedef interface ISAXAttributes ISAXAttributes;
#endif 	/* __ISAXAttributes_FWD_DEFINED__ */


#ifndef __IVBSAXXMLReader_FWD_DEFINED__
#define __IVBSAXXMLReader_FWD_DEFINED__
typedef interface IVBSAXXMLReader IVBSAXXMLReader;
#endif 	/* __IVBSAXXMLReader_FWD_DEFINED__ */


#ifndef __IVBSAXXMLFilter_FWD_DEFINED__
#define __IVBSAXXMLFilter_FWD_DEFINED__
typedef interface IVBSAXXMLFilter IVBSAXXMLFilter;
#endif 	/* __IVBSAXXMLFilter_FWD_DEFINED__ */


#ifndef __IVBSAXLocator_FWD_DEFINED__
#define __IVBSAXLocator_FWD_DEFINED__
typedef interface IVBSAXLocator IVBSAXLocator;
#endif 	/* __IVBSAXLocator_FWD_DEFINED__ */


#ifndef __IVBSAXEntityResolver_FWD_DEFINED__
#define __IVBSAXEntityResolver_FWD_DEFINED__
typedef interface IVBSAXEntityResolver IVBSAXEntityResolver;
#endif 	/* __IVBSAXEntityResolver_FWD_DEFINED__ */


#ifndef __IVBSAXContentHandler_FWD_DEFINED__
#define __IVBSAXContentHandler_FWD_DEFINED__
typedef interface IVBSAXContentHandler IVBSAXContentHandler;
#endif 	/* __IVBSAXContentHandler_FWD_DEFINED__ */


#ifndef __IVBSAXDTDHandler_FWD_DEFINED__
#define __IVBSAXDTDHandler_FWD_DEFINED__
typedef interface IVBSAXDTDHandler IVBSAXDTDHandler;
#endif 	/* __IVBSAXDTDHandler_FWD_DEFINED__ */


#ifndef __IVBSAXErrorHandler_FWD_DEFINED__
#define __IVBSAXErrorHandler_FWD_DEFINED__
typedef interface IVBSAXErrorHandler IVBSAXErrorHandler;
#endif 	/* __IVBSAXErrorHandler_FWD_DEFINED__ */


#ifndef __IVBSAXLexicalHandler_FWD_DEFINED__
#define __IVBSAXLexicalHandler_FWD_DEFINED__
typedef interface IVBSAXLexicalHandler IVBSAXLexicalHandler;
#endif 	/* __IVBSAXLexicalHandler_FWD_DEFINED__ */


#ifndef __IVBSAXDeclHandler_FWD_DEFINED__
#define __IVBSAXDeclHandler_FWD_DEFINED__
typedef interface IVBSAXDeclHandler IVBSAXDeclHandler;
#endif 	/* __IVBSAXDeclHandler_FWD_DEFINED__ */


#ifndef __IVBSAXAttributes_FWD_DEFINED__
#define __IVBSAXAttributes_FWD_DEFINED__
typedef interface IVBSAXAttributes IVBSAXAttributes;
#endif 	/* __IVBSAXAttributes_FWD_DEFINED__ */


#ifndef __IMXWriter_FWD_DEFINED__
#define __IMXWriter_FWD_DEFINED__
typedef interface IMXWriter IMXWriter;
#endif 	/* __IMXWriter_FWD_DEFINED__ */


#ifndef __IMXAttributes_FWD_DEFINED__
#define __IMXAttributes_FWD_DEFINED__
typedef interface IMXAttributes IMXAttributes;
#endif 	/* __IMXAttributes_FWD_DEFINED__ */


#ifndef __IMXReaderControl_FWD_DEFINED__
#define __IMXReaderControl_FWD_DEFINED__
typedef interface IMXReaderControl IMXReaderControl;
#endif 	/* __IMXReaderControl_FWD_DEFINED__ */


#ifndef __IXMLElementCollection_FWD_DEFINED__
#define __IXMLElementCollection_FWD_DEFINED__
typedef interface IXMLElementCollection IXMLElementCollection;
#endif 	/* __IXMLElementCollection_FWD_DEFINED__ */


#ifndef __IXMLDocument_FWD_DEFINED__
#define __IXMLDocument_FWD_DEFINED__
typedef interface IXMLDocument IXMLDocument;
#endif 	/* __IXMLDocument_FWD_DEFINED__ */


#ifndef __IXMLDocument2_FWD_DEFINED__
#define __IXMLDocument2_FWD_DEFINED__
typedef interface IXMLDocument2 IXMLDocument2;
#endif 	/* __IXMLDocument2_FWD_DEFINED__ */


#ifndef __IXMLElement_FWD_DEFINED__
#define __IXMLElement_FWD_DEFINED__
typedef interface IXMLElement IXMLElement;
#endif 	/* __IXMLElement_FWD_DEFINED__ */


#ifndef __IXMLElement2_FWD_DEFINED__
#define __IXMLElement2_FWD_DEFINED__
typedef interface IXMLElement2 IXMLElement2;
#endif 	/* __IXMLElement2_FWD_DEFINED__ */


#ifndef __IXMLAttribute_FWD_DEFINED__
#define __IXMLAttribute_FWD_DEFINED__
typedef interface IXMLAttribute IXMLAttribute;
#endif 	/* __IXMLAttribute_FWD_DEFINED__ */


#ifndef __IXMLError_FWD_DEFINED__
#define __IXMLError_FWD_DEFINED__
typedef interface IXMLError IXMLError;
#endif 	/* __IXMLError_FWD_DEFINED__ */


#ifndef __IXMLDOMSelection_FWD_DEFINED__
#define __IXMLDOMSelection_FWD_DEFINED__
typedef interface IXMLDOMSelection IXMLDOMSelection;
#endif 	/* __IXMLDOMSelection_FWD_DEFINED__ */


#ifndef __XMLDOMDocumentEvents_FWD_DEFINED__
#define __XMLDOMDocumentEvents_FWD_DEFINED__
typedef interface XMLDOMDocumentEvents XMLDOMDocumentEvents;
#endif 	/* __XMLDOMDocumentEvents_FWD_DEFINED__ */


#ifndef __IDSOControl_FWD_DEFINED__
#define __IDSOControl_FWD_DEFINED__
typedef interface IDSOControl IDSOControl;
#endif 	/* __IDSOControl_FWD_DEFINED__ */


#ifndef __IXMLHTTPRequest_FWD_DEFINED__
#define __IXMLHTTPRequest_FWD_DEFINED__
typedef interface IXMLHTTPRequest IXMLHTTPRequest;
#endif 	/* __IXMLHTTPRequest_FWD_DEFINED__ */


#ifndef __IServerXMLHTTPRequest_FWD_DEFINED__
#define __IServerXMLHTTPRequest_FWD_DEFINED__
typedef interface IServerXMLHTTPRequest IServerXMLHTTPRequest;
#endif 	/* __IServerXMLHTTPRequest_FWD_DEFINED__ */


#ifndef __DOMDocument_FWD_DEFINED__
#define __DOMDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class DOMDocument DOMDocument;
#else
typedef struct DOMDocument DOMDocument;
#endif /* __cplusplus */

#endif 	/* __DOMDocument_FWD_DEFINED__ */


#ifndef __DOMDocument26_FWD_DEFINED__
#define __DOMDocument26_FWD_DEFINED__

#ifdef __cplusplus
typedef class DOMDocument26 DOMDocument26;
#else
typedef struct DOMDocument26 DOMDocument26;
#endif /* __cplusplus */

#endif 	/* __DOMDocument26_FWD_DEFINED__ */


#ifndef __DOMDocument30_FWD_DEFINED__
#define __DOMDocument30_FWD_DEFINED__

#ifdef __cplusplus
typedef class DOMDocument30 DOMDocument30;
#else
typedef struct DOMDocument30 DOMDocument30;
#endif /* __cplusplus */

#endif 	/* __DOMDocument30_FWD_DEFINED__ */


#ifndef __FreeThreadedDOMDocument_FWD_DEFINED__
#define __FreeThreadedDOMDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class FreeThreadedDOMDocument FreeThreadedDOMDocument;
#else
typedef struct FreeThreadedDOMDocument FreeThreadedDOMDocument;
#endif /* __cplusplus */

#endif 	/* __FreeThreadedDOMDocument_FWD_DEFINED__ */


#ifndef __FreeThreadedDOMDocument26_FWD_DEFINED__
#define __FreeThreadedDOMDocument26_FWD_DEFINED__

#ifdef __cplusplus
typedef class FreeThreadedDOMDocument26 FreeThreadedDOMDocument26;
#else
typedef struct FreeThreadedDOMDocument26 FreeThreadedDOMDocument26;
#endif /* __cplusplus */

#endif 	/* __FreeThreadedDOMDocument26_FWD_DEFINED__ */


#ifndef __FreeThreadedDOMDocument30_FWD_DEFINED__
#define __FreeThreadedDOMDocument30_FWD_DEFINED__

#ifdef __cplusplus
typedef class FreeThreadedDOMDocument30 FreeThreadedDOMDocument30;
#else
typedef struct FreeThreadedDOMDocument30 FreeThreadedDOMDocument30;
#endif /* __cplusplus */

#endif 	/* __FreeThreadedDOMDocument30_FWD_DEFINED__ */


#ifndef __XMLSchemaCache_FWD_DEFINED__
#define __XMLSchemaCache_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLSchemaCache XMLSchemaCache;
#else
typedef struct XMLSchemaCache XMLSchemaCache;
#endif /* __cplusplus */

#endif 	/* __XMLSchemaCache_FWD_DEFINED__ */


#ifndef __XMLSchemaCache26_FWD_DEFINED__
#define __XMLSchemaCache26_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLSchemaCache26 XMLSchemaCache26;
#else
typedef struct XMLSchemaCache26 XMLSchemaCache26;
#endif /* __cplusplus */

#endif 	/* __XMLSchemaCache26_FWD_DEFINED__ */


#ifndef __XMLSchemaCache30_FWD_DEFINED__
#define __XMLSchemaCache30_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLSchemaCache30 XMLSchemaCache30;
#else
typedef struct XMLSchemaCache30 XMLSchemaCache30;
#endif /* __cplusplus */

#endif 	/* __XMLSchemaCache30_FWD_DEFINED__ */


#ifndef __XSLTemplate_FWD_DEFINED__
#define __XSLTemplate_FWD_DEFINED__

#ifdef __cplusplus
typedef class XSLTemplate XSLTemplate;
#else
typedef struct XSLTemplate XSLTemplate;
#endif /* __cplusplus */

#endif 	/* __XSLTemplate_FWD_DEFINED__ */


#ifndef __XSLTemplate26_FWD_DEFINED__
#define __XSLTemplate26_FWD_DEFINED__

#ifdef __cplusplus
typedef class XSLTemplate26 XSLTemplate26;
#else
typedef struct XSLTemplate26 XSLTemplate26;
#endif /* __cplusplus */

#endif 	/* __XSLTemplate26_FWD_DEFINED__ */


#ifndef __XSLTemplate30_FWD_DEFINED__
#define __XSLTemplate30_FWD_DEFINED__

#ifdef __cplusplus
typedef class XSLTemplate30 XSLTemplate30;
#else
typedef struct XSLTemplate30 XSLTemplate30;
#endif /* __cplusplus */

#endif 	/* __XSLTemplate30_FWD_DEFINED__ */


#ifndef __DSOControl_FWD_DEFINED__
#define __DSOControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSOControl DSOControl;
#else
typedef struct DSOControl DSOControl;
#endif /* __cplusplus */

#endif 	/* __DSOControl_FWD_DEFINED__ */


#ifndef __DSOControl26_FWD_DEFINED__
#define __DSOControl26_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSOControl26 DSOControl26;
#else
typedef struct DSOControl26 DSOControl26;
#endif /* __cplusplus */

#endif 	/* __DSOControl26_FWD_DEFINED__ */


#ifndef __DSOControl30_FWD_DEFINED__
#define __DSOControl30_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSOControl30 DSOControl30;
#else
typedef struct DSOControl30 DSOControl30;
#endif /* __cplusplus */

#endif 	/* __DSOControl30_FWD_DEFINED__ */


#ifndef __XMLHTTP_FWD_DEFINED__
#define __XMLHTTP_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLHTTP XMLHTTP;
#else
typedef struct XMLHTTP XMLHTTP;
#endif /* __cplusplus */

#endif 	/* __XMLHTTP_FWD_DEFINED__ */


#ifndef __XMLHTTP26_FWD_DEFINED__
#define __XMLHTTP26_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLHTTP26 XMLHTTP26;
#else
typedef struct XMLHTTP26 XMLHTTP26;
#endif /* __cplusplus */

#endif 	/* __XMLHTTP26_FWD_DEFINED__ */


#ifndef __XMLHTTP30_FWD_DEFINED__
#define __XMLHTTP30_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLHTTP30 XMLHTTP30;
#else
typedef struct XMLHTTP30 XMLHTTP30;
#endif /* __cplusplus */

#endif 	/* __XMLHTTP30_FWD_DEFINED__ */


#ifndef __ServerXMLHTTP_FWD_DEFINED__
#define __ServerXMLHTTP_FWD_DEFINED__

#ifdef __cplusplus
typedef class ServerXMLHTTP ServerXMLHTTP;
#else
typedef struct ServerXMLHTTP ServerXMLHTTP;
#endif /* __cplusplus */

#endif 	/* __ServerXMLHTTP_FWD_DEFINED__ */


#ifndef __ServerXMLHTTP30_FWD_DEFINED__
#define __ServerXMLHTTP30_FWD_DEFINED__

#ifdef __cplusplus
typedef class ServerXMLHTTP30 ServerXMLHTTP30;
#else
typedef struct ServerXMLHTTP30 ServerXMLHTTP30;
#endif /* __cplusplus */

#endif 	/* __ServerXMLHTTP30_FWD_DEFINED__ */


#ifndef __SAXXMLReader_FWD_DEFINED__
#define __SAXXMLReader_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAXXMLReader SAXXMLReader;
#else
typedef struct SAXXMLReader SAXXMLReader;
#endif /* __cplusplus */

#endif 	/* __SAXXMLReader_FWD_DEFINED__ */


#ifndef __SAXXMLReader30_FWD_DEFINED__
#define __SAXXMLReader30_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAXXMLReader30 SAXXMLReader30;
#else
typedef struct SAXXMLReader30 SAXXMLReader30;
#endif /* __cplusplus */

#endif 	/* __SAXXMLReader30_FWD_DEFINED__ */


#ifndef __MXXMLWriter_FWD_DEFINED__
#define __MXXMLWriter_FWD_DEFINED__

#ifdef __cplusplus
typedef class MXXMLWriter MXXMLWriter;
#else
typedef struct MXXMLWriter MXXMLWriter;
#endif /* __cplusplus */

#endif 	/* __MXXMLWriter_FWD_DEFINED__ */


#ifndef __MXXMLWriter30_FWD_DEFINED__
#define __MXXMLWriter30_FWD_DEFINED__

#ifdef __cplusplus
typedef class MXXMLWriter30 MXXMLWriter30;
#else
typedef struct MXXMLWriter30 MXXMLWriter30;
#endif /* __cplusplus */

#endif 	/* __MXXMLWriter30_FWD_DEFINED__ */


#ifndef __SAXAttributes_FWD_DEFINED__
#define __SAXAttributes_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAXAttributes SAXAttributes;
#else
typedef struct SAXAttributes SAXAttributes;
#endif /* __cplusplus */

#endif 	/* __SAXAttributes_FWD_DEFINED__ */


#ifndef __SAXAttributes30_FWD_DEFINED__
#define __SAXAttributes30_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAXAttributes30 SAXAttributes30;
#else
typedef struct SAXAttributes30 SAXAttributes30;
#endif /* __cplusplus */

#endif 	/* __SAXAttributes30_FWD_DEFINED__ */


#ifndef __XMLDocument_FWD_DEFINED__
#define __XMLDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLDocument XMLDocument;
#else
typedef struct XMLDocument XMLDocument;
#endif /* __cplusplus */

#endif 	/* __XMLDocument_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msxml2_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//--------------------------------------------------------------------------
#define DOMDocument DOMDocument2
#define CLSID_DOMDocument CLSID_DOMDocument2

#ifdef __USE_MSXML2_NAMESPACE__
namespace MSXML2 {
#endif
#ifndef __msxml_h__
typedef struct _xml_error
    {
    unsigned int _nLine;
    BSTR _pchBuf;
    unsigned int _cchBuf;
    unsigned int _ich;
    BSTR _pszFound;
    BSTR _pszExpected;
    DWORD _reserved1;
    DWORD _reserved2;
    } 	XML_ERROR;

#endif
#ifndef __ISAXXMLReader_INTERFACE_DEFINED__
#undef __MSXML2_LIBRARY_DEFINED__
#endif


extern RPC_IF_HANDLE __MIDL_itf_msxml2_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml2_0000_v0_0_s_ifspec;


#ifndef __MSXML2_LIBRARY_DEFINED__
#define __MSXML2_LIBRARY_DEFINED__

/* library MSXML2 */
/* [lcid][helpstring][version][uuid] */ 























































#undef ParseURL
#if !defined(__msxml_h__)
typedef /* [helpstring] */ 
enum tagXMLEMEM_TYPE
    {	XMLELEMTYPE_ELEMENT	= 0,
	XMLELEMTYPE_TEXT	= XMLELEMTYPE_ELEMENT + 1,
	XMLELEMTYPE_COMMENT	= XMLELEMTYPE_TEXT + 1,
	XMLELEMTYPE_DOCUMENT	= XMLELEMTYPE_COMMENT + 1,
	XMLELEMTYPE_DTD	= XMLELEMTYPE_DOCUMENT + 1,
	XMLELEMTYPE_PI	= XMLELEMTYPE_DTD + 1,
	XMLELEMTYPE_OTHER	= XMLELEMTYPE_PI + 1
    } 	XMLELEM_TYPE;

#endif
#if !defined(__msxml_h__) || defined(__IXMLElementNotificationSink_INTERFACE_DEFINED__)
typedef /* [helpstring] */ 
enum tagDOMNodeType
    {	NODE_INVALID	= 0,
	NODE_ELEMENT	= NODE_INVALID + 1,
	NODE_ATTRIBUTE	= NODE_ELEMENT + 1,
	NODE_TEXT	= NODE_ATTRIBUTE + 1,
	NODE_CDATA_SECTION	= NODE_TEXT + 1,
	NODE_ENTITY_REFERENCE	= NODE_CDATA_SECTION + 1,
	NODE_ENTITY	= NODE_ENTITY_REFERENCE + 1,
	NODE_PROCESSING_INSTRUCTION	= NODE_ENTITY + 1,
	NODE_COMMENT	= NODE_PROCESSING_INSTRUCTION + 1,
	NODE_DOCUMENT	= NODE_COMMENT + 1,
	NODE_DOCUMENT_TYPE	= NODE_DOCUMENT + 1,
	NODE_DOCUMENT_FRAGMENT	= NODE_DOCUMENT_TYPE + 1,
	NODE_NOTATION	= NODE_DOCUMENT_FRAGMENT + 1
    } 	DOMNodeType;

#endif
typedef /* [helpstring] */ 
enum _SERVERXMLHTTP_OPTION
    {	SXH_OPTION_URL_CODEPAGE	= 0,
	SXH_OPTION_ESCAPE_PERCENT_IN_URL	= SXH_OPTION_URL_CODEPAGE + 1
    } 	SERVERXMLHTTP_OPTION;


EXTERN_C const IID LIBID_MSXML2;

#ifndef __IXMLDOMImplementation_INTERFACE_DEFINED__
#define __IXMLDOMImplementation_INTERFACE_DEFINED__

/* interface IXMLDOMImplementation */
/* [uuid][dual][oleautomation][unique][nonextensible][object][local] */ 


EXTERN_C const IID IID_IXMLDOMImplementation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8F-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMImplementation : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE hasFeature( 
            /* [in] */ BSTR feature,
            /* [in] */ BSTR version,
            /* [retval][out] */ VARIANT_BOOL *hasFeature) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMImplementationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMImplementation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMImplementation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMImplementation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMImplementation * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMImplementation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMImplementation * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMImplementation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *hasFeature )( 
            IXMLDOMImplementation * This,
            /* [in] */ BSTR feature,
            /* [in] */ BSTR version,
            /* [retval][out] */ VARIANT_BOOL *hasFeature);
        
        END_INTERFACE
    } IXMLDOMImplementationVtbl;

    interface IXMLDOMImplementation
    {
        CONST_VTBL struct IXMLDOMImplementationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMImplementation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMImplementation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMImplementation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMImplementation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMImplementation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMImplementation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMImplementation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMImplementation_hasFeature(This,feature,version,hasFeature)	\
    (This)->lpVtbl -> hasFeature(This,feature,version,hasFeature)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMImplementation_hasFeature_Proxy( 
    IXMLDOMImplementation * This,
    /* [in] */ BSTR feature,
    /* [in] */ BSTR version,
    /* [retval][out] */ VARIANT_BOOL *hasFeature);


void __RPC_STUB IXMLDOMImplementation_hasFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMImplementation_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNode_INTERFACE_DEFINED__
#define __IXMLDOMNode_INTERFACE_DEFINED__

/* interface IXMLDOMNode */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF80-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNode : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeName( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeValue( 
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_nodeValue( 
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeType( 
            /* [retval][out] */ DOMNodeType *type) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parentNode( 
            /* [retval][out] */ IXMLDOMNode **parent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_childNodes( 
            /* [retval][out] */ IXMLDOMNodeList **childList) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_firstChild( 
            /* [retval][out] */ IXMLDOMNode **firstChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lastChild( 
            /* [retval][out] */ IXMLDOMNode **lastChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_previousSibling( 
            /* [retval][out] */ IXMLDOMNode **previousSibling) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nextSibling( 
            /* [retval][out] */ IXMLDOMNode **nextSibling) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE insertBefore( 
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE replaceChild( 
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE appendChild( 
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE hasChildNodes( 
            /* [retval][out] */ VARIANT_BOOL *hasChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ownerDocument( 
            /* [retval][out] */ IXMLDOMDocument **DOMDocument) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE cloneNode( 
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeTypeString( 
            /* [out][retval] */ BSTR *nodeType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR *text) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR text) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_specified( 
            /* [retval][out] */ VARIANT_BOOL *isSpecified) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_definition( 
            /* [out][retval] */ IXMLDOMNode **definitionNode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeTypedValue( 
            /* [out][retval] */ VARIANT *typedValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_nodeTypedValue( 
            /* [in] */ VARIANT typedValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_dataType( 
            /* [out][retval] */ VARIANT *dataTypeName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_dataType( 
            /* [in] */ BSTR dataTypeName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_xml( 
            /* [out][retval] */ BSTR *xmlString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE transformNode( 
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE selectNodes( 
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE selectSingleNode( 
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parsed( 
            /* [out][retval] */ VARIANT_BOOL *isParsed) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_namespaceURI( 
            /* [out][retval] */ BSTR *namespaceURI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_prefix( 
            /* [out][retval] */ BSTR *prefixString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_baseName( 
            /* [out][retval] */ BSTR *nameString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE transformNodeToObject( 
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMNode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMNode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMNode * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMNode * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMNode * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMNode * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMNode * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMNode * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMNode * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMNode * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMNode * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMNode * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMNode * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMNode * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMNode * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMNode * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMNode * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMNode * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMNode * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMNode * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMNode * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMNode * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMNode * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMNodeVtbl;

    interface IXMLDOMNode
    {
        CONST_VTBL struct IXMLDOMNodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNode_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMNode_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMNode_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMNode_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMNode_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMNode_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMNode_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMNode_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMNode_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMNode_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMNode_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMNode_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMNode_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMNode_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMNode_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMNode_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMNode_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMNode_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMNode_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMNode_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMNode_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMNode_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMNode_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMNode_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMNode_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMNode_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMNode_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMNode_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMNode_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMNode_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMNode_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMNode_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMNode_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMNode_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMNode_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMNode_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeName_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB IXMLDOMNode_get_nodeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeValue_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IXMLDOMNode_get_nodeValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_nodeValue_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMNode_put_nodeValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeType_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ DOMNodeType *type);


void __RPC_STUB IXMLDOMNode_get_nodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_parentNode_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **parent);


void __RPC_STUB IXMLDOMNode_get_parentNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_childNodes_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNodeList **childList);


void __RPC_STUB IXMLDOMNode_get_childNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_firstChild_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **firstChild);


void __RPC_STUB IXMLDOMNode_get_firstChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_lastChild_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **lastChild);


void __RPC_STUB IXMLDOMNode_get_lastChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_previousSibling_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **previousSibling);


void __RPC_STUB IXMLDOMNode_get_previousSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nextSibling_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **nextSibling);


void __RPC_STUB IXMLDOMNode_get_nextSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_attributes_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);


void __RPC_STUB IXMLDOMNode_get_attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_insertBefore_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *newChild,
    /* [in] */ VARIANT refChild,
    /* [retval][out] */ IXMLDOMNode **outNewChild);


void __RPC_STUB IXMLDOMNode_insertBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_replaceChild_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *newChild,
    /* [in] */ IXMLDOMNode *oldChild,
    /* [retval][out] */ IXMLDOMNode **outOldChild);


void __RPC_STUB IXMLDOMNode_replaceChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_removeChild_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *childNode,
    /* [retval][out] */ IXMLDOMNode **oldChild);


void __RPC_STUB IXMLDOMNode_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_appendChild_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *newChild,
    /* [retval][out] */ IXMLDOMNode **outNewChild);


void __RPC_STUB IXMLDOMNode_appendChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_hasChildNodes_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ VARIANT_BOOL *hasChild);


void __RPC_STUB IXMLDOMNode_hasChildNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_ownerDocument_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMDocument **DOMDocument);


void __RPC_STUB IXMLDOMNode_get_ownerDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_cloneNode_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ VARIANT_BOOL deep,
    /* [retval][out] */ IXMLDOMNode **cloneRoot);


void __RPC_STUB IXMLDOMNode_cloneNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeTypeString_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *nodeType);


void __RPC_STUB IXMLDOMNode_get_nodeTypeString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_text_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *text);


void __RPC_STUB IXMLDOMNode_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_text_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ BSTR text);


void __RPC_STUB IXMLDOMNode_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_specified_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ VARIANT_BOOL *isSpecified);


void __RPC_STUB IXMLDOMNode_get_specified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_definition_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ IXMLDOMNode **definitionNode);


void __RPC_STUB IXMLDOMNode_get_definition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeTypedValue_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ VARIANT *typedValue);


void __RPC_STUB IXMLDOMNode_get_nodeTypedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_nodeTypedValue_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ VARIANT typedValue);


void __RPC_STUB IXMLDOMNode_put_nodeTypedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_dataType_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ VARIANT *dataTypeName);


void __RPC_STUB IXMLDOMNode_get_dataType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_dataType_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ BSTR dataTypeName);


void __RPC_STUB IXMLDOMNode_put_dataType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_xml_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *xmlString);


void __RPC_STUB IXMLDOMNode_get_xml_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_transformNode_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *stylesheet,
    /* [out][retval] */ BSTR *xmlString);


void __RPC_STUB IXMLDOMNode_transformNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_selectNodes_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ BSTR queryString,
    /* [out][retval] */ IXMLDOMNodeList **resultList);


void __RPC_STUB IXMLDOMNode_selectNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_selectSingleNode_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ BSTR queryString,
    /* [out][retval] */ IXMLDOMNode **resultNode);


void __RPC_STUB IXMLDOMNode_selectSingleNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_parsed_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ VARIANT_BOOL *isParsed);


void __RPC_STUB IXMLDOMNode_get_parsed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_namespaceURI_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *namespaceURI);


void __RPC_STUB IXMLDOMNode_get_namespaceURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_prefix_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *prefixString);


void __RPC_STUB IXMLDOMNode_get_prefix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_baseName_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *nameString);


void __RPC_STUB IXMLDOMNode_get_baseName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_transformNodeToObject_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *stylesheet,
    /* [in] */ VARIANT outputObject);


void __RPC_STUB IXMLDOMNode_transformNodeToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNode_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocumentFragment_INTERFACE_DEFINED__
#define __IXMLDOMDocumentFragment_INTERFACE_DEFINED__

/* interface IXMLDOMDocumentFragment */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocumentFragment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa413-272f-11d2-836f-0000f87a7782")
    IXMLDOMDocumentFragment : public IXMLDOMNode
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentFragmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMDocumentFragment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMDocumentFragment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMDocumentFragment * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMDocumentFragmentVtbl;

    interface IXMLDOMDocumentFragment
    {
        CONST_VTBL struct IXMLDOMDocumentFragmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocumentFragment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocumentFragment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocumentFragment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocumentFragment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocumentFragment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocumentFragment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocumentFragment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocumentFragment_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocumentFragment_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocumentFragment_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocumentFragment_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocumentFragment_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocumentFragment_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocumentFragment_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocumentFragment_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocumentFragment_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocumentFragment_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocumentFragment_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocumentFragment_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocumentFragment_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocumentFragment_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocumentFragment_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocumentFragment_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocumentFragment_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocumentFragment_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocumentFragment_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocumentFragment_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocumentFragment_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocumentFragment_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocumentFragment_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocumentFragment_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentFragment_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentFragment_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocumentFragment_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocumentFragment_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocumentFragment_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocumentFragment_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocumentFragment_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocumentFragment_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocumentFragment_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocumentFragment_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocumentFragment_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocumentFragment_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMDocumentFragment_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocument_INTERFACE_DEFINED__
#define __IXMLDOMDocument_INTERFACE_DEFINED__

/* interface IXMLDOMDocument */
/* [hidden][unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF81-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocument : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [retval][out] */ IXMLDOMDocumentType **documentType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_implementation( 
            /* [retval][out] */ IXMLDOMImplementation **impl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_documentElement( 
            /* [retval][out] */ IXMLDOMElement **DOMElement) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_documentElement( 
            /* [in] */ IXMLDOMElement *DOMElement) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement **element) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createDocumentFragment( 
            /* [retval][out] */ IXMLDOMDocumentFragment **docFrag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createTextNode( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText **text) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createComment( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment **comment) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createCDATASection( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection **cdata) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createProcessingInstruction( 
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction **pi) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createAttribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attribute) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createEntityReference( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference **entityRef) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getElementsByTagName( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createNode( 
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode **node) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nodeFromID( 
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode **node) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parseError( 
            /* [out][retval] */ IXMLDOMParseError **errorObj) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
            /* [out][retval] */ BSTR *urlString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_async( 
            /* [out][retval] */ VARIANT_BOOL *isAsync) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_async( 
            /* [in] */ VARIANT_BOOL isAsync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE loadXML( 
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ VARIANT destination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_validateOnParse( 
            /* [out][retval] */ VARIANT_BOOL *isValidating) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_validateOnParse( 
            /* [in] */ VARIANT_BOOL isValidating) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_resolveExternals( 
            /* [out][retval] */ VARIANT_BOOL *isResolving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_resolveExternals( 
            /* [in] */ VARIANT_BOOL isResolving) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_preserveWhiteSpace( 
            /* [out][retval] */ VARIANT_BOOL *isPreserving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_preserveWhiteSpace( 
            /* [in] */ VARIANT_BOOL isPreserving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ VARIANT readystatechangeSink) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ondataavailable( 
            /* [in] */ VARIANT ondataavailableSink) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ontransformnode( 
            /* [in] */ VARIANT ontransformnodeSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMDocument * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMDocument * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMDocument * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMDocument * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMDocumentType **documentType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_implementation )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMImplementation **impl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_documentElement )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMElement **DOMElement);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_documentElement )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMElement *DOMElement);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement **element);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createDocumentFragment )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMDocumentFragment **docFrag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createTextNode )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText **text);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createComment )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment **comment);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createCDATASection )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection **cdata);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createProcessingInstruction )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction **pi);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createAttribute )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attribute);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createEntityReference )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference **entityRef);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getElementsByTagName )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createNode )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nodeFromID )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *load )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ long *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parseError )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ IXMLDOMParseError **errorObj);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_url )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_async )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isAsync);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_async )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL isAsync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IXMLDOMDocument * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *loadXML )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *save )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT destination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_validateOnParse )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isValidating);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_validateOnParse )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL isValidating);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_resolveExternals )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isResolving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_resolveExternals )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL isResolving);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_preserveWhiteSpace )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_preserveWhiteSpace )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT readystatechangeSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ondataavailable )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT ondataavailableSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ontransformnode )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT ontransformnodeSink);
        
        END_INTERFACE
    } IXMLDOMDocumentVtbl;

    interface IXMLDOMDocument
    {
        CONST_VTBL struct IXMLDOMDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocument_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocument_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocument_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocument_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocument_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocument_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocument_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocument_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocument_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocument_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocument_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocument_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocument_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocument_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocument_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocument_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocument_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocument_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocument_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocument_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocument_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocument_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocument_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocument_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocument_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocument_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocument_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocument_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocument_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocument_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocument_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocument_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocument_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocument_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocument_get_doctype(This,documentType)	\
    (This)->lpVtbl -> get_doctype(This,documentType)

#define IXMLDOMDocument_get_implementation(This,impl)	\
    (This)->lpVtbl -> get_implementation(This,impl)

#define IXMLDOMDocument_get_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> get_documentElement(This,DOMElement)

#define IXMLDOMDocument_putref_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> putref_documentElement(This,DOMElement)

#define IXMLDOMDocument_createElement(This,tagName,element)	\
    (This)->lpVtbl -> createElement(This,tagName,element)

#define IXMLDOMDocument_createDocumentFragment(This,docFrag)	\
    (This)->lpVtbl -> createDocumentFragment(This,docFrag)

#define IXMLDOMDocument_createTextNode(This,data,text)	\
    (This)->lpVtbl -> createTextNode(This,data,text)

#define IXMLDOMDocument_createComment(This,data,comment)	\
    (This)->lpVtbl -> createComment(This,data,comment)

#define IXMLDOMDocument_createCDATASection(This,data,cdata)	\
    (This)->lpVtbl -> createCDATASection(This,data,cdata)

#define IXMLDOMDocument_createProcessingInstruction(This,target,data,pi)	\
    (This)->lpVtbl -> createProcessingInstruction(This,target,data,pi)

#define IXMLDOMDocument_createAttribute(This,name,attribute)	\
    (This)->lpVtbl -> createAttribute(This,name,attribute)

#define IXMLDOMDocument_createEntityReference(This,name,entityRef)	\
    (This)->lpVtbl -> createEntityReference(This,name,entityRef)

#define IXMLDOMDocument_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IXMLDOMDocument_createNode(This,Type,name,namespaceURI,node)	\
    (This)->lpVtbl -> createNode(This,Type,name,namespaceURI,node)

#define IXMLDOMDocument_nodeFromID(This,idString,node)	\
    (This)->lpVtbl -> nodeFromID(This,idString,node)

#define IXMLDOMDocument_load(This,xmlSource,isSuccessful)	\
    (This)->lpVtbl -> load(This,xmlSource,isSuccessful)

#define IXMLDOMDocument_get_readyState(This,value)	\
    (This)->lpVtbl -> get_readyState(This,value)

#define IXMLDOMDocument_get_parseError(This,errorObj)	\
    (This)->lpVtbl -> get_parseError(This,errorObj)

#define IXMLDOMDocument_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMDocument_get_async(This,isAsync)	\
    (This)->lpVtbl -> get_async(This,isAsync)

#define IXMLDOMDocument_put_async(This,isAsync)	\
    (This)->lpVtbl -> put_async(This,isAsync)

#define IXMLDOMDocument_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLDOMDocument_loadXML(This,bstrXML,isSuccessful)	\
    (This)->lpVtbl -> loadXML(This,bstrXML,isSuccessful)

#define IXMLDOMDocument_save(This,destination)	\
    (This)->lpVtbl -> save(This,destination)

#define IXMLDOMDocument_get_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> get_validateOnParse(This,isValidating)

#define IXMLDOMDocument_put_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> put_validateOnParse(This,isValidating)

#define IXMLDOMDocument_get_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> get_resolveExternals(This,isResolving)

#define IXMLDOMDocument_put_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> put_resolveExternals(This,isResolving)

#define IXMLDOMDocument_get_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> get_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument_put_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> put_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument_put_onreadystatechange(This,readystatechangeSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,readystatechangeSink)

#define IXMLDOMDocument_put_ondataavailable(This,ondataavailableSink)	\
    (This)->lpVtbl -> put_ondataavailable(This,ondataavailableSink)

#define IXMLDOMDocument_put_ontransformnode(This,ontransformnodeSink)	\
    (This)->lpVtbl -> put_ontransformnode(This,ontransformnodeSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_doctype_Proxy( 
    IXMLDOMDocument * This,
    /* [retval][out] */ IXMLDOMDocumentType **documentType);


void __RPC_STUB IXMLDOMDocument_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_implementation_Proxy( 
    IXMLDOMDocument * This,
    /* [retval][out] */ IXMLDOMImplementation **impl);


void __RPC_STUB IXMLDOMDocument_get_implementation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_documentElement_Proxy( 
    IXMLDOMDocument * This,
    /* [retval][out] */ IXMLDOMElement **DOMElement);


void __RPC_STUB IXMLDOMDocument_get_documentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_putref_documentElement_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ IXMLDOMElement *DOMElement);


void __RPC_STUB IXMLDOMDocument_putref_documentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createElement_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMElement **element);


void __RPC_STUB IXMLDOMDocument_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createDocumentFragment_Proxy( 
    IXMLDOMDocument * This,
    /* [retval][out] */ IXMLDOMDocumentFragment **docFrag);


void __RPC_STUB IXMLDOMDocument_createDocumentFragment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createTextNode_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMText **text);


void __RPC_STUB IXMLDOMDocument_createTextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createComment_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMComment **comment);


void __RPC_STUB IXMLDOMDocument_createComment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createCDATASection_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMCDATASection **cdata);


void __RPC_STUB IXMLDOMDocument_createCDATASection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createProcessingInstruction_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR target,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMProcessingInstruction **pi);


void __RPC_STUB IXMLDOMDocument_createProcessingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createAttribute_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMAttribute **attribute);


void __RPC_STUB IXMLDOMDocument_createAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createEntityReference_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMEntityReference **entityRef);


void __RPC_STUB IXMLDOMDocument_createEntityReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_getElementsByTagName_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMNodeList **resultList);


void __RPC_STUB IXMLDOMDocument_getElementsByTagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createNode_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT Type,
    /* [in] */ BSTR name,
    /* [in] */ BSTR namespaceURI,
    /* [out][retval] */ IXMLDOMNode **node);


void __RPC_STUB IXMLDOMDocument_createNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_nodeFromID_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR idString,
    /* [out][retval] */ IXMLDOMNode **node);


void __RPC_STUB IXMLDOMDocument_nodeFromID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_load_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT xmlSource,
    /* [retval][out] */ VARIANT_BOOL *isSuccessful);


void __RPC_STUB IXMLDOMDocument_load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_readyState_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ long *value);


void __RPC_STUB IXMLDOMDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_parseError_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ IXMLDOMParseError **errorObj);


void __RPC_STUB IXMLDOMDocument_get_parseError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_url_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ BSTR *urlString);


void __RPC_STUB IXMLDOMDocument_get_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_async_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ VARIANT_BOOL *isAsync);


void __RPC_STUB IXMLDOMDocument_get_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_async_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT_BOOL isAsync);


void __RPC_STUB IXMLDOMDocument_put_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_abort_Proxy( 
    IXMLDOMDocument * This);


void __RPC_STUB IXMLDOMDocument_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_loadXML_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR bstrXML,
    /* [retval][out] */ VARIANT_BOOL *isSuccessful);


void __RPC_STUB IXMLDOMDocument_loadXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_save_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT destination);


void __RPC_STUB IXMLDOMDocument_save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_validateOnParse_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ VARIANT_BOOL *isValidating);


void __RPC_STUB IXMLDOMDocument_get_validateOnParse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_validateOnParse_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT_BOOL isValidating);


void __RPC_STUB IXMLDOMDocument_put_validateOnParse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_resolveExternals_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ VARIANT_BOOL *isResolving);


void __RPC_STUB IXMLDOMDocument_get_resolveExternals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_resolveExternals_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT_BOOL isResolving);


void __RPC_STUB IXMLDOMDocument_put_resolveExternals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_preserveWhiteSpace_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ VARIANT_BOOL *isPreserving);


void __RPC_STUB IXMLDOMDocument_get_preserveWhiteSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_preserveWhiteSpace_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT_BOOL isPreserving);


void __RPC_STUB IXMLDOMDocument_put_preserveWhiteSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_onreadystatechange_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT readystatechangeSink);


void __RPC_STUB IXMLDOMDocument_put_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_ondataavailable_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT ondataavailableSink);


void __RPC_STUB IXMLDOMDocument_put_ondataavailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_ontransformnode_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT ontransformnodeSink);


void __RPC_STUB IXMLDOMDocument_put_ontransformnode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocument_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMSchemaCollection_INTERFACE_DEFINED__
#define __IXMLDOMSchemaCollection_INTERFACE_DEFINED__

/* interface IXMLDOMSchemaCollection */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMSchemaCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("373984c8-b845-449b-91e7-45ac83036ade")
    IXMLDOMSchemaCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE add( 
            /* [in] */ BSTR namespaceURI,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE get( 
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **schemaNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE remove( 
            /* [in] */ BSTR namespaceURI) = 0;
        
        virtual /* [propget][helpstring][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *length) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_namespaceURI( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR *length) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addCollection( 
            /* [in] */ IXMLDOMSchemaCollection *otherCollection) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMSchemaCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMSchemaCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMSchemaCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMSchemaCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *add )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ BSTR namespaceURI,
            /* [in] */ VARIANT var);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *get )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **schemaNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *remove )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ BSTR namespaceURI);
        
        /* [propget][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMSchemaCollection * This,
            /* [retval][out] */ long *length);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *length);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addCollection )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ IXMLDOMSchemaCollection *otherCollection);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMSchemaCollection * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IXMLDOMSchemaCollectionVtbl;

    interface IXMLDOMSchemaCollection
    {
        CONST_VTBL struct IXMLDOMSchemaCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMSchemaCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMSchemaCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMSchemaCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMSchemaCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMSchemaCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMSchemaCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMSchemaCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMSchemaCollection_add(This,namespaceURI,var)	\
    (This)->lpVtbl -> add(This,namespaceURI,var)

#define IXMLDOMSchemaCollection_get(This,namespaceURI,schemaNode)	\
    (This)->lpVtbl -> get(This,namespaceURI,schemaNode)

#define IXMLDOMSchemaCollection_remove(This,namespaceURI)	\
    (This)->lpVtbl -> remove(This,namespaceURI)

#define IXMLDOMSchemaCollection_get_length(This,length)	\
    (This)->lpVtbl -> get_length(This,length)

#define IXMLDOMSchemaCollection_get_namespaceURI(This,index,length)	\
    (This)->lpVtbl -> get_namespaceURI(This,index,length)

#define IXMLDOMSchemaCollection_addCollection(This,otherCollection)	\
    (This)->lpVtbl -> addCollection(This,otherCollection)

#define IXMLDOMSchemaCollection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_add_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ BSTR namespaceURI,
    /* [in] */ VARIANT var);


void __RPC_STUB IXMLDOMSchemaCollection_add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_get_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ BSTR namespaceURI,
    /* [retval][out] */ IXMLDOMNode **schemaNode);


void __RPC_STUB IXMLDOMSchemaCollection_get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_remove_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ BSTR namespaceURI);


void __RPC_STUB IXMLDOMSchemaCollection_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_get_length_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [retval][out] */ long *length);


void __RPC_STUB IXMLDOMSchemaCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_get_namespaceURI_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ long index,
    /* [retval][out] */ BSTR *length);


void __RPC_STUB IXMLDOMSchemaCollection_get_namespaceURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_addCollection_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ IXMLDOMSchemaCollection *otherCollection);


void __RPC_STUB IXMLDOMSchemaCollection_addCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_get__newEnum_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [out][retval] */ IUnknown **ppUnk);


void __RPC_STUB IXMLDOMSchemaCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMSchemaCollection_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocument2_INTERFACE_DEFINED__
#define __IXMLDOMDocument2_INTERFACE_DEFINED__

/* interface IXMLDOMDocument2 */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF95-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocument2 : public IXMLDOMDocument
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_namespaces( 
            /* [retval][out] */ IXMLDOMSchemaCollection **namespaceCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_schemas( 
            /* [retval][out] */ VARIANT *otherCollection) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_schemas( 
            /* [in] */ VARIANT otherCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE validate( 
            /* [out][retval] */ IXMLDOMParseError **errorObj) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMDocument2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMDocument2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMDocument2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMDocument2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMDocument2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMDocument2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMDocument2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMDocumentType **documentType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_implementation )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMImplementation **impl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_documentElement )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMElement **DOMElement);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_documentElement )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMElement *DOMElement);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement **element);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createDocumentFragment )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMDocumentFragment **docFrag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createTextNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText **text);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createComment )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment **comment);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createCDATASection )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection **cdata);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createProcessingInstruction )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction **pi);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createAttribute )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attribute);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createEntityReference )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference **entityRef);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getElementsByTagName )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nodeFromID )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *load )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ long *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parseError )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ IXMLDOMParseError **errorObj);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_url )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_async )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isAsync);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_async )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL isAsync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IXMLDOMDocument2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *loadXML )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *save )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT destination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_validateOnParse )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isValidating);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_validateOnParse )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL isValidating);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_resolveExternals )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isResolving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_resolveExternals )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL isResolving);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_preserveWhiteSpace )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_preserveWhiteSpace )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT readystatechangeSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ondataavailable )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT ondataavailableSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ontransformnode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT ontransformnodeSink);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaces )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMSchemaCollection **namespaceCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_schemas )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ VARIANT *otherCollection);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_schemas )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT otherCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *validate )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ IXMLDOMParseError **errorObj);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setProperty )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value);
        
        END_INTERFACE
    } IXMLDOMDocument2Vtbl;

    interface IXMLDOMDocument2
    {
        CONST_VTBL struct IXMLDOMDocument2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocument2_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocument2_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocument2_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocument2_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocument2_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocument2_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocument2_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocument2_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocument2_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocument2_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocument2_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocument2_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocument2_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocument2_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocument2_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocument2_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocument2_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocument2_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocument2_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocument2_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocument2_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocument2_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocument2_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocument2_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument2_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument2_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocument2_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocument2_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocument2_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocument2_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocument2_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocument2_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocument2_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocument2_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocument2_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocument2_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocument2_get_doctype(This,documentType)	\
    (This)->lpVtbl -> get_doctype(This,documentType)

#define IXMLDOMDocument2_get_implementation(This,impl)	\
    (This)->lpVtbl -> get_implementation(This,impl)

#define IXMLDOMDocument2_get_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> get_documentElement(This,DOMElement)

#define IXMLDOMDocument2_putref_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> putref_documentElement(This,DOMElement)

#define IXMLDOMDocument2_createElement(This,tagName,element)	\
    (This)->lpVtbl -> createElement(This,tagName,element)

#define IXMLDOMDocument2_createDocumentFragment(This,docFrag)	\
    (This)->lpVtbl -> createDocumentFragment(This,docFrag)

#define IXMLDOMDocument2_createTextNode(This,data,text)	\
    (This)->lpVtbl -> createTextNode(This,data,text)

#define IXMLDOMDocument2_createComment(This,data,comment)	\
    (This)->lpVtbl -> createComment(This,data,comment)

#define IXMLDOMDocument2_createCDATASection(This,data,cdata)	\
    (This)->lpVtbl -> createCDATASection(This,data,cdata)

#define IXMLDOMDocument2_createProcessingInstruction(This,target,data,pi)	\
    (This)->lpVtbl -> createProcessingInstruction(This,target,data,pi)

#define IXMLDOMDocument2_createAttribute(This,name,attribute)	\
    (This)->lpVtbl -> createAttribute(This,name,attribute)

#define IXMLDOMDocument2_createEntityReference(This,name,entityRef)	\
    (This)->lpVtbl -> createEntityReference(This,name,entityRef)

#define IXMLDOMDocument2_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IXMLDOMDocument2_createNode(This,Type,name,namespaceURI,node)	\
    (This)->lpVtbl -> createNode(This,Type,name,namespaceURI,node)

#define IXMLDOMDocument2_nodeFromID(This,idString,node)	\
    (This)->lpVtbl -> nodeFromID(This,idString,node)

#define IXMLDOMDocument2_load(This,xmlSource,isSuccessful)	\
    (This)->lpVtbl -> load(This,xmlSource,isSuccessful)

#define IXMLDOMDocument2_get_readyState(This,value)	\
    (This)->lpVtbl -> get_readyState(This,value)

#define IXMLDOMDocument2_get_parseError(This,errorObj)	\
    (This)->lpVtbl -> get_parseError(This,errorObj)

#define IXMLDOMDocument2_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMDocument2_get_async(This,isAsync)	\
    (This)->lpVtbl -> get_async(This,isAsync)

#define IXMLDOMDocument2_put_async(This,isAsync)	\
    (This)->lpVtbl -> put_async(This,isAsync)

#define IXMLDOMDocument2_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLDOMDocument2_loadXML(This,bstrXML,isSuccessful)	\
    (This)->lpVtbl -> loadXML(This,bstrXML,isSuccessful)

#define IXMLDOMDocument2_save(This,destination)	\
    (This)->lpVtbl -> save(This,destination)

#define IXMLDOMDocument2_get_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> get_validateOnParse(This,isValidating)

#define IXMLDOMDocument2_put_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> put_validateOnParse(This,isValidating)

#define IXMLDOMDocument2_get_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> get_resolveExternals(This,isResolving)

#define IXMLDOMDocument2_put_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> put_resolveExternals(This,isResolving)

#define IXMLDOMDocument2_get_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> get_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument2_put_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> put_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument2_put_onreadystatechange(This,readystatechangeSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,readystatechangeSink)

#define IXMLDOMDocument2_put_ondataavailable(This,ondataavailableSink)	\
    (This)->lpVtbl -> put_ondataavailable(This,ondataavailableSink)

#define IXMLDOMDocument2_put_ontransformnode(This,ontransformnodeSink)	\
    (This)->lpVtbl -> put_ontransformnode(This,ontransformnodeSink)


#define IXMLDOMDocument2_get_namespaces(This,namespaceCollection)	\
    (This)->lpVtbl -> get_namespaces(This,namespaceCollection)

#define IXMLDOMDocument2_get_schemas(This,otherCollection)	\
    (This)->lpVtbl -> get_schemas(This,otherCollection)

#define IXMLDOMDocument2_putref_schemas(This,otherCollection)	\
    (This)->lpVtbl -> putref_schemas(This,otherCollection)

#define IXMLDOMDocument2_validate(This,errorObj)	\
    (This)->lpVtbl -> validate(This,errorObj)

#define IXMLDOMDocument2_setProperty(This,name,value)	\
    (This)->lpVtbl -> setProperty(This,name,value)

#define IXMLDOMDocument2_getProperty(This,name,value)	\
    (This)->lpVtbl -> getProperty(This,name,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_get_namespaces_Proxy( 
    IXMLDOMDocument2 * This,
    /* [retval][out] */ IXMLDOMSchemaCollection **namespaceCollection);


void __RPC_STUB IXMLDOMDocument2_get_namespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_get_schemas_Proxy( 
    IXMLDOMDocument2 * This,
    /* [retval][out] */ VARIANT *otherCollection);


void __RPC_STUB IXMLDOMDocument2_get_schemas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_putref_schemas_Proxy( 
    IXMLDOMDocument2 * This,
    /* [in] */ VARIANT otherCollection);


void __RPC_STUB IXMLDOMDocument2_putref_schemas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_validate_Proxy( 
    IXMLDOMDocument2 * This,
    /* [out][retval] */ IXMLDOMParseError **errorObj);


void __RPC_STUB IXMLDOMDocument2_validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_setProperty_Proxy( 
    IXMLDOMDocument2 * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMDocument2_setProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_getProperty_Proxy( 
    IXMLDOMDocument2 * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IXMLDOMDocument2_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocument2_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNodeList_INTERFACE_DEFINED__
#define __IXMLDOMNodeList_INTERFACE_DEFINED__

/* interface IXMLDOMNodeList */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNodeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF82-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNodeList : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *listLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nextNode( 
            /* [retval][out] */ IXMLDOMNode **nextItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNodeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMNodeList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMNodeList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMNodeList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMNodeList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMNodeList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMNodeList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMNodeList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IXMLDOMNodeList * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMNodeList * This,
            /* [retval][out] */ long *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nextNode )( 
            IXMLDOMNodeList * This,
            /* [retval][out] */ IXMLDOMNode **nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXMLDOMNodeList * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMNodeList * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IXMLDOMNodeListVtbl;

    interface IXMLDOMNodeList
    {
        CONST_VTBL struct IXMLDOMNodeListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNodeList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNodeList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNodeList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNodeList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNodeList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNodeList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNodeList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNodeList_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMNodeList_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMNodeList_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMNodeList_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMNodeList_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get_item_Proxy( 
    IXMLDOMNodeList * This,
    /* [in] */ long index,
    /* [retval][out] */ IXMLDOMNode **listItem);


void __RPC_STUB IXMLDOMNodeList_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get_length_Proxy( 
    IXMLDOMNodeList * This,
    /* [retval][out] */ long *listLength);


void __RPC_STUB IXMLDOMNodeList_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_nextNode_Proxy( 
    IXMLDOMNodeList * This,
    /* [retval][out] */ IXMLDOMNode **nextItem);


void __RPC_STUB IXMLDOMNodeList_nextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_reset_Proxy( 
    IXMLDOMNodeList * This);


void __RPC_STUB IXMLDOMNodeList_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get__newEnum_Proxy( 
    IXMLDOMNodeList * This,
    /* [out][retval] */ IUnknown **ppUnk);


void __RPC_STUB IXMLDOMNodeList_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNodeList_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__
#define __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__

/* interface IXMLDOMNamedNodeMap */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNamedNodeMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF83-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNamedNodeMap : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getNamedItem( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode **namedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setNamedItem( 
            /* [in] */ IXMLDOMNode *newItem,
            /* [retval][out] */ IXMLDOMNode **nameItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeNamedItem( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode **namedItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *listLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getQualifiedItem( 
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **qualifiedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeQualifiedItem( 
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **qualifiedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nextNode( 
            /* [retval][out] */ IXMLDOMNode **nextItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNamedNodeMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMNamedNodeMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMNamedNodeMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMNamedNodeMap * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getNamedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode **namedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setNamedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ IXMLDOMNode *newItem,
            /* [retval][out] */ IXMLDOMNode **nameItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeNamedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode **namedItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMNamedNodeMap * This,
            /* [retval][out] */ long *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getQualifiedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **qualifiedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeQualifiedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **qualifiedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nextNode )( 
            IXMLDOMNamedNodeMap * This,
            /* [retval][out] */ IXMLDOMNode **nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXMLDOMNamedNodeMap * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMNamedNodeMap * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IXMLDOMNamedNodeMapVtbl;

    interface IXMLDOMNamedNodeMap
    {
        CONST_VTBL struct IXMLDOMNamedNodeMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNamedNodeMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNamedNodeMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNamedNodeMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNamedNodeMap_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNamedNodeMap_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNamedNodeMap_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNamedNodeMap_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNamedNodeMap_getNamedItem(This,name,namedItem)	\
    (This)->lpVtbl -> getNamedItem(This,name,namedItem)

#define IXMLDOMNamedNodeMap_setNamedItem(This,newItem,nameItem)	\
    (This)->lpVtbl -> setNamedItem(This,newItem,nameItem)

#define IXMLDOMNamedNodeMap_removeNamedItem(This,name,namedItem)	\
    (This)->lpVtbl -> removeNamedItem(This,name,namedItem)

#define IXMLDOMNamedNodeMap_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMNamedNodeMap_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMNamedNodeMap_getQualifiedItem(This,baseName,namespaceURI,qualifiedItem)	\
    (This)->lpVtbl -> getQualifiedItem(This,baseName,namespaceURI,qualifiedItem)

#define IXMLDOMNamedNodeMap_removeQualifiedItem(This,baseName,namespaceURI,qualifiedItem)	\
    (This)->lpVtbl -> removeQualifiedItem(This,baseName,namespaceURI,qualifiedItem)

#define IXMLDOMNamedNodeMap_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMNamedNodeMap_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMNamedNodeMap_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_getNamedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMNode **namedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_getNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_setNamedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ IXMLDOMNode *newItem,
    /* [retval][out] */ IXMLDOMNode **nameItem);


void __RPC_STUB IXMLDOMNamedNodeMap_setNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_removeNamedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMNode **namedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_removeNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get_item_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ long index,
    /* [retval][out] */ IXMLDOMNode **listItem);


void __RPC_STUB IXMLDOMNamedNodeMap_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get_length_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [retval][out] */ long *listLength);


void __RPC_STUB IXMLDOMNamedNodeMap_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_getQualifiedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ BSTR baseName,
    /* [in] */ BSTR namespaceURI,
    /* [retval][out] */ IXMLDOMNode **qualifiedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_getQualifiedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_removeQualifiedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ BSTR baseName,
    /* [in] */ BSTR namespaceURI,
    /* [retval][out] */ IXMLDOMNode **qualifiedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_removeQualifiedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_nextNode_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [retval][out] */ IXMLDOMNode **nextItem);


void __RPC_STUB IXMLDOMNamedNodeMap_nextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_reset_Proxy( 
    IXMLDOMNamedNodeMap * This);


void __RPC_STUB IXMLDOMNamedNodeMap_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get__newEnum_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [out][retval] */ IUnknown **ppUnk);


void __RPC_STUB IXMLDOMNamedNodeMap_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMCharacterData_INTERFACE_DEFINED__
#define __IXMLDOMCharacterData_INTERFACE_DEFINED__

/* interface IXMLDOMCharacterData */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMCharacterData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF84-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMCharacterData : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_data( 
            /* [retval][out] */ BSTR *data) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_data( 
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *dataLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE substringData( 
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE appendData( 
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE insertData( 
            /* [in] */ long offset,
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteData( 
            /* [in] */ long offset,
            /* [in] */ long count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE replaceData( 
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCharacterDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMCharacterData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMCharacterData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMCharacterData * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMCharacterData * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMCharacterData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMCharacterData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMCharacterData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMCharacterData * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMCharacterData * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMCharacterData * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ long *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *substringData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        END_INTERFACE
    } IXMLDOMCharacterDataVtbl;

    interface IXMLDOMCharacterData
    {
        CONST_VTBL struct IXMLDOMCharacterDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMCharacterData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMCharacterData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMCharacterData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMCharacterData_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMCharacterData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMCharacterData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMCharacterData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMCharacterData_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMCharacterData_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMCharacterData_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMCharacterData_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMCharacterData_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMCharacterData_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMCharacterData_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMCharacterData_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMCharacterData_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMCharacterData_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMCharacterData_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMCharacterData_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMCharacterData_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMCharacterData_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMCharacterData_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMCharacterData_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMCharacterData_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMCharacterData_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMCharacterData_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMCharacterData_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMCharacterData_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMCharacterData_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMCharacterData_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMCharacterData_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMCharacterData_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMCharacterData_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMCharacterData_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMCharacterData_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMCharacterData_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMCharacterData_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMCharacterData_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMCharacterData_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMCharacterData_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMCharacterData_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMCharacterData_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMCharacterData_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMCharacterData_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMCharacterData_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMCharacterData_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMCharacterData_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMCharacterData_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMCharacterData_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMCharacterData_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMCharacterData_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_get_data_Proxy( 
    IXMLDOMCharacterData * This,
    /* [retval][out] */ BSTR *data);


void __RPC_STUB IXMLDOMCharacterData_get_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_put_data_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_put_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_get_length_Proxy( 
    IXMLDOMCharacterData * This,
    /* [retval][out] */ long *dataLength);


void __RPC_STUB IXMLDOMCharacterData_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_substringData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ long offset,
    /* [in] */ long count,
    /* [retval][out] */ BSTR *data);


void __RPC_STUB IXMLDOMCharacterData_substringData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_appendData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_appendData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_insertData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ long offset,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_insertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_deleteData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ long offset,
    /* [in] */ long count);


void __RPC_STUB IXMLDOMCharacterData_deleteData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_replaceData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ long offset,
    /* [in] */ long count,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_replaceData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMCharacterData_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMAttribute_INTERFACE_DEFINED__
#define __IXMLDOMAttribute_INTERFACE_DEFINED__

/* interface IXMLDOMAttribute */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF85-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMAttribute : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *attributeName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [retval][out] */ VARIANT *attributeValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ VARIANT attributeValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMAttribute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMAttribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMAttribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMAttribute * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMAttribute * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMAttribute * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMAttribute * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMAttribute * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMAttribute * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMAttribute * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMAttribute * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMAttribute * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMAttribute * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMAttribute * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ BSTR *attributeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_value )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ VARIANT *attributeValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_value )( 
            IXMLDOMAttribute * This,
            /* [in] */ VARIANT attributeValue);
        
        END_INTERFACE
    } IXMLDOMAttributeVtbl;

    interface IXMLDOMAttribute
    {
        CONST_VTBL struct IXMLDOMAttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMAttribute_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMAttribute_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMAttribute_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMAttribute_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMAttribute_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMAttribute_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMAttribute_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMAttribute_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMAttribute_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMAttribute_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMAttribute_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMAttribute_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMAttribute_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMAttribute_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMAttribute_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMAttribute_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMAttribute_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMAttribute_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMAttribute_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMAttribute_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMAttribute_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMAttribute_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMAttribute_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMAttribute_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMAttribute_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMAttribute_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMAttribute_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMAttribute_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMAttribute_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMAttribute_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMAttribute_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMAttribute_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMAttribute_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMAttribute_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMAttribute_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMAttribute_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMAttribute_get_name(This,attributeName)	\
    (This)->lpVtbl -> get_name(This,attributeName)

#define IXMLDOMAttribute_get_value(This,attributeValue)	\
    (This)->lpVtbl -> get_value(This,attributeValue)

#define IXMLDOMAttribute_put_value(This,attributeValue)	\
    (This)->lpVtbl -> put_value(This,attributeValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_get_name_Proxy( 
    IXMLDOMAttribute * This,
    /* [retval][out] */ BSTR *attributeName);


void __RPC_STUB IXMLDOMAttribute_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_get_value_Proxy( 
    IXMLDOMAttribute * This,
    /* [retval][out] */ VARIANT *attributeValue);


void __RPC_STUB IXMLDOMAttribute_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_put_value_Proxy( 
    IXMLDOMAttribute * This,
    /* [in] */ VARIANT attributeValue);


void __RPC_STUB IXMLDOMAttribute_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMAttribute_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMElement_INTERFACE_DEFINED__
#define __IXMLDOMElement_INTERFACE_DEFINED__

/* interface IXMLDOMElement */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF86-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMElement : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [retval][out] */ BSTR *tagName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR name) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttributeNode( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttributeNode( 
            /* [in] */ IXMLDOMAttribute *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttributeNode( 
            /* [in] */ IXMLDOMAttribute *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getElementsByTagName( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE normalize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMElement * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMElement * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMElement * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMElement * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMElement * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMElement * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMElement * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMElement * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMElement * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMElement * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMElement * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMElement * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_tagName )( 
            IXMLDOMElement * This,
            /* [retval][out] */ BSTR *tagName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAttribute )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAttributeNode )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttributeNode )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMAttribute *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttributeNode )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMAttribute *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getElementsByTagName )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *normalize )( 
            IXMLDOMElement * This);
        
        END_INTERFACE
    } IXMLDOMElementVtbl;

    interface IXMLDOMElement
    {
        CONST_VTBL struct IXMLDOMElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMElement_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMElement_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMElement_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMElement_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMElement_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMElement_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMElement_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMElement_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMElement_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMElement_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMElement_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMElement_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMElement_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMElement_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMElement_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMElement_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMElement_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMElement_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMElement_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMElement_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMElement_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMElement_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMElement_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMElement_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMElement_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMElement_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMElement_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMElement_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMElement_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMElement_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMElement_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMElement_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMElement_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMElement_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMElement_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMElement_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMElement_get_tagName(This,tagName)	\
    (This)->lpVtbl -> get_tagName(This,tagName)

#define IXMLDOMElement_getAttribute(This,name,value)	\
    (This)->lpVtbl -> getAttribute(This,name,value)

#define IXMLDOMElement_setAttribute(This,name,value)	\
    (This)->lpVtbl -> setAttribute(This,name,value)

#define IXMLDOMElement_removeAttribute(This,name)	\
    (This)->lpVtbl -> removeAttribute(This,name)

#define IXMLDOMElement_getAttributeNode(This,name,attributeNode)	\
    (This)->lpVtbl -> getAttributeNode(This,name,attributeNode)

#define IXMLDOMElement_setAttributeNode(This,DOMAttribute,attributeNode)	\
    (This)->lpVtbl -> setAttributeNode(This,DOMAttribute,attributeNode)

#define IXMLDOMElement_removeAttributeNode(This,DOMAttribute,attributeNode)	\
    (This)->lpVtbl -> removeAttributeNode(This,DOMAttribute,attributeNode)

#define IXMLDOMElement_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IXMLDOMElement_normalize(This)	\
    (This)->lpVtbl -> normalize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_get_tagName_Proxy( 
    IXMLDOMElement * This,
    /* [retval][out] */ BSTR *tagName);


void __RPC_STUB IXMLDOMElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getAttribute_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IXMLDOMElement_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_setAttribute_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMElement_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_removeAttribute_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR name);


void __RPC_STUB IXMLDOMElement_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getAttributeNode_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMAttribute **attributeNode);


void __RPC_STUB IXMLDOMElement_getAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_setAttributeNode_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ IXMLDOMAttribute *DOMAttribute,
    /* [retval][out] */ IXMLDOMAttribute **attributeNode);


void __RPC_STUB IXMLDOMElement_setAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_removeAttributeNode_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ IXMLDOMAttribute *DOMAttribute,
    /* [retval][out] */ IXMLDOMAttribute **attributeNode);


void __RPC_STUB IXMLDOMElement_removeAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getElementsByTagName_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMNodeList **resultList);


void __RPC_STUB IXMLDOMElement_getElementsByTagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_normalize_Proxy( 
    IXMLDOMElement * This);


void __RPC_STUB IXMLDOMElement_normalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMElement_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMText_INTERFACE_DEFINED__
#define __IXMLDOMText_INTERFACE_DEFINED__

/* interface IXMLDOMText */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF87-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMText : public IXMLDOMCharacterData
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE splitText( 
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText **rightHandTextNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMText * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMText * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMText * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMText * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMText * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMText * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMText * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMText * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMText * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMText * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMText * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMText * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMText * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMText * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMText * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMText * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMText * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMText * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMText * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMText * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMText * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMText * This,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMText * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMText * This,
            /* [retval][out] */ long *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *substringData )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendData )( 
            IXMLDOMText * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertData )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteData )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceData )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *splitText )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText **rightHandTextNode);
        
        END_INTERFACE
    } IXMLDOMTextVtbl;

    interface IXMLDOMText
    {
        CONST_VTBL struct IXMLDOMTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMText_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMText_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMText_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMText_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMText_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMText_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMText_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMText_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMText_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMText_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMText_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMText_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMText_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMText_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMText_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMText_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMText_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMText_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMText_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMText_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMText_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMText_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMText_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMText_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMText_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMText_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMText_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMText_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMText_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMText_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMText_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMText_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMText_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMText_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMText_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMText_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMText_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMText_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMText_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMText_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMText_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMText_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMText_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMText_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMText_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMText_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMText_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMText_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#define IXMLDOMText_splitText(This,offset,rightHandTextNode)	\
    (This)->lpVtbl -> splitText(This,offset,rightHandTextNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMText_splitText_Proxy( 
    IXMLDOMText * This,
    /* [in] */ long offset,
    /* [retval][out] */ IXMLDOMText **rightHandTextNode);


void __RPC_STUB IXMLDOMText_splitText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMText_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMComment_INTERFACE_DEFINED__
#define __IXMLDOMComment_INTERFACE_DEFINED__

/* interface IXMLDOMComment */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMComment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF88-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMComment : public IXMLDOMCharacterData
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCommentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMComment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMComment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMComment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMComment * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMComment * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMComment * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMComment * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMComment * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMComment * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMComment * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMComment * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMComment * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMComment * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMComment * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMComment * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMComment * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMComment * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMComment * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMComment * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMComment * This,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMComment * This,
            /* [retval][out] */ long *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *substringData )( 
            IXMLDOMComment * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendData )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertData )( 
            IXMLDOMComment * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteData )( 
            IXMLDOMComment * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceData )( 
            IXMLDOMComment * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        END_INTERFACE
    } IXMLDOMCommentVtbl;

    interface IXMLDOMComment
    {
        CONST_VTBL struct IXMLDOMCommentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMComment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMComment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMComment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMComment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMComment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMComment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMComment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMComment_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMComment_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMComment_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMComment_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMComment_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMComment_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMComment_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMComment_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMComment_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMComment_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMComment_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMComment_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMComment_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMComment_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMComment_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMComment_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMComment_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMComment_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMComment_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMComment_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMComment_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMComment_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMComment_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMComment_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMComment_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMComment_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMComment_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMComment_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMComment_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMComment_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMComment_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMComment_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMComment_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMComment_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMComment_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMComment_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMComment_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMComment_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMComment_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMComment_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMComment_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMComment_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMComment_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMComment_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMComment_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__
#define __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__

/* interface IXMLDOMProcessingInstruction */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMProcessingInstruction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF89-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMProcessingInstruction : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_target( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_data( 
            /* [retval][out] */ BSTR *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_data( 
            /* [in] */ BSTR value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMProcessingInstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMProcessingInstruction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMProcessingInstruction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMProcessingInstruction * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_target )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ BSTR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR value);
        
        END_INTERFACE
    } IXMLDOMProcessingInstructionVtbl;

    interface IXMLDOMProcessingInstruction
    {
        CONST_VTBL struct IXMLDOMProcessingInstructionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMProcessingInstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMProcessingInstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMProcessingInstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMProcessingInstruction_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMProcessingInstruction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMProcessingInstruction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMProcessingInstruction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMProcessingInstruction_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMProcessingInstruction_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMProcessingInstruction_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMProcessingInstruction_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMProcessingInstruction_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMProcessingInstruction_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMProcessingInstruction_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMProcessingInstruction_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMProcessingInstruction_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMProcessingInstruction_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMProcessingInstruction_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMProcessingInstruction_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMProcessingInstruction_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMProcessingInstruction_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMProcessingInstruction_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMProcessingInstruction_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMProcessingInstruction_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMProcessingInstruction_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMProcessingInstruction_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMProcessingInstruction_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMProcessingInstruction_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMProcessingInstruction_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMProcessingInstruction_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMProcessingInstruction_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMProcessingInstruction_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMProcessingInstruction_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMProcessingInstruction_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMProcessingInstruction_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMProcessingInstruction_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMProcessingInstruction_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMProcessingInstruction_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMProcessingInstruction_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMProcessingInstruction_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMProcessingInstruction_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMProcessingInstruction_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMProcessingInstruction_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMProcessingInstruction_get_target(This,name)	\
    (This)->lpVtbl -> get_target(This,name)

#define IXMLDOMProcessingInstruction_get_data(This,value)	\
    (This)->lpVtbl -> get_data(This,value)

#define IXMLDOMProcessingInstruction_put_data(This,value)	\
    (This)->lpVtbl -> put_data(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_get_target_Proxy( 
    IXMLDOMProcessingInstruction * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB IXMLDOMProcessingInstruction_get_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_get_data_Proxy( 
    IXMLDOMProcessingInstruction * This,
    /* [retval][out] */ BSTR *value);


void __RPC_STUB IXMLDOMProcessingInstruction_get_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_put_data_Proxy( 
    IXMLDOMProcessingInstruction * This,
    /* [in] */ BSTR value);


void __RPC_STUB IXMLDOMProcessingInstruction_put_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMCDATASection_INTERFACE_DEFINED__
#define __IXMLDOMCDATASection_INTERFACE_DEFINED__

/* interface IXMLDOMCDATASection */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMCDATASection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8A-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMCDATASection : public IXMLDOMText
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCDATASectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMCDATASection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMCDATASection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMCDATASection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMCDATASection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMCDATASection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMCDATASection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMCDATASection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMCDATASection * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMCDATASection * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMCDATASection * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ long *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *substringData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *splitText )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText **rightHandTextNode);
        
        END_INTERFACE
    } IXMLDOMCDATASectionVtbl;

    interface IXMLDOMCDATASection
    {
        CONST_VTBL struct IXMLDOMCDATASectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMCDATASection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMCDATASection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMCDATASection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMCDATASection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMCDATASection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMCDATASection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMCDATASection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMCDATASection_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMCDATASection_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMCDATASection_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMCDATASection_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMCDATASection_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMCDATASection_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMCDATASection_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMCDATASection_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMCDATASection_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMCDATASection_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMCDATASection_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMCDATASection_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMCDATASection_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMCDATASection_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMCDATASection_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMCDATASection_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMCDATASection_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMCDATASection_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMCDATASection_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMCDATASection_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMCDATASection_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMCDATASection_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMCDATASection_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMCDATASection_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMCDATASection_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMCDATASection_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMCDATASection_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMCDATASection_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMCDATASection_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMCDATASection_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMCDATASection_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMCDATASection_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMCDATASection_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMCDATASection_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMCDATASection_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMCDATASection_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMCDATASection_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMCDATASection_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMCDATASection_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMCDATASection_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMCDATASection_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMCDATASection_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMCDATASection_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMCDATASection_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#define IXMLDOMCDATASection_splitText(This,offset,rightHandTextNode)	\
    (This)->lpVtbl -> splitText(This,offset,rightHandTextNode)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMCDATASection_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocumentType_INTERFACE_DEFINED__
#define __IXMLDOMDocumentType_INTERFACE_DEFINED__

/* interface IXMLDOMDocumentType */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocumentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8B-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocumentType : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *rootName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_entities( 
            /* [retval][out] */ IXMLDOMNamedNodeMap **entityMap) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_notations( 
            /* [retval][out] */ IXMLDOMNamedNodeMap **notationMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMDocumentType * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMDocumentType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMDocumentType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMDocumentType * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMDocumentType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMDocumentType * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMDocumentType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMDocumentType * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMDocumentType * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMDocumentType * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMDocumentType * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMDocumentType * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMDocumentType * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMDocumentType * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ BSTR *rootName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_entities )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **entityMap);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notations )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **notationMap);
        
        END_INTERFACE
    } IXMLDOMDocumentTypeVtbl;

    interface IXMLDOMDocumentType
    {
        CONST_VTBL struct IXMLDOMDocumentTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocumentType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocumentType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocumentType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocumentType_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocumentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocumentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocumentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocumentType_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocumentType_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocumentType_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocumentType_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocumentType_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocumentType_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocumentType_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocumentType_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocumentType_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocumentType_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocumentType_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocumentType_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocumentType_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocumentType_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocumentType_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocumentType_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocumentType_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocumentType_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocumentType_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocumentType_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocumentType_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocumentType_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocumentType_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocumentType_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentType_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentType_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocumentType_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocumentType_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocumentType_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocumentType_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocumentType_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocumentType_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocumentType_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocumentType_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocumentType_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocumentType_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocumentType_get_name(This,rootName)	\
    (This)->lpVtbl -> get_name(This,rootName)

#define IXMLDOMDocumentType_get_entities(This,entityMap)	\
    (This)->lpVtbl -> get_entities(This,entityMap)

#define IXMLDOMDocumentType_get_notations(This,notationMap)	\
    (This)->lpVtbl -> get_notations(This,notationMap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_name_Proxy( 
    IXMLDOMDocumentType * This,
    /* [retval][out] */ BSTR *rootName);


void __RPC_STUB IXMLDOMDocumentType_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_entities_Proxy( 
    IXMLDOMDocumentType * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap **entityMap);


void __RPC_STUB IXMLDOMDocumentType_get_entities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_notations_Proxy( 
    IXMLDOMDocumentType * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap **notationMap);


void __RPC_STUB IXMLDOMDocumentType_get_notations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocumentType_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNotation_INTERFACE_DEFINED__
#define __IXMLDOMNotation_INTERFACE_DEFINED__

/* interface IXMLDOMNotation */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNotation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8C-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNotation : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ VARIANT *publicID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ VARIANT *systemID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNotationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMNotation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMNotation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMNotation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMNotation * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMNotation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMNotation * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMNotation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMNotation * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMNotation * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMNotation * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMNotation * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMNotation * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMNotation * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMNotation * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_publicId )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT *publicID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemId )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT *systemID);
        
        END_INTERFACE
    } IXMLDOMNotationVtbl;

    interface IXMLDOMNotation
    {
        CONST_VTBL struct IXMLDOMNotationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNotation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNotation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNotation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNotation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNotation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNotation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNotation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNotation_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMNotation_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMNotation_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMNotation_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMNotation_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMNotation_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMNotation_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMNotation_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMNotation_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMNotation_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMNotation_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMNotation_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMNotation_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMNotation_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMNotation_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMNotation_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMNotation_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMNotation_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMNotation_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMNotation_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMNotation_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMNotation_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMNotation_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMNotation_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMNotation_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMNotation_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMNotation_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMNotation_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMNotation_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMNotation_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMNotation_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMNotation_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMNotation_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMNotation_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMNotation_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMNotation_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMNotation_get_publicId(This,publicID)	\
    (This)->lpVtbl -> get_publicId(This,publicID)

#define IXMLDOMNotation_get_systemId(This,systemID)	\
    (This)->lpVtbl -> get_systemId(This,systemID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNotation_get_publicId_Proxy( 
    IXMLDOMNotation * This,
    /* [retval][out] */ VARIANT *publicID);


void __RPC_STUB IXMLDOMNotation_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNotation_get_systemId_Proxy( 
    IXMLDOMNotation * This,
    /* [retval][out] */ VARIANT *systemID);


void __RPC_STUB IXMLDOMNotation_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNotation_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMEntity_INTERFACE_DEFINED__
#define __IXMLDOMEntity_INTERFACE_DEFINED__

/* interface IXMLDOMEntity */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8D-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMEntity : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ VARIANT *publicID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ VARIANT *systemID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_notationName( 
            /* [retval][out] */ BSTR *name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMEntity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMEntity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMEntity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMEntity * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMEntity * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMEntity * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMEntity * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMEntity * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMEntity * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMEntity * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMEntity * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMEntity * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMEntity * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMEntity * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_publicId )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT *publicID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemId )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT *systemID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notationName )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ BSTR *name);
        
        END_INTERFACE
    } IXMLDOMEntityVtbl;

    interface IXMLDOMEntity
    {
        CONST_VTBL struct IXMLDOMEntityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMEntity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMEntity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMEntity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMEntity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMEntity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMEntity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMEntity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMEntity_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMEntity_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMEntity_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMEntity_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMEntity_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMEntity_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMEntity_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMEntity_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMEntity_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMEntity_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMEntity_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMEntity_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMEntity_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMEntity_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMEntity_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMEntity_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMEntity_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMEntity_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMEntity_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMEntity_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMEntity_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMEntity_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMEntity_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMEntity_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMEntity_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMEntity_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMEntity_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMEntity_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMEntity_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMEntity_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMEntity_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMEntity_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMEntity_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMEntity_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMEntity_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMEntity_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMEntity_get_publicId(This,publicID)	\
    (This)->lpVtbl -> get_publicId(This,publicID)

#define IXMLDOMEntity_get_systemId(This,systemID)	\
    (This)->lpVtbl -> get_systemId(This,systemID)

#define IXMLDOMEntity_get_notationName(This,name)	\
    (This)->lpVtbl -> get_notationName(This,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_publicId_Proxy( 
    IXMLDOMEntity * This,
    /* [retval][out] */ VARIANT *publicID);


void __RPC_STUB IXMLDOMEntity_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_systemId_Proxy( 
    IXMLDOMEntity * This,
    /* [retval][out] */ VARIANT *systemID);


void __RPC_STUB IXMLDOMEntity_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_notationName_Proxy( 
    IXMLDOMEntity * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB IXMLDOMEntity_get_notationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMEntity_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMEntityReference_INTERFACE_DEFINED__
#define __IXMLDOMEntityReference_INTERFACE_DEFINED__

/* interface IXMLDOMEntityReference */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMEntityReference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8E-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMEntityReference : public IXMLDOMNode
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMEntityReferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMEntityReference * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMEntityReference * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMEntityReference * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMEntityReference * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMEntityReference * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMEntityReference * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMEntityReference * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMEntityReference * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMEntityReference * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMEntityReference * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMEntityReference * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMEntityReference * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMEntityReference * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMEntityReference * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMEntityReferenceVtbl;

    interface IXMLDOMEntityReference
    {
        CONST_VTBL struct IXMLDOMEntityReferenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMEntityReference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMEntityReference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMEntityReference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMEntityReference_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMEntityReference_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMEntityReference_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMEntityReference_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMEntityReference_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMEntityReference_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMEntityReference_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMEntityReference_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMEntityReference_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMEntityReference_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMEntityReference_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMEntityReference_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMEntityReference_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMEntityReference_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMEntityReference_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMEntityReference_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMEntityReference_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMEntityReference_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMEntityReference_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMEntityReference_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMEntityReference_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMEntityReference_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMEntityReference_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMEntityReference_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMEntityReference_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMEntityReference_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMEntityReference_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMEntityReference_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMEntityReference_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMEntityReference_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMEntityReference_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMEntityReference_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMEntityReference_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMEntityReference_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMEntityReference_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMEntityReference_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMEntityReference_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMEntityReference_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMEntityReference_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMEntityReference_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMEntityReference_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMParseError_INTERFACE_DEFINED__
#define __IXMLDOMParseError_INTERFACE_DEFINED__

/* interface IXMLDOMParseError */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMParseError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa426-272f-11d2-836f-0000f87a7782")
    IXMLDOMParseError : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_errorCode( 
            /* [out][retval] */ long *errorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
            /* [out][retval] */ BSTR *urlString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_reason( 
            /* [out][retval] */ BSTR *reasonString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_srcText( 
            /* [out][retval] */ BSTR *sourceString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_line( 
            /* [out][retval] */ long *lineNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_linepos( 
            /* [out][retval] */ long *linePosition) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_filepos( 
            /* [out][retval] */ long *filePosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMParseErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMParseError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMParseError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMParseError * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMParseError * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMParseError * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMParseError * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMParseError * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_errorCode )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ long *errorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_url )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ BSTR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_reason )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ BSTR *reasonString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_srcText )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ BSTR *sourceString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_line )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ long *lineNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_linepos )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ long *linePosition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_filepos )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ long *filePosition);
        
        END_INTERFACE
    } IXMLDOMParseErrorVtbl;

    interface IXMLDOMParseError
    {
        CONST_VTBL struct IXMLDOMParseErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMParseError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMParseError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMParseError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMParseError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMParseError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMParseError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMParseError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMParseError_get_errorCode(This,errorCode)	\
    (This)->lpVtbl -> get_errorCode(This,errorCode)

#define IXMLDOMParseError_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMParseError_get_reason(This,reasonString)	\
    (This)->lpVtbl -> get_reason(This,reasonString)

#define IXMLDOMParseError_get_srcText(This,sourceString)	\
    (This)->lpVtbl -> get_srcText(This,sourceString)

#define IXMLDOMParseError_get_line(This,lineNumber)	\
    (This)->lpVtbl -> get_line(This,lineNumber)

#define IXMLDOMParseError_get_linepos(This,linePosition)	\
    (This)->lpVtbl -> get_linepos(This,linePosition)

#define IXMLDOMParseError_get_filepos(This,filePosition)	\
    (This)->lpVtbl -> get_filepos(This,filePosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_errorCode_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ long *errorCode);


void __RPC_STUB IXMLDOMParseError_get_errorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_url_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ BSTR *urlString);


void __RPC_STUB IXMLDOMParseError_get_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_reason_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ BSTR *reasonString);


void __RPC_STUB IXMLDOMParseError_get_reason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_srcText_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ BSTR *sourceString);


void __RPC_STUB IXMLDOMParseError_get_srcText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_line_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ long *lineNumber);


void __RPC_STUB IXMLDOMParseError_get_line_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_linepos_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ long *linePosition);


void __RPC_STUB IXMLDOMParseError_get_linepos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_filepos_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ long *filePosition);


void __RPC_STUB IXMLDOMParseError_get_filepos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMParseError_INTERFACE_DEFINED__ */


#ifndef __IXTLRuntime_INTERFACE_DEFINED__
#define __IXTLRuntime_INTERFACE_DEFINED__

/* interface IXTLRuntime */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXTLRuntime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa425-272f-11d2-836f-0000f87a7782")
    IXTLRuntime : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE uniqueID( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE depth( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pDepth) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE childNumber( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ancestorChildNumber( 
            /* [in] */ BSTR bstrNodeName,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE absoluteChildNumber( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatIndex( 
            /* [in] */ long lIndex,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatNumber( 
            /* [in] */ double dblNumber,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatDate( 
            /* [in] */ VARIANT varDate,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatTime( 
            /* [in] */ VARIANT varTime,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR *pbstrFormattedString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXTLRuntimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXTLRuntime * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXTLRuntime * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXTLRuntime * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXTLRuntime * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXTLRuntime * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXTLRuntime * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXTLRuntime * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXTLRuntime * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXTLRuntime * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXTLRuntime * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXTLRuntime * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXTLRuntime * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXTLRuntime * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXTLRuntime * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXTLRuntime * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXTLRuntime * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXTLRuntime * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXTLRuntime * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXTLRuntime * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXTLRuntime * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *uniqueID )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *depth )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pDepth);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *childNumber )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ancestorChildNumber )( 
            IXTLRuntime * This,
            /* [in] */ BSTR bstrNodeName,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *absoluteChildNumber )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *formatIndex )( 
            IXTLRuntime * This,
            /* [in] */ long lIndex,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *formatNumber )( 
            IXTLRuntime * This,
            /* [in] */ double dblNumber,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *formatDate )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT varDate,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *formatTime )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT varTime,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR *pbstrFormattedString);
        
        END_INTERFACE
    } IXTLRuntimeVtbl;

    interface IXTLRuntime
    {
        CONST_VTBL struct IXTLRuntimeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXTLRuntime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXTLRuntime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXTLRuntime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXTLRuntime_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXTLRuntime_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXTLRuntime_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXTLRuntime_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXTLRuntime_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXTLRuntime_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXTLRuntime_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXTLRuntime_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXTLRuntime_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXTLRuntime_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXTLRuntime_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXTLRuntime_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXTLRuntime_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXTLRuntime_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXTLRuntime_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXTLRuntime_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXTLRuntime_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXTLRuntime_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXTLRuntime_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXTLRuntime_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXTLRuntime_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXTLRuntime_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXTLRuntime_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXTLRuntime_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXTLRuntime_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXTLRuntime_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXTLRuntime_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXTLRuntime_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXTLRuntime_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXTLRuntime_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXTLRuntime_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXTLRuntime_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXTLRuntime_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXTLRuntime_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXTLRuntime_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXTLRuntime_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXTLRuntime_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXTLRuntime_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXTLRuntime_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXTLRuntime_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXTLRuntime_uniqueID(This,pNode,pID)	\
    (This)->lpVtbl -> uniqueID(This,pNode,pID)

#define IXTLRuntime_depth(This,pNode,pDepth)	\
    (This)->lpVtbl -> depth(This,pNode,pDepth)

#define IXTLRuntime_childNumber(This,pNode,pNumber)	\
    (This)->lpVtbl -> childNumber(This,pNode,pNumber)

#define IXTLRuntime_ancestorChildNumber(This,bstrNodeName,pNode,pNumber)	\
    (This)->lpVtbl -> ancestorChildNumber(This,bstrNodeName,pNode,pNumber)

#define IXTLRuntime_absoluteChildNumber(This,pNode,pNumber)	\
    (This)->lpVtbl -> absoluteChildNumber(This,pNode,pNumber)

#define IXTLRuntime_formatIndex(This,lIndex,bstrFormat,pbstrFormattedString)	\
    (This)->lpVtbl -> formatIndex(This,lIndex,bstrFormat,pbstrFormattedString)

#define IXTLRuntime_formatNumber(This,dblNumber,bstrFormat,pbstrFormattedString)	\
    (This)->lpVtbl -> formatNumber(This,dblNumber,bstrFormat,pbstrFormattedString)

#define IXTLRuntime_formatDate(This,varDate,bstrFormat,varDestLocale,pbstrFormattedString)	\
    (This)->lpVtbl -> formatDate(This,varDate,bstrFormat,varDestLocale,pbstrFormattedString)

#define IXTLRuntime_formatTime(This,varTime,bstrFormat,varDestLocale,pbstrFormattedString)	\
    (This)->lpVtbl -> formatTime(This,varTime,bstrFormat,varDestLocale,pbstrFormattedString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_uniqueID_Proxy( 
    IXTLRuntime * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pID);


void __RPC_STUB IXTLRuntime_uniqueID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_depth_Proxy( 
    IXTLRuntime * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pDepth);


void __RPC_STUB IXTLRuntime_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_childNumber_Proxy( 
    IXTLRuntime * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pNumber);


void __RPC_STUB IXTLRuntime_childNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_ancestorChildNumber_Proxy( 
    IXTLRuntime * This,
    /* [in] */ BSTR bstrNodeName,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pNumber);


void __RPC_STUB IXTLRuntime_ancestorChildNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_absoluteChildNumber_Proxy( 
    IXTLRuntime * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pNumber);


void __RPC_STUB IXTLRuntime_absoluteChildNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatIndex_Proxy( 
    IXTLRuntime * This,
    /* [in] */ long lIndex,
    /* [in] */ BSTR bstrFormat,
    /* [retval][out] */ BSTR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatNumber_Proxy( 
    IXTLRuntime * This,
    /* [in] */ double dblNumber,
    /* [in] */ BSTR bstrFormat,
    /* [retval][out] */ BSTR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatDate_Proxy( 
    IXTLRuntime * This,
    /* [in] */ VARIANT varDate,
    /* [in] */ BSTR bstrFormat,
    /* [optional][in] */ VARIANT varDestLocale,
    /* [retval][out] */ BSTR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatTime_Proxy( 
    IXTLRuntime * This,
    /* [in] */ VARIANT varTime,
    /* [in] */ BSTR bstrFormat,
    /* [optional][in] */ VARIANT varDestLocale,
    /* [retval][out] */ BSTR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXTLRuntime_INTERFACE_DEFINED__ */


#ifndef __IXSLTemplate_INTERFACE_DEFINED__
#define __IXSLTemplate_INTERFACE_DEFINED__

/* interface IXSLTemplate */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXSLTemplate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF93-7B36-11d2-B20E-00C04F983E60")
    IXSLTemplate : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_stylesheet( 
            /* [in] */ IXMLDOMNode *stylesheet) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_stylesheet( 
            /* [retval][out] */ IXMLDOMNode **stylesheet) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createProcessor( 
            /* [retval][out] */ IXSLProcessor **ppProcessor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXSLTemplateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXSLTemplate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXSLTemplate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXSLTemplate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXSLTemplate * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXSLTemplate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXSLTemplate * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXSLTemplate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_stylesheet )( 
            IXSLTemplate * This,
            /* [in] */ IXMLDOMNode *stylesheet);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_stylesheet )( 
            IXSLTemplate * This,
            /* [retval][out] */ IXMLDOMNode **stylesheet);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createProcessor )( 
            IXSLTemplate * This,
            /* [retval][out] */ IXSLProcessor **ppProcessor);
        
        END_INTERFACE
    } IXSLTemplateVtbl;

    interface IXSLTemplate
    {
        CONST_VTBL struct IXSLTemplateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXSLTemplate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXSLTemplate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXSLTemplate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXSLTemplate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXSLTemplate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXSLTemplate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXSLTemplate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXSLTemplate_putref_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> putref_stylesheet(This,stylesheet)

#define IXSLTemplate_get_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> get_stylesheet(This,stylesheet)

#define IXSLTemplate_createProcessor(This,ppProcessor)	\
    (This)->lpVtbl -> createProcessor(This,ppProcessor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_putref_stylesheet_Proxy( 
    IXSLTemplate * This,
    /* [in] */ IXMLDOMNode *stylesheet);


void __RPC_STUB IXSLTemplate_putref_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_get_stylesheet_Proxy( 
    IXSLTemplate * This,
    /* [retval][out] */ IXMLDOMNode **stylesheet);


void __RPC_STUB IXSLTemplate_get_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_createProcessor_Proxy( 
    IXSLTemplate * This,
    /* [retval][out] */ IXSLProcessor **ppProcessor);


void __RPC_STUB IXSLTemplate_createProcessor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXSLTemplate_INTERFACE_DEFINED__ */


#ifndef __IXSLProcessor_INTERFACE_DEFINED__
#define __IXSLProcessor_INTERFACE_DEFINED__

/* interface IXSLProcessor */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXSLProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF92-7B36-11d2-B20E-00C04F983E60")
    IXSLProcessor : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_input( 
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_input( 
            /* [retval][out] */ VARIANT *pVar) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ownerTemplate( 
            /* [retval][out] */ IXSLTemplate **ppTemplate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setStartMode( 
            /* [in] */ BSTR mode,
            /* [defaultvalue][in] */ BSTR namespaceURI = L"") = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_startMode( 
            /* [retval][out] */ BSTR *mode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_startModeURI( 
            /* [retval][out] */ BSTR *namespaceURI) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_output( 
            /* [in] */ VARIANT output) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_output( 
            /* [retval][out] */ VARIANT *pOutput) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE transform( 
            /* [retval][out] */ VARIANT_BOOL *pDone) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long *pReadyState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addParameter( 
            /* [in] */ BSTR baseName,
            /* [in] */ VARIANT parameter,
            /* [defaultvalue][in] */ BSTR namespaceURI = L"") = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addObject( 
            /* [in] */ IDispatch *obj,
            /* [in] */ BSTR namespaceURI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_stylesheet( 
            /* [retval][out] */ IXMLDOMNode **stylesheet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXSLProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXSLProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXSLProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXSLProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXSLProcessor * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXSLProcessor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXSLProcessor * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXSLProcessor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_input )( 
            IXSLProcessor * This,
            /* [in] */ VARIANT var);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_input )( 
            IXSLProcessor * This,
            /* [retval][out] */ VARIANT *pVar);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerTemplate )( 
            IXSLProcessor * This,
            /* [retval][out] */ IXSLTemplate **ppTemplate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setStartMode )( 
            IXSLProcessor * This,
            /* [in] */ BSTR mode,
            /* [defaultvalue][in] */ BSTR namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_startMode )( 
            IXSLProcessor * This,
            /* [retval][out] */ BSTR *mode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_startModeURI )( 
            IXSLProcessor * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_output )( 
            IXSLProcessor * This,
            /* [in] */ VARIANT output);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_output )( 
            IXSLProcessor * This,
            /* [retval][out] */ VARIANT *pOutput);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transform )( 
            IXSLProcessor * This,
            /* [retval][out] */ VARIANT_BOOL *pDone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXSLProcessor * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXSLProcessor * This,
            /* [retval][out] */ long *pReadyState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addParameter )( 
            IXSLProcessor * This,
            /* [in] */ BSTR baseName,
            /* [in] */ VARIANT parameter,
            /* [defaultvalue][in] */ BSTR namespaceURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addObject )( 
            IXSLProcessor * This,
            /* [in] */ IDispatch *obj,
            /* [in] */ BSTR namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_stylesheet )( 
            IXSLProcessor * This,
            /* [retval][out] */ IXMLDOMNode **stylesheet);
        
        END_INTERFACE
    } IXSLProcessorVtbl;

    interface IXSLProcessor
    {
        CONST_VTBL struct IXSLProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXSLProcessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXSLProcessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXSLProcessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXSLProcessor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXSLProcessor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXSLProcessor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXSLProcessor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXSLProcessor_put_input(This,var)	\
    (This)->lpVtbl -> put_input(This,var)

#define IXSLProcessor_get_input(This,pVar)	\
    (This)->lpVtbl -> get_input(This,pVar)

#define IXSLProcessor_get_ownerTemplate(This,ppTemplate)	\
    (This)->lpVtbl -> get_ownerTemplate(This,ppTemplate)

#define IXSLProcessor_setStartMode(This,mode,namespaceURI)	\
    (This)->lpVtbl -> setStartMode(This,mode,namespaceURI)

#define IXSLProcessor_get_startMode(This,mode)	\
    (This)->lpVtbl -> get_startMode(This,mode)

#define IXSLProcessor_get_startModeURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_startModeURI(This,namespaceURI)

#define IXSLProcessor_put_output(This,output)	\
    (This)->lpVtbl -> put_output(This,output)

#define IXSLProcessor_get_output(This,pOutput)	\
    (This)->lpVtbl -> get_output(This,pOutput)

#define IXSLProcessor_transform(This,pDone)	\
    (This)->lpVtbl -> transform(This,pDone)

#define IXSLProcessor_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXSLProcessor_get_readyState(This,pReadyState)	\
    (This)->lpVtbl -> get_readyState(This,pReadyState)

#define IXSLProcessor_addParameter(This,baseName,parameter,namespaceURI)	\
    (This)->lpVtbl -> addParameter(This,baseName,parameter,namespaceURI)

#define IXSLProcessor_addObject(This,obj,namespaceURI)	\
    (This)->lpVtbl -> addObject(This,obj,namespaceURI)

#define IXSLProcessor_get_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> get_stylesheet(This,stylesheet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_put_input_Proxy( 
    IXSLProcessor * This,
    /* [in] */ VARIANT var);


void __RPC_STUB IXSLProcessor_put_input_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_input_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ VARIANT *pVar);


void __RPC_STUB IXSLProcessor_get_input_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_ownerTemplate_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ IXSLTemplate **ppTemplate);


void __RPC_STUB IXSLProcessor_get_ownerTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_setStartMode_Proxy( 
    IXSLProcessor * This,
    /* [in] */ BSTR mode,
    /* [defaultvalue][in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_setStartMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_startMode_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ BSTR *mode);


void __RPC_STUB IXSLProcessor_get_startMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_startModeURI_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ BSTR *namespaceURI);


void __RPC_STUB IXSLProcessor_get_startModeURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_put_output_Proxy( 
    IXSLProcessor * This,
    /* [in] */ VARIANT output);


void __RPC_STUB IXSLProcessor_put_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_output_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ VARIANT *pOutput);


void __RPC_STUB IXSLProcessor_get_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_transform_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ VARIANT_BOOL *pDone);


void __RPC_STUB IXSLProcessor_transform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_reset_Proxy( 
    IXSLProcessor * This);


void __RPC_STUB IXSLProcessor_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_readyState_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ long *pReadyState);


void __RPC_STUB IXSLProcessor_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_addParameter_Proxy( 
    IXSLProcessor * This,
    /* [in] */ BSTR baseName,
    /* [in] */ VARIANT parameter,
    /* [defaultvalue][in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_addParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_addObject_Proxy( 
    IXSLProcessor * This,
    /* [in] */ IDispatch *obj,
    /* [in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_addObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_stylesheet_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ IXMLDOMNode **stylesheet);


void __RPC_STUB IXSLProcessor_get_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXSLProcessor_INTERFACE_DEFINED__ */


#ifndef __ISAXXMLReader_INTERFACE_DEFINED__
#define __ISAXXMLReader_INTERFACE_DEFINED__

/* interface ISAXXMLReader */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXXMLReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a4f96ed0-f829-476e-81c0-cdc7bd2a0802")
    ISAXXMLReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getFeature( 
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT_BOOL *pvfValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putFeature( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT_BOOL vfValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putProperty( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEntityResolver( 
            /* [retval][out] */ ISAXEntityResolver **ppResolver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putEntityResolver( 
            /* [in] */ ISAXEntityResolver *pResolver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getContentHandler( 
            /* [retval][out] */ ISAXContentHandler **ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putContentHandler( 
            /* [in] */ ISAXContentHandler *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getDTDHandler( 
            /* [retval][out] */ ISAXDTDHandler **ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putDTDHandler( 
            /* [in] */ ISAXDTDHandler *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getErrorHandler( 
            /* [retval][out] */ ISAXErrorHandler **ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putErrorHandler( 
            /* [in] */ ISAXErrorHandler *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getBaseURL( 
            /* [retval][out] */ const wchar_t **ppwchBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putBaseURL( 
            /* [in] */ const wchar_t *pwchBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSecureBaseURL( 
            /* [retval][out] */ const wchar_t **ppwchSecureBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putSecureBaseURL( 
            /* [in] */ const wchar_t *pwchSecureBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE parse( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE parseURL( 
            /* [in] */ const wchar_t *pwchUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXXMLReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXXMLReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXXMLReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXXMLReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *getFeature )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT_BOOL *pvfValue);
        
        HRESULT ( STDMETHODCALLTYPE *putFeature )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT_BOOL vfValue);
        
        HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *putProperty )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT varValue);
        
        HRESULT ( STDMETHODCALLTYPE *getEntityResolver )( 
            ISAXXMLReader * This,
            /* [retval][out] */ ISAXEntityResolver **ppResolver);
        
        HRESULT ( STDMETHODCALLTYPE *putEntityResolver )( 
            ISAXXMLReader * This,
            /* [in] */ ISAXEntityResolver *pResolver);
        
        HRESULT ( STDMETHODCALLTYPE *getContentHandler )( 
            ISAXXMLReader * This,
            /* [retval][out] */ ISAXContentHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putContentHandler )( 
            ISAXXMLReader * This,
            /* [in] */ ISAXContentHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getDTDHandler )( 
            ISAXXMLReader * This,
            /* [retval][out] */ ISAXDTDHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putDTDHandler )( 
            ISAXXMLReader * This,
            /* [in] */ ISAXDTDHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getErrorHandler )( 
            ISAXXMLReader * This,
            /* [retval][out] */ ISAXErrorHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putErrorHandler )( 
            ISAXXMLReader * This,
            /* [in] */ ISAXErrorHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getBaseURL )( 
            ISAXXMLReader * This,
            /* [retval][out] */ const wchar_t **ppwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *putBaseURL )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *getSecureBaseURL )( 
            ISAXXMLReader * This,
            /* [retval][out] */ const wchar_t **ppwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *putSecureBaseURL )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *parse )( 
            ISAXXMLReader * This,
            /* [in] */ VARIANT varInput);
        
        HRESULT ( STDMETHODCALLTYPE *parseURL )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchUrl);
        
        END_INTERFACE
    } ISAXXMLReaderVtbl;

    interface ISAXXMLReader
    {
        CONST_VTBL struct ISAXXMLReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXXMLReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXXMLReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXXMLReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXXMLReader_getFeature(This,pwchName,pvfValue)	\
    (This)->lpVtbl -> getFeature(This,pwchName,pvfValue)

#define ISAXXMLReader_putFeature(This,pwchName,vfValue)	\
    (This)->lpVtbl -> putFeature(This,pwchName,vfValue)

#define ISAXXMLReader_getProperty(This,pwchName,pvarValue)	\
    (This)->lpVtbl -> getProperty(This,pwchName,pvarValue)

#define ISAXXMLReader_putProperty(This,pwchName,varValue)	\
    (This)->lpVtbl -> putProperty(This,pwchName,varValue)

#define ISAXXMLReader_getEntityResolver(This,ppResolver)	\
    (This)->lpVtbl -> getEntityResolver(This,ppResolver)

#define ISAXXMLReader_putEntityResolver(This,pResolver)	\
    (This)->lpVtbl -> putEntityResolver(This,pResolver)

#define ISAXXMLReader_getContentHandler(This,ppHandler)	\
    (This)->lpVtbl -> getContentHandler(This,ppHandler)

#define ISAXXMLReader_putContentHandler(This,pHandler)	\
    (This)->lpVtbl -> putContentHandler(This,pHandler)

#define ISAXXMLReader_getDTDHandler(This,ppHandler)	\
    (This)->lpVtbl -> getDTDHandler(This,ppHandler)

#define ISAXXMLReader_putDTDHandler(This,pHandler)	\
    (This)->lpVtbl -> putDTDHandler(This,pHandler)

#define ISAXXMLReader_getErrorHandler(This,ppHandler)	\
    (This)->lpVtbl -> getErrorHandler(This,ppHandler)

#define ISAXXMLReader_putErrorHandler(This,pHandler)	\
    (This)->lpVtbl -> putErrorHandler(This,pHandler)

#define ISAXXMLReader_getBaseURL(This,ppwchBaseUrl)	\
    (This)->lpVtbl -> getBaseURL(This,ppwchBaseUrl)

#define ISAXXMLReader_putBaseURL(This,pwchBaseUrl)	\
    (This)->lpVtbl -> putBaseURL(This,pwchBaseUrl)

#define ISAXXMLReader_getSecureBaseURL(This,ppwchSecureBaseUrl)	\
    (This)->lpVtbl -> getSecureBaseURL(This,ppwchSecureBaseUrl)

#define ISAXXMLReader_putSecureBaseURL(This,pwchSecureBaseUrl)	\
    (This)->lpVtbl -> putSecureBaseURL(This,pwchSecureBaseUrl)

#define ISAXXMLReader_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define ISAXXMLReader_parseURL(This,pwchUrl)	\
    (This)->lpVtbl -> parseURL(This,pwchUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXXMLReader_getFeature_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchName,
    /* [retval][out] */ VARIANT_BOOL *pvfValue);


void __RPC_STUB ISAXXMLReader_getFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putFeature_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ VARIANT_BOOL vfValue);


void __RPC_STUB ISAXXMLReader_putFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getProperty_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchName,
    /* [retval][out] */ VARIANT *pvarValue);


void __RPC_STUB ISAXXMLReader_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putProperty_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ VARIANT varValue);


void __RPC_STUB ISAXXMLReader_putProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getEntityResolver_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ ISAXEntityResolver **ppResolver);


void __RPC_STUB ISAXXMLReader_getEntityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putEntityResolver_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ ISAXEntityResolver *pResolver);


void __RPC_STUB ISAXXMLReader_putEntityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getContentHandler_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ ISAXContentHandler **ppHandler);


void __RPC_STUB ISAXXMLReader_getContentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putContentHandler_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ ISAXContentHandler *pHandler);


void __RPC_STUB ISAXXMLReader_putContentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getDTDHandler_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ ISAXDTDHandler **ppHandler);


void __RPC_STUB ISAXXMLReader_getDTDHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putDTDHandler_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ ISAXDTDHandler *pHandler);


void __RPC_STUB ISAXXMLReader_putDTDHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getErrorHandler_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ ISAXErrorHandler **ppHandler);


void __RPC_STUB ISAXXMLReader_getErrorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putErrorHandler_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ ISAXErrorHandler *pHandler);


void __RPC_STUB ISAXXMLReader_putErrorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getBaseURL_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ const wchar_t **ppwchBaseUrl);


void __RPC_STUB ISAXXMLReader_getBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putBaseURL_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchBaseUrl);


void __RPC_STUB ISAXXMLReader_putBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getSecureBaseURL_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ const wchar_t **ppwchSecureBaseUrl);


void __RPC_STUB ISAXXMLReader_getSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putSecureBaseURL_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchSecureBaseUrl);


void __RPC_STUB ISAXXMLReader_putSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_parse_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB ISAXXMLReader_parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_parseURL_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchUrl);


void __RPC_STUB ISAXXMLReader_parseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXXMLReader_INTERFACE_DEFINED__ */


#ifndef __ISAXXMLFilter_INTERFACE_DEFINED__
#define __ISAXXMLFilter_INTERFACE_DEFINED__

/* interface ISAXXMLFilter */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXXMLFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70409222-ca09-4475-acb8-40312fe8d145")
    ISAXXMLFilter : public ISAXXMLReader
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getParent( 
            /* [retval][out] */ ISAXXMLReader **ppReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putParent( 
            /* [in] */ ISAXXMLReader *pReader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXXMLFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXXMLFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXXMLFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXXMLFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *getFeature )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT_BOOL *pvfValue);
        
        HRESULT ( STDMETHODCALLTYPE *putFeature )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT_BOOL vfValue);
        
        HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *putProperty )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT varValue);
        
        HRESULT ( STDMETHODCALLTYPE *getEntityResolver )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXEntityResolver **ppResolver);
        
        HRESULT ( STDMETHODCALLTYPE *putEntityResolver )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXEntityResolver *pResolver);
        
        HRESULT ( STDMETHODCALLTYPE *getContentHandler )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXContentHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putContentHandler )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXContentHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getDTDHandler )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXDTDHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putDTDHandler )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXDTDHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getErrorHandler )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXErrorHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putErrorHandler )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXErrorHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getBaseURL )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ const wchar_t **ppwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *putBaseURL )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *getSecureBaseURL )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ const wchar_t **ppwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *putSecureBaseURL )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *parse )( 
            ISAXXMLFilter * This,
            /* [in] */ VARIANT varInput);
        
        HRESULT ( STDMETHODCALLTYPE *parseURL )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchUrl);
        
        HRESULT ( STDMETHODCALLTYPE *getParent )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXXMLReader **ppReader);
        
        HRESULT ( STDMETHODCALLTYPE *putParent )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXXMLReader *pReader);
        
        END_INTERFACE
    } ISAXXMLFilterVtbl;

    interface ISAXXMLFilter
    {
        CONST_VTBL struct ISAXXMLFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXXMLFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXXMLFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXXMLFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXXMLFilter_getFeature(This,pwchName,pvfValue)	\
    (This)->lpVtbl -> getFeature(This,pwchName,pvfValue)

#define ISAXXMLFilter_putFeature(This,pwchName,vfValue)	\
    (This)->lpVtbl -> putFeature(This,pwchName,vfValue)

#define ISAXXMLFilter_getProperty(This,pwchName,pvarValue)	\
    (This)->lpVtbl -> getProperty(This,pwchName,pvarValue)

#define ISAXXMLFilter_putProperty(This,pwchName,varValue)	\
    (This)->lpVtbl -> putProperty(This,pwchName,varValue)

#define ISAXXMLFilter_getEntityResolver(This,ppResolver)	\
    (This)->lpVtbl -> getEntityResolver(This,ppResolver)

#define ISAXXMLFilter_putEntityResolver(This,pResolver)	\
    (This)->lpVtbl -> putEntityResolver(This,pResolver)

#define ISAXXMLFilter_getContentHandler(This,ppHandler)	\
    (This)->lpVtbl -> getContentHandler(This,ppHandler)

#define ISAXXMLFilter_putContentHandler(This,pHandler)	\
    (This)->lpVtbl -> putContentHandler(This,pHandler)

#define ISAXXMLFilter_getDTDHandler(This,ppHandler)	\
    (This)->lpVtbl -> getDTDHandler(This,ppHandler)

#define ISAXXMLFilter_putDTDHandler(This,pHandler)	\
    (This)->lpVtbl -> putDTDHandler(This,pHandler)

#define ISAXXMLFilter_getErrorHandler(This,ppHandler)	\
    (This)->lpVtbl -> getErrorHandler(This,ppHandler)

#define ISAXXMLFilter_putErrorHandler(This,pHandler)	\
    (This)->lpVtbl -> putErrorHandler(This,pHandler)

#define ISAXXMLFilter_getBaseURL(This,ppwchBaseUrl)	\
    (This)->lpVtbl -> getBaseURL(This,ppwchBaseUrl)

#define ISAXXMLFilter_putBaseURL(This,pwchBaseUrl)	\
    (This)->lpVtbl -> putBaseURL(This,pwchBaseUrl)

#define ISAXXMLFilter_getSecureBaseURL(This,ppwchSecureBaseUrl)	\
    (This)->lpVtbl -> getSecureBaseURL(This,ppwchSecureBaseUrl)

#define ISAXXMLFilter_putSecureBaseURL(This,pwchSecureBaseUrl)	\
    (This)->lpVtbl -> putSecureBaseURL(This,pwchSecureBaseUrl)

#define ISAXXMLFilter_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define ISAXXMLFilter_parseURL(This,pwchUrl)	\
    (This)->lpVtbl -> parseURL(This,pwchUrl)


#define ISAXXMLFilter_getParent(This,ppReader)	\
    (This)->lpVtbl -> getParent(This,ppReader)

#define ISAXXMLFilter_putParent(This,pReader)	\
    (This)->lpVtbl -> putParent(This,pReader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXXMLFilter_getParent_Proxy( 
    ISAXXMLFilter * This,
    /* [retval][out] */ ISAXXMLReader **ppReader);


void __RPC_STUB ISAXXMLFilter_getParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLFilter_putParent_Proxy( 
    ISAXXMLFilter * This,
    /* [in] */ ISAXXMLReader *pReader);


void __RPC_STUB ISAXXMLFilter_putParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXXMLFilter_INTERFACE_DEFINED__ */


#ifndef __ISAXLocator_INTERFACE_DEFINED__
#define __ISAXLocator_INTERFACE_DEFINED__

/* interface ISAXLocator */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b7e472a-0de4-4640-bff3-84d38a051c31")
    ISAXLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getColumnNumber( 
            /* [retval][out] */ int *pnColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getLineNumber( 
            /* [retval][out] */ int *pnLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getPublicId( 
            /* [retval][out] */ const wchar_t **ppwchPublicId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSystemId( 
            /* [retval][out] */ const wchar_t **ppwchSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *getColumnNumber )( 
            ISAXLocator * This,
            /* [retval][out] */ int *pnColumn);
        
        HRESULT ( STDMETHODCALLTYPE *getLineNumber )( 
            ISAXLocator * This,
            /* [retval][out] */ int *pnLine);
        
        HRESULT ( STDMETHODCALLTYPE *getPublicId )( 
            ISAXLocator * This,
            /* [retval][out] */ const wchar_t **ppwchPublicId);
        
        HRESULT ( STDMETHODCALLTYPE *getSystemId )( 
            ISAXLocator * This,
            /* [retval][out] */ const wchar_t **ppwchSystemId);
        
        END_INTERFACE
    } ISAXLocatorVtbl;

    interface ISAXLocator
    {
        CONST_VTBL struct ISAXLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXLocator_getColumnNumber(This,pnColumn)	\
    (This)->lpVtbl -> getColumnNumber(This,pnColumn)

#define ISAXLocator_getLineNumber(This,pnLine)	\
    (This)->lpVtbl -> getLineNumber(This,pnLine)

#define ISAXLocator_getPublicId(This,ppwchPublicId)	\
    (This)->lpVtbl -> getPublicId(This,ppwchPublicId)

#define ISAXLocator_getSystemId(This,ppwchSystemId)	\
    (This)->lpVtbl -> getSystemId(This,ppwchSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXLocator_getColumnNumber_Proxy( 
    ISAXLocator * This,
    /* [retval][out] */ int *pnColumn);


void __RPC_STUB ISAXLocator_getColumnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getLineNumber_Proxy( 
    ISAXLocator * This,
    /* [retval][out] */ int *pnLine);


void __RPC_STUB ISAXLocator_getLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getPublicId_Proxy( 
    ISAXLocator * This,
    /* [retval][out] */ const wchar_t **ppwchPublicId);


void __RPC_STUB ISAXLocator_getPublicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getSystemId_Proxy( 
    ISAXLocator * This,
    /* [retval][out] */ const wchar_t **ppwchSystemId);


void __RPC_STUB ISAXLocator_getSystemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXLocator_INTERFACE_DEFINED__ */


#ifndef __ISAXEntityResolver_INTERFACE_DEFINED__
#define __ISAXEntityResolver_INTERFACE_DEFINED__

/* interface ISAXEntityResolver */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXEntityResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("99bca7bd-e8c4-4d5f-a0cf-6d907901ff07")
    ISAXEntityResolver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE resolveEntity( 
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [retval][out] */ VARIANT *pvarInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXEntityResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXEntityResolver * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXEntityResolver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXEntityResolver * This);
        
        HRESULT ( STDMETHODCALLTYPE *resolveEntity )( 
            ISAXEntityResolver * This,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [retval][out] */ VARIANT *pvarInput);
        
        END_INTERFACE
    } ISAXEntityResolverVtbl;

    interface ISAXEntityResolver
    {
        CONST_VTBL struct ISAXEntityResolverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXEntityResolver_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXEntityResolver_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXEntityResolver_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXEntityResolver_resolveEntity(This,pwchPublicId,pwchSystemId,pvarInput)	\
    (This)->lpVtbl -> resolveEntity(This,pwchPublicId,pwchSystemId,pvarInput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXEntityResolver_resolveEntity_Proxy( 
    ISAXEntityResolver * This,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [retval][out] */ VARIANT *pvarInput);


void __RPC_STUB ISAXEntityResolver_resolveEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXEntityResolver_INTERFACE_DEFINED__ */


#ifndef __ISAXContentHandler_INTERFACE_DEFINED__
#define __ISAXContentHandler_INTERFACE_DEFINED__

/* interface ISAXContentHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXContentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1545cdfa-9e4e-4497-a8a4-2bf7d0112c44")
    ISAXContentHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE putDocumentLocator( 
            /* [in] */ ISAXLocator *pLocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startDocument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endDocument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startPrefixMapping( 
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endPrefixMapping( 
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ int cchPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startElement( 
            /* [in] */ const wchar_t *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [in] */ ISAXAttributes *pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endElement( 
            /* [in] */ const wchar_t *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE characters( 
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [in] */ const wchar_t *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t *pwchData,
            /* [in] */ int cchData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXContentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXContentHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXContentHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXContentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *putDocumentLocator )( 
            ISAXContentHandler * This,
            /* [in] */ ISAXLocator *pLocator);
        
        HRESULT ( STDMETHODCALLTYPE *startDocument )( 
            ISAXContentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *endDocument )( 
            ISAXContentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *startPrefixMapping )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri);
        
        HRESULT ( STDMETHODCALLTYPE *endPrefixMapping )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ int cchPrefix);
        
        HRESULT ( STDMETHODCALLTYPE *startElement )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [in] */ ISAXAttributes *pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *endElement )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName);
        
        HRESULT ( STDMETHODCALLTYPE *characters )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars);
        
        HRESULT ( STDMETHODCALLTYPE *ignorableWhitespace )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars);
        
        HRESULT ( STDMETHODCALLTYPE *processingInstruction )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t *pwchData,
            /* [in] */ int cchData);
        
        HRESULT ( STDMETHODCALLTYPE *skippedEntity )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName);
        
        END_INTERFACE
    } ISAXContentHandlerVtbl;

    interface ISAXContentHandler
    {
        CONST_VTBL struct ISAXContentHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXContentHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXContentHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXContentHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXContentHandler_putDocumentLocator(This,pLocator)	\
    (This)->lpVtbl -> putDocumentLocator(This,pLocator)

#define ISAXContentHandler_startDocument(This)	\
    (This)->lpVtbl -> startDocument(This)

#define ISAXContentHandler_endDocument(This)	\
    (This)->lpVtbl -> endDocument(This)

#define ISAXContentHandler_startPrefixMapping(This,pwchPrefix,cchPrefix,pwchUri,cchUri)	\
    (This)->lpVtbl -> startPrefixMapping(This,pwchPrefix,cchPrefix,pwchUri,cchUri)

#define ISAXContentHandler_endPrefixMapping(This,pwchPrefix,cchPrefix)	\
    (This)->lpVtbl -> endPrefixMapping(This,pwchPrefix,cchPrefix)

#define ISAXContentHandler_startElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName,pAttributes)	\
    (This)->lpVtbl -> startElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName,pAttributes)

#define ISAXContentHandler_endElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName)	\
    (This)->lpVtbl -> endElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName)

#define ISAXContentHandler_characters(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> characters(This,pwchChars,cchChars)

#define ISAXContentHandler_ignorableWhitespace(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> ignorableWhitespace(This,pwchChars,cchChars)

#define ISAXContentHandler_processingInstruction(This,pwchTarget,cchTarget,pwchData,cchData)	\
    (This)->lpVtbl -> processingInstruction(This,pwchTarget,cchTarget,pwchData,cchData)

#define ISAXContentHandler_skippedEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> skippedEntity(This,pwchName,cchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXContentHandler_putDocumentLocator_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ ISAXLocator *pLocator);


void __RPC_STUB ISAXContentHandler_putDocumentLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startDocument_Proxy( 
    ISAXContentHandler * This);


void __RPC_STUB ISAXContentHandler_startDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endDocument_Proxy( 
    ISAXContentHandler * This);


void __RPC_STUB ISAXContentHandler_endDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startPrefixMapping_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchPrefix,
    /* [in] */ int cchPrefix,
    /* [in] */ const wchar_t *pwchUri,
    /* [in] */ int cchUri);


void __RPC_STUB ISAXContentHandler_startPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endPrefixMapping_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchPrefix,
    /* [in] */ int cchPrefix);


void __RPC_STUB ISAXContentHandler_endPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startElement_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchNamespaceUri,
    /* [in] */ int cchNamespaceUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName,
    /* [in] */ ISAXAttributes *pAttributes);


void __RPC_STUB ISAXContentHandler_startElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endElement_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchNamespaceUri,
    /* [in] */ int cchNamespaceUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName);


void __RPC_STUB ISAXContentHandler_endElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_characters_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXContentHandler_characters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_ignorableWhitespace_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXContentHandler_ignorableWhitespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_processingInstruction_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchTarget,
    /* [in] */ int cchTarget,
    /* [in] */ const wchar_t *pwchData,
    /* [in] */ int cchData);


void __RPC_STUB ISAXContentHandler_processingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_skippedEntity_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXContentHandler_skippedEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXContentHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXDTDHandler_INTERFACE_DEFINED__
#define __ISAXDTDHandler_INTERFACE_DEFINED__

/* interface ISAXDTDHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXDTDHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e15c1baf-afb3-4d60-8c36-19a8c45defed")
    ISAXDTDHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE notationDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE unparsedEntityDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId,
            /* [in] */ const wchar_t *pwchNotationName,
            /* [in] */ int cchNotationName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXDTDHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXDTDHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXDTDHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXDTDHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *notationDecl )( 
            ISAXDTDHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        HRESULT ( STDMETHODCALLTYPE *unparsedEntityDecl )( 
            ISAXDTDHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId,
            /* [in] */ const wchar_t *pwchNotationName,
            /* [in] */ int cchNotationName);
        
        END_INTERFACE
    } ISAXDTDHandlerVtbl;

    interface ISAXDTDHandler
    {
        CONST_VTBL struct ISAXDTDHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXDTDHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXDTDHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXDTDHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXDTDHandler_notationDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> notationDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#define ISAXDTDHandler_unparsedEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId,pwchNotationName,cchNotationName)	\
    (This)->lpVtbl -> unparsedEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId,pwchNotationName,cchNotationName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXDTDHandler_notationDecl_Proxy( 
    ISAXDTDHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXDTDHandler_notationDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDTDHandler_unparsedEntityDecl_Proxy( 
    ISAXDTDHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [in] */ int cchSystemId,
    /* [in] */ const wchar_t *pwchNotationName,
    /* [in] */ int cchNotationName);


void __RPC_STUB ISAXDTDHandler_unparsedEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXDTDHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXErrorHandler_INTERFACE_DEFINED__
#define __ISAXErrorHandler_INTERFACE_DEFINED__

/* interface ISAXErrorHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a60511c4-ccf5-479e-98a3-dc8dc545b7d0")
    ISAXErrorHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE error( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE fatalError( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWarning( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXErrorHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXErrorHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *error )( 
            ISAXErrorHandler * This,
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        HRESULT ( STDMETHODCALLTYPE *fatalError )( 
            ISAXErrorHandler * This,
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        HRESULT ( STDMETHODCALLTYPE *ignorableWarning )( 
            ISAXErrorHandler * This,
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        END_INTERFACE
    } ISAXErrorHandlerVtbl;

    interface ISAXErrorHandler
    {
        CONST_VTBL struct ISAXErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXErrorHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXErrorHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXErrorHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXErrorHandler_error(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> error(This,pLocator,pwchErrorMessage,hrErrorCode)

#define ISAXErrorHandler_fatalError(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> fatalError(This,pLocator,pwchErrorMessage,hrErrorCode)

#define ISAXErrorHandler_ignorableWarning(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> ignorableWarning(This,pLocator,pwchErrorMessage,hrErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXErrorHandler_error_Proxy( 
    ISAXErrorHandler * This,
    /* [in] */ ISAXLocator *pLocator,
    /* [in] */ const wchar_t *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXErrorHandler_fatalError_Proxy( 
    ISAXErrorHandler * This,
    /* [in] */ ISAXLocator *pLocator,
    /* [in] */ const wchar_t *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_fatalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXErrorHandler_ignorableWarning_Proxy( 
    ISAXErrorHandler * This,
    /* [in] */ ISAXLocator *pLocator,
    /* [in] */ const wchar_t *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_ignorableWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXErrorHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXLexicalHandler_INTERFACE_DEFINED__
#define __ISAXLexicalHandler_INTERFACE_DEFINED__

/* interface ISAXLexicalHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXLexicalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7f85d5f5-47a8-4497-bda5-84ba04819ea6")
    ISAXLexicalHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE startDTD( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endDTD( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startEntity( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endEntity( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startCDATA( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endCDATA( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE comment( 
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXLexicalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXLexicalHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXLexicalHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *startDTD )( 
            ISAXLexicalHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        HRESULT ( STDMETHODCALLTYPE *endDTD )( 
            ISAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *startEntity )( 
            ISAXLexicalHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName);
        
        HRESULT ( STDMETHODCALLTYPE *endEntity )( 
            ISAXLexicalHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName);
        
        HRESULT ( STDMETHODCALLTYPE *startCDATA )( 
            ISAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *endCDATA )( 
            ISAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *comment )( 
            ISAXLexicalHandler * This,
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars);
        
        END_INTERFACE
    } ISAXLexicalHandlerVtbl;

    interface ISAXLexicalHandler
    {
        CONST_VTBL struct ISAXLexicalHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXLexicalHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXLexicalHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXLexicalHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXLexicalHandler_startDTD(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> startDTD(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#define ISAXLexicalHandler_endDTD(This)	\
    (This)->lpVtbl -> endDTD(This)

#define ISAXLexicalHandler_startEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> startEntity(This,pwchName,cchName)

#define ISAXLexicalHandler_endEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> endEntity(This,pwchName,cchName)

#define ISAXLexicalHandler_startCDATA(This)	\
    (This)->lpVtbl -> startCDATA(This)

#define ISAXLexicalHandler_endCDATA(This)	\
    (This)->lpVtbl -> endCDATA(This)

#define ISAXLexicalHandler_comment(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> comment(This,pwchChars,cchChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startDTD_Proxy( 
    ISAXLexicalHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXLexicalHandler_startDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endDTD_Proxy( 
    ISAXLexicalHandler * This);


void __RPC_STUB ISAXLexicalHandler_endDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startEntity_Proxy( 
    ISAXLexicalHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXLexicalHandler_startEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endEntity_Proxy( 
    ISAXLexicalHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXLexicalHandler_endEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startCDATA_Proxy( 
    ISAXLexicalHandler * This);


void __RPC_STUB ISAXLexicalHandler_startCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endCDATA_Proxy( 
    ISAXLexicalHandler * This);


void __RPC_STUB ISAXLexicalHandler_endCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_comment_Proxy( 
    ISAXLexicalHandler * This,
    /* [in] */ const wchar_t *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXLexicalHandler_comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXLexicalHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXDeclHandler_INTERFACE_DEFINED__
#define __ISAXDeclHandler_INTERFACE_DEFINED__

/* interface ISAXDeclHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXDeclHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("862629ac-771a-47b2-8337-4e6843c1be90")
    ISAXDeclHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE elementDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchModel,
            /* [in] */ int cchModel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE attributeDecl( 
            /* [in] */ const wchar_t *pwchElementName,
            /* [in] */ int cchElementName,
            /* [in] */ const wchar_t *pwchAttributeName,
            /* [in] */ int cchAttributeName,
            /* [in] */ const wchar_t *pwchType,
            /* [in] */ int cchType,
            /* [in] */ const wchar_t *pwchValueDefault,
            /* [in] */ int cchValueDefault,
            /* [in] */ const wchar_t *pwchValue,
            /* [in] */ int cchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE internalEntityDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchValue,
            /* [in] */ int cchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE externalEntityDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXDeclHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXDeclHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXDeclHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *elementDecl )( 
            ISAXDeclHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchModel,
            /* [in] */ int cchModel);
        
        HRESULT ( STDMETHODCALLTYPE *attributeDecl )( 
            ISAXDeclHandler * This,
            /* [in] */ const wchar_t *pwchElementName,
            /* [in] */ int cchElementName,
            /* [in] */ const wchar_t *pwchAttributeName,
            /* [in] */ int cchAttributeName,
            /* [in] */ const wchar_t *pwchType,
            /* [in] */ int cchType,
            /* [in] */ const wchar_t *pwchValueDefault,
            /* [in] */ int cchValueDefault,
            /* [in] */ const wchar_t *pwchValue,
            /* [in] */ int cchValue);
        
        HRESULT ( STDMETHODCALLTYPE *internalEntityDecl )( 
            ISAXDeclHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchValue,
            /* [in] */ int cchValue);
        
        HRESULT ( STDMETHODCALLTYPE *externalEntityDecl )( 
            ISAXDeclHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        END_INTERFACE
    } ISAXDeclHandlerVtbl;

    interface ISAXDeclHandler
    {
        CONST_VTBL struct ISAXDeclHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXDeclHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXDeclHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXDeclHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXDeclHandler_elementDecl(This,pwchName,cchName,pwchModel,cchModel)	\
    (This)->lpVtbl -> elementDecl(This,pwchName,cchName,pwchModel,cchModel)

#define ISAXDeclHandler_attributeDecl(This,pwchElementName,cchElementName,pwchAttributeName,cchAttributeName,pwchType,cchType,pwchValueDefault,cchValueDefault,pwchValue,cchValue)	\
    (This)->lpVtbl -> attributeDecl(This,pwchElementName,cchElementName,pwchAttributeName,cchAttributeName,pwchType,cchType,pwchValueDefault,cchValueDefault,pwchValue,cchValue)

#define ISAXDeclHandler_internalEntityDecl(This,pwchName,cchName,pwchValue,cchValue)	\
    (This)->lpVtbl -> internalEntityDecl(This,pwchName,cchName,pwchValue,cchValue)

#define ISAXDeclHandler_externalEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> externalEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXDeclHandler_elementDecl_Proxy( 
    ISAXDeclHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchModel,
    /* [in] */ int cchModel);


void __RPC_STUB ISAXDeclHandler_elementDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_attributeDecl_Proxy( 
    ISAXDeclHandler * This,
    /* [in] */ const wchar_t *pwchElementName,
    /* [in] */ int cchElementName,
    /* [in] */ const wchar_t *pwchAttributeName,
    /* [in] */ int cchAttributeName,
    /* [in] */ const wchar_t *pwchType,
    /* [in] */ int cchType,
    /* [in] */ const wchar_t *pwchValueDefault,
    /* [in] */ int cchValueDefault,
    /* [in] */ const wchar_t *pwchValue,
    /* [in] */ int cchValue);


void __RPC_STUB ISAXDeclHandler_attributeDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_internalEntityDecl_Proxy( 
    ISAXDeclHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchValue,
    /* [in] */ int cchValue);


void __RPC_STUB ISAXDeclHandler_internalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_externalEntityDecl_Proxy( 
    ISAXDeclHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXDeclHandler_externalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXDeclHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXAttributes_INTERFACE_DEFINED__
#define __ISAXAttributes_INTERFACE_DEFINED__

/* interface ISAXAttributes */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f078abe1-45d2-4832-91ea-4466ce2f25c9")
    ISAXAttributes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getLength( 
            /* [retval][out] */ int *pnLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchUri,
            /* [out] */ int *pcchUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getLocalName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchLocalName,
            /* [out] */ int *pcchLocalName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getQName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchQName,
            /* [out] */ int *pcchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchUri,
            /* [out] */ int *pcchUri,
            /* [out] */ const wchar_t **ppwchLocalName,
            /* [out] */ int *pcchLocalName,
            /* [out] */ const wchar_t **ppwchQName,
            /* [out] */ int *pcchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getIndexFromName( 
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [retval][out] */ int *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getIndexFromQName( 
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [retval][out] */ int *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getTypeFromName( 
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getTypeFromQName( 
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValue( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValueFromName( 
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValueFromQName( 
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXAttributes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *getLength )( 
            ISAXAttributes * This,
            /* [retval][out] */ int *pnLength);
        
        HRESULT ( STDMETHODCALLTYPE *getURI )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchUri,
            /* [out] */ int *pcchUri);
        
        HRESULT ( STDMETHODCALLTYPE *getLocalName )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchLocalName,
            /* [out] */ int *pcchLocalName);
        
        HRESULT ( STDMETHODCALLTYPE *getQName )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchQName,
            /* [out] */ int *pcchQName);
        
        HRESULT ( STDMETHODCALLTYPE *getName )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchUri,
            /* [out] */ int *pcchUri,
            /* [out] */ const wchar_t **ppwchLocalName,
            /* [out] */ int *pcchLocalName,
            /* [out] */ const wchar_t **ppwchQName,
            /* [out] */ int *pcchQName);
        
        HRESULT ( STDMETHODCALLTYPE *getIndexFromName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [retval][out] */ int *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE *getIndexFromQName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [retval][out] */ int *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE *getType )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE *getTypeFromName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE *getTypeFromQName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE *getValue )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue);
        
        HRESULT ( STDMETHODCALLTYPE *getValueFromName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue);
        
        HRESULT ( STDMETHODCALLTYPE *getValueFromQName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue);
        
        END_INTERFACE
    } ISAXAttributesVtbl;

    interface ISAXAttributes
    {
        CONST_VTBL struct ISAXAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXAttributes_getLength(This,pnLength)	\
    (This)->lpVtbl -> getLength(This,pnLength)

#define ISAXAttributes_getURI(This,nIndex,ppwchUri,pcchUri)	\
    (This)->lpVtbl -> getURI(This,nIndex,ppwchUri,pcchUri)

#define ISAXAttributes_getLocalName(This,nIndex,ppwchLocalName,pcchLocalName)	\
    (This)->lpVtbl -> getLocalName(This,nIndex,ppwchLocalName,pcchLocalName)

#define ISAXAttributes_getQName(This,nIndex,ppwchQName,pcchQName)	\
    (This)->lpVtbl -> getQName(This,nIndex,ppwchQName,pcchQName)

#define ISAXAttributes_getName(This,nIndex,ppwchUri,pcchUri,ppwchLocalName,pcchLocalName,ppwchQName,pcchQName)	\
    (This)->lpVtbl -> getName(This,nIndex,ppwchUri,pcchUri,ppwchLocalName,pcchLocalName,ppwchQName,pcchQName)

#define ISAXAttributes_getIndexFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,pnIndex)	\
    (This)->lpVtbl -> getIndexFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,pnIndex)

#define ISAXAttributes_getIndexFromQName(This,pwchQName,cchQName,pnIndex)	\
    (This)->lpVtbl -> getIndexFromQName(This,pwchQName,cchQName,pnIndex)

#define ISAXAttributes_getType(This,nIndex,ppwchType,pcchType)	\
    (This)->lpVtbl -> getType(This,nIndex,ppwchType,pcchType)

#define ISAXAttributes_getTypeFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchType,pcchType)	\
    (This)->lpVtbl -> getTypeFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchType,pcchType)

#define ISAXAttributes_getTypeFromQName(This,pwchQName,cchQName,ppwchType,pcchType)	\
    (This)->lpVtbl -> getTypeFromQName(This,pwchQName,cchQName,ppwchType,pcchType)

#define ISAXAttributes_getValue(This,nIndex,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValue(This,nIndex,ppwchValue,pcchValue)

#define ISAXAttributes_getValueFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValueFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchValue,pcchValue)

#define ISAXAttributes_getValueFromQName(This,pwchQName,cchQName,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValueFromQName(This,pwchQName,cchQName,ppwchValue,pcchValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXAttributes_getLength_Proxy( 
    ISAXAttributes * This,
    /* [retval][out] */ int *pnLength);


void __RPC_STUB ISAXAttributes_getLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getURI_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchUri,
    /* [out] */ int *pcchUri);


void __RPC_STUB ISAXAttributes_getURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getLocalName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchLocalName,
    /* [out] */ int *pcchLocalName);


void __RPC_STUB ISAXAttributes_getLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getQName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchQName,
    /* [out] */ int *pcchQName);


void __RPC_STUB ISAXAttributes_getQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchUri,
    /* [out] */ int *pcchUri,
    /* [out] */ const wchar_t **ppwchLocalName,
    /* [out] */ int *pcchLocalName,
    /* [out] */ const wchar_t **ppwchQName,
    /* [out] */ int *pcchQName);


void __RPC_STUB ISAXAttributes_getName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getIndexFromName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [retval][out] */ int *pnIndex);


void __RPC_STUB ISAXAttributes_getIndexFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getIndexFromQName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName,
    /* [retval][out] */ int *pnIndex);


void __RPC_STUB ISAXAttributes_getIndexFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getType_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchType,
    /* [out] */ int *pcchType);


void __RPC_STUB ISAXAttributes_getType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getTypeFromName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [out] */ const wchar_t **ppwchType,
    /* [out] */ int *pcchType);


void __RPC_STUB ISAXAttributes_getTypeFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getTypeFromQName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName,
    /* [out] */ const wchar_t **ppwchType,
    /* [out] */ int *pcchType);


void __RPC_STUB ISAXAttributes_getTypeFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValue_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchValue,
    /* [out] */ int *pcchValue);


void __RPC_STUB ISAXAttributes_getValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValueFromName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [out] */ const wchar_t **ppwchValue,
    /* [out] */ int *pcchValue);


void __RPC_STUB ISAXAttributes_getValueFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValueFromQName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName,
    /* [out] */ const wchar_t **ppwchValue,
    /* [out] */ int *pcchValue);


void __RPC_STUB ISAXAttributes_getValueFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXAttributes_INTERFACE_DEFINED__ */


#ifndef __IVBSAXXMLReader_INTERFACE_DEFINED__
#define __IVBSAXXMLReader_INTERFACE_DEFINED__

/* interface IVBSAXXMLReader */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXXMLReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c033caa-6cd6-4f73-b728-4531af74945f")
    IVBSAXXMLReader : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getFeature( 
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE putFeature( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT *varValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE putProperty( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_entityResolver( 
            /* [retval][out] */ IVBSAXEntityResolver **oResolver) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_entityResolver( 
            /* [in] */ IVBSAXEntityResolver *oResolver) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_contentHandler( 
            /* [retval][out] */ IVBSAXContentHandler **oHandler) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_contentHandler( 
            /* [in] */ IVBSAXContentHandler *oHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_dtdHandler( 
            /* [retval][out] */ IVBSAXDTDHandler **oHandler) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_dtdHandler( 
            /* [in] */ IVBSAXDTDHandler *oHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_errorHandler( 
            /* [retval][out] */ IVBSAXErrorHandler **oHandler) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_errorHandler( 
            /* [in] */ IVBSAXErrorHandler *oHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_baseURL( 
            /* [retval][out] */ BSTR *strBaseURL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_baseURL( 
            /* [in] */ BSTR strBaseURL) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_secureBaseURL( 
            /* [retval][out] */ BSTR *strSecureBaseURL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_secureBaseURL( 
            /* [in] */ BSTR strSecureBaseURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE parse( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE parseURL( 
            /* [in] */ BSTR strURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXXMLReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXXMLReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXXMLReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXXMLReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXXMLReader * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXXMLReader * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXXMLReader * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXXMLReader * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getFeature )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *putFeature )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT *varValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *putProperty )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT varValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_entityResolver )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ IVBSAXEntityResolver **oResolver);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_entityResolver )( 
            IVBSAXXMLReader * This,
            /* [in] */ IVBSAXEntityResolver *oResolver);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_contentHandler )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ IVBSAXContentHandler **oHandler);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_contentHandler )( 
            IVBSAXXMLReader * This,
            /* [in] */ IVBSAXContentHandler *oHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dtdHandler )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ IVBSAXDTDHandler **oHandler);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_dtdHandler )( 
            IVBSAXXMLReader * This,
            /* [in] */ IVBSAXDTDHandler *oHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_errorHandler )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ IVBSAXErrorHandler **oHandler);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_errorHandler )( 
            IVBSAXXMLReader * This,
            /* [in] */ IVBSAXErrorHandler *oHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseURL )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ BSTR *strBaseURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_baseURL )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strBaseURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_secureBaseURL )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ BSTR *strSecureBaseURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_secureBaseURL )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strSecureBaseURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *parse )( 
            IVBSAXXMLReader * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *parseURL )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strURL);
        
        END_INTERFACE
    } IVBSAXXMLReaderVtbl;

    interface IVBSAXXMLReader
    {
        CONST_VTBL struct IVBSAXXMLReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXXMLReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXXMLReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXXMLReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXXMLReader_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXXMLReader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXXMLReader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXXMLReader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXXMLReader_getFeature(This,strName,fValue)	\
    (This)->lpVtbl -> getFeature(This,strName,fValue)

#define IVBSAXXMLReader_putFeature(This,strName,fValue)	\
    (This)->lpVtbl -> putFeature(This,strName,fValue)

#define IVBSAXXMLReader_getProperty(This,strName,varValue)	\
    (This)->lpVtbl -> getProperty(This,strName,varValue)

#define IVBSAXXMLReader_putProperty(This,strName,varValue)	\
    (This)->lpVtbl -> putProperty(This,strName,varValue)

#define IVBSAXXMLReader_get_entityResolver(This,oResolver)	\
    (This)->lpVtbl -> get_entityResolver(This,oResolver)

#define IVBSAXXMLReader_putref_entityResolver(This,oResolver)	\
    (This)->lpVtbl -> putref_entityResolver(This,oResolver)

#define IVBSAXXMLReader_get_contentHandler(This,oHandler)	\
    (This)->lpVtbl -> get_contentHandler(This,oHandler)

#define IVBSAXXMLReader_putref_contentHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_contentHandler(This,oHandler)

#define IVBSAXXMLReader_get_dtdHandler(This,oHandler)	\
    (This)->lpVtbl -> get_dtdHandler(This,oHandler)

#define IVBSAXXMLReader_putref_dtdHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_dtdHandler(This,oHandler)

#define IVBSAXXMLReader_get_errorHandler(This,oHandler)	\
    (This)->lpVtbl -> get_errorHandler(This,oHandler)

#define IVBSAXXMLReader_putref_errorHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_errorHandler(This,oHandler)

#define IVBSAXXMLReader_get_baseURL(This,strBaseURL)	\
    (This)->lpVtbl -> get_baseURL(This,strBaseURL)

#define IVBSAXXMLReader_put_baseURL(This,strBaseURL)	\
    (This)->lpVtbl -> put_baseURL(This,strBaseURL)

#define IVBSAXXMLReader_get_secureBaseURL(This,strSecureBaseURL)	\
    (This)->lpVtbl -> get_secureBaseURL(This,strSecureBaseURL)

#define IVBSAXXMLReader_put_secureBaseURL(This,strSecureBaseURL)	\
    (This)->lpVtbl -> put_secureBaseURL(This,strSecureBaseURL)

#define IVBSAXXMLReader_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define IVBSAXXMLReader_parseURL(This,strURL)	\
    (This)->lpVtbl -> parseURL(This,strURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_getFeature_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strName,
    /* [retval][out] */ VARIANT_BOOL *fValue);


void __RPC_STUB IVBSAXXMLReader_getFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putFeature_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strName,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IVBSAXXMLReader_putFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_getProperty_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strName,
    /* [retval][out] */ VARIANT *varValue);


void __RPC_STUB IVBSAXXMLReader_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putProperty_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strName,
    /* [in] */ VARIANT varValue);


void __RPC_STUB IVBSAXXMLReader_putProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_entityResolver_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ IVBSAXEntityResolver **oResolver);


void __RPC_STUB IVBSAXXMLReader_get_entityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_entityResolver_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ IVBSAXEntityResolver *oResolver);


void __RPC_STUB IVBSAXXMLReader_putref_entityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_contentHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ IVBSAXContentHandler **oHandler);


void __RPC_STUB IVBSAXXMLReader_get_contentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_contentHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ IVBSAXContentHandler *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_contentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_dtdHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ IVBSAXDTDHandler **oHandler);


void __RPC_STUB IVBSAXXMLReader_get_dtdHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_dtdHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ IVBSAXDTDHandler *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_dtdHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_errorHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ IVBSAXErrorHandler **oHandler);


void __RPC_STUB IVBSAXXMLReader_get_errorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_errorHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ IVBSAXErrorHandler *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_errorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_baseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ BSTR *strBaseURL);


void __RPC_STUB IVBSAXXMLReader_get_baseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_put_baseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strBaseURL);


void __RPC_STUB IVBSAXXMLReader_put_baseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_secureBaseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ BSTR *strSecureBaseURL);


void __RPC_STUB IVBSAXXMLReader_get_secureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_put_secureBaseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strSecureBaseURL);


void __RPC_STUB IVBSAXXMLReader_put_secureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_parse_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IVBSAXXMLReader_parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_parseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strURL);


void __RPC_STUB IVBSAXXMLReader_parseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXXMLReader_INTERFACE_DEFINED__ */


#ifndef __IVBSAXXMLFilter_INTERFACE_DEFINED__
#define __IVBSAXXMLFilter_INTERFACE_DEFINED__

/* interface IVBSAXXMLFilter */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXXMLFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1299eb1b-5b88-433e-82de-82ca75ad4e04")
    IVBSAXXMLFilter : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [retval][out] */ IVBSAXXMLReader **oReader) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_parent( 
            /* [in] */ IVBSAXXMLReader *oReader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXXMLFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXXMLFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXXMLFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXXMLFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXXMLFilter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXXMLFilter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXXMLFilter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXXMLFilter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parent )( 
            IVBSAXXMLFilter * This,
            /* [retval][out] */ IVBSAXXMLReader **oReader);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_parent )( 
            IVBSAXXMLFilter * This,
            /* [in] */ IVBSAXXMLReader *oReader);
        
        END_INTERFACE
    } IVBSAXXMLFilterVtbl;

    interface IVBSAXXMLFilter
    {
        CONST_VTBL struct IVBSAXXMLFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXXMLFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXXMLFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXXMLFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXXMLFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXXMLFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXXMLFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXXMLFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXXMLFilter_get_parent(This,oReader)	\
    (This)->lpVtbl -> get_parent(This,oReader)

#define IVBSAXXMLFilter_putref_parent(This,oReader)	\
    (This)->lpVtbl -> putref_parent(This,oReader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLFilter_get_parent_Proxy( 
    IVBSAXXMLFilter * This,
    /* [retval][out] */ IVBSAXXMLReader **oReader);


void __RPC_STUB IVBSAXXMLFilter_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLFilter_putref_parent_Proxy( 
    IVBSAXXMLFilter * This,
    /* [in] */ IVBSAXXMLReader *oReader);


void __RPC_STUB IVBSAXXMLFilter_putref_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXXMLFilter_INTERFACE_DEFINED__ */


#ifndef __IVBSAXLocator_INTERFACE_DEFINED__
#define __IVBSAXLocator_INTERFACE_DEFINED__

/* interface IVBSAXLocator */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("796e7ac5-5aa2-4eff-acad-3faaf01a3288")
    IVBSAXLocator : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumber( 
            /* [retval][out] */ int *nColumn) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumber( 
            /* [retval][out] */ int *nLine) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ BSTR *strPublicId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ BSTR *strSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXLocator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXLocator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumber )( 
            IVBSAXLocator * This,
            /* [retval][out] */ int *nColumn);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumber )( 
            IVBSAXLocator * This,
            /* [retval][out] */ int *nLine);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_publicId )( 
            IVBSAXLocator * This,
            /* [retval][out] */ BSTR *strPublicId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemId )( 
            IVBSAXLocator * This,
            /* [retval][out] */ BSTR *strSystemId);
        
        END_INTERFACE
    } IVBSAXLocatorVtbl;

    interface IVBSAXLocator
    {
        CONST_VTBL struct IVBSAXLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXLocator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXLocator_get_columnNumber(This,nColumn)	\
    (This)->lpVtbl -> get_columnNumber(This,nColumn)

#define IVBSAXLocator_get_lineNumber(This,nLine)	\
    (This)->lpVtbl -> get_lineNumber(This,nLine)

#define IVBSAXLocator_get_publicId(This,strPublicId)	\
    (This)->lpVtbl -> get_publicId(This,strPublicId)

#define IVBSAXLocator_get_systemId(This,strSystemId)	\
    (This)->lpVtbl -> get_systemId(This,strSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_columnNumber_Proxy( 
    IVBSAXLocator * This,
    /* [retval][out] */ int *nColumn);


void __RPC_STUB IVBSAXLocator_get_columnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_lineNumber_Proxy( 
    IVBSAXLocator * This,
    /* [retval][out] */ int *nLine);


void __RPC_STUB IVBSAXLocator_get_lineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_publicId_Proxy( 
    IVBSAXLocator * This,
    /* [retval][out] */ BSTR *strPublicId);


void __RPC_STUB IVBSAXLocator_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_systemId_Proxy( 
    IVBSAXLocator * This,
    /* [retval][out] */ BSTR *strSystemId);


void __RPC_STUB IVBSAXLocator_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXLocator_INTERFACE_DEFINED__ */


#ifndef __IVBSAXEntityResolver_INTERFACE_DEFINED__
#define __IVBSAXEntityResolver_INTERFACE_DEFINED__

/* interface IVBSAXEntityResolver */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXEntityResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0c05d096-f45b-4aca-ad1a-aa0bc25518dc")
    IVBSAXEntityResolver : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE resolveEntity( 
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId,
            /* [retval][out] */ VARIANT *varInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXEntityResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXEntityResolver * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXEntityResolver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXEntityResolver * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXEntityResolver * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXEntityResolver * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXEntityResolver * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXEntityResolver * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *resolveEntity )( 
            IVBSAXEntityResolver * This,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId,
            /* [retval][out] */ VARIANT *varInput);
        
        END_INTERFACE
    } IVBSAXEntityResolverVtbl;

    interface IVBSAXEntityResolver
    {
        CONST_VTBL struct IVBSAXEntityResolverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXEntityResolver_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXEntityResolver_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXEntityResolver_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXEntityResolver_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXEntityResolver_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXEntityResolver_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXEntityResolver_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXEntityResolver_resolveEntity(This,strPublicId,strSystemId,varInput)	\
    (This)->lpVtbl -> resolveEntity(This,strPublicId,strSystemId,varInput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXEntityResolver_resolveEntity_Proxy( 
    IVBSAXEntityResolver * This,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId,
    /* [retval][out] */ VARIANT *varInput);


void __RPC_STUB IVBSAXEntityResolver_resolveEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXEntityResolver_INTERFACE_DEFINED__ */


#ifndef __IVBSAXContentHandler_INTERFACE_DEFINED__
#define __IVBSAXContentHandler_INTERFACE_DEFINED__

/* interface IVBSAXContentHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXContentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2ed7290a-4dd5-4b46-bb26-4e4155e77faa")
    IVBSAXContentHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_documentLocator( 
            /* [in] */ IVBSAXLocator *oLocator) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startDocument( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endDocument( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startPrefixMapping( 
            /* [out][in] */ BSTR *strPrefix,
            /* [out][in] */ BSTR *strURI) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endPrefixMapping( 
            /* [out][in] */ BSTR *strPrefix) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startElement( 
            /* [out][in] */ BSTR *strNamespaceURI,
            /* [out][in] */ BSTR *strLocalName,
            /* [out][in] */ BSTR *strQName,
            /* [in] */ IVBSAXAttributes *oAttributes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endElement( 
            /* [out][in] */ BSTR *strNamespaceURI,
            /* [out][in] */ BSTR *strLocalName,
            /* [out][in] */ BSTR *strQName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE characters( 
            /* [out][in] */ BSTR *strChars) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [out][in] */ BSTR *strChars) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [out][in] */ BSTR *strTarget,
            /* [out][in] */ BSTR *strData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [out][in] */ BSTR *strName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXContentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXContentHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXContentHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXContentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXContentHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXContentHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXContentHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXContentHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_documentLocator )( 
            IVBSAXContentHandler * This,
            /* [in] */ IVBSAXLocator *oLocator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startDocument )( 
            IVBSAXContentHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endDocument )( 
            IVBSAXContentHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startPrefixMapping )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strPrefix,
            /* [out][in] */ BSTR *strURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endPrefixMapping )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strPrefix);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startElement )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strNamespaceURI,
            /* [out][in] */ BSTR *strLocalName,
            /* [out][in] */ BSTR *strQName,
            /* [in] */ IVBSAXAttributes *oAttributes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endElement )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strNamespaceURI,
            /* [out][in] */ BSTR *strLocalName,
            /* [out][in] */ BSTR *strQName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *characters )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strChars);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ignorableWhitespace )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strChars);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *processingInstruction )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strTarget,
            /* [out][in] */ BSTR *strData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *skippedEntity )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strName);
        
        END_INTERFACE
    } IVBSAXContentHandlerVtbl;

    interface IVBSAXContentHandler
    {
        CONST_VTBL struct IVBSAXContentHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXContentHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXContentHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXContentHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXContentHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXContentHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXContentHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXContentHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXContentHandler_putref_documentLocator(This,oLocator)	\
    (This)->lpVtbl -> putref_documentLocator(This,oLocator)

#define IVBSAXContentHandler_startDocument(This)	\
    (This)->lpVtbl -> startDocument(This)

#define IVBSAXContentHandler_endDocument(This)	\
    (This)->lpVtbl -> endDocument(This)

#define IVBSAXContentHandler_startPrefixMapping(This,strPrefix,strURI)	\
    (This)->lpVtbl -> startPrefixMapping(This,strPrefix,strURI)

#define IVBSAXContentHandler_endPrefixMapping(This,strPrefix)	\
    (This)->lpVtbl -> endPrefixMapping(This,strPrefix)

#define IVBSAXContentHandler_startElement(This,strNamespaceURI,strLocalName,strQName,oAttributes)	\
    (This)->lpVtbl -> startElement(This,strNamespaceURI,strLocalName,strQName,oAttributes)

#define IVBSAXContentHandler_endElement(This,strNamespaceURI,strLocalName,strQName)	\
    (This)->lpVtbl -> endElement(This,strNamespaceURI,strLocalName,strQName)

#define IVBSAXContentHandler_characters(This,strChars)	\
    (This)->lpVtbl -> characters(This,strChars)

#define IVBSAXContentHandler_ignorableWhitespace(This,strChars)	\
    (This)->lpVtbl -> ignorableWhitespace(This,strChars)

#define IVBSAXContentHandler_processingInstruction(This,strTarget,strData)	\
    (This)->lpVtbl -> processingInstruction(This,strTarget,strData)

#define IVBSAXContentHandler_skippedEntity(This,strName)	\
    (This)->lpVtbl -> skippedEntity(This,strName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_putref_documentLocator_Proxy( 
    IVBSAXContentHandler * This,
    /* [in] */ IVBSAXLocator *oLocator);


void __RPC_STUB IVBSAXContentHandler_putref_documentLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startDocument_Proxy( 
    IVBSAXContentHandler * This);


void __RPC_STUB IVBSAXContentHandler_startDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endDocument_Proxy( 
    IVBSAXContentHandler * This);


void __RPC_STUB IVBSAXContentHandler_endDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startPrefixMapping_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strPrefix,
    /* [out][in] */ BSTR *strURI);


void __RPC_STUB IVBSAXContentHandler_startPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endPrefixMapping_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strPrefix);


void __RPC_STUB IVBSAXContentHandler_endPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startElement_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strNamespaceURI,
    /* [out][in] */ BSTR *strLocalName,
    /* [out][in] */ BSTR *strQName,
    /* [in] */ IVBSAXAttributes *oAttributes);


void __RPC_STUB IVBSAXContentHandler_startElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endElement_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strNamespaceURI,
    /* [out][in] */ BSTR *strLocalName,
    /* [out][in] */ BSTR *strQName);


void __RPC_STUB IVBSAXContentHandler_endElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_characters_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strChars);


void __RPC_STUB IVBSAXContentHandler_characters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_ignorableWhitespace_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strChars);


void __RPC_STUB IVBSAXContentHandler_ignorableWhitespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_processingInstruction_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strTarget,
    /* [out][in] */ BSTR *strData);


void __RPC_STUB IVBSAXContentHandler_processingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_skippedEntity_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strName);


void __RPC_STUB IVBSAXContentHandler_skippedEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXContentHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXDTDHandler_INTERFACE_DEFINED__
#define __IVBSAXDTDHandler_INTERFACE_DEFINED__

/* interface IVBSAXDTDHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXDTDHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24fb3297-302d-4620-ba39-3a732d850558")
    IVBSAXDTDHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE notationDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE unparsedEntityDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId,
            /* [out][in] */ BSTR *strNotationName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXDTDHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXDTDHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXDTDHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXDTDHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXDTDHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXDTDHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXDTDHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXDTDHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *notationDecl )( 
            IVBSAXDTDHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *unparsedEntityDecl )( 
            IVBSAXDTDHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId,
            /* [out][in] */ BSTR *strNotationName);
        
        END_INTERFACE
    } IVBSAXDTDHandlerVtbl;

    interface IVBSAXDTDHandler
    {
        CONST_VTBL struct IVBSAXDTDHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXDTDHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXDTDHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXDTDHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXDTDHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXDTDHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXDTDHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXDTDHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXDTDHandler_notationDecl(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> notationDecl(This,strName,strPublicId,strSystemId)

#define IVBSAXDTDHandler_unparsedEntityDecl(This,strName,strPublicId,strSystemId,strNotationName)	\
    (This)->lpVtbl -> unparsedEntityDecl(This,strName,strPublicId,strSystemId,strNotationName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDTDHandler_notationDecl_Proxy( 
    IVBSAXDTDHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId);


void __RPC_STUB IVBSAXDTDHandler_notationDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDTDHandler_unparsedEntityDecl_Proxy( 
    IVBSAXDTDHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId,
    /* [out][in] */ BSTR *strNotationName);


void __RPC_STUB IVBSAXDTDHandler_unparsedEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXDTDHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXErrorHandler_INTERFACE_DEFINED__
#define __IVBSAXErrorHandler_INTERFACE_DEFINED__

/* interface IVBSAXErrorHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d963d3fe-173c-4862-9095-b92f66995f52")
    IVBSAXErrorHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE error( 
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE fatalError( 
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ignorableWarning( 
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXErrorHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXErrorHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXErrorHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXErrorHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXErrorHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXErrorHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *error )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *fatalError )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ignorableWarning )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        END_INTERFACE
    } IVBSAXErrorHandlerVtbl;

    interface IVBSAXErrorHandler
    {
        CONST_VTBL struct IVBSAXErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXErrorHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXErrorHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXErrorHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXErrorHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXErrorHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXErrorHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXErrorHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXErrorHandler_error(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> error(This,oLocator,strErrorMessage,nErrorCode)

#define IVBSAXErrorHandler_fatalError(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> fatalError(This,oLocator,strErrorMessage,nErrorCode)

#define IVBSAXErrorHandler_ignorableWarning(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> ignorableWarning(This,oLocator,strErrorMessage,nErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_error_Proxy( 
    IVBSAXErrorHandler * This,
    /* [in] */ IVBSAXLocator *oLocator,
    /* [out][in] */ BSTR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_fatalError_Proxy( 
    IVBSAXErrorHandler * This,
    /* [in] */ IVBSAXLocator *oLocator,
    /* [out][in] */ BSTR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_fatalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_ignorableWarning_Proxy( 
    IVBSAXErrorHandler * This,
    /* [in] */ IVBSAXLocator *oLocator,
    /* [out][in] */ BSTR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_ignorableWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXErrorHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXLexicalHandler_INTERFACE_DEFINED__
#define __IVBSAXLexicalHandler_INTERFACE_DEFINED__

/* interface IVBSAXLexicalHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXLexicalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("032aac35-8c0e-4d9d-979f-e3b702935576")
    IVBSAXLexicalHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startDTD( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endDTD( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startEntity( 
            /* [out][in] */ BSTR *strName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endEntity( 
            /* [out][in] */ BSTR *strName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startCDATA( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endCDATA( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE comment( 
            /* [out][in] */ BSTR *strChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXLexicalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXLexicalHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXLexicalHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startDTD )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endDTD )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startEntity )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endEntity )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startCDATA )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endCDATA )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *comment )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strChars);
        
        END_INTERFACE
    } IVBSAXLexicalHandlerVtbl;

    interface IVBSAXLexicalHandler
    {
        CONST_VTBL struct IVBSAXLexicalHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXLexicalHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXLexicalHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXLexicalHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXLexicalHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXLexicalHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXLexicalHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXLexicalHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXLexicalHandler_startDTD(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> startDTD(This,strName,strPublicId,strSystemId)

#define IVBSAXLexicalHandler_endDTD(This)	\
    (This)->lpVtbl -> endDTD(This)

#define IVBSAXLexicalHandler_startEntity(This,strName)	\
    (This)->lpVtbl -> startEntity(This,strName)

#define IVBSAXLexicalHandler_endEntity(This,strName)	\
    (This)->lpVtbl -> endEntity(This,strName)

#define IVBSAXLexicalHandler_startCDATA(This)	\
    (This)->lpVtbl -> startCDATA(This)

#define IVBSAXLexicalHandler_endCDATA(This)	\
    (This)->lpVtbl -> endCDATA(This)

#define IVBSAXLexicalHandler_comment(This,strChars)	\
    (This)->lpVtbl -> comment(This,strChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startDTD_Proxy( 
    IVBSAXLexicalHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId);


void __RPC_STUB IVBSAXLexicalHandler_startDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endDTD_Proxy( 
    IVBSAXLexicalHandler * This);


void __RPC_STUB IVBSAXLexicalHandler_endDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startEntity_Proxy( 
    IVBSAXLexicalHandler * This,
    /* [out][in] */ BSTR *strName);


void __RPC_STUB IVBSAXLexicalHandler_startEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endEntity_Proxy( 
    IVBSAXLexicalHandler * This,
    /* [out][in] */ BSTR *strName);


void __RPC_STUB IVBSAXLexicalHandler_endEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startCDATA_Proxy( 
    IVBSAXLexicalHandler * This);


void __RPC_STUB IVBSAXLexicalHandler_startCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endCDATA_Proxy( 
    IVBSAXLexicalHandler * This);


void __RPC_STUB IVBSAXLexicalHandler_endCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_comment_Proxy( 
    IVBSAXLexicalHandler * This,
    /* [out][in] */ BSTR *strChars);


void __RPC_STUB IVBSAXLexicalHandler_comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXLexicalHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXDeclHandler_INTERFACE_DEFINED__
#define __IVBSAXDeclHandler_INTERFACE_DEFINED__

/* interface IVBSAXDeclHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXDeclHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e8917260-7579-4be1-b5dd-7afbfa6f077b")
    IVBSAXDeclHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE elementDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strModel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE attributeDecl( 
            /* [out][in] */ BSTR *strElementName,
            /* [out][in] */ BSTR *strAttributeName,
            /* [out][in] */ BSTR *strType,
            /* [out][in] */ BSTR *strValueDefault,
            /* [out][in] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE internalEntityDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE externalEntityDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXDeclHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXDeclHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXDeclHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXDeclHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXDeclHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXDeclHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *elementDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strModel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *attributeDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strElementName,
            /* [out][in] */ BSTR *strAttributeName,
            /* [out][in] */ BSTR *strType,
            /* [out][in] */ BSTR *strValueDefault,
            /* [out][in] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *internalEntityDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *externalEntityDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId);
        
        END_INTERFACE
    } IVBSAXDeclHandlerVtbl;

    interface IVBSAXDeclHandler
    {
        CONST_VTBL struct IVBSAXDeclHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXDeclHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXDeclHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXDeclHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXDeclHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXDeclHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXDeclHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXDeclHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXDeclHandler_elementDecl(This,strName,strModel)	\
    (This)->lpVtbl -> elementDecl(This,strName,strModel)

#define IVBSAXDeclHandler_attributeDecl(This,strElementName,strAttributeName,strType,strValueDefault,strValue)	\
    (This)->lpVtbl -> attributeDecl(This,strElementName,strAttributeName,strType,strValueDefault,strValue)

#define IVBSAXDeclHandler_internalEntityDecl(This,strName,strValue)	\
    (This)->lpVtbl -> internalEntityDecl(This,strName,strValue)

#define IVBSAXDeclHandler_externalEntityDecl(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> externalEntityDecl(This,strName,strPublicId,strSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_elementDecl_Proxy( 
    IVBSAXDeclHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strModel);


void __RPC_STUB IVBSAXDeclHandler_elementDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_attributeDecl_Proxy( 
    IVBSAXDeclHandler * This,
    /* [out][in] */ BSTR *strElementName,
    /* [out][in] */ BSTR *strAttributeName,
    /* [out][in] */ BSTR *strType,
    /* [out][in] */ BSTR *strValueDefault,
    /* [out][in] */ BSTR *strValue);


void __RPC_STUB IVBSAXDeclHandler_attributeDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_internalEntityDecl_Proxy( 
    IVBSAXDeclHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strValue);


void __RPC_STUB IVBSAXDeclHandler_internalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_externalEntityDecl_Proxy( 
    IVBSAXDeclHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId);


void __RPC_STUB IVBSAXDeclHandler_externalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXDeclHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXAttributes_INTERFACE_DEFINED__
#define __IVBSAXAttributes_INTERFACE_DEFINED__

/* interface IVBSAXAttributes */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10dc0586-132b-4cac-8bb3-db00ac8b7ee0")
    IVBSAXAttributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ int *nLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strURI) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getLocalName( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strLocalName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getQName( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strQName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getIndexFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ int *nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getIndexFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ int *nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getTypeFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getTypeFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValue( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValueFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValueFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXAttributes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXAttributes * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXAttributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXAttributes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXAttributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IVBSAXAttributes * This,
            /* [retval][out] */ int *nLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getURI )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getLocalName )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strLocalName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getQName )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strQName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getIndexFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ int *nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getIndexFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ int *nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getType )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getTypeFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getTypeFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValue )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValueFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValueFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strValue);
        
        END_INTERFACE
    } IVBSAXAttributesVtbl;

    interface IVBSAXAttributes
    {
        CONST_VTBL struct IVBSAXAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXAttributes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXAttributes_get_length(This,nLength)	\
    (This)->lpVtbl -> get_length(This,nLength)

#define IVBSAXAttributes_getURI(This,nIndex,strURI)	\
    (This)->lpVtbl -> getURI(This,nIndex,strURI)

#define IVBSAXAttributes_getLocalName(This,nIndex,strLocalName)	\
    (This)->lpVtbl -> getLocalName(This,nIndex,strLocalName)

#define IVBSAXAttributes_getQName(This,nIndex,strQName)	\
    (This)->lpVtbl -> getQName(This,nIndex,strQName)

#define IVBSAXAttributes_getIndexFromName(This,strURI,strLocalName,nIndex)	\
    (This)->lpVtbl -> getIndexFromName(This,strURI,strLocalName,nIndex)

#define IVBSAXAttributes_getIndexFromQName(This,strQName,nIndex)	\
    (This)->lpVtbl -> getIndexFromQName(This,strQName,nIndex)

#define IVBSAXAttributes_getType(This,nIndex,strType)	\
    (This)->lpVtbl -> getType(This,nIndex,strType)

#define IVBSAXAttributes_getTypeFromName(This,strURI,strLocalName,strType)	\
    (This)->lpVtbl -> getTypeFromName(This,strURI,strLocalName,strType)

#define IVBSAXAttributes_getTypeFromQName(This,strQName,strType)	\
    (This)->lpVtbl -> getTypeFromQName(This,strQName,strType)

#define IVBSAXAttributes_getValue(This,nIndex,strValue)	\
    (This)->lpVtbl -> getValue(This,nIndex,strValue)

#define IVBSAXAttributes_getValueFromName(This,strURI,strLocalName,strValue)	\
    (This)->lpVtbl -> getValueFromName(This,strURI,strLocalName,strValue)

#define IVBSAXAttributes_getValueFromQName(This,strQName,strValue)	\
    (This)->lpVtbl -> getValueFromQName(This,strQName,strValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_get_length_Proxy( 
    IVBSAXAttributes * This,
    /* [retval][out] */ int *nLength);


void __RPC_STUB IVBSAXAttributes_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getURI_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strURI);


void __RPC_STUB IVBSAXAttributes_getURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getLocalName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strLocalName);


void __RPC_STUB IVBSAXAttributes_getLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getQName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strQName);


void __RPC_STUB IVBSAXAttributes_getQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getIndexFromName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ int *nIndex);


void __RPC_STUB IVBSAXAttributes_getIndexFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getIndexFromQName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ int *nIndex);


void __RPC_STUB IVBSAXAttributes_getIndexFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getType_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IVBSAXAttributes_getType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getTypeFromName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IVBSAXAttributes_getTypeFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getTypeFromQName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IVBSAXAttributes_getTypeFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValue_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strValue);


void __RPC_STUB IVBSAXAttributes_getValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValueFromName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ BSTR *strValue);


void __RPC_STUB IVBSAXAttributes_getValueFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValueFromQName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ BSTR *strValue);


void __RPC_STUB IVBSAXAttributes_getValueFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXAttributes_INTERFACE_DEFINED__ */


#ifndef __IMXWriter_INTERFACE_DEFINED__
#define __IMXWriter_INTERFACE_DEFINED__

/* interface IMXWriter */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d7ff4ba-1565-4ea8-94e1-6e724a46f98d")
    IMXWriter : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_output( 
            /* [in] */ VARIANT varDestination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_output( 
            /* [retval][out] */ VARIANT *varDestination) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_encoding( 
            /* [in] */ BSTR strEncoding) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_encoding( 
            /* [retval][out] */ BSTR *strEncoding) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_byteOrderMark( 
            /* [in] */ VARIANT_BOOL fWriteByteOrderMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_byteOrderMark( 
            /* [retval][out] */ VARIANT_BOOL *fWriteByteOrderMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_indent( 
            /* [in] */ VARIANT_BOOL fIndentMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_indent( 
            /* [retval][out] */ VARIANT_BOOL *fIndentMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_standalone( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_standalone( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_omitXMLDeclaration( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_omitXMLDeclaration( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_version( 
            /* [in] */ BSTR strVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [retval][out] */ BSTR *strVersion) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_disableOutputEscaping( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_disableOutputEscaping( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXWriter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXWriter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXWriter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXWriter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_output )( 
            IMXWriter * This,
            /* [in] */ VARIANT varDestination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_output )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT *varDestination);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_encoding )( 
            IMXWriter * This,
            /* [in] */ BSTR strEncoding);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_encoding )( 
            IMXWriter * This,
            /* [retval][out] */ BSTR *strEncoding);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_byteOrderMark )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fWriteByteOrderMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_byteOrderMark )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fWriteByteOrderMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_indent )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fIndentMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_indent )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fIndentMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_standalone )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_standalone )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_omitXMLDeclaration )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_omitXMLDeclaration )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_version )( 
            IMXWriter * This,
            /* [in] */ BSTR strVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            IMXWriter * This,
            /* [retval][out] */ BSTR *strVersion);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_disableOutputEscaping )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_disableOutputEscaping )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *flush )( 
            IMXWriter * This);
        
        END_INTERFACE
    } IMXWriterVtbl;

    interface IMXWriter
    {
        CONST_VTBL struct IMXWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXWriter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXWriter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXWriter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXWriter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXWriter_put_output(This,varDestination)	\
    (This)->lpVtbl -> put_output(This,varDestination)

#define IMXWriter_get_output(This,varDestination)	\
    (This)->lpVtbl -> get_output(This,varDestination)

#define IMXWriter_put_encoding(This,strEncoding)	\
    (This)->lpVtbl -> put_encoding(This,strEncoding)

#define IMXWriter_get_encoding(This,strEncoding)	\
    (This)->lpVtbl -> get_encoding(This,strEncoding)

#define IMXWriter_put_byteOrderMark(This,fWriteByteOrderMark)	\
    (This)->lpVtbl -> put_byteOrderMark(This,fWriteByteOrderMark)

#define IMXWriter_get_byteOrderMark(This,fWriteByteOrderMark)	\
    (This)->lpVtbl -> get_byteOrderMark(This,fWriteByteOrderMark)

#define IMXWriter_put_indent(This,fIndentMode)	\
    (This)->lpVtbl -> put_indent(This,fIndentMode)

#define IMXWriter_get_indent(This,fIndentMode)	\
    (This)->lpVtbl -> get_indent(This,fIndentMode)

#define IMXWriter_put_standalone(This,fValue)	\
    (This)->lpVtbl -> put_standalone(This,fValue)

#define IMXWriter_get_standalone(This,fValue)	\
    (This)->lpVtbl -> get_standalone(This,fValue)

#define IMXWriter_put_omitXMLDeclaration(This,fValue)	\
    (This)->lpVtbl -> put_omitXMLDeclaration(This,fValue)

#define IMXWriter_get_omitXMLDeclaration(This,fValue)	\
    (This)->lpVtbl -> get_omitXMLDeclaration(This,fValue)

#define IMXWriter_put_version(This,strVersion)	\
    (This)->lpVtbl -> put_version(This,strVersion)

#define IMXWriter_get_version(This,strVersion)	\
    (This)->lpVtbl -> get_version(This,strVersion)

#define IMXWriter_put_disableOutputEscaping(This,fValue)	\
    (This)->lpVtbl -> put_disableOutputEscaping(This,fValue)

#define IMXWriter_get_disableOutputEscaping(This,fValue)	\
    (This)->lpVtbl -> get_disableOutputEscaping(This,fValue)

#define IMXWriter_flush(This)	\
    (This)->lpVtbl -> flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_output_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT varDestination);


void __RPC_STUB IMXWriter_put_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_output_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT *varDestination);


void __RPC_STUB IMXWriter_get_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_encoding_Proxy( 
    IMXWriter * This,
    /* [in] */ BSTR strEncoding);


void __RPC_STUB IMXWriter_put_encoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_encoding_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ BSTR *strEncoding);


void __RPC_STUB IMXWriter_get_encoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_byteOrderMark_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fWriteByteOrderMark);


void __RPC_STUB IMXWriter_put_byteOrderMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_byteOrderMark_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fWriteByteOrderMark);


void __RPC_STUB IMXWriter_get_byteOrderMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_indent_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fIndentMode);


void __RPC_STUB IMXWriter_put_indent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_indent_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fIndentMode);


void __RPC_STUB IMXWriter_get_indent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_standalone_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_standalone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_standalone_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fValue);


void __RPC_STUB IMXWriter_get_standalone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_omitXMLDeclaration_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_omitXMLDeclaration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_omitXMLDeclaration_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fValue);


void __RPC_STUB IMXWriter_get_omitXMLDeclaration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_version_Proxy( 
    IMXWriter * This,
    /* [in] */ BSTR strVersion);


void __RPC_STUB IMXWriter_put_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_version_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ BSTR *strVersion);


void __RPC_STUB IMXWriter_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_disableOutputEscaping_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_disableOutputEscaping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_disableOutputEscaping_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fValue);


void __RPC_STUB IMXWriter_get_disableOutputEscaping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXWriter_flush_Proxy( 
    IMXWriter * This);


void __RPC_STUB IMXWriter_flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXWriter_INTERFACE_DEFINED__ */


#ifndef __IMXAttributes_INTERFACE_DEFINED__
#define __IMXAttributes_INTERFACE_DEFINED__

/* interface IMXAttributes */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f10d27cc-3ec0-415c-8ed8-77ab1c5e7262")
    IMXAttributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addAttribute( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addAttributeFromIndex( 
            /* [in] */ VARIANT varAtts,
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttributes( 
            /* [in] */ VARIANT varAtts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setLocalName( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strLocalName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setQName( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strQName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setType( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setURI( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setValue( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXAttributes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXAttributes * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXAttributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXAttributes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXAttributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addAttribute )( 
            IMXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addAttributeFromIndex )( 
            IMXAttributes * This,
            /* [in] */ VARIANT varAtts,
            /* [in] */ int nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *clear )( 
            IMXAttributes * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IMXAttributes * This,
            /* [in] */ int nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttributes )( 
            IMXAttributes * This,
            /* [in] */ VARIANT varAtts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setLocalName )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strLocalName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setQName )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strQName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setType )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setURI )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setValue )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strValue);
        
        END_INTERFACE
    } IMXAttributesVtbl;

    interface IMXAttributes
    {
        CONST_VTBL struct IMXAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXAttributes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXAttributes_addAttribute(This,strURI,strLocalName,strQName,strType,strValue)	\
    (This)->lpVtbl -> addAttribute(This,strURI,strLocalName,strQName,strType,strValue)

#define IMXAttributes_addAttributeFromIndex(This,varAtts,nIndex)	\
    (This)->lpVtbl -> addAttributeFromIndex(This,varAtts,nIndex)

#define IMXAttributes_clear(This)	\
    (This)->lpVtbl -> clear(This)

#define IMXAttributes_removeAttribute(This,nIndex)	\
    (This)->lpVtbl -> removeAttribute(This,nIndex)

#define IMXAttributes_setAttribute(This,nIndex,strURI,strLocalName,strQName,strType,strValue)	\
    (This)->lpVtbl -> setAttribute(This,nIndex,strURI,strLocalName,strQName,strType,strValue)

#define IMXAttributes_setAttributes(This,varAtts)	\
    (This)->lpVtbl -> setAttributes(This,varAtts)

#define IMXAttributes_setLocalName(This,nIndex,strLocalName)	\
    (This)->lpVtbl -> setLocalName(This,nIndex,strLocalName)

#define IMXAttributes_setQName(This,nIndex,strQName)	\
    (This)->lpVtbl -> setQName(This,nIndex,strQName)

#define IMXAttributes_setType(This,nIndex,strType)	\
    (This)->lpVtbl -> setType(This,nIndex,strType)

#define IMXAttributes_setURI(This,nIndex,strURI)	\
    (This)->lpVtbl -> setURI(This,nIndex,strURI)

#define IMXAttributes_setValue(This,nIndex,strValue)	\
    (This)->lpVtbl -> setValue(This,nIndex,strValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_addAttribute_Proxy( 
    IMXAttributes * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [in] */ BSTR strQName,
    /* [in] */ BSTR strType,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_addAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_addAttributeFromIndex_Proxy( 
    IMXAttributes * This,
    /* [in] */ VARIANT varAtts,
    /* [in] */ int nIndex);


void __RPC_STUB IMXAttributes_addAttributeFromIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_clear_Proxy( 
    IMXAttributes * This);


void __RPC_STUB IMXAttributes_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_removeAttribute_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex);


void __RPC_STUB IMXAttributes_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setAttribute_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [in] */ BSTR strQName,
    /* [in] */ BSTR strType,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setAttributes_Proxy( 
    IMXAttributes * This,
    /* [in] */ VARIANT varAtts);


void __RPC_STUB IMXAttributes_setAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setLocalName_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strLocalName);


void __RPC_STUB IMXAttributes_setLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setQName_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strQName);


void __RPC_STUB IMXAttributes_setQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setType_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strType);


void __RPC_STUB IMXAttributes_setType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setURI_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strURI);


void __RPC_STUB IMXAttributes_setURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setValue_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_setValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXAttributes_INTERFACE_DEFINED__ */


#ifndef __IMXReaderControl_INTERFACE_DEFINED__
#define __IMXReaderControl_INTERFACE_DEFINED__

/* interface IMXReaderControl */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXReaderControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("808f4e35-8d5a-4fbe-8466-33a41279ed30")
    IMXReaderControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE resume( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE suspend( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXReaderControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXReaderControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXReaderControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXReaderControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXReaderControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXReaderControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXReaderControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXReaderControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IMXReaderControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *resume )( 
            IMXReaderControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *suspend )( 
            IMXReaderControl * This);
        
        END_INTERFACE
    } IMXReaderControlVtbl;

    interface IMXReaderControl
    {
        CONST_VTBL struct IMXReaderControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXReaderControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXReaderControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXReaderControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXReaderControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXReaderControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXReaderControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXReaderControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXReaderControl_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IMXReaderControl_resume(This)	\
    (This)->lpVtbl -> resume(This)

#define IMXReaderControl_suspend(This)	\
    (This)->lpVtbl -> suspend(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_abort_Proxy( 
    IMXReaderControl * This);


void __RPC_STUB IMXReaderControl_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_resume_Proxy( 
    IMXReaderControl * This);


void __RPC_STUB IMXReaderControl_resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_suspend_Proxy( 
    IMXReaderControl * This);


void __RPC_STUB IMXReaderControl_suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXReaderControl_INTERFACE_DEFINED__ */


#ifndef __IXMLElementCollection_INTERFACE_DEFINED__
#define __IXMLElementCollection_INTERFACE_DEFINED__

/* interface IXMLElementCollection */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElementCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65725580-9B5D-11d0-9BFE-00C04FC99C8E")
    IXMLElementCollection : public IDispatch
    {
    public:
        virtual /* [id][hidden][restricted][propput] */ HRESULT STDMETHODCALLTYPE put_length( 
            /* [in] */ long v) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **ppUnk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch **ppDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLElementCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLElementCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLElementCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLElementCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLElementCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLElementCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLElementCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][hidden][restricted][propput] */ HRESULT ( STDMETHODCALLTYPE *put_length )( 
            IXMLElementCollection * This,
            /* [in] */ long v);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLElementCollection * This,
            /* [out][retval] */ long *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLElementCollection * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *item )( 
            IXMLElementCollection * This,
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch **ppDisp);
        
        END_INTERFACE
    } IXMLElementCollectionVtbl;

    interface IXMLElementCollection
    {
        CONST_VTBL struct IXMLElementCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElementCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElementCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElementCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElementCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElementCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElementCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElementCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElementCollection_put_length(This,v)	\
    (This)->lpVtbl -> put_length(This,v)

#define IXMLElementCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IXMLElementCollection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#define IXMLElementCollection_item(This,var1,var2,ppDisp)	\
    (This)->lpVtbl -> item(This,var1,var2,ppDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][hidden][restricted][propput] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_put_length_Proxy( 
    IXMLElementCollection * This,
    /* [in] */ long v);


void __RPC_STUB IXMLElementCollection_put_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get_length_Proxy( 
    IXMLElementCollection * This,
    /* [out][retval] */ long *p);


void __RPC_STUB IXMLElementCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get__newEnum_Proxy( 
    IXMLElementCollection * This,
    /* [out][retval] */ IUnknown **ppUnk);


void __RPC_STUB IXMLElementCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_item_Proxy( 
    IXMLElementCollection * This,
    /* [in][optional] */ VARIANT var1,
    /* [in][optional] */ VARIANT var2,
    /* [out][retval] */ IDispatch **ppDisp);


void __RPC_STUB IXMLElementCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElementCollection_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument_INTERFACE_DEFINED__
#define __IXMLDocument_INTERFACE_DEFINED__

/* interface IXMLDocument */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F52E2B61-18A1-11d1-B105-00805F49916B")
    IXMLDocument : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement **p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long *pl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement **ppElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDocument * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDocument * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDocument * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDocument * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_root )( 
            IXMLDocument * This,
            /* [out][retval] */ IXMLElement **p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileSize )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileModifiedDate )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileUpdatedDate )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IXMLDocument * This,
            /* [in] */ BSTR p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_mimeType )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLDocument * This,
            /* [out][retval] */ long *pl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_charset )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_charset )( 
            IXMLDocument * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dtdURL )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IXMLDocument * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement **ppElem);
        
        END_INTERFACE
    } IXMLDocumentVtbl;

    interface IXMLDocument
    {
        CONST_VTBL struct IXMLDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_root_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ IXMLElement **p);


void __RPC_STUB IXMLDocument_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileSize_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileModifiedDate_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileUpdatedDate_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_URL_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_URL_Proxy( 
    IXMLDocument * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_mimeType_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_readyState_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ long *pl);


void __RPC_STUB IXMLDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_charset_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_charset_Proxy( 
    IXMLDocument * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_version_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_doctype_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_dtdURL_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDocument_createElement_Proxy( 
    IXMLDocument * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement **ppElem);


void __RPC_STUB IXMLDocument_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument2_INTERFACE_DEFINED__
#define __IXMLDocument2_INTERFACE_DEFINED__

/* interface IXMLDocument2 */
/* [hidden][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8DE2FE-8D2D-11d1-B2FC-00C04FD915A9")
    IXMLDocument2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement2 **p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long *pl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement2 **ppElem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_async( 
            /* [out][retval] */ VARIANT_BOOL *pf) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_async( 
            /* [in] */ VARIANT_BOOL f) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDocument2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDocument2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDocument2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDocument2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDocument2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDocument2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDocument2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_root )( 
            IXMLDocument2 * This,
            /* [out][retval] */ IXMLElement2 **p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileSize )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileModifiedDate )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileUpdatedDate )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IXMLDocument2 * This,
            /* [in] */ BSTR p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_mimeType )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLDocument2 * This,
            /* [out][retval] */ long *pl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_charset )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_charset )( 
            IXMLDocument2 * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dtdURL )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IXMLDocument2 * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement2 **ppElem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_async )( 
            IXMLDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *pf);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_async )( 
            IXMLDocument2 * This,
            /* [in] */ VARIANT_BOOL f);
        
        END_INTERFACE
    } IXMLDocument2Vtbl;

    interface IXMLDocument2
    {
        CONST_VTBL struct IXMLDocument2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument2_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument2_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument2_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument2_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument2_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument2_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument2_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument2_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument2_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument2_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument2_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument2_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument2_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument2_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#define IXMLDocument2_get_async(This,pf)	\
    (This)->lpVtbl -> get_async(This,pf)

#define IXMLDocument2_put_async(This,f)	\
    (This)->lpVtbl -> put_async(This,f)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_root_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ IXMLElement2 **p);


void __RPC_STUB IXMLDocument2_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileSize_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileModifiedDate_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileUpdatedDate_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_URL_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_URL_Proxy( 
    IXMLDocument2 * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument2_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_mimeType_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_readyState_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ long *pl);


void __RPC_STUB IXMLDocument2_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_charset_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_charset_Proxy( 
    IXMLDocument2 * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument2_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_version_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_doctype_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_dtdURL_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_createElement_Proxy( 
    IXMLDocument2 * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement2 **ppElem);


void __RPC_STUB IXMLDocument2_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_async_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ VARIANT_BOOL *pf);


void __RPC_STUB IXMLDocument2_get_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_async_Proxy( 
    IXMLDocument2 * This,
    /* [in] */ VARIANT_BOOL f);


void __RPC_STUB IXMLDocument2_put_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument2_INTERFACE_DEFINED__ */


#ifndef __IXMLElement_INTERFACE_DEFINED__
#define __IXMLElement_INTERFACE_DEFINED__

/* interface IXMLElement */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F7F31AC-E15F-11d0-9C25-00C04FC99C8E")
    IXMLElement : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement **ppParent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT *PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection **pp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long *plType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement *pChildElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_tagName )( 
            IXMLElement * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_tagName )( 
            IXMLElement * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parent )( 
            IXMLElement * This,
            /* [out][retval] */ IXMLElement **ppParent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IXMLElement * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAttribute )( 
            IXMLElement * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT *PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IXMLElement * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_children )( 
            IXMLElement * This,
            /* [out][retval] */ IXMLElementCollection **pp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IXMLElement * This,
            /* [out][retval] */ long *plType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLElement * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLElement * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addChild )( 
            IXMLElement * This,
            /* [in] */ IXMLElement *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLElement * This,
            /* [in] */ IXMLElement *pChildElem);
        
        END_INTERFACE
    } IXMLElementVtbl;

    interface IXMLElement
    {
        CONST_VTBL struct IXMLElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_tagName_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_tagName_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_parent_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ IXMLElement **ppParent);


void __RPC_STUB IXMLElement_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_setAttribute_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_getAttribute_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT *PropertyValue);


void __RPC_STUB IXMLElement_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeAttribute_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_children_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ IXMLElementCollection **pp);


void __RPC_STUB IXMLElement_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_type_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ long *plType);


void __RPC_STUB IXMLElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_text_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_text_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_addChild_Proxy( 
    IXMLElement * This,
    /* [in] */ IXMLElement *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeChild_Proxy( 
    IXMLElement * This,
    /* [in] */ IXMLElement *pChildElem);


void __RPC_STUB IXMLElement_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement_INTERFACE_DEFINED__ */


#ifndef __IXMLElement2_INTERFACE_DEFINED__
#define __IXMLElement2_INTERFACE_DEFINED__

/* interface IXMLElement2 */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElement2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8DE2FF-8D2D-11d1-B2FC-00C04FD915A9")
    IXMLElement2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement2 **ppParent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT *PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection **pp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long *plType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement2 *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement2 *pChildElem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [out][retval] */ IXMLElementCollection **pp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElement2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLElement2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLElement2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLElement2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLElement2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLElement2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLElement2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLElement2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_tagName )( 
            IXMLElement2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_tagName )( 
            IXMLElement2 * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parent )( 
            IXMLElement2 * This,
            /* [out][retval] */ IXMLElement2 **ppParent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IXMLElement2 * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAttribute )( 
            IXMLElement2 * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT *PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IXMLElement2 * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_children )( 
            IXMLElement2 * This,
            /* [out][retval] */ IXMLElementCollection **pp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IXMLElement2 * This,
            /* [out][retval] */ long *plType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLElement2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLElement2 * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addChild )( 
            IXMLElement2 * This,
            /* [in] */ IXMLElement2 *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLElement2 * This,
            /* [in] */ IXMLElement2 *pChildElem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLElement2 * This,
            /* [out][retval] */ IXMLElementCollection **pp);
        
        END_INTERFACE
    } IXMLElement2Vtbl;

    interface IXMLElement2
    {
        CONST_VTBL struct IXMLElement2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement2_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement2_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement2_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement2_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement2_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement2_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement2_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement2_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement2_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement2_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement2_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement2_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#define IXMLElement2_get_attributes(This,pp)	\
    (This)->lpVtbl -> get_attributes(This,pp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_tagName_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLElement2_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement2_put_tagName_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement2_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_parent_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ IXMLElement2 **ppParent);


void __RPC_STUB IXMLElement2_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_setAttribute_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement2_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_getAttribute_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT *PropertyValue);


void __RPC_STUB IXMLElement2_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_removeAttribute_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement2_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_children_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ IXMLElementCollection **pp);


void __RPC_STUB IXMLElement2_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_type_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ long *plType);


void __RPC_STUB IXMLElement2_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_text_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLElement2_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement2_put_text_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement2_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_addChild_Proxy( 
    IXMLElement2 * This,
    /* [in] */ IXMLElement2 *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement2_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_removeChild_Proxy( 
    IXMLElement2 * This,
    /* [in] */ IXMLElement2 *pChildElem);


void __RPC_STUB IXMLElement2_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_attributes_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ IXMLElementCollection **pp);


void __RPC_STUB IXMLElement2_get_attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement2_INTERFACE_DEFINED__ */


#ifndef __IXMLAttribute_INTERFACE_DEFINED__
#define __IXMLAttribute_INTERFACE_DEFINED__

/* interface IXMLAttribute */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4D4A0FC-3B73-11d1-B2B4-00C04FB92596")
    IXMLAttribute : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR *n) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR *v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLAttribute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLAttribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLAttribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLAttribute * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLAttribute * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLAttribute * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLAttribute * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IXMLAttribute * This,
            /* [out][retval] */ BSTR *n);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_value )( 
            IXMLAttribute * This,
            /* [out][retval] */ BSTR *v);
        
        END_INTERFACE
    } IXMLAttributeVtbl;

    interface IXMLAttribute
    {
        CONST_VTBL struct IXMLAttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLAttribute_get_name(This,n)	\
    (This)->lpVtbl -> get_name(This,n)

#define IXMLAttribute_get_value(This,v)	\
    (This)->lpVtbl -> get_value(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLAttribute_get_name_Proxy( 
    IXMLAttribute * This,
    /* [out][retval] */ BSTR *n);


void __RPC_STUB IXMLAttribute_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLAttribute_get_value_Proxy( 
    IXMLAttribute * This,
    /* [out][retval] */ BSTR *v);


void __RPC_STUB IXMLAttribute_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLAttribute_INTERFACE_DEFINED__ */


#ifndef __IXMLError_INTERFACE_DEFINED__
#define __IXMLError_INTERFACE_DEFINED__

/* interface IXMLError */
/* [helpstring][hidden][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("948C5AD3-C58D-11d0-9C0B-00C04FC99C8E")
    IXMLError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            XML_ERROR *pErrorReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLError * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLError * This,
            XML_ERROR *pErrorReturn);
        
        END_INTERFACE
    } IXMLErrorVtbl;

    interface IXMLError
    {
        CONST_VTBL struct IXMLErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLError_GetErrorInfo(This,pErrorReturn)	\
    (This)->lpVtbl -> GetErrorInfo(This,pErrorReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLError_GetErrorInfo_Proxy( 
    IXMLError * This,
    XML_ERROR *pErrorReturn);


void __RPC_STUB IXMLError_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLError_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMSelection_INTERFACE_DEFINED__
#define __IXMLDOMSelection_INTERFACE_DEFINED__

/* interface IXMLDOMSelection */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA634FC7-5888-44a7-A257-3A47150D3A0E")
    IXMLDOMSelection : public IXMLDOMNodeList
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_expr( 
            /* [retval][out] */ BSTR *expression) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_expr( 
            /* [in] */ BSTR expression) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_context( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_context( 
            /* [in] */ IXMLDOMNode *pNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE peekNode( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE matches( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeNext( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAll( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IXMLDOMSelection **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMSelection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMSelection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMSelection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMSelection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMSelection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMSelection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMSelection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IXMLDOMSelection * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ long *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nextNode )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXMLDOMSelection * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMSelection * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_expr )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ BSTR *expression);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_expr )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR expression);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_context )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_context )( 
            IXMLDOMSelection * This,
            /* [in] */ IXMLDOMNode *pNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *peekNode )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *matches )( 
            IXMLDOMSelection * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeNext )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAll )( 
            IXMLDOMSelection * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *clone )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMSelection **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setProperty )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        END_INTERFACE
    } IXMLDOMSelectionVtbl;

    interface IXMLDOMSelection
    {
        CONST_VTBL struct IXMLDOMSelectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMSelection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMSelection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMSelection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMSelection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMSelection_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMSelection_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMSelection_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMSelection_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMSelection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)


#define IXMLDOMSelection_get_expr(This,expression)	\
    (This)->lpVtbl -> get_expr(This,expression)

#define IXMLDOMSelection_put_expr(This,expression)	\
    (This)->lpVtbl -> put_expr(This,expression)

#define IXMLDOMSelection_get_context(This,ppNode)	\
    (This)->lpVtbl -> get_context(This,ppNode)

#define IXMLDOMSelection_putref_context(This,pNode)	\
    (This)->lpVtbl -> putref_context(This,pNode)

#define IXMLDOMSelection_peekNode(This,ppNode)	\
    (This)->lpVtbl -> peekNode(This,ppNode)

#define IXMLDOMSelection_matches(This,pNode,ppNode)	\
    (This)->lpVtbl -> matches(This,pNode,ppNode)

#define IXMLDOMSelection_removeNext(This,ppNode)	\
    (This)->lpVtbl -> removeNext(This,ppNode)

#define IXMLDOMSelection_removeAll(This)	\
    (This)->lpVtbl -> removeAll(This)

#define IXMLDOMSelection_clone(This,ppNode)	\
    (This)->lpVtbl -> clone(This,ppNode)

#define IXMLDOMSelection_getProperty(This,name,value)	\
    (This)->lpVtbl -> getProperty(This,name,value)

#define IXMLDOMSelection_setProperty(This,name,value)	\
    (This)->lpVtbl -> setProperty(This,name,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_get_expr_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ BSTR *expression);


void __RPC_STUB IXMLDOMSelection_get_expr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_put_expr_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ BSTR expression);


void __RPC_STUB IXMLDOMSelection_put_expr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_get_context_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ IXMLDOMNode **ppNode);


void __RPC_STUB IXMLDOMSelection_get_context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_putref_context_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ IXMLDOMNode *pNode);


void __RPC_STUB IXMLDOMSelection_putref_context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_peekNode_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ IXMLDOMNode **ppNode);


void __RPC_STUB IXMLDOMSelection_peekNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_matches_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ IXMLDOMNode **ppNode);


void __RPC_STUB IXMLDOMSelection_matches_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_removeNext_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ IXMLDOMNode **ppNode);


void __RPC_STUB IXMLDOMSelection_removeNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_removeAll_Proxy( 
    IXMLDOMSelection * This);


void __RPC_STUB IXMLDOMSelection_removeAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_clone_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ IXMLDOMSelection **ppNode);


void __RPC_STUB IXMLDOMSelection_clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_getProperty_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IXMLDOMSelection_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_setProperty_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMSelection_setProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMSelection_INTERFACE_DEFINED__ */


#ifndef __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__
#define __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__

/* dispinterface XMLDOMDocumentEvents */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_XMLDOMDocumentEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3efaa427-272f-11d2-836f-0000f87a7782")
    XMLDOMDocumentEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct XMLDOMDocumentEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            XMLDOMDocumentEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            XMLDOMDocumentEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            XMLDOMDocumentEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } XMLDOMDocumentEventsVtbl;

    interface XMLDOMDocumentEvents
    {
        CONST_VTBL struct XMLDOMDocumentEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define XMLDOMDocumentEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define XMLDOMDocumentEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define XMLDOMDocumentEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define XMLDOMDocumentEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define XMLDOMDocumentEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define XMLDOMDocumentEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define XMLDOMDocumentEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IDSOControl_INTERFACE_DEFINED__
#define __IDSOControl_INTERFACE_DEFINED__

/* interface IDSOControl */
/* [unique][helpstring][hidden][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IDSOControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("310afa62-0575-11d2-9ca9-0060b0ec3d39")
    IDSOControl : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLDocument( 
            /* [retval][out] */ IXMLDOMDocument **ppDoc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLDocument( 
            /* [in] */ IXMLDOMDocument *ppDoc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_JavaDSOCompatible( 
            /* [retval][out] */ BOOL *fJavaDSOCompatible) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_JavaDSOCompatible( 
            /* [in] */ BOOL fJavaDSOCompatible) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long *state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSOControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSOControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSOControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSOControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSOControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSOControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSOControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSOControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XMLDocument )( 
            IDSOControl * This,
            /* [retval][out] */ IXMLDOMDocument **ppDoc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_XMLDocument )( 
            IDSOControl * This,
            /* [in] */ IXMLDOMDocument *ppDoc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JavaDSOCompatible )( 
            IDSOControl * This,
            /* [retval][out] */ BOOL *fJavaDSOCompatible);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_JavaDSOCompatible )( 
            IDSOControl * This,
            /* [in] */ BOOL fJavaDSOCompatible);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IDSOControl * This,
            /* [retval][out] */ long *state);
        
        END_INTERFACE
    } IDSOControlVtbl;

    interface IDSOControl
    {
        CONST_VTBL struct IDSOControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSOControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDSOControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDSOControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDSOControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDSOControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDSOControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDSOControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDSOControl_get_XMLDocument(This,ppDoc)	\
    (This)->lpVtbl -> get_XMLDocument(This,ppDoc)

#define IDSOControl_put_XMLDocument(This,ppDoc)	\
    (This)->lpVtbl -> put_XMLDocument(This,ppDoc)

#define IDSOControl_get_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    (This)->lpVtbl -> get_JavaDSOCompatible(This,fJavaDSOCompatible)

#define IDSOControl_put_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    (This)->lpVtbl -> put_JavaDSOCompatible(This,fJavaDSOCompatible)

#define IDSOControl_get_readyState(This,state)	\
    (This)->lpVtbl -> get_readyState(This,state)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_XMLDocument_Proxy( 
    IDSOControl * This,
    /* [retval][out] */ IXMLDOMDocument **ppDoc);


void __RPC_STUB IDSOControl_get_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDSOControl_put_XMLDocument_Proxy( 
    IDSOControl * This,
    /* [in] */ IXMLDOMDocument *ppDoc);


void __RPC_STUB IDSOControl_put_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_JavaDSOCompatible_Proxy( 
    IDSOControl * This,
    /* [retval][out] */ BOOL *fJavaDSOCompatible);


void __RPC_STUB IDSOControl_get_JavaDSOCompatible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDSOControl_put_JavaDSOCompatible_Proxy( 
    IDSOControl * This,
    /* [in] */ BOOL fJavaDSOCompatible);


void __RPC_STUB IDSOControl_put_JavaDSOCompatible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_readyState_Proxy( 
    IDSOControl * This,
    /* [retval][out] */ long *state);


void __RPC_STUB IDSOControl_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDSOControl_INTERFACE_DEFINED__ */


#ifndef __IXMLHTTPRequest_INTERFACE_DEFINED__
#define __IXMLHTTPRequest_INTERFACE_DEFINED__

/* interface IXMLHTTPRequest */
/* [unique][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IXMLHTTPRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED8C108D-4349-11D2-91A4-00C04F7969E8")
    IXMLHTTPRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE open( 
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setRequestHeader( 
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getResponseHeader( 
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAllResponseHeaders( 
            /* [retval][out] */ BSTR *pbstrHeaders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE send( 
            /* [optional][in] */ VARIANT varBody) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_status( 
            /* [retval][out] */ long *plStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_statusText( 
            /* [retval][out] */ BSTR *pbstrStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseXML( 
            /* [retval][out] */ IDispatch **ppBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseText( 
            /* [retval][out] */ BSTR *pbstrBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseBody( 
            /* [retval][out] */ VARIANT *pvarBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseStream( 
            /* [retval][out] */ VARIANT *pvarBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long *plState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ IDispatch *pReadyStateSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLHTTPRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLHTTPRequest * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLHTTPRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLHTTPRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLHTTPRequest * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLHTTPRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLHTTPRequest * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLHTTPRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *open )( 
            IXMLHTTPRequest * This,
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setRequestHeader )( 
            IXMLHTTPRequest * This,
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getResponseHeader )( 
            IXMLHTTPRequest * This,
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAllResponseHeaders )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *send )( 
            IXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IXMLHTTPRequest * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ long *plStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statusText )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseXML )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ IDispatch **ppBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseText )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseBody )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseStream )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ long *plState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IXMLHTTPRequest * This,
            /* [in] */ IDispatch *pReadyStateSink);
        
        END_INTERFACE
    } IXMLHTTPRequestVtbl;

    interface IXMLHTTPRequest
    {
        CONST_VTBL struct IXMLHTTPRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLHTTPRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLHTTPRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLHTTPRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLHTTPRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLHTTPRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLHTTPRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLHTTPRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLHTTPRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)

#define IXMLHTTPRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue)

#define IXMLHTTPRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue)

#define IXMLHTTPRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders)

#define IXMLHTTPRequest_send(This,varBody)	\
    (This)->lpVtbl -> send(This,varBody)

#define IXMLHTTPRequest_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLHTTPRequest_get_status(This,plStatus)	\
    (This)->lpVtbl -> get_status(This,plStatus)

#define IXMLHTTPRequest_get_statusText(This,pbstrStatus)	\
    (This)->lpVtbl -> get_statusText(This,pbstrStatus)

#define IXMLHTTPRequest_get_responseXML(This,ppBody)	\
    (This)->lpVtbl -> get_responseXML(This,ppBody)

#define IXMLHTTPRequest_get_responseText(This,pbstrBody)	\
    (This)->lpVtbl -> get_responseText(This,pbstrBody)

#define IXMLHTTPRequest_get_responseBody(This,pvarBody)	\
    (This)->lpVtbl -> get_responseBody(This,pvarBody)

#define IXMLHTTPRequest_get_responseStream(This,pvarBody)	\
    (This)->lpVtbl -> get_responseStream(This,pvarBody)

#define IXMLHTTPRequest_get_readyState(This,plState)	\
    (This)->lpVtbl -> get_readyState(This,plState)

#define IXMLHTTPRequest_put_onreadystatechange(This,pReadyStateSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_open_Proxy( 
    IXMLHTTPRequest * This,
    /* [in] */ BSTR bstrMethod,
    /* [in] */ BSTR bstrUrl,
    /* [optional][in] */ VARIANT varAsync,
    /* [optional][in] */ VARIANT bstrUser,
    /* [optional][in] */ VARIANT bstrPassword);


void __RPC_STUB IXMLHTTPRequest_open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_setRequestHeader_Proxy( 
    IXMLHTTPRequest * This,
    /* [in] */ BSTR bstrHeader,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IXMLHTTPRequest_setRequestHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_getResponseHeader_Proxy( 
    IXMLHTTPRequest * This,
    /* [in] */ BSTR bstrHeader,
    /* [retval][out] */ BSTR *pbstrValue);


void __RPC_STUB IXMLHTTPRequest_getResponseHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_getAllResponseHeaders_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ BSTR *pbstrHeaders);


void __RPC_STUB IXMLHTTPRequest_getAllResponseHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_send_Proxy( 
    IXMLHTTPRequest * This,
    /* [optional][in] */ VARIANT varBody);


void __RPC_STUB IXMLHTTPRequest_send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_abort_Proxy( 
    IXMLHTTPRequest * This);


void __RPC_STUB IXMLHTTPRequest_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_status_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ long *plStatus);


void __RPC_STUB IXMLHTTPRequest_get_status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_statusText_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ BSTR *pbstrStatus);


void __RPC_STUB IXMLHTTPRequest_get_statusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseXML_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ IDispatch **ppBody);


void __RPC_STUB IXMLHTTPRequest_get_responseXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseText_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ BSTR *pbstrBody);


void __RPC_STUB IXMLHTTPRequest_get_responseText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseBody_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ VARIANT *pvarBody);


void __RPC_STUB IXMLHTTPRequest_get_responseBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseStream_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ VARIANT *pvarBody);


void __RPC_STUB IXMLHTTPRequest_get_responseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_readyState_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ long *plState);


void __RPC_STUB IXMLHTTPRequest_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_put_onreadystatechange_Proxy( 
    IXMLHTTPRequest * This,
    /* [in] */ IDispatch *pReadyStateSink);


void __RPC_STUB IXMLHTTPRequest_put_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLHTTPRequest_INTERFACE_DEFINED__ */


#ifndef __IServerXMLHTTPRequest_INTERFACE_DEFINED__
#define __IServerXMLHTTPRequest_INTERFACE_DEFINED__

/* interface IServerXMLHTTPRequest */
/* [unique][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IServerXMLHTTPRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e9196bf-13ba-4dd4-91ca-6c571f281495")
    IServerXMLHTTPRequest : public IXMLHTTPRequest
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setTimeouts( 
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE waitForResponse( 
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getOption( 
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setOption( 
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerXMLHTTPRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServerXMLHTTPRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServerXMLHTTPRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IServerXMLHTTPRequest * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *open )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setRequestHeader )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getResponseHeader )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAllResponseHeaders )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *send )( 
            IServerXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IServerXMLHTTPRequest * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ long *plStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statusText )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseXML )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ IDispatch **ppBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseText )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseBody )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseStream )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ long *plState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ IDispatch *pReadyStateSink);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setTimeouts )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *waitForResponse )( 
            IServerXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getOption )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setOption )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value);
        
        END_INTERFACE
    } IServerXMLHTTPRequestVtbl;

    interface IServerXMLHTTPRequest
    {
        CONST_VTBL struct IServerXMLHTTPRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerXMLHTTPRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerXMLHTTPRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerXMLHTTPRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerXMLHTTPRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServerXMLHTTPRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServerXMLHTTPRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServerXMLHTTPRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServerXMLHTTPRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)

#define IServerXMLHTTPRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue)

#define IServerXMLHTTPRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue)

#define IServerXMLHTTPRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders)

#define IServerXMLHTTPRequest_send(This,varBody)	\
    (This)->lpVtbl -> send(This,varBody)

#define IServerXMLHTTPRequest_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IServerXMLHTTPRequest_get_status(This,plStatus)	\
    (This)->lpVtbl -> get_status(This,plStatus)

#define IServerXMLHTTPRequest_get_statusText(This,pbstrStatus)	\
    (This)->lpVtbl -> get_statusText(This,pbstrStatus)

#define IServerXMLHTTPRequest_get_responseXML(This,ppBody)	\
    (This)->lpVtbl -> get_responseXML(This,ppBody)

#define IServerXMLHTTPRequest_get_responseText(This,pbstrBody)	\
    (This)->lpVtbl -> get_responseText(This,pbstrBody)

#define IServerXMLHTTPRequest_get_responseBody(This,pvarBody)	\
    (This)->lpVtbl -> get_responseBody(This,pvarBody)

#define IServerXMLHTTPRequest_get_responseStream(This,pvarBody)	\
    (This)->lpVtbl -> get_responseStream(This,pvarBody)

#define IServerXMLHTTPRequest_get_readyState(This,plState)	\
    (This)->lpVtbl -> get_readyState(This,plState)

#define IServerXMLHTTPRequest_put_onreadystatechange(This,pReadyStateSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink)


#define IServerXMLHTTPRequest_setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout)	\
    (This)->lpVtbl -> setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout)

#define IServerXMLHTTPRequest_waitForResponse(This,timeoutInSeconds,isSuccessful)	\
    (This)->lpVtbl -> waitForResponse(This,timeoutInSeconds,isSuccessful)

#define IServerXMLHTTPRequest_getOption(This,option,value)	\
    (This)->lpVtbl -> getOption(This,option,value)

#define IServerXMLHTTPRequest_setOption(This,option,value)	\
    (This)->lpVtbl -> setOption(This,option,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_setTimeouts_Proxy( 
    IServerXMLHTTPRequest * This,
    /* [in] */ long resolveTimeout,
    /* [in] */ long connectTimeout,
    /* [in] */ long sendTimeout,
    /* [in] */ long receiveTimeout);


void __RPC_STUB IServerXMLHTTPRequest_setTimeouts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_waitForResponse_Proxy( 
    IServerXMLHTTPRequest * This,
    /* [optional][in] */ VARIANT timeoutInSeconds,
    /* [retval][out] */ VARIANT_BOOL *isSuccessful);


void __RPC_STUB IServerXMLHTTPRequest_waitForResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_getOption_Proxy( 
    IServerXMLHTTPRequest * This,
    /* [in] */ SERVERXMLHTTP_OPTION option,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IServerXMLHTTPRequest_getOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_setOption_Proxy( 
    IServerXMLHTTPRequest * This,
    /* [in] */ SERVERXMLHTTP_OPTION option,
    /* [in] */ VARIANT value);


void __RPC_STUB IServerXMLHTTPRequest_setOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerXMLHTTPRequest_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F11-9C73-11D3-B32E-00C04F990BB4")
DOMDocument;
#endif

EXTERN_C const CLSID CLSID_DOMDocument26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1b-c551-11d3-89b9-0000f81fe221")
DOMDocument26;
#endif

EXTERN_C const CLSID CLSID_DOMDocument30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f32-c551-11d3-89b9-0000f81fe221")
DOMDocument30;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F12-9C73-11D3-B32E-00C04F990BB4")
FreeThreadedDOMDocument;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1c-c551-11d3-89b9-0000f81fe221")
FreeThreadedDOMDocument26;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f33-c551-11d3-89b9-0000f81fe221")
FreeThreadedDOMDocument30;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache;

#ifdef __cplusplus

class DECLSPEC_UUID("373984c9-b845-449b-91e7-45ac83036ade")
XMLSchemaCache;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1d-c551-11d3-89b9-0000f81fe221")
XMLSchemaCache26;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f34-c551-11d3-89b9-0000f81fe221")
XMLSchemaCache30;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate;

#ifdef __cplusplus

class DECLSPEC_UUID("2933BF94-7B36-11d2-B20E-00C04F983E60")
XSLTemplate;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f21-c551-11d3-89b9-0000f81fe221")
XSLTemplate26;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f36-c551-11d3-89b9-0000f81fe221")
XSLTemplate30;
#endif

EXTERN_C const CLSID CLSID_DSOControl;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F14-9C73-11D3-B32E-00C04F990BB4")
DSOControl;
#endif

EXTERN_C const CLSID CLSID_DSOControl26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1f-c551-11d3-89b9-0000f81fe221")
DSOControl26;
#endif

EXTERN_C const CLSID CLSID_DSOControl30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f39-c551-11d3-89b9-0000f81fe221")
DSOControl30;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F16-9C73-11D3-B32E-00C04F990BB4")
XMLHTTP;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1e-c551-11d3-89b9-0000f81fe221")
XMLHTTP26;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f35-c551-11d3-89b9-0000f81fe221")
XMLHTTP30;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP;

#ifdef __cplusplus

class DECLSPEC_UUID("afba6b42-5692-48ea-8141-dc517dcf0ef1")
ServerXMLHTTP;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP30;

#ifdef __cplusplus

class DECLSPEC_UUID("afb40ffd-b609-40a3-9828-f88bbe11e4e3")
ServerXMLHTTP30;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader;

#ifdef __cplusplus

class DECLSPEC_UUID("079aa557-4a18-424a-8eee-e39f0a8d41b9")
SAXXMLReader;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader30;

#ifdef __cplusplus

class DECLSPEC_UUID("3124c396-fb13-4836-a6ad-1317f1713688")
SAXXMLReader30;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter;

#ifdef __cplusplus

class DECLSPEC_UUID("fc220ad8-a72a-4ee8-926e-0b7ad152a020")
MXXMLWriter;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter30;

#ifdef __cplusplus

class DECLSPEC_UUID("3d813dfe-6c91-4a4e-8f41-04346a841d9c")
MXXMLWriter30;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes;

#ifdef __cplusplus

class DECLSPEC_UUID("4dd441ad-526d-4a77-9f1b-9841ed802fb0")
SAXAttributes;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes30;

#ifdef __cplusplus

class DECLSPEC_UUID("3e784a01-f3ae-4dc0-9354-9526b9370eba")
SAXAttributes30;
#endif

EXTERN_C const CLSID CLSID_XMLDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("CFC399AF-D876-11d0-9C10-00C04FC99C8E")
XMLDocument;
#endif
#endif /* __MSXML2_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_msxml2_0167 */
/* [local] */ 

//----------------------------
// MSXML SPECIFIC ERROR CODES 
//----------------------------
#define E_XML_NOTWF 0xC00CE223L  // Validate failed because the document is not well formed.
#define E_XML_NODTD 0xC00CE224L  // Validate failed because a DTD/Schema was not specified in the document.
#define E_XML_INVALID 0xC00CE225L  // Validate failed because of a DTD/Schema violation.
#ifdef __USE_MSXML2_NAMESPACE__
}
#endif


extern RPC_IF_HANDLE __MIDL_itf_msxml2_0167_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml2_0167_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\adreplpv\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#include <winldap.h>

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#if DBG==1

class CDbg
{
public:
    CDbg(LPTSTR str);
   ~CDbg();

    void Trace(PWSTR pszfmt, ...);
    void Trace(LPSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, PWSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, PWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);
//    void PingDc(LPSTR msg);
    void IncIndent();
    void DecIndent();

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

    static ULONG s_idxTls;

private:

    ULONG
    _GetIndent();

    unsigned long   m_flInfoLevel; // must be the first data member
    unsigned long   m_flOutputOptions;
    LPTSTR          m_InfoLevelString;

    /*
    //
    // Members used by PingDc
    //

    LDAP           *m_pldap;
    */
}; // class CDbg

class CIndenter
{
public:

    CIndenter(CDbg *pdbg): m_pDbg(pdbg) { m_pDbg->IncIndent(); }
    ~CIndenter() { m_pDbg->DecIndent(); }

private:

    CDbg *m_pDbg;
};

#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG==1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG==1





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined

#define DEB_FUNCTION        0x00800000
#define DEB_RESOURCE        0x01000000
#define DEB_METHOD          0x02000000
#define DEB_DSOBJECT        0x04000000
#define DEB_DATAOBJECT      0x08000000
#define DEB_RICHEDIT        0x10000000      // text processing
#define DEB_ENABLEPING      0x20000000      // enable DC pings
#define DEB_ELAPSEDTIME     0x40000000      // output elapsed time
#define DEB_NOCOMPNAME      0x80000000      // suppress component name

#define DEB_FORCE           0x1fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#ifndef DEF_INFOLEVEL
#define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\adreplpv\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0FF1CBC9_6CFC_4664_9657_D877BD3FB341__INCLUDED_)
#define AFX_STDAFX_H__0FF1CBC9_6CFC_4664_9657_D877BD3FB341__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <wbemprov.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <dsgetdc.h>

#include <iads.h> // IADsPathname

extern bool g_DoAssert;
EXTERN_C const CLSID CLSID_ADReplProvider;

#define ASSERT(f) if (g_DoAssert && !(f)) {_ASSERTE(false);}

///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_ADMINPRV_TRACE
    #define _USE_ADMINPRV_ASSERT
    #define _USE_ADMINPRV_TIMER
  #endif
#endif

#define ADMINPRV_COMPNAME L"AdReplPv"

#include "dbg.h"
///////////////////////////////////////////

#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0FF1CBC9_6CFC_4664_9657_D877BD3FB341__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\common\common.h ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service WMI providers
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       common.h
//
//  Contents:   Common macros and definitions
//
//  History:    24-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#define BAD_IN_STRING_PTR(p) (NULL == p || IsBadStringPtr(p,0))
#define BAD_IN_STRING_PTR_OPTIONAL(p) (NULL != p && IsBadStringPtr(p,0))
#define BAD_IN_READ_PTR(p,size) (NULL == p || IsBadReadPtr(p,size))
#define BAD_WRITE_PTR(p,size) (NULL == p || IsBadWritePtr(p,size))

template<class T>
bool
BAD_IN_MULTISTRUCT_PTR(T* p, size_t count)
{
    return BAD_IN_READ_PTR(p, count * sizeof(T));
}
#define BAD_IN_STRUCT_PTR(p) BAD_IN_MULTISTRUCT_PTR(p,1)

template<class T>
bool
BAD_OUT_MULTISTRUCT_PTR(T* p, size_t count)
{
    return BAD_WRITE_PTR(p, count * sizeof(T));
}
#define BAD_OUT_STRUCT_PTR(p) BAD_OUT_MULTISTRUCT_PTR(p,1)

#define ASSERT_AND_RETURN {ASSERT(false); return WBEM_E_INVALID_PARAMETER;}
#define ASSERT_AND_BREAK {ASSERT(false); break;}
#define BREAK_ON_FAIL if (FAILED(hr)) ASSERT_AND_BREAK;
#define BREAK_ON_NULL(x) if (!(x)) ASSERT_AND_BREAK;
#define BREAK_ON_NULL_(x, h, c) if (!(x)) {h = c; ASSERT_AND_BREAK;}
#define WBEM_VALIDATE_READ_PTR(p,size) \
            if (BAD_IN_READ_PTR(p,size)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRUCT_PTR(p) \
            if (BAD_IN_STRUCT_PTR(p)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_MULTISTRUCT_PTR(p,n) \
            if (BAD_IN_MULTISTRUCT_PTR(p,n)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_OUT_STRUCT_PTR(p) \
            if (BAD_OUT_STRUCT_PTR(p)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_OUT_PTRPTR(p) \
            if (NULL == p || IsBadWritePtr(p,sizeof(void*))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_INTF_PTR(p) \
            if (NULL == p || IsBadReadPtr(p,sizeof(void*))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRING_PTR(p) \
            if (BAD_IN_STRING_PTR(p)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(p) \
            if (BAD_IN_STRING_PTR_OPTIONAL(p)) ASSERT_AND_RETURN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\adreplpv\wbem.h ===
// WbemProv.h: Definition of the CProvider class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WBEMPROV_H__95A79B93_CFC8_4DB1_8256_5BEFC3FE2A26__INCLUDED_)
#define AFX_WBEMPROV_H__95A79B93_CFC8_4DB1_8256_5BEFC3FE2A26__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

typedef enum _ProviderClass
{
    CLASS_STATUS,
    CLASS_DC
} ProviderClass;

/////////////////////////////////////////////////////////////////////////////
// CProvider

class CProvider : 
	public IWbemProviderInit,
	public IWbemServices,
	public CComObjectRoot,
	public CComCoClass<CProvider,&CLSID_ADReplProvider>
{
public:
    CProvider();
    ~CProvider();
BEGIN_COM_MAP(CProvider)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CProvider) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_ADReplProvider)


// IWbemProviderInit

    STDMETHOD(Initialize)(
         IN LPWSTR pszUser,
         IN LONG lFlags,
         IN LPWSTR pszNamespace,
         IN LPWSTR pszLocale,
         IN IWbemServices *pNamespace,
         IN IWbemContext *pCtx,
         IN IWbemProviderInitSink *pInitSink
         );


// IWbemServices

    //
    // +++ Implemented +++
    //

    STDMETHOD(GetObjectAsync)( 
        IN const BSTR bstrObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler);

    STDMETHOD(CreateInstanceEnumAsync)( 
        IN const BSTR bstrClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler);

    //
    // --- NOT Implemented ---
    //

    STDMETHOD(OpenNamespace)( 
        IN const BSTR strNamespace,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemServices **ppWorkingNamespace,
        IN OUT IWbemCallResult **ppResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CancelAsyncCall)( 
        IN IWbemObjectSink *pSink)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(QueryObjectSink)( 
        IN long lFlags,
        OUT IWbemObjectSink **ppResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(GetObject)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemClassObject **ppObject,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(PutClass)( 
        IN IWbemClassObject *pObject,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutClassAsync)( 
        IN IWbemClassObject *pObject,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteClass)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteClassAsync)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CreateClassEnum)( 
        IN const BSTR strSuperclass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CreateClassEnumAsync)( 
        IN const BSTR strSuperclass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutInstance)( 
        IN IWbemClassObject *pInst,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutInstanceAsync)( 
        IN IWbemClassObject *pInst,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteInstance)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteInstanceAsync)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CreateInstanceEnum)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecQuery)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecQueryAsync)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecNotificationQuery)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecMethod)( 
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemClassObject *pInParams,
        IN OUT IWbemClassObject **ppOutParams,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecMethodAsync)( 
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemClassObject *pInParams,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

protected:

    HRESULT _EnumAndIndicateDC(
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue = FALSE
        );
    HRESULT _EnumAndIndicateStatus(
        IN ProviderClass provclass,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue = NULL );
    HRESULT _EnumAndIndicateWorker(
        IN ProviderClass provclass,
        IN HANDLE hDS,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue = NULL,
        IN const BSTR bstrDnsDomainName = NULL );
    /*
    HRESULT _EnumAndIndicateDCWorker(
        IN HANDLE hDS,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue = NULL );
    */

    HRESULT _BuildListStatus(
        IN HANDLE hDS,
        OUT DS_REPL_NEIGHBORS** ppneighborsstruct );
    /*
    HRESULT _BuildListDC(
        IN HANDLE hDS,
        IN const BSTR bstrDnsDomainName,
        OUT DS_DOMAIN_CONTROLLER_INFO_1** ppDCs,
        OUT ULONG* pcDCs );
    */

    HRESULT _BuildIndicateArrayStatus(
        IN  DS_REPL_NEIGHBORS*  pneighborstruct,
        IN  const BSTR          bstrFilterValue,
        OUT IWbemClassObject*** ppaIndicateItems,
        OUT DWORD*              pcIndicateItems);
    /*
    HRESULT _BuildIndicateArrayDC(
        IN  DS_DOMAIN_CONTROLLER_INFO_1* pDCs,
        IN  ULONG                        cDCs,
        IN  const BSTR                   bstrFilterValue,
        OUT IWbemClassObject***          ppaIndicateItems,
        OUT DWORD*                       pcIndicateItems);
    */
    void _ReleaseIndicateArray(
        IWbemClassObject**  paIndicateItems,
        DWORD               cIndicateItems,
        bool                fReleaseArray = true);

    HRESULT _PutAttributesStatus(
        IWbemClassObject**  pipNewInst,
        const BSTR          bstrFilterValue,
        DS_REPL_NEIGHBOR*   pneighbor);
    HRESULT _PutAttributesDC(
        IN IWbemClassObject*    pIndicateItem,
        IN IADsPathname*        pPathCracker,
        IN const BSTR           bstrFilterValue,
        IN IDirectorySearch*    pIADsSearch,
        IN ADS_SEARCH_HANDLE     hSearch);

    CComPtr<IWbemServices>      m_sipNamespace;
    CComPtr<IWbemClassObject>   m_sipClassDefStatus;
    CComPtr<IWbemClassObject>   m_sipClassDefDC;

};

#endif // !defined(AFX_WBEMPROV_H__95A79B93_CFC8_4DB1_8256_5BEFC3FE2A26__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\adreplpv\wbem.cpp ===
// WbemProv.cpp : Implementation of CAdreplpvApp and DLL registration.

#include "stdafx.h"
#include "dbg.cpp"
//#include "adreplpv.h"
#include "Wbem.h"
#include <lmcons.h>
#include <lmapibuf.h>
#include <adshlp.h>

#define INITGUID
#include <initguid.h>
DEFINE_GUID(CLSID_ADReplProvider,0x96FA95C4,0x0AF3,0x4EF9,0xA1,0xEB,0xC8,0x15,0x13,0x22,0x15,0x7B);

/////////////////////////////////////////////////////////////////////////////
//

// CODEWORK should only have one definition of classname and GUID
#define CLASSNAME_STRING_STATUS L"Microsoft_ADReplStatus"
#define CLASSNAME_STRING_DC L"Microsoft_ADReplDomainController"

CProvider::CProvider()
{
}

CProvider::~CProvider()
{
}


// IWbemProviderInit

STDMETHODIMP CProvider::Initialize(
         IN LPWSTR pszUser,
         IN LONG lFlags,
         IN LPWSTR pszNamespace,
         IN LPWSTR pszLocale,
         IN IWbemServices *pNamespace,
         IN IWbemContext *pCtx,
         IN IWbemProviderInitSink *pInitSink
         )
{
    WBEM_VALIDATE_INTF_PTR( pNamespace );
    WBEM_VALIDATE_INTF_PTR( pCtx );
    WBEM_VALIDATE_INTF_PTR( pInitSink );

    HRESULT hr = WBEM_S_NO_ERROR;

    do
    { 
        m_sipNamespace = pNamespace;

        CComBSTR sbstrObjectName = CLASSNAME_STRING_STATUS; // is this necessary?
        hr = m_sipNamespace->GetObject( sbstrObjectName,
                                        WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                        pCtx,
                                        &m_sipClassDefStatus,
                                        NULL );
        BREAK_ON_FAIL;

        sbstrObjectName = CLASSNAME_STRING_DC;
        hr = m_sipNamespace->GetObject( sbstrObjectName,
                                        WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                        pCtx,
                                        &m_sipClassDefDC,
                                        NULL );
        BREAK_ON_FAIL;

        // Let CIMOM know you are initialized
        // return value and SetStatus param should be consistent, so ignore
        // the return value from SetStatus itself (in retail builds)
        HRESULT hr2 = pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
        ASSERT( !FAILED(hr2) );

    } while (false);

    return hr;
}


// IWbemServices

// BUGBUG should this ever indicate more than one?
STDMETHODIMP CProvider::GetObjectAsync( 
        IN const BSTR bstrObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
{
    WBEM_VALIDATE_IN_STRING_PTR( bstrObjectPath );
    // CODEWORK check lFlags?
    WBEM_VALIDATE_INTF_PTR( pCtx );
    WBEM_VALIDATE_INTF_PTR( pResponseHandler );

    static LPCWSTR ROOTSTR_STATUS = L"Microsoft_ADReplStatus.CompositeName=\"";
    static LPCWSTR ROOTSTR_DC = L"Microsoft_ADReplDomainController.SiteName=\"";

    int rootlen = lstrlen(ROOTSTR_STATUS);
    if (   lstrlen(bstrObjectPath) > rootlen
        && 0 == _tcsnicmp(bstrObjectPath, ROOTSTR_STATUS, rootlen)
       )
    {
        // remove prefix
        CComBSTR sbstrFilterValue = (BSTR)bstrObjectPath + rootlen;
        // remove trailing doublequote
        sbstrFilterValue[lstrlen(sbstrFilterValue)-1] = L'\0';

        return _EnumAndIndicateStatus( CLASS_STATUS,
                                 pCtx,
                                 pResponseHandler,
                                 sbstrFilterValue );
    }

    rootlen = lstrlen(ROOTSTR_DC);
    if (   lstrlen(bstrObjectPath) > rootlen
        && 0 == _tcsnicmp(bstrObjectPath, ROOTSTR_DC, rootlen)
       )
    {
        // remove prefix
        CComBSTR sbstrFilterValue = (BSTR)bstrObjectPath + rootlen;
        // remove trailing doublequote
        sbstrFilterValue[lstrlen(sbstrFilterValue)-1] = L'\0';

        return _EnumAndIndicateDC( pCtx,
                                   pResponseHandler,
                                   sbstrFilterValue );
    }

    ASSERT(false);
    return WBEM_E_INVALID_OBJECT_PATH;
}

STDMETHODIMP CProvider::CreateInstanceEnumAsync( 
        IN const BSTR bstrClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
{
    WBEM_VALIDATE_IN_STRING_PTR( bstrClass );
    // CODEWORK check lFlags?
    WBEM_VALIDATE_INTF_PTR( pCtx );
    WBEM_VALIDATE_INTF_PTR( pResponseHandler );

    if ( 0 == lstrcmp( bstrClass, CLASSNAME_STRING_STATUS ) )
        return _EnumAndIndicateStatus( CLASS_STATUS, pCtx, pResponseHandler );
    else if ( 0 == lstrcmp( bstrClass, CLASSNAME_STRING_DC ) )
        return _EnumAndIndicateDC( pCtx, pResponseHandler );
    return WBEM_E_INVALID_OBJECT_PATH;

}

HRESULT CProvider::_EnumAndIndicateStatus(
        IN ProviderClass provclass, // BUGBUG don't need this parameter
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomaininfo = NULL;
    HANDLE hDS = NULL;
    bool fImpersonating = false;

    do
    {
        hr = CoImpersonateClient();
        BREAK_ON_FAIL;
        fImpersonating = true;

        // Check whether this is a DC
        hr = HRESULT_FROM_WIN32(DsRoleGetPrimaryDomainInformation(
            NULL,                           // lpServer = local machine
            DsRolePrimaryDomainInfoBasic,   // InfoLevel
            (PBYTE*)&pdomaininfo            // pBuffer
            ));
        BREAK_ON_FAIL;
        ASSERT( NULL != pdomaininfo );
        bool fIsDC = true;
        switch (pdomaininfo->MachineRole)
        {
        case DsRole_RoleBackupDomainController:
        case DsRole_RolePrimaryDomainController:
            break;
        default:
            fIsDC = false;
            break;
        }
        if ( !fIsDC )
        {
            // this is not a DC, return no connections
            break;
        }

        TCHAR achComputerName[MAX_PATH];
        DWORD dwSize = sizeof(achComputerName)/sizeof(TCHAR);
        if ( !GetComputerNameEx(
            ComputerNameDnsFullyQualified,
            achComputerName,
            &dwSize ))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
        BREAK_ON_FAIL;

        hr = HRESULT_FROM_WIN32(DsBind(
            achComputerName, // DomainControllerName
            NULL,            // DnsDomainName
            &hDS             // phDS
            ));
        // RPC_S_UUID_NO_ADDRESS means this is not a DC
        BREAK_ON_FAIL;
        ASSERT( NULL != hDS );

        switch (provclass)
        {
        case CLASS_DC:
            ASSERT(false);
            break;
        case CLASS_STATUS:
            hr = _EnumAndIndicateWorker( provclass,
                                         hDS,
                                         pCtx,
                                         pResponseHandler,
                                         bstrFilterValue );
            break;
        default:
            ASSERT(false);
        }

    } while (false);

    if (fImpersonating)
    {
        // CODEWORK do we want to keep impersonating and reverting?
        HRESULT hr2 = CoRevertToSelf();
        ASSERT( !FAILED(hr2) );
    }

    if (NULL != hDS)
    {
        (void) DsUnBind( &hDS );
    }
    if (NULL != pdomaininfo)
    {
        DsRoleFreeMemory( pdomaininfo );
    }

    return hr;
}

/*
HRESULT CProvider::_EnumAndIndicateDCWorker(
        IN HANDLE hDS,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DS_DOMAIN_TRUSTS* ptrusts = NULL;
    ULONG ctrusts = 0;

    do
    {
        hr = HRESULT_FROM_WIN32(DsEnumerateDomainTrustsW(
            NULL,                       // ServerName
            DS_DOMAIN_IN_FOREST,        // Flags,
            &ptrusts,                   // Domains,
            &ctrusts                    // DomainCount
            ));

        BREAK_ON_FAIL;
        if (0 == ctrusts)
            break;
        if ( BAD_IN_MULTISTRUCT_PTR(ptrusts,ctrusts) )
        {
            ASSERT(false);
            break;
        }

        for (ULONG i = 0; i < ctrusts; i++)
        {
            if ( BAD_IN_STRING_PTR(ptrusts[i].DnsDomainName) )
            {
                // skip this one
                break;
            }
            hr = _EnumAndIndicateWorker( CLASS_DC,
                                         hDS,
                                         pCtx,
                                         pResponseHandler,
                                         bstrFilterValue,
                                         ptrusts[i].DnsDomainName );
            BREAK_ON_FAIL;
        }

    } while (false);

    if ( NULL != ptrusts )
    {
        (void) NetApiBufferFree( ptrusts );
    }

    return hr;
}
*/

HRESULT CProvider::_EnumAndIndicateWorker(
        IN ProviderClass provclass, // BUGBUG parameter not needed
        IN HANDLE hDS,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue,
        IN const BSTR bstrDnsDomainName )
{
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(bstrFilterValue);
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(bstrDnsDomainName);

    HRESULT hr = WBEM_S_NO_ERROR;
    DS_REPL_NEIGHBORS* pneighborsstruct = NULL;
    DS_DOMAIN_CONTROLLER_INFO_1 * pDCs = NULL; // BUGBUG not needed
    ULONG cDCs = 0;
    DWORD cIndicateItems = 0;
    IWbemClassObject** paIndicateItems = NULL;

    do
    {
        switch (provclass)
        {
        case CLASS_STATUS:
            hr = _BuildListStatus( hDS, &pneighborsstruct );
            break;
        /*
        case CLASS_DC:
            hr = _BuildListDC( hDS, bstrDnsDomainName, &pDCs, &cDCs );
            break;
        */
        default:
            ASSERT(false);
            break;
        }
        BREAK_ON_FAIL;

        switch (provclass)
        {
        case CLASS_STATUS:
            hr = _BuildIndicateArrayStatus( pneighborsstruct,
                                            bstrFilterValue,
                                            &paIndicateItems,
                                            &cIndicateItems );
            break;
        /*
        case CLASS_DC:
            hr = _BuildIndicateArrayDC( pDCs,
                                        cDCs,
                                        bstrFilterValue,
                                        &paIndicateItems,
                                        &cIndicateItems );
            break;
        */
        default:
            ASSERT(false);
            break;
        }

        //
        // Send the objects to the caller
        //
        // [In] param, no need to addref.
        if (cIndicateItems > 0)
        {
            hr = pResponseHandler->Indicate( cIndicateItems, paIndicateItems );
            BREAK_ON_FAIL;
        }

        // Let CIMOM know you are finished
        // return value and SetStatus param should be consistent, so ignore
        // the return value from SetStatus itself (in retail builds)
        HRESULT hr2 = pResponseHandler->SetStatus( WBEM_STATUS_COMPLETE, hr,
                                                   NULL, NULL );
        ASSERT( !FAILED(hr2) );

    } while (false);

    _ReleaseIndicateArray( paIndicateItems, cIndicateItems );

    if ( NULL != pneighborsstruct )
    {
        (void) DsReplicaFreeInfo( DS_REPL_INFO_NEIGHBORS, pneighborsstruct );
    }
    if ( NULL != pDCs )
    {
        (void) NetApiBufferFree( pDCs );
    }

    return hr;
}

/*
// does not validate resultant structs coming from API
HRESULT CProvider::_BuildConnectionList(
    IN ProviderClass provclass,
    OUT void** ppitems )
{
    WBEM_VALIDATE_OUT_PTRPTR( ppitems );

    HRESULT hr = WBEM_S_NO_ERROR;
    bool fImpersonating = false;

    do {

        hr = CoImpersonateClient();
        BREAK_ON_FAIL;
        fImpersonating = true;

        switch (provclass)
        {
        case CLASS_STATUS:
            hr = _BuildListStatus( ppitems );
            break;
        case CLASS_DC:
            hr = _BuildListDC( ppitems );
            break;
        default:
            ASSERT(false);
            break;
        }

    } while (false);

    if (fImpersonating)
    {
        HRESULT hr2 = CoRevertToSelf();
        ASSERT( !FAILED(hr2) );
    }

    return hr;
}
*/

// does not validate resultant structs coming from API
HRESULT CProvider::_BuildListStatus(
    IN HANDLE hDS,
    OUT DS_REPL_NEIGHBORS** ppneighborsstruct )
{
    WBEM_VALIDATE_OUT_STRUCT_PTR(ppneighborsstruct);

    HRESULT hr = WBEM_S_NO_ERROR;

    do {
        hr = HRESULT_FROM_WIN32(DsReplicaGetInfo(
            hDS,                        // hDS
            DS_REPL_INFO_NEIGHBORS,     // InfoType
            NULL,                       // pszObject
            NULL,                       // puuidForSourceDsaObjGuid,
            (void**)ppneighborsstruct   // ppinfo
            ));
        BREAK_ON_FAIL;

        if ( BAD_IN_STRUCT_PTR(*ppneighborsstruct) )
        {
            ASSERT(false);
            break;
        }

    } while (false);

    return hr;
}

HRESULT CProvider::_EnumAndIndicateDC(
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue
        )
{
    WBEM_VALIDATE_INTF_PTR( pCtx );
    WBEM_VALIDATE_INTF_PTR( pResponseHandler );
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL( bstrFilterValue );

    HRESULT hr = WBEM_S_NO_ERROR;

    CComPtr<IADs> spIADsRootDSE;
    CComVariant svarSchema;
    CComPtr<IADsPathname> spIADsPathname;
    CComPtr<IDirectorySearch> spIADsSearch;
    CComPtr<IADsPathname> spPathCracker;

    do {

        //
        // Enumerate all nTDSDSA objects
        //

    	hr = ADsOpenObject( L"LDAP://RootDSE",
                            NULL, NULL, ADS_SECURE_AUTHENTICATION,
		                    IID_IADs, OUT (void **)&spIADsRootDSE);
        BREAK_ON_FAIL;

        hr = spIADsRootDSE->Get(L"configurationNamingContext", &svarSchema);
        BREAK_ON_FAIL;
        ASSERT( VT_BSTR == svarSchema.vt );

        hr = spIADsPathname.CoCreateInstance( CLSID_Pathname );
        BREAK_ON_FAIL;
        ASSERT( !!spIADsPathname );

        CComBSTR sbstr = L"LDAP://CN=Sites,";
        sbstr += svarSchema.bstrVal;

    	hr = ADsOpenObject( sbstr,
                            NULL, NULL, ADS_SECURE_AUTHENTICATION,
		                    IID_IDirectorySearch, (void **)&spIADsSearch);
        BREAK_ON_FAIL;

        ADS_SEARCHPREF_INFO aSearchPref[4];
        aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
        aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
        aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
        aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPref[1].vValue.Integer = 50;
        aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
        aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
        aSearchPref[2].vValue.Integer = FALSE;
        aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPref[3].vValue.Integer = ADS_SCOPE_SUBTREE;

        hr = spIADsSearch->SetSearchPreference (aSearchPref, 4);
        BREAK_ON_FAIL;

        CComBSTR sbstr1 = L"objectGUID";
        CComBSTR sbstr2 = L"distinguishedName";
        LPWSTR apAttributeNames[2] = {sbstr1,sbstr2};
        ADS_SEARCH_HANDLE hSearch = NULL;
        hr = spIADsSearch->ExecuteSearch( L"(objectclass=nTDSDSA)",
                                          apAttributeNames, // CODEWORK must use BSTRs?
                                          2,
                                          &hSearch );
        BREAK_ON_FAIL;

        //
        // Prepare a path cracker object
        //
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (PVOID *)&spPathCracker);
        BREAK_ON_FAIL;
        ASSERT( !!spPathCracker );
        hr = spPathCracker->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
        BREAK_ON_FAIL;

        while ( S_OK == (hr = spIADsSearch->GetNextRow ( hSearch )) )
        {
            CComPtr<IWbemClassObject> spIndicateItem;
            hr = m_sipClassDefDC->SpawnInstance( 0, &spIndicateItem );
            BREAK_ON_FAIL;
            IWbemClassObject* pIndicateItem = spIndicateItem;
            ASSERT( NULL != pIndicateItem );

            hr = _PutAttributesDC( pIndicateItem,
                                   spPathCracker,
                                   bstrFilterValue,
                                   spIADsSearch,
                                   hSearch );
            if (S_FALSE == hr)
                continue;
            BREAK_ON_FAIL;

            //
            // Send the object to the caller
            //
            // [In] param, no need to addref.

            // ATL asserts on CComPtr<>::operator& if contents not NULL
            hr = pResponseHandler->Indicate( 1, &pIndicateItem );
            BREAK_ON_FAIL;

            // Let CIMOM know you are finished
            // return value and SetStatus param should be consistent,
            // so ignore the return value from SetStatus itself
            // (in retail builds)
            HRESULT hr2 = pResponseHandler->SetStatus(
                    WBEM_STATUS_COMPLETE, hr, NULL, NULL );
            ASSERT( !FAILED(hr2) );
        }

    } while (false);

    return hr;
}

/*
HRESULT CProvider::_BuildListDC(
    IN HANDLE hDS,
    IN const BSTR bstrDnsDomainName,
    OUT DS_DOMAIN_CONTROLLER_INFO_1** ppDCs,
    OUT ULONG* pcDCs )
{
    WBEM_VALIDATE_OUT_STRUCT_PTR(ppDCs);
    WBEM_VALIDATE_OUT_STRUCT_PTR(pcDCs);

    HRESULT hr = WBEM_S_NO_ERROR;

    do {
        hr = HRESULT_FROM_WIN32(DsGetDomainControllerInfo(
            hDS,                        // hDS
            bstrDnsDomainName,          // DomainName
            1,                          // InfoLevel
            pcDCs,                      // pcOut,
            (void**)ppDCs               // ppInfo
            ));
        BREAK_ON_FAIL;

        if ( BAD_IN_MULTISTRUCT_PTR(*ppDCs,*pcDCs) )
        {
            ASSERT(false);
            break;
        }

    } while (false);

    return hr;
}
*/

HRESULT _PutUUIDAttribute(
    IWbemClassObject* ipNewInst,
    LPCTSTR           pcszAttributeName,
    UUID&             refuuid)
{
    CComVariant svar;
    OLECHAR ach[MAX_PATH];
    ::ZeroMemory( ach, sizeof(ach) );
    if ( 0 >= StringFromGUID2( refuuid, ach, MAX_PATH ) )
    {
        ASSERT(false);
    }
    svar = ach;
    return ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
}


HRESULT _PutLONGLONGAttribute(
    IWbemClassObject* ipNewInst,
    LPCTSTR           pcszAttributeName,
    LONGLONG          longlong)
{
    CComVariant svar;
    OLECHAR ach[MAX_PATH];
    ::ZeroMemory( ach, sizeof(ach) );
    _ui64tot( longlong, ach, 10 );
    svar = ach;
    return ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
}


HRESULT _PutFILETIMEAttribute(
    IWbemClassObject* ipNewInst,
    LPCTSTR           pcszAttributeName,
    FILETIME&         reffiletime)
{
    SYSTEMTIME systime;
    ::ZeroMemory( &systime, sizeof(SYSTEMTIME) );
    if ( !FileTimeToSystemTime( &reffiletime, &systime ) )
    {
        ASSERT(false);
        return HRESULT_FROM_WIN32(::GetLastError());
    }
    CComVariant svar;
    OLECHAR ach[MAX_PATH];
    ::ZeroMemory( ach, sizeof(ach) );
    swprintf( ach, L"%04u%02u%02u%02u%02u%02u.%06u+000", 
        systime.wYear,
        systime.wMonth,
        systime.wDay,
        systime.wHour,
        systime.wMinute,
        systime.wSecond,
        systime.wMilliseconds
        );
    svar = ach;
    return ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
}


HRESULT _PutBooleanAttributes(
    IWbemClassObject* ipNewInst,
    UINT              cNumAttributes,
    LPCTSTR*          aAttributeNames,
    DWORD*            aBitmasks,
    DWORD             dwValue)
{
    WBEM_VALIDATE_READ_PTR( aAttributeNames, cNumAttributes*sizeof(LPCTSTR) );
    WBEM_VALIDATE_READ_PTR( aBitmasks,       cNumAttributes*sizeof(DWORD) );

    HRESULT hr = WBEM_S_NO_ERROR; 
    CComVariant svar = true;
    for (UINT i = 0; i < cNumAttributes; i++)
    {
        WBEM_VALIDATE_IN_STRING_PTR( aAttributeNames[i] );
        if (dwValue & aBitmasks[i])
        {
            hr = ipNewInst->Put( aAttributeNames[i], 0, &svar, 0 );
            BREAK_ON_FAIL;
        }
    }
    return hr;
}


HRESULT _ExtractDomainName(
    LPCTSTR pszNamingContext,
    BSTR*   pbstrDomainName )
{
    WBEM_VALIDATE_IN_STRING_PTR( pszNamingContext );
    WBEM_VALIDATE_OUT_PTRPTR( pbstrDomainName );

    PDS_NAME_RESULTW pDsNameResult = NULL;
    HRESULT hr = WBEM_S_NO_ERROR;

    do {
        DWORD dwErr = DsCrackNamesW(
                (HANDLE)-1,
                DS_NAME_FLAG_SYNTACTICAL_ONLY,
                DS_FQDN_1779_NAME,
                DS_CANONICAL_NAME,
                1,
                &pszNamingContext,
                &pDsNameResult);
        if (NO_ERROR != dwErr)
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            ASSERT(false);
            break;
        }
        if (   BAD_IN_STRUCT_PTR(pDsNameResult)
            || 1 != pDsNameResult->cItems
            || DS_NAME_NO_ERROR != pDsNameResult->rItems->status
            || BAD_IN_STRUCT_PTR(pDsNameResult->rItems)
            || BAD_IN_STRING_PTR(pDsNameResult->rItems->pDomain)
           )
        {
            hr = E_FAIL;
            ASSERT(false);
            break;
        }

        *pbstrDomainName = ::SysAllocString(pDsNameResult->rItems->pDomain);
        if (NULL == *pbstrDomainName)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }

    } while (false);

    if (pDsNameResult)
    {
        DsFreeNameResultW(pDsNameResult);
    }

    return hr;
}


// if this returns S_FALSE, skip this connection but do not consider this an error
HRESULT CProvider::_PutAttributesStatus(
    IWbemClassObject**  pipNewInst,
    const BSTR          bstrFilterValue,
    DS_REPL_NEIGHBOR*   pneighbor)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (   BAD_IN_STRING_PTR(pneighbor->pszNamingContext)
        || BAD_IN_STRING_PTR(pneighbor->pszSourceDsaDN)
        || BAD_IN_STRING_PTR_OPTIONAL(pneighbor->pszSourceDsaAddress)
        || BAD_IN_STRING_PTR_OPTIONAL(pneighbor->pszAsyncIntersiteTransportDN)
       )
    {
        ASSERT(false);
        return S_FALSE;
    }

    CComPtr<IADsPathname> spPathCracker;
    CComBSTR sbstrReplicatedDomain, // DNS name of replicated domain
             sbstrSourceServer,     // CN= name of source server
             sbstrSourceSite,       // name of site containing source server
             sbstrCompositeName;    // composite name for WMI

    do {
        hr = _ExtractDomainName( pneighbor->pszNamingContext, &sbstrReplicatedDomain );
        BREAK_ON_FAIL;

        boolean bIsConfigNC = (0 == wcsnicmp(pneighbor->pszNamingContext,
                                             L"CN=Configuration,",
                                             17));
        boolean bIsSchemaNC = (0 == wcsnicmp(pneighbor->pszNamingContext,
                                             L"CN=Schema,",
                                             10));
        boolean bIsDeleted = (NULL != wcsstr(pneighbor->pszSourceDsaAddress, L"\nDEL:"));

        // retrieve source server name and site name
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (PVOID *)&spPathCracker);
        BREAK_ON_FAIL;
        ASSERT( !!spPathCracker );
        hr = spPathCracker->Set( pneighbor->pszSourceDsaDN, ADS_SETTYPE_DN );
        BREAK_ON_FAIL;
        hr = spPathCracker->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
        BREAK_ON_FAIL;
        hr = spPathCracker->GetElement( 1L, &sbstrSourceServer );
        BREAK_ON_FAIL;
        hr = spPathCracker->GetElement( 3L, &sbstrSourceSite );
        BREAK_ON_FAIL;

        // Build the composite name
        sbstrCompositeName = sbstrSourceSite;
        sbstrCompositeName += L"\\";
        sbstrCompositeName += sbstrSourceServer;
        sbstrCompositeName += L";";
        sbstrCompositeName += sbstrReplicatedDomain;
        if (bIsConfigNC)
            sbstrCompositeName += L",Configuration";
        else if (bIsSchemaNC)
            sbstrCompositeName += L",Schema";
        else
            sbstrCompositeName += L",Domain";

        // Test the composite name against the filter
        if (   NULL != bstrFilterValue
            && !lstrcmpi(sbstrCompositeName, bstrFilterValue)
        )
        {
            hr = S_FALSE;
            break;
        }

        //
        // Create a new instance of the data object
        //
        hr = m_sipClassDefStatus->SpawnInstance( 0, pipNewInst );
        BREAK_ON_FAIL;
        IWbemClassObject* ipNewInst = *pipNewInst;
        if (NULL == ipNewInst)
        {
            ASSERT(false);
            hr = S_FALSE;
            break;
        }

        CComVariant svar;

        svar = sbstrCompositeName;
        hr = ipNewInst->Put( L"CompositeName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszNamingContext;
        hr = ipNewInst->Put( L"NamingContext", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszSourceDsaDN;
        hr = ipNewInst->Put( L"SourceDsaDN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszSourceDsaAddress;
        hr = ipNewInst->Put( L"SourceDsaAddress", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszAsyncIntersiteTransportDN;
        hr = ipNewInst->Put( L"AsyncIntersiteTransportDN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)pneighbor->dwReplicaFlags;
        hr = ipNewInst->Put( L"ReplicaFlags", 0, &svar, 0 );
        BREAK_ON_FAIL;

        if (bIsConfigNC)
        {
            svar = TRUE;
            hr = ipNewInst->Put( L"IsConfigurationNamingContext", 0, &svar, 0 );
            BREAK_ON_FAIL;
        }

        if (bIsSchemaNC)
        {
            svar = TRUE;
            hr = ipNewInst->Put( L"IsSchemaNamingContext", 0, &svar, 0 );
            BREAK_ON_FAIL;
        }

        if (bIsDeleted)
        {
            svar = TRUE;
            hr = ipNewInst->Put( L"IsDeletedSourceDsa", 0, &svar, 0 );
            BREAK_ON_FAIL;
        }
        svar = sbstrSourceSite;
        hr = ipNewInst->Put( L"SourceDsaSite", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrSourceServer;
        hr = ipNewInst->Put( L"SourceDsaCN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrReplicatedDomain;
        hr = ipNewInst->Put( L"Domain", 0, &svar, 0 );
        BREAK_ON_FAIL;

LPCTSTR aBooleanAttrNames[12] = {
    TEXT("Writeable"),
    TEXT("SyncOnStartup"),
    TEXT("DoScheduledSyncs"),
    TEXT("UseAsyncIntersiteTransport"),
    TEXT("TwoWaySync"),
    TEXT("FullSyncInProgress"),
    TEXT("FullSyncNextPacket"),
    TEXT("NeverSynced"),
    TEXT("IgnoreChangeNotifications"),
    TEXT("DisableScheduledSync"),
    TEXT("CompressChanges"),
    TEXT("NoChangeNotifications")
};

DWORD aBitmasks[12] = {
    DS_REPL_NBR_WRITEABLE,
    DS_REPL_NBR_SYNC_ON_STARTUP,
    DS_REPL_NBR_DO_SCHEDULED_SYNCS,
    DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT,
    DS_REPL_NBR_TWO_WAY_SYNC,
    DS_REPL_NBR_FULL_SYNC_IN_PROGRESS,
    DS_REPL_NBR_FULL_SYNC_NEXT_PACKET,
    DS_REPL_NBR_NEVER_SYNCED,
    DS_REPL_NBR_IGNORE_CHANGE_NOTIFICATIONS,
    DS_REPL_NBR_DISABLE_SCHEDULED_SYNC,
    DS_REPL_NBR_COMPRESS_CHANGES,
    DS_REPL_NBR_NO_CHANGE_NOTIFICATIONS
};

        hr = _PutBooleanAttributes( ipNewInst,
                                    12,
                                    aBooleanAttrNames,
                                    aBitmasks,
                                    pneighbor->dwReplicaFlags );
        BREAK_ON_FAIL;

        hr = _PutUUIDAttribute( ipNewInst,
                                L"NamingContextObjGuid",
                                pneighbor->uuidNamingContextObjGuid );
        BREAK_ON_FAIL;

        hr = _PutUUIDAttribute( ipNewInst,
                                L"SourceDsaObjGuid",
                                pneighbor->uuidSourceDsaObjGuid );
        BREAK_ON_FAIL;

        hr = _PutUUIDAttribute( ipNewInst,
                                L"SourceDsaInvocationID",
                                pneighbor->uuidSourceDsaInvocationID );
        BREAK_ON_FAIL;

        hr = _PutUUIDAttribute( ipNewInst,
                                L"AsyncIntersiteTransportObjGuid",
                                pneighbor->uuidAsyncIntersiteTransportObjGuid );
        BREAK_ON_FAIL;

        hr = _PutLONGLONGAttribute( ipNewInst,
                                    L"LastObjChangeSynced",
                                    pneighbor->usnLastObjChangeSynced);
        BREAK_ON_FAIL;

        hr = _PutLONGLONGAttribute( ipNewInst,
                                    L"AttributeFilter",
                                    pneighbor->usnAttributeFilter);
        BREAK_ON_FAIL;

        hr = _PutFILETIMEAttribute( ipNewInst,
                                    L"LastSyncSuccess",
                                    pneighbor->ftimeLastSyncSuccess);
        BREAK_ON_FAIL;

        hr = _PutFILETIMEAttribute( ipNewInst,
                                    L"LastSyncAttempt",
                                    pneighbor->ftimeLastSyncAttempt);
        BREAK_ON_FAIL;

        svar = (long)pneighbor->dwLastSyncResult;
        hr = ipNewInst->Put( L"LastSyncResult", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)pneighbor->cNumConsecutiveSyncFailures;
        hr = ipNewInst->Put( L"NumConsecutiveSyncFailures", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)((bIsDeleted) ? 0L : pneighbor->cNumConsecutiveSyncFailures);
        hr = ipNewInst->Put( L"ModifiedNumConsecutiveSyncFailures", 0, &svar, 0 );
        BREAK_ON_FAIL;

    } while (false);

    return hr;
}

// if this returns S_FALSE, skip this connection but do not consider this an error
// note, this version does not create or release the instance
HRESULT CProvider::_PutAttributesDC(
        IN IWbemClassObject*    pIndicateItem,
        IN IADsPathname*        pPathCracker,
        IN const BSTR           bstrFilterValue,
        IN IDirectorySearch*    pIADsSearch,
        IN ADS_SEARCH_HANDLE    hSearch)
{
    WBEM_VALIDATE_INTF_PTR( pIndicateItem );
    WBEM_VALIDATE_INTF_PTR( pPathCracker );

    HRESULT hr = WBEM_S_NO_ERROR;
    ADS_SEARCH_COLUMN adscolDN, adscolGUID;
    boolean fFreeColumnDN = false, fFreeColumnGUID = false;
    CComVariant svar;
    CComBSTR sbstrServerCN, sbstrSite;

    do {
        hr = pIADsSearch->GetColumn( hSearch, L"distinguishedName", &adscolDN );
        BREAK_ON_FAIL;
        fFreeColumnDN = true;
        if (   ADSTYPE_DN_STRING != adscolDN.dwADsType
            || 1 != adscolDN.dwNumValues
            || BAD_IN_STRUCT_PTR(adscolDN.pADsValues)
            || BAD_IN_STRING_PTR(adscolDN.pADsValues[0].DNString)
           )
        {
            // skip this one
            hr = S_FALSE;
            break;
        }

        hr = pIADsSearch->GetColumn( hSearch, L"objectGUID", &adscolGUID );
        BREAK_ON_FAIL;
        fFreeColumnGUID = true;
        if (   ADSTYPE_OCTET_STRING != adscolGUID.dwADsType
            || 1 != adscolGUID.dwNumValues
            || BAD_IN_STRUCT_PTR(adscolGUID.pADsValues)
            || 0 == adscolGUID.pADsValues[0].OctetString.dwLength
            || BAD_IN_READ_PTR(adscolGUID.pADsValues[0].OctetString.lpValue,
                               adscolGUID.pADsValues[0].OctetString.dwLength)
           )
        {
            // skip this one
            hr = S_FALSE;
            break;
        }

        hr = pPathCracker->Set( adscolDN.pADsValues[0].DNString, ADS_SETTYPE_DN );
        BREAK_ON_FAIL;
        hr = pPathCracker->GetElement( 1L, &sbstrServerCN );
        BREAK_ON_FAIL;
        hr = pPathCracker->GetElement( 3L, &sbstrSite );
        BREAK_ON_FAIL;

        // Test the site name against the filter
        if (   NULL != bstrFilterValue
            && !lstrcmpi(sbstrSite, bstrFilterValue)
        )
        {
            hr = S_FALSE;
            break;
        }

        svar = adscolDN.pADsValues[0].DNString;
        hr = pIndicateItem->Put( L"DistinguishedName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrServerCN;
        hr = pIndicateItem->Put( L"CommonName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrSite;
        hr = pIndicateItem->Put( L"SiteName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        hr = _PutUUIDAttribute( pIndicateItem,
                                L"ObjectGUID",
                                (GUID&)adscolGUID.pADsValues[0].OctetString.lpValue );
        BREAK_ON_FAIL;

    } while (false);

    if (fFreeColumnDN)
    {
        HRESULT hr2 = pIADsSearch->FreeColumn( &adscolDN );
        ASSERT( SUCCEEDED(hr2) );
    }
    if (fFreeColumnGUID)
    {
        HRESULT hr2 = pIADsSearch->FreeColumn( &adscolGUID );
        ASSERT( SUCCEEDED(hr2) );
    }

    return hr;
}

HRESULT CProvider::_BuildIndicateArrayStatus(
    IN  DS_REPL_NEIGHBORS*  pneighborstruct,
    IN  const BSTR          bstrFilterValue,
    OUT IWbemClassObject*** ppaIndicateItems,
    OUT DWORD*              pcIndicateItems)
{
    WBEM_VALIDATE_IN_STRUCT_PTR( pneighborstruct );
    WBEM_VALIDATE_IN_MULTISTRUCT_PTR( pneighborstruct->rgNeighbor,
                                      pneighborstruct->cNumNeighbors );
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL( bstrFilterValue );
    WBEM_VALIDATE_OUT_PTRPTR( ppaIndicateItems );
    WBEM_VALIDATE_OUT_STRUCT_PTR( pcIndicateItems );

    HRESULT hr = WBEM_S_NO_ERROR;
    DS_REPL_NEIGHBOR* pneighbors = pneighborstruct->rgNeighbor;
    DWORD cneighbors = pneighborstruct->cNumNeighbors;
    if (0 == cneighbors)
        return WBEM_S_NO_ERROR;

    IWbemClassObject** paIndicateItems = NULL;
    DWORD cIndicateItems = 0;

    *ppaIndicateItems = NULL;
    *pcIndicateItems = 0;

    do
    {
        paIndicateItems = new IWbemClassObject*[cneighbors];
        if (NULL == paIndicateItems)
        {
            ASSERT(false);
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }
        ::ZeroMemory( paIndicateItems, cneighbors * sizeof(IWbemClassObject*) );
        for (DWORD i = 0; i < cneighbors; i++)
        {
            DS_REPL_NEIGHBOR* pneighbor = &(pneighbors[i]);

            hr = _PutAttributesStatus( &paIndicateItems[cIndicateItems],
                                       bstrFilterValue,
                                       pneighbor );
            if (S_FALSE == hr)
                continue;
            cIndicateItems++;
            BREAK_ON_FAIL;
        }

    } while (false);

    if (!FAILED(hr))
    {
        *ppaIndicateItems = paIndicateItems;
        *pcIndicateItems  = cIndicateItems;
    }
    else
    {
        _ReleaseIndicateArray( paIndicateItems, cneighbors );
    }

    return hr;
}

/*
HRESULT CProvider::_BuildIndicateArrayDC(
        IN  DS_DOMAIN_CONTROLLER_INFO_1* pDCs,
        IN  ULONG                        cDCs,
        IN  const BSTR                   bstrFilterValue,
        OUT IWbemClassObject***          ppaIndicateItems,
        OUT DWORD*                       pcIndicateItems)
{
    WBEM_VALIDATE_IN_MULTISTRUCT_PTR( pDCs, cDCs );
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL( bstrFilterValue );
    WBEM_VALIDATE_OUT_PTRPTR( ppaIndicateItems );
    WBEM_VALIDATE_OUT_STRUCT_PTR( pcIndicateItems );

    HRESULT hr = WBEM_S_NO_ERROR;
    if (0 == cDCs)
        return WBEM_S_NO_ERROR;

    IWbemClassObject** paIndicateItems = NULL;
    DWORD cIndicateItems = 0;

    *ppaIndicateItems = NULL;
    *pcIndicateItems = 0;

    do
    {
        paIndicateItems = new IWbemClassObject*[cDCs];
        if (NULL == paIndicateItems)
        {
            ASSERT(false);
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }
        ::ZeroMemory( paIndicateItems, cDCs * sizeof(IWbemClassObject*) );
        for (DWORD i = 0; i < cDCs; i++)
        {
            DS_DOMAIN_CONTROLLER_INFO_1* pDC = &(pDCs[i]);

            hr = _PutAttributesDC( &paIndicateItems[cIndicateItems],
                                   bstrFilterValue,
                                   pDC );
            if (S_FALSE == hr)
                continue;
            cIndicateItems++;
            BREAK_ON_FAIL;
            }

    } while (false);

    if (!FAILED(hr))
    {
        *ppaIndicateItems = paIndicateItems;
        *pcIndicateItems  = cIndicateItems;
    }
    else
    {
        _ReleaseIndicateArray( paIndicateItems, cDCs );
    }

    return hr;
}
*/

void CProvider::_ReleaseIndicateArray(
    IWbemClassObject**  paIndicateItems,
    DWORD               cIndicateItems,
    bool                fReleaseArray)
{
    if (paIndicateItems != NULL)
    {
        for (DWORD i = 0; i < cIndicateItems; i++)
        {
            if (NULL != paIndicateItems[i])
                paIndicateItems[i]->Release();
        }
        if (fReleaseArray)
        {
            delete[] paIndicateItems;
        }
        else
        {
            ::ZeroMemory( *paIndicateItems,
                          cIndicateItems * sizeof(IWbemClassObject*) );

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\common\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_ADMINPRV_TRACE)
  #if defined(TRACE)
    #undef TRACE
    void __cdecl DSATrace(LPCWSTR, ...);
    #define TRACE DSATrace
  #endif // defined(TRACE)
#endif // defined(_USE_ADMINPRV_TRACE)

#if defined(_USE_ADMINPRV_ASSERT)
#undef ASSERT
#undef VERIFY
#undef THIS_FILE
#define THIS_FILE          __FILE__
BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
#define ASSERT(f) \
    if (!(f) && DSAAssertFailedLine(THIS_FILE, __LINE__)) { ::DebugBreak(); }

#define VERIFY(f)          ASSERT(f)

#endif // _USE_ADMINPRV_ASSERT

#if defined (_USE_ADMINPRV_TIMER)

void __cdecl DSATimer(LPCWSTR, ...);
#define TIMER DSATimer

#else

#define TIMER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\common\dbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       dbg.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_ADMINPRV_TRACE) || defined(_USE_ADMINPRV_ASSERT) || defined(_USE_ADMINPRV_TIMER)

UINT GetInfoFromIniFile(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
    static LPCWSTR lpszFile = L"\\system32\\" ADMINPRV_COMPNAME L".ini";

    WCHAR szFilePath[2*MAX_PATH];
    UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
    if (nLen == 0)
        return nDefault;

    wcscat(szFilePath, lpszFile);
    return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif


#if defined(_USE_ADMINPRV_TRACE)

#ifdef DEBUG_DSA
DWORD g_dwTrace = 0x1;
#else
DWORD g_dwTrace = ::GetInfoFromIniFile(L"Debug", L"Trace");
#endif

void __cdecl DSATrace(LPCTSTR lpszFormat, ...)
{
    if (g_dwTrace == 0)
        return;

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    WCHAR szBuffer[512];

    nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

    // was there an error? was the expanded string too long?
    ASSERT(nBuf >= 0);
    ::OutputDebugString(szBuffer);

    va_end(args);
}

#endif // defined(_USE_ADMINPRV_TRACE)

#if defined(_USE_ADMINPRV_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Debug", L"Assert");

BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
    if (g_dwAssert == 0)
        return FALSE;

    WCHAR szMessage[_MAX_PATH*2];

    // assume the debugger or auxiliary port
    wsprintf(szMessage, _T("Assertion Failed: File %hs, Line %d\n"),
             lpszFileName, nLine);
    OutputDebugString(szMessage);

    // JonN 6/28/00 Do not MessageBox here, this is a WMI provider.
    //              Return TRUE to always DebugBreak().

    return TRUE;

}
#endif // _USE_ADMINPRV_ASSERT

#if defined(_USE_ADMINPRV_TIMER)

#ifdef TIMER_DSA
DWORD g_dwTimer = 0x1;
#else
DWORD g_dwTimer = ::GetInfoFromIniFile(L"Debug", L"Timer");
#endif

DWORD StartTicks = ::GetTickCount();
DWORD LastTicks = 0;

void __cdecl DSATimer(LPCTSTR lpszFormat, ...)
{
    if (g_dwTimer == 0)
        return;

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    WCHAR szBuffer[512], szBuffer2[512];

    DWORD CurrentTicks = GetTickCount() - StartTicks;
    DWORD Interval = CurrentTicks - LastTicks;
    LastTicks = CurrentTicks;

    nBuf = swprintf(szBuffer2,
                    L"%d, (%d): %ws", CurrentTicks,
                    Interval, lpszFormat);
    nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), 
                       szBuffer2, 
                       args);

    // was there an error? was the expanded string too long?
    ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

    va_end(args);
}
#endif // _USE_ADMINPRV_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trustmon.rc
//
#define IDS_PROJNAME                    100
#define IDS_TRUSTPRV_DESC               101
#define IDR_TrustPrv                    102
#define IDS_MIT_TRUST_STATUS            103
#define IDS_TRUST_STATUS_OK             104
#define IDS_TRUST_STATUS_FAILED         105
#define IDS_STATUS_INBOUND_ONLY         106
#define IDS_STATUS_NOT_CHECKED          107
#define IDS_STATUS_UNKNOWN              108
#define IDS_PW_VERIFY_NOT_SUPPORTED     109
#define IDS_FIXED_BY_RETARGET           110
#define IDS_STATUS_REDISCOVER           111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\domain.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       domain.cpp
//
//  Contents:   domain class implementation
//
//  Classes:    CDomainInfo
//
//  History:    27-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#include <stdafx.h>

PCWSTR CSTR_PROP_LOCAL_DNS_NAME  = L"DNSname";  // String
PCWSTR CSTR_PROP_LOCAL_FLAT_NAME = L"FlatName"; // String
PCWSTR CSTR_PROP_LOCAL_SID       = L"SID";      // String
PCWSTR CSTR_PROP_LOCAL_TREE_NAME = L"TreeName"; // String
PCWSTR CSTR_PROP_LOCAL_DC_NAME   = L"DCname";   // String
// TODO: string property listing the FSMOs owned by this DC?

//Implementaion of CDomainInfo class

//+----------------------------------------------------------------------------
//
// Class:   CDomainInfo
//
//-----------------------------------------------------------------------------
CDomainInfo::CDomainInfo()
{
   TRACE(L"CDomainInfo::CDomainInfo\n");

   m_liLastEnumed.QuadPart = 0;
}

CDomainInfo::~CDomainInfo()
{
   TRACE(L"CDomainInfo::~CDomainInfo\n");

   Reset();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::Init
//
//  Synopsis:   Initializes the CDomainInfo object.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainInfo::Init(IWbemClassObject * pClassDef)
{
   TRACE(L"CDomainInfo::Init\n");

   NTSTATUS Status = STATUS_SUCCESS;
   OBJECT_ATTRIBUTES objectAttributes;
   CSmartPolicyHandle chPolicy;

   m_sipClassDefLocalDomain = pClassDef;

   InitializeObjectAttributes(&objectAttributes, NULL, 0L, NULL, NULL);

   // Get Local policy
   Status = LsaOpenPolicy(NULL,              // Local server
                          &objectAttributes,
                          MAXIMUM_ALLOWED,   // Needed for Rediscover
                          &chPolicy);

   if (!NT_SUCCESS(Status))
   {
      TRACE(L"LsaOpenPolicy failed with error %d\n", Status);
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
   }

   PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo;

   Status = LsaQueryInformationPolicy(chPolicy,
                                      PolicyDnsDomainInformation,
                                      (PVOID *)&pDnsDomainInfo);

   if (!NT_SUCCESS(Status))
   {
      TRACE(L"LsaQueryInformationPolicy failed with error %d\n", Status);
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
   }

   m_strDomainFlatName = pDnsDomainInfo->Name.Buffer;
   m_strDomainDnsName = pDnsDomainInfo->DnsDomainName.Buffer;
   m_strForestName = pDnsDomainInfo->DnsForestName.Buffer;

   if (!SetSid(pDnsDomainInfo->Sid))
   {
      ASSERT(false);
      LsaFreeMemory(pDnsDomainInfo);
      return E_OUTOFMEMORY;
   }

   LsaFreeMemory(pDnsDomainInfo);

   DWORD dwBufSize = MAX_COMPUTERNAME_LENGTH + 1;

   if (!GetComputerName(m_strDcName.GetBuffer(dwBufSize), &dwBufSize))
   {
      DWORD dwErr = GetLastError();
      TRACE(L"GetComputerName failed with error %d\n", dwErr);
      return HRESULT_FROM_WIN32(dwErr);
   }

   m_strDcName.ReleaseBuffer();

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::Reset
//
//  Synopsis:   Free the contents of the trust array and re-initialize it.
//
//-----------------------------------------------------------------------------
void
CDomainInfo::Reset(void)
{
   TRACE(L"CDomainInfo::Reset\n");

   CTrustInfo * pTrustInfo = NULL;

   if (IsEnumerated())
   {
      // Empty cache 
      for (UINT i = 0; i < m_vectTrustInfo.size(); ++i)
      {
         pTrustInfo = m_vectTrustInfo[i];
         if (pTrustInfo)
            delete pTrustInfo;
      }
      m_vectTrustInfo.clear();
   }
}

//+----------------------------------------------------------------------------
//
//  Method: CDomainInfo::SetSid
//
//-----------------------------------------------------------------------------
BOOL
CDomainInfo::SetSid(PSID pSid)
{
   if (!pSid)
   {
      return TRUE;
   }

#if !defined(NT4_BUILD)
   PWSTR buffer;

   BOOL fRet = ConvertSidToStringSid(pSid, &buffer);

   if (fRet)
   {
      m_strSid = buffer;
      LocalFree(buffer);
   }

   return fRet;
#else
// TODO: Code for NT4 ??
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::EnumerateTrusts
//
//  Synopsis:   List the trusts for this domain.
//
//-----------------------------------------------------------------------------
#if !defined(NT4_BUILD)
HRESULT
CDomainInfo::EnumerateTrusts(void)
{
   TRACE(L"CDomainInfo::EnumerateTrusts\n");

   DWORD dwRet = ERROR_SUCCESS;
   CTrustInfo * pTrustInfo = NULL;
   PDS_DOMAIN_TRUSTS rgTrusts = NULL;
   ULONG nTrustCount = 0;

   Reset();

   dwRet = DsEnumerateDomainTrusts(NULL,
                                   DS_DOMAIN_DIRECT_OUTBOUND |
                                   DS_DOMAIN_DIRECT_INBOUND,
                                   &rgTrusts,
                                   &nTrustCount);

   if (ERROR_SUCCESS != dwRet)
   {
      TRACE(L"DsEnumerateDomainTrusts failed with error %d\n", dwRet);
      return HRESULT_FROM_WIN32(dwRet);
   }

   for (ULONG i = 0; i < nTrustCount; i++) 
   {
      pTrustInfo = new CTrustInfo();
      BREAK_ON_NULL(pTrustInfo);
      if (rgTrusts[i].DnsDomainName)
      {
         // Downlevel domains don't have a DNS name.
         //
         pTrustInfo->SetTrustedDomain(rgTrusts[i].DnsDomainName);
      }
      else
      {
         // So use the flat name instead.
         //
         pTrustInfo->SetTrustedDomain(rgTrusts[i].NetbiosDomainName);
      }
      pTrustInfo->SetFlatName(rgTrusts[i].NetbiosDomainName);
      BREAK_ON_NULL(pTrustInfo->SetSid(rgTrusts[i].DomainSid));
      pTrustInfo->SetTrustType(rgTrusts[i].TrustType);
      pTrustInfo->SetTrustDirectionFromFlags(rgTrusts[i].Flags);
      pTrustInfo->SetTrustAttributes(rgTrusts[i].TrustAttributes);
      pTrustInfo->SetFlags(rgTrusts[i].Flags);

      m_vectTrustInfo.push_back(pTrustInfo);

      pTrustInfo = NULL;
   }

   if (rgTrusts)
   {
      NetApiBufferFree(rgTrusts);
   }

   if (ERROR_SUCCESS == dwRet)
   {
      SYSTEMTIME st;

      GetSystemTime(&st);
      SystemTimeToFileTime(&st, (LPFILETIME)&m_liLastEnumed);
   }

   return HRESULT_FROM_WIN32(dwRet);
}

#else // NT4_BUILD

HRESULT
CDomainInfo::EnumerateTrusts(void)
{
   TRACE(L"CDomainInfo::EnumerateTrusts\n");

   NTSTATUS Status = STATUS_SUCCESS;
   DWORD dwErr = ERROR_SUCCESS;
   ULONG i = 0;
   CTrustInfo * pTrustInfo = NULL;

   Reset();

   LSA_ENUMERATION_HANDLE hEnumContext = NULL;
   ULONG nTrustCount = 0;
   ULONG nTotalCount = 0;
   ULONG j = 0;    
   PLSA_TRUST_INFORMATION pTrustDomainInfo = NULL;
   DWORD hResumeHandle = 0;
   LPUSER_INFO_0 pUserList = NULL;
   CTrustInfo * pTempTrustInfo = NULL;
   LPWSTR Lop = NULL;
   CSmartPolicyHandle chPolicy;
   OBJECT_ATTRIBUTES objectAttributes;

   InitializeObjectAttributes(&objectAttributes, NULL, 0L, NULL, NULL);

   //
   // We'll have to do this the old fashioned way. That means that we'll enumerate all of
   // the trust directly, save them off in a list, and then go through and enumerate all
   // of the interdomain trust accounts and merge those into the list.
   //
   do
   {
      Status = LsaOpenPolicy(NULL,              // Local server
                             &objectAttributes,
                             MAXIMUM_ALLOWED,   // Needed for Rediscover
                             &chPolicy);

      Status = LsaEnumerateTrustedDomains(chPolicy,
                                          &hEnumContext,
                                          (void**)&pTrustDomainInfo,
                                          ULONG_MAX,
                                          &nTrustCount );

      if (NT_SUCCESS(Status) || Status == STATUS_MORE_ENTRIES) 
      {
         dwErr = ERROR_SUCCESS;
         for ( i = 0; i < nTrustCount; i++ ) 
         {
            pTrustInfo = new CTrustInfo();
            CHECK_NULL( pTrustInfo, CLEAN_RETURN );
            pTrustInfo->SetTrustedDomain( pTrustDomainInfo[i].Name.Buffer );
            pTrustInfo->SetFlatName( pTrustDomainInfo[i].Name.Buffer );
            pTrustInfo->SetSid( pTrustDomainInfo[i].Sid );
            pTrustInfo->SetTrustType( TRUST_TYPE_DOWNLEVEL );
            pTrustInfo->SetTrustDirection( TRUST_DIRECTION_OUTBOUND );
            m_vectTrustInfo.push_back( pTrustInfo );
            pTrustInfo = NULL;
         }
         LsaFreeMemory( pTrustDomainInfo );
         pTrustDomainInfo = NULL;
      }       
      else
         dwErr = LsaNtStatusToWinError(Status);      
   } while (Status == STATUS_MORE_ENTRIES);

   if( Status == STATUS_NO_MORE_ENTRIES )
       dwErr = ERROR_SUCCESS;
   //
   // Now, let's add in the user accounts
   //
   if ( dwErr == ERROR_SUCCESS ) 
   {
      do 
      {
         nTrustCount = 0;
         nTotalCount = 0;

         dwErr = NetUserEnum(NULL,
                             0,
                             FILTER_INTERDOMAIN_TRUST_ACCOUNT,
                             (LPBYTE *)&pUserList,
                             MAX_PREFERRED_LENGTH,
                             &nTrustCount,
                             &nTotalCount,
                             &hResumeHandle);

         if ( dwErr == ERROR_SUCCESS || dwErr == ERROR_MORE_DATA ) 
         {
            dwErr = ERROR_SUCCESS;
            for ( i = 0; i < nTrustCount; i++ ) 
            {
               Lop = wcsrchr( pUserList[ i ].usri0_name, L'$' );
               if ( Lop ) 
               {
                  *Lop = UNICODE_NULL;
               }
          
               for ( j = 0; j < m_vectTrustInfo.size(); j++ ) 
               {                                 
                  pTempTrustInfo = m_vectTrustInfo[j];                             
                  if ( _wcsicmp( pUserList[ i ].usri0_name, pTempTrustInfo->GetTrustedDomain() ) == 0 )
                  {   
                      pTempTrustInfo->SetTrustDirection( TRUST_DIRECTION_INBOUND | TRUST_DIRECTION_OUTBOUND );         
                      break;
                  }
               }

               // If it wasn't found, add it...
               if ( j == m_vectTrustInfo.size() ) 
               {
                  pTrustInfo = new CTrustInfo();
                  CHECK_NULL( pTrustInfo, CLEAN_RETURN );
                  pTrustInfo->SetTrustedDomain( pUserList[ i ].usri0_name  );
                  pTrustInfo->SetFlatName( pUserList[ i ].usri0_name  );
                  pTrustInfo->SetTrustType( TRUST_TYPE_DOWNLEVEL );
                  pTrustInfo->SetTrustDirection( TRUST_DIRECTION_INBOUND );

                  m_vectTrustInfo.push_back( pTrustInfo );
            
                  pTrustInfo = NULL;
               }

               if ( Lop ) 
               {
                  *Lop = L'$';
               }
            }

            NetApiBufferFree( pUserList );
            pUserList = NULL;
         }

      } while ( dwErr == ERROR_MORE_DATA );
   }

CLEAN_RETURN:
   if( pUserList )
      NetApiBufferFree( pUserList );
   if( pTrustDomainInfo )
      LsaFreeMemory( pTrustDomainInfo );

   if (ERROR_SUCCESS == dwErr)
   {
      SYSTEMTIME st;

      GetSystemTime(&st);
      SystemTimeToFileTime(&st, (LPFILETIME)&m_liLastEnumed);
   }

   return HRESULT_FROM_WIN32(dwErr);
}
#endif  // NT4_BUILD

//+----------------------------------------------------------------------------
//
//  Method:    CDomainInfo::FindTrust
//
//  Synopsis:  Find a trust by trusted Domain Name
//
//-----------------------------------------------------------------------------
CTrustInfo *
CDomainInfo::FindTrust(PCWSTR pwzTrust)
{
   TRACE(L"CDomainInfo::FindTrust\n");
   TRACE(L"\nlooking for domain %s\n", pwzTrust);
   ASSERT(IsEnumerated());

   ULONG i = 0;
   for( i = 0; i < m_vectTrustInfo.size(); ++i )
   {
      int nStrComp = CompareString(LOCALE_SYSTEM_DEFAULT,
                                   NORM_IGNORECASE,
                                   (m_vectTrustInfo[i])->GetTrustedDomain(), -1,
                                   pwzTrust, -1 );
      ASSERT( nStrComp );
      
      if( CSTR_EQUAL == nStrComp )
      {
         TRACE(L"Trust found!\n");
         return m_vectTrustInfo[i];
      }
   }

   return NULL;   // Not Found
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::GetTrustByIndex
//
//  Synopsis:   Get trust info by Index
//
//-----------------------------------------------------------------------------
CTrustInfo *
CDomainInfo::GetTrustByIndex(size_t index)
{
   ASSERT(IsEnumerated());

   if (index < Size())
   {
      return m_vectTrustInfo[index];
   }
   else
   {
      ASSERT(FALSE);
      return NULL;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainInfo::IsTrustListStale
//
//  Synopsis:  Checks to see if the last emumeration time is older than the
//             passed in criteria.
//
//  Returns:   TRUE if older.
//
//  Notes:     If the trusts haven't been enumerated (m_liLastEnumed == 0),
//             then the enumeration is defined to be stale.
//
//-----------------------------------------------------------------------------
BOOL
CDomainInfo::IsTrustListStale(LARGE_INTEGER liMaxAge)
{
   TRACE(L"CDomainInfo::IsTrustListStale(0x%08x), MaxAge = %d\n",
         this, liMaxAge.QuadPart / TRUSTMON_FILETIMES_PER_MINUTE);
   BOOL fStale = FALSE;
   LARGE_INTEGER liCurrentTime;
   SYSTEMTIME st;

   GetSystemTime(&st);
   SystemTimeToFileTime(&st, (LPFILETIME)&liCurrentTime);

   fStale = (m_liLastEnumed.QuadPart + liMaxAge.QuadPart) < liCurrentTime.QuadPart;

   return fStale;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::CreateAndSendInst
//
//  Synopsis:   Returns a copy of the current instance back to WMI
//
//-----------------------------------------------------------------------------
HRESULT
CDomainInfo::CreateAndSendInst(IWbemObjectSink * pResponseHandler)
{
   TRACE(L"CDomainInfo::CreateAndSendInst\n");
   HRESULT hr = WBEM_S_NO_ERROR;

   do
   {
      CComPtr<IWbemClassObject> ipNewInst;
      CComVariant var;

      //
      // Create a new instance of the WMI class object
      //
      hr = m_sipClassDefLocalDomain->SpawnInstance(0, &ipNewInst);

      BREAK_ON_FAIL;
      
      // Set the DNS property value
      var = GetDnsName();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_DNS_NAME, 0, &var, 0);
      TRACE(L"\tCreating instance %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the flat name property value
      var = GetFlatName();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_FLAT_NAME, 0, &var, 0);
      TRACE(L"\twith flat name %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the SID property value
      var = GetSid();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_SID, 0, &var, 0);
      TRACE(L"\twith SID %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the forest name property value
      var = GetForestName();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_TREE_NAME, 0, &var, 0);
      TRACE(L"\twith forest name %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the DC name property value
      var = GetDcName();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_DC_NAME, 0, &var, 0);
      TRACE(L"\ton DC %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      //
      // Send the object to the caller
      //
      // [In] param, no need to addref.

      IWbemClassObject * pNewInstance = ipNewInst;

      hr = pResponseHandler->Indicate(1, &pNewInstance);

      BREAK_ON_FAIL;

   } while(FALSE);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\domain.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       domain.h
//
//  Contents:   domain class definition
//
//  Classes:    CDomainInfo
//
//  History:    27-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef DOMAIN_H
#define DOMAIN_H

extern PCWSTR CSTR_PROP_LOCAL_DNS_NAME;
extern PCWSTR CSTR_PROP_LOCAL_FLAT_NAME;
extern PCWSTR CSTR_PROP_LOCAL_SID;
extern PCWSTR CSTR_PROP_LOCAL_TREE_NAME;
extern PCWSTR CSTR_PROP_LOCAL_DC_NAME;

#ifndef MAXDWORD
    #define MAXDWORD ((DWORD) -1)
#endif

class CTrustPrv; // forward declaration;

//+----------------------------------------------------------------------------
//
//  class CDomainInfo
//
//  Domain Information with list of all of the domain's Trusts
//
//-----------------------------------------------------------------------------
class CDomainInfo
{
public:
   CDomainInfo(void);
   ~CDomainInfo(void);

   friend class CTrustPrv;

   void   SetDnsName(PWSTR pszName) {m_strDomainDnsName = pszName;}
   PCWSTR GetDnsName(void) {return m_strDomainDnsName;}
   void   SetFlatName(PWSTR pszFlatName) {m_strDomainFlatName = pszFlatName;}
   PCWSTR GetFlatName(void) {return m_strDomainFlatName;}
   BOOL   SetSid(PSID pSid);
   PCWSTR GetSid(void) {return m_strSid;}
   void   SetForestName(PWSTR pszName) {m_strForestName = pszName;}
   PCWSTR GetForestName(void) {return m_strForestName;}
   void   SetDcName(PWSTR pszName) {m_strDcName = pszName;}
   PCWSTR GetDcName(void) {return m_strDcName;}

   HRESULT Init(IWbemClassObject * pClassDef); // Call once to initialize this object
   void    Reset(void);           // Reset the internal cache
   HRESULT EnumerateTrusts(void); // Enumerate Outgoing trusts for the local domain
   size_t  Size(void) const {return m_vectTrustInfo.size();}  // Get the number of trusts
   CTrustInfo * FindTrust(PCWSTR strTrust);  // Find trust's index
   CTrustInfo * GetTrustByIndex(size_t index); // Get trust info by Index
   BOOL    IsTrustListStale(LARGE_INTEGER liMaxAge);

protected:
   HRESULT CreateAndSendInst(IWbemObjectSink * pResponseHandler);

   // Object's Status
   BOOL IsEnumerated(void) const {return m_liLastEnumed.QuadPart != 0;}

private:

   //
   // Microsoft_LocalDomainInfo properties:
   //
   CString m_strDomainFlatName;
   CString m_strDomainDnsName;
   CString m_strForestName;
   CString m_strSid;
   CString m_strDcName;
   // TODO: FSMO holder info???

   // internal variables.
   //
   CComPtr<IWbemClassObject> m_sipClassDefLocalDomain;
   vector<CTrustInfo *> m_vectTrustInfo;   // array of trusts
   LARGE_INTEGER m_liLastEnumed;
};

class CSmartPolicyHandle
{
public:
   CSmartPolicyHandle(void) : m_hPolicy(NULL) {};
   ~CSmartPolicyHandle(void)
      {
         if( m_hPolicy )
         {
            LsaClose(m_hPolicy);
            m_hPolicy = NULL;
         }
      };

   LSA_HANDLE * operator&()
      {
         return &m_hPolicy;
      }

   operator LSA_HANDLE() const
      {
         return m_hPolicy;
      }

private:

	LSA_HANDLE m_hPolicy;
};

#endif //DOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\trust.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       trust.h
//
//  Contents:   Trust class definition
//
//  Classes:    CTrustInfo
//
//  History:    27-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef TRUSTINF_H
#define TRUSTINF_H

extern PCWSTR CSTR_PROP_TRUSTED_DOMAIN;
extern PCWSTR CSTR_PROP_FLAT_NAME;
extern PCWSTR CSTR_PROP_SID;
extern PCWSTR CSTR_PROP_TRUST_DIRECTION;
extern PCWSTR CSTR_PROP_TRUST_TYPE;
extern PCWSTR CSTR_PROP_TRUST_ATTRIBUTES;
extern PCWSTR CSTR_PROP_TRUST_STATUS;     // uint32
extern PCWSTR CSTR_PROP_TRUST_STATUS_STRING;
extern PCWSTR CSTR_PROP_TRUST_IS_OK;      // Boolean
extern PCWSTR CSTR_PROP_TRUSTED_DC_NAME;

enum VerifyStatus
{
   VerifyStatusNone = 0,
   VerifyStatusBroken,
   VerifyStatusTrustOK,
   VerifyStatusRediscover,
   VerifyStatusRetarget,
   VerifyStatusNotWindowsTrust,
   VerifyStatusNotOutboundTrust,
   VerifyStatusTrustNotChecked,
   VerifyStatusPwCheckNotSupported
};

class CDomainInfo; // forward declaration
enum TrustCheckLevel; // ditto

//+----------------------------------------------------------------------------
//
//  class CTrustInfo
//
//  Each instance contains information about one trust
//
//-----------------------------------------------------------------------------
class CTrustInfo
{
public:
   CTrustInfo();
   ~CTrustInfo() {};

friend class CDomainInfo;

   BOOL Verify(TrustCheckLevel CheckLevel);
   //Get List of All the DC for the Domain
   DWORD GetDCList(PCWSTR pszKnownServer, vector<LPWSTR> & dcList, LPBYTE * pbufptr);
   // Rediscover the Trust
   DWORD ForceRediscover(PCWSTR pstrDCName, CString * strDCName);

   //Funtion to Get/Set Private Members
   void   SetTrustedDomain(LPWSTR pszTrustedDomain) {m_strTrustedDomainName = (LPCWSTR)pszTrustedDomain;}
   PCWSTR GetTrustedDomain() {return m_strTrustedDomainName;}
   void   SetFlatName(LPWSTR pszFlatName) {m_strFlatName = pszFlatName;}
   PCWSTR GetFlatName() {return m_strFlatName;}
   BOOL   SetSid(PSID pSid);
   PCWSTR GetSid(void) {return m_strSid;}
   void   SetTrustDirection(ULONG ulDir) {m_ulTrustDirection = ulDir;}
   ULONG  GetTrustDirection(void) {return m_ulTrustDirection;}
   void   SetTrustType(ULONG ulTrustType) {m_ulTrustType = ulTrustType;}
   ULONG  GetTrustType(void) {return m_ulTrustType;}
   void   SetTrustAttributes(ULONG ulTrustAttributes) {m_ulTrustAttributes = ulTrustAttributes;}
   ULONG  GetTrustAttributes(void) {return m_ulTrustAttributes;}
   void   SetTrustedDCName(LPWSTR strTrustedDCName) {m_strTrustedDCName = strTrustedDCName;}
   PCWSTR GetTrustedDCName(void) {return m_strTrustedDCName;}
   void   SetTrustStatus(ULONG netStatus, VerifyStatus Status = VerifyStatusNone);
   ULONG  GetTrustStatus(void) {return m_trustStatus;}
   PCWSTR GetTrustStatusString(void) {return m_strTrustStatus;}
   ULONG  GetFlags(void) {return m_ulFlags;}
   void   SetFlags(ULONG ulFlags) {m_ulFlags = ulFlags;}
   bool   IsTrustOK(void) {return (ERROR_SUCCESS == m_trustStatus);}

   BOOL   IsVerificationStale(LARGE_INTEGER liMaxVerifyAge);
   BOOL   IsTrustOutbound(void) {return m_ulTrustDirection & TRUST_DIRECTION_OUTBOUND;}

protected:

   void   SetTrustDirectionFromFlags(ULONG ulFlags);
   void   SetLastVerifiedTime(void);

private:

   //Information about trust, for more info see Doc of TRUSTED_DOMAIN_INFORMATION_EX    
   CString       m_strTrustedDomainName; // name of the trusted domain
   CString       m_strFlatName;          // Netbios name of the trusted domain 
   CString       m_strSid;               // Sid of the trusted domian in string format
   ULONG         m_ulTrustDirection;     // indicate the direction of the trust
   ULONG         m_ulTrustType;          // Type of trust
   ULONG         m_ulTrustAttributes;    // Attributes of trust
   ULONG         m_ulFlags;              // DS_DOMAIN_TRUSTS Flags element

   CString       m_strTrustedDCName;     // Name of the DC with which trust is verified
   ULONG         m_trustStatus;          // Status of the trust; win32 error code
   CString       m_strTrustStatus;       // Status string.

   VerifyStatus  m_VerifyStatus;
   LARGE_INTEGER m_liLastVerified;
   BOOL          m_fPwVerifySupported;
};

#ifdef NT4_BUILD

DWORD ForceReplication(void);

#endif // NT4_BUILD

#endif //TRUSTINF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\columnmgrdlg.h ===
//-------------------------------------------------------------------------
// File: ColumnMgrDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK ColumnManagerDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CColumnItem
{
	public:
		CColumnItem(LPCTSTR pcszName, LPCTSTR pcszPropertyName, bool bSelected=false);
		CColumnItem(const CColumnItem& colItem);

		bool IsSelected() { return m_bSelected; }
		void SetSelected(bool bValue) { m_bSelected = bValue; }
		void SetSelected(BOOL bValue) { bValue? m_bSelected = true : m_bSelected = false; }
		void SetName(LPCTSTR pcszName) { m_bstrName = pcszName; }
		LPCTSTR GetName() { return m_bstrName; }
		void SetPropertyName(LPCTSTR pcszPropertyName) { m_bstrPropertyName = pcszPropertyName; }
		LPCTSTR GetPropertyName() { return m_bstrPropertyName; }
		CColumnItem& operator=(const CColumnItem& colItem);

	protected:
		CComBSTR m_bstrName;
		CComBSTR m_bstrPropertyName;
		bool m_bSelected;
};

class CColumnManagerDlg
{
	public:
		CColumnManagerDlg(CSimpleArray<CColumnItem*> *pArrayColumns);
		~CColumnManagerDlg();
		INT_PTR CALLBACK ColumnManagerDlgProc(HWND hDlg, UINT iMessage, WPAR